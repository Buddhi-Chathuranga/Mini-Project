-----------------------------------------------------------------------------
--
--  Logical unit: InventoryPart
--  Type:         Entity
--  Component:    INVENT
--
--  Template:     3.0
--  Built by:     IFS Developer Studio
--
--  NOTE! Do not edit!! This file is completely generated and will be
--        overwritten next time the corresponding model is saved.
-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
-------------------- API PACKAGE IMPLEMENTATION -----------------------------
-----------------------------------------------------------------------------

PROMPT Creating Inventory_Part_API implementation

-- [IFS COMPLETE BLOCK PACKAGEBODY Inventory_Part_API]
CREATE OR REPLACE PACKAGE BODY Inventory_Part_API IS

-----------------------------------------------------------------------------
-------------------- PRIVATE DECLARATIONS -----------------------------------
-----------------------------------------------------------------------------

TYPE Indicator_Rec IS RECORD
  (contract                       BOOLEAN := FALSE,
   part_no                        BOOLEAN := FALSE,
   accounting_group               BOOLEAN := FALSE,
   asset_class                    BOOLEAN := FALSE,
   country_of_origin              BOOLEAN := FALSE,
   hazard_code                    BOOLEAN := FALSE,
   note_id                        BOOLEAN := FALSE,
   part_product_code              BOOLEAN := FALSE,
   part_product_family            BOOLEAN := FALSE,
   part_status                    BOOLEAN := FALSE,
   planner_buyer                  BOOLEAN := FALSE,
   prime_commodity                BOOLEAN := FALSE,
   second_commodity               BOOLEAN := FALSE,
   unit_meas                      BOOLEAN := FALSE,
   catch_unit_meas                BOOLEAN := FALSE,
   description                    BOOLEAN := FALSE,
   abc_class                      BOOLEAN := FALSE,
   abc_class_locked_until         BOOLEAN := FALSE,
   count_variance                 BOOLEAN := FALSE,
   create_date                    BOOLEAN := FALSE,
   cycle_code                     BOOLEAN := FALSE,
   cycle_period                   BOOLEAN := FALSE,
   dim_quality                    BOOLEAN := FALSE,
   durability_day                 BOOLEAN := FALSE,
   expected_leadtime              BOOLEAN := FALSE,
   last_activity_date             BOOLEAN := FALSE,
   lead_time_code                 BOOLEAN := FALSE,
   manuf_leadtime                 BOOLEAN := FALSE,
   note_text                      BOOLEAN := FALSE,
   oe_alloc_assign_flag           BOOLEAN := FALSE,
   onhand_analysis_flag           BOOLEAN := FALSE,
   purch_leadtime                 BOOLEAN := FALSE,
   earliest_ultd_supply_date      BOOLEAN := FALSE,
   supersedes                     BOOLEAN := FALSE,
   supply_code                    BOOLEAN := FALSE,
   type_code                      BOOLEAN := FALSE,
   customs_stat_no                BOOLEAN := FALSE,
   type_designation               BOOLEAN := FALSE,
   zero_cost_flag                 BOOLEAN := FALSE,
   avail_activity_status          BOOLEAN := FALSE,
   eng_attribute                  BOOLEAN := FALSE,
   shortage_flag                  BOOLEAN := FALSE,
   forecast_consumption_flag      BOOLEAN := FALSE,
   stock_management               BOOLEAN := FALSE,
   intrastat_conv_factor          BOOLEAN := FALSE,
   part_cost_group_id             BOOLEAN := FALSE,
   dop_connection                 BOOLEAN := FALSE,
   std_name_id                    BOOLEAN := FALSE,
   inventory_valuation_method     BOOLEAN := FALSE,
   negative_on_hand               BOOLEAN := FALSE,
   technical_coordinator_id       BOOLEAN := FALSE,
   invoice_consideration          BOOLEAN := FALSE,
   actual_cost_activated          BOOLEAN := FALSE,
   max_actual_cost_update         BOOLEAN := FALSE,
   cust_warranty_id               BOOLEAN := FALSE,
   sup_warranty_id                BOOLEAN := FALSE,
   region_of_origin               BOOLEAN := FALSE,
   inventory_part_cost_level      BOOLEAN := FALSE,
   ext_service_cost_method        BOOLEAN := FALSE,
   supply_chain_part_group        BOOLEAN := FALSE,
   automatic_capability_check     BOOLEAN := FALSE,
   input_unit_meas_group_id       BOOLEAN := FALSE,
   dop_netting                    BOOLEAN := FALSE,
   co_reserve_onh_analys_flag     BOOLEAN := FALSE,
   qty_calc_rounding              BOOLEAN := FALSE,
   lifecycle_stage                BOOLEAN := FALSE,
   life_stage_locked_until        BOOLEAN := FALSE,
   frequency_class                BOOLEAN := FALSE,
   freq_class_locked_until        BOOLEAN := FALSE,
   first_stat_issue_date          BOOLEAN := FALSE,
   latest_stat_issue_date         BOOLEAN := FALSE,
   decline_date                   BOOLEAN := FALSE,
   expired_date                   BOOLEAN := FALSE,
   decline_issue_counter          BOOLEAN := FALSE,
   expired_issue_counter          BOOLEAN := FALSE,
   min_durab_days_co_deliv        BOOLEAN := FALSE,
   min_durab_days_planning        BOOLEAN := FALSE,
   storage_width_requirement      BOOLEAN := FALSE,
   storage_height_requirement     BOOLEAN := FALSE,
   storage_depth_requirement      BOOLEAN := FALSE,
   storage_volume_requirement     BOOLEAN := FALSE,
   storage_weight_requirement     BOOLEAN := FALSE,
   min_storage_temperature        BOOLEAN := FALSE,
   max_storage_temperature        BOOLEAN := FALSE,
   min_storage_humidity           BOOLEAN := FALSE,
   max_storage_humidity           BOOLEAN := FALSE,
   standard_putaway_qty           BOOLEAN := FALSE,
   putaway_zone_refill_option     BOOLEAN := FALSE,
   reset_config_std_cost          BOOLEAN := FALSE,
   mandatory_expiration_date      BOOLEAN := FALSE,
   excl_ship_pack_proposal        BOOLEAN := FALSE,
   statistical_code               BOOLEAN := FALSE,
   acquisition_origin             BOOLEAN := FALSE,
   acquisition_reason_id          BOOLEAN := FALSE);

TYPE Micro_Cache_Rec IS RECORD
  (accounting_group               INVENTORY_PART_TAB.accounting_group%TYPE,
   asset_class                    INVENTORY_PART_TAB.asset_class%TYPE,
   note_id                        INVENTORY_PART_TAB.note_id%TYPE,
   part_product_code              INVENTORY_PART_TAB.part_product_code%TYPE,
   part_product_family            INVENTORY_PART_TAB.part_product_family%TYPE,
   part_status                    INVENTORY_PART_TAB.part_status%TYPE,
   planner_buyer                  INVENTORY_PART_TAB.planner_buyer%TYPE,
   prime_commodity                INVENTORY_PART_TAB.prime_commodity%TYPE,
   second_commodity               INVENTORY_PART_TAB.second_commodity%TYPE,
   unit_meas                      INVENTORY_PART_TAB.unit_meas%TYPE,
   abc_class                      INVENTORY_PART_TAB.abc_class%TYPE,
   abc_class_locked_until         INVENTORY_PART_TAB.abc_class_locked_until%TYPE,
   durability_day                 INVENTORY_PART_TAB.durability_day%TYPE,
   expected_leadtime              INVENTORY_PART_TAB.expected_leadtime%TYPE,
   lead_time_code                 INVENTORY_PART_TAB.lead_time_code%TYPE,
   manuf_leadtime                 INVENTORY_PART_TAB.manuf_leadtime%TYPE,
   purch_leadtime                 INVENTORY_PART_TAB.purch_leadtime%TYPE,
   earliest_ultd_supply_date      INVENTORY_PART_TAB.earliest_ultd_supply_date%TYPE,
   type_code                      INVENTORY_PART_TAB.type_code%TYPE,
   stock_management               INVENTORY_PART_TAB.stock_management%TYPE,
   invoice_consideration          INVENTORY_PART_TAB.invoice_consideration%TYPE,
   qty_calc_rounding              INVENTORY_PART_TAB.qty_calc_rounding%TYPE,
   lifecycle_stage                INVENTORY_PART_TAB.lifecycle_stage%TYPE,
   life_stage_locked_until        INVENTORY_PART_TAB.life_stage_locked_until%TYPE,
   frequency_class                INVENTORY_PART_TAB.frequency_class%TYPE,
   freq_class_locked_until        INVENTORY_PART_TAB.freq_class_locked_until%TYPE,
   min_durab_days_co_deliv        INVENTORY_PART_TAB.min_durab_days_co_deliv%TYPE,
   min_durab_days_planning        INVENTORY_PART_TAB.min_durab_days_planning%TYPE,
   storage_width_requirement      INVENTORY_PART_TAB.storage_width_requirement%TYPE,
   storage_height_requirement     INVENTORY_PART_TAB.storage_height_requirement%TYPE,
   storage_depth_requirement      INVENTORY_PART_TAB.storage_depth_requirement%TYPE,
   storage_volume_requirement     INVENTORY_PART_TAB.storage_volume_requirement%TYPE,
   storage_weight_requirement     INVENTORY_PART_TAB.storage_weight_requirement%TYPE,
   min_storage_temperature        INVENTORY_PART_TAB.min_storage_temperature%TYPE,
   max_storage_temperature        INVENTORY_PART_TAB.max_storage_temperature%TYPE,
   min_storage_humidity           INVENTORY_PART_TAB.min_storage_humidity%TYPE,
   max_storage_humidity           INVENTORY_PART_TAB.max_storage_humidity%TYPE,
   standard_putaway_qty           INVENTORY_PART_TAB.standard_putaway_qty%TYPE,
   putaway_zone_refill_option     INVENTORY_PART_TAB.putaway_zone_refill_option%TYPE,
   reset_config_std_cost          INVENTORY_PART_TAB.reset_config_std_cost%TYPE,
   mandatory_expiration_date      INVENTORY_PART_TAB.mandatory_expiration_date%TYPE,
   excl_ship_pack_proposal        INVENTORY_PART_TAB.excl_ship_pack_proposal%TYPE,
   statistical_code               INVENTORY_PART_TAB.statistical_code%TYPE,
   acquisition_origin             INVENTORY_PART_TAB.acquisition_origin%TYPE,
   acquisition_reason_id          INVENTORY_PART_TAB.acquisition_reason_id%TYPE);

micro_cache_id_                    VARCHAR2(4000);

micro_cache_value_                 Micro_Cache_Rec;

micro_cache_time_                  NUMBER := 0;

micro_cache_user_                  VARCHAR2(30);

max_cached_element_life_           CONSTANT NUMBER := 100;

CURSOR Get_Mrp_Part_Cur(contract_ IN VARCHAR2) RETURN Get_Mrp_Part_Rec
IS
   SELECT part.part_no,
          part.planner_buyer,
          plan.planning_method,
          decode(part.lead_time_code, 'M', part.manuf_leadtime, part.purch_leadtime) lead_time,
          stat.supply_flag_db,
          part.lead_time_code,
          part.unit_meas,
          part.type_code
   FROM  inventory_part_tab part, inventory_part_planning_pub plan, inventory_part_status_par_pub stat
   WHERE plan.part_no = part.part_no
   AND   plan.contract = part.contract
   AND   part.part_status = stat.part_status
   AND   stat.demand_flag_db = 'Y'
   AND   plan.planning_method IN ('A','D','E','F','G','H','K','M','P')
   AND   plan.contract = contract_;

CURSOR Get_Reorder_Point_Parts(contract_ IN VARCHAR2) RETURN Reorder_Point_Parts
IS
   SELECT part.part_no,
          part.type_code,
          plan.planning_method,
          part.lead_time_code,
          part.manuf_leadtime,
          part.purch_leadtime
   FROM inventory_part_tab part, inventory_part_planning_tab plan
   WHERE  plan.part_no = part.part_no
   AND    plan.contract = part.contract
   AND    plan.planning_method IN ('B','C')
   AND    plan.contract = contract_;


-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION METHOD DECLARATIONS ---------------------
-----------------------------------------------------------------------------

PROCEDURE Invalidate_Cache___;

PROCEDURE Update_Cache___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 );

FUNCTION Key_Message___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2;

FUNCTION Formatted_Key___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2;

PROCEDURE Raise_Too_Many_Rows___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2,
   methodname_ IN VARCHAR2 );

PROCEDURE Raise_Record_Not_Exist___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 );

PROCEDURE Raise_Record_Exist___ (
   rec_ IN inventory_part_tab%ROWTYPE );

PROCEDURE Raise_Constraint_Violated___ (
   rec_ IN inventory_part_tab%ROWTYPE,
   constraint_ IN VARCHAR2 );

PROCEDURE Raise_Item_Format___ (
   name_ IN VARCHAR2,
   value_ IN VARCHAR2 );

PROCEDURE Raise_Record_Modified___ (
   rec_ IN inventory_part_tab%ROWTYPE );

PROCEDURE Raise_Record_Locked___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 );

PROCEDURE Raise_Record_Removed___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 );

FUNCTION Lock_By_Id___ (
   objid_      IN VARCHAR2,
   objversion_ IN VARCHAR2 ) RETURN inventory_part_tab%ROWTYPE;

FUNCTION Lock_By_Keys___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2) RETURN inventory_part_tab%ROWTYPE;

FUNCTION Lock_By_Keys_Nowait___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2) RETURN inventory_part_tab%ROWTYPE;

FUNCTION Get_Object_By_Id___ (
   objid_ IN VARCHAR2 ) RETURN inventory_part_tab%ROWTYPE;

FUNCTION Get_Object_By_Keys___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab%ROWTYPE;

FUNCTION Check_Exist___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN BOOLEAN;

PROCEDURE Get_Version_By_Id___ (
   objid_      IN     VARCHAR2,
   objversion_ IN OUT NOCOPY VARCHAR2 );

PROCEDURE Get_Id_Version_By_Keys___ (
   objid_      IN OUT NOCOPY VARCHAR2,
   objversion_ IN OUT NOCOPY VARCHAR2,
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 );

PROCEDURE Unpack___ (
   newrec_   IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   indrec_   IN OUT NOCOPY Indicator_Rec,
   attr_     IN OUT NOCOPY VARCHAR2 );

FUNCTION Pack___ (
   rec_ IN inventory_part_tab%ROWTYPE ) RETURN VARCHAR2;

FUNCTION Pack___ (
   rec_ IN inventory_part_tab%ROWTYPE,
   indrec_ IN Indicator_Rec ) RETURN VARCHAR2;

FUNCTION Pack_Table___ (
   rec_ IN inventory_part_tab%ROWTYPE ) RETURN VARCHAR2;

FUNCTION Public_To_Table___ (
   public_ IN Public_Rec ) RETURN inventory_part_tab%ROWTYPE;

FUNCTION Table_To_Public___ (
   rec_ IN inventory_part_tab%ROWTYPE ) RETURN Public_Rec;

PROCEDURE Reset_Indicator_Rec___ (
   indrec_ IN OUT NOCOPY Indicator_Rec );

FUNCTION Get_Indicator_Rec___ (
   rec_ IN inventory_part_tab%ROWTYPE ) RETURN Indicator_Rec;

FUNCTION Get_Indicator_Rec___ (
   oldrec_ IN inventory_part_tab%ROWTYPE,
   newrec_ IN inventory_part_tab%ROWTYPE ) RETURN Indicator_Rec;

PROCEDURE Check_Common___ (
   oldrec_ IN     inventory_part_tab%ROWTYPE,
   newrec_ IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   indrec_ IN OUT NOCOPY Indicator_Rec,
   attr_   IN OUT NOCOPY VARCHAR2 );

PROCEDURE Prepare_Insert___ (
   attr_ IN OUT NOCOPY VARCHAR2 );

PROCEDURE Check_Insert___ (
   newrec_ IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   indrec_ IN OUT NOCOPY Indicator_Rec,
   attr_   IN OUT NOCOPY VARCHAR2 );

PROCEDURE Insert___ (
   objid_                OUT    VARCHAR2,
   objversion_           OUT    VARCHAR2,
   newrec_               IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   attr_                 IN OUT NOCOPY VARCHAR2,
   create_purchase_part_ IN     VARCHAR2 DEFAULT 'TRUE',
   create_part_planning_ IN     VARCHAR2 DEFAULT 'TRUE');

PROCEDURE Prepare_New___ (
   newrec_ IN OUT NOCOPY inventory_part_tab%ROWTYPE );

PROCEDURE New___ (
   newrec_ IN OUT NOCOPY inventory_part_tab%ROWTYPE );

PROCEDURE Check_Update___ (
   oldrec_            IN     inventory_part_tab%ROWTYPE,
   newrec_            IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   indrec_            IN OUT NOCOPY Indicator_Rec,
   attr_              IN OUT NOCOPY VARCHAR2,
   updated_by_client_ IN     BOOLEAN DEFAULT TRUE  );

PROCEDURE Update___ (
   objid_             IN     VARCHAR2,
   oldrec_            IN     inventory_part_tab%ROWTYPE,
   newrec_            IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   attr_              IN OUT NOCOPY VARCHAR2,
   objversion_        IN OUT NOCOPY VARCHAR2,
   by_keys_           IN     BOOLEAN DEFAULT FALSE );

PROCEDURE Modify___ (
   newrec_              IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   lock_mode_wait_      IN     BOOLEAN DEFAULT TRUE,
   updated_by_client_   IN     BOOLEAN DEFAULT FALSE );

PROCEDURE Check_Delete___ (
   remrec_ IN inventory_part_tab%ROWTYPE );

PROCEDURE Delete___ (
   objid_  IN VARCHAR2,
   remrec_ IN inventory_part_tab%ROWTYPE );

PROCEDURE Delete___ (
   remrec_ IN inventory_part_tab%ROWTYPE );

PROCEDURE Remove___ (
   remrec_         IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   lock_mode_wait_ IN     BOOLEAN DEFAULT TRUE );

PROCEDURE Raise_Inv_Part_Not_Exist___ (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 );

PROCEDURE Raise_Part_Not_Exist___ (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 );

PROCEDURE Raise_Lot_Bat_Cost_Lvl_Error___ (
   newrec_   IN inventory_part_tab%ROWTYPE );

PROCEDURE Raise_Position_Part_Type_Error___;

PROCEDURE Raise_Input_Uom_Error___;

PROCEDURE Validate_Lead_Time_Code___ (
   lead_time_code_ OUT VARCHAR2,
   contract_       IN  VARCHAR2,
   part_no_        IN  VARCHAR2,
   type_code_      IN  VARCHAR2,
   old_type_code_  IN  VARCHAR2 );

PROCEDURE Check_Unit_Meas___ (
  contract_                      IN VARCHAR2,
  part_no_                       IN VARCHAR2,
  unit_meas_                     IN VARCHAR2,
  catch_unit_meas_               IN VARCHAR2,
  receipt_issue_serial_track_db_ IN VARCHAR2,
  catch_unit_enabled_            IN VARCHAR2 );

PROCEDURE Copy_Impl___ (
   new_contract_             IN VARCHAR2,
   new_part_no_              IN VARCHAR2,
   old_contract_             IN VARCHAR2,
   old_part_no_              IN VARCHAR2,
   attr_                     IN VARCHAR2,
   error_when_no_source_     IN VARCHAR2,
   error_when_existing_copy_ IN VARCHAR2,
   create_purchase_part_     IN VARCHAR2 );

PROCEDURE Convert_Storage_Req_Uom___(
   to_storage_width_requirement_    OUT NUMBER,
   to_storage_height_requirement_   OUT NUMBER,
   to_storage_depth_requirement_    OUT NUMBER,
   to_storage_volume_requirement_   OUT NUMBER,
   to_storage_weight_requirement_   OUT NUMBER,
   to_min_storage_temperature_      OUT NUMBER,
   to_max_storage_temperature_      OUT NUMBER,
   to_min_storage_humidity_         OUT NUMBER,
   to_max_storage_humidity_         OUT NUMBER,
   from_rec_                        IN  inventory_part_tab%ROWTYPE,
   to_contract_                     IN  VARCHAR2);

PROCEDURE Check_Value_Method_Combinat___ (
   newrec_                        IN inventory_part_tab%ROWTYPE,
   configurable_db_               IN VARCHAR2,
   condition_code_usage_db_       IN VARCHAR2,
   lot_tracking_code_db_          IN VARCHAR2,
   serial_tracking_code_db_       IN VARCHAR2,
   receipt_issue_serial_track_db_ IN VARCHAR2 );

PROCEDURE Check_Value_Method_Change___ (
   newrec_ IN inventory_part_tab%ROWTYPE,
   oldrec_ IN inventory_part_tab%ROWTYPE );

PROCEDURE Check_Open_Eso_Exist___ (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 );

PROCEDURE Overwrite_Record_With_Attr___ (
   lu_rec_ IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   attr_   IN     VARCHAR2 );

PROCEDURE Check_Invoice_Consideration___ (
   contract_                 IN VARCHAR2,
   company_                  IN VARCHAR2,
   invoice_consideration_db_ IN VARCHAR2 );

PROCEDURE Check_Auto_Capability_Check___ (
   newrec_ IN inventory_part_tab%ROWTYPE );

FUNCTION Cascade_Update_On_SO_Close___ (
   inventory_valuation_method_db_ IN VARCHAR2,
   inventory_part_cost_level_db_  IN VARCHAR2 ) RETURN BOOLEAN;

FUNCTION Get_Calc_Rounded_Qty___ (
   original_qty_      IN NUMBER,
   qty_calc_rounding_ IN NUMBER,
   action_            IN VARCHAR2,
   unit_meas_         IN VARCHAR2,
   ignore_unit_type_  IN BOOLEAN ) RETURN NUMBER;

PROCEDURE Check_Qty_Calc_Rounding___ (
   qty_calc_rounding_             IN NUMBER,
   receipt_issue_serial_track_db_ IN VARCHAR2,
   unit_meas_                     IN VARCHAR2 );

PROCEDURE Get_Our_Qty_At_Customer___ (
   qty_to_deliv_confirm_ OUT NUMBER,
   qty_in_consignment_   OUT NUMBER,
   qty_in_exchange_      OUT NUMBER,
   contract_             IN  VARCHAR2,
   part_no_              IN  VARCHAR2 );

PROCEDURE Handle_Description_Change___ (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 );

PROCEDURE Check_Lead_Time___ (
   lead_time_ IN NUMBER );

PROCEDURE Check_Expense_Part_Allowed___ (
   allow_not_consumed_ IN VARCHAR2);

PROCEDURE Check_Min_Durab_Days_Co_Del___ (
   durability_day_          IN NUMBER,
   min_durab_days_co_deliv_ IN NUMBER );

PROCEDURE Check_Min_Durab_Days_Plan___ (
   durability_day_          IN NUMBER,
   min_durab_days_planning_ IN NUMBER );

PROCEDURE Handle_Planning_Attr_Change___ (
   newrec_ IN inventory_part_tab%ROWTYPE,
   oldrec_ IN inventory_part_tab%ROWTYPE);

FUNCTION Get_Planning_Method___ (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2;

PROCEDURE Check_Supersedes___ (
   contract_     IN VARCHAR2,
   part_no_      IN VARCHAR2,
   supersedes_   IN VARCHAR2,
   part_status_  IN VARCHAR2 );

PROCEDURE Handle_Part_Status_Change___ (
   contract_        IN VARCHAR2,
   part_no_         IN VARCHAR2,
   old_part_status_ IN VARCHAR2,
   new_part_status_ IN VARCHAR2 );

FUNCTION Company_Owned_Stock_Exists___(
   contract_     IN VARCHAR2,
   part_no_      IN VARCHAR2 ) RETURN BOOLEAN;

FUNCTION Get_Updated_Control_Type___ (
   oldrec_            IN inventory_part_tab%ROWTYPE,
   newrec_            IN inventory_part_tab%ROWTYPE,
   check_only_active_ IN BOOLEAN,
   company_           IN VARCHAR2 ) RETURN VARCHAR2;

PROCEDURE Check_Standard_Putaway_Qty___(
   standard_putaway_qty_ IN NUMBER );

PROCEDURE Check_Intrastat_And_Customs___ (
   customs_stat_no_       IN VARCHAR2,
   intrastat_conv_factor_ IN NUMBER );

FUNCTION Get_Stop_Analysis_Date___ (
   contract_                    IN VARCHAR2,
   part_no_                     IN VARCHAR2,
   site_date_                   IN DATE,
   dist_calendar_id_            IN VARCHAR2,
   manuf_calendar_id_           IN VARCHAR2,
   detect_supplies_not_allowed_ IN BOOLEAN,
   use_expected_leadtime_       IN BOOLEAN,
   lead_time_code_db_           IN VARCHAR2 ) RETURN DATE;

PROCEDURE Get_Default_Site_And_Uom___ (
   contract_      OUT VARCHAR2,
   unit_meas_     OUT VARCHAR2,
   part_no_       IN  VARCHAR2,
   unit_category_ IN  VARCHAR2 DEFAULT 'INVENT' );

PROCEDURE Add_To_Purchase_Order___ (
   order_no_            OUT VARCHAR2,
   contract_            IN  VARCHAR2,
   part_no_             IN  VARCHAR2,
   inventory_unit_qty_  IN  NUMBER,
   inventory_unit_meas_ IN  VARCHAR2,
   wanted_receipt_date_ IN  DATE,
   authorize_code_      IN  VARCHAR2 );

PROCEDURE Mod_Earliest_Ultd_Sply_Date___ (
   date_modified_        OUT BOOLEAN, 
   contract_             IN  VARCHAR2,
   part_no_              IN  VARCHAR2,
   planned_receipt_date_ IN  DATE,
   backdate_allowed_db_  IN  VARCHAR2 );

-----------------------------------------------------------------------------
-------------------- BASE METHODS -------------------------------------------
-----------------------------------------------------------------------------

--@IgnoreMissingSysinit
FUNCTION Get_Key_By_Rowkey (
   rowkey_ IN VARCHAR2 ) RETURN inventory_part_tab%ROWTYPE
IS
   rec_ inventory_part_tab%ROWTYPE;
BEGIN
   IF (rowkey_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT contract, part_no
      INTO  rec_.contract, rec_.part_no
      FROM  inventory_part_tab
      WHERE rowkey = rowkey_;
   RETURN rec_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN rec_;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(rec_.contract, rec_.part_no, 'Get_Key_By_Rowkey');
END Get_Key_By_Rowkey;


--@IgnoreMissingSysinit
PROCEDURE Exist (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 )
IS
BEGIN
   IF (NOT Check_Exist___(contract_, part_no_)) THEN
      Raise_Record_Not_Exist___(contract_, part_no_);
   END IF;
END Exist;


--@IgnoreMissingSysinit
FUNCTION Exists (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   RETURN Check_Exist___(contract_, part_no_);
END Exists;


--@IgnoreMissingSysinit
PROCEDURE Rowkey_Exist (
   rowkey_ IN VARCHAR2 )
IS
   contract_ inventory_part_tab.contract%TYPE;
   part_no_ inventory_part_tab.part_no%TYPE;
BEGIN
   IF (rowkey_ IS NULL) THEN
      RAISE no_data_found;
   END IF;
   SELECT contract, part_no
   INTO  contract_, part_no_
   FROM  inventory_part_tab
   WHERE rowkey = rowkey_;
EXCEPTION
   WHEN no_data_found THEN
      Raise_Record_Not_Exist___(contract_, part_no_);
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Rowkey_Exist___');
END Rowkey_Exist;


--@IgnoreMissingSysinit
FUNCTION Get_Accounting_Group (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.accounting_group;
END Get_Accounting_Group;


--@IgnoreMissingSysinit
FUNCTION Get_Asset_Class (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.asset_class;
END Get_Asset_Class;


--@IgnoreMissingSysinit
FUNCTION Get_Country_Of_Origin (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.country_of_origin%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT country_of_origin
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Country_Of_Origin');
END Get_Country_Of_Origin;


--@IgnoreMissingSysinit
FUNCTION Get_Hazard_Code (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.hazard_code%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT hazard_code
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Hazard_Code');
END Get_Hazard_Code;


--@IgnoreMissingSysinit
FUNCTION Get_Note_Id (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.note_id;
END Get_Note_Id;


--@IgnoreMissingSysinit
FUNCTION Get_Part_Product_Code (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.part_product_code;
END Get_Part_Product_Code;


--@IgnoreMissingSysinit
FUNCTION Get_Part_Product_Family (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.part_product_family;
END Get_Part_Product_Family;


--@IgnoreMissingSysinit
FUNCTION Get_Part_Status (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.part_status;
END Get_Part_Status;


--@IgnoreMissingSysinit
FUNCTION Get_Planner_Buyer (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.planner_buyer;
END Get_Planner_Buyer;


--@IgnoreMissingSysinit
FUNCTION Get_Prime_Commodity (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.prime_commodity;
END Get_Prime_Commodity;


--@IgnoreMissingSysinit
FUNCTION Get_Second_Commodity (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.second_commodity;
END Get_Second_Commodity;


--@IgnoreMissingSysinit
FUNCTION Get_Unit_Meas (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.unit_meas;
END Get_Unit_Meas;


--@IgnoreMissingSysinit
FUNCTION Get_Catch_Unit_Meas (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.catch_unit_meas%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT catch_unit_meas
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Catch_Unit_Meas');
END Get_Catch_Unit_Meas;


--@IgnoreMissingSysinit
FUNCTION Get_Abc_Class (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.abc_class;
END Get_Abc_Class;


--@IgnoreMissingSysinit
FUNCTION Get_Abc_Class_Locked_Until (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN DATE
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.abc_class_locked_until;
END Get_Abc_Class_Locked_Until;


--@IgnoreMissingSysinit
FUNCTION Get_Count_Variance (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ inventory_part_tab.count_variance%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT count_variance
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Count_Variance');
END Get_Count_Variance;


--@IgnoreMissingSysinit
FUNCTION Get_Create_Date (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN DATE
IS
   temp_ inventory_part_tab.create_date%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT create_date
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Create_Date');
END Get_Create_Date;


--@IgnoreMissingSysinit
FUNCTION Get_Cycle_Code (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.cycle_code%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT cycle_code
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Inventory_Part_Count_Type_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Cycle_Code');
END Get_Cycle_Code;


--@IgnoreMissingSysinit
FUNCTION Get_Cycle_Code_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.cycle_code%TYPE
IS
   temp_ inventory_part_tab.cycle_code%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT cycle_code
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Cycle_Code_Db');
END Get_Cycle_Code_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Cycle_Period (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ inventory_part_tab.cycle_period%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT cycle_period
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Cycle_Period');
END Get_Cycle_Period;


--@IgnoreMissingSysinit
FUNCTION Get_Dim_Quality (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.dim_quality%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT dim_quality
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Dim_Quality');
END Get_Dim_Quality;


--@IgnoreMissingSysinit
FUNCTION Get_Durability_Day (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.durability_day;
END Get_Durability_Day;


--@IgnoreMissingSysinit
FUNCTION Get_Expected_Leadtime (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.expected_leadtime;
END Get_Expected_Leadtime;


--@IgnoreMissingSysinit
FUNCTION Get_Lead_Time_Code (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN Inv_Part_Lead_Time_Code_API.Decode(micro_cache_value_.lead_time_code);
END Get_Lead_Time_Code;


--@IgnoreMissingSysinit
FUNCTION Get_Lead_Time_Code_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.lead_time_code%TYPE
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.lead_time_code;
END Get_Lead_Time_Code_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Manuf_Leadtime (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.manuf_leadtime;
END Get_Manuf_Leadtime;


--@IgnoreMissingSysinit
FUNCTION Get_Oe_Alloc_Assign_Flag (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.oe_alloc_assign_flag%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT oe_alloc_assign_flag
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Cust_Ord_Reservation_Type_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Oe_Alloc_Assign_Flag');
END Get_Oe_Alloc_Assign_Flag;


--@IgnoreMissingSysinit
FUNCTION Get_Oe_Alloc_Assign_Flag_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.oe_alloc_assign_flag%TYPE
IS
   temp_ inventory_part_tab.oe_alloc_assign_flag%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT oe_alloc_assign_flag
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Oe_Alloc_Assign_Flag_Db');
END Get_Oe_Alloc_Assign_Flag_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Onhand_Analysis_Flag (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.onhand_analysis_flag%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT onhand_analysis_flag
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Inventory_Part_Onh_Analys_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Onhand_Analysis_Flag');
END Get_Onhand_Analysis_Flag;


--@IgnoreMissingSysinit
FUNCTION Get_Onhand_Analysis_Flag_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.onhand_analysis_flag%TYPE
IS
   temp_ inventory_part_tab.onhand_analysis_flag%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT onhand_analysis_flag
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Onhand_Analysis_Flag_Db');
END Get_Onhand_Analysis_Flag_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Purch_Leadtime (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.purch_leadtime;
END Get_Purch_Leadtime;


--@IgnoreMissingSysinit
FUNCTION Get_Earliest_Ultd_Supply_Date (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN DATE
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.earliest_ultd_supply_date;
END Get_Earliest_Ultd_Supply_Date;


--@IgnoreMissingSysinit
FUNCTION Get_Supersedes (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.supersedes%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT supersedes
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Supersedes');
END Get_Supersedes;


--@IgnoreMissingSysinit
FUNCTION Get_Supply_Code (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.supply_code%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT supply_code
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Material_Requis_Supply_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Supply_Code');
END Get_Supply_Code;


--@IgnoreMissingSysinit
FUNCTION Get_Supply_Code_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.supply_code%TYPE
IS
   temp_ inventory_part_tab.supply_code%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT supply_code
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Supply_Code_Db');
END Get_Supply_Code_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Type_Code (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN Inventory_Part_Type_API.Decode(micro_cache_value_.type_code);
END Get_Type_Code;


--@IgnoreMissingSysinit
FUNCTION Get_Type_Code_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.type_code%TYPE
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.type_code;
END Get_Type_Code_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Customs_Stat_No (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.customs_stat_no%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT customs_stat_no
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Customs_Stat_No');
END Get_Customs_Stat_No;


--@IgnoreMissingSysinit
FUNCTION Get_Type_Designation (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.type_designation%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT type_designation
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Type_Designation');
END Get_Type_Designation;


--@IgnoreMissingSysinit
FUNCTION Get_Zero_Cost_Flag (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.zero_cost_flag%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT zero_cost_flag
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Inventory_Part_Zero_Cost_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Zero_Cost_Flag');
END Get_Zero_Cost_Flag;


--@IgnoreMissingSysinit
FUNCTION Get_Zero_Cost_Flag_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.zero_cost_flag%TYPE
IS
   temp_ inventory_part_tab.zero_cost_flag%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT zero_cost_flag
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Zero_Cost_Flag_Db');
END Get_Zero_Cost_Flag_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Avail_Activity_Status (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.avail_activity_status%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT avail_activity_status
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Inventory_Part_Avail_Stat_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Avail_Activity_Status');
END Get_Avail_Activity_Status;


--@IgnoreMissingSysinit
FUNCTION Get_Avail_Activity_Status_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.avail_activity_status%TYPE
IS
   temp_ inventory_part_tab.avail_activity_status%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT avail_activity_status
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Avail_Activity_Status_Db');
END Get_Avail_Activity_Status_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Eng_Attribute (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.eng_attribute%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT eng_attribute
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Eng_Attribute');
END Get_Eng_Attribute;


--@IgnoreMissingSysinit
FUNCTION Get_Shortage_Flag (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.shortage_flag%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT shortage_flag
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Inventory_Part_Shortage_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Shortage_Flag');
END Get_Shortage_Flag;


--@IgnoreMissingSysinit
FUNCTION Get_Shortage_Flag_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.shortage_flag%TYPE
IS
   temp_ inventory_part_tab.shortage_flag%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT shortage_flag
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Shortage_Flag_Db');
END Get_Shortage_Flag_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Forecast_Consumption_Flag (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.forecast_consumption_flag%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT forecast_consumption_flag
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Inv_Part_Forecast_Consum_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Forecast_Consumption_Flag');
END Get_Forecast_Consumption_Flag;


--@IgnoreMissingSysinit
FUNCTION Get_Forecast_Consumption_Fl_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.forecast_consumption_flag%TYPE
IS
   temp_ inventory_part_tab.forecast_consumption_flag%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT forecast_consumption_flag
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Forecast_Consumption_Fl_Db');
END Get_Forecast_Consumption_Fl_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Stock_Management (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN Inventory_Part_Management_API.Decode(micro_cache_value_.stock_management);
END Get_Stock_Management;


--@IgnoreMissingSysinit
FUNCTION Get_Stock_Management_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.stock_management%TYPE
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.stock_management;
END Get_Stock_Management_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Intrastat_Conv_Factor (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ inventory_part_tab.intrastat_conv_factor%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT intrastat_conv_factor
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Intrastat_Conv_Factor');
END Get_Intrastat_Conv_Factor;


--@IgnoreMissingSysinit
FUNCTION Get_Part_Cost_Group_Id (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.part_cost_group_id%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT part_cost_group_id
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Part_Cost_Group_Id');
END Get_Part_Cost_Group_Id;


--@IgnoreMissingSysinit
FUNCTION Get_Dop_Connection (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.dop_connection%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT dop_connection
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Dop_Connection_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Dop_Connection');
END Get_Dop_Connection;


--@IgnoreMissingSysinit
FUNCTION Get_Dop_Connection_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.dop_connection%TYPE
IS
   temp_ inventory_part_tab.dop_connection%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT dop_connection
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Dop_Connection_Db');
END Get_Dop_Connection_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Inventory_Valuation_Method (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.inventory_valuation_method%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT inventory_valuation_method
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Inventory_Value_Method_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Inventory_Valuation_Method');
END Get_Inventory_Valuation_Method;


--@IgnoreMissingSysinit
FUNCTION Get_Inventory_Valuation_Met_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.inventory_valuation_method%TYPE
IS
   temp_ inventory_part_tab.inventory_valuation_method%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT inventory_valuation_method
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Inventory_Valuation_Met_Db');
END Get_Inventory_Valuation_Met_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Negative_On_Hand (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.negative_on_hand%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT negative_on_hand
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Negative_On_Hand_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Negative_On_Hand');
END Get_Negative_On_Hand;


--@IgnoreMissingSysinit
FUNCTION Get_Negative_On_Hand_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.negative_on_hand%TYPE
IS
   temp_ inventory_part_tab.negative_on_hand%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT negative_on_hand
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Negative_On_Hand_Db');
END Get_Negative_On_Hand_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Technical_Coordinator_Id (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.technical_coordinator_id%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT technical_coordinator_id
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Technical_Coordinator_Id');
END Get_Technical_Coordinator_Id;


--@IgnoreMissingSysinit
FUNCTION Get_Invoice_Consideration (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN Invoice_Consideration_API.Decode(micro_cache_value_.invoice_consideration);
END Get_Invoice_Consideration;


--@IgnoreMissingSysinit
FUNCTION Get_Invoice_Consideration_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.invoice_consideration%TYPE
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.invoice_consideration;
END Get_Invoice_Consideration_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Actual_Cost_Activated (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN DATE
IS
   temp_ inventory_part_tab.actual_cost_activated%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT actual_cost_activated
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Actual_Cost_Activated');
END Get_Actual_Cost_Activated;


--@IgnoreMissingSysinit
FUNCTION Get_Max_Actual_Cost_Update (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ inventory_part_tab.max_actual_cost_update%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT max_actual_cost_update
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Max_Actual_Cost_Update');
END Get_Max_Actual_Cost_Update;


--@IgnoreMissingSysinit
FUNCTION Get_Cust_Warranty_Id (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ inventory_part_tab.cust_warranty_id%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT cust_warranty_id
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Cust_Warranty_Id');
END Get_Cust_Warranty_Id;


--@IgnoreMissingSysinit
FUNCTION Get_Sup_Warranty_Id (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ inventory_part_tab.sup_warranty_id%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT sup_warranty_id
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Sup_Warranty_Id');
END Get_Sup_Warranty_Id;


--@IgnoreMissingSysinit
FUNCTION Get_Region_Of_Origin (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.region_of_origin%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT region_of_origin
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Region_Of_Origin');
END Get_Region_Of_Origin;


--@IgnoreMissingSysinit
FUNCTION Get_Inventory_Part_Cost_Level (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.inventory_part_cost_level%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT inventory_part_cost_level
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Inventory_Part_Cost_Level_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Inventory_Part_Cost_Level');
END Get_Inventory_Part_Cost_Level;


--@IgnoreMissingSysinit
FUNCTION Get_Inventory_Part_Cost_Lev_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.inventory_part_cost_level%TYPE
IS
   temp_ inventory_part_tab.inventory_part_cost_level%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT inventory_part_cost_level
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Inventory_Part_Cost_Lev_Db');
END Get_Inventory_Part_Cost_Lev_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Ext_Service_Cost_Method (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.ext_service_cost_method%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT ext_service_cost_method
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Ext_Service_Cost_Method_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Ext_Service_Cost_Method');
END Get_Ext_Service_Cost_Method;


--@IgnoreMissingSysinit
FUNCTION Get_Ext_Service_Cost_Method_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.ext_service_cost_method%TYPE
IS
   temp_ inventory_part_tab.ext_service_cost_method%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT ext_service_cost_method
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Ext_Service_Cost_Method_Db');
END Get_Ext_Service_Cost_Method_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Supply_Chain_Part_Group (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.supply_chain_part_group%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT supply_chain_part_group
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Supply_Chain_Part_Group');
END Get_Supply_Chain_Part_Group;


--@IgnoreMissingSysinit
FUNCTION Get_Automatic_Capability_Check (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.automatic_capability_check%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT automatic_capability_check
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Capability_Check_Allocate_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Automatic_Capability_Check');
END Get_Automatic_Capability_Check;


--@IgnoreMissingSysinit
FUNCTION Get_Automatic_Capability_Ch_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.automatic_capability_check%TYPE
IS
   temp_ inventory_part_tab.automatic_capability_check%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT automatic_capability_check
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Automatic_Capability_Ch_Db');
END Get_Automatic_Capability_Ch_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Input_Unit_Meas_Group_Id (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.input_unit_meas_group_id%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT input_unit_meas_group_id
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Input_Unit_Meas_Group_Id');
END Get_Input_Unit_Meas_Group_Id;


--@IgnoreMissingSysinit
FUNCTION Get_Dop_Netting (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.dop_netting%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT dop_netting
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Dop_Netting_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Dop_Netting');
END Get_Dop_Netting;


--@IgnoreMissingSysinit
FUNCTION Get_Dop_Netting_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.dop_netting%TYPE
IS
   temp_ inventory_part_tab.dop_netting%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT dop_netting
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Dop_Netting_Db');
END Get_Dop_Netting_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Co_Reserve_Onh_Analys_Flag (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.co_reserve_onh_analys_flag%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT co_reserve_onh_analys_flag
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN Inventory_Part_Onh_Analys_API.Decode(temp_);
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Co_Reserve_Onh_Analys_Flag');
END Get_Co_Reserve_Onh_Analys_Flag;


--@IgnoreMissingSysinit
FUNCTION Get_Co_Reserve_Onh_Analys_F_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.co_reserve_onh_analys_flag%TYPE
IS
   temp_ inventory_part_tab.co_reserve_onh_analys_flag%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT co_reserve_onh_analys_flag
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Co_Reserve_Onh_Analys_F_Db');
END Get_Co_Reserve_Onh_Analys_F_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Qty_Calc_Rounding (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.qty_calc_rounding;
END Get_Qty_Calc_Rounding;


--@IgnoreMissingSysinit
FUNCTION Get_Lifecycle_Stage (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN Inv_Part_Lifecycle_Stage_API.Decode(micro_cache_value_.lifecycle_stage);
END Get_Lifecycle_Stage;


--@IgnoreMissingSysinit
FUNCTION Get_Lifecycle_Stage_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.lifecycle_stage%TYPE
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.lifecycle_stage;
END Get_Lifecycle_Stage_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Life_Stage_Locked_Until (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN DATE
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.life_stage_locked_until;
END Get_Life_Stage_Locked_Until;


--@IgnoreMissingSysinit
FUNCTION Get_Frequency_Class (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN Inv_Part_Frequency_Class_API.Decode(micro_cache_value_.frequency_class);
END Get_Frequency_Class;


--@IgnoreMissingSysinit
FUNCTION Get_Frequency_Class_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.frequency_class%TYPE
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.frequency_class;
END Get_Frequency_Class_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Freq_Class_Locked_Until (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN DATE
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.freq_class_locked_until;
END Get_Freq_Class_Locked_Until;


--@IgnoreMissingSysinit
FUNCTION Get_First_Stat_Issue_Date (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN DATE
IS
   temp_ inventory_part_tab.first_stat_issue_date%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT first_stat_issue_date
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_First_Stat_Issue_Date');
END Get_First_Stat_Issue_Date;


--@IgnoreMissingSysinit
FUNCTION Get_Latest_Stat_Issue_Date (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN DATE
IS
   temp_ inventory_part_tab.latest_stat_issue_date%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT latest_stat_issue_date
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Latest_Stat_Issue_Date');
END Get_Latest_Stat_Issue_Date;


--@IgnoreMissingSysinit
FUNCTION Get_Decline_Date (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN DATE
IS
   temp_ inventory_part_tab.decline_date%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT decline_date
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Decline_Date');
END Get_Decline_Date;


--@IgnoreMissingSysinit
FUNCTION Get_Expired_Date (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN DATE
IS
   temp_ inventory_part_tab.expired_date%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT expired_date
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Expired_Date');
END Get_Expired_Date;


--@IgnoreMissingSysinit
FUNCTION Get_Decline_Issue_Counter (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ inventory_part_tab.decline_issue_counter%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT decline_issue_counter
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Decline_Issue_Counter');
END Get_Decline_Issue_Counter;


--@IgnoreMissingSysinit
FUNCTION Get_Expired_Issue_Counter (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ inventory_part_tab.expired_issue_counter%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT expired_issue_counter
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Expired_Issue_Counter');
END Get_Expired_Issue_Counter;


--@IgnoreMissingSysinit
FUNCTION Get_Min_Durab_Days_Co_Deliv (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.min_durab_days_co_deliv;
END Get_Min_Durab_Days_Co_Deliv;


--@IgnoreMissingSysinit
FUNCTION Get_Min_Durab_Days_Planning (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.min_durab_days_planning;
END Get_Min_Durab_Days_Planning;


--@IgnoreMissingSysinit
FUNCTION Get_Standard_Putaway_Qty (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.standard_putaway_qty;
END Get_Standard_Putaway_Qty;


--@IgnoreMissingSysinit
FUNCTION Get_Reset_Config_Std_Cost (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN Fnd_Boolean_API.Decode(micro_cache_value_.reset_config_std_cost);
END Get_Reset_Config_Std_Cost;


--@IgnoreMissingSysinit
FUNCTION Get_Reset_Config_Std_Cost_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.reset_config_std_cost%TYPE
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.reset_config_std_cost;
END Get_Reset_Config_Std_Cost_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Mandatory_Expiration_Date (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN Fnd_Boolean_API.Decode(micro_cache_value_.mandatory_expiration_date);
END Get_Mandatory_Expiration_Date;


--@IgnoreMissingSysinit
FUNCTION Get_Mandatory_Expiration_Da_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.mandatory_expiration_date%TYPE
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.mandatory_expiration_date;
END Get_Mandatory_Expiration_Da_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Excl_Ship_Pack_Proposal (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN Fnd_Boolean_API.Decode(micro_cache_value_.excl_ship_pack_proposal);
END Get_Excl_Ship_Pack_Proposal;


--@IgnoreMissingSysinit
FUNCTION Get_Excl_Ship_Pack_Proposal_Db (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab.excl_ship_pack_proposal%TYPE
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.excl_ship_pack_proposal;
END Get_Excl_Ship_Pack_Proposal_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Statistical_Code (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.statistical_code;
END Get_Statistical_Code;


--@IgnoreMissingSysinit
FUNCTION Get_Acquisition_Origin (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.acquisition_origin;
END Get_Acquisition_Origin;


--@IgnoreMissingSysinit
FUNCTION Get_Acquisition_Reason_Id (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   Update_Cache___(contract_, part_no_);
   RETURN micro_cache_value_.acquisition_reason_id;
END Get_Acquisition_Reason_Id;


--@IgnoreMissingSysinit
FUNCTION Get_By_Rowkey (
   rowkey_ IN VARCHAR2 ) RETURN Public_Rec
IS
   rowrec_ inventory_part_tab%ROWTYPE;
BEGIN
   rowrec_ := Get_Key_By_Rowkey(rowkey_);
   RETURN Get(rowrec_.contract, rowrec_.part_no);
END Get_By_Rowkey;


--@IgnoreMissingSysinit
FUNCTION Get (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN Public_Rec
IS
   temp_ Public_Rec;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT contract, part_no, rowid, rowversion, rowkey,
          accounting_group, 
          asset_class, 
          country_of_origin, 
          hazard_code, 
          note_id, 
          part_product_code, 
          part_product_family, 
          part_status, 
          planner_buyer, 
          prime_commodity, 
          second_commodity, 
          unit_meas, 
          catch_unit_meas, 
          abc_class, 
          abc_class_locked_until, 
          count_variance, 
          create_date, 
          cycle_code, 
          cycle_period, 
          dim_quality, 
          durability_day, 
          expected_leadtime, 
          lead_time_code, 
          manuf_leadtime, 
          oe_alloc_assign_flag, 
          onhand_analysis_flag, 
          purch_leadtime, 
          earliest_ultd_supply_date, 
          supersedes, 
          supply_code, 
          type_code, 
          customs_stat_no, 
          type_designation, 
          zero_cost_flag, 
          avail_activity_status, 
          eng_attribute, 
          shortage_flag, 
          forecast_consumption_flag, 
          stock_management, 
          intrastat_conv_factor, 
          part_cost_group_id, 
          dop_connection, 
          std_name_id, 
          inventory_valuation_method, 
          negative_on_hand, 
          technical_coordinator_id, 
          invoice_consideration, 
          actual_cost_activated, 
          max_actual_cost_update, 
          cust_warranty_id, 
          sup_warranty_id, 
          region_of_origin, 
          inventory_part_cost_level, 
          ext_service_cost_method, 
          supply_chain_part_group, 
          automatic_capability_check, 
          input_unit_meas_group_id, 
          dop_netting, 
          co_reserve_onh_analys_flag, 
          qty_calc_rounding, 
          lifecycle_stage, 
          life_stage_locked_until, 
          frequency_class, 
          freq_class_locked_until, 
          first_stat_issue_date, 
          latest_stat_issue_date, 
          decline_date, 
          expired_date, 
          decline_issue_counter, 
          expired_issue_counter, 
          min_durab_days_co_deliv, 
          min_durab_days_planning, 
          storage_width_requirement, 
          storage_height_requirement, 
          storage_depth_requirement, 
          storage_volume_requirement, 
          storage_weight_requirement, 
          min_storage_temperature, 
          max_storage_temperature, 
          min_storage_humidity, 
          max_storage_humidity, 
          standard_putaway_qty, 
          reset_config_std_cost, 
          mandatory_expiration_date, 
          excl_ship_pack_proposal, 
          statistical_code, 
          acquisition_origin, 
          acquisition_reason_id
      INTO  temp_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get');
END Get;


--@IgnoreMissingSysinit
FUNCTION Get_Objkey (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   rowkey_ inventory_part_tab.rowkey%TYPE;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN NULL;
   END IF;
   SELECT rowkey
      INTO  rowkey_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN rowkey_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Objkey');
END Get_Objkey;


--@IgnoreMissingSysinit
PROCEDURE Lock__ (
   info_       OUT VARCHAR2,
   objid_      IN  VARCHAR2,
   objversion_ IN  VARCHAR2 )
IS
   dummy_ inventory_part_tab%ROWTYPE;
BEGIN
   dummy_ := Lock_By_Id___(objid_, objversion_);
   info_ := Client_SYS.Get_All_Info;
END Lock__;


PROCEDURE Remove__ (
   info_       OUT VARCHAR2,
   objid_      IN  VARCHAR2,
   objversion_ IN  VARCHAR2,
   action_     IN  VARCHAR2 )
IS
   remrec_ inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Remove__');
   IF (action_ = 'CHECK') THEN
      remrec_ := Get_Object_By_Id___(objid_);
      Check_Delete___(remrec_);
   ELSIF (action_ = 'DO') THEN
      remrec_ := Lock_By_Id___(objid_, objversion_);
      Check_Delete___(remrec_);
      Delete___(objid_, remrec_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Remove__;


PROCEDURE Invalidate_Cache___
IS
   null_value_ Micro_Cache_Rec;
BEGIN
   micro_cache_id_ := NULL;
   micro_cache_value_ := null_value_;
   micro_cache_time_  := 0;
END Invalidate_Cache___;


PROCEDURE Update_Cache___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 )
IS
   req_id_     VARCHAR2(1000) := contract_||'^'||part_no_;
   null_value_ Micro_Cache_Rec;
   time_       NUMBER;
   expired_    BOOLEAN;
BEGIN
   time_    := Database_SYS.Get_Time_Offset;
   expired_ := ((time_ - micro_cache_time_) > max_cached_element_life_);
   IF (expired_ OR (micro_cache_user_ IS NULL) OR (micro_cache_user_ != Fnd_Session_API.Get_Fnd_User)) THEN
      Invalidate_Cache___;
      micro_cache_user_ := Fnd_Session_API.Get_Fnd_User;
   END IF;
   IF (expired_ OR (micro_cache_id_ IS NULL) OR (micro_cache_id_ != req_id_)) THEN
      SELECT
              accounting_group, 
              asset_class, 
              note_id, 
              part_product_code, 
              part_product_family, 
              part_status, 
              planner_buyer, 
              prime_commodity, 
              second_commodity, 
              unit_meas, 
              abc_class, 
              abc_class_locked_until, 
              durability_day, 
              expected_leadtime, 
              lead_time_code, 
              manuf_leadtime, 
              purch_leadtime, 
              earliest_ultd_supply_date, 
              type_code, 
              stock_management, 
              invoice_consideration, 
              qty_calc_rounding, 
              lifecycle_stage, 
              life_stage_locked_until, 
              frequency_class, 
              freq_class_locked_until, 
              min_durab_days_co_deliv, 
              min_durab_days_planning, 
              storage_width_requirement, 
              storage_height_requirement, 
              storage_depth_requirement, 
              storage_volume_requirement, 
              storage_weight_requirement, 
              min_storage_temperature, 
              max_storage_temperature, 
              min_storage_humidity, 
              max_storage_humidity, 
              standard_putaway_qty, 
              putaway_zone_refill_option, 
              reset_config_std_cost, 
              mandatory_expiration_date, 
              excl_ship_pack_proposal, 
              statistical_code, 
              acquisition_origin, 
              acquisition_reason_id
      INTO  micro_cache_value_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
      micro_cache_id_ := req_id_;
      micro_cache_time_ := time_;
   END IF;
EXCEPTION
   WHEN no_data_found THEN
      micro_cache_value_ := null_value_;
      micro_cache_id_    := NULL;
      micro_cache_time_  := time_;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Update_Cache___');
END Update_Cache___;


FUNCTION Key_Message___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   msg_ VARCHAR2(4000) := Message_SYS.Construct('ERROR_KEY');
BEGIN
   Message_SYS.Add_Attribute(msg_, 'CONTRACT', contract_);
   Message_SYS.Add_Attribute(msg_, 'PART_NO', part_no_);
   RETURN msg_;
END Key_Message___;


FUNCTION Formatted_Key___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   formatted_key_ VARCHAR2(4000) := Language_SYS.Translate_Item_Prompt_(lu_name_, 'CONTRACT', Fnd_Session_API.Get_Language) || ': ' || contract_ || ', ' ||
                                    Language_SYS.Translate_Item_Prompt_(lu_name_, 'PART_NO', Fnd_Session_API.Get_Language) || ': ' || part_no_;
BEGIN
   RETURN formatted_key_;
END Formatted_Key___;


PROCEDURE Raise_Too_Many_Rows___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2,
   methodname_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Set_Key_Values(Key_Message___(contract_, part_no_),
                            Formatted_Key___(contract_, part_no_));
   Error_SYS.Fnd_Too_Many_Rows(Inventory_Part_API.lu_name_, NULL, methodname_);
END Raise_Too_Many_Rows___;


PROCEDURE Raise_Record_Exist___ (
   rec_ IN inventory_part_tab%ROWTYPE )
IS
BEGIN
   Error_SYS.Set_Key_Values(Key_Message___(rec_.contract, rec_.part_no),
                            Formatted_Key___(rec_.contract, rec_.part_no));
   Error_SYS.Fnd_Record_Exist(Inventory_Part_API.lu_name_);
END Raise_Record_Exist___;


PROCEDURE Raise_Constraint_Violated___ (
   rec_ IN inventory_part_tab%ROWTYPE,
   constraint_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Fnd_Record_Exist(Inventory_Part_API.lu_name_);
END Raise_Constraint_Violated___;


PROCEDURE Raise_Item_Format___ (
   name_ IN VARCHAR2,
   value_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Fnd_Item_Format(Inventory_Part_API.lu_name_, name_, value_);
END Raise_Item_Format___;


PROCEDURE Raise_Record_Modified___ (
   rec_ IN inventory_part_tab%ROWTYPE )
IS
BEGIN
   Error_SYS.Set_Key_Values(Key_Message___(rec_.contract, rec_.part_no),
                            Formatted_Key___(rec_.contract, rec_.part_no));
   Error_SYS.Fnd_Record_Modified(Inventory_Part_API.lu_name_);
END Raise_Record_Modified___;


PROCEDURE Raise_Record_Locked___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Set_Key_Values(Key_Message___(contract_, part_no_),
                            Formatted_Key___(contract_, part_no_));
   Error_SYS.Fnd_Record_Locked(Inventory_Part_API.lu_name_);
END Raise_Record_Locked___;


PROCEDURE Raise_Record_Removed___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Set_Key_Values(Key_Message___(contract_, part_no_),
                            Formatted_Key___(contract_, part_no_));
   Error_SYS.Fnd_Record_Removed(Inventory_Part_API.lu_name_);
END Raise_Record_Removed___;


FUNCTION Lock_By_Id___ (
   objid_      IN VARCHAR2,
   objversion_ IN VARCHAR2 ) RETURN inventory_part_tab%ROWTYPE
IS
   row_locked  EXCEPTION;
   PRAGMA      EXCEPTION_INIT(row_locked, -0054);
   rec_        inventory_part_tab%ROWTYPE;
BEGIN
   SELECT *
      INTO  rec_
      FROM  inventory_part_tab
      WHERE rowid = objid_
      AND    to_char(rowversion,'YYYYMMDDHH24MISS') = objversion_
      FOR UPDATE NOWAIT;
   RETURN rec_;
EXCEPTION
   WHEN row_locked THEN
      Error_SYS.Fnd_Record_Locked(lu_name_);
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(NULL, NULL, 'Lock_By_Id___');
   WHEN no_data_found THEN
      BEGIN
         SELECT *
            INTO  rec_
            FROM  inventory_part_tab
            WHERE rowid = objid_;
         Raise_Record_Modified___(rec_);
      EXCEPTION
         WHEN no_data_found THEN
            Error_SYS.Fnd_Record_Removed(lu_name_);
         WHEN too_many_rows THEN
            Raise_Too_Many_Rows___(NULL, NULL, 'Lock_By_Id___');
      END;
END Lock_By_Id___;


FUNCTION Lock_By_Keys___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2) RETURN inventory_part_tab%ROWTYPE
IS
   rec_        inventory_part_tab%ROWTYPE;
BEGIN
   BEGIN
      SELECT *
         INTO  rec_
         FROM  inventory_part_tab
         WHERE contract = contract_
         AND   part_no = part_no_
         FOR UPDATE;
      RETURN rec_;
   EXCEPTION
      WHEN no_data_found THEN
         Raise_Record_Removed___(contract_, part_no_);
      WHEN too_many_rows THEN
         Raise_Too_Many_Rows___(contract_, part_no_, 'Lock_By_Keys___');
   END;
END Lock_By_Keys___;


FUNCTION Lock_By_Keys_Nowait___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2) RETURN inventory_part_tab%ROWTYPE
IS
   row_locked  EXCEPTION;
   PRAGMA      EXCEPTION_INIT(row_locked, -0054);
   rec_        inventory_part_tab%ROWTYPE;
BEGIN
   BEGIN
      SELECT *
         INTO  rec_
         FROM  inventory_part_tab
         WHERE contract = contract_
         AND   part_no = part_no_
         FOR UPDATE NOWAIT;
      RETURN rec_;
   EXCEPTION
      WHEN row_locked THEN
         Raise_Record_Locked___(contract_, part_no_);
      WHEN too_many_rows THEN
         Raise_Too_Many_Rows___(contract_, part_no_, 'Lock_By_Keys___');
      WHEN no_data_found THEN
         Raise_Record_Removed___(contract_, part_no_);
   END;
END Lock_By_Keys_Nowait___;


FUNCTION Get_Object_By_Id___ (
   objid_ IN VARCHAR2 ) RETURN inventory_part_tab%ROWTYPE
IS
   lu_rec_ inventory_part_tab%ROWTYPE;
BEGIN
   SELECT *
      INTO  lu_rec_
      FROM  inventory_part_tab
      WHERE rowid = objid_;
   RETURN lu_rec_;
EXCEPTION
   WHEN no_data_found THEN
      Error_SYS.Fnd_Record_Removed(lu_name_);
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(NULL, NULL, 'Get_Object_By_Id___');
END Get_Object_By_Id___;


--@IgnoreMissingSysinit
FUNCTION Get_Object_By_Keys___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN inventory_part_tab%ROWTYPE
IS
   lu_rec_ inventory_part_tab%ROWTYPE;
BEGIN
   SELECT *
      INTO  lu_rec_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN lu_rec_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN lu_rec_;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Object_By_Keys___');
END Get_Object_By_Keys___;


--@IgnoreMissingSysinit
FUNCTION Check_Exist___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_ NUMBER;
BEGIN
   IF (contract_ IS NULL OR part_no_ IS NULL) THEN
      RETURN FALSE;
   END IF;
   SELECT 1
      INTO  dummy_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
   RETURN TRUE;
EXCEPTION
   WHEN no_data_found THEN
      RETURN FALSE;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Check_Exist___');
END Check_Exist___;


PROCEDURE Get_Version_By_Id___ (
   objid_      IN     VARCHAR2,
   objversion_ IN OUT NOCOPY VARCHAR2 )
IS
BEGIN
   SELECT to_char(rowversion,'YYYYMMDDHH24MISS')
      INTO  objversion_
      FROM  inventory_part_tab
      WHERE rowid = objid_;
EXCEPTION
   WHEN no_data_found THEN
      objversion_ := NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(NULL, NULL, 'Get_Version_By_Id___');
END Get_Version_By_Id___;


PROCEDURE Get_Id_Version_By_Keys___ (
   objid_      IN OUT NOCOPY VARCHAR2,
   objversion_ IN OUT NOCOPY VARCHAR2,
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 )
IS
BEGIN
   SELECT rowid, to_char(rowversion,'YYYYMMDDHH24MISS')
      INTO  objid_, objversion_
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
EXCEPTION
   WHEN no_data_found THEN
      objid_      := NULL;
      objversion_ := NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Id_Version_By_Keys___');
END Get_Id_Version_By_Keys___;


PROCEDURE Unpack___ (
   newrec_   IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   indrec_   IN OUT NOCOPY Indicator_Rec,
   attr_     IN OUT NOCOPY VARCHAR2 )
IS
   ptr_   NUMBER;
   name_  VARCHAR2(30);
   value_ VARCHAR2(32000);
   msg_   VARCHAR2(32000);
BEGIN
   Reset_Indicator_Rec___(indrec_);
   Client_SYS.Clear_Attr(msg_);
   ptr_ := NULL;
   WHILE (Client_SYS.Get_Next_From_Attr(attr_, ptr_, name_, value_)) LOOP
      CASE name_
      WHEN ('CONTRACT') THEN
         newrec_.contract := value_;
         indrec_.contract := TRUE;
      WHEN ('PART_NO') THEN
         newrec_.part_no := value_;
         indrec_.part_no := TRUE;
      WHEN ('ACCOUNTING_GROUP') THEN
         newrec_.accounting_group := value_;
         indrec_.accounting_group := TRUE;
      WHEN ('ASSET_CLASS') THEN
         newrec_.asset_class := value_;
         indrec_.asset_class := TRUE;
      WHEN ('COUNTRY_OF_ORIGIN') THEN
         newrec_.country_of_origin := value_;
         indrec_.country_of_origin := TRUE;
      WHEN ('HAZARD_CODE') THEN
         newrec_.hazard_code := value_;
         indrec_.hazard_code := TRUE;
      WHEN ('NOTE_ID') THEN
         newrec_.note_id := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.note_id := TRUE;
      WHEN ('PART_PRODUCT_CODE') THEN
         newrec_.part_product_code := value_;
         indrec_.part_product_code := TRUE;
      WHEN ('PART_PRODUCT_FAMILY') THEN
         newrec_.part_product_family := value_;
         indrec_.part_product_family := TRUE;
      WHEN ('PART_STATUS') THEN
         newrec_.part_status := value_;
         indrec_.part_status := TRUE;
      WHEN ('PLANNER_BUYER') THEN
         newrec_.planner_buyer := value_;
         indrec_.planner_buyer := TRUE;
      WHEN ('PRIME_COMMODITY') THEN
         newrec_.prime_commodity := value_;
         indrec_.prime_commodity := TRUE;
      WHEN ('SECOND_COMMODITY') THEN
         newrec_.second_commodity := value_;
         indrec_.second_commodity := TRUE;
      WHEN ('UNIT_MEAS') THEN
         newrec_.unit_meas := value_;
         indrec_.unit_meas := TRUE;
      WHEN ('CATCH_UNIT_MEAS') THEN
         newrec_.catch_unit_meas := value_;
         indrec_.catch_unit_meas := TRUE;
      WHEN ('DESCRIPTION') THEN
         newrec_.description := value_;
         indrec_.description := TRUE;
      WHEN ('ABC_CLASS') THEN
         newrec_.abc_class := value_;
         indrec_.abc_class := TRUE;
      WHEN ('ABC_CLASS_LOCKED_UNTIL') THEN
         newrec_.abc_class_locked_until := Client_SYS.Attr_Value_To_Date(value_);
         indrec_.abc_class_locked_until := TRUE;
      WHEN ('COUNT_VARIANCE') THEN
         newrec_.count_variance := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.count_variance := TRUE;
      WHEN ('CREATE_DATE') THEN
         newrec_.create_date := Client_SYS.Attr_Value_To_Date(value_);
         indrec_.create_date := TRUE;
      WHEN ('CYCLE_CODE') THEN
         newrec_.cycle_code := Inventory_Part_Count_Type_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.cycle_code IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.cycle_code := TRUE;
      WHEN ('CYCLE_CODE_DB') THEN
         newrec_.cycle_code := value_;
         indrec_.cycle_code := TRUE;
      WHEN ('CYCLE_PERIOD') THEN
         newrec_.cycle_period := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.cycle_period := TRUE;
      WHEN ('DIM_QUALITY') THEN
         newrec_.dim_quality := value_;
         indrec_.dim_quality := TRUE;
      WHEN ('DURABILITY_DAY') THEN
         newrec_.durability_day := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.durability_day := TRUE;
      WHEN ('EXPECTED_LEADTIME') THEN
         newrec_.expected_leadtime := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.expected_leadtime := TRUE;
      WHEN ('LAST_ACTIVITY_DATE') THEN
         newrec_.last_activity_date := Client_SYS.Attr_Value_To_Date(value_);
         indrec_.last_activity_date := TRUE;
      WHEN ('LEAD_TIME_CODE') THEN
         newrec_.lead_time_code := Inv_Part_Lead_Time_Code_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.lead_time_code IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.lead_time_code := TRUE;
      WHEN ('LEAD_TIME_CODE_DB') THEN
         newrec_.lead_time_code := value_;
         indrec_.lead_time_code := TRUE;
      WHEN ('MANUF_LEADTIME') THEN
         newrec_.manuf_leadtime := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.manuf_leadtime := TRUE;
      WHEN ('NOTE_TEXT') THEN
         newrec_.note_text := value_;
         indrec_.note_text := TRUE;
      WHEN ('OE_ALLOC_ASSIGN_FLAG') THEN
         newrec_.oe_alloc_assign_flag := Cust_Ord_Reservation_Type_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.oe_alloc_assign_flag IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.oe_alloc_assign_flag := TRUE;
      WHEN ('OE_ALLOC_ASSIGN_FLAG_DB') THEN
         newrec_.oe_alloc_assign_flag := value_;
         indrec_.oe_alloc_assign_flag := TRUE;
      WHEN ('ONHAND_ANALYSIS_FLAG') THEN
         newrec_.onhand_analysis_flag := Inventory_Part_Onh_Analys_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.onhand_analysis_flag IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.onhand_analysis_flag := TRUE;
      WHEN ('ONHAND_ANALYSIS_FLAG_DB') THEN
         newrec_.onhand_analysis_flag := value_;
         indrec_.onhand_analysis_flag := TRUE;
      WHEN ('PURCH_LEADTIME') THEN
         newrec_.purch_leadtime := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.purch_leadtime := TRUE;
      WHEN ('EARLIEST_ULTD_SUPPLY_DATE') THEN
         newrec_.earliest_ultd_supply_date := Client_SYS.Attr_Value_To_Date(value_);
         indrec_.earliest_ultd_supply_date := TRUE;
      WHEN ('SUPERSEDES') THEN
         newrec_.supersedes := value_;
         indrec_.supersedes := TRUE;
      WHEN ('SUPPLY_CODE') THEN
         newrec_.supply_code := Material_Requis_Supply_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.supply_code IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.supply_code := TRUE;
      WHEN ('SUPPLY_CODE_DB') THEN
         newrec_.supply_code := value_;
         indrec_.supply_code := TRUE;
      WHEN ('TYPE_CODE') THEN
         newrec_.type_code := Inventory_Part_Type_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.type_code IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.type_code := TRUE;
      WHEN ('TYPE_CODE_DB') THEN
         newrec_.type_code := value_;
         indrec_.type_code := TRUE;
      WHEN ('CUSTOMS_STAT_NO') THEN
         newrec_.customs_stat_no := value_;
         indrec_.customs_stat_no := TRUE;
      WHEN ('TYPE_DESIGNATION') THEN
         newrec_.type_designation := value_;
         indrec_.type_designation := TRUE;
      WHEN ('ZERO_COST_FLAG') THEN
         newrec_.zero_cost_flag := Inventory_Part_Zero_Cost_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.zero_cost_flag IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.zero_cost_flag := TRUE;
      WHEN ('ZERO_COST_FLAG_DB') THEN
         newrec_.zero_cost_flag := value_;
         indrec_.zero_cost_flag := TRUE;
      WHEN ('AVAIL_ACTIVITY_STATUS') THEN
         newrec_.avail_activity_status := Inventory_Part_Avail_Stat_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.avail_activity_status IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.avail_activity_status := TRUE;
      WHEN ('AVAIL_ACTIVITY_STATUS_DB') THEN
         newrec_.avail_activity_status := value_;
         indrec_.avail_activity_status := TRUE;
      WHEN ('ENG_ATTRIBUTE') THEN
         newrec_.eng_attribute := value_;
         indrec_.eng_attribute := TRUE;
      WHEN ('SHORTAGE_FLAG') THEN
         newrec_.shortage_flag := Inventory_Part_Shortage_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.shortage_flag IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.shortage_flag := TRUE;
      WHEN ('SHORTAGE_FLAG_DB') THEN
         newrec_.shortage_flag := value_;
         indrec_.shortage_flag := TRUE;
      WHEN ('FORECAST_CONSUMPTION_FLAG') THEN
         newrec_.forecast_consumption_flag := Inv_Part_Forecast_Consum_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.forecast_consumption_flag IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.forecast_consumption_flag := TRUE;
      WHEN ('FORECAST_CONSUMPTION_FLAG_DB') THEN
         newrec_.forecast_consumption_flag := value_;
         indrec_.forecast_consumption_flag := TRUE;
      WHEN ('STOCK_MANAGEMENT') THEN
         newrec_.stock_management := Inventory_Part_Management_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.stock_management IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.stock_management := TRUE;
      WHEN ('STOCK_MANAGEMENT_DB') THEN
         newrec_.stock_management := value_;
         indrec_.stock_management := TRUE;
      WHEN ('INTRASTAT_CONV_FACTOR') THEN
         newrec_.intrastat_conv_factor := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.intrastat_conv_factor := TRUE;
      WHEN ('PART_COST_GROUP_ID') THEN
         newrec_.part_cost_group_id := value_;
         indrec_.part_cost_group_id := TRUE;
      WHEN ('DOP_CONNECTION') THEN
         newrec_.dop_connection := Dop_Connection_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.dop_connection IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.dop_connection := TRUE;
      WHEN ('DOP_CONNECTION_DB') THEN
         newrec_.dop_connection := value_;
         indrec_.dop_connection := TRUE;
      WHEN ('STD_NAME_ID') THEN
         newrec_.std_name_id := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.std_name_id := TRUE;
      WHEN ('INVENTORY_VALUATION_METHOD') THEN
         newrec_.inventory_valuation_method := Inventory_Value_Method_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.inventory_valuation_method IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.inventory_valuation_method := TRUE;
      WHEN ('INVENTORY_VALUATION_METHOD_DB') THEN
         newrec_.inventory_valuation_method := value_;
         indrec_.inventory_valuation_method := TRUE;
      WHEN ('NEGATIVE_ON_HAND') THEN
         newrec_.negative_on_hand := Negative_On_Hand_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.negative_on_hand IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.negative_on_hand := TRUE;
      WHEN ('NEGATIVE_ON_HAND_DB') THEN
         newrec_.negative_on_hand := value_;
         indrec_.negative_on_hand := TRUE;
      WHEN ('TECHNICAL_COORDINATOR_ID') THEN
         newrec_.technical_coordinator_id := value_;
         indrec_.technical_coordinator_id := TRUE;
      WHEN ('INVOICE_CONSIDERATION') THEN
         newrec_.invoice_consideration := Invoice_Consideration_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.invoice_consideration IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.invoice_consideration := TRUE;
      WHEN ('INVOICE_CONSIDERATION_DB') THEN
         newrec_.invoice_consideration := value_;
         indrec_.invoice_consideration := TRUE;
      WHEN ('ACTUAL_COST_ACTIVATED') THEN
         newrec_.actual_cost_activated := Client_SYS.Attr_Value_To_Date(value_);
         indrec_.actual_cost_activated := TRUE;
      WHEN ('MAX_ACTUAL_COST_UPDATE') THEN
         newrec_.max_actual_cost_update := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.max_actual_cost_update := TRUE;
      WHEN ('CUST_WARRANTY_ID') THEN
         newrec_.cust_warranty_id := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.cust_warranty_id := TRUE;
      WHEN ('SUP_WARRANTY_ID') THEN
         newrec_.sup_warranty_id := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.sup_warranty_id := TRUE;
      WHEN ('REGION_OF_ORIGIN') THEN
         newrec_.region_of_origin := value_;
         indrec_.region_of_origin := TRUE;
      WHEN ('INVENTORY_PART_COST_LEVEL') THEN
         newrec_.inventory_part_cost_level := Inventory_Part_Cost_Level_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.inventory_part_cost_level IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.inventory_part_cost_level := TRUE;
      WHEN ('INVENTORY_PART_COST_LEVEL_DB') THEN
         newrec_.inventory_part_cost_level := value_;
         indrec_.inventory_part_cost_level := TRUE;
      WHEN ('EXT_SERVICE_COST_METHOD') THEN
         newrec_.ext_service_cost_method := Ext_Service_Cost_Method_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.ext_service_cost_method IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.ext_service_cost_method := TRUE;
      WHEN ('EXT_SERVICE_COST_METHOD_DB') THEN
         newrec_.ext_service_cost_method := value_;
         indrec_.ext_service_cost_method := TRUE;
      WHEN ('SUPPLY_CHAIN_PART_GROUP') THEN
         newrec_.supply_chain_part_group := value_;
         indrec_.supply_chain_part_group := TRUE;
      WHEN ('AUTOMATIC_CAPABILITY_CHECK') THEN
         newrec_.automatic_capability_check := Capability_Check_Allocate_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.automatic_capability_check IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.automatic_capability_check := TRUE;
      WHEN ('AUTOMATIC_CAPABILITY_CHECK_DB') THEN
         newrec_.automatic_capability_check := value_;
         indrec_.automatic_capability_check := TRUE;
      WHEN ('INPUT_UNIT_MEAS_GROUP_ID') THEN
         newrec_.input_unit_meas_group_id := value_;
         indrec_.input_unit_meas_group_id := TRUE;
      WHEN ('DOP_NETTING') THEN
         newrec_.dop_netting := Dop_Netting_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.dop_netting IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.dop_netting := TRUE;
      WHEN ('DOP_NETTING_DB') THEN
         newrec_.dop_netting := value_;
         indrec_.dop_netting := TRUE;
      WHEN ('CO_RESERVE_ONH_ANALYS_FLAG') THEN
         newrec_.co_reserve_onh_analys_flag := Inventory_Part_Onh_Analys_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.co_reserve_onh_analys_flag IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.co_reserve_onh_analys_flag := TRUE;
      WHEN ('CO_RESERVE_ONH_ANALYS_FLAG_DB') THEN
         newrec_.co_reserve_onh_analys_flag := value_;
         indrec_.co_reserve_onh_analys_flag := TRUE;
      WHEN ('QTY_CALC_ROUNDING') THEN
         newrec_.qty_calc_rounding := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.qty_calc_rounding := TRUE;
      WHEN ('LIFECYCLE_STAGE') THEN
         newrec_.lifecycle_stage := Inv_Part_Lifecycle_Stage_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.lifecycle_stage IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.lifecycle_stage := TRUE;
      WHEN ('LIFECYCLE_STAGE_DB') THEN
         newrec_.lifecycle_stage := value_;
         indrec_.lifecycle_stage := TRUE;
      WHEN ('LIFE_STAGE_LOCKED_UNTIL') THEN
         newrec_.life_stage_locked_until := Client_SYS.Attr_Value_To_Date(value_);
         indrec_.life_stage_locked_until := TRUE;
      WHEN ('FREQUENCY_CLASS') THEN
         newrec_.frequency_class := Inv_Part_Frequency_Class_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.frequency_class IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.frequency_class := TRUE;
      WHEN ('FREQUENCY_CLASS_DB') THEN
         newrec_.frequency_class := value_;
         indrec_.frequency_class := TRUE;
      WHEN ('FREQ_CLASS_LOCKED_UNTIL') THEN
         newrec_.freq_class_locked_until := Client_SYS.Attr_Value_To_Date(value_);
         indrec_.freq_class_locked_until := TRUE;
      WHEN ('FIRST_STAT_ISSUE_DATE') THEN
         newrec_.first_stat_issue_date := Client_SYS.Attr_Value_To_Date(value_);
         indrec_.first_stat_issue_date := TRUE;
      WHEN ('LATEST_STAT_ISSUE_DATE') THEN
         newrec_.latest_stat_issue_date := Client_SYS.Attr_Value_To_Date(value_);
         indrec_.latest_stat_issue_date := TRUE;
      WHEN ('DECLINE_DATE') THEN
         newrec_.decline_date := Client_SYS.Attr_Value_To_Date(value_);
         indrec_.decline_date := TRUE;
      WHEN ('EXPIRED_DATE') THEN
         newrec_.expired_date := Client_SYS.Attr_Value_To_Date(value_);
         indrec_.expired_date := TRUE;
      WHEN ('DECLINE_ISSUE_COUNTER') THEN
         newrec_.decline_issue_counter := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.decline_issue_counter := TRUE;
      WHEN ('EXPIRED_ISSUE_COUNTER') THEN
         newrec_.expired_issue_counter := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.expired_issue_counter := TRUE;
      WHEN ('MIN_DURAB_DAYS_CO_DELIV') THEN
         newrec_.min_durab_days_co_deliv := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.min_durab_days_co_deliv := TRUE;
      WHEN ('MIN_DURAB_DAYS_PLANNING') THEN
         newrec_.min_durab_days_planning := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.min_durab_days_planning := TRUE;
      WHEN ('STORAGE_WIDTH_REQUIREMENT') THEN
         newrec_.storage_width_requirement := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.storage_width_requirement := TRUE;
      WHEN ('STORAGE_HEIGHT_REQUIREMENT') THEN
         newrec_.storage_height_requirement := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.storage_height_requirement := TRUE;
      WHEN ('STORAGE_DEPTH_REQUIREMENT') THEN
         newrec_.storage_depth_requirement := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.storage_depth_requirement := TRUE;
      WHEN ('STORAGE_VOLUME_REQUIREMENT') THEN
         newrec_.storage_volume_requirement := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.storage_volume_requirement := TRUE;
      WHEN ('STORAGE_WEIGHT_REQUIREMENT') THEN
         newrec_.storage_weight_requirement := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.storage_weight_requirement := TRUE;
      WHEN ('MIN_STORAGE_TEMPERATURE') THEN
         newrec_.min_storage_temperature := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.min_storage_temperature := TRUE;
      WHEN ('MAX_STORAGE_TEMPERATURE') THEN
         newrec_.max_storage_temperature := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.max_storage_temperature := TRUE;
      WHEN ('MIN_STORAGE_HUMIDITY') THEN
         newrec_.min_storage_humidity := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.min_storage_humidity := TRUE;
      WHEN ('MAX_STORAGE_HUMIDITY') THEN
         newrec_.max_storage_humidity := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.max_storage_humidity := TRUE;
      WHEN ('STANDARD_PUTAWAY_QTY') THEN
         newrec_.standard_putaway_qty := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.standard_putaway_qty := TRUE;
      WHEN ('PUTAWAY_ZONE_REFILL_OPTION') THEN
         newrec_.putaway_zone_refill_option := Putaway_Zone_Refill_Option_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.putaway_zone_refill_option IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.putaway_zone_refill_option := TRUE;
      WHEN ('PUTAWAY_ZONE_REFILL_OPTION_DB') THEN
         newrec_.putaway_zone_refill_option := value_;
         indrec_.putaway_zone_refill_option := TRUE;
      WHEN ('RESET_CONFIG_STD_COST') THEN
         newrec_.reset_config_std_cost := Fnd_Boolean_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.reset_config_std_cost IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.reset_config_std_cost := TRUE;
      WHEN ('RESET_CONFIG_STD_COST_DB') THEN
         newrec_.reset_config_std_cost := value_;
         indrec_.reset_config_std_cost := TRUE;
      WHEN ('MANDATORY_EXPIRATION_DATE') THEN
         newrec_.mandatory_expiration_date := Fnd_Boolean_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.mandatory_expiration_date IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.mandatory_expiration_date := TRUE;
      WHEN ('MANDATORY_EXPIRATION_DATE_DB') THEN
         newrec_.mandatory_expiration_date := value_;
         indrec_.mandatory_expiration_date := TRUE;
      WHEN ('EXCL_SHIP_PACK_PROPOSAL') THEN
         newrec_.excl_ship_pack_proposal := Fnd_Boolean_API.Encode(value_);
         IF (value_ IS NOT NULL AND newrec_.excl_ship_pack_proposal IS NULL) THEN
            RAISE value_error;
         END IF;
         indrec_.excl_ship_pack_proposal := TRUE;
      WHEN ('EXCL_SHIP_PACK_PROPOSAL_DB') THEN
         newrec_.excl_ship_pack_proposal := value_;
         indrec_.excl_ship_pack_proposal := TRUE;
      WHEN ('STATISTICAL_CODE') THEN
         newrec_.statistical_code := value_;
         indrec_.statistical_code := TRUE;
      WHEN ('ACQUISITION_ORIGIN') THEN
         newrec_.acquisition_origin := Client_SYS.Attr_Value_To_Number(value_);
         indrec_.acquisition_origin := TRUE;
      WHEN ('ACQUISITION_REASON_ID') THEN
         newrec_.acquisition_reason_id := value_;
         indrec_.acquisition_reason_id := TRUE;
      ELSE
         Client_SYS.Add_To_Attr(name_, value_, msg_);
      END CASE;
   END LOOP;
   attr_ := msg_;
EXCEPTION
   WHEN value_error THEN
      Raise_Item_Format___(name_, value_);
END Unpack___;


FUNCTION Pack___ (
   rec_ IN inventory_part_tab%ROWTYPE ) RETURN VARCHAR2
IS
   attr_ VARCHAR2(32000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   IF (rec_.contract IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('CONTRACT', rec_.contract, attr_);
   END IF;
   IF (rec_.part_no IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('PART_NO', rec_.part_no, attr_);
   END IF;
   IF (rec_.accounting_group IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('ACCOUNTING_GROUP', rec_.accounting_group, attr_);
   END IF;
   IF (rec_.asset_class IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('ASSET_CLASS', rec_.asset_class, attr_);
   END IF;
   IF (rec_.country_of_origin IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('COUNTRY_OF_ORIGIN', rec_.country_of_origin, attr_);
   END IF;
   IF (rec_.hazard_code IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('HAZARD_CODE', rec_.hazard_code, attr_);
   END IF;
   IF (rec_.note_id IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('NOTE_ID', rec_.note_id, attr_);
   END IF;
   IF (rec_.part_product_code IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('PART_PRODUCT_CODE', rec_.part_product_code, attr_);
   END IF;
   IF (rec_.part_product_family IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('PART_PRODUCT_FAMILY', rec_.part_product_family, attr_);
   END IF;
   IF (rec_.part_status IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('PART_STATUS', rec_.part_status, attr_);
   END IF;
   IF (rec_.planner_buyer IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('PLANNER_BUYER', rec_.planner_buyer, attr_);
   END IF;
   IF (rec_.prime_commodity IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('PRIME_COMMODITY', rec_.prime_commodity, attr_);
   END IF;
   IF (rec_.second_commodity IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('SECOND_COMMODITY', rec_.second_commodity, attr_);
   END IF;
   IF (rec_.unit_meas IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('UNIT_MEAS', rec_.unit_meas, attr_);
   END IF;
   IF (rec_.catch_unit_meas IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('CATCH_UNIT_MEAS', rec_.catch_unit_meas, attr_);
   END IF;
   IF (rec_.description IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('DESCRIPTION', rec_.description, attr_);
   END IF;
   IF (rec_.abc_class IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('ABC_CLASS', rec_.abc_class, attr_);
   END IF;
   IF (rec_.abc_class_locked_until IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('ABC_CLASS_LOCKED_UNTIL', rec_.abc_class_locked_until, attr_);
   END IF;
   IF (rec_.count_variance IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('COUNT_VARIANCE', rec_.count_variance, attr_);
   END IF;
   IF (rec_.create_date IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('CREATE_DATE', rec_.create_date, attr_);
   END IF;
   IF (rec_.cycle_code IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('CYCLE_CODE', Inventory_Part_Count_Type_API.Decode(rec_.cycle_code), attr_);
      Client_SYS.Add_To_Attr('CYCLE_CODE_DB', rec_.cycle_code, attr_);
   END IF;
   IF (rec_.cycle_period IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('CYCLE_PERIOD', rec_.cycle_period, attr_);
   END IF;
   IF (rec_.dim_quality IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('DIM_QUALITY', rec_.dim_quality, attr_);
   END IF;
   IF (rec_.durability_day IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('DURABILITY_DAY', rec_.durability_day, attr_);
   END IF;
   IF (rec_.expected_leadtime IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('EXPECTED_LEADTIME', rec_.expected_leadtime, attr_);
   END IF;
   IF (rec_.last_activity_date IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('LAST_ACTIVITY_DATE', rec_.last_activity_date, attr_);
   END IF;
   IF (rec_.lead_time_code IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('LEAD_TIME_CODE', Inv_Part_Lead_Time_Code_API.Decode(rec_.lead_time_code), attr_);
      Client_SYS.Add_To_Attr('LEAD_TIME_CODE_DB', rec_.lead_time_code, attr_);
   END IF;
   IF (rec_.manuf_leadtime IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('MANUF_LEADTIME', rec_.manuf_leadtime, attr_);
   END IF;
   IF (rec_.note_text IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('NOTE_TEXT', rec_.note_text, attr_);
   END IF;
   IF (rec_.oe_alloc_assign_flag IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('OE_ALLOC_ASSIGN_FLAG', Cust_Ord_Reservation_Type_API.Decode(rec_.oe_alloc_assign_flag), attr_);
      Client_SYS.Add_To_Attr('OE_ALLOC_ASSIGN_FLAG_DB', rec_.oe_alloc_assign_flag, attr_);
   END IF;
   IF (rec_.onhand_analysis_flag IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('ONHAND_ANALYSIS_FLAG', Inventory_Part_Onh_Analys_API.Decode(rec_.onhand_analysis_flag), attr_);
      Client_SYS.Add_To_Attr('ONHAND_ANALYSIS_FLAG_DB', rec_.onhand_analysis_flag, attr_);
   END IF;
   IF (rec_.purch_leadtime IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('PURCH_LEADTIME', rec_.purch_leadtime, attr_);
   END IF;
   IF (rec_.earliest_ultd_supply_date IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('EARLIEST_ULTD_SUPPLY_DATE', rec_.earliest_ultd_supply_date, attr_);
   END IF;
   IF (rec_.supersedes IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('SUPERSEDES', rec_.supersedes, attr_);
   END IF;
   IF (rec_.supply_code IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('SUPPLY_CODE', Material_Requis_Supply_API.Decode(rec_.supply_code), attr_);
      Client_SYS.Add_To_Attr('SUPPLY_CODE_DB', rec_.supply_code, attr_);
   END IF;
   IF (rec_.type_code IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('TYPE_CODE', Inventory_Part_Type_API.Decode(rec_.type_code), attr_);
      Client_SYS.Add_To_Attr('TYPE_CODE_DB', rec_.type_code, attr_);
   END IF;
   IF (rec_.customs_stat_no IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('CUSTOMS_STAT_NO', rec_.customs_stat_no, attr_);
   END IF;
   IF (rec_.type_designation IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('TYPE_DESIGNATION', rec_.type_designation, attr_);
   END IF;
   IF (rec_.zero_cost_flag IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('ZERO_COST_FLAG', Inventory_Part_Zero_Cost_API.Decode(rec_.zero_cost_flag), attr_);
      Client_SYS.Add_To_Attr('ZERO_COST_FLAG_DB', rec_.zero_cost_flag, attr_);
   END IF;
   IF (rec_.avail_activity_status IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('AVAIL_ACTIVITY_STATUS', Inventory_Part_Avail_Stat_API.Decode(rec_.avail_activity_status), attr_);
      Client_SYS.Add_To_Attr('AVAIL_ACTIVITY_STATUS_DB', rec_.avail_activity_status, attr_);
   END IF;
   IF (rec_.eng_attribute IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('ENG_ATTRIBUTE', rec_.eng_attribute, attr_);
   END IF;
   IF (rec_.shortage_flag IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('SHORTAGE_FLAG', Inventory_Part_Shortage_API.Decode(rec_.shortage_flag), attr_);
      Client_SYS.Add_To_Attr('SHORTAGE_FLAG_DB', rec_.shortage_flag, attr_);
   END IF;
   IF (rec_.forecast_consumption_flag IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('FORECAST_CONSUMPTION_FLAG', Inv_Part_Forecast_Consum_API.Decode(rec_.forecast_consumption_flag), attr_);
      Client_SYS.Add_To_Attr('FORECAST_CONSUMPTION_FLAG_DB', rec_.forecast_consumption_flag, attr_);
   END IF;
   IF (rec_.stock_management IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('STOCK_MANAGEMENT', Inventory_Part_Management_API.Decode(rec_.stock_management), attr_);
      Client_SYS.Add_To_Attr('STOCK_MANAGEMENT_DB', rec_.stock_management, attr_);
   END IF;
   IF (rec_.intrastat_conv_factor IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('INTRASTAT_CONV_FACTOR', rec_.intrastat_conv_factor, attr_);
   END IF;
   IF (rec_.part_cost_group_id IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('PART_COST_GROUP_ID', rec_.part_cost_group_id, attr_);
   END IF;
   IF (rec_.dop_connection IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('DOP_CONNECTION', Dop_Connection_API.Decode(rec_.dop_connection), attr_);
      Client_SYS.Add_To_Attr('DOP_CONNECTION_DB', rec_.dop_connection, attr_);
   END IF;
   IF (rec_.std_name_id IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('STD_NAME_ID', rec_.std_name_id, attr_);
   END IF;
   IF (rec_.inventory_valuation_method IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('INVENTORY_VALUATION_METHOD', Inventory_Value_Method_API.Decode(rec_.inventory_valuation_method), attr_);
      Client_SYS.Add_To_Attr('INVENTORY_VALUATION_METHOD_DB', rec_.inventory_valuation_method, attr_);
   END IF;
   IF (rec_.negative_on_hand IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('NEGATIVE_ON_HAND', Negative_On_Hand_API.Decode(rec_.negative_on_hand), attr_);
      Client_SYS.Add_To_Attr('NEGATIVE_ON_HAND_DB', rec_.negative_on_hand, attr_);
   END IF;
   IF (rec_.technical_coordinator_id IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('TECHNICAL_COORDINATOR_ID', rec_.technical_coordinator_id, attr_);
   END IF;
   IF (rec_.invoice_consideration IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('INVOICE_CONSIDERATION', Invoice_Consideration_API.Decode(rec_.invoice_consideration), attr_);
      Client_SYS.Add_To_Attr('INVOICE_CONSIDERATION_DB', rec_.invoice_consideration, attr_);
   END IF;
   IF (rec_.actual_cost_activated IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('ACTUAL_COST_ACTIVATED', rec_.actual_cost_activated, attr_);
   END IF;
   IF (rec_.max_actual_cost_update IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('MAX_ACTUAL_COST_UPDATE', rec_.max_actual_cost_update, attr_);
   END IF;
   IF (rec_.cust_warranty_id IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('CUST_WARRANTY_ID', rec_.cust_warranty_id, attr_);
   END IF;
   IF (rec_.sup_warranty_id IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('SUP_WARRANTY_ID', rec_.sup_warranty_id, attr_);
   END IF;
   IF (rec_.region_of_origin IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('REGION_OF_ORIGIN', rec_.region_of_origin, attr_);
   END IF;
   IF (rec_.inventory_part_cost_level IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('INVENTORY_PART_COST_LEVEL', Inventory_Part_Cost_Level_API.Decode(rec_.inventory_part_cost_level), attr_);
      Client_SYS.Add_To_Attr('INVENTORY_PART_COST_LEVEL_DB', rec_.inventory_part_cost_level, attr_);
   END IF;
   IF (rec_.ext_service_cost_method IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('EXT_SERVICE_COST_METHOD', Ext_Service_Cost_Method_API.Decode(rec_.ext_service_cost_method), attr_);
      Client_SYS.Add_To_Attr('EXT_SERVICE_COST_METHOD_DB', rec_.ext_service_cost_method, attr_);
   END IF;
   IF (rec_.supply_chain_part_group IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('SUPPLY_CHAIN_PART_GROUP', rec_.supply_chain_part_group, attr_);
   END IF;
   IF (rec_.automatic_capability_check IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('AUTOMATIC_CAPABILITY_CHECK', Capability_Check_Allocate_API.Decode(rec_.automatic_capability_check), attr_);
      Client_SYS.Add_To_Attr('AUTOMATIC_CAPABILITY_CHECK_DB', rec_.automatic_capability_check, attr_);
   END IF;
   IF (rec_.input_unit_meas_group_id IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('INPUT_UNIT_MEAS_GROUP_ID', rec_.input_unit_meas_group_id, attr_);
   END IF;
   IF (rec_.dop_netting IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('DOP_NETTING', Dop_Netting_API.Decode(rec_.dop_netting), attr_);
      Client_SYS.Add_To_Attr('DOP_NETTING_DB', rec_.dop_netting, attr_);
   END IF;
   IF (rec_.co_reserve_onh_analys_flag IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('CO_RESERVE_ONH_ANALYS_FLAG', Inventory_Part_Onh_Analys_API.Decode(rec_.co_reserve_onh_analys_flag), attr_);
      Client_SYS.Add_To_Attr('CO_RESERVE_ONH_ANALYS_FLAG_DB', rec_.co_reserve_onh_analys_flag, attr_);
   END IF;
   IF (rec_.qty_calc_rounding IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('QTY_CALC_ROUNDING', rec_.qty_calc_rounding, attr_);
   END IF;
   IF (rec_.lifecycle_stage IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('LIFECYCLE_STAGE', Inv_Part_Lifecycle_Stage_API.Decode(rec_.lifecycle_stage), attr_);
      Client_SYS.Add_To_Attr('LIFECYCLE_STAGE_DB', rec_.lifecycle_stage, attr_);
   END IF;
   IF (rec_.life_stage_locked_until IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('LIFE_STAGE_LOCKED_UNTIL', rec_.life_stage_locked_until, attr_);
   END IF;
   IF (rec_.frequency_class IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('FREQUENCY_CLASS', Inv_Part_Frequency_Class_API.Decode(rec_.frequency_class), attr_);
      Client_SYS.Add_To_Attr('FREQUENCY_CLASS_DB', rec_.frequency_class, attr_);
   END IF;
   IF (rec_.freq_class_locked_until IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('FREQ_CLASS_LOCKED_UNTIL', rec_.freq_class_locked_until, attr_);
   END IF;
   IF (rec_.first_stat_issue_date IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('FIRST_STAT_ISSUE_DATE', rec_.first_stat_issue_date, attr_);
   END IF;
   IF (rec_.latest_stat_issue_date IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('LATEST_STAT_ISSUE_DATE', rec_.latest_stat_issue_date, attr_);
   END IF;
   IF (rec_.decline_date IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('DECLINE_DATE', rec_.decline_date, attr_);
   END IF;
   IF (rec_.expired_date IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('EXPIRED_DATE', rec_.expired_date, attr_);
   END IF;
   IF (rec_.decline_issue_counter IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('DECLINE_ISSUE_COUNTER', rec_.decline_issue_counter, attr_);
   END IF;
   IF (rec_.expired_issue_counter IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('EXPIRED_ISSUE_COUNTER', rec_.expired_issue_counter, attr_);
   END IF;
   IF (rec_.min_durab_days_co_deliv IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('MIN_DURAB_DAYS_CO_DELIV', rec_.min_durab_days_co_deliv, attr_);
   END IF;
   IF (rec_.min_durab_days_planning IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('MIN_DURAB_DAYS_PLANNING', rec_.min_durab_days_planning, attr_);
   END IF;
   IF (rec_.storage_width_requirement IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('STORAGE_WIDTH_REQUIREMENT', rec_.storage_width_requirement, attr_);
   END IF;
   IF (rec_.storage_height_requirement IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('STORAGE_HEIGHT_REQUIREMENT', rec_.storage_height_requirement, attr_);
   END IF;
   IF (rec_.storage_depth_requirement IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('STORAGE_DEPTH_REQUIREMENT', rec_.storage_depth_requirement, attr_);
   END IF;
   IF (rec_.storage_volume_requirement IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('STORAGE_VOLUME_REQUIREMENT', rec_.storage_volume_requirement, attr_);
   END IF;
   IF (rec_.storage_weight_requirement IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('STORAGE_WEIGHT_REQUIREMENT', rec_.storage_weight_requirement, attr_);
   END IF;
   IF (rec_.min_storage_temperature IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('MIN_STORAGE_TEMPERATURE', rec_.min_storage_temperature, attr_);
   END IF;
   IF (rec_.max_storage_temperature IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('MAX_STORAGE_TEMPERATURE', rec_.max_storage_temperature, attr_);
   END IF;
   IF (rec_.min_storage_humidity IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('MIN_STORAGE_HUMIDITY', rec_.min_storage_humidity, attr_);
   END IF;
   IF (rec_.max_storage_humidity IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('MAX_STORAGE_HUMIDITY', rec_.max_storage_humidity, attr_);
   END IF;
   IF (rec_.standard_putaway_qty IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('STANDARD_PUTAWAY_QTY', rec_.standard_putaway_qty, attr_);
   END IF;
   IF (rec_.putaway_zone_refill_option IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('PUTAWAY_ZONE_REFILL_OPTION', Putaway_Zone_Refill_Option_API.Decode(rec_.putaway_zone_refill_option), attr_);
      Client_SYS.Add_To_Attr('PUTAWAY_ZONE_REFILL_OPTION_DB', rec_.putaway_zone_refill_option, attr_);
   END IF;
   IF (rec_.reset_config_std_cost IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('RESET_CONFIG_STD_COST', Fnd_Boolean_API.Decode(rec_.reset_config_std_cost), attr_);
      Client_SYS.Add_To_Attr('RESET_CONFIG_STD_COST_DB', rec_.reset_config_std_cost, attr_);
   END IF;
   IF (rec_.mandatory_expiration_date IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('MANDATORY_EXPIRATION_DATE', Fnd_Boolean_API.Decode(rec_.mandatory_expiration_date), attr_);
      Client_SYS.Add_To_Attr('MANDATORY_EXPIRATION_DATE_DB', rec_.mandatory_expiration_date, attr_);
   END IF;
   IF (rec_.excl_ship_pack_proposal IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('EXCL_SHIP_PACK_PROPOSAL', Fnd_Boolean_API.Decode(rec_.excl_ship_pack_proposal), attr_);
      Client_SYS.Add_To_Attr('EXCL_SHIP_PACK_PROPOSAL_DB', rec_.excl_ship_pack_proposal, attr_);
   END IF;
   IF (rec_.statistical_code IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('STATISTICAL_CODE', rec_.statistical_code, attr_);
   END IF;
   IF (rec_.acquisition_origin IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('ACQUISITION_ORIGIN', rec_.acquisition_origin, attr_);
   END IF;
   IF (rec_.acquisition_reason_id IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('ACQUISITION_REASON_ID', rec_.acquisition_reason_id, attr_);
   END IF;
   RETURN attr_;
END Pack___;


FUNCTION Pack___ (
   rec_ IN inventory_part_tab%ROWTYPE,
   indrec_ IN Indicator_Rec ) RETURN VARCHAR2
IS
   attr_ VARCHAR2(32000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   IF (indrec_.contract) THEN
      Client_SYS.Add_To_Attr('CONTRACT', rec_.contract, attr_);
   END IF;
   IF (indrec_.part_no) THEN
      Client_SYS.Add_To_Attr('PART_NO', rec_.part_no, attr_);
   END IF;
   IF (indrec_.accounting_group) THEN
      Client_SYS.Add_To_Attr('ACCOUNTING_GROUP', rec_.accounting_group, attr_);
   END IF;
   IF (indrec_.asset_class) THEN
      Client_SYS.Add_To_Attr('ASSET_CLASS', rec_.asset_class, attr_);
   END IF;
   IF (indrec_.country_of_origin) THEN
      Client_SYS.Add_To_Attr('COUNTRY_OF_ORIGIN', rec_.country_of_origin, attr_);
   END IF;
   IF (indrec_.hazard_code) THEN
      Client_SYS.Add_To_Attr('HAZARD_CODE', rec_.hazard_code, attr_);
   END IF;
   IF (indrec_.note_id) THEN
      Client_SYS.Add_To_Attr('NOTE_ID', rec_.note_id, attr_);
   END IF;
   IF (indrec_.part_product_code) THEN
      Client_SYS.Add_To_Attr('PART_PRODUCT_CODE', rec_.part_product_code, attr_);
   END IF;
   IF (indrec_.part_product_family) THEN
      Client_SYS.Add_To_Attr('PART_PRODUCT_FAMILY', rec_.part_product_family, attr_);
   END IF;
   IF (indrec_.part_status) THEN
      Client_SYS.Add_To_Attr('PART_STATUS', rec_.part_status, attr_);
   END IF;
   IF (indrec_.planner_buyer) THEN
      Client_SYS.Add_To_Attr('PLANNER_BUYER', rec_.planner_buyer, attr_);
   END IF;
   IF (indrec_.prime_commodity) THEN
      Client_SYS.Add_To_Attr('PRIME_COMMODITY', rec_.prime_commodity, attr_);
   END IF;
   IF (indrec_.second_commodity) THEN
      Client_SYS.Add_To_Attr('SECOND_COMMODITY', rec_.second_commodity, attr_);
   END IF;
   IF (indrec_.unit_meas) THEN
      Client_SYS.Add_To_Attr('UNIT_MEAS', rec_.unit_meas, attr_);
   END IF;
   IF (indrec_.catch_unit_meas) THEN
      Client_SYS.Add_To_Attr('CATCH_UNIT_MEAS', rec_.catch_unit_meas, attr_);
   END IF;
   IF (indrec_.description) THEN
      Client_SYS.Add_To_Attr('DESCRIPTION', rec_.description, attr_);
   END IF;
   IF (indrec_.abc_class) THEN
      Client_SYS.Add_To_Attr('ABC_CLASS', rec_.abc_class, attr_);
   END IF;
   IF (indrec_.abc_class_locked_until) THEN
      Client_SYS.Add_To_Attr('ABC_CLASS_LOCKED_UNTIL', rec_.abc_class_locked_until, attr_);
   END IF;
   IF (indrec_.count_variance) THEN
      Client_SYS.Add_To_Attr('COUNT_VARIANCE', rec_.count_variance, attr_);
   END IF;
   IF (indrec_.create_date) THEN
      Client_SYS.Add_To_Attr('CREATE_DATE', rec_.create_date, attr_);
   END IF;
   IF (indrec_.cycle_code) THEN
      Client_SYS.Add_To_Attr('CYCLE_CODE', Inventory_Part_Count_Type_API.Decode(rec_.cycle_code), attr_);
      Client_SYS.Add_To_Attr('CYCLE_CODE_DB', rec_.cycle_code, attr_);
   END IF;
   IF (indrec_.cycle_period) THEN
      Client_SYS.Add_To_Attr('CYCLE_PERIOD', rec_.cycle_period, attr_);
   END IF;
   IF (indrec_.dim_quality) THEN
      Client_SYS.Add_To_Attr('DIM_QUALITY', rec_.dim_quality, attr_);
   END IF;
   IF (indrec_.durability_day) THEN
      Client_SYS.Add_To_Attr('DURABILITY_DAY', rec_.durability_day, attr_);
   END IF;
   IF (indrec_.expected_leadtime) THEN
      Client_SYS.Add_To_Attr('EXPECTED_LEADTIME', rec_.expected_leadtime, attr_);
   END IF;
   IF (indrec_.last_activity_date) THEN
      Client_SYS.Add_To_Attr('LAST_ACTIVITY_DATE', rec_.last_activity_date, attr_);
   END IF;
   IF (indrec_.lead_time_code) THEN
      Client_SYS.Add_To_Attr('LEAD_TIME_CODE', Inv_Part_Lead_Time_Code_API.Decode(rec_.lead_time_code), attr_);
      Client_SYS.Add_To_Attr('LEAD_TIME_CODE_DB', rec_.lead_time_code, attr_);
   END IF;
   IF (indrec_.manuf_leadtime) THEN
      Client_SYS.Add_To_Attr('MANUF_LEADTIME', rec_.manuf_leadtime, attr_);
   END IF;
   IF (indrec_.note_text) THEN
      Client_SYS.Add_To_Attr('NOTE_TEXT', rec_.note_text, attr_);
   END IF;
   IF (indrec_.oe_alloc_assign_flag) THEN
      Client_SYS.Add_To_Attr('OE_ALLOC_ASSIGN_FLAG', Cust_Ord_Reservation_Type_API.Decode(rec_.oe_alloc_assign_flag), attr_);
      Client_SYS.Add_To_Attr('OE_ALLOC_ASSIGN_FLAG_DB', rec_.oe_alloc_assign_flag, attr_);
   END IF;
   IF (indrec_.onhand_analysis_flag) THEN
      Client_SYS.Add_To_Attr('ONHAND_ANALYSIS_FLAG', Inventory_Part_Onh_Analys_API.Decode(rec_.onhand_analysis_flag), attr_);
      Client_SYS.Add_To_Attr('ONHAND_ANALYSIS_FLAG_DB', rec_.onhand_analysis_flag, attr_);
   END IF;
   IF (indrec_.purch_leadtime) THEN
      Client_SYS.Add_To_Attr('PURCH_LEADTIME', rec_.purch_leadtime, attr_);
   END IF;
   IF (indrec_.earliest_ultd_supply_date) THEN
      Client_SYS.Add_To_Attr('EARLIEST_ULTD_SUPPLY_DATE', rec_.earliest_ultd_supply_date, attr_);
   END IF;
   IF (indrec_.supersedes) THEN
      Client_SYS.Add_To_Attr('SUPERSEDES', rec_.supersedes, attr_);
   END IF;
   IF (indrec_.supply_code) THEN
      Client_SYS.Add_To_Attr('SUPPLY_CODE', Material_Requis_Supply_API.Decode(rec_.supply_code), attr_);
      Client_SYS.Add_To_Attr('SUPPLY_CODE_DB', rec_.supply_code, attr_);
   END IF;
   IF (indrec_.type_code) THEN
      Client_SYS.Add_To_Attr('TYPE_CODE', Inventory_Part_Type_API.Decode(rec_.type_code), attr_);
      Client_SYS.Add_To_Attr('TYPE_CODE_DB', rec_.type_code, attr_);
   END IF;
   IF (indrec_.customs_stat_no) THEN
      Client_SYS.Add_To_Attr('CUSTOMS_STAT_NO', rec_.customs_stat_no, attr_);
   END IF;
   IF (indrec_.type_designation) THEN
      Client_SYS.Add_To_Attr('TYPE_DESIGNATION', rec_.type_designation, attr_);
   END IF;
   IF (indrec_.zero_cost_flag) THEN
      Client_SYS.Add_To_Attr('ZERO_COST_FLAG', Inventory_Part_Zero_Cost_API.Decode(rec_.zero_cost_flag), attr_);
      Client_SYS.Add_To_Attr('ZERO_COST_FLAG_DB', rec_.zero_cost_flag, attr_);
   END IF;
   IF (indrec_.avail_activity_status) THEN
      Client_SYS.Add_To_Attr('AVAIL_ACTIVITY_STATUS', Inventory_Part_Avail_Stat_API.Decode(rec_.avail_activity_status), attr_);
      Client_SYS.Add_To_Attr('AVAIL_ACTIVITY_STATUS_DB', rec_.avail_activity_status, attr_);
   END IF;
   IF (indrec_.eng_attribute) THEN
      Client_SYS.Add_To_Attr('ENG_ATTRIBUTE', rec_.eng_attribute, attr_);
   END IF;
   IF (indrec_.shortage_flag) THEN
      Client_SYS.Add_To_Attr('SHORTAGE_FLAG', Inventory_Part_Shortage_API.Decode(rec_.shortage_flag), attr_);
      Client_SYS.Add_To_Attr('SHORTAGE_FLAG_DB', rec_.shortage_flag, attr_);
   END IF;
   IF (indrec_.forecast_consumption_flag) THEN
      Client_SYS.Add_To_Attr('FORECAST_CONSUMPTION_FLAG', Inv_Part_Forecast_Consum_API.Decode(rec_.forecast_consumption_flag), attr_);
      Client_SYS.Add_To_Attr('FORECAST_CONSUMPTION_FLAG_DB', rec_.forecast_consumption_flag, attr_);
   END IF;
   IF (indrec_.stock_management) THEN
      Client_SYS.Add_To_Attr('STOCK_MANAGEMENT', Inventory_Part_Management_API.Decode(rec_.stock_management), attr_);
      Client_SYS.Add_To_Attr('STOCK_MANAGEMENT_DB', rec_.stock_management, attr_);
   END IF;
   IF (indrec_.intrastat_conv_factor) THEN
      Client_SYS.Add_To_Attr('INTRASTAT_CONV_FACTOR', rec_.intrastat_conv_factor, attr_);
   END IF;
   IF (indrec_.part_cost_group_id) THEN
      Client_SYS.Add_To_Attr('PART_COST_GROUP_ID', rec_.part_cost_group_id, attr_);
   END IF;
   IF (indrec_.dop_connection) THEN
      Client_SYS.Add_To_Attr('DOP_CONNECTION', Dop_Connection_API.Decode(rec_.dop_connection), attr_);
      Client_SYS.Add_To_Attr('DOP_CONNECTION_DB', rec_.dop_connection, attr_);
   END IF;
   IF (indrec_.std_name_id) THEN
      Client_SYS.Add_To_Attr('STD_NAME_ID', rec_.std_name_id, attr_);
   END IF;
   IF (indrec_.inventory_valuation_method) THEN
      Client_SYS.Add_To_Attr('INVENTORY_VALUATION_METHOD', Inventory_Value_Method_API.Decode(rec_.inventory_valuation_method), attr_);
      Client_SYS.Add_To_Attr('INVENTORY_VALUATION_METHOD_DB', rec_.inventory_valuation_method, attr_);
   END IF;
   IF (indrec_.negative_on_hand) THEN
      Client_SYS.Add_To_Attr('NEGATIVE_ON_HAND', Negative_On_Hand_API.Decode(rec_.negative_on_hand), attr_);
      Client_SYS.Add_To_Attr('NEGATIVE_ON_HAND_DB', rec_.negative_on_hand, attr_);
   END IF;
   IF (indrec_.technical_coordinator_id) THEN
      Client_SYS.Add_To_Attr('TECHNICAL_COORDINATOR_ID', rec_.technical_coordinator_id, attr_);
   END IF;
   IF (indrec_.invoice_consideration) THEN
      Client_SYS.Add_To_Attr('INVOICE_CONSIDERATION', Invoice_Consideration_API.Decode(rec_.invoice_consideration), attr_);
      Client_SYS.Add_To_Attr('INVOICE_CONSIDERATION_DB', rec_.invoice_consideration, attr_);
   END IF;
   IF (indrec_.actual_cost_activated) THEN
      Client_SYS.Add_To_Attr('ACTUAL_COST_ACTIVATED', rec_.actual_cost_activated, attr_);
   END IF;
   IF (indrec_.max_actual_cost_update) THEN
      Client_SYS.Add_To_Attr('MAX_ACTUAL_COST_UPDATE', rec_.max_actual_cost_update, attr_);
   END IF;
   IF (indrec_.cust_warranty_id) THEN
      Client_SYS.Add_To_Attr('CUST_WARRANTY_ID', rec_.cust_warranty_id, attr_);
   END IF;
   IF (indrec_.sup_warranty_id) THEN
      Client_SYS.Add_To_Attr('SUP_WARRANTY_ID', rec_.sup_warranty_id, attr_);
   END IF;
   IF (indrec_.region_of_origin) THEN
      Client_SYS.Add_To_Attr('REGION_OF_ORIGIN', rec_.region_of_origin, attr_);
   END IF;
   IF (indrec_.inventory_part_cost_level) THEN
      Client_SYS.Add_To_Attr('INVENTORY_PART_COST_LEVEL', Inventory_Part_Cost_Level_API.Decode(rec_.inventory_part_cost_level), attr_);
      Client_SYS.Add_To_Attr('INVENTORY_PART_COST_LEVEL_DB', rec_.inventory_part_cost_level, attr_);
   END IF;
   IF (indrec_.ext_service_cost_method) THEN
      Client_SYS.Add_To_Attr('EXT_SERVICE_COST_METHOD', Ext_Service_Cost_Method_API.Decode(rec_.ext_service_cost_method), attr_);
      Client_SYS.Add_To_Attr('EXT_SERVICE_COST_METHOD_DB', rec_.ext_service_cost_method, attr_);
   END IF;
   IF (indrec_.supply_chain_part_group) THEN
      Client_SYS.Add_To_Attr('SUPPLY_CHAIN_PART_GROUP', rec_.supply_chain_part_group, attr_);
   END IF;
   IF (indrec_.automatic_capability_check) THEN
      Client_SYS.Add_To_Attr('AUTOMATIC_CAPABILITY_CHECK', Capability_Check_Allocate_API.Decode(rec_.automatic_capability_check), attr_);
      Client_SYS.Add_To_Attr('AUTOMATIC_CAPABILITY_CHECK_DB', rec_.automatic_capability_check, attr_);
   END IF;
   IF (indrec_.input_unit_meas_group_id) THEN
      Client_SYS.Add_To_Attr('INPUT_UNIT_MEAS_GROUP_ID', rec_.input_unit_meas_group_id, attr_);
   END IF;
   IF (indrec_.dop_netting) THEN
      Client_SYS.Add_To_Attr('DOP_NETTING', Dop_Netting_API.Decode(rec_.dop_netting), attr_);
      Client_SYS.Add_To_Attr('DOP_NETTING_DB', rec_.dop_netting, attr_);
   END IF;
   IF (indrec_.co_reserve_onh_analys_flag) THEN
      Client_SYS.Add_To_Attr('CO_RESERVE_ONH_ANALYS_FLAG', Inventory_Part_Onh_Analys_API.Decode(rec_.co_reserve_onh_analys_flag), attr_);
      Client_SYS.Add_To_Attr('CO_RESERVE_ONH_ANALYS_FLAG_DB', rec_.co_reserve_onh_analys_flag, attr_);
   END IF;
   IF (indrec_.qty_calc_rounding) THEN
      Client_SYS.Add_To_Attr('QTY_CALC_ROUNDING', rec_.qty_calc_rounding, attr_);
   END IF;
   IF (indrec_.lifecycle_stage) THEN
      Client_SYS.Add_To_Attr('LIFECYCLE_STAGE', Inv_Part_Lifecycle_Stage_API.Decode(rec_.lifecycle_stage), attr_);
      Client_SYS.Add_To_Attr('LIFECYCLE_STAGE_DB', rec_.lifecycle_stage, attr_);
   END IF;
   IF (indrec_.life_stage_locked_until) THEN
      Client_SYS.Add_To_Attr('LIFE_STAGE_LOCKED_UNTIL', rec_.life_stage_locked_until, attr_);
   END IF;
   IF (indrec_.frequency_class) THEN
      Client_SYS.Add_To_Attr('FREQUENCY_CLASS', Inv_Part_Frequency_Class_API.Decode(rec_.frequency_class), attr_);
      Client_SYS.Add_To_Attr('FREQUENCY_CLASS_DB', rec_.frequency_class, attr_);
   END IF;
   IF (indrec_.freq_class_locked_until) THEN
      Client_SYS.Add_To_Attr('FREQ_CLASS_LOCKED_UNTIL', rec_.freq_class_locked_until, attr_);
   END IF;
   IF (indrec_.first_stat_issue_date) THEN
      Client_SYS.Add_To_Attr('FIRST_STAT_ISSUE_DATE', rec_.first_stat_issue_date, attr_);
   END IF;
   IF (indrec_.latest_stat_issue_date) THEN
      Client_SYS.Add_To_Attr('LATEST_STAT_ISSUE_DATE', rec_.latest_stat_issue_date, attr_);
   END IF;
   IF (indrec_.decline_date) THEN
      Client_SYS.Add_To_Attr('DECLINE_DATE', rec_.decline_date, attr_);
   END IF;
   IF (indrec_.expired_date) THEN
      Client_SYS.Add_To_Attr('EXPIRED_DATE', rec_.expired_date, attr_);
   END IF;
   IF (indrec_.decline_issue_counter) THEN
      Client_SYS.Add_To_Attr('DECLINE_ISSUE_COUNTER', rec_.decline_issue_counter, attr_);
   END IF;
   IF (indrec_.expired_issue_counter) THEN
      Client_SYS.Add_To_Attr('EXPIRED_ISSUE_COUNTER', rec_.expired_issue_counter, attr_);
   END IF;
   IF (indrec_.min_durab_days_co_deliv) THEN
      Client_SYS.Add_To_Attr('MIN_DURAB_DAYS_CO_DELIV', rec_.min_durab_days_co_deliv, attr_);
   END IF;
   IF (indrec_.min_durab_days_planning) THEN
      Client_SYS.Add_To_Attr('MIN_DURAB_DAYS_PLANNING', rec_.min_durab_days_planning, attr_);
   END IF;
   IF (indrec_.storage_width_requirement) THEN
      Client_SYS.Add_To_Attr('STORAGE_WIDTH_REQUIREMENT', rec_.storage_width_requirement, attr_);
   END IF;
   IF (indrec_.storage_height_requirement) THEN
      Client_SYS.Add_To_Attr('STORAGE_HEIGHT_REQUIREMENT', rec_.storage_height_requirement, attr_);
   END IF;
   IF (indrec_.storage_depth_requirement) THEN
      Client_SYS.Add_To_Attr('STORAGE_DEPTH_REQUIREMENT', rec_.storage_depth_requirement, attr_);
   END IF;
   IF (indrec_.storage_volume_requirement) THEN
      Client_SYS.Add_To_Attr('STORAGE_VOLUME_REQUIREMENT', rec_.storage_volume_requirement, attr_);
   END IF;
   IF (indrec_.storage_weight_requirement) THEN
      Client_SYS.Add_To_Attr('STORAGE_WEIGHT_REQUIREMENT', rec_.storage_weight_requirement, attr_);
   END IF;
   IF (indrec_.min_storage_temperature) THEN
      Client_SYS.Add_To_Attr('MIN_STORAGE_TEMPERATURE', rec_.min_storage_temperature, attr_);
   END IF;
   IF (indrec_.max_storage_temperature) THEN
      Client_SYS.Add_To_Attr('MAX_STORAGE_TEMPERATURE', rec_.max_storage_temperature, attr_);
   END IF;
   IF (indrec_.min_storage_humidity) THEN
      Client_SYS.Add_To_Attr('MIN_STORAGE_HUMIDITY', rec_.min_storage_humidity, attr_);
   END IF;
   IF (indrec_.max_storage_humidity) THEN
      Client_SYS.Add_To_Attr('MAX_STORAGE_HUMIDITY', rec_.max_storage_humidity, attr_);
   END IF;
   IF (indrec_.standard_putaway_qty) THEN
      Client_SYS.Add_To_Attr('STANDARD_PUTAWAY_QTY', rec_.standard_putaway_qty, attr_);
   END IF;
   IF (indrec_.putaway_zone_refill_option) THEN
      Client_SYS.Add_To_Attr('PUTAWAY_ZONE_REFILL_OPTION', Putaway_Zone_Refill_Option_API.Decode(rec_.putaway_zone_refill_option), attr_);
      Client_SYS.Add_To_Attr('PUTAWAY_ZONE_REFILL_OPTION_DB', rec_.putaway_zone_refill_option, attr_);
   END IF;
   IF (indrec_.reset_config_std_cost) THEN
      Client_SYS.Add_To_Attr('RESET_CONFIG_STD_COST', Fnd_Boolean_API.Decode(rec_.reset_config_std_cost), attr_);
      Client_SYS.Add_To_Attr('RESET_CONFIG_STD_COST_DB', rec_.reset_config_std_cost, attr_);
   END IF;
   IF (indrec_.mandatory_expiration_date) THEN
      Client_SYS.Add_To_Attr('MANDATORY_EXPIRATION_DATE', Fnd_Boolean_API.Decode(rec_.mandatory_expiration_date), attr_);
      Client_SYS.Add_To_Attr('MANDATORY_EXPIRATION_DATE_DB', rec_.mandatory_expiration_date, attr_);
   END IF;
   IF (indrec_.excl_ship_pack_proposal) THEN
      Client_SYS.Add_To_Attr('EXCL_SHIP_PACK_PROPOSAL', Fnd_Boolean_API.Decode(rec_.excl_ship_pack_proposal), attr_);
      Client_SYS.Add_To_Attr('EXCL_SHIP_PACK_PROPOSAL_DB', rec_.excl_ship_pack_proposal, attr_);
   END IF;
   IF (indrec_.statistical_code) THEN
      Client_SYS.Add_To_Attr('STATISTICAL_CODE', rec_.statistical_code, attr_);
   END IF;
   IF (indrec_.acquisition_origin) THEN
      Client_SYS.Add_To_Attr('ACQUISITION_ORIGIN', rec_.acquisition_origin, attr_);
   END IF;
   IF (indrec_.acquisition_reason_id) THEN
      Client_SYS.Add_To_Attr('ACQUISITION_REASON_ID', rec_.acquisition_reason_id, attr_);
   END IF;
   RETURN attr_;
END Pack___;


FUNCTION Pack_Table___ (
   rec_ IN inventory_part_tab%ROWTYPE ) RETURN VARCHAR2
IS
   attr_ VARCHAR2(32000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('CONTRACT', rec_.contract, attr_);
   Client_SYS.Add_To_Attr('PART_NO', rec_.part_no, attr_);
   Client_SYS.Add_To_Attr('ACCOUNTING_GROUP', rec_.accounting_group, attr_);
   Client_SYS.Add_To_Attr('ASSET_CLASS', rec_.asset_class, attr_);
   Client_SYS.Add_To_Attr('COUNTRY_OF_ORIGIN', rec_.country_of_origin, attr_);
   Client_SYS.Add_To_Attr('HAZARD_CODE', rec_.hazard_code, attr_);
   Client_SYS.Add_To_Attr('NOTE_ID', rec_.note_id, attr_);
   Client_SYS.Add_To_Attr('PART_PRODUCT_CODE', rec_.part_product_code, attr_);
   Client_SYS.Add_To_Attr('PART_PRODUCT_FAMILY', rec_.part_product_family, attr_);
   Client_SYS.Add_To_Attr('PART_STATUS', rec_.part_status, attr_);
   Client_SYS.Add_To_Attr('PLANNER_BUYER', rec_.planner_buyer, attr_);
   Client_SYS.Add_To_Attr('PRIME_COMMODITY', rec_.prime_commodity, attr_);
   Client_SYS.Add_To_Attr('SECOND_COMMODITY', rec_.second_commodity, attr_);
   Client_SYS.Add_To_Attr('UNIT_MEAS', rec_.unit_meas, attr_);
   Client_SYS.Add_To_Attr('CATCH_UNIT_MEAS', rec_.catch_unit_meas, attr_);
   Client_SYS.Add_To_Attr('DESCRIPTION', rec_.description, attr_);
   Client_SYS.Add_To_Attr('ABC_CLASS', rec_.abc_class, attr_);
   Client_SYS.Add_To_Attr('ABC_CLASS_LOCKED_UNTIL', rec_.abc_class_locked_until, attr_);
   Client_SYS.Add_To_Attr('COUNT_VARIANCE', rec_.count_variance, attr_);
   Client_SYS.Add_To_Attr('CREATE_DATE', rec_.create_date, attr_);
   Client_SYS.Add_To_Attr('CYCLE_CODE', rec_.cycle_code, attr_);
   Client_SYS.Add_To_Attr('CYCLE_PERIOD', rec_.cycle_period, attr_);
   Client_SYS.Add_To_Attr('DIM_QUALITY', rec_.dim_quality, attr_);
   Client_SYS.Add_To_Attr('DURABILITY_DAY', rec_.durability_day, attr_);
   Client_SYS.Add_To_Attr('EXPECTED_LEADTIME', rec_.expected_leadtime, attr_);
   Client_SYS.Add_To_Attr('LAST_ACTIVITY_DATE', rec_.last_activity_date, attr_);
   Client_SYS.Add_To_Attr('LEAD_TIME_CODE', rec_.lead_time_code, attr_);
   Client_SYS.Add_To_Attr('MANUF_LEADTIME', rec_.manuf_leadtime, attr_);
   Client_SYS.Add_To_Attr('NOTE_TEXT', rec_.note_text, attr_);
   Client_SYS.Add_To_Attr('OE_ALLOC_ASSIGN_FLAG', rec_.oe_alloc_assign_flag, attr_);
   Client_SYS.Add_To_Attr('ONHAND_ANALYSIS_FLAG', rec_.onhand_analysis_flag, attr_);
   Client_SYS.Add_To_Attr('PURCH_LEADTIME', rec_.purch_leadtime, attr_);
   Client_SYS.Add_To_Attr('EARLIEST_ULTD_SUPPLY_DATE', rec_.earliest_ultd_supply_date, attr_);
   Client_SYS.Add_To_Attr('SUPERSEDES', rec_.supersedes, attr_);
   Client_SYS.Add_To_Attr('SUPPLY_CODE', rec_.supply_code, attr_);
   Client_SYS.Add_To_Attr('TYPE_CODE', rec_.type_code, attr_);
   Client_SYS.Add_To_Attr('CUSTOMS_STAT_NO', rec_.customs_stat_no, attr_);
   Client_SYS.Add_To_Attr('TYPE_DESIGNATION', rec_.type_designation, attr_);
   Client_SYS.Add_To_Attr('ZERO_COST_FLAG', rec_.zero_cost_flag, attr_);
   Client_SYS.Add_To_Attr('AVAIL_ACTIVITY_STATUS', rec_.avail_activity_status, attr_);
   Client_SYS.Add_To_Attr('ENG_ATTRIBUTE', rec_.eng_attribute, attr_);
   Client_SYS.Add_To_Attr('SHORTAGE_FLAG', rec_.shortage_flag, attr_);
   Client_SYS.Add_To_Attr('FORECAST_CONSUMPTION_FLAG', rec_.forecast_consumption_flag, attr_);
   Client_SYS.Add_To_Attr('STOCK_MANAGEMENT', rec_.stock_management, attr_);
   Client_SYS.Add_To_Attr('INTRASTAT_CONV_FACTOR', rec_.intrastat_conv_factor, attr_);
   Client_SYS.Add_To_Attr('PART_COST_GROUP_ID', rec_.part_cost_group_id, attr_);
   Client_SYS.Add_To_Attr('DOP_CONNECTION', rec_.dop_connection, attr_);
   Client_SYS.Add_To_Attr('STD_NAME_ID', rec_.std_name_id, attr_);
   Client_SYS.Add_To_Attr('INVENTORY_VALUATION_METHOD', rec_.inventory_valuation_method, attr_);
   Client_SYS.Add_To_Attr('NEGATIVE_ON_HAND', rec_.negative_on_hand, attr_);
   Client_SYS.Add_To_Attr('TECHNICAL_COORDINATOR_ID', rec_.technical_coordinator_id, attr_);
   Client_SYS.Add_To_Attr('INVOICE_CONSIDERATION', rec_.invoice_consideration, attr_);
   Client_SYS.Add_To_Attr('ACTUAL_COST_ACTIVATED', rec_.actual_cost_activated, attr_);
   Client_SYS.Add_To_Attr('MAX_ACTUAL_COST_UPDATE', rec_.max_actual_cost_update, attr_);
   Client_SYS.Add_To_Attr('CUST_WARRANTY_ID', rec_.cust_warranty_id, attr_);
   Client_SYS.Add_To_Attr('SUP_WARRANTY_ID', rec_.sup_warranty_id, attr_);
   Client_SYS.Add_To_Attr('REGION_OF_ORIGIN', rec_.region_of_origin, attr_);
   Client_SYS.Add_To_Attr('INVENTORY_PART_COST_LEVEL', rec_.inventory_part_cost_level, attr_);
   Client_SYS.Add_To_Attr('EXT_SERVICE_COST_METHOD', rec_.ext_service_cost_method, attr_);
   Client_SYS.Add_To_Attr('SUPPLY_CHAIN_PART_GROUP', rec_.supply_chain_part_group, attr_);
   Client_SYS.Add_To_Attr('AUTOMATIC_CAPABILITY_CHECK', rec_.automatic_capability_check, attr_);
   Client_SYS.Add_To_Attr('INPUT_UNIT_MEAS_GROUP_ID', rec_.input_unit_meas_group_id, attr_);
   Client_SYS.Add_To_Attr('DOP_NETTING', rec_.dop_netting, attr_);
   Client_SYS.Add_To_Attr('CO_RESERVE_ONH_ANALYS_FLAG', rec_.co_reserve_onh_analys_flag, attr_);
   Client_SYS.Add_To_Attr('QTY_CALC_ROUNDING', rec_.qty_calc_rounding, attr_);
   Client_SYS.Add_To_Attr('LIFECYCLE_STAGE', rec_.lifecycle_stage, attr_);
   Client_SYS.Add_To_Attr('LIFE_STAGE_LOCKED_UNTIL', rec_.life_stage_locked_until, attr_);
   Client_SYS.Add_To_Attr('FREQUENCY_CLASS', rec_.frequency_class, attr_);
   Client_SYS.Add_To_Attr('FREQ_CLASS_LOCKED_UNTIL', rec_.freq_class_locked_until, attr_);
   Client_SYS.Add_To_Attr('FIRST_STAT_ISSUE_DATE', rec_.first_stat_issue_date, attr_);
   Client_SYS.Add_To_Attr('LATEST_STAT_ISSUE_DATE', rec_.latest_stat_issue_date, attr_);
   Client_SYS.Add_To_Attr('DECLINE_DATE', rec_.decline_date, attr_);
   Client_SYS.Add_To_Attr('EXPIRED_DATE', rec_.expired_date, attr_);
   Client_SYS.Add_To_Attr('DECLINE_ISSUE_COUNTER', rec_.decline_issue_counter, attr_);
   Client_SYS.Add_To_Attr('EXPIRED_ISSUE_COUNTER', rec_.expired_issue_counter, attr_);
   Client_SYS.Add_To_Attr('MIN_DURAB_DAYS_CO_DELIV', rec_.min_durab_days_co_deliv, attr_);
   Client_SYS.Add_To_Attr('MIN_DURAB_DAYS_PLANNING', rec_.min_durab_days_planning, attr_);
   Client_SYS.Add_To_Attr('STORAGE_WIDTH_REQUIREMENT', rec_.storage_width_requirement, attr_);
   Client_SYS.Add_To_Attr('STORAGE_HEIGHT_REQUIREMENT', rec_.storage_height_requirement, attr_);
   Client_SYS.Add_To_Attr('STORAGE_DEPTH_REQUIREMENT', rec_.storage_depth_requirement, attr_);
   Client_SYS.Add_To_Attr('STORAGE_VOLUME_REQUIREMENT', rec_.storage_volume_requirement, attr_);
   Client_SYS.Add_To_Attr('STORAGE_WEIGHT_REQUIREMENT', rec_.storage_weight_requirement, attr_);
   Client_SYS.Add_To_Attr('MIN_STORAGE_TEMPERATURE', rec_.min_storage_temperature, attr_);
   Client_SYS.Add_To_Attr('MAX_STORAGE_TEMPERATURE', rec_.max_storage_temperature, attr_);
   Client_SYS.Add_To_Attr('MIN_STORAGE_HUMIDITY', rec_.min_storage_humidity, attr_);
   Client_SYS.Add_To_Attr('MAX_STORAGE_HUMIDITY', rec_.max_storage_humidity, attr_);
   Client_SYS.Add_To_Attr('STANDARD_PUTAWAY_QTY', rec_.standard_putaway_qty, attr_);
   Client_SYS.Add_To_Attr('PUTAWAY_ZONE_REFILL_OPTION', rec_.putaway_zone_refill_option, attr_);
   Client_SYS.Add_To_Attr('RESET_CONFIG_STD_COST', rec_.reset_config_std_cost, attr_);
   Client_SYS.Add_To_Attr('MANDATORY_EXPIRATION_DATE', rec_.mandatory_expiration_date, attr_);
   Client_SYS.Add_To_Attr('EXCL_SHIP_PACK_PROPOSAL', rec_.excl_ship_pack_proposal, attr_);
   Client_SYS.Add_To_Attr('STATISTICAL_CODE', rec_.statistical_code, attr_);
   Client_SYS.Add_To_Attr('ACQUISITION_ORIGIN', rec_.acquisition_origin, attr_);
   Client_SYS.Add_To_Attr('ACQUISITION_REASON_ID', rec_.acquisition_reason_id, attr_);
   Client_SYS.Add_To_Attr('ROWKEY', rec_.rowkey, attr_);
   RETURN attr_;
END Pack_Table___;


FUNCTION Public_To_Table___ (
   public_ IN Public_Rec ) RETURN inventory_part_tab%ROWTYPE
IS
   rec_ inventory_part_tab%ROWTYPE;
BEGIN
   rec_.rowversion                     := public_.rowversion;
   rec_.rowkey                         := public_.rowkey;
   rec_.contract                       := public_.contract;
   rec_.part_no                        := public_.part_no;
   rec_.accounting_group               := public_.accounting_group;
   rec_.asset_class                    := public_.asset_class;
   rec_.country_of_origin              := public_.country_of_origin;
   rec_.hazard_code                    := public_.hazard_code;
   rec_.note_id                        := public_.note_id;
   rec_.part_product_code              := public_.part_product_code;
   rec_.part_product_family            := public_.part_product_family;
   rec_.part_status                    := public_.part_status;
   rec_.planner_buyer                  := public_.planner_buyer;
   rec_.prime_commodity                := public_.prime_commodity;
   rec_.second_commodity               := public_.second_commodity;
   rec_.unit_meas                      := public_.unit_meas;
   rec_.catch_unit_meas                := public_.catch_unit_meas;
   rec_.abc_class                      := public_.abc_class;
   rec_.abc_class_locked_until         := public_.abc_class_locked_until;
   rec_.count_variance                 := public_.count_variance;
   rec_.create_date                    := public_.create_date;
   rec_.cycle_code                     := public_.cycle_code;
   rec_.cycle_period                   := public_.cycle_period;
   rec_.dim_quality                    := public_.dim_quality;
   rec_.durability_day                 := public_.durability_day;
   rec_.expected_leadtime              := public_.expected_leadtime;
   rec_.lead_time_code                 := public_.lead_time_code;
   rec_.manuf_leadtime                 := public_.manuf_leadtime;
   rec_.oe_alloc_assign_flag           := public_.oe_alloc_assign_flag;
   rec_.onhand_analysis_flag           := public_.onhand_analysis_flag;
   rec_.purch_leadtime                 := public_.purch_leadtime;
   rec_.earliest_ultd_supply_date      := public_.earliest_ultd_supply_date;
   rec_.supersedes                     := public_.supersedes;
   rec_.supply_code                    := public_.supply_code;
   rec_.type_code                      := public_.type_code;
   rec_.customs_stat_no                := public_.customs_stat_no;
   rec_.type_designation               := public_.type_designation;
   rec_.zero_cost_flag                 := public_.zero_cost_flag;
   rec_.avail_activity_status          := public_.avail_activity_status;
   rec_.eng_attribute                  := public_.eng_attribute;
   rec_.shortage_flag                  := public_.shortage_flag;
   rec_.forecast_consumption_flag      := public_.forecast_consumption_flag;
   rec_.stock_management               := public_.stock_management;
   rec_.intrastat_conv_factor          := public_.intrastat_conv_factor;
   rec_.part_cost_group_id             := public_.part_cost_group_id;
   rec_.dop_connection                 := public_.dop_connection;
   rec_.std_name_id                    := public_.std_name_id;
   rec_.inventory_valuation_method     := public_.inventory_valuation_method;
   rec_.negative_on_hand               := public_.negative_on_hand;
   rec_.technical_coordinator_id       := public_.technical_coordinator_id;
   rec_.invoice_consideration          := public_.invoice_consideration;
   rec_.actual_cost_activated          := public_.actual_cost_activated;
   rec_.max_actual_cost_update         := public_.max_actual_cost_update;
   rec_.cust_warranty_id               := public_.cust_warranty_id;
   rec_.sup_warranty_id                := public_.sup_warranty_id;
   rec_.region_of_origin               := public_.region_of_origin;
   rec_.inventory_part_cost_level      := public_.inventory_part_cost_level;
   rec_.ext_service_cost_method        := public_.ext_service_cost_method;
   rec_.supply_chain_part_group        := public_.supply_chain_part_group;
   rec_.automatic_capability_check     := public_.automatic_capability_check;
   rec_.input_unit_meas_group_id       := public_.input_unit_meas_group_id;
   rec_.dop_netting                    := public_.dop_netting;
   rec_.co_reserve_onh_analys_flag     := public_.co_reserve_onh_analys_flag;
   rec_.qty_calc_rounding              := public_.qty_calc_rounding;
   rec_.lifecycle_stage                := public_.lifecycle_stage;
   rec_.life_stage_locked_until        := public_.life_stage_locked_until;
   rec_.frequency_class                := public_.frequency_class;
   rec_.freq_class_locked_until        := public_.freq_class_locked_until;
   rec_.first_stat_issue_date          := public_.first_stat_issue_date;
   rec_.latest_stat_issue_date         := public_.latest_stat_issue_date;
   rec_.decline_date                   := public_.decline_date;
   rec_.expired_date                   := public_.expired_date;
   rec_.decline_issue_counter          := public_.decline_issue_counter;
   rec_.expired_issue_counter          := public_.expired_issue_counter;
   rec_.min_durab_days_co_deliv        := public_.min_durab_days_co_deliv;
   rec_.min_durab_days_planning        := public_.min_durab_days_planning;
   rec_.storage_width_requirement      := public_.storage_width_requirement;
   rec_.storage_height_requirement     := public_.storage_height_requirement;
   rec_.storage_depth_requirement      := public_.storage_depth_requirement;
   rec_.storage_volume_requirement     := public_.storage_volume_requirement;
   rec_.storage_weight_requirement     := public_.storage_weight_requirement;
   rec_.min_storage_temperature        := public_.min_storage_temperature;
   rec_.max_storage_temperature        := public_.max_storage_temperature;
   rec_.min_storage_humidity           := public_.min_storage_humidity;
   rec_.max_storage_humidity           := public_.max_storage_humidity;
   rec_.standard_putaway_qty           := public_.standard_putaway_qty;
   rec_.reset_config_std_cost          := public_.reset_config_std_cost;
   rec_.mandatory_expiration_date      := public_.mandatory_expiration_date;
   rec_.excl_ship_pack_proposal        := public_.excl_ship_pack_proposal;
   rec_.statistical_code               := public_.statistical_code;
   rec_.acquisition_origin             := public_.acquisition_origin;
   rec_.acquisition_reason_id          := public_.acquisition_reason_id;
   RETURN rec_;
END Public_To_Table___;


FUNCTION Table_To_Public___ (
   rec_ IN inventory_part_tab%ROWTYPE ) RETURN Public_Rec
IS
   public_ Public_Rec;
BEGIN
   public_.rowversion                     := rec_.rowversion;
   public_.rowkey                         := rec_.rowkey;
   public_.contract                       := rec_.contract;
   public_.part_no                        := rec_.part_no;
   public_.accounting_group               := rec_.accounting_group;
   public_.asset_class                    := rec_.asset_class;
   public_.country_of_origin              := rec_.country_of_origin;
   public_.hazard_code                    := rec_.hazard_code;
   public_.note_id                        := rec_.note_id;
   public_.part_product_code              := rec_.part_product_code;
   public_.part_product_family            := rec_.part_product_family;
   public_.part_status                    := rec_.part_status;
   public_.planner_buyer                  := rec_.planner_buyer;
   public_.prime_commodity                := rec_.prime_commodity;
   public_.second_commodity               := rec_.second_commodity;
   public_.unit_meas                      := rec_.unit_meas;
   public_.catch_unit_meas                := rec_.catch_unit_meas;
   public_.abc_class                      := rec_.abc_class;
   public_.abc_class_locked_until         := rec_.abc_class_locked_until;
   public_.count_variance                 := rec_.count_variance;
   public_.create_date                    := rec_.create_date;
   public_.cycle_code                     := rec_.cycle_code;
   public_.cycle_period                   := rec_.cycle_period;
   public_.dim_quality                    := rec_.dim_quality;
   public_.durability_day                 := rec_.durability_day;
   public_.expected_leadtime              := rec_.expected_leadtime;
   public_.lead_time_code                 := rec_.lead_time_code;
   public_.manuf_leadtime                 := rec_.manuf_leadtime;
   public_.oe_alloc_assign_flag           := rec_.oe_alloc_assign_flag;
   public_.onhand_analysis_flag           := rec_.onhand_analysis_flag;
   public_.purch_leadtime                 := rec_.purch_leadtime;
   public_.earliest_ultd_supply_date      := rec_.earliest_ultd_supply_date;
   public_.supersedes                     := rec_.supersedes;
   public_.supply_code                    := rec_.supply_code;
   public_.type_code                      := rec_.type_code;
   public_.customs_stat_no                := rec_.customs_stat_no;
   public_.type_designation               := rec_.type_designation;
   public_.zero_cost_flag                 := rec_.zero_cost_flag;
   public_.avail_activity_status          := rec_.avail_activity_status;
   public_.eng_attribute                  := rec_.eng_attribute;
   public_.shortage_flag                  := rec_.shortage_flag;
   public_.forecast_consumption_flag      := rec_.forecast_consumption_flag;
   public_.stock_management               := rec_.stock_management;
   public_.intrastat_conv_factor          := rec_.intrastat_conv_factor;
   public_.part_cost_group_id             := rec_.part_cost_group_id;
   public_.dop_connection                 := rec_.dop_connection;
   public_.std_name_id                    := rec_.std_name_id;
   public_.inventory_valuation_method     := rec_.inventory_valuation_method;
   public_.negative_on_hand               := rec_.negative_on_hand;
   public_.technical_coordinator_id       := rec_.technical_coordinator_id;
   public_.invoice_consideration          := rec_.invoice_consideration;
   public_.actual_cost_activated          := rec_.actual_cost_activated;
   public_.max_actual_cost_update         := rec_.max_actual_cost_update;
   public_.cust_warranty_id               := rec_.cust_warranty_id;
   public_.sup_warranty_id                := rec_.sup_warranty_id;
   public_.region_of_origin               := rec_.region_of_origin;
   public_.inventory_part_cost_level      := rec_.inventory_part_cost_level;
   public_.ext_service_cost_method        := rec_.ext_service_cost_method;
   public_.supply_chain_part_group        := rec_.supply_chain_part_group;
   public_.automatic_capability_check     := rec_.automatic_capability_check;
   public_.input_unit_meas_group_id       := rec_.input_unit_meas_group_id;
   public_.dop_netting                    := rec_.dop_netting;
   public_.co_reserve_onh_analys_flag     := rec_.co_reserve_onh_analys_flag;
   public_.qty_calc_rounding              := rec_.qty_calc_rounding;
   public_.lifecycle_stage                := rec_.lifecycle_stage;
   public_.life_stage_locked_until        := rec_.life_stage_locked_until;
   public_.frequency_class                := rec_.frequency_class;
   public_.freq_class_locked_until        := rec_.freq_class_locked_until;
   public_.first_stat_issue_date          := rec_.first_stat_issue_date;
   public_.latest_stat_issue_date         := rec_.latest_stat_issue_date;
   public_.decline_date                   := rec_.decline_date;
   public_.expired_date                   := rec_.expired_date;
   public_.decline_issue_counter          := rec_.decline_issue_counter;
   public_.expired_issue_counter          := rec_.expired_issue_counter;
   public_.min_durab_days_co_deliv        := rec_.min_durab_days_co_deliv;
   public_.min_durab_days_planning        := rec_.min_durab_days_planning;
   public_.storage_width_requirement      := rec_.storage_width_requirement;
   public_.storage_height_requirement     := rec_.storage_height_requirement;
   public_.storage_depth_requirement      := rec_.storage_depth_requirement;
   public_.storage_volume_requirement     := rec_.storage_volume_requirement;
   public_.storage_weight_requirement     := rec_.storage_weight_requirement;
   public_.min_storage_temperature        := rec_.min_storage_temperature;
   public_.max_storage_temperature        := rec_.max_storage_temperature;
   public_.min_storage_humidity           := rec_.min_storage_humidity;
   public_.max_storage_humidity           := rec_.max_storage_humidity;
   public_.standard_putaway_qty           := rec_.standard_putaway_qty;
   public_.reset_config_std_cost          := rec_.reset_config_std_cost;
   public_.mandatory_expiration_date      := rec_.mandatory_expiration_date;
   public_.excl_ship_pack_proposal        := rec_.excl_ship_pack_proposal;
   public_.statistical_code               := rec_.statistical_code;
   public_.acquisition_origin             := rec_.acquisition_origin;
   public_.acquisition_reason_id          := rec_.acquisition_reason_id;
   RETURN public_;
END Table_To_Public___;


PROCEDURE Reset_Indicator_Rec___ (
   indrec_ IN OUT NOCOPY Indicator_Rec )
IS
   empty_indrec_ Indicator_Rec;
BEGIN
   indrec_ := empty_indrec_;
END Reset_Indicator_Rec___;


FUNCTION Get_Indicator_Rec___ (
   rec_ IN inventory_part_tab%ROWTYPE ) RETURN Indicator_Rec
IS
   indrec_ Indicator_Rec;
BEGIN
   indrec_.contract := rec_.contract IS NOT NULL;
   indrec_.part_no := rec_.part_no IS NOT NULL;
   indrec_.accounting_group := rec_.accounting_group IS NOT NULL;
   indrec_.asset_class := rec_.asset_class IS NOT NULL;
   indrec_.country_of_origin := rec_.country_of_origin IS NOT NULL;
   indrec_.hazard_code := rec_.hazard_code IS NOT NULL;
   indrec_.note_id := rec_.note_id IS NOT NULL;
   indrec_.part_product_code := rec_.part_product_code IS NOT NULL;
   indrec_.part_product_family := rec_.part_product_family IS NOT NULL;
   indrec_.part_status := rec_.part_status IS NOT NULL;
   indrec_.planner_buyer := rec_.planner_buyer IS NOT NULL;
   indrec_.prime_commodity := rec_.prime_commodity IS NOT NULL;
   indrec_.second_commodity := rec_.second_commodity IS NOT NULL;
   indrec_.unit_meas := rec_.unit_meas IS NOT NULL;
   indrec_.catch_unit_meas := rec_.catch_unit_meas IS NOT NULL;
   indrec_.description := rec_.description IS NOT NULL;
   indrec_.abc_class := rec_.abc_class IS NOT NULL;
   indrec_.abc_class_locked_until := rec_.abc_class_locked_until IS NOT NULL;
   indrec_.count_variance := rec_.count_variance IS NOT NULL;
   indrec_.create_date := rec_.create_date IS NOT NULL;
   indrec_.cycle_code := rec_.cycle_code IS NOT NULL;
   indrec_.cycle_period := rec_.cycle_period IS NOT NULL;
   indrec_.dim_quality := rec_.dim_quality IS NOT NULL;
   indrec_.durability_day := rec_.durability_day IS NOT NULL;
   indrec_.expected_leadtime := rec_.expected_leadtime IS NOT NULL;
   indrec_.last_activity_date := rec_.last_activity_date IS NOT NULL;
   indrec_.lead_time_code := rec_.lead_time_code IS NOT NULL;
   indrec_.manuf_leadtime := rec_.manuf_leadtime IS NOT NULL;
   indrec_.note_text := rec_.note_text IS NOT NULL;
   indrec_.oe_alloc_assign_flag := rec_.oe_alloc_assign_flag IS NOT NULL;
   indrec_.onhand_analysis_flag := rec_.onhand_analysis_flag IS NOT NULL;
   indrec_.purch_leadtime := rec_.purch_leadtime IS NOT NULL;
   indrec_.earliest_ultd_supply_date := rec_.earliest_ultd_supply_date IS NOT NULL;
   indrec_.supersedes := rec_.supersedes IS NOT NULL;
   indrec_.supply_code := rec_.supply_code IS NOT NULL;
   indrec_.type_code := rec_.type_code IS NOT NULL;
   indrec_.customs_stat_no := rec_.customs_stat_no IS NOT NULL;
   indrec_.type_designation := rec_.type_designation IS NOT NULL;
   indrec_.zero_cost_flag := rec_.zero_cost_flag IS NOT NULL;
   indrec_.avail_activity_status := rec_.avail_activity_status IS NOT NULL;
   indrec_.eng_attribute := rec_.eng_attribute IS NOT NULL;
   indrec_.shortage_flag := rec_.shortage_flag IS NOT NULL;
   indrec_.forecast_consumption_flag := rec_.forecast_consumption_flag IS NOT NULL;
   indrec_.stock_management := rec_.stock_management IS NOT NULL;
   indrec_.intrastat_conv_factor := rec_.intrastat_conv_factor IS NOT NULL;
   indrec_.part_cost_group_id := rec_.part_cost_group_id IS NOT NULL;
   indrec_.dop_connection := rec_.dop_connection IS NOT NULL;
   indrec_.std_name_id := rec_.std_name_id IS NOT NULL;
   indrec_.inventory_valuation_method := rec_.inventory_valuation_method IS NOT NULL;
   indrec_.negative_on_hand := rec_.negative_on_hand IS NOT NULL;
   indrec_.technical_coordinator_id := rec_.technical_coordinator_id IS NOT NULL;
   indrec_.invoice_consideration := rec_.invoice_consideration IS NOT NULL;
   indrec_.actual_cost_activated := rec_.actual_cost_activated IS NOT NULL;
   indrec_.max_actual_cost_update := rec_.max_actual_cost_update IS NOT NULL;
   indrec_.cust_warranty_id := rec_.cust_warranty_id IS NOT NULL;
   indrec_.sup_warranty_id := rec_.sup_warranty_id IS NOT NULL;
   indrec_.region_of_origin := rec_.region_of_origin IS NOT NULL;
   indrec_.inventory_part_cost_level := rec_.inventory_part_cost_level IS NOT NULL;
   indrec_.ext_service_cost_method := rec_.ext_service_cost_method IS NOT NULL;
   indrec_.supply_chain_part_group := rec_.supply_chain_part_group IS NOT NULL;
   indrec_.automatic_capability_check := rec_.automatic_capability_check IS NOT NULL;
   indrec_.input_unit_meas_group_id := rec_.input_unit_meas_group_id IS NOT NULL;
   indrec_.dop_netting := rec_.dop_netting IS NOT NULL;
   indrec_.co_reserve_onh_analys_flag := rec_.co_reserve_onh_analys_flag IS NOT NULL;
   indrec_.qty_calc_rounding := rec_.qty_calc_rounding IS NOT NULL;
   indrec_.lifecycle_stage := rec_.lifecycle_stage IS NOT NULL;
   indrec_.life_stage_locked_until := rec_.life_stage_locked_until IS NOT NULL;
   indrec_.frequency_class := rec_.frequency_class IS NOT NULL;
   indrec_.freq_class_locked_until := rec_.freq_class_locked_until IS NOT NULL;
   indrec_.first_stat_issue_date := rec_.first_stat_issue_date IS NOT NULL;
   indrec_.latest_stat_issue_date := rec_.latest_stat_issue_date IS NOT NULL;
   indrec_.decline_date := rec_.decline_date IS NOT NULL;
   indrec_.expired_date := rec_.expired_date IS NOT NULL;
   indrec_.decline_issue_counter := rec_.decline_issue_counter IS NOT NULL;
   indrec_.expired_issue_counter := rec_.expired_issue_counter IS NOT NULL;
   indrec_.min_durab_days_co_deliv := rec_.min_durab_days_co_deliv IS NOT NULL;
   indrec_.min_durab_days_planning := rec_.min_durab_days_planning IS NOT NULL;
   indrec_.storage_width_requirement := rec_.storage_width_requirement IS NOT NULL;
   indrec_.storage_height_requirement := rec_.storage_height_requirement IS NOT NULL;
   indrec_.storage_depth_requirement := rec_.storage_depth_requirement IS NOT NULL;
   indrec_.storage_volume_requirement := rec_.storage_volume_requirement IS NOT NULL;
   indrec_.storage_weight_requirement := rec_.storage_weight_requirement IS NOT NULL;
   indrec_.min_storage_temperature := rec_.min_storage_temperature IS NOT NULL;
   indrec_.max_storage_temperature := rec_.max_storage_temperature IS NOT NULL;
   indrec_.min_storage_humidity := rec_.min_storage_humidity IS NOT NULL;
   indrec_.max_storage_humidity := rec_.max_storage_humidity IS NOT NULL;
   indrec_.standard_putaway_qty := rec_.standard_putaway_qty IS NOT NULL;
   indrec_.putaway_zone_refill_option := rec_.putaway_zone_refill_option IS NOT NULL;
   indrec_.reset_config_std_cost := rec_.reset_config_std_cost IS NOT NULL;
   indrec_.mandatory_expiration_date := rec_.mandatory_expiration_date IS NOT NULL;
   indrec_.excl_ship_pack_proposal := rec_.excl_ship_pack_proposal IS NOT NULL;
   indrec_.statistical_code := rec_.statistical_code IS NOT NULL;
   indrec_.acquisition_origin := rec_.acquisition_origin IS NOT NULL;
   indrec_.acquisition_reason_id := rec_.acquisition_reason_id IS NOT NULL;
   RETURN indrec_;
END Get_Indicator_Rec___;


FUNCTION Get_Indicator_Rec___ (
   oldrec_ IN inventory_part_tab%ROWTYPE,
   newrec_ IN inventory_part_tab%ROWTYPE ) RETURN Indicator_Rec
IS
   indrec_ Indicator_Rec;
BEGIN
   indrec_.contract := Validate_SYS.Is_Changed(oldrec_.contract, newrec_.contract);
   indrec_.part_no := Validate_SYS.Is_Changed(oldrec_.part_no, newrec_.part_no);
   indrec_.accounting_group := Validate_SYS.Is_Changed(oldrec_.accounting_group, newrec_.accounting_group);
   indrec_.asset_class := Validate_SYS.Is_Changed(oldrec_.asset_class, newrec_.asset_class);
   indrec_.country_of_origin := Validate_SYS.Is_Changed(oldrec_.country_of_origin, newrec_.country_of_origin);
   indrec_.hazard_code := Validate_SYS.Is_Changed(oldrec_.hazard_code, newrec_.hazard_code);
   indrec_.note_id := Validate_SYS.Is_Changed(oldrec_.note_id, newrec_.note_id);
   indrec_.part_product_code := Validate_SYS.Is_Changed(oldrec_.part_product_code, newrec_.part_product_code);
   indrec_.part_product_family := Validate_SYS.Is_Changed(oldrec_.part_product_family, newrec_.part_product_family);
   indrec_.part_status := Validate_SYS.Is_Changed(oldrec_.part_status, newrec_.part_status);
   indrec_.planner_buyer := Validate_SYS.Is_Changed(oldrec_.planner_buyer, newrec_.planner_buyer);
   indrec_.prime_commodity := Validate_SYS.Is_Changed(oldrec_.prime_commodity, newrec_.prime_commodity);
   indrec_.second_commodity := Validate_SYS.Is_Changed(oldrec_.second_commodity, newrec_.second_commodity);
   indrec_.unit_meas := Validate_SYS.Is_Changed(oldrec_.unit_meas, newrec_.unit_meas);
   indrec_.catch_unit_meas := Validate_SYS.Is_Changed(oldrec_.catch_unit_meas, newrec_.catch_unit_meas);
   indrec_.description := Validate_SYS.Is_Changed(oldrec_.description, newrec_.description);
   indrec_.abc_class := Validate_SYS.Is_Changed(oldrec_.abc_class, newrec_.abc_class);
   indrec_.abc_class_locked_until := Validate_SYS.Is_Changed(oldrec_.abc_class_locked_until, newrec_.abc_class_locked_until);
   indrec_.count_variance := Validate_SYS.Is_Changed(oldrec_.count_variance, newrec_.count_variance);
   indrec_.create_date := Validate_SYS.Is_Changed(oldrec_.create_date, newrec_.create_date);
   indrec_.cycle_code := Validate_SYS.Is_Changed(oldrec_.cycle_code, newrec_.cycle_code);
   indrec_.cycle_period := Validate_SYS.Is_Changed(oldrec_.cycle_period, newrec_.cycle_period);
   indrec_.dim_quality := Validate_SYS.Is_Changed(oldrec_.dim_quality, newrec_.dim_quality);
   indrec_.durability_day := Validate_SYS.Is_Changed(oldrec_.durability_day, newrec_.durability_day);
   indrec_.expected_leadtime := Validate_SYS.Is_Changed(oldrec_.expected_leadtime, newrec_.expected_leadtime);
   indrec_.last_activity_date := Validate_SYS.Is_Changed(oldrec_.last_activity_date, newrec_.last_activity_date);
   indrec_.lead_time_code := Validate_SYS.Is_Changed(oldrec_.lead_time_code, newrec_.lead_time_code);
   indrec_.manuf_leadtime := Validate_SYS.Is_Changed(oldrec_.manuf_leadtime, newrec_.manuf_leadtime);
   indrec_.note_text := Validate_SYS.Is_Changed(oldrec_.note_text, newrec_.note_text);
   indrec_.oe_alloc_assign_flag := Validate_SYS.Is_Changed(oldrec_.oe_alloc_assign_flag, newrec_.oe_alloc_assign_flag);
   indrec_.onhand_analysis_flag := Validate_SYS.Is_Changed(oldrec_.onhand_analysis_flag, newrec_.onhand_analysis_flag);
   indrec_.purch_leadtime := Validate_SYS.Is_Changed(oldrec_.purch_leadtime, newrec_.purch_leadtime);
   indrec_.earliest_ultd_supply_date := Validate_SYS.Is_Changed(oldrec_.earliest_ultd_supply_date, newrec_.earliest_ultd_supply_date);
   indrec_.supersedes := Validate_SYS.Is_Changed(oldrec_.supersedes, newrec_.supersedes);
   indrec_.supply_code := Validate_SYS.Is_Changed(oldrec_.supply_code, newrec_.supply_code);
   indrec_.type_code := Validate_SYS.Is_Changed(oldrec_.type_code, newrec_.type_code);
   indrec_.customs_stat_no := Validate_SYS.Is_Changed(oldrec_.customs_stat_no, newrec_.customs_stat_no);
   indrec_.type_designation := Validate_SYS.Is_Changed(oldrec_.type_designation, newrec_.type_designation);
   indrec_.zero_cost_flag := Validate_SYS.Is_Changed(oldrec_.zero_cost_flag, newrec_.zero_cost_flag);
   indrec_.avail_activity_status := Validate_SYS.Is_Changed(oldrec_.avail_activity_status, newrec_.avail_activity_status);
   indrec_.eng_attribute := Validate_SYS.Is_Changed(oldrec_.eng_attribute, newrec_.eng_attribute);
   indrec_.shortage_flag := Validate_SYS.Is_Changed(oldrec_.shortage_flag, newrec_.shortage_flag);
   indrec_.forecast_consumption_flag := Validate_SYS.Is_Changed(oldrec_.forecast_consumption_flag, newrec_.forecast_consumption_flag);
   indrec_.stock_management := Validate_SYS.Is_Changed(oldrec_.stock_management, newrec_.stock_management);
   indrec_.intrastat_conv_factor := Validate_SYS.Is_Changed(oldrec_.intrastat_conv_factor, newrec_.intrastat_conv_factor);
   indrec_.part_cost_group_id := Validate_SYS.Is_Changed(oldrec_.part_cost_group_id, newrec_.part_cost_group_id);
   indrec_.dop_connection := Validate_SYS.Is_Changed(oldrec_.dop_connection, newrec_.dop_connection);
   indrec_.std_name_id := Validate_SYS.Is_Changed(oldrec_.std_name_id, newrec_.std_name_id);
   indrec_.inventory_valuation_method := Validate_SYS.Is_Changed(oldrec_.inventory_valuation_method, newrec_.inventory_valuation_method);
   indrec_.negative_on_hand := Validate_SYS.Is_Changed(oldrec_.negative_on_hand, newrec_.negative_on_hand);
   indrec_.technical_coordinator_id := Validate_SYS.Is_Changed(oldrec_.technical_coordinator_id, newrec_.technical_coordinator_id);
   indrec_.invoice_consideration := Validate_SYS.Is_Changed(oldrec_.invoice_consideration, newrec_.invoice_consideration);
   indrec_.actual_cost_activated := Validate_SYS.Is_Changed(oldrec_.actual_cost_activated, newrec_.actual_cost_activated);
   indrec_.max_actual_cost_update := Validate_SYS.Is_Changed(oldrec_.max_actual_cost_update, newrec_.max_actual_cost_update);
   indrec_.cust_warranty_id := Validate_SYS.Is_Changed(oldrec_.cust_warranty_id, newrec_.cust_warranty_id);
   indrec_.sup_warranty_id := Validate_SYS.Is_Changed(oldrec_.sup_warranty_id, newrec_.sup_warranty_id);
   indrec_.region_of_origin := Validate_SYS.Is_Changed(oldrec_.region_of_origin, newrec_.region_of_origin);
   indrec_.inventory_part_cost_level := Validate_SYS.Is_Changed(oldrec_.inventory_part_cost_level, newrec_.inventory_part_cost_level);
   indrec_.ext_service_cost_method := Validate_SYS.Is_Changed(oldrec_.ext_service_cost_method, newrec_.ext_service_cost_method);
   indrec_.supply_chain_part_group := Validate_SYS.Is_Changed(oldrec_.supply_chain_part_group, newrec_.supply_chain_part_group);
   indrec_.automatic_capability_check := Validate_SYS.Is_Changed(oldrec_.automatic_capability_check, newrec_.automatic_capability_check);
   indrec_.input_unit_meas_group_id := Validate_SYS.Is_Changed(oldrec_.input_unit_meas_group_id, newrec_.input_unit_meas_group_id);
   indrec_.dop_netting := Validate_SYS.Is_Changed(oldrec_.dop_netting, newrec_.dop_netting);
   indrec_.co_reserve_onh_analys_flag := Validate_SYS.Is_Changed(oldrec_.co_reserve_onh_analys_flag, newrec_.co_reserve_onh_analys_flag);
   indrec_.qty_calc_rounding := Validate_SYS.Is_Changed(oldrec_.qty_calc_rounding, newrec_.qty_calc_rounding);
   indrec_.lifecycle_stage := Validate_SYS.Is_Changed(oldrec_.lifecycle_stage, newrec_.lifecycle_stage);
   indrec_.life_stage_locked_until := Validate_SYS.Is_Changed(oldrec_.life_stage_locked_until, newrec_.life_stage_locked_until);
   indrec_.frequency_class := Validate_SYS.Is_Changed(oldrec_.frequency_class, newrec_.frequency_class);
   indrec_.freq_class_locked_until := Validate_SYS.Is_Changed(oldrec_.freq_class_locked_until, newrec_.freq_class_locked_until);
   indrec_.first_stat_issue_date := Validate_SYS.Is_Changed(oldrec_.first_stat_issue_date, newrec_.first_stat_issue_date);
   indrec_.latest_stat_issue_date := Validate_SYS.Is_Changed(oldrec_.latest_stat_issue_date, newrec_.latest_stat_issue_date);
   indrec_.decline_date := Validate_SYS.Is_Changed(oldrec_.decline_date, newrec_.decline_date);
   indrec_.expired_date := Validate_SYS.Is_Changed(oldrec_.expired_date, newrec_.expired_date);
   indrec_.decline_issue_counter := Validate_SYS.Is_Changed(oldrec_.decline_issue_counter, newrec_.decline_issue_counter);
   indrec_.expired_issue_counter := Validate_SYS.Is_Changed(oldrec_.expired_issue_counter, newrec_.expired_issue_counter);
   indrec_.min_durab_days_co_deliv := Validate_SYS.Is_Changed(oldrec_.min_durab_days_co_deliv, newrec_.min_durab_days_co_deliv);
   indrec_.min_durab_days_planning := Validate_SYS.Is_Changed(oldrec_.min_durab_days_planning, newrec_.min_durab_days_planning);
   indrec_.storage_width_requirement := Validate_SYS.Is_Changed(oldrec_.storage_width_requirement, newrec_.storage_width_requirement);
   indrec_.storage_height_requirement := Validate_SYS.Is_Changed(oldrec_.storage_height_requirement, newrec_.storage_height_requirement);
   indrec_.storage_depth_requirement := Validate_SYS.Is_Changed(oldrec_.storage_depth_requirement, newrec_.storage_depth_requirement);
   indrec_.storage_volume_requirement := Validate_SYS.Is_Changed(oldrec_.storage_volume_requirement, newrec_.storage_volume_requirement);
   indrec_.storage_weight_requirement := Validate_SYS.Is_Changed(oldrec_.storage_weight_requirement, newrec_.storage_weight_requirement);
   indrec_.min_storage_temperature := Validate_SYS.Is_Changed(oldrec_.min_storage_temperature, newrec_.min_storage_temperature);
   indrec_.max_storage_temperature := Validate_SYS.Is_Changed(oldrec_.max_storage_temperature, newrec_.max_storage_temperature);
   indrec_.min_storage_humidity := Validate_SYS.Is_Changed(oldrec_.min_storage_humidity, newrec_.min_storage_humidity);
   indrec_.max_storage_humidity := Validate_SYS.Is_Changed(oldrec_.max_storage_humidity, newrec_.max_storage_humidity);
   indrec_.standard_putaway_qty := Validate_SYS.Is_Changed(oldrec_.standard_putaway_qty, newrec_.standard_putaway_qty);
   indrec_.putaway_zone_refill_option := Validate_SYS.Is_Changed(oldrec_.putaway_zone_refill_option, newrec_.putaway_zone_refill_option);
   indrec_.reset_config_std_cost := Validate_SYS.Is_Changed(oldrec_.reset_config_std_cost, newrec_.reset_config_std_cost);
   indrec_.mandatory_expiration_date := Validate_SYS.Is_Changed(oldrec_.mandatory_expiration_date, newrec_.mandatory_expiration_date);
   indrec_.excl_ship_pack_proposal := Validate_SYS.Is_Changed(oldrec_.excl_ship_pack_proposal, newrec_.excl_ship_pack_proposal);
   indrec_.statistical_code := Validate_SYS.Is_Changed(oldrec_.statistical_code, newrec_.statistical_code);
   indrec_.acquisition_origin := Validate_SYS.Is_Changed(oldrec_.acquisition_origin, newrec_.acquisition_origin);
   indrec_.acquisition_reason_id := Validate_SYS.Is_Changed(oldrec_.acquisition_reason_id, newrec_.acquisition_reason_id);
   RETURN indrec_;
END Get_Indicator_Rec___;


PROCEDURE Prepare_New___ (
   newrec_ IN OUT NOCOPY inventory_part_tab%ROWTYPE )
IS
   attr_    VARCHAR2(32000);
   indrec_  Indicator_Rec;
BEGIN
   attr_ := Pack___(newrec_);
   Prepare_Insert___(attr_);
   Unpack___(newrec_, indrec_, attr_);
END Prepare_New___;


PROCEDURE New___ (
   newrec_ IN OUT NOCOPY inventory_part_tab%ROWTYPE )
IS
   objid_         VARCHAR2(20);
   objversion_    VARCHAR2(100);
   attr_          VARCHAR2(32000);
   indrec_        Indicator_Rec;
BEGIN
   indrec_ := Get_Indicator_Rec___(newrec_);
   Check_Insert___(newrec_, indrec_, attr_);
   Insert___(objid_, objversion_, newrec_, attr_);
END New___;


PROCEDURE Delete___ (
   remrec_ IN inventory_part_tab%ROWTYPE )
IS
BEGIN
   Delete___(NULL, remrec_);
END Delete___;


PROCEDURE Remove___ (
   remrec_         IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   lock_mode_wait_ IN     BOOLEAN DEFAULT TRUE )
IS
   oldrec_     inventory_part_tab%ROWTYPE;
BEGIN
   IF (lock_mode_wait_) THEN
      oldrec_ := Lock_By_Keys___(remrec_.contract, remrec_.part_no);
   ELSE
      oldrec_ := Lock_By_Keys_Nowait___(remrec_.contract, remrec_.part_no);
   END IF;
   Check_Delete___(oldrec_);
   Delete___(NULL, oldrec_);
END Remove___;

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC PUBLIC METHODS -----------------------------
-----------------------------------------------------------------------------

--@IgnoreMissingSysinit
FUNCTION Get_Std_Name_Id (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   
   FUNCTION Base (
      contract_ IN VARCHAR2,
      part_no_ IN VARCHAR2 ) RETURN NUMBER
   IS
      temp_ inventory_part_tab.std_name_id%TYPE;
   BEGIN
      IF (contract_ IS NULL OR part_no_ IS NULL) THEN
         RETURN NULL;
      END IF;
      SELECT std_name_id
         INTO  temp_
         FROM  inventory_part_tab
         WHERE contract = contract_
         AND   part_no = part_no_;
      RETURN temp_;
   EXCEPTION
      WHEN no_data_found THEN
         RETURN NULL;
      WHEN too_many_rows THEN
         Raise_Too_Many_Rows___(contract_, part_no_, 'Get_Std_Name_Id');
   END Base;

   FUNCTION Core (
      contract_ IN VARCHAR2,
      part_no_  IN VARCHAR2 ) RETURN NUMBER
   IS   
   BEGIN
      RETURN NVL(Base(contract_, part_no_),Part_Catalog_API.Get_Std_Name_Id(part_no_));
   END Core;

BEGIN
   RETURN Core(contract_, part_no_);
END Get_Std_Name_Id;


--@IgnoreMissingSysinit
FUNCTION Get_Storage_Width_Requirement (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   
   FUNCTION Base (
      contract_ IN VARCHAR2,
      part_no_ IN VARCHAR2 ) RETURN NUMBER
   IS
   BEGIN
      IF (contract_ IS NULL OR part_no_ IS NULL) THEN
         RETURN NULL;
      END IF;
      Update_Cache___(contract_, part_no_);
      RETURN micro_cache_value_.storage_width_requirement;
   END Base;

   FUNCTION Core (
      contract_ IN VARCHAR2,
      part_no_  IN VARCHAR2 ) RETURN NUMBER
   IS
      storage_width_requirement_ inventory_part_tab.storage_width_requirement%TYPE;
      site_length_uom_           VARCHAR2(30);
      part_length_uom_           VARCHAR2(30);
   BEGIN
      storage_width_requirement_ := Base(contract_, part_no_);
   
      IF micro_cache_value_.unit_meas = Part_Catalog_API.Get_Unit_Code(part_no_) THEN
         IF (storage_width_requirement_ IS NULL) THEN
            storage_width_requirement_ := Part_Catalog_Invent_Attrib_API.Get_Storage_Width_Requirement(part_no_);
            IF storage_width_requirement_ IS NOT NULL THEN
               site_length_uom_ := Company_Invent_Info_API.Get_Uom_For_Length(Site_API.Get_Company(contract_));
               part_length_uom_ := Part_Catalog_Invent_Attrib_API.Get_Uom_For_Length(part_no_);
               IF part_length_uom_ IS NULL THEN
                  part_length_uom_ := Storage_Capacity_Req_Group_API.Get_Uom_For_Length(
                                            Part_Catalog_Invent_Attrib_API.Get_Capacity_Req_Group_Id(part_no_));
               END IF;
               -- IF the uom on site (company) is different from the one on Part Catalog or Capacity Requirement Group
               -- the width needs to be converted to the uom on site
               IF site_length_uom_ != part_length_uom_ THEN
                  storage_width_requirement_ := ROUND(Iso_Unit_API.Get_Unit_Converted_Quantity(storage_width_requirement_,
                                                                                               part_length_uom_,
                                                                                               site_length_uom_), 4);
               END IF;
            END IF;
         END IF;
      END IF;
      RETURN (storage_width_requirement_);
   END Core;

BEGIN
   RETURN Core(contract_, part_no_);
END Get_Storage_Width_Requirement;


--@IgnoreMissingSysinit
FUNCTION Get_Storage_Height_Requirement (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   
   FUNCTION Base (
      contract_ IN VARCHAR2,
      part_no_ IN VARCHAR2 ) RETURN NUMBER
   IS
   BEGIN
      IF (contract_ IS NULL OR part_no_ IS NULL) THEN
         RETURN NULL;
      END IF;
      Update_Cache___(contract_, part_no_);
      RETURN micro_cache_value_.storage_height_requirement;
   END Base;

   FUNCTION Core (
      contract_ IN VARCHAR2,
      part_no_  IN VARCHAR2 ) RETURN NUMBER
   IS
      storage_height_requirement_ inventory_part_tab.storage_height_requirement%TYPE;
      site_length_uom_            VARCHAR2(30);
      part_length_uom_            VARCHAR2(30);
   BEGIN
      storage_height_requirement_ := Base(contract_, part_no_);
   
      IF micro_cache_value_.unit_meas = Part_Catalog_API.Get_Unit_Code(part_no_) THEN
         IF (storage_height_requirement_ IS NULL) THEN
            storage_height_requirement_ := Part_Catalog_Invent_Attrib_API.Get_Storage_Height_Requirement(part_no_);
            IF storage_height_requirement_ IS NOT NULL THEN
               site_length_uom_ := Company_Invent_Info_API.Get_Uom_For_Length(Site_API.Get_Company(contract_));
               part_length_uom_ := Part_Catalog_Invent_Attrib_API.Get_Uom_For_Length(part_no_);
               IF part_length_uom_ IS NULL THEN
                  part_length_uom_ := Storage_Capacity_Req_Group_API.Get_Uom_For_Length(
                                            Part_Catalog_Invent_Attrib_API.Get_Capacity_Req_Group_Id(part_no_));
               END IF;
               -- IF the uom on site (company) is different from the one on Part Catalog or Capacity Requirement Group
               -- the height needs to be converted to the uom on site
               IF site_length_uom_ != part_length_uom_ THEN
                  storage_height_requirement_ := ROUND(Iso_Unit_API.Get_Unit_Converted_Quantity(storage_height_requirement_,
                                                                                                part_length_uom_,
                                                                                                site_length_uom_), 4);
               END IF;
            END IF;
         END IF;
      END IF;
      RETURN (storage_height_requirement_);
   END Core;

BEGIN
   RETURN Core(contract_, part_no_);
END Get_Storage_Height_Requirement;


--@IgnoreMissingSysinit
FUNCTION Get_Storage_Depth_Requirement (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   
   FUNCTION Base (
      contract_ IN VARCHAR2,
      part_no_ IN VARCHAR2 ) RETURN NUMBER
   IS
   BEGIN
      IF (contract_ IS NULL OR part_no_ IS NULL) THEN
         RETURN NULL;
      END IF;
      Update_Cache___(contract_, part_no_);
      RETURN micro_cache_value_.storage_depth_requirement;
   END Base;

   FUNCTION Core (
      contract_ IN VARCHAR2,
      part_no_  IN VARCHAR2 ) RETURN NUMBER
   IS
      storage_depth_requirement_ inventory_part_tab.storage_depth_requirement%TYPE;
      site_length_uom_           VARCHAR2(30);
      part_length_uom_           VARCHAR2(30);
   BEGIN
      storage_depth_requirement_ := Base(contract_, part_no_);
   
      IF micro_cache_value_.unit_meas = Part_Catalog_API.Get_Unit_Code(part_no_) THEN
         IF (storage_depth_requirement_ IS NULL) THEN
            storage_depth_requirement_ := Part_Catalog_Invent_Attrib_API.Get_Storage_Depth_Requirement(part_no_);
            IF storage_depth_requirement_ IS NOT NULL THEN
               site_length_uom_ := Company_Invent_Info_API.Get_Uom_For_Length(Site_API.Get_Company(contract_));
               part_length_uom_ := Part_Catalog_Invent_Attrib_API.Get_Uom_For_Length(part_no_);
               IF part_length_uom_ IS NULL THEN
                  part_length_uom_ := Storage_Capacity_Req_Group_API.Get_Uom_For_Length(
                                            Part_Catalog_Invent_Attrib_API.Get_Capacity_Req_Group_Id(part_no_));
               END IF;
               -- IF the uom on site (company) is different from the one on Part Catalog or Capacity Requirement Group
               -- the depth needs to be converted to the uom on site
               IF site_length_uom_ != part_length_uom_ THEN
                  storage_depth_requirement_ := ROUND(Iso_Unit_API.Get_Unit_Converted_Quantity(storage_depth_requirement_,
                                                                                               part_length_uom_,
                                                                                               site_length_uom_), 4);
               END IF;
            END IF;
         END IF;
      END IF;
      RETURN (storage_depth_requirement_);
   END Core;

BEGIN
   RETURN Core(contract_, part_no_);
END Get_Storage_Depth_Requirement;


--@IgnoreMissingSysinit
FUNCTION Get_Storage_Volume_Requirement (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   
   FUNCTION Base (
      contract_ IN VARCHAR2,
      part_no_ IN VARCHAR2 ) RETURN NUMBER
   IS
   BEGIN
      IF (contract_ IS NULL OR part_no_ IS NULL) THEN
         RETURN NULL;
      END IF;
      Update_Cache___(contract_, part_no_);
      RETURN micro_cache_value_.storage_volume_requirement;
   END Base;

   FUNCTION Core (
      contract_ IN VARCHAR2,
      part_no_  IN VARCHAR2 ) RETURN NUMBER
   IS
      storage_volume_requirement_ inventory_part_tab.storage_volume_requirement%TYPE;
      invpart_volume_uom_         VARCHAR2(30);
      partca_volume_uom_          VARCHAR2(30);
   BEGIN
      storage_volume_requirement_ := Base(contract_, part_no_);
   
      IF micro_cache_value_.unit_meas = Part_Catalog_API.Get_Unit_Code(part_no_) THEN
         IF (storage_volume_requirement_ IS NULL) THEN
            storage_volume_requirement_ := Part_Catalog_Invent_Attrib_API.Get_Storage_Volume_Requirement(part_no_);
            IF storage_volume_requirement_ IS NOT NULL THEN
               invpart_volume_uom_ := Site_Invent_Info_API.Get_Volume_Uom(contract_);  -- can be null if length uom + 3 becomes an invalid uom
               partca_volume_uom_  := Part_Catalog_Invent_Attrib_API.Get_Uom_For_Volume(part_no_);
               IF partca_volume_uom_ IS NULL THEN
                  partca_volume_uom_ := Storage_Capacity_Req_Group_API.Get_Uom_For_Volume(
                                            Part_Catalog_Invent_Attrib_API.Get_Capacity_Req_Group_Id(part_no_));
               END IF;
               IF invpart_volume_uom_ IS NULL THEN
                  storage_volume_requirement_ := NULL;
               -- IF the volume uom on inventory part client is different from the one on Part Catalog or Capacity Requirement Group
               -- the volume needs to be converted to the uom on site
               ELSIF invpart_volume_uom_ != partca_volume_uom_ THEN
                  storage_volume_requirement_ := Iso_Unit_API.Get_Unit_Converted_Quantity(storage_volume_requirement_,
                                                                                                partca_volume_uom_,
                                                                                                invpart_volume_uom_);
               END IF;
            END IF;
         END IF;
      END IF;
      RETURN (storage_volume_requirement_);
   END Core;

BEGIN
   RETURN Core(contract_, part_no_);
END Get_Storage_Volume_Requirement;


--@IgnoreMissingSysinit
FUNCTION Get_Storage_Weight_Requirement (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   
   FUNCTION Base (
      contract_ IN VARCHAR2,
      part_no_ IN VARCHAR2 ) RETURN NUMBER
   IS
   BEGIN
      IF (contract_ IS NULL OR part_no_ IS NULL) THEN
         RETURN NULL;
      END IF;
      Update_Cache___(contract_, part_no_);
      RETURN micro_cache_value_.storage_weight_requirement;
   END Base;

   FUNCTION Core (
      contract_ IN VARCHAR2,
      part_no_  IN VARCHAR2 ) RETURN NUMBER
   IS
      storage_weight_requirement_ inventory_part_tab.storage_weight_requirement%TYPE;
      site_weight_uom_            VARCHAR2(30);
      part_weight_uom_            VARCHAR2(30);
   BEGIN
      storage_weight_requirement_ := Base(contract_, part_no_);
   
      IF micro_cache_value_.unit_meas = Part_Catalog_API.Get_Unit_Code(part_no_) THEN
         IF (storage_weight_requirement_ IS NULL) THEN
            storage_weight_requirement_ := Part_Catalog_Invent_Attrib_API.Get_Storage_Weight_Requirement(part_no_);
            IF storage_weight_requirement_ IS NOT NULL THEN
               site_weight_uom_ := Company_Invent_Info_API.Get_Uom_For_Weight(Site_API.Get_Company(contract_));
               part_weight_uom_ := Part_Catalog_Invent_Attrib_API.Get_Uom_For_Weight(part_no_);
               IF part_weight_uom_ IS NULL THEN
                  part_weight_uom_ := Storage_Capacity_Req_Group_API.Get_Uom_For_Weight(
                                               Part_Catalog_Invent_Attrib_API.Get_Capacity_Req_Group_Id(part_no_));
               END IF;
               -- IF the uom on site (company) is different from the one on Part Catalog or Capacity Requirement Group
               -- the weight needs to be converted to the uom on site
               IF site_weight_uom_ != part_weight_uom_ THEN
                  storage_weight_requirement_ := ROUND(Iso_Unit_API.Get_Unit_Converted_Quantity(storage_weight_requirement_,
                                                                                                part_weight_uom_,
                                                                                                site_weight_uom_), 4);
   
               END IF;
            END IF;
         END IF;
      END IF;
      RETURN (storage_weight_requirement_);
   END Core;

BEGIN
   RETURN Core(contract_, part_no_);
END Get_Storage_Weight_Requirement;


--@IgnoreMissingSysinit
FUNCTION Get_Min_Storage_Temperature (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   
   FUNCTION Base (
      contract_ IN VARCHAR2,
      part_no_ IN VARCHAR2 ) RETURN NUMBER
   IS
   BEGIN
      IF (contract_ IS NULL OR part_no_ IS NULL) THEN
         RETURN NULL;
      END IF;
      Update_Cache___(contract_, part_no_);
      RETURN micro_cache_value_.min_storage_temperature;
   END Base;

   FUNCTION Core (
      contract_ IN VARCHAR2,
      part_no_  IN VARCHAR2 ) RETURN NUMBER
   IS
      min_storage_temperature_ inventory_part_tab.min_storage_temperature%TYPE;
      site_temp_uom_           VARCHAR2(30);
      part_temp_uom_           VARCHAR2(30);
   BEGIN
      min_storage_temperature_ := Base(contract_, part_no_);
   
      IF (min_storage_temperature_ IS NULL) THEN
         min_storage_temperature_ := Part_Catalog_Invent_Attrib_API.Get_Min_Storage_Temperature(part_no_);
         IF min_storage_temperature_ IS NOT NULL THEN
            site_temp_uom_ := Company_Invent_Info_API.Get_Uom_For_Temperature(Site_API.Get_Company(contract_));
            part_temp_uom_ := Part_Catalog_Invent_Attrib_API.Get_Uom_For_Temperature(part_no_);
            IF part_temp_uom_ IS NULL THEN
               part_temp_uom_ := Storage_Cond_Req_Group_API.Get_Uom_For_Temperature(
                                          Part_Catalog_Invent_Attrib_API.Get_Condition_Req_Group_Id(part_no_));
            END IF;
            -- IF the uom on site (company) is different from the one on Part Catalog or Condition Requirement Group
            -- temperature needs to be converted to the uom on site
            IF site_temp_uom_ != part_temp_uom_ THEN
               min_storage_temperature_ := ROUND(Iso_Unit_API.Get_Unit_Converted_Quantity(min_storage_temperature_,
                                                                                          part_temp_uom_,
                                                                                          site_temp_uom_), 4);
            END IF;
         END IF;
      END IF;
      RETURN (min_storage_temperature_);
   END Core;

BEGIN
   RETURN Core(contract_, part_no_);
END Get_Min_Storage_Temperature;


--@IgnoreMissingSysinit
FUNCTION Get_Max_Storage_Temperature (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   
   FUNCTION Base (
      contract_ IN VARCHAR2,
      part_no_ IN VARCHAR2 ) RETURN NUMBER
   IS
   BEGIN
      IF (contract_ IS NULL OR part_no_ IS NULL) THEN
         RETURN NULL;
      END IF;
      Update_Cache___(contract_, part_no_);
      RETURN micro_cache_value_.max_storage_temperature;
   END Base;

   FUNCTION Core (
      contract_ IN VARCHAR2,
      part_no_  IN VARCHAR2 ) RETURN NUMBER
   IS
      max_storage_temperature_ inventory_part_tab.max_storage_temperature%TYPE;
      site_temp_uom_           VARCHAR2(30);
      part_temp_uom_           VARCHAR2(30);
   BEGIN
      max_storage_temperature_ := Base(contract_, part_no_);
   
      IF (max_storage_temperature_ IS NULL) THEN
         max_storage_temperature_ := Part_Catalog_Invent_Attrib_API.Get_Max_Storage_Temperature(part_no_);
         IF max_storage_temperature_ IS NOT NULL THEN
            site_temp_uom_ := Company_Invent_Info_API.Get_Uom_For_Temperature(Site_API.Get_Company(contract_));
            part_temp_uom_ := Part_Catalog_Invent_Attrib_API.Get_Uom_For_Temperature(part_no_);
            IF part_temp_uom_ IS NULL THEN
               part_temp_uom_ := Storage_Cond_Req_Group_API.Get_Uom_For_Temperature(
                                        Part_Catalog_Invent_Attrib_API.Get_Condition_Req_Group_Id(part_no_));
            END IF;
            -- IF the uom on site (company) is different from the one on Part Catalog or Condition Requirement Group 
            -- temperature needs to be converted to the uom on site
            IF site_temp_uom_ != part_temp_uom_ THEN
               max_storage_temperature_ := ROUND(Iso_Unit_API.Get_Unit_Converted_Quantity(max_storage_temperature_,
                                                                                          part_temp_uom_,
                                                                                          site_temp_uom_), 4);
            END IF;
         END IF;
      END IF;
      RETURN (max_storage_temperature_);
   END Core;

BEGIN
   RETURN Core(contract_, part_no_);
END Get_Max_Storage_Temperature;


--@IgnoreMissingSysinit
FUNCTION Get_Min_Storage_Humidity (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   
   FUNCTION Base (
      contract_ IN VARCHAR2,
      part_no_ IN VARCHAR2 ) RETURN NUMBER
   IS
   BEGIN
      IF (contract_ IS NULL OR part_no_ IS NULL) THEN
         RETURN NULL;
      END IF;
      Update_Cache___(contract_, part_no_);
      RETURN micro_cache_value_.min_storage_humidity;
   END Base;

   FUNCTION Core (
      contract_ IN VARCHAR2,
      part_no_  IN VARCHAR2 ) RETURN NUMBER
   IS
      min_storage_humidity_ inventory_part_tab.min_storage_humidity%TYPE;
   BEGIN
      min_storage_humidity_ := Base(contract_, part_no_);
   
      IF (min_storage_humidity_ IS NULL) THEN
         min_storage_humidity_ := Part_Catalog_Invent_Attrib_API.Get_Min_Storage_Humidity(part_no_);
      END IF;
      RETURN (min_storage_humidity_);
   END Core;

BEGIN
   RETURN Core(contract_, part_no_);
END Get_Min_Storage_Humidity;


--@IgnoreMissingSysinit
FUNCTION Get_Max_Storage_Humidity (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   
   FUNCTION Base (
      contract_ IN VARCHAR2,
      part_no_ IN VARCHAR2 ) RETURN NUMBER
   IS
   BEGIN
      IF (contract_ IS NULL OR part_no_ IS NULL) THEN
         RETURN NULL;
      END IF;
      Update_Cache___(contract_, part_no_);
      RETURN micro_cache_value_.max_storage_humidity;
   END Base;

   FUNCTION Core (
      contract_ IN VARCHAR2,
      part_no_  IN VARCHAR2 ) RETURN NUMBER
   IS
      max_storage_humidity_ inventory_part_tab.max_storage_humidity%TYPE;
   BEGIN
      max_storage_humidity_ := Base(contract_, part_no_);
   
      IF (max_storage_humidity_ IS NULL) THEN
         max_storage_humidity_ := Part_Catalog_Invent_Attrib_API.Get_Max_Storage_Humidity(part_no_);
      END IF;
      RETURN (max_storage_humidity_);
   END Core;

BEGIN
   RETURN Core(contract_, part_no_);
END Get_Max_Storage_Humidity;


--@IgnoreMissingSysinit
FUNCTION Get_Superseded_By (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ VARCHAR2(25);
   CURSOR get_attr IS
      SELECT part_no
       FROM inventory_part_tab
      WHERE contract   = contract_
        AND supersedes = part_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Superseded_By;


--@IgnoreMissingSysinit
FUNCTION Get_Volume_Net (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   CURSOR get_values IS
      SELECT t.unit_meas, t.input_unit_meas_group_id
      FROM Inventory_Part_Tab t
      WHERE t.contract = contract_
      AND t.part_no = part_no_;

   value_rec_                 get_values%ROWTYPE;
   con_factor_for_invent_uom_ NUMBER := 0;
   converted_qty_             NUMBER := 0;
BEGIN
   OPEN get_values;
   FETCH get_values INTO value_rec_;
   CLOSE get_values;
   
   IF (value_rec_.unit_meas = Part_Catalog_Api.Get_Unit_Code(part_no_)) THEN
      -- if the part cat and the invent part has same UoM both implies 1 qty in same UoM.
      converted_qty_ := 1;
   END IF;

   -- Note : no need to consider Input UoM group .. because always if a Input UoM Grp. is there invent and partcat has same UoM.
   
   IF (converted_qty_ = 0) THEN
   -- Check the convertion factor in the unit relationships
      con_factor_for_invent_uom_ := Technical_Unit_Conv_API.Get_Valid_Conv_Factor( Part_Catalog_Api.Get_Unit_Code(part_no_), value_rec_.unit_meas);
      IF (con_factor_for_invent_uom_ IS NOT NULL) THEN
          converted_qty_ := 1 / con_factor_for_invent_uom_;
      END IF;
   END IF;
   -- IF no convertion found returned value will be 0
   RETURN (converted_qty_ * Iso_Unit_API.Get_Unit_Converted_Quantity(Part_Catalog_API.Get_Volume_Net(part_no_),
                                                                     Part_Catalog_API.Get_Uom_For_Volume_Net(part_no_),
                                                                     Company_Invent_Info_API.Get_Uom_For_Volume(Site_API.Get_Company(contract_))));
END Get_Volume_Net;


--@IgnoreMissingSysinit
FUNCTION Get_Weight_Net (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   partca_rec_                Part_Catalog_API.Public_Rec;
   unit_meas_                 inventory_part_tab.unit_meas%TYPE;
   con_factor_for_invent_uom_ NUMBER := 0;
   converted_qty_             NUMBER := 0;
   weight_net_                NUMBER;
   comp_uom_for_weight_       VARCHAR2(30);
BEGIN
   partca_rec_ := Part_Catalog_API.Get(part_no_);
   unit_meas_  := Get_Unit_Meas(contract_, part_no_);
   
   IF (partca_rec_.unit_code = unit_meas_) THEN
      -- if the part cat and the invent part has same UoM both implies 1 qty in same UoM.
      converted_qty_ := 1;
   END IF;

   -- Note : no need to consider Input UoM group .. because always if a Input UoM Grp. is there invent and partcat has same UoM.
   IF (converted_qty_ = 0) THEN
   -- Check the convertion factor in the unit relationships
      con_factor_for_invent_uom_ := Technical_Unit_Conv_API.Get_Valid_Conv_Factor( partca_rec_.unit_code, unit_meas_);
      IF (con_factor_for_invent_uom_ IS NOT NULL) THEN
          converted_qty_ := 1 / con_factor_for_invent_uom_;
      END IF;
   END IF;

   comp_uom_for_weight_ := Company_Invent_Info_API.Get_Uom_For_Weight(Site_API.Get_Company(contract_));
   IF (partca_rec_.uom_for_weight_net = comp_uom_for_weight_) THEN
      weight_net_ := converted_qty_ * partca_rec_.weight_net;
   ELSE
      weight_net_ := converted_qty_ * Iso_Unit_API.Get_Unit_Converted_Quantity(partca_rec_.weight_net,
                                                                               partca_rec_.uom_for_weight_net,
                                                                               comp_uom_for_weight_);
   END IF;
   -- IF no convertion found returned value will be 0
   RETURN weight_net_;
END Get_Weight_Net;


--@IgnoreMissingSysinit
FUNCTION Check_Stored (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   temp_  NUMBER;
   CURSOR get_attr IS
      SELECT 1
      FROM   inventory_part_tab
      WHERE  contract = contract_
      AND    part_no = part_no_;
BEGIN
   OPEN  get_attr;
   FETCH get_attr INTO temp_;
   IF (get_attr%NOTFOUND) THEN
      temp_ := 0;
   END IF;
   CLOSE get_attr;
   RETURN (temp_ = 1);
END Check_Stored;


--@IgnoreMissingSysinit
FUNCTION Count_Sites (
   part_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   CURSOR count_sites is
      SELECT count(*)
      FROM  inventory_part_tab
      WHERE part_no = part_no_;
   no_of_sites_ NUMBER;
BEGIN
   OPEN count_sites;
   FETCH count_sites into no_of_sites_;
   CLOSE count_sites;
   RETURN no_of_sites_;
END Count_Sites;


--@IgnoreMissingSysinit
FUNCTION Check_Exist_Anywhere (
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   dummy_ NUMBER;
   CURSOR exist_control IS
      SELECT 1
      FROM   inventory_part_tab
      WHERE  part_no = part_no_;
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RETURN 'TRUE';
   END IF;
   CLOSE exist_control;
   RETURN 'FALSE';
END Check_Exist_Anywhere;


--@IgnoreMissingSysinit
FUNCTION Check_Exist (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   RETURN Check_Exist___(contract_,part_no_);
END Check_Exist;


--@IgnoreMissingSysinit
FUNCTION Check_If_Purchased (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_  inventory_part_tab.type_code%TYPE;
   CURSOR get_attr IS
      SELECT type_code
      FROM   inventory_part_tab
      WHERE  contract = contract_
      AND    part_no = part_no_;
BEGIN
   OPEN  get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   IF temp_ IN ('3','4') THEN
      RETURN part_no_;
   ELSE
      RETURN NULL;
   END IF;
END Check_If_Purchased;


--@IgnoreMissingSysinit
FUNCTION Check_Any_Forecast_Part_Exist(
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   $IF (Component_Demand_SYS.INSTALLED) $THEN
      RETURN  Forecast_Part_Util_API.Check_Any_Forecast_Part_Exist(contract_, part_no_);
   $ELSE
      RETURN 'FALSE';
   $END
END Check_Any_Forecast_Part_Exist;


--@IgnoreMissingSysinit
FUNCTION Part_Exist (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   IF Check_Exist___(contract_, part_no_) THEN
      RETURN 1;
   ELSE
      RETURN 0;
   END IF;
END Part_Exist;


--@IgnoreMissingSysinit
FUNCTION Document_Connected (
    contract_ IN VARCHAR2,
    part_no_  IN VARCHAR2) RETURN BOOLEAN
IS
   obj_ref_exists_     VARCHAR2(5);
   document_connected_ BOOLEAN := FALSE;
   key_ref_            VARCHAR2(2000);
BEGIN
   $IF (Component_Docman_SYS.INSTALLED) $THEN

      key_ref_ := Client_SYS.Get_Key_Reference(lu_name_,
                                                    'CONTRACT', contract_,
                                                    'PART_NO',  part_no_);
      obj_ref_exists_ := Doc_Reference_Object_API.Exist_Obj_Reference(lu_name_, key_ref_);      

      IF (obj_ref_exists_ = 'TRUE') THEN
         document_connected_ := TRUE;
      END IF;
   $END
   RETURN (document_connected_);
END Document_Connected;


--@IgnoreMissingSysinit
PROCEDURE Get_Values_For_Accounting (
   type_code_           OUT NOCOPY VARCHAR2,
   prime_commodity_     OUT NOCOPY VARCHAR2,
   second_commodity_    OUT NOCOPY VARCHAR2,
   asset_class_         OUT NOCOPY VARCHAR2,
   abc_class_           OUT NOCOPY VARCHAR2,
   engineering_group_   OUT NOCOPY VARCHAR2,
   planner_buyer_       OUT NOCOPY VARCHAR2,
   accounting_group_    OUT NOCOPY VARCHAR2,
   part_product_family_ OUT NOCOPY VARCHAR2,
   part_product_code_   OUT NOCOPY VARCHAR2,
   contract_            IN  VARCHAR2,
   part_no_             IN  VARCHAR2 )
IS
BEGIN
   Update_Cache___(contract_, part_no_);

   type_code_           := micro_cache_value_.type_code;
   prime_commodity_     := micro_cache_value_.prime_commodity;
   second_commodity_    := micro_cache_value_.second_commodity;
   asset_class_         := micro_cache_value_.asset_class;
   abc_class_           := micro_cache_value_.abc_class;
   engineering_group_   := NULL;
   planner_buyer_       := micro_cache_value_.planner_buyer;
   accounting_group_    := micro_cache_value_.accounting_group;
   part_product_family_ := micro_cache_value_.part_product_family;
   part_product_code_   := micro_cache_value_.part_product_code;
END Get_Values_For_Accounting;


--@IgnoreMissingSysinit
FUNCTION Get_Inventory_Value_By_Method (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   RETURN Inventory_Part_Unit_Cost_API.Get_Inventory_Value_By_Method(contract_,
                                                                     part_no_,
                                                                     NULL,
                                                                     NULL,
                                                                     NULL);
END Get_Inventory_Value_By_Method;


PROCEDURE Modify_Abc_Frequency_Lifecycle (
   contract_           IN VARCHAR2,
   part_no_            IN VARCHAR2,
   abc_class_          IN VARCHAR2,
   frequency_class_db_ IN VARCHAR2,
   lifecycle_stage_db_ IN VARCHAR2 )
IS
   newrec_         inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Abc_Frequency_Lifecycle');
   newrec_ := Lock_By_Keys___(contract_, part_no_);
   IF (abc_class_ != newrec_.abc_class) THEN
      newrec_.abc_class              := abc_class_;
      newrec_.abc_class_locked_until := NULL;
   END IF;

   IF (frequency_class_db_ != newrec_.frequency_class) THEN
      newrec_.frequency_class         := frequency_class_db_;
      newrec_.freq_class_locked_until := NULL;
   END IF;

   IF (lifecycle_stage_db_ != newrec_.lifecycle_stage) THEN
      newrec_.lifecycle_stage         := lifecycle_stage_db_;
      newrec_.life_stage_locked_until := NULL;
   END IF;
   Modify___(newrec_);
END Modify_Abc_Frequency_Lifecycle;


PROCEDURE Modify_Counted_Part (
   contract_       IN VARCHAR2,
   part_no_        IN VARCHAR2,
   count_variance_ IN NUMBER )
IS
   newrec_              inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Counted_Part');
   newrec_ := Lock_By_Keys___(contract_, part_no_);
   newrec_.count_variance := NVL(newrec_.count_variance, 0) + NVL(count_variance_, 0);
   Modify___(newrec_);
END Modify_Counted_Part;


PROCEDURE Modify_Purch_Leadtime (
   contract_       IN VARCHAR2,
   part_no_        IN VARCHAR2,
   purch_leadtime_ IN NUMBER )
IS
   newrec_             inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Purch_Leadtime');
   newrec_ := Get_Object_By_Keys___(contract_, part_no_);
   IF (newrec_.purch_leadtime != purch_leadtime_) THEN
      newrec_ := Lock_By_Keys___(contract_, part_no_);
      --Check the condition again to make sure that it hasn't been modified by someone else
      IF (newrec_.purch_leadtime != purch_leadtime_) THEN
         newrec_.purch_leadtime := purch_leadtime_;
         Modify___(newrec_);
      END IF;
   END IF;
END Modify_Purch_Leadtime;


PROCEDURE Modify_Expected_Leadtime (
   contract_          IN VARCHAR2,
   part_no_           IN VARCHAR2,
   expected_leadtime_ IN NUMBER )
IS
   newrec_ inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Expected_Leadtime');
   newrec_ := Lock_By_Keys___(contract_, part_no_);
   newrec_.expected_leadtime := expected_leadtime_;
   Modify___(newrec_);
END Modify_Expected_Leadtime;


PROCEDURE Modify_Part_Product_Code (
   contract_          IN VARCHAR2,
   part_no_           IN VARCHAR2,
   part_product_code_ IN VARCHAR2 )
IS
   newrec_ inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Part_Product_Code');
   newrec_ := Lock_By_Keys___(contract_, part_no_);
   newrec_.part_product_code := part_product_code_;
   Modify___(newrec_);
END Modify_Part_Product_Code;


PROCEDURE Modify_Part_Product_Family (
   contract_            IN VARCHAR2,
   part_no_             IN VARCHAR2,
   part_product_family_ IN VARCHAR2 )
IS
   newrec_ inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Part_Product_Family');
   newrec_ := Lock_By_Keys___(contract_, part_no_);
   newrec_.part_product_family := part_product_family_;
   Modify___(newrec_);
END Modify_Part_Product_Family;


PROCEDURE Recalc_Stockfactors (
   contract_         IN VARCHAR2,
   second_commodity_ IN VARCHAR2,
   periods_          IN NUMBER )
IS
   attrib_       VARCHAR2(32000);
   batch_desc_   VARCHAR2(100);
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Recalc_Stockfactors');
   -- IF site is not given all user allowed sites are to be processed.
   IF contract_ IS NOT NULL THEN
      Site_API.Exist(contract_);
      User_Allowed_Site_API.Exist(Fnd_Session_API.Get_Fnd_User, contract_);
   END IF;

   -- IF second commodity is not given, all second commoditys are to be processed.
   IF second_commodity_ IS NOT NULL THEN
      Commodity_Group_API.Exist(second_commodity_, true);
   END IF;

   IF (periods_ < 1) OR (trunc(periods_) != periods_) THEN
      Error_Sys.Record_General(lu_name_,'PERIODS_NA: Only positive integers are valid.');
   END IF;

   Client_SYS.Clear_Attr(attrib_);
   Client_SYS.Add_To_Attr('CONTRACT', contract_, attrib_);
   Client_SYS.Add_To_Attr('SECOND_COMMODITY', second_commodity_, attrib_);
   Client_SYS.Add_To_Attr('PERIODS', periods_, attrib_);
   Trace_SYS.Message('TRACE => attrib_ = '||attrib_);
   batch_desc_:= Language_SYS.Translate_Constant(lu_name_,'BDESCCAPD: Calculate Planning Data');
   Transaction_SYS.Deferred_Call('INVENTORY_PART_API.Recalc_Stockfactors_Impl__' ,attrib_,batch_desc_);
END Recalc_Stockfactors;


PROCEDURE Get_Production_Flags (
   lead_time_code_  OUT VARCHAR2,
   manuf_leadtime_  OUT NUMBER,
   purch_leadtime_  OUT NUMBER,
   planning_method_ OUT VARCHAR2,
   supply_code_     OUT VARCHAR2,
   type_code_       OUT VARCHAR2,
   unit_meas_       OUT VARCHAR2,
   contract_        IN  VARCHAR2,
   part_no_         IN  VARCHAR2 )
IS
   lu_rec_ inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Get_Production_Flags');
   lu_rec_ := Get_Object_By_Keys___(contract_, part_no_);
   lead_time_code_  := lu_rec_.lead_time_code;
   manuf_leadtime_  := lu_rec_.manuf_leadtime;
   purch_leadtime_  := lu_rec_.purch_leadtime;
   planning_method_ := Get_Planning_Method___(contract_, part_no_);
   supply_code_     := lu_rec_.supply_code;
   type_code_       := lu_rec_.type_code;
   unit_meas_       := lu_rec_.unit_meas;
END Get_Production_Flags;


PROCEDURE New_Part (
   contract_                      IN VARCHAR2,
   part_no_                       IN VARCHAR2,
   accounting_group_              IN VARCHAR2,
   asset_class_                   IN VARCHAR2,
   country_of_origin_             IN VARCHAR2,
   hazard_code_                   IN VARCHAR2,
   part_product_code_             IN VARCHAR2,
   part_product_family_           IN VARCHAR2,
   part_status_                   IN VARCHAR2,
   planner_buyer_                 IN VARCHAR2,
   prime_commodity_               IN VARCHAR2,
   second_commodity_              IN VARCHAR2,
   unit_meas_                     IN VARCHAR2,
   description_                   IN VARCHAR2,
   abc_class_                     IN VARCHAR2,
   count_variance_                IN NUMBER,
   create_date_                   IN DATE,
   cycle_code_                    IN VARCHAR2,
   cycle_period_                  IN NUMBER,
   dim_quality_                   IN VARCHAR2,
   durability_day_                IN NUMBER,
   expected_leadtime_             IN NUMBER,
   inactive_obs_flag_             IN VARCHAR2,
   last_activity_date_            IN DATE,
   lead_time_code_                IN VARCHAR2,
   manuf_leadtime_                IN NUMBER,
   note_text_                     IN VARCHAR2,
   oe_alloc_assign_flag_          IN VARCHAR2,
   onhand_analysis_flag_          IN VARCHAR2,
   purch_leadtime_                IN NUMBER,
   supersedes_                    IN VARCHAR2,
   supply_code_                   IN VARCHAR2,
   type_code_                     IN VARCHAR2,
   customs_stat_no_               IN VARCHAR2,
   type_designation_              IN VARCHAR2,
   zero_cost_flag_                IN VARCHAR2,
   avail_activity_status_         IN VARCHAR2,
   eng_attribute_                 IN VARCHAR2,
   forecast_consumption_flag_     IN VARCHAR2 DEFAULT NULL,
   intrastat_conv_factor_         IN NUMBER DEFAULT NULL,
   invoice_consideration_         IN VARCHAR2 DEFAULT NULL,
   max_actual_cost_update_        IN NUMBER DEFAULT NULL,
   shortage_flag_                 IN VARCHAR2 DEFAULT NULL,
   inventory_part_cost_level_     IN VARCHAR2 DEFAULT NULL,
   std_name_id_                   IN NUMBER DEFAULT NULL,
   input_unit_meas_group_id_      IN VARCHAR2 DEFAULT NULL,
   dop_connection_                IN VARCHAR2 DEFAULT NULL,
   supply_chain_part_group_       IN VARCHAR2 DEFAULT NULL,
   ext_service_cost_method_       IN VARCHAR2 DEFAULT NULL,
   stock_management_              IN VARCHAR2 DEFAULT NULL,
   technical_coordinator_id_      IN VARCHAR2 DEFAULT NULL,
   sup_warranty_id_               IN NUMBER DEFAULT NULL,
   cust_warranty_id_              IN NUMBER DEFAULT NULL,
   estimated_material_cost_       IN NUMBER DEFAULT NULL,
   automatic_capability_check_    IN VARCHAR2 DEFAULT NULL,
   create_purchase_part_          IN VARCHAR2 DEFAULT 'TRUE',
   inventory_valuation_method_    IN VARCHAR2 DEFAULT NULL,
   negative_on_hand_              IN VARCHAR2 DEFAULT NULL,
   create_part_planning_          IN VARCHAR2 DEFAULT 'TRUE',
   catch_unit_meas_               IN VARCHAR2 DEFAULT NULL,
   part_cost_group_id_            IN VARCHAR2 DEFAULT NULL,
   qty_calc_rounding_             IN NUMBER DEFAULT NULL,
   min_durab_days_co_deliv_       IN NUMBER DEFAULT NULL,
   min_durab_days_planning_       IN NUMBER DEFAULT NULL,
   storage_width_requirement_     IN NUMBER DEFAULT NULL,
   storage_height_requirement_    IN NUMBER DEFAULT NULL,
   storage_depth_requirement_     IN NUMBER DEFAULT NULL,
   storage_volume_requirement_    IN NUMBER DEFAULT NULL,
   storage_weight_requirement_    IN NUMBER DEFAULT NULL,
   min_storage_temperature_       IN NUMBER DEFAULT NULL,
   max_storage_temperature_       IN NUMBER DEFAULT NULL,
   min_storage_humidity_          IN NUMBER DEFAULT NULL,
   max_storage_humidity_          IN NUMBER DEFAULT NULL,
   standard_putaway_qty_          IN NUMBER DEFAULT NULL,
   putaway_zone_refill_option_    IN VARCHAR2 DEFAULT NULL,
   dop_netting_db_                IN VARCHAR2 DEFAULT NULL,
   reset_config_std_cost_db_      IN VARCHAR2 DEFAULT NULL,
   co_reserve_onh_analys_flag_db_ IN VARCHAR2 DEFAULT NULL,
   mandatory_expiration_date_db_  IN VARCHAR2 DEFAULT NULL,
   region_of_origin_              IN VARCHAR2 DEFAULT NULL,
   statistical_code_              IN VARCHAR2 DEFAULT NULL,
   acquisition_origin_            IN NUMBER DEFAULT NULL,
   acquisition_reason_id_         IN VARCHAR2 DEFAULT NULL)
IS
   newrec_       inventory_part_tab%ROWTYPE;
   objid_        INVENTORY_PART.objid%TYPE;
   objversion_   INVENTORY_PART.objversion%TYPE;
   attr_         VARCHAR2(32000);
   indrec_       Indicator_Rec;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'New_Part');
   Prepare_Insert___(attr_);
   Unpack___(newrec_, indrec_, attr_);

   newrec_.contract                    := NVL(contract_,                      newrec_.contract);
   newrec_.part_no                     := NVL(part_no_,                       newrec_.part_no);
   newrec_.accounting_group            := NVL(accounting_group_,              newrec_.accounting_group);
   newrec_.asset_class                 := NVL(asset_class_,                   newrec_.asset_class);
   newrec_.country_of_origin           := NVL(country_of_origin_,             newrec_.country_of_origin);
   newrec_.hazard_code                 := NVL(hazard_code_,                   newrec_.hazard_code);
   newrec_.part_product_code           := NVL(part_product_code_,             newrec_.part_product_code);
   newrec_.part_product_family         := NVL(part_product_family_,           newrec_.part_product_family);
   newrec_.part_status                 := NVL(part_status_,                   newrec_.part_status);
   newrec_.planner_buyer               := NVL(planner_buyer_,                 newrec_.planner_buyer);
   newrec_.prime_commodity             := NVL(prime_commodity_,               newrec_.prime_commodity);
   newrec_.second_commodity            := NVL(second_commodity_,              newrec_.second_commodity);
   newrec_.unit_meas                   := NVL(unit_meas_,                     newrec_.unit_meas);
   newrec_.description                 := NVL(description_,                   newrec_.description);
   newrec_.cycle_code                  := NVL(Inventory_Part_Count_Type_API.Encode(cycle_code_),                  newrec_.cycle_code);
   newrec_.cycle_period                := NVL(cycle_period_,                  newrec_.cycle_period);
   newrec_.dim_quality                 := NVL(dim_quality_,                   newrec_.dim_quality);
   newrec_.durability_day              := NVL(durability_day_,                newrec_.durability_day);
   newrec_.expected_leadtime           := NVL(expected_leadtime_,             newrec_.expected_leadtime);
   newrec_.lead_time_code              := NVL(Inv_Part_Lead_Time_Code_API.Encode(lead_time_code_),                newrec_.lead_time_code);
   newrec_.manuf_leadtime              := NVL(manuf_leadtime_,                newrec_.manuf_leadtime);
   newrec_.note_text                   := NVL(note_text_,                     newrec_.note_text);
   newrec_.oe_alloc_assign_flag        := NVL(Cust_Ord_Reservation_Type_API.Encode(oe_alloc_assign_flag_),        newrec_.oe_alloc_assign_flag);
   newrec_.onhand_analysis_flag        := NVL(Inventory_Part_Onh_Analys_API.Encode(onhand_analysis_flag_),        newrec_.onhand_analysis_flag);
   newrec_.purch_leadtime              := NVL(purch_leadtime_,                newrec_.purch_leadtime);
   newrec_.supersedes                  := NVl(supersedes_,                    newrec_.supersedes);
   newrec_.supply_code                 := NVL(Material_Requis_Supply_API.Encode(supply_code_),                    newrec_.supply_code);
   newrec_.type_code                   := NVL(Inventory_Part_Type_API.Encode(type_code_),                         newrec_.type_code);
   newrec_.customs_stat_no             := NVL(customs_stat_no_,               newrec_.customs_stat_no);
   newrec_.type_designation            := NVL(type_designation_,              newrec_.type_designation);
   newrec_.zero_cost_flag              := NVL(Inventory_Part_Zero_Cost_API.Encode(zero_cost_flag_),               newrec_.zero_cost_flag);
   newrec_.avail_activity_status       := NVL(Inventory_Part_Avail_Stat_API.Encode(avail_activity_status_),       newrec_.avail_activity_status);
   newrec_.eng_attribute               := NVL(eng_attribute_,                 newrec_.eng_attribute);
   newrec_.forecast_consumption_flag   := NVL(Inv_Part_Forecast_Consum_API.Encode(forecast_consumption_flag_),    Inv_Part_Forecast_Consum_API.DB_NO_ONLINE_CONSUMPTION);
   newrec_.intrastat_conv_factor       := NVL(intrastat_conv_factor_,         newrec_.intrastat_conv_factor);
   newrec_.invoice_consideration       := NVL(Invoice_Consideration_API.Encode(invoice_consideration_),           newrec_.invoice_consideration);
   newrec_.max_actual_cost_update      := NVL(max_actual_cost_update_,        newrec_.max_actual_cost_update);
   newrec_.shortage_flag               := NVL(Inventory_Part_Shortage_API.Encode(shortage_flag_),                 newrec_.shortage_flag);
   newrec_.inventory_part_cost_level   := NVL(Inventory_Part_Cost_Level_API.Encode(inventory_part_cost_level_),   newrec_.inventory_part_cost_level);
   newrec_.std_name_id                 := NVL(std_name_id_,                   newrec_.std_name_id);
   newrec_.input_unit_meas_group_id    := NVL(input_unit_meas_group_id_,      newrec_.input_unit_meas_group_id);
   newrec_.dop_connection              := NVL(Dop_Connection_API.Encode(dop_connection_),                         newrec_.dop_connection);
   newrec_.supply_chain_part_group     := NVL(supply_chain_part_group_,       newrec_.supply_chain_part_group);
   newrec_.ext_service_cost_method     := NVL(Ext_Service_Cost_Method_API.Encode(ext_service_cost_method_),       newrec_.ext_service_cost_method);
   newrec_.stock_management            := NVL(Inventory_Part_Management_API.Encode(stock_management_),            newrec_.stock_management);
   newrec_.technical_coordinator_id    := NVL(technical_coordinator_id_,      newrec_.technical_coordinator_id);
   newrec_.sup_warranty_id             := NVL(sup_warranty_id_,               newrec_.sup_warranty_id);
   newrec_.cust_warranty_id            := NVL(cust_warranty_id_,              newrec_.cust_warranty_id);
   newrec_.automatic_capability_check  := NVL(Capability_Check_Allocate_API.Encode(automatic_capability_check_),  newrec_.automatic_capability_check);
   newrec_.inventory_valuation_method  := NVL(Inventory_Value_Method_API.Encode(inventory_valuation_method_),     newrec_.inventory_valuation_method);
   newrec_.negative_on_hand            := NVL(Negative_On_Hand_API.Encode(negative_on_hand_),                     newrec_.negative_on_hand);
   newrec_.catch_unit_meas             := NVL(catch_unit_meas_,               newrec_.catch_unit_meas);
   newrec_.part_cost_group_id          := NVL(part_cost_group_id_,            newrec_.part_cost_group_id);
   newrec_.min_durab_days_co_deliv     := NVL(min_durab_days_co_deliv_,       newrec_.min_durab_days_co_deliv);
   newrec_.qty_calc_rounding           := NVL(qty_calc_rounding_,             newrec_.qty_calc_rounding);
   newrec_.min_durab_days_planning     := NVL(min_durab_days_planning_,       newrec_.min_durab_days_planning);
   newrec_.storage_width_requirement   := NVL(storage_width_requirement_,     newrec_.storage_width_requirement);
   newrec_.storage_height_requirement  := NVL(storage_height_requirement_,    newrec_.storage_height_requirement);
   newrec_.storage_depth_requirement   := NVL(storage_depth_requirement_,     newrec_.storage_depth_requirement);
   newrec_.storage_volume_requirement  := NVL(storage_volume_requirement_,    newrec_.storage_volume_requirement);
   newrec_.storage_weight_requirement  := NVL(storage_weight_requirement_,    newrec_.storage_weight_requirement);
   newrec_.min_storage_temperature     := NVL(min_storage_temperature_,       newrec_.min_storage_temperature);
   newrec_.max_storage_temperature     := NVL(max_storage_temperature_,       newrec_.max_storage_temperature);
   newrec_.min_storage_humidity        := NVL(min_storage_humidity_,          newrec_.min_storage_humidity);
   newrec_.max_storage_humidity        := NVL(max_storage_humidity_,          newrec_.max_storage_humidity);
   newrec_.standard_putaway_qty        := NVL(standard_putaway_qty_,          newrec_.standard_putaway_qty);
   newrec_.putaway_zone_refill_option  := NVL(Putaway_Zone_Refill_Option_API.Encode(putaway_zone_refill_option_), newrec_.putaway_zone_refill_option );
   newrec_.dop_netting                 := NVL(dop_netting_db_,                newrec_.dop_netting);
   newrec_.reset_config_std_cost       := NVL(reset_config_std_cost_db_,      newrec_.reset_config_std_cost);
   newrec_.co_reserve_onh_analys_flag  := NVL(co_reserve_onh_analys_flag_db_, newrec_.co_reserve_onh_analys_flag);
   newrec_.mandatory_expiration_date   := NVL(mandatory_expiration_date_db_,  newrec_.mandatory_expiration_date);
   newrec_.region_of_origin            := NVL(region_of_origin_,              newrec_.region_of_origin);
   newrec_.abc_class                   := NVL(abc_class_,                     newrec_.abc_class);
   -- gelr: good_service_statistical_code, acquisition_origin and  brazilian_specific_attributes added to newrec_.
   newrec_.statistical_code            := NVL(statistical_code_,              newrec_.statistical_code);
   newrec_.acquisition_origin          := NVL(acquisition_origin_,            newrec_.acquisition_origin);
   newrec_.acquisition_reason_id       := NVL(acquisition_reason_id_,         newrec_.acquisition_reason_id);

   Client_SYS.Clear_Attr(attr_);
   IF (estimated_material_cost_ IS NOT NULL) THEN
      Client_SYS.Set_Item_Value('ESTIMATED_MATERIAL_COST', estimated_material_cost_, attr_);
   END IF;
   indrec_ := Get_Indicator_Rec___(newrec_);
   Check_Insert___(newrec_, indrec_, attr_);
   Insert___(objid_, objversion_, newrec_, attr_, create_purchase_part_, create_part_planning_);
END New_Part;


PROCEDURE Qty_To_Order (
   requisition_no_  IN OUT NOCOPY VARCHAR2,
   qty_ordered_     IN OUT NOCOPY NUMBER,
   disp_qty_onhand_ IN OUT NOCOPY NUMBER,
   contract_        IN     VARCHAR2,
   part_no_         IN     VARCHAR2,
   date_required_   IN     DATE,
   type_code_       IN     VARCHAR2,
   lu_req_exist_    IN     BOOLEAN,
   lu_shp_exist_    IN     BOOLEAN,
   create_req_      IN     NUMBER,
   authorize_code_  IN     VARCHAR2,
   order_point_qty_ IN     NUMBER )
IS
   stmt_                VARCHAR2(2000);
   planning_method_     VARCHAR2(1);
   unit_meas_           VARCHAR2(10);
   lot_size_            NUMBER;
   lot_count_           NUMBER;
   line_no_             NUMBER;
   order_code_          VARCHAR2(3);
   requisition_code_    VARCHAR2(20);
   demand_code_         VARCHAR2(200);
   release_no_          VARCHAR2(4);
   use_split_           BOOLEAN := FALSE;
   qty_to_make_         NUMBER;
   qty_to_buy_          NUMBER;
   wanted_receipt_date_ DATE;
   lead_time_code_db_   VARCHAR2(20);
   date_req_            DATE;
   nulln_               NUMBER;
   calendar_id_         VARCHAR2(10);
   part_planning_rec_   Inventory_Part_Planning_API.Public_Rec;
   inventory_part_rec_  inventory_part_tab%ROWTYPE;
   multi_site_planned_  VARCHAR2(50);
   primary_supplier_    VARCHAR2(100);
   planned_due_date_    DATE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Qty_To_Order');
   line_no_            := 0;
   inventory_part_rec_ := Get_Object_By_Keys___(contract_, part_no_);
   unit_meas_          := inventory_part_rec_.unit_meas;
   lead_time_code_db_  := inventory_part_rec_.lead_time_code;

   part_planning_rec_  := Inventory_Part_Planning_API.Get(contract_, part_no_);
   planning_method_    := part_planning_rec_.planning_method;
   lot_size_           := part_planning_rec_.lot_size;

   date_req_ := date_required_;
   Trace_SYS.Message('Date required: '||date_req_);
   calendar_id_ := Site_API.Get_Dist_Calendar_Id (contract_);
   Trace_SYS.Message('after site calendar id');

   -- Is_Working_Day returns 0 if FALSE
   IF (Work_Time_Calendar_API.Is_Working_Day(calendar_id_, date_req_ ) = 0) THEN
      Trace_SYS.Message('working day');

      date_req_ := Work_Time_Calendar_API.Get_Previous_Work_Day(calendar_id_,date_req_);
      Trace_SYS.Message('previous work day '||date_req_);

      IF (date_req_ IS NULL) THEN
         Error_SYS.Record_General(lu_name_, 'NOT_IN_CAL_QORD: Retrieving next work day from :P1 failed. The date is outside the interval of the calendar :P2.', to_char(date_req_, 'YYYY-MM-DD'), calendar_id_);
      END IF;
      Trace_SYS.Message('Adjusted Date required: '||date_req_);
   END IF;

   IF (planning_method_ = 'B') THEN
      IF (lot_size_ = 0) THEN
         lot_size_ := 1;
      END IF;
      lot_count_ := 1;
      -- Round result of shrinkage to the most conservative number with 12 decimals.
      WHILE (trunc((lot_count_ * lot_size_ + disp_qty_onhand_), 12) < order_point_qty_) LOOP
         lot_count_ := lot_count_ + 1;
      END LOOP;
      qty_ordered_ := lot_count_ * lot_size_;
   ELSIF (planning_method_ = 'C') THEN
      qty_ordered_ := GREATEST(lot_size_, order_point_qty_) - disp_qty_onhand_;
   END IF;

   qty_ordered_ := qty_ordered_ / (1 - (part_planning_rec_.shrinkage_fac / 100));

   IF create_req_ = 1 THEN
      -- Check if make/buy split
      -- Purchase Requistion and Shop Order Requisition must have been installed in order to
      -- split between Purch/Shpord
      IF part_planning_rec_.split_manuf_acquired = 'SPLIT' AND lu_req_exist_ AND
         lu_shp_exist_ THEN
         use_split_ := TRUE;
         IF lead_time_code_db_ = 'P' THEN
            -- split for manufactured
            qty_to_make_ := part_planning_rec_.percent_manufactured/100 * qty_ordered_;
            qty_to_buy_  := qty_ordered_ - qty_to_make_;
         ELSE
            -- split for purchased
            qty_to_buy_  := part_planning_rec_.percent_acquired/100 * qty_ordered_;
            qty_to_make_ := qty_ordered_ - qty_to_buy_;
         END IF;
      ELSE
         IF lead_time_code_db_ = 'P' THEN
            qty_to_buy_  := qty_ordered_;
         ELSE
            qty_to_make_ := qty_ordered_;
         END IF;
      END IF;

      qty_to_buy_  := Get_Calc_Rounded_Qty(contract_, part_no_, qty_to_buy_);
      qty_to_make_ := Get_Calc_Rounded_Qty(contract_, part_no_, qty_to_make_);

      disp_qty_onhand_ := disp_qty_onhand_ + qty_ordered_;
      wanted_receipt_date_ := date_req_; -- Do not keep changing this to order_date_ because it's wrong!
      Trace_SYS.Message('wanted receipt date '||wanted_receipt_date_);

      -- IF order_requisition_ is set we will create an order directly without
      -- passing requisitions or collecting $200.
      Trace_SYS.Field('lead_time_code_db_',lead_time_code_db_);

      requisition_code_ := Mpccom_Defaults_API.Get_Char_Value('ORDPNT', 'REQUISITION_HEADER', 'REQUISITIONER_CODE');

      IF use_split_ THEN
         IF lu_shp_exist_ AND part_planning_rec_.manuf_supply_type IN ('R','O') THEN
            stmt_ :=
              'BEGIN
                  Shop_Order_Prop_API.Generate_Proposal
                    (:requisition_no, :part_no, :contract,
                     :nulln1, :wanted_receipt_date, :original_qty,
                     Shop_Proposal_Type_API.Decode(''INV''));
               END;';

            --@ApproveDynamicStatement(2006-05-31,mushlk)
            EXECUTE IMMEDIATE stmt_
               USING OUT requisition_no_,
                     IN  part_no_,
                     IN  contract_,
                     IN  nulln_,
                     IN  wanted_receipt_date_,
                     IN  qty_to_make_;
         ELSIF part_planning_rec_.manuf_supply_type = 'S' THEN
            Error_SYS.Record_General(lu_name_, 'INVALID_SUPPLY_TYPE: Invalid supply type for part :P1. Supply type :P2 is not allowed.',
                                     part_no_, Inventory_Part_Supply_Type_API.Decode(part_planning_rec_.manuf_supply_type));
         END IF;
         IF lu_req_exist_ AND part_planning_rec_.acquired_supply_type = 'O' THEN
            stmt_ := '
               DECLARE
                  primary_supplier_ VARCHAR2(100);
               BEGIN
                  primary_supplier_ := Purchase_Part_Supplier_API.Get_Primary_Supplier_No(:contract, :part_no);
                  :multi_site_planned := Purchase_Part_Supplier_API.Get_Multisite_Planned_Part_Db(:contract, :part_no, primary_supplier_);
                  :primary_supplier := primary_supplier_;
               END;';

            --@ApproveDynamicStatement(2006-01-23,nidalk)
            EXECUTE IMMEDIATE stmt_
               USING IN  contract_,
                     IN  part_no_,
                     OUT multi_site_planned_,
                     OUT primary_supplier_;

            IF (nvl(multi_site_planned_, Database_SYS.string_null_) = 'MULTISITE_PLAN') THEN
               -- Create DO
               $IF (Component_Disord_SYS.INSTALLED) $THEN
                  Distribution_Order_API.Create_Distribution_Order(planned_due_date_,
                                                                   requisition_no_,
                                                                   qty_to_buy_,
                                                                   Supplier_API.Get_Acquisition_Site(primary_supplier_),
                                                                   contract_,
                                                                   part_no_,
                                                                   requisition_code_,
                                                                   NULL,
                                                                   wanted_receipt_date_);
               $ELSE
                  Add_To_Purchase_Order___(requisition_no_, contract_, part_no_, qty_to_buy_, unit_meas_, wanted_receipt_date_, authorize_code_);
               $END               
            ELSE
               -- Create PO
               Add_To_Purchase_Order___(requisition_no_, contract_, part_no_, qty_to_buy_, unit_meas_, wanted_receipt_date_, authorize_code_);
            END IF;
         ELSIF lu_req_exist_ AND part_planning_rec_.acquired_supply_type = 'R' THEN
            -- Create PO requisitions
            IF ((line_no_ = 0) OR (line_no_ >= 9999)) THEN
               line_no_ := 1;
               order_code_ := '1';
               stmt_ := 'BEGIN
                            Purchase_Req_Util_API.New_Requisition(:requisition_no, :order_code, :contract, :requisition_code, :mark_for);
                         END;';
               --@ApproveDynamicStatement(2006-01-23,nidalk)
               EXECUTE IMMEDIATE stmt_
                  USING OUT requisition_no_,
                        IN  order_code_,
                        IN  contract_,
                        IN  requisition_code_,
                        IN  ' ';
            END IF;


            release_no_    := '1';
            demand_code_   := Order_Supply_Type_API.Decode('IO');

            stmt_ := 'BEGIN
                         Purchase_Req_Util_API.New_Line_Part(:line_no, :release_no, :requisition_no,
                           :contract, :part_no, :unit_meas, :original_qty, :wanted_receipt_date,
                           :demand_code);
                      END;';

            --@ApproveDynamicStatement(2006-05-31,mushlk)
            EXECUTE IMMEDIATE stmt_
                  USING IN OUT line_no_,
                        IN OUT release_no_,
                        IN     requisition_no_,
                        IN     contract_,
                        IN     part_no_,
                        IN     unit_meas_,
                        IN     qty_to_buy_,
                        IN     wanted_receipt_date_,
                        IN     demand_code_;

         ELSIF part_planning_rec_.acquired_supply_type = 'S' THEN
            Error_SYS.Record_General(lu_name_, 'INVALID_SUPPLY_TYPE: Invalid supply type for part :P1. Supply type :P2 is not allowed.',
                                     part_no_, Inventory_Part_Supply_Type_API.Decode(part_planning_rec_.acquired_supply_type));
         END IF;
      ELSE
         IF (lu_req_exist_ AND part_planning_rec_.order_requisition = 'O' AND
             lead_time_code_db_ = 'P') THEN
            stmt_ := '
               DECLARE
                  primary_supplier_ VARCHAR2(100);
               BEGIN
                  primary_supplier_ := Purchase_Part_Supplier_API.Get_Primary_Supplier_No(:contract, :part_no);
                  :multi_site_planned := Purchase_Part_Supplier_API.Get_Multisite_Planned_Part_Db(:contract, :part_no, primary_supplier_);
                  :primary_supplier := primary_supplier_;
               END;';

            --@ApproveDynamicStatement(2006-01-23,nidalk)
            EXECUTE IMMEDIATE stmt_
               USING IN  contract_,
                     IN  part_no_,
                     OUT multi_site_planned_,
                     OUT primary_supplier_;

             IF (nvl(multi_site_planned_, Database_SYS.string_null_) = 'MULTISITE_PLAN' ) THEN
                $IF (Component_Disord_SYS.INSTALLED) $THEN
                  Distribution_Order_API.Create_Distribution_Order(planned_due_date_,
                                                                   requisition_no_,
                                                                   qty_to_buy_,
                                                                   Supplier_API.Get_Acquisition_Site(primary_supplier_),
                                                                   contract_,
                                                                   part_no_,
                                                                   requisition_code_,
                                                                   NULL,
                                                                   wanted_receipt_date_);
               $ELSE
                  Add_To_Purchase_Order___(requisition_no_, contract_, part_no_, qty_to_buy_, unit_meas_, wanted_receipt_date_, authorize_code_);
               $END     
             ELSE
               -- SHVE using the same out param requisition_no to return order_no
               Add_To_Purchase_Order___(requisition_no_, contract_, part_no_, qty_to_buy_, unit_meas_, wanted_receipt_date_, authorize_code_);
            END IF;
         ELSIF (lu_req_exist_ AND part_planning_rec_.order_requisition = 'R' AND lead_time_code_db_ = 'P') THEN
            -- Create requisitions
            IF ((line_no_ = 0) OR (line_no_ >= 9999)) THEN
               line_no_ := 1;
               order_code_ := '1';
               stmt_ := 'BEGIN
                            Purchase_Req_Util_API.New_Requisition(:requisition_no, :order_code, :contract, :requisition_code, :mark_for);
                         END;';
               --@ApproveDynamicStatement(2006-01-23,nidalk)
               EXECUTE IMMEDIATE stmt_
                  USING OUT requisition_no_,
                        IN  order_code_,
                        IN  contract_,
                        IN  requisition_code_,
                        IN  ' ';
            END IF;


            release_no_    := '1';
            demand_code_   := Order_Supply_Type_API.Decode('IO');

            stmt_ := 'BEGIN
                         Purchase_Req_Util_API.New_Line_Part(:line_no, :release_no, :requisition_no,
                           :contract, :part_no, :unit_meas, :original_qty, :wanted_receipt_date,
                           :demand_code);
                      END;';

            --@ApproveDynamicStatement(2006-05-31,mushlk)
            EXECUTE IMMEDIATE stmt_
                  USING IN OUT line_no_,
                        IN OUT release_no_,
                        IN     requisition_no_,
                        IN     contract_,
                        IN     part_no_,
                        IN     unit_meas_,
                        IN     qty_to_buy_,
                        IN     wanted_receipt_date_,
                        IN     demand_code_;
         ELSIF (part_planning_rec_.order_requisition = 'S' AND lead_time_code_db_ = 'P') THEN
            Error_SYS.Record_General(lu_name_, 'INVALID_SUPPLY_TYPE: Invalid supply type for part :P1. Supply type :P2 is not allowed.',
                                     part_no_, Inventory_Part_Supply_Type_API.Decode(part_planning_rec_.order_requisition));
         END IF;

         IF (lu_shp_exist_ AND part_planning_rec_.order_requisition IN ('O','R') AND
             lead_time_code_db_ = 'M') THEN
            stmt_ :=
              'BEGIN
                  Shop_Order_Prop_API.Generate_Proposal
                    (:requisition_no, :part_no, :contract,
                     :nulln1, :wanted_receipt_date, :original_qty,
                     Shop_Proposal_Type_API.Decode(''INV''));
               END;';

            --@ApproveDynamicStatement(2006-05-31,mushlk)
            EXECUTE IMMEDIATE stmt_
               USING OUT requisition_no_,
                     IN  part_no_,
                     IN  contract_,
                     IN  nulln_,
                     IN  wanted_receipt_date_,
                     IN  qty_to_make_;
         ELSIF (part_planning_rec_.order_requisition = 'S' AND lead_time_code_db_ = 'M') THEN
            Error_SYS.Record_General(lu_name_, 'INVALID_SUPPLY_TYPE: Invalid supply type for part :P1. Supply type :P2 is not allowed.',
                                     part_no_, Inventory_Part_Supply_Type_API.Decode(part_planning_rec_.order_requisition));
         END IF;
      END IF; -- end if use_split
      Trace_SYS.Message('INVENTORY_PART_API.' || 'Qty_To_Order.' ||
         ' New_requisition_no: ' || requisition_no_ ||
         ' Wanted_receipt_date: ' || to_char(wanted_receipt_date_, 'yyyymmdd') ||
         ' Qty To Order (before shrinkage rounding): '|| qty_ordered_);
   END IF;
END Qty_To_Order;


--@IgnoreMissingSysinit
FUNCTION Check_If_Counting (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   second_commodity_ IN VARCHAR2,
   cycle_code_       IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN NULL;
END Check_If_Counting;


PROCEDURE Set_Avail_Activity_Status (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 )
IS
   newrec_     inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Set_Avail_Activity_Status');
   newrec_ := Get_Object_By_Keys___(contract_, part_no_);
   IF (newrec_.avail_activity_status != 'CHANGED') THEN
      newrec_ := Lock_By_Keys___(contract_, part_no_);
      --Check the condition again to make sure that it hasn't been modified by someone else
      IF (newrec_.avail_activity_status != 'CHANGED') THEN
         newrec_.avail_activity_status := Inventory_Part_Avail_Stat_API.DB_CHANGED;
         Modify___(newrec_);
      END IF;
   END IF;
END Set_Avail_Activity_Status;


PROCEDURE Clear_Avail_Activity_Status (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 )
IS
   newrec_     inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Clear_Avail_Activity_Status');
   newrec_ := Get_Object_By_Keys___(contract_, part_no_);
   IF (newrec_.avail_activity_status != 'UNCHANGED') THEN
      newrec_ := Lock_By_Keys___(contract_, part_no_);
      --Check the condition again to make sure that it hasn't been modified by someone else
      IF (newrec_.avail_activity_status != 'UNCHANGED') THEN
         newrec_.avail_activity_status := Inventory_Part_Avail_Stat_API.DB_UNCHANGED;
         Modify___(newrec_);
      END IF;
   END IF;
END Clear_Avail_Activity_Status;


--@IgnoreMissingSysinit
FUNCTION Get_Stop_Analysis_Date (
   contract_                    IN VARCHAR2,
   part_no_                     IN VARCHAR2,
   site_date_                   IN DATE,
   dist_calendar_id_            IN VARCHAR2,
   manuf_calendar_id_           IN VARCHAR2,
   detect_supplies_not_allowed_ IN VARCHAR2,
   use_expected_leadtime_       IN VARCHAR2 DEFAULT Fnd_Boolean_API.db_true ) RETURN DATE
IS
BEGIN
   Update_Cache___(contract_, part_no_);

   RETURN (Get_Stop_Analysis_Date___(contract_,
                                     part_no_,
                                     site_date_,
                                     dist_calendar_id_,
                                     manuf_calendar_id_,
                                     (detect_supplies_not_allowed_ = Fnd_Boolean_API.db_true),
                                     (use_expected_leadtime_       = Fnd_Boolean_API.db_true),
                                     micro_cache_value_.lead_time_code));
END Get_Stop_Analysis_Date;


--@IgnoreMissingSysinit
FUNCTION Check_If_Manufactured (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ inventory_part_tab.type_code%TYPE;
   CURSOR get_attr IS
      SELECT type_code
      FROM   inventory_part_tab
      WHERE  contract = contract_
      AND    part_no = part_no_;
BEGIN
   OPEN  get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   IF temp_ IN ('1','2') THEN
      RETURN 1;
   ELSE
      RETURN 0;
   END IF;
END Check_If_Manufactured;


PROCEDURE Modify_Manuf_Leadtime (
   contract_       IN VARCHAR2,
   part_no_        IN VARCHAR2,
   manuf_leadtime_ IN NUMBER )
IS
   newrec_  inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Manuf_Leadtime');
   newrec_ := Lock_By_Keys___(contract_, part_no_);
   newrec_.manuf_leadtime := manuf_leadtime_;
   Modify___(newrec_);
END Modify_Manuf_Leadtime;


PROCEDURE Copy (
   new_contract_             IN VARCHAR2,
   new_part_no_              IN VARCHAR2,
   old_contract_             IN VARCHAR2,
   old_part_no_              IN VARCHAR2,
   attr_                     IN VARCHAR2 DEFAULT NULL,
   error_when_no_source_     IN VARCHAR2 DEFAULT 'TRUE',
   error_when_existing_copy_ IN VARCHAR2 DEFAULT 'TRUE',
   create_purchase_part_     IN VARCHAR2 DEFAULT 'TRUE' )
IS
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Copy');
   Copy_Impl___(new_contract_,
                new_part_no_,
                old_contract_,
                old_part_no_,
                attr_,
                error_when_no_source_,
                error_when_existing_copy_,
                create_purchase_part_);
   IF (Check_Exist___(old_contract_, old_part_no_)) THEN
      Inventory_Part_Planning_API.Copy(new_contract_, new_part_no_,
                                       old_contract_, old_part_no_);

      Inventory_Part_Capability_API.Copy(new_contract_, new_part_no_,
                                         old_contract_, old_part_no_);
      
      Invent_Part_Putaway_Zone_API.Copy(new_contract_, new_part_no_,
                                        old_contract_, old_part_no_);
   END IF;
END Copy;


PROCEDURE Copy_Part_To_Site (
   from_contract_         IN VARCHAR2,
   from_second_commodity_ IN VARCHAR2,
   to_contract_           IN VARCHAR2 )
IS
   attrib_     VARCHAR2(32000);
   batch_desc_ VARCHAR2(100);
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Copy_Part_To_Site');
   Site_API.Exist(from_contract_);
   Site_API.Exist(to_contract_);
   User_Allowed_Site_api.Exist(Fnd_Session_API.Get_Fnd_User, from_contract_);
   User_Allowed_Site_api.Exist(Fnd_Session_API.Get_Fnd_User, to_contract_);
   IF from_contract_ = to_contract_ THEN
      Error_SYS.Record_General(lu_name_, 'ERRORSAMECONTRACT: You must select different sites.');
   END IF;

   Commodity_Group_API.Exist_With_Wildcard(NVL(from_second_commodity_, '%'));

   Client_SYS.Clear_Attr(attrib_);
   Client_SYS.Add_To_Attr('FROM_CONTRACT', from_contract_, attrib_);
   Client_SYS.Add_To_Attr('FROM_SECOND_COMMODITY', NVL(from_second_commodity_, '%'), attrib_);
   Client_SYS.Add_To_Attr('TO_CONTRACT', to_contract_, attrib_);
   Trace_SYS.Message('TRACE => attrib_ = '||attrib_);
   batch_desc_:= Language_SYS.Translate_Constant(lu_name_,'BDESCCOPP: Copy Part To Site');
   Transaction_SYS.Deferred_Call('Inventory_Part_API.Copy_Part_To_Site_Impl__', attrib_,batch_desc_);
END Copy_Part_To_Site;


FUNCTION Get_Cumm_Leadtime (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   temp_ NUMBER;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Get_Cumm_Leadtime');
   $IF (Component_Mfgstd_SYS.INSTALLED) $THEN
      temp_ := Manuf_Part_Attribute_API.Get_Cum_Leadtime(contract_, part_no_);
   $END
   RETURN temp_;
END Get_Cumm_Leadtime;


--@IgnoreMissingSysinit
FUNCTION Get_Mrp_Order_Code (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN Get_Planning_Method___(contract_, part_no_);
END Get_Mrp_Order_Code;


--@IgnoreMissingSysinit
FUNCTION Get_No_Of_Purchase_Parts (
   contract_ IN VARCHAR2 ) RETURN NUMBER
IS
   CURSOR get_pur_parts IS
     SELECT COUNT(*)
     FROM inventory_part_tab
     WHERE contract = contract_
     AND   lead_time_code = 'P';
   no_of_pur_parts_ NUMBER;
BEGIN
   OPEN get_pur_parts;
   FETCH get_pur_parts INTO no_of_pur_parts_;
   CLOSE get_pur_parts;
   RETURN no_of_pur_parts_;
END Get_No_Of_Purchase_Parts;


PROCEDURE Calc_Purch_Costs (
   contract_      IN VARCHAR2,
   cost_set_type_ IN VARCHAR2,
   begin_date_    IN DATE,
   end_date_      IN DATE )
IS
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Calc_Purch_Costs');
   Inventory_Part_Config_API.Calc_Purch_Costs(contract_,
                                              cost_set_type_,
                                              begin_date_,
                                              end_date_);
END Calc_Purch_Costs;


PROCEDURE Modify_Part_Cost_Group_Id (
   contract_           IN VARCHAR2,
   part_no_            IN VARCHAR2,
   part_cost_group_id_ IN VARCHAR2 )
IS
   newrec_  inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Part_Cost_Group_Id');
   newrec_ := Lock_By_Keys___(contract_, part_no_);
   newrec_.part_cost_group_id := part_cost_group_id_;
   Modify___(newrec_);
END Modify_Part_Cost_Group_Id;


--@IgnoreMissingSysinit
FUNCTION Get_No_Of_Parts (
   contract_ IN VARCHAR2 ) RETURN NUMBER
IS
   CURSOR get_parts IS
      SELECT COUNT(*)
      FROM inventory_part_tab
      WHERE contract = contract_;
   no_of_parts_ NUMBER;
BEGIN
   OPEN get_parts;
   FETCH get_parts INTO no_of_parts_;
   CLOSE get_parts;
   RETURN no_of_parts_;
END Get_No_Of_Parts;


--@IgnoreMissingSysinit
FUNCTION Get_Invent_Valuation_Method_Db (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.inventory_valuation_method%TYPE;
   CURSOR get_attr IS
      SELECT inventory_valuation_method
      FROM inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Invent_Valuation_Method_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Invent_Part_Cost_Level_Db (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.inventory_part_cost_level%TYPE;
   CURSOR get_attr IS
      SELECT inventory_part_cost_level
      FROM inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Invent_Part_Cost_Level_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Forecast_Consump_Flag_Db (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ inventory_part_tab.forecast_consumption_flag%TYPE;
   CURSOR get_attr IS
      SELECT forecast_consumption_flag
      FROM inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Forecast_Consump_Flag_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Forecast_Trans_Start_Date (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN DATE
IS
BEGIN
   $IF (Component_Demand_SYS.INSTALLED) $THEN
     RETURN  Forecast_Part_Util_API.Get_Latest_Trans_Start_Date(contract_, part_no_);
   $ELSE
     RETURN NULL;
   $END
END Get_Forecast_Trans_Start_Date;


--@IgnoreMissingSysinit
FUNCTION Get_Forecast_Phase_In_Date (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN DATE
IS
BEGIN
   $IF (Component_Demand_SYS.INSTALLED) $THEN
     RETURN  Forecast_Part_Util_API.Get_Latest_Phase_In_Date(contract_, part_no_);
   $ELSE
     RETURN NULL;
   $END
END Get_Forecast_Phase_In_Date;


--@IgnoreMissingSysinit
FUNCTION Get_Forecast_Phase_Out_Date (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN DATE
IS
BEGIN
   $IF (Component_Demand_SYS.INSTALLED) $THEN
     RETURN  Forecast_Part_Util_API.Get_Latest_Phase_Out_Date(contract_, part_no_);
   $ELSE
     RETURN NULL;
   $END
END Get_Forecast_Phase_Out_Date;


--@IgnoreMissingSysinit
FUNCTION Get_Forecast_Service_Level (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   $IF (Component_Demand_SYS.INSTALLED) $THEN
      RETURN  Forecast_Part_Util_API.Get_Master_Flow_Service_Level(contract_, part_no_);
   $ELSE
     RETURN NULL;
   $END
END Get_Forecast_Service_Level;


--@IgnoreMissingSysinit
FUNCTION Get_Forecast_Fill_Rate (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   $IF (Component_Demand_SYS.INSTALLED) $THEN
     RETURN  Forecast_Part_Util_API.Get_Master_Flow_Fill_Rate(contract_, part_no_);
   $ELSE
     RETURN NULL;
   $END
END Get_Forecast_Fill_Rate;


--@IgnoreMissingSysinit
FUNCTION Check_If_Alternate_Part (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   CURSOR  get_all_alternative_part IS
      SELECT   part_no, alternative_part_no
      FROM  part_catalog_alternative_pub
      WHERE part_no = part_no_;
BEGIN
   FOR rec_ IN get_all_alternative_part LOOP
      IF (Check_Exist___(contract_,rec_.alternative_part_no)) THEN
         RETURN 'TRUE';
      END IF;
   END LOOP;
   RETURN 'FALSE';
END Check_If_Alternate_Part;


--@IgnoreMissingSysinit
FUNCTION Check_Partca_Part_Exist (
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   dummy_ NUMBER;
   CURSOR exist_control IS
      SELECT 1
      FROM inventory_part_tab
      WHERE part_no = part_no_;
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RETURN ('TRUE');
   END IF;
   CLOSE exist_control;
   RETURN ('FALSE');
END Check_Partca_Part_Exist;


PROCEDURE Check_Value_Method_Combination (
   contract_                      IN VARCHAR2,
   part_no_                       IN VARCHAR2,
   configurable_db_               IN VARCHAR2,
   condition_code_usage_db_       IN VARCHAR2,
   lot_tracking_code_db_          IN VARCHAR2,
   serial_tracking_code_db_       IN VARCHAR2,
   receipt_issue_serial_track_db_ IN VARCHAR2 )
IS
   part_rec_ inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Check_Value_Method_Combination');
   part_rec_ := Get_Object_By_Keys___(contract_, part_no_);
   Check_Value_Method_Combinat___(part_rec_,
                                  configurable_db_,
                                  condition_code_usage_db_,
                                  lot_tracking_code_db_,
                                  serial_tracking_code_db_,
                                  receipt_issue_serial_track_db_);
END Check_Value_Method_Combination;


--@IgnoreMissingSysinit
FUNCTION Check_Exist_On_User_Site (
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   dummy_   NUMBER;

   CURSOR exist_control IS
      SELECT 1
      FROM  inventory_part_tab ip, USER_ALLOWED_SITE_PUB uas
      WHERE ip.contract = uas.site
      AND   ip.part_no = part_no_;
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RETURN('TRUE');
   END IF;
   CLOSE exist_control;
   RETURN('FALSE');
END Check_Exist_On_User_Site;


--@IgnoreMissingSysinit
FUNCTION Check_Neg_Onhand_Part_Exist (
   part_no_  IN VARCHAR2,
   contract_ IN VARCHAR2 DEFAULT NULL ) RETURN VARCHAR2
IS
   dummy_      NUMBER;
   qty_found_  VARCHAR2(5) := 'FALSE';

   CURSOR check_exist IS
      SELECT 1
      FROM   inventory_part_tab
      WHERE  part_no           = part_no_
        AND  (contract         = contract_ OR contract_ IS NULL)
        AND  negative_on_hand  = 'NEG ONHAND OK';
BEGIN
   OPEN check_exist;
   FETCH check_exist INTO dummy_;
   IF (check_exist%FOUND) THEN
      qty_found_ := 'TRUE';
   END IF;
   CLOSE check_exist;
   RETURN qty_found_;
END Check_Neg_Onhand_Part_Exist;


--@IgnoreMissingSysinit
FUNCTION Customs_Stat_No_With_Uom_Exist (
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   stat_with_uom_   VARCHAR2(5) := 'FALSE';
   CURSOR get_custom_stat IS
      SELECT DISTINCT customs_stat_no
      FROM inventory_part_tab
      WHERE part_no = part_no_
      AND customs_stat_no IS NOT NULL;
BEGIN
   FOR rec_ IN get_custom_stat LOOP
      IF (Customs_Statistics_Number_API.Get_Customs_Unit_Meas(rec_.customs_stat_no) IS NOT NULL) THEN
         stat_with_uom_ := 'TRUE';
         EXIT;
      END IF;
   END LOOP;
   RETURN stat_with_uom_;
END Customs_Stat_No_With_Uom_Exist;


PROCEDURE Copy_Connected_Objects (
   from_contract_            IN VARCHAR2,
   from_part_no_             IN VARCHAR2,
   to_contract_              IN VARCHAR2,
   to_part_no_               IN VARCHAR2,
   error_when_no_source_     IN VARCHAR2,
   error_when_existing_copy_ IN VARCHAR2 )
IS
   objid_               INVENTORY_PART.objid%TYPE;
   objversion_          INVENTORY_PART.objversion%TYPE;
   source_key_ref_      VARCHAR2(2000);
   destination_key_ref_ VARCHAR2(2000);
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Copy_Connected_Objects');
   Get_Id_Version_By_Keys___(objid_,
                             objversion_,
                             to_contract_,
                             to_part_no_);

   source_key_ref_      := Client_SYS.Get_Key_Reference(lu_name_, 'PART_NO',  from_part_no_,
                                                                  'CONTRACT', from_contract_);
   destination_key_ref_ := Client_SYS.Get_Key_Reference(lu_name_, 'PART_NO',  to_part_no_,
                                                                  'CONTRACT', to_contract_);
   
   $IF (Component_Docman_SYS.INSTALLED) $THEN
      Doc_Reference_Object_API.Copy(lu_name_,
                                    source_key_ref_,
                                    lu_name_,
                                    destination_key_ref_,
                                    '',
                                    error_when_no_source_,
                                    error_when_existing_copy_);
      Approval_Routing_API.Copy_App_Route(lu_name_,
                                          source_key_ref_,
                                          lu_name_,
                                          objid_,
                                          error_when_no_source_);
   $END   

   Technical_Object_Reference_API.Copy(lu_name_,
                                       source_key_ref_,
                                       destination_key_ref_,
                                       error_when_no_source_,
                                       error_when_existing_copy_);
END Copy_Connected_Objects;


PROCEDURE Copy_Note_Texts (
   from_contract_            IN VARCHAR2,
   from_part_no_             IN VARCHAR2,
   to_contract_              IN VARCHAR2,
   to_part_no_               IN VARCHAR2,
   error_when_no_source_     IN VARCHAR2,
   error_when_existing_copy_ IN VARCHAR2 )
IS
   from_note_id_ inventory_part_tab.note_id%TYPE;
   to_note_id_   inventory_part_tab.note_id%TYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Copy_Note_Texts');
   from_note_id_ := Get_Note_Id(from_contract_, from_part_no_);
   to_note_id_   := Get_Note_Id(to_contract_  , to_part_no_);

   Document_Text_API.Copy_All_Note_Texts(from_note_id_,
                                         to_note_id_,
                                         error_when_no_source_,
                                         error_when_existing_copy_);
END Copy_Note_Texts;


PROCEDURE Copy_Characteristics (
   from_contract_            IN VARCHAR2,
   from_part_no_             IN VARCHAR2,
   to_contract_              IN VARCHAR2,
   to_part_no_               IN VARCHAR2,
   error_when_no_source_     IN VARCHAR2,
   error_when_existing_copy_ IN VARCHAR2 )
IS
   newrec_         inventory_part_tab%ROWTYPE;
   frompartrec_    inventory_part_tab%ROWTYPE;
   exit_procedure_ EXCEPTION;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Copy_Characteristics');
   frompartrec_ := Get_Object_By_Keys___(from_contract_, from_part_no_);

   IF (frompartrec_.part_no IS NULL) THEN
      IF (error_when_no_source_ = 'TRUE') THEN
         Error_SYS.Record_Not_Exist(lu_name_, 'IPNOTEXIST: Inventory Part :P1 does not exist on site :P2', from_part_no_, from_contract_);
      ELSE
         RAISE exit_procedure_;
      END IF;
   ELSIF (frompartrec_.eng_attribute IS NULL) THEN
      IF (error_when_no_source_ = 'TRUE') THEN
         Error_SYS.Record_Not_Exist(lu_name_, 'IPNOCHARTEMP: Characteristic template does not exist for part :P1 on site :P2', from_part_no_, from_contract_);
      ELSE
         RAISE exit_procedure_;
      END IF;
   END IF;

   IF NOT (Check_Exist___(to_contract_, to_part_no_)) THEN
      RAISE exit_procedure_;
   END IF;

   newrec_ := Lock_By_Keys___(to_contract_, to_part_no_);
   IF (newrec_.eng_attribute IS NOT NULL) THEN
      IF (error_when_existing_copy_ = 'TRUE') THEN
         Error_SYS.Record_Exist(lu_name_, 'IPCHARTEMPEXIST: Characteristic template does already exist for part :P1 on site :P2', to_part_no_, to_contract_);
      ELSE
         RAISE exit_procedure_;
      END IF;
   END IF;
   newrec_.eng_attribute := frompartrec_.eng_attribute;
   Modify___(newrec_);

   IF NOT Inventory_Part_Char_API.Part_Has_Char(from_contract_, from_part_no_) THEN
      IF (error_when_no_source_ = 'TRUE') THEN
         Error_SYS.Record_Not_Exist(lu_name_, 'IPCHARNOTEXIST: Characteristics do not exist for Part :P1 on Site :P2', from_part_no_, from_contract_);
      ELSE
         RAISE exit_procedure_;
      END IF;
   ELSE
      Inv_Part_Indiscrete_Char_API.Copy(from_contract_,
                                        from_part_no_,
                                        to_contract_,
                                        to_part_no_,
                                        error_when_existing_copy_);

      Inv_Part_Discrete_Char_API.Copy(from_contract_,
                                      from_part_no_,
                                      to_contract_,
                                      to_part_no_,
                                      error_when_existing_copy_);
   END IF;
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Copy_Characteristics;


PROCEDURE Check_Ownership_Transfer_Point (
   company_                     IN VARCHAR2,
   ownership_transfer_point_db_ IN VARCHAR2 )
IS
   CURSOR get_part IS
      SELECT contract, part_no
      FROM inventory_part_tab
      WHERE invoice_consideration = 'TRANSACTION BASED';
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Check_Ownership_Transfer_Point');
   IF (ownership_transfer_point_db_ = 'RECEIPT INTO INVENTORY') THEN
      FOR part_rec_ IN get_part LOOP
         IF (Site_API.Get_Company(part_rec_.contract) = company_) THEN
            Error_SYS.Record_General(lu_name_, 'TRANBASSEPARR: You cannot use Receipt Into Inventory as Ownership Transfer Point on company :P1 since Transaction Based Invoice Consideration is activated for inventory part :P2 on site :P3.', company_, part_rec_.part_no, part_rec_.contract);
         END IF;
      END LOOP;
   END IF;
END Check_Ownership_Transfer_Point;


--@IgnoreMissingSysinit
FUNCTION Cascade_Update_On_SO_Close (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   inventory_valuation_method_db_ inventory_part_tab.inventory_valuation_method%TYPE;
   inventory_part_cost_level_db_  inventory_part_tab.inventory_part_cost_level%TYPE;

   CURSOR get_valuation_settings IS
      SELECT inventory_valuation_method,
             inventory_part_cost_level
      FROM inventory_part_tab
      WHERE contract = contract_
      AND   part_no  = part_no_;
BEGIN
   OPEN get_valuation_settings;
   FETCH get_valuation_settings INTO inventory_valuation_method_db_,
                                     inventory_part_cost_level_db_;
   CLOSE get_valuation_settings;

   RETURN Cascade_Update_On_So_Close___(inventory_valuation_method_db_,
                                        inventory_part_cost_level_db_);
END Cascade_Update_On_SO_Close;


--@IgnoreMissingSysinit
FUNCTION Get_Calc_Rounded_Qty (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   original_qty_     IN NUMBER,
   action_           IN VARCHAR2 DEFAULT 'ADD',
   ignore_unit_type_ IN BOOLEAN  DEFAULT FALSE ) RETURN NUMBER
IS
   qty_calc_rounding_ inventory_part_tab.qty_calc_rounding%TYPE;
   unit_meas_         inventory_part_tab.unit_meas%TYPE;
   
   CURSOR get_attr IS
      SELECT qty_calc_rounding, unit_meas
      FROM   inventory_part_tab
      WHERE  contract = contract_
      AND    part_no = part_no_;
BEGIN
   OPEN  get_attr;
   FETCH get_attr INTO qty_calc_rounding_, unit_meas_;
   CLOSE get_attr;
   RETURN Get_Calc_Rounded_Qty___(original_qty_, qty_calc_rounding_, action_, unit_meas_, ignore_unit_type_);
END Get_Calc_Rounded_Qty;


PROCEDURE Check_Partcat_Unit_Code_Change (
   part_no_             IN VARCHAR2,
   old_unit_of_measure_ IN VARCHAR2,
   new_unit_of_measure_ IN VARCHAR2 )
IS
   uom_in_inventory_  VARCHAR2(10);
   engpart_exists_    VARCHAR2(5);   
   inv_base_unit_     VARCHAR2(120);
   new_base_unit_     VARCHAR2(120);

   CURSOR get_invpart_uom IS
      SELECT unit_meas
      FROM   inventory_part_tab
      WHERE  part_no = part_no_;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Check_Partcat_Unit_Code_Change');
   OPEN get_invpart_uom;
   FETCH get_invpart_uom INTO uom_in_inventory_;
   CLOSE get_invpart_uom;
   IF(uom_in_inventory_ IS NOT NULL ) THEN
      $IF (Component_Pdmcon_SYS.INSTALLED) $THEN
         engpart_exists_ := Eng_Part_Revision_API.Check_Part_Exist(part_no_);      
         IF( engpart_exists_ ='TRUE') THEN
            new_base_unit_ := Iso_Unit_API.Get_Base_Unit(new_unit_of_measure_);
            inv_base_unit_ := Iso_Unit_API.Get_Base_Unit(uom_in_inventory_);
            IF NOT(inv_base_unit_ = new_base_unit_) THEN
               Error_SYS.Record_General(lu_name_, 'ONLYALLOWEDTOCHANGE: This is an engineering part and also an inventory part with Base Unit :P1. Therefore it is only allowed to change Unit Code into Base Unit :P1.',inv_base_unit_);
            END IF;
         END IF;
      $ELSE
         NULL;
      $END
   END IF;
END Check_Partcat_Unit_Code_Change;


--@IgnoreMissingSysinit
FUNCTION Get_Description (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   description_   inventory_part_tab.description%TYPE;
   CURSOR get_attr IS
      SELECT description
      FROM  inventory_part_tab
      WHERE contract = contract_
      AND   part_no  = part_no_;
BEGIN
   IF (Site_Invent_Info_API.Get_Use_Partca_Desc_Invent_Db(contract_) = 'TRUE') THEN
      description_ := Part_Catalog_API.Get_Description(part_no_);
   ELSE
      OPEN  get_attr;
      FETCH get_attr INTO description_;
      CLOSE get_attr;
   END IF;
   RETURN description_;
END Get_Description;


PROCEDURE Handle_Partca_Desc_Change (
   part_no_ IN VARCHAR2 )
IS
   CURSOR get_contract IS
      SELECT contract
      FROM   inventory_part_tab
      WHERE  part_no = part_no_;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Handle_Partca_Desc_Change');
   FOR get_contract_ IN get_contract LOOP
      IF (Site_Invent_Info_API.Get_Use_Partca_Desc_Invent_Db(get_contract_.contract) = 'TRUE') THEN
         Handle_Description_Change___(get_contract_.contract, part_no_);
      END IF;
   END LOOP;
END Handle_Partca_Desc_Change;


PROCEDURE Handle_Partca_Desc_Flag_Change (
   contract_ IN VARCHAR2 )
IS
   partca_description_   inventory_part_tab.description%TYPE;
   CURSOR get_part_info IS
      SELECT part_no, description
      FROM   inventory_part_tab
      WHERE  contract = contract_;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Handle_Partca_Desc_Flag_Change');
   FOR get_part_info_ IN get_part_info LOOP
     partca_description_ := Part_Catalog_API.Get_Description(get_part_info_.part_no);
     IF (get_part_info_.description != partca_description_) THEN
        Handle_Description_Change___(contract_, get_part_info_.part_no);
     END IF;
  END LOOP;
END Handle_Partca_Desc_Flag_Change;


--@IgnoreMissingSysinit
FUNCTION Get_Site_Converted_Qty (
   contract_        IN VARCHAR2,
   part_no_         IN VARCHAR2,
   quantity_        IN NUMBER,
   to_contract_     IN VARCHAR2,
   rounding_action_ IN VARCHAR2,
   unit_category_   IN VARCHAR2 DEFAULT 'INVENT',
   to_part_no_      IN VARCHAR2 DEFAULT NULL ) RETURN NUMBER
IS
   from_part_rec_  inventory_part_tab%ROWTYPE;
   to_part_rec_    inventory_part_tab%ROWTYPE;
   to_quantity_    NUMBER;
   -- could be either unit_meas (10 characters) or catch_unit_meas (30 characters)
   from_unit_meas_ inventory_part_tab.catch_unit_meas%TYPE;
   to_unit_meas_   inventory_part_tab.catch_unit_meas%TYPE;
BEGIN
   to_quantity_ := quantity_;
   IF (contract_ != to_contract_ AND quantity_ != 0) THEN
      from_part_rec_  := Get_Object_By_Keys___(contract_,part_no_);
      to_part_rec_    := Get_Object_By_Keys___(to_contract_, NVL(to_part_no_, part_no_));
      IF (unit_category_ = 'INVENT') THEN
         from_unit_meas_ := from_part_rec_.unit_meas;
         to_unit_meas_ := to_part_rec_.unit_meas;
      ELSIF (unit_category_ = 'CATCH') THEN
         from_unit_meas_ := from_part_rec_.catch_unit_meas;
         to_unit_meas_ := to_part_rec_.catch_unit_meas;
      END IF;
      IF (from_unit_meas_ != to_unit_meas_) THEN
         to_quantity_ := Iso_Unit_API.Get_Unit_Converted_Quantity(quantity_,
                                                     from_unit_meas_,
                                                     to_unit_meas_ );

         IF (rounding_action_ IN ('ADD','REMOVE')) THEN
            to_quantity_ := Get_Calc_Rounded_Qty___(to_quantity_,
                                                    to_part_rec_.qty_calc_rounding,
                                                    rounding_action_,
                                                    to_unit_meas_,
                                                    FALSE);
         ELSIF (rounding_action_ = 'SKIP') THEN
            NULL;
         ELSE
            to_quantity_ := NULL;
         END IF;
      ELSIF (from_unit_meas_ IS NULL OR to_unit_meas_ IS NULL) THEN
         to_quantity_ := NULL;
      END IF;
   END IF;

   RETURN (to_quantity_);
END Get_Site_Converted_Qty;


FUNCTION Get_Site_Converted_Qty (
   part_no_         IN VARCHAR2,
   quantity_        IN NUMBER,
   unit_meas_       IN VARCHAR2,
   to_contract_     IN VARCHAR2,
   rounding_action_ IN VARCHAR2,
   unit_category_   IN VARCHAR2 DEFAULT 'INVENT' ) RETURN NUMBER
IS
   to_part_rec_   inventory_part_tab%ROWTYPE;
   to_quantity_   NUMBER;
   -- could be either unit_meas (10 characters) or catch_unit_meas (30 characters)
   to_unit_meas_  inventory_part_tab.catch_unit_meas%TYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Get_Site_Converted_Qty');
   to_quantity_ := quantity_;
   IF (quantity_ != 0) THEN
      to_part_rec_    := Get_Object_By_Keys___(to_contract_,part_no_);

      IF (unit_category_ = 'INVENT') THEN
         to_unit_meas_ := to_part_rec_.unit_meas;
      ELSIF (unit_category_ = 'CATCH') THEN
         to_unit_meas_ := to_part_rec_.catch_unit_meas;
      ELSE
         Error_SYS.Record_General(lu_name_, 'ERR_UOM: Unit Category :P1 sent to method Get_Site_Converted_Qty is invalid.',unit_category_);
      END IF;

      IF (unit_meas_ != to_unit_meas_) THEN
         to_quantity_ := Iso_Unit_API.Convert_Unit_Quantity(quantity_,
                                                            unit_meas_,
                                                            to_unit_meas_);
         IF (rounding_action_ IN ('ADD','REMOVE')) THEN
            to_quantity_ := Get_Calc_Rounded_Qty___(to_quantity_,
                                                    to_part_rec_.qty_calc_rounding,
                                                    rounding_action_,
                                                    to_unit_meas_,
                                                    FALSE);
         ELSIF (rounding_action_ = 'SKIP') THEN
            NULL;
         ELSE
            Error_SYS.Record_General(lu_name_, 'ERR_ROUNDING: Rounding action :P1 sent to method Get_Site_Converted_Qty is invalid.',rounding_action_);
         END IF;
      ELSIF (to_unit_meas_ IS NULL) THEN
         Raise_Part_Not_Exist___(part_no_, to_contract_);
      END IF;
   END IF;

   RETURN (to_quantity_);
END Get_Site_Converted_Qty;


FUNCTION Get_Site_Converted_Qty (
   contract_        IN VARCHAR2,
   part_no_         IN VARCHAR2,
   to_contract_     IN VARCHAR2,
   quantity_        IN NUMBER,
   rounding_action_ IN VARCHAR2,
   unit_category_   IN VARCHAR2 DEFAULT 'INVENT' ) RETURN NUMBER
IS
   from_part_rec_  inventory_part_tab%ROWTYPE;
   to_quantity_    NUMBER;
   -- could be either unit_meas (10 characters) or catch_unit_meas (30 characters)
   from_unit_meas_ inventory_part_tab.catch_unit_meas%TYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Get_Site_Converted_Qty');
   to_quantity_ := quantity_;
   IF (contract_ != to_contract_ AND quantity_ != 0) THEN
      from_part_rec_  := Get_Object_By_Keys___(contract_,part_no_);

      IF (unit_category_ = 'INVENT') THEN
         from_unit_meas_ := from_part_rec_.unit_meas;
      ELSIF (unit_category_ = 'CATCH') THEN
         from_unit_meas_ := from_part_rec_.catch_unit_meas;
      ELSE
         Error_SYS.Record_General(lu_name_, 'ERR_UOM: Unit Category :P1 sent to method Get_Site_Converted_Qty is invalid.',unit_category_);
      END IF;

      IF (from_unit_meas_ IS NOT NULL) THEN
         to_quantity_ := Get_Site_Converted_Qty(part_no_,
                                                quantity_,
                                                from_unit_meas_,
                                                to_contract_,
                                                rounding_action_,
                                                unit_category_);
      ELSE
         Raise_Part_Not_Exist___(part_no_,contract_);
      END IF;
   END IF;

   RETURN (to_quantity_);
END Get_Site_Converted_Qty;


--@IgnoreMissingSysinit
FUNCTION Get_User_Default_Converted_Qty (
   contract_        IN VARCHAR2,
   part_no_         IN VARCHAR2,
   quantity_        IN NUMBER,
   rounding_action_ IN VARCHAR2,
   unit_category_   IN VARCHAR2 DEFAULT 'INVENT' ) RETURN NUMBER
IS
   to_quantity_ NUMBER;
   not_used_    inventory_part_tab.catch_unit_meas%TYPE;
   to_contract_ inventory_part_tab.contract%TYPE;
BEGIN
   to_quantity_ := quantity_;
   IF (quantity_ != 0) THEN
      Get_Default_Site_And_Uom___(to_contract_, not_used_, part_no_, unit_category_);
      to_quantity_ := Get_Site_Converted_Qty(contract_,
                                             part_no_,
                                             quantity_,
                                             to_contract_,
                                             rounding_action_,
                                             unit_category_);
   END IF;
   RETURN (to_quantity_);
END Get_User_Default_Converted_Qty;


--@IgnoreMissingSysinit
FUNCTION Get_User_Default_Unit_Meas (
   part_no_       IN VARCHAR2,
   unit_category_ IN VARCHAR2 DEFAULT 'INVENT' ) RETURN VARCHAR2
IS
   not_used_       inventory_part_tab.contract%TYPE;
   -- could be either unit_meas (10 characters) or catch_unit_meas (30 characters)
   unit_meas_      inventory_part_tab.catch_unit_meas%TYPE;
BEGIN
   Get_Default_Site_And_Uom___(not_used_, unit_meas_, part_no_, unit_category_);
   RETURN unit_meas_;
END Get_User_Default_Unit_Meas;


--@IgnoreMissingSysinit
FUNCTION Get_User_Default_Site (
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   contract_ inventory_part_tab.contract%TYPE;
   not_used_ inventory_part_tab.catch_unit_meas%TYPE;
BEGIN
   Get_Default_Site_And_Uom___(contract_, not_used_, part_no_);
   RETURN contract_;
END Get_User_Default_Site;


--@IgnoreMissingSysinit
FUNCTION Get_Enabled_Catch_Unit_Meas (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   catch_unit_meas_ inventory_part_tab.catch_unit_meas%TYPE;

   CURSOR get_attr IS
      SELECT catch_unit_meas
      FROM   inventory_part_tab
      WHERE contract = contract_
      AND   part_no = part_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO catch_unit_meas_;
   IF (get_attr%FOUND) THEN
      IF (Part_Catalog_API.Get_Catch_Unit_Enabled_Db(part_no_) = 'FALSE') THEN
         catch_unit_meas_ := NULL;
      END IF;
   END IF;
   CLOSE get_attr;

   RETURN catch_unit_meas_;
END Get_Enabled_Catch_Unit_Meas;


PROCEDURE Check_Enable_Catch_Unit (
   part_no_ IN VARCHAR2 )
IS
   CURSOR get_inv_part IS
      SELECT contract, catch_unit_meas
      FROM   inventory_part_tab
      WHERE  part_no = part_no_;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Check_Enable_Catch_Unit');
   $IF (Component_Order_SYS.INSTALLED) $THEN
      FOR part_rec_ IN get_inv_part LOOP
         Sales_Part_API.Check_Enable_Catch_Unit(part_rec_.contract, part_no_, part_rec_.catch_unit_meas);
      END LOOP;
   $ELSE
      NULL;
   $END
END Check_Enable_Catch_Unit;


PROCEDURE Modify_Qty_Calc_Rounding (
   contract_          IN VARCHAR2,
   part_no_           IN VARCHAR2,
   qty_calc_rounding_ IN NUMBER )
IS
   newrec_  inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Qty_Calc_Rounding');
   newrec_ := Lock_By_Keys___(contract_, part_no_);
   newrec_.qty_calc_rounding := qty_calc_rounding_;
   Modify___(newrec_);
END Modify_Qty_Calc_Rounding;


PROCEDURE Modify_Eng_Attribute (
   contract_          IN VARCHAR2,
   part_no_           IN VARCHAR2,
   eng_attribute_  IN VARCHAR2 )
IS
   newrec_  inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Eng_Attribute');
   newrec_ := Lock_By_Keys___(contract_, part_no_);
   newrec_.eng_attribute := eng_attribute_;
   Modify___(newrec_);
END Modify_Eng_Attribute;


PROCEDURE Get_All_Notes (
   partca_part_note_id_ OUT NUMBER,
   partca_part_notes_   OUT VARCHAR2,
   inv_part_note_id_    OUT NUMBER,
   inv_part_notes_      OUT VARCHAR2,
   contract_            IN  VARCHAR2,
   part_no_             IN  VARCHAR2,
   language_code_       IN  VARCHAR2,
   document_code_       IN  VARCHAR2 )
IS
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Get_All_Notes');
   IF (Site_Invent_Info_API.Get_Use_Partca_Desc_Invent_Db(contract_) = 'TRUE') THEN
      partca_part_note_id_ := Part_Catalog_Language_API.Get_Note_Id(part_no_, language_code_);
   END IF;
   partca_part_notes_ := Document_Text_API.Get_All_Notes(partca_part_note_id_, document_code_);

   inv_part_note_id_  := Inventory_Part_API.Get_Note_Id(contract_, part_no_);
   inv_part_notes_    := Document_Text_API.Get_All_Notes(inv_part_note_id_, document_code_);
END Get_All_Notes;


--@IgnoreMissingSysinit
FUNCTION Cascade_Trans_Cost_Update (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   rec_ inventory_part_tab%ROWTYPE;
BEGIN
   rec_ := Get_Object_By_Keys___(contract_, part_no_);
   RETURN (Cascade_Trans_Cost_Update(rec_.invoice_consideration,
                                     rec_.inventory_valuation_method,
                                     rec_.inventory_part_cost_level));
END Cascade_Trans_Cost_Update;


--@IgnoreMissingSysinit
FUNCTION Cascade_Trans_Cost_Update (
   invoice_consideration_db_      IN VARCHAR2,
   inventory_valuation_method_db_ IN VARCHAR2,
   inventory_part_cost_level_db_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   cascade_trans_cost_update_ BOOLEAN := FALSE;
BEGIN
   IF ((invoice_consideration_db_ = 'TRANSACTION BASED') OR
       (Cascade_Update_On_SO_Close___(inventory_valuation_method_db_,
                                      inventory_part_cost_level_db_))) THEN
      cascade_trans_cost_update_ := TRUE;
   END IF;
   RETURN (cascade_trans_cost_update_);
END Cascade_Trans_Cost_Update;


PROCEDURE Modify_Type_Code (
   contract_     IN VARCHAR2,
   part_no_      IN VARCHAR2,
   type_code_db_ IN VARCHAR2 )
IS
   newrec_  inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Type_Code');
   newrec_ := Lock_By_Keys___(contract_, part_no_);
   newrec_.type_code := type_code_db_;
   Modify___(newrec_);
END Modify_Type_Code;


PROCEDURE Modify_Invent_Part_Cost_Level (
   contract_                     IN VARCHAR2,
   part_no_                      IN VARCHAR2,
   inventory_part_cost_level_db_ IN VARCHAR2 )
IS
   record_ inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Invent_Part_Cost_Level');
   record_ := Lock_By_Keys___(contract_, part_no_);
   record_.inventory_part_cost_level := inventory_part_cost_level_db_;
   Modify___(record_, updated_by_client_ => TRUE);
END Modify_Invent_Part_Cost_Level;


PROCEDURE Modify_Invent_Valuation_Met (
   contract_                      IN VARCHAR2,
   part_no_                       IN VARCHAR2,
   inventory_valuation_method_db_ IN VARCHAR2 )
IS
   record_ inventory_part_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Invent_Valuation_Met');
   record_ := Lock_By_Keys___(contract_, part_no_);
   record_.inventory_valuation_method := inventory_valuation_method_db_;
   Modify___(record_);
END Modify_Invent_Valuation_Met;


PROCEDURE Modify_Earliest_Ultd_Sply_Date (
   contract_             IN VARCHAR2,
   part_no_              IN VARCHAR2,
   planned_receipt_date_ IN DATE )
IS
   dummy_ BOOLEAN;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Earliest_Ultd_Sply_Date');
   Mod_Earliest_Ultd_Sply_Date___(date_modified_        => dummy_,
                                  contract_             => contract_,
                                  part_no_              => part_no_,
                                  planned_receipt_date_ => planned_receipt_date_,
                                  backdate_allowed_db_  => Fnd_Boolean_API.DB_TRUE);
END Modify_Earliest_Ultd_Sply_Date;


PROCEDURE Modify_Earliest_Ultd_Sply_Date (
   date_modified_        OUT BOOLEAN,
   contract_             IN  VARCHAR2,
   part_no_              IN  VARCHAR2,
   planned_receipt_date_ IN  DATE,
   backdate_allowed_db_  IN  VARCHAR2 )
IS
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Earliest_Ultd_Sply_Date');
   Mod_Earliest_Ultd_Sply_Date___(date_modified_, contract_, part_no_, planned_receipt_date_, backdate_allowed_db_);
END Modify_Earliest_Ultd_Sply_Date;


PROCEDURE Check_Disallow_As_Not_Consumed (
   part_no_ IN VARCHAR2 )
IS
   contract_           inventory_part_tab.contract%TYPE;
   expense_part_exist_ EXCEPTION;

   CURSOR check_invpart IS
      SELECT contract
      FROM   inventory_part_tab
      WHERE  part_no = part_no_
      AND    type_code = 6 ;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Check_Disallow_As_Not_Consumed');
   OPEN check_invpart;
   FETCH check_invpart INTO contract_;
   IF check_invpart%FOUND THEN
      CLOSE check_invpart;
      RAISE expense_part_exist_;
   END IF;
   CLOSE check_invpart;
EXCEPTION
   WHEN expense_part_exist_ THEN
      Error_SYS.Record_General(lu_name_, 'EXPENSEPRTEXIST: Allow as Not Consumed check box cannot be cleared when the inventory part :P1 in site :P2 is of type expense.',part_no_, contract_);
END Check_Disallow_As_Not_Consumed;


--@IgnoreMissingSysinit
FUNCTION Cascade_Update_On_SO_Close_Str (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   cascade_update_ VARCHAR2(5) := 'FALSE';
BEGIN
   IF (Cascade_Update_On_SO_Close(contract_, part_no_)) THEN
      cascade_update_ := 'TRUE';
   END IF;
   RETURN cascade_update_;
END Cascade_Update_On_SO_Close_Str;


PROCEDURE Add_Issue_For_Decline_Expired (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 )
IS
   oldrec_ inventory_part_tab%ROWTYPE;
   newrec_ inventory_part_tab%ROWTYPE;
   modify_ BOOLEAN := FALSE;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Add_Issue_For_Decline_Expired');
   oldrec_ := Lock_By_Keys___(contract_, part_no_);
   newrec_ := oldrec_;

   CASE oldrec_.lifecycle_stage
      WHEN Inv_Part_Lifecycle_Stage_API.DB_DECLINE THEN
         newrec_.decline_issue_counter := NVL(oldrec_.decline_issue_counter, 0) + 1;
         modify_                       := TRUE;
      WHEN Inv_Part_Lifecycle_Stage_API.DB_EXPIRED THEN
         newrec_.expired_issue_counter := NVL(oldrec_.expired_issue_counter, 0) + 1;
         modify_                       := TRUE;
      ELSE
         NULL;
   END CASE;

   IF (modify_) THEN
      Modify___(newrec_);
   END IF;
END Add_Issue_For_Decline_Expired;


PROCEDURE Modify_Latest_Stat_Issue_Date (
   contract_               IN VARCHAR2,
   part_no_                IN VARCHAR2,
   latest_stat_issue_date_ IN DATE )
IS
   oldrec_                     inventory_part_tab%ROWTYPE;
   asset_class_rec_            Asset_Class_API.Public_Rec;
   company_invent_info_rec_    Company_Invent_Info_API.Public_Rec;
   update_needed_              BOOLEAN := FALSE;
   new_first_stat_issue_date_  DATE;
   new_latest_stat_issue_date_ DATE;
   expired_inactivity_days_    NUMBER;
   expired_to_intro_issues_    NUMBER;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify_Latest_Stat_Issue_Date');
   oldrec_                     := Lock_By_Keys___(contract_, part_no_);
   new_first_stat_issue_date_  := oldrec_.first_stat_issue_date;
   new_latest_stat_issue_date_ := oldrec_.latest_stat_issue_date;

   IF (NVL(oldrec_.latest_stat_issue_date, Database_SYS.first_calendar_date_) <
                                                                      latest_stat_issue_date_) THEN
      new_latest_stat_issue_date_ := latest_stat_issue_date_;
      update_needed_              := TRUE;
   END IF;

   IF (NVL(oldrec_.first_stat_issue_date, Database_SYS.last_calendar_date_) >
                                                                      latest_stat_issue_date_) THEN
      new_first_stat_issue_date_ := latest_stat_issue_date_;
      update_needed_             := TRUE;
   END IF;

   IF (oldrec_.lifecycle_stage = Inv_Part_Lifecycle_Stage_API.DB_EXPIRED) THEN
      company_invent_info_rec_ := Company_Invent_Info_API.Get(Site_API.Get_Company(contract_));
      asset_class_rec_         := Asset_Class_API.Get(oldrec_.asset_class);
      expired_inactivity_days_ := NVL(asset_class_rec_.expired_inactivity_days ,
                                      company_invent_info_rec_.expired_inactivity_days);
      expired_to_intro_issues_ := NVL(asset_class_rec_.expired_to_intro_issues,
                                      company_invent_info_rec_.expired_to_intro_issues);
      
      -- Confirm that the part latest statistical issue is done in Expired stage. (new_first_stat_issue_date_ + expired_inactivity_days_ < new_latest_stat_issue_date_)
      IF (new_first_stat_issue_date_ < (new_latest_stat_issue_date_ - expired_inactivity_days_)) THEN
         IF (oldrec_.expired_issue_counter >= expired_to_intro_issues_)THEN 
            new_first_stat_issue_date_ := new_latest_stat_issue_date_;
            update_needed_             := TRUE;
         END IF;
      END IF;
   END IF;

   IF (update_needed_) THEN
      oldrec_.first_stat_issue_date  := new_first_stat_issue_date_;
      oldrec_.latest_stat_issue_date := new_latest_stat_issue_date_;
      Modify___(oldrec_);
   END IF;
END Modify_Latest_Stat_Issue_Date;


--@IgnoreMissingSysinit
FUNCTION Get_Storage_Volume_Req_Oper_Cl (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   storage_volume_requirement_ inventory_part_tab.storage_volume_requirement%TYPE;
BEGIN
   storage_volume_requirement_ := Get_Storage_Volume_Requirement(contract_,part_no_);
   IF (storage_volume_requirement_ > 0) THEN
      storage_volume_requirement_ := 1 / storage_volume_requirement_;
   ELSE
      storage_volume_requirement_ := NULL;
   END IF;
   RETURN (storage_volume_requirement_);
END Get_Storage_Volume_Req_Oper_Cl;


--@IgnoreMissingSysinit
FUNCTION Get_Storage_Volume_Req_Client (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   storage_volume_requirement_ inventory_part_tab.storage_volume_requirement%TYPE;
BEGIN
   Update_Cache___(contract_, part_no_);
   storage_volume_requirement_ := micro_cache_value_.storage_volume_requirement;
   IF (storage_volume_requirement_ > 0) THEN
      storage_volume_requirement_ := 1 / storage_volume_requirement_;
   ELSE
      storage_volume_requirement_ := NULL;
   END IF;
   RETURN (storage_volume_requirement_);
END Get_Storage_Volume_Req_Client;


--@IgnoreMissingSysinit
FUNCTION Get_Storage_Width_Req_Source (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   storage_width_req_source_ VARCHAR2(200);
BEGIN
   Update_Cache___(contract_, part_no_);
   IF (micro_cache_value_.storage_width_requirement IS NULL) THEN
      IF micro_cache_value_.unit_meas = Part_Catalog_API.Get_Unit_Code(part_no_) THEN
         storage_width_req_source_ := Part_Catalog_Invent_Attrib_API.Get_Storage_Width_Req_Source(part_no_);
      END IF;
   ELSE
      storage_width_req_source_ := Part_Structure_Level_API.Decode('INVENTORY_PART');
   END IF;
   RETURN (storage_width_req_source_);
END Get_Storage_Width_Req_Source;


--@IgnoreMissingSysinit
FUNCTION Get_Storage_Height_Req_Source (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   storage_height_req_source_ VARCHAR2(200);
BEGIN
   Update_Cache___(contract_, part_no_);
   IF (micro_cache_value_.storage_height_requirement IS NULL) THEN
      IF micro_cache_value_.unit_meas = Part_Catalog_API.Get_Unit_Code(part_no_) THEN
         storage_height_req_source_ := Part_Catalog_Invent_Attrib_API.Get_Storage_Height_Req_Source(part_no_);
      END IF;
   ELSE
      storage_height_req_source_ := Part_Structure_Level_API.Decode('INVENTORY_PART');
   END IF;
   RETURN (storage_height_req_source_);
END Get_Storage_Height_Req_Source;


--@IgnoreMissingSysinit
FUNCTION Get_Storage_Depth_Req_Source (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   storage_depth_req_source_ VARCHAR2(200);
BEGIN
   Update_Cache___(contract_, part_no_);
   IF (micro_cache_value_.storage_depth_requirement IS NULL) THEN
      IF micro_cache_value_.unit_meas = Part_Catalog_API.Get_Unit_Code(part_no_) THEN
         storage_depth_req_source_ := Part_Catalog_Invent_Attrib_API.Get_Storage_Depth_Req_Source(part_no_);
      END IF;
   ELSE
      storage_depth_req_source_ := Part_Structure_Level_API.Decode('INVENTORY_PART');
   END IF;
   RETURN (storage_depth_req_source_);
END Get_Storage_Depth_Req_Source;


--@IgnoreMissingSysinit
FUNCTION Get_Storage_Volume_Req_Source (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   storage_volume_req_source_ VARCHAR2(200);
BEGIN
   Update_Cache___(contract_, part_no_);
   IF (micro_cache_value_.storage_volume_requirement IS NULL) THEN
      IF micro_cache_value_.unit_meas = Part_Catalog_API.Get_Unit_Code(part_no_) THEN
         storage_volume_req_source_ := Part_Catalog_Invent_Attrib_API.Get_Storage_Volume_Req_Source(part_no_);
      END IF;
   ELSE
      storage_volume_req_source_ := Part_Structure_Level_API.Decode('INVENTORY_PART');
   END IF;
   RETURN (storage_volume_req_source_);
END Get_Storage_Volume_Req_Source;


--@IgnoreMissingSysinit
FUNCTION Get_Storage_Weight_Req_Source (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   storage_weight_req_source_ VARCHAR2(200);
BEGIN
   Update_Cache___(contract_, part_no_);
   IF (micro_cache_value_.storage_weight_requirement IS NULL) THEN
      IF micro_cache_value_.unit_meas = Part_Catalog_API.Get_Unit_Code(part_no_) THEN
         storage_weight_req_source_ := Part_Catalog_Invent_Attrib_API.Get_Storage_Weight_Req_Source(part_no_);
      END IF;
   ELSE
      storage_weight_req_source_ := Part_Structure_Level_API.Decode('INVENTORY_PART');
   END IF;
   RETURN (storage_weight_req_source_);
END Get_Storage_Weight_Req_Source;


--@IgnoreMissingSysinit
FUNCTION Get_Min_Storage_Temp_Source (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   min_storage_temp_source_ VARCHAR2(200);
BEGIN
   Update_Cache___(contract_, part_no_);
   IF (micro_cache_value_.min_storage_temperature IS NULL) THEN
      min_storage_temp_source_ := Part_Catalog_Invent_Attrib_API.Get_Min_Storage_Temp_Source(part_no_);
   ELSE
      min_storage_temp_source_ := Part_Structure_Level_API.Decode('INVENTORY_PART');
   END IF;
   RETURN (min_storage_temp_source_);
END Get_Min_Storage_Temp_Source;


--@IgnoreMissingSysinit
FUNCTION Get_Max_Storage_Temp_Source (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   max_storage_temp_source_ VARCHAR2(200);
BEGIN
   Update_Cache___(contract_, part_no_);
   IF (micro_cache_value_.max_storage_temperature IS NULL) THEN
      max_storage_temp_source_ := Part_Catalog_Invent_Attrib_API.Get_Max_Storage_Temp_Source(part_no_);
   ELSE
      max_storage_temp_source_ := Part_Structure_Level_API.Decode('INVENTORY_PART');
   END IF;
   RETURN (max_storage_temp_source_);
END Get_Max_Storage_Temp_Source;


--@IgnoreMissingSysinit
FUNCTION Get_Min_Storage_Humid_Source (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   min_storage_humid_source_ VARCHAR2(200);
BEGIN
   Update_Cache___(contract_, part_no_);
   IF (micro_cache_value_.min_storage_humidity IS NULL) THEN
      min_storage_humid_source_ := Part_Catalog_Invent_Attrib_API.Get_Min_Storage_Humid_Source(part_no_);
   ELSE
      min_storage_humid_source_ := Part_Structure_Level_API.Decode('INVENTORY_PART');
   END IF;
   RETURN (min_storage_humid_source_);
END Get_Min_Storage_Humid_Source;


--@IgnoreMissingSysinit
FUNCTION Get_Max_Storage_Humid_Source (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   max_storage_humidity_source_ VARCHAR2(200);
BEGIN
   Update_Cache___(contract_, part_no_);
   IF (micro_cache_value_.max_storage_humidity IS NULL) THEN
      max_storage_humidity_source_ := Part_Catalog_Invent_Attrib_API.Get_Max_Storage_Humid_Source(part_no_);
   ELSE
      max_storage_humidity_source_ := Part_Structure_Level_API.Decode('INVENTORY_PART');
   END IF;
   RETURN (max_storage_humidity_source_);
END Get_Max_Storage_Humid_Source;


PROCEDURE Check_Temperature_Range (
   part_no_  IN VARCHAR2,
   contract_ IN VARCHAR2 DEFAULT NULL )
IS
   min_storage_temperature_ inventory_part_tab.min_storage_temperature%TYPE;
   max_storage_temperature_ inventory_part_tab.max_storage_temperature%TYPE;

   CURSOR get_sites IS
      SELECT contract
      FROM inventory_part_tab
      WHERE part_no = part_no_;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Check_Temperature_Range');
   IF contract_ IS NOT NULL THEN
      min_storage_temperature_ := Get_Min_Storage_Temperature(contract_, part_no_);
      max_storage_temperature_ := Get_Max_Storage_Temperature(contract_, part_no_);

      IF (Part_Catalog_Invent_Attrib_API.Incorrect_Temperature_Range(min_storage_temperature_, max_storage_temperature_)) THEN
         Error_SYS.Record_General(lu_name_, 'TEMPRANGE: Incorrect Operative Temperature Range in Inventory Part :P1 on Site :P2.', part_no_, contract_);
      END IF;
   ELSE
      -- IF method is called from Part Catalog all parts on all sites must be checked
      FOR sites_rec_ IN get_sites LOOP
         min_storage_temperature_ := Get_Min_Storage_Temperature(sites_rec_.contract, part_no_);
         max_storage_temperature_ := Get_Max_Storage_Temperature(sites_rec_.contract, part_no_);

         IF (Part_Catalog_Invent_Attrib_API.Incorrect_Temperature_Range(min_storage_temperature_, max_storage_temperature_)) THEN
            Error_SYS.Record_General(lu_name_, 'TEMPRANGE: Incorrect Operative Temperature Range in Inventory Part :P1 on Site :P2.', part_no_, sites_rec_.contract);
         END IF;
      END LOOP;
   END IF;
END Check_Temperature_Range;


PROCEDURE Check_Humidity_Range (
   part_no_  IN VARCHAR2,
   contract_ IN VARCHAR2 DEFAULT NULL )
IS
   min_storage_humidity_ inventory_part_tab.min_storage_humidity%TYPE;
   max_storage_humidity_ inventory_part_tab.max_storage_humidity%TYPE;

   CURSOR get_sites IS
      SELECT contract
      FROM inventory_part_tab
      WHERE part_no = part_no_;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Check_Humidity_Range');
   IF contract_ IS NOT NULL THEN
      min_storage_humidity_ := Get_Min_Storage_Humidity(contract_, part_no_);
      max_storage_humidity_ := Get_Max_Storage_Humidity(contract_, part_no_);

      IF (Part_Catalog_Invent_Attrib_API.Incorrect_Humidity_Range(min_storage_humidity_, max_storage_humidity_)) THEN
         Error_SYS.Record_General(lu_name_, 'HUMRANGE: Incorrect Operative Humidity Range in Inventory Part :P1 on Site :P2.', part_no_, contract_);
      END IF;
   ELSE
      -- IF method is called from Part Catalog all parts on all sites must be checked
      FOR sites_rec_ IN get_sites LOOP
         min_storage_humidity_ := Get_Min_Storage_Humidity(sites_rec_.contract, part_no_);
         max_storage_humidity_ := Get_Max_Storage_Humidity(sites_rec_.contract, part_no_);

         IF (Part_Catalog_Invent_Attrib_API.Incorrect_Humidity_Range(min_storage_humidity_, max_storage_humidity_)) THEN
            Error_SYS.Record_General(lu_name_, 'HUMRANGE: Incorrect Operative Humidity Range in Inventory Part :P1 on Site :P2.', part_no_, sites_rec_.contract);
         END IF;
      END LOOP;
   END IF;
END Check_Humidity_Range;


--@IgnoreMissingSysinit
FUNCTION Unit_Meas_Different_On_Sites (
  part_no_                  IN VARCHAR2,
  unit_meas_for_comparsion_ IN VARCHAR2 DEFAULT NULL) RETURN BOOLEAN
IS
   unit_meas_different_on_sites_ BOOLEAN := FALSE;
   compare_with_unit_meas_       inventory_part_tab.unit_meas%TYPE;
   conversion_factor_            NUMBER;

    CURSOR get_unit_meas IS
      SELECT unit_meas
      FROM   inventory_part_tab
      WHERE  part_no = part_no_;
BEGIN
   compare_with_unit_meas_ := unit_meas_for_comparsion_;

   FOR rec_ IN get_unit_meas LOOP
      IF (compare_with_unit_meas_ IS NULL) THEN
         compare_with_unit_meas_ := rec_.unit_meas;
      ELSE
         IF (rec_.unit_meas != compare_with_unit_meas_) THEN
            conversion_factor_ :=Technical_Unit_Conv_API.Get_Conv_Factor(compare_with_unit_meas_,rec_.unit_meas);
            IF (conversion_factor_ != 1) THEN
               unit_meas_different_on_sites_ := TRUE;
               EXIT;
            END IF;
         END IF;
      END IF;
   END LOOP;

   RETURN (unit_meas_different_on_sites_);
END Unit_Meas_Different_On_Sites;


--@IgnoreMissingSysinit
FUNCTION Get_Putaway_Zone_Refill_Opt_Db (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   putaway_zone_refill_option_ inventory_part_tab.putaway_zone_refill_option%TYPE;
BEGIN
   Update_Cache___(contract_, part_no_);
   putaway_zone_refill_option_ := micro_cache_value_.putaway_zone_refill_option;
   IF (putaway_zone_refill_option_ IS NULL) THEN
      putaway_zone_refill_option_ := Site_Invent_Info_API.Get_Putaway_Zone_Refill_Opt_Db(contract_);
   END IF;
   RETURN putaway_zone_refill_option_;
END Get_Putaway_Zone_Refill_Opt_Db;


--@IgnoreMissingSysinit
FUNCTION Get_Putaway_Refill_Option_Src(
   contract_ IN VARCHAR2, 
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   putaway_zone_refill_option_ inventory_part_tab.putaway_zone_refill_option%TYPE;
   source_                     VARCHAR2(200);
BEGIN
   Update_Cache___(contract_, part_no_);
   putaway_zone_refill_option_ := micro_cache_value_.putaway_zone_refill_option;
   IF (putaway_zone_refill_option_ IS NULL) THEN
      source_ := Planning_Hierarchy_Source_API.DB_SITE;
   ELSE
      source_ := Planning_Hierarchy_Source_API.DB_INVENTORY_PART;
   END IF;
   RETURN Planning_Hierarchy_Source_API.Decode(source_);
END Get_Putaway_Refill_Option_Src;


--@IgnoreMissingSysinit
FUNCTION Get_Putaway_Zone_Refill_Option (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN Putaway_Zone_Refill_Option_API.Decode(Get_Putaway_Zone_Refill_Opt_Db(contract_, part_no_));
END Get_Putaway_Zone_Refill_Option;


--@IgnoreMissingSysinit
FUNCTION Get_Ultd_Expected_Supply_Date (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN DATE
IS
   ultd_expected_supply_date_ DATE;
   lu_rec_                    inventory_part_tab%ROWTYPE;
BEGIN
   lu_rec_                    := Get_Object_By_Keys___(contract_, part_no_);
   ultd_expected_supply_date_ := Get_Ultd_Expect_Supply_Date__(contract_,
                                                                 part_no_,
                                                                 lu_rec_.lead_time_code,
                                                                 Site_API.Get_Dist_Calendar_Id(contract_),
                                                                 Site_API.Get_Manuf_Calendar_Id(contract_),
                                                                 Site_API.Get_Site_Date(contract_));
   RETURN (ultd_expected_supply_date_);
END Get_Ultd_Expected_Supply_Date;


--@IgnoreMissingSysinit
FUNCTION Get_Ultd_Manuf_Supply_Date (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN DATE
IS
BEGIN
   RETURN Get_Ultd_Manuf_Supply_Date__(contract_,
                                       part_no_,
                                       Site_API.Get_Manuf_Calendar_Id(contract_),
                                       Site_API.Get_Site_Date(contract_));
END Get_Ultd_Manuf_Supply_Date;


--@IgnoreMissingSysinit
FUNCTION Get_Ultd_Purch_Supply_Date (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN DATE
IS
BEGIN
   RETURN Get_Ultd_Purch_Supply_Date__(contract_,
                                       part_no_,
                                       Site_API.Get_Dist_Calendar_Id(contract_),
                                       Site_API.Get_Site_Date(contract_));
END Get_Ultd_Purch_Supply_Date;


PROCEDURE Exist_With_Wildcard (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 )
IS
   dummy_ NUMBER;
   exist_ BOOLEAN;

   CURSOR exist_control IS
      SELECT 1
        FROM inventory_part_tab
       WHERE contract = contract_
         AND part_no LIKE NVL(part_no_,'%');
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Exist_With_Wildcard');
   IF (INSTR(NVL(part_no_,'%'), '%') = 0) THEN
      --No wildcard
      Exist(contract_, part_no_);
   ELSE
      --Wildcard
      OPEN exist_control;
      FETCH exist_control INTO dummy_;
      exist_ := exist_control%FOUND;
      CLOSE exist_control;

      IF (NOT exist_) THEN
         Error_SYS.Record_Not_Exist(lu_name_, 'WILDNOTEXIST: Search criteria :P1 does not match any Inventory Part on Site :P2.', part_no_, contract_);
      END IF;
   END IF;
END Exist_With_Wildcard;


FUNCTION Transf_Invent_Part_To_Eng_Rev (
   target_key_ref_   IN VARCHAR2,
   service_name_     IN VARCHAR2 ) RETURN VARCHAR2
IS
   source_key_ref_            VARCHAR2(2000);
   contract_                  inventory_part_tab.contract%TYPE;
   part_no_                   inventory_part_tab.part_no%TYPE; 
   eng_chg_level_             VARCHAR2(6);
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Transf_Invent_Part_To_Eng_Rev');
   $IF Component_Mfgstd_SYS.INSTALLED $THEN
      contract_       := Client_SYS.Get_Key_Reference_Value(target_key_ref_, 'CONTRACT');
      part_no_        := Client_SYS.Get_Key_Reference_Value(target_key_ref_, 'PART_NO'); 

      eng_chg_level_  := Inventory_Part_Revision_API.Get_Eng_Chg_Level(contract_, part_no_, Site_API.Get_Site_Date(contract_));
      
      
      source_key_ref_ := 'PART_NO=' || part_no_ ||
                         '^PART_REV=' || Part_Revision_API.Get_Eng_Revision(contract_, part_no_, eng_chg_level_) ||'^';
   $END  
   RETURN source_key_ref_;
END Transf_Invent_Part_To_Eng_Rev;


PROCEDURE Create_Data_Capture_Lov (
   contract_           IN VARCHAR2,
   capture_session_id_ IN NUMBER,
   type_code_          IN VARCHAR2 DEFAULT NULL,
   part_no_            IN VARCHAR2 DEFAULT NULL,
   lov_id_             IN NUMBER DEFAULT 1 )
IS
   lov_item_description_ VARCHAR2(200);
   session_rec_          Data_Capture_Common_Util_API.Session_Rec;
   lov_row_limitation_   NUMBER;
   exit_lov_             BOOLEAN := FALSE;

   CURSOR get_list_of_values1 IS
      SELECT part_no, description, type_code
      FROM   INVENTORY_PART_LOV2
      WHERE  contract = contract_
      AND    type_code = NVL(type_code_, type_code)
      ORDER BY Utility_SYS.String_To_Number(part_no) ASC, part_no ASC;

   CURSOR get_list_of_values2 IS
      SELECT distinct(contract)
      FROM   INVENTORY_PART_LOV2
      WHERE  part_no = part_no_
      ORDER BY Utility_SYS.String_To_Number(contract) ASC, contract ASC;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Create_Data_Capture_Lov', server_only_ => TRUE);
   $IF Component_Wadaco_SYS.INSTALLED $THEN
      session_rec_ := Data_Capture_Session_API.Get_Session_Rec(capture_session_id_);    
      lov_row_limitation_ := Data_Capture_Config_API.Get_Lov_Row_Limitation(session_rec_.capture_process_id, session_rec_.capture_config_id);

      IF (lov_id_ = 1) THEN
         FOR lov_rec_ IN get_list_of_values1 LOOP
            lov_item_description_ := lov_rec_.description;
            Data_Capture_Session_Lov_API.New(exit_lov_              => exit_lov_,
                                             capture_session_id_    => capture_session_id_,
                                             lov_item_value_        => lov_rec_.part_no,
                                             lov_item_description_  => lov_item_description_,
                                             lov_row_limitation_    => lov_row_limitation_,    
                                             session_rec_           => session_rec_);
            EXIT WHEN exit_lov_;
         END LOOP;
      ELSIF (lov_id_ = 2) THEN
         -- NOTE that this LOV actually fetches contract
         FOR lov_rec_ IN get_list_of_values2 LOOP
            Data_Capture_Session_Lov_API.New(exit_lov_              => exit_lov_,
                                             capture_session_id_    => capture_session_id_,
                                             lov_item_value_        => lov_rec_.contract,
                                             lov_item_description_  => NULL,
                                             lov_row_limitation_    => lov_row_limitation_,    
                                             session_rec_           => session_rec_);
            EXIT WHEN exit_lov_;
         END LOOP;
      END IF;
   $ELSE
      NULL;
   $END
END Create_Data_Capture_Lov;


--@IgnoreMissingSysinit
FUNCTION Get_Media_Id (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2) RETURN ROWID
IS
   media_id_   ROWID;
   objid_      INVENTORY_PART.objid%TYPE;
   objversion_ INVENTORY_PART.objversion%TYPE;
BEGIN
   Get_Id_Version_By_Keys___(objid_, objversion_, contract_, part_no_);
   media_id_ := Media_Library_Item_API.Get_Def_Media_Obj_Id(Media_Library_API.Get_Library_Id_From_Obj_Id(lu_name_, objid_));
   RETURN media_id_;
END Get_Media_Id;


PROCEDURE Check_Negative_On_Hand (
   neg_on_hand_allowed_db_          IN VARCHAR2,
   catch_unit_enabled_db_           IN VARCHAR2,
   receipt_issue_serial_track_db_   IN VARCHAR2,
   lot_tracking_code_db_            IN VARCHAR2 )
IS
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Check_Negative_On_Hand');
   IF (neg_on_hand_allowed_db_ = Negative_On_Hand_API.DB_NEGATIVE_ON_HAND_ALLOWED) THEN
      IF (catch_unit_enabled_db_ = Fnd_Boolean_API.db_true ) THEN
         Error_SYS.Record_General(lu_name_,'CATCHUNITENABLED: Negative On Hand cannot be allowed when catch unit is enabled.');
      END IF;
      IF (receipt_issue_serial_track_db_ = Fnd_Boolean_API.db_true OR  lot_tracking_code_db_ != Part_Lot_Tracking_API.DB_NOT_LOT_TRACKING) THEN
         Error_SYS.Record_General(lu_name_,'NEGONHANDNOTALLOWED: Negative On Hand cannot be allowed when the part is Lot or Serial Tracked.');
      END IF;
   END IF;
END Check_Negative_On_Hand;


--@IgnoreMissingSysinit
FUNCTION Get_Latest_Order_Date (
   contract_      IN VARCHAR2,
   part_no_       IN VARCHAR2,
   date_required_ IN DATE ) RETURN DATE
IS
   unlimited_supply_date_     DATE;
   unlimited_supply_date_tmp_ DATE;
   local_date_required_       DATE;
   old_order_date_            DATE;
   order_date_                DATE;
   order_date_tmp_            DATE;
   next_working_day_          DATE;
   too_late_order_date_       DATE;
   calendar_id_               VARCHAR2(10);
BEGIN
   local_date_required_ := TRUNC(date_required_);
   Update_Cache___(contract_, part_no_);
   calendar_id_ := CASE micro_cache_value_.lead_time_code
                      WHEN Inv_Part_Lead_Time_Code_API.DB_PURCHASED THEN Site_API.Get_Dist_Calendar_Id(contract_)
                      ELSE                                               Site_API.Get_Manuf_Calendar_Id(contract_)
                      END;
   -- Start the trial-and-error with assuming that we can order one work day before the date_required
   order_date_ := work_time_calendar_API.Get_Prior_Work_Day(calendar_id_, local_date_required_ - 1);
   LOOP
      unlimited_supply_date_ := NULL;
      order_date_tmp_        := order_date_;
      old_order_date_        := order_date_;
      LOOP
          IF (micro_cache_value_.lead_time_code = Inv_Part_Lead_Time_Code_API.DB_PURCHASED) THEN
             unlimited_supply_date_tmp_ := Inventory_Part_API.Get_Ultd_Purch_Supply_Date__(contract_         => contract_,
                                                                                       part_no_          => part_no_,
                                                                                       dist_calendar_id_ => calendar_id_,
                                                                                       site_date_        => order_date_tmp_);
          ELSE
             unlimited_supply_date_tmp_ := Inventory_Part_API.Get_Ultd_Manuf_Supply_Date__(contract_          => contract_,
                                                                                       part_no_           => part_no_,
                                                                                       manuf_calendar_id_ => calendar_id_,
                                                                                       site_date_         => order_date_tmp_);
          END IF;
          IF unlimited_supply_date_tmp_ IS NULL THEN
             EXIT;
          END IF;
          IF unlimited_supply_date_ IS NULL OR unlimited_supply_date_ = unlimited_supply_date_tmp_ THEN
             unlimited_supply_date_ := unlimited_supply_date_tmp_;
             order_date_ := order_date_tmp_;
             order_date_tmp_ := work_time_calendar_API.Get_Next_Work_day(calendar_id_,order_date_tmp_);
          ELSE
             EXIT;
          END IF;           
      END LOOP;
      IF (unlimited_supply_date_ < local_date_required_) THEN
         -- There is no point in placing the order this early. Try with the following work day.
         next_working_day_ := work_time_calendar_API.Get_Next_Work_day(calendar_id_ , order_date_);
         IF (next_working_day_ >= too_late_order_date_) THEN
            -- we have already found out that when ordering on the next working day we get the supply too late.
            -- So we have found the latest possible order date. Let's return it.
           EXIT;
         END IF;
         order_date_ := next_working_day_;
      ELSIF (unlimited_supply_date_ > local_date_required_) THEN
         -- we need to place the order at an earlier date.
         IF (unlimited_supply_date_ = micro_cache_value_.earliest_ultd_supply_date) THEN
            -- there will not be any earlier supply date regardless how early we place the order.
            -- So the date_required is impossible and therefore we return NULL.
            order_date_ := NULL;
            EXIT;
         END IF;
         -- order date was too late, so lets take a note on that.
         too_late_order_date_ := old_order_date_;
         -- Try again with an earlier order date. Reduce the current suggested order date with the number of days that differs
         -- between the supply date that we got and the supply date that we wish to have.
         order_date_ := old_order_date_ - (unlimited_supply_date_ - local_date_required_);
      ELSE
         -- We have managed to find an order date that gives us the exact supply date that we require. 
           EXIT;
      END IF;
   END LOOP;

   RETURN(order_date_);
END Get_Latest_Order_Date;

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC PRIVATE METHODS ----------------------------
-----------------------------------------------------------------------------

PROCEDURE New__ (
   info_       OUT    VARCHAR2,
   objid_      OUT    VARCHAR2,
   objversion_ OUT    VARCHAR2,
   attr_       IN OUT NOCOPY VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   
   PROCEDURE Base (
      info_       OUT    VARCHAR2,
      objid_      OUT    VARCHAR2,
      objversion_ OUT    VARCHAR2,
      attr_       IN OUT NOCOPY VARCHAR2,
      action_     IN     VARCHAR2 )
   IS
      newrec_   inventory_part_tab%ROWTYPE;
      indrec_   Indicator_Rec;
   BEGIN
      IF (action_ = 'PREPARE') THEN
         Prepare_Insert___(attr_);
      ELSIF (action_ = 'CHECK') THEN
         Unpack___(newrec_, indrec_, attr_);
         Check_Insert___(newrec_, indrec_, attr_);
      ELSIF (action_ = 'DO') THEN
         Unpack___(newrec_, indrec_, attr_);
         Check_Insert___(newrec_, indrec_, attr_);
         Insert___(objid_, objversion_, newrec_, attr_);
      END IF;
      info_ := Client_SYS.Get_All_Info;
   END Base;

   PROCEDURE Core (
      info_       OUT    VARCHAR2,
      objid_      OUT    VARCHAR2,
      objversion_ OUT    VARCHAR2,
      attr_       IN OUT NOCOPY VARCHAR2,
      action_     IN     VARCHAR2 )
   IS
      newrec_                      inventory_part_tab%ROWTYPE;
      new_estimated_material_cost_ NUMBER; 
   BEGIN
      --Add pre-processing code here
      Base(info_, objid_, objversion_, attr_, action_);
      IF action_ = 'DO' THEN
         newrec_ := Get_Object_By_Id___(objid_);
         new_estimated_material_cost_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('ESTIMATED_MATERIAL_COST', attr_));
         IF ((NVL(new_estimated_material_cost_,0) != 0) AND
             (newrec_.zero_cost_flag != 'O')) THEN
            Inventory_Part_Config_API.Modify_Standard_Cost__(newrec_.contract,
                                                             newrec_.part_no,
                                                             '*',
                                                             new_estimated_material_cost_);
         END IF;
   
         -- Communicating info that is decided in the server, back to the client after inserting a record.
         Client_SYS.Add_To_Attr('INVENTORY_VALUATION_METHOD',Inventory_Value_Method_API.Decode(newrec_.inventory_valuation_method),attr_);
         Client_SYS.Add_To_Attr('INVOICE_CONSIDERATION',Invoice_Consideration_API.Decode(newrec_.invoice_consideration),attr_);
         Client_SYS.Add_To_Attr('NEGATIVE_ON_HAND_DB',newrec_.negative_on_hand,attr_);
         Client_SYS.Add_To_Attr('NOTE_ID', newrec_.note_id, attr_);
         Client_SYS.Add_To_Attr('LEAD_TIME_CODE', Inv_Part_Lead_Time_Code_API.Decode(newrec_.lead_time_code), attr_);
         Client_SYS.Add_To_Attr('CREATE_DATE', newrec_.create_date, attr_);
         Client_SYS.Add_To_Attr('LAST_ACTIVITY_DATE', newrec_.last_activity_date, attr_);
         Client_SYS.Add_To_Attr('SHORTAGE_FLAG_DB', newrec_.shortage_flag,attr_);
         Client_SYS.Add_To_Attr('ONHAND_ANALYSIS_FLAG_DB',newrec_.Onhand_Analysis_Flag,attr_);
         Client_SYS.Add_To_Attr('FORECAST_CONSUMPTION_FLAG_DB',newrec_.Forecast_Consumption_Flag,attr_);
         Client_SYS.Add_To_Attr('OE_ALLOC_ASSIGN_FLAG',Cust_Ord_Reservation_Type_API.Decode(newrec_.oe_alloc_assign_flag),attr_);
         Client_SYS.Add_To_Attr('TECHNICAL_COORDINATOR_ID',newrec_.technical_coordinator_id,attr_);
         Client_SYS.Add_To_Attr('INVENTORY_PART_COST_LEVEL',Inventory_Part_Cost_Level_API.Decode(newrec_.inventory_part_cost_level),attr_);
         Client_SYS.Add_To_Attr('EXT_SERVICE_COST_METHOD', Ext_Service_Cost_Method_API.Decode(newrec_.ext_service_cost_method), attr_);
      END IF;
      --Add post-processing code here
   END Core;

BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'New__');
   Core(info_, objid_, objversion_, attr_, action_);
END New__;


PROCEDURE Modify__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT NOCOPY VARCHAR2,
   attr_       IN OUT NOCOPY VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   
   PROCEDURE Base (
      info_       OUT    VARCHAR2,
      objid_      IN     VARCHAR2,
      objversion_ IN OUT NOCOPY VARCHAR2,
      attr_       IN OUT NOCOPY VARCHAR2,
      action_     IN     VARCHAR2 )
   IS
      oldrec_   inventory_part_tab%ROWTYPE;
      newrec_   inventory_part_tab%ROWTYPE;
      indrec_   Indicator_Rec;
   BEGIN
      IF (action_ = 'CHECK') THEN
         oldrec_ := Get_Object_By_Id___(objid_);
         newrec_ := oldrec_;
         Unpack___(newrec_, indrec_, attr_);
         Check_Update___(oldrec_, newrec_, indrec_, attr_);
      ELSIF (action_ = 'DO') THEN
         oldrec_ := Lock_By_Id___(objid_, objversion_);
         newrec_ := oldrec_;
         Unpack___(newrec_, indrec_, attr_);
         Check_Update___(oldrec_, newrec_, indrec_, attr_);
         Update___(objid_, oldrec_, newrec_, attr_, objversion_);
      END IF;
      info_ := Client_SYS.Get_All_Info;
   END Base;

   PROCEDURE Core (
      info_       OUT    VARCHAR2,
      objid_      IN     VARCHAR2,
      objversion_ IN OUT NOCOPY VARCHAR2,
      attr_       IN OUT NOCOPY VARCHAR2,
      action_     IN     VARCHAR2 )
   IS
       newrec_     inventory_part_tab%ROWTYPE;
   BEGIN
      --Add pre-processing code here
      Base(info_, objid_, objversion_, attr_, action_);
      IF action_ = 'DO' THEN
         newrec_ := Get_Object_By_Id___(objid_);
         -- Communicating info that is decided in the server, back to the client after updating a record.
         Client_SYS.Add_To_Attr('LAST_ACTIVITY_DATE', newrec_.last_activity_date, attr_);
         Client_SYS.Add_To_Attr('LEAD_TIME_CODE', Inv_Part_Lead_Time_Code_API.Decode(newrec_.lead_time_code), attr_);
         Client_SYS.Add_To_Attr('STOCK_MANAGEMENT', Inventory_Part_Management_API.Decode(newrec_.stock_management), attr_);
         Client_SYS.Add_To_Attr('SHORTAGE_FLAG_DB', newrec_.shortage_flag,attr_);
         Client_SYS.Add_To_Attr('ONHAND_ANALYSIS_FLAG_DB',newrec_.Onhand_Analysis_Flag,attr_);
         Client_SYS.Add_To_Attr('FORECAST_CONSUMPTION_FLAG_DB',newrec_.Forecast_Consumption_Flag,attr_);
         Client_SYS.Add_To_Attr('OE_ALLOC_ASSIGN_FLAG',Cust_Ord_Reservation_Type_API.Decode(newrec_.oe_alloc_assign_flag),attr_); 
      END IF; 
      --Add post-processing code here
   END Core;

BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Modify__');
   Core(info_, objid_, objversion_, attr_, action_);
END Modify__;


PROCEDURE Recalc_Stockfactors_Impl__ (
   attrib_ IN VARCHAR2 )
IS
   average_period_      NUMBER;
   work_days_           NUMBER;
   rows_changed_        NUMBER;
   records_changed_     NUMBER;
   contract_            inventory_part_tab.contract%TYPE;
   second_commodity_    inventory_part_tab.second_commodity%TYPE;
   periods_             NUMBER;
   ptr_                 NUMBER;
   name_                VARCHAR2(30);
   value_               VARCHAR2(2000);
   periods_per_year_    NUMBER;
   manuf_median_period_ NUMBER;
   purch_median_period_ NUMBER;

   CURSOR get_parts IS
      SELECT ip.part_no,
             ip.contract,
             ip.second_commodity,
             ip.lead_time_code,
             ip.manuf_leadtime,
             ip.purch_leadtime
      FROM   inventory_part_planning_pub ipp, inventory_part_tab ip, user_allowed_site_pub
      WHERE  (ipp.safety_stock_auto_db = 'Y' OR ipp.order_point_qty_auto_db = 'Y' OR ipp.lot_size_auto_db = 'Y')
      AND    ip.part_no = ipp.part_no
      AND    ip.contract = ipp.contract
      AND    (ip.second_commodity = second_commodity_ OR second_commodity_ IS NULL)
      AND    ip.contract = site
      AND    (ip.contract = contract_ OR contract_ IS NULL);
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Recalc_Stockfactors_Impl__');
   ptr_ := NULL;
   WHILE (Client_SYS.Get_Next_From_Attr(attrib_, ptr_, name_, value_)) LOOP
    IF (name_ = 'CONTRACT') THEN
       contract_ := value_;
    ELSIF (name_ = 'SECOND_COMMODITY') THEN
       second_commodity_:= value_;
    ELSIF (name_ = 'PERIODS') THEN
       periods_:= Client_SYS.Attr_Value_To_Number(value_);
    ELSE
       Error_SYS.Item_Not_Exist(lu_name_, name_, value_);
    END IF;
   END LOOP;

   rows_changed_    := 0;
   records_changed_ := 0;

   -- Retrieve number of workdays in a week
   work_days_ := 0;
   work_days_ := Site_Invent_Info_API.Get_Avg_Work_Days_Per_Week(contract_);

   -- Retrieve general statistic data.
   average_period_ := Statistic_Period_API.Get_Average_Period;
   periods_per_year_ := Statistic_Period_API.Get_Periods_Per_Year;
   Statistic_Period_API.Get_Median_Period(manuf_median_period_, average_period_, work_days_, 'M');
   Statistic_Period_API.Get_Median_Period(purch_median_period_, average_period_, work_days_, 'P');

   -- Loop over all parts in question and modify their stockfactors.
   FOR rec_ IN get_parts LOOP
      Inventory_Part_Planning_API.Modify_Stockfactors(rows_changed_,
                                                      rec_.contract,
                                                      rec_.part_no,
                                                      rec_.second_commodity,
                                                      periods_,
                                                      work_days_,
                                                      manuf_median_period_,
                                                      purch_median_period_,
                                                      periods_per_year_,
                                                      rec_.lead_time_code,
                                                      rec_.manuf_leadtime,
                                                      rec_.purch_leadtime);
      IF (rows_changed_ > 0) THEN
         records_changed_ := records_changed_ + 1;
         Trace_SYS.Field('records_changed_',records_changed_);
         
      END IF;
   END LOOP;
   Trace_SYS.Message('Recalc_Stockfactors ended. Changed: ' || to_char(records_changed_));
END Recalc_Stockfactors_Impl__;


PROCEDURE Copy_Part_To_Site_Impl__ (
   attr_ IN VARCHAR2 )
IS
   from_contract_           inventory_part_tab.contract%TYPE;
   from_second_commodity_   inventory_part_tab.second_commodity%TYPE;
   to_contract_             inventory_part_tab.contract%TYPE;
   noninv_sales_part_exist_ NUMBER;

   CURSOR get_parts IS
      SELECT part_no
      FROM inventory_part_tab
      WHERE NVL(second_commodity, '%') LIKE from_second_commodity_
      AND   contract = from_contract_
      AND   part_no NOT IN (SELECT part_no FROM inventory_part_tab
                            WHERE contract = to_contract_);
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Copy_Part_To_Site_Impl__');
   from_contract_         := Client_SYS.Get_Item_Value('FROM_CONTRACT', attr_);
   from_second_commodity_ := NVL(Client_SYS.Get_Item_Value('FROM_SECOND_COMMODITY', attr_), '%');
   to_contract_           := Client_SYS.Get_Item_Value('TO_CONTRACT', attr_);
   FOR part_rec IN get_parts LOOP
      -- Loop for selected parts --
      noninv_sales_part_exist_ := 0 ;
      $IF (Component_Order_SYS.INSTALLED) $THEN
         DECLARE
            temp_ VARCHAR2(4);
         BEGIN
            temp_ := Sales_Part_API.Get_Catalog_Type_Db(to_contract_, part_rec.part_no);
            IF (temp_ IS NOT NULL)THEN
               IF (temp_ = 'NON')THEN
                 noninv_sales_part_exist_ := 1 ;
               END IF;
            END IF;
         END;
      $END     
      IF (noninv_sales_part_exist_ = 0)THEN
         Copy (to_contract_, part_rec.part_no, from_contract_, part_rec.part_no);
      END IF;
   END LOOP;
END Copy_Part_To_Site_Impl__;


PROCEDURE Pack_And_Post_Message__ (
   action_   IN VARCHAR2,
   part_no_  IN VARCHAR2,
   contract_ IN VARCHAR2 DEFAULT NULL )
IS
   hse_contract_              VARCHAR2(5);   
   invent_attrib_rec_         Part_Catalog_Invent_Attrib_API.Public_rec;
   hse_inv_part_params_rec_   Plsqlap_Record_API.Type_Record_;
   xml_                       CLOB;
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Pack_And_Post_Message__');
   invent_attrib_rec_   := Part_Catalog_Invent_Attrib_API.Get(part_no_);
   hse_contract_        := invent_attrib_rec_.hse_contract;
   
   $IF (Component_Mfgstd_SYS.INSTALLED) $THEN
      hse_inv_part_params_rec_ := Plsqlap_Record_API.New_Record('HSE_INV_PART_PARAMS');
      Plsqlap_Record_API.Set_Value(hse_inv_part_params_rec_, 'SITE', hse_contract_);
      Plsqlap_Record_API.Set_Value(hse_inv_part_params_rec_, 'PART_NO', part_no_);
      
      IF (action_ = 'ADDEDIT') THEN
         Plsqlap_Record_API.To_Xml(xml_, hse_inv_part_params_rec_);
         Plsqlap_Server_API.Post_Outbound_Message( xml_ => xml_,
                                                   sender_       => Fnd_Session_API.Get_Fnd_User,
                                                   receiver_     => 'HSEInventoryPart');

         Hse_Structure_Transfer_API.Transfer_Part_Structure(hse_contract_, part_no_);
      ELSIF (action_ = 'DELETE') THEN
         -- For delete operation, use custom event and Application Message event action to trigger BIZAPI
         NULL;
      END IF;
   $END
END Pack_And_Post_Message__;


--@IgnoreMissingSysinit
FUNCTION Get_Objid__ (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   objid_      INVENTORY_PART.objid%TYPE;
   objversion_ INVENTORY_PART.objversion%TYPE;
BEGIN
   Get_Id_Version_By_Keys___(objid_, objversion_, contract_, part_no_);
   RETURN (objid_);
END Get_Objid__;


--@IgnoreMissingSysinit
FUNCTION Get_Ultd_Expect_Supply_Date__ (
   contract_          IN VARCHAR2,
   part_no_           IN VARCHAR2,
   lead_time_code_db_ IN VARCHAR2,
   dist_calendar_id_  IN VARCHAR2,
   manuf_calendar_id_ IN VARCHAR2,
   site_date_         IN DATE ) RETURN DATE
IS
   ultd_expected_supply_date_ DATE;
   stop_analysis_date_        DATE;
   calendar_id_               VARCHAR2(10);
BEGIN
   IF (lead_time_code_db_ = Inv_Part_Lead_Time_Code_API.DB_PURCHASED) THEN
      calendar_id_ := dist_calendar_id_;
   ELSE
      calendar_id_ := manuf_calendar_id_;
   END IF;

   stop_analysis_date_ := Get_Stop_Analysis_Date(contract_,
                                                 part_no_,
                                                 site_date_,
                                                 dist_calendar_id_,
                                                 manuf_calendar_id_,
                                                 'TRUE',
                                                 'TRUE');
   
   -- The same method as Get_Closest_Work_Day but without internal error handling.
   ultd_expected_supply_date_ := Work_Time_Calendar_API.Get_Nearest_Work_Day(calendar_id_,
                                                                                  stop_analysis_date_ + 1);

   RETURN (ultd_expected_supply_date_);
END Get_Ultd_Expect_Supply_Date__;


--@IgnoreMissingSysinit
FUNCTION Get_Ultd_Manuf_Supply_Date__ (
   contract_          IN VARCHAR2,
   part_no_           IN VARCHAR2,
   manuf_calendar_id_ IN VARCHAR2,
   site_date_         IN DATE ) RETURN DATE
IS
   ultd_manuf_supply_date_ DATE;
   stop_analysis_date_     DATE;
BEGIN
   stop_analysis_date_ := Get_Stop_Analysis_Date___(contract_                    => contract_,
                                                    part_no_                     => part_no_,
                                                    site_date_                   => site_date_,
                                                    dist_calendar_id_            => NULL,
                                                    manuf_calendar_id_           => manuf_calendar_id_,
                                                    detect_supplies_not_allowed_ => TRUE,
                                                    use_expected_leadtime_       => FALSE,
                                                    lead_time_code_db_           => Inv_Part_Lead_Time_Code_API.DB_MANUFACTURED);

   -- The same method as Get_Closest_Work_Day but without internal error handling.
   ultd_manuf_supply_date_ := Work_Time_Calendar_API.Get_Nearest_Work_Day(manuf_calendar_id_,
                                                                               stop_analysis_date_ + 1);
   RETURN (ultd_manuf_supply_date_);
END Get_Ultd_Manuf_Supply_Date__;


--@IgnoreMissingSysinit
FUNCTION Get_Ultd_Purch_Supply_Date__ (
   contract_          IN VARCHAR2,
   part_no_           IN VARCHAR2,
   dist_calendar_id_  IN VARCHAR2,
   site_date_         IN DATE ) RETURN DATE
IS
   ultd_purch_supply_date_ DATE;
   stop_analysis_date_     DATE;
BEGIN
   stop_analysis_date_ := Get_Stop_Analysis_Date___(contract_                    => contract_,
                                                    part_no_                     => part_no_,
                                                    site_date_                   => site_date_,
                                                    dist_calendar_id_            => dist_calendar_id_,
                                                    manuf_calendar_id_           => NULL,
                                                    detect_supplies_not_allowed_ => TRUE,
                                                    use_expected_leadtime_       => FALSE,
                                                    lead_time_code_db_           => Inv_Part_Lead_Time_Code_API.DB_PURCHASED);

   -- The same method as Get_Closest_Work_Day but without internal error handling.
   ultd_purch_supply_date_ := Work_Time_Calendar_API.Get_Nearest_Work_Day(dist_calendar_id_,
                                                                               stop_analysis_date_ + 1);
   RETURN (ultd_purch_supply_date_);
END Get_Ultd_Purch_Supply_Date__;

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC IMPLEMENTATION METHODS ---------------------
-----------------------------------------------------------------------------

PROCEDURE Raise_Record_Not_Exist___ (
   contract_ IN VARCHAR2,
   part_no_ IN VARCHAR2 )
IS
   
   PROCEDURE Base (
      contract_ IN VARCHAR2,
      part_no_ IN VARCHAR2 )
   IS
   BEGIN
      Error_SYS.Set_Key_Values(Key_Message___(contract_, part_no_),
                               Formatted_Key___(contract_, part_no_));
      Error_SYS.Fnd_Record_Not_Exist(Inventory_Part_API.lu_name_);
   END Base;

   PROCEDURE Core (
      contract_ IN VARCHAR2,
      part_no_ IN VARCHAR2 )
   IS
   BEGIN
      --Add pre-processing code here
      Raise_Inv_Part_Not_Exist___(contract_,part_no_);
      Base(contract_, part_no_);
      --Add post-processing code here   
   END Core;

BEGIN
   Core(contract_, part_no_);
END Raise_Record_Not_Exist___;


PROCEDURE Check_Common___ (
   oldrec_ IN     inventory_part_tab%ROWTYPE,
   newrec_ IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   indrec_ IN OUT NOCOPY Indicator_Rec,
   attr_   IN OUT NOCOPY VARCHAR2 )
IS
   
   PROCEDURE Base (
      oldrec_ IN     inventory_part_tab%ROWTYPE,
      newrec_ IN OUT NOCOPY inventory_part_tab%ROWTYPE,
      indrec_ IN OUT NOCOPY Indicator_Rec,
      attr_   IN OUT NOCOPY VARCHAR2 )
   IS
   BEGIN
      IF (newrec_.region_of_origin IS NOT NULL
          AND indrec_.region_of_origin
          AND Validate_SYS.Is_Changed(oldrec_.region_of_origin, newrec_.region_of_origin)) THEN
         Error_SYS.Check_Upper(lu_name_, 'REGION_OF_ORIGIN', newrec_.region_of_origin);
      END IF;
      IF (newrec_.cycle_code IS NOT NULL)
      AND (indrec_.cycle_code)
      AND (Validate_SYS.Is_Changed(oldrec_.cycle_code, newrec_.cycle_code)) THEN
         Inventory_Part_Count_Type_API.Exist_Db(newrec_.cycle_code);
      END IF;
      IF (newrec_.lead_time_code IS NOT NULL)
      AND (indrec_.lead_time_code)
      AND (Validate_SYS.Is_Changed(oldrec_.lead_time_code, newrec_.lead_time_code)) THEN
         Inv_Part_Lead_Time_Code_API.Exist_Db(newrec_.lead_time_code);
      END IF;
      IF (newrec_.oe_alloc_assign_flag IS NOT NULL)
      AND (indrec_.oe_alloc_assign_flag)
      AND (Validate_SYS.Is_Changed(oldrec_.oe_alloc_assign_flag, newrec_.oe_alloc_assign_flag)) THEN
         Cust_Ord_Reservation_Type_API.Exist_Db(newrec_.oe_alloc_assign_flag);
      END IF;
      IF (newrec_.onhand_analysis_flag IS NOT NULL)
      AND (indrec_.onhand_analysis_flag)
      AND (Validate_SYS.Is_Changed(oldrec_.onhand_analysis_flag, newrec_.onhand_analysis_flag)) THEN
         Inventory_Part_Onh_Analys_API.Exist_Db(newrec_.onhand_analysis_flag);
      END IF;
      IF (newrec_.supply_code IS NOT NULL)
      AND (indrec_.supply_code)
      AND (Validate_SYS.Is_Changed(oldrec_.supply_code, newrec_.supply_code)) THEN
         Material_Requis_Supply_API.Exist_Subset1_Db(newrec_.supply_code);
      END IF;
      IF (newrec_.type_code IS NOT NULL)
      AND (indrec_.type_code)
      AND (Validate_SYS.Is_Changed(oldrec_.type_code, newrec_.type_code)) THEN
         Inventory_Part_Type_API.Exist_Db(newrec_.type_code);
      END IF;
      IF (newrec_.zero_cost_flag IS NOT NULL)
      AND (indrec_.zero_cost_flag)
      AND (Validate_SYS.Is_Changed(oldrec_.zero_cost_flag, newrec_.zero_cost_flag)) THEN
         Inventory_Part_Zero_Cost_API.Exist_Db(newrec_.zero_cost_flag);
      END IF;
      IF (newrec_.avail_activity_status IS NOT NULL)
      AND (indrec_.avail_activity_status)
      AND (Validate_SYS.Is_Changed(oldrec_.avail_activity_status, newrec_.avail_activity_status)) THEN
         Inventory_Part_Avail_Stat_API.Exist_Db(newrec_.avail_activity_status);
      END IF;
      IF (newrec_.shortage_flag IS NOT NULL)
      AND (indrec_.shortage_flag)
      AND (Validate_SYS.Is_Changed(oldrec_.shortage_flag, newrec_.shortage_flag)) THEN
         Inventory_Part_Shortage_API.Exist_Db(newrec_.shortage_flag);
      END IF;
      IF (newrec_.forecast_consumption_flag IS NOT NULL)
      AND (indrec_.forecast_consumption_flag)
      AND (Validate_SYS.Is_Changed(oldrec_.forecast_consumption_flag, newrec_.forecast_consumption_flag)) THEN
         Inv_Part_Forecast_Consum_API.Exist_Db(newrec_.forecast_consumption_flag);
      END IF;
      IF (newrec_.stock_management IS NOT NULL)
      AND (indrec_.stock_management)
      AND (Validate_SYS.Is_Changed(oldrec_.stock_management, newrec_.stock_management)) THEN
         Inventory_Part_Management_API.Exist_Db(newrec_.stock_management);
      END IF;
      IF (newrec_.dop_connection IS NOT NULL)
      AND (indrec_.dop_connection)
      AND (Validate_SYS.Is_Changed(oldrec_.dop_connection, newrec_.dop_connection)) THEN
         Dop_Connection_API.Exist_Db(newrec_.dop_connection);
      END IF;
      IF (newrec_.inventory_valuation_method IS NOT NULL)
      AND (indrec_.inventory_valuation_method)
      AND (Validate_SYS.Is_Changed(oldrec_.inventory_valuation_method, newrec_.inventory_valuation_method)) THEN
         Inventory_Value_Method_API.Exist_Db(newrec_.inventory_valuation_method);
      END IF;
      IF (newrec_.negative_on_hand IS NOT NULL)
      AND (indrec_.negative_on_hand)
      AND (Validate_SYS.Is_Changed(oldrec_.negative_on_hand, newrec_.negative_on_hand)) THEN
         Negative_On_Hand_API.Exist_Db(newrec_.negative_on_hand);
      END IF;
      IF (newrec_.invoice_consideration IS NOT NULL)
      AND (indrec_.invoice_consideration)
      AND (Validate_SYS.Is_Changed(oldrec_.invoice_consideration, newrec_.invoice_consideration)) THEN
         Invoice_Consideration_API.Exist_Db(newrec_.invoice_consideration);
      END IF;
      IF (newrec_.inventory_part_cost_level IS NOT NULL)
      AND (indrec_.inventory_part_cost_level)
      AND (Validate_SYS.Is_Changed(oldrec_.inventory_part_cost_level, newrec_.inventory_part_cost_level)) THEN
         Inventory_Part_Cost_Level_API.Exist_Db(newrec_.inventory_part_cost_level);
      END IF;
      IF (newrec_.ext_service_cost_method IS NOT NULL)
      AND (indrec_.ext_service_cost_method)
      AND (Validate_SYS.Is_Changed(oldrec_.ext_service_cost_method, newrec_.ext_service_cost_method)) THEN
         Ext_Service_Cost_Method_API.Exist_Db(newrec_.ext_service_cost_method);
      END IF;
      IF (newrec_.automatic_capability_check IS NOT NULL)
      AND (indrec_.automatic_capability_check)
      AND (Validate_SYS.Is_Changed(oldrec_.automatic_capability_check, newrec_.automatic_capability_check)) THEN
         Capability_Check_Allocate_API.Exist_Db(newrec_.automatic_capability_check);
      END IF;
      IF (newrec_.dop_netting IS NOT NULL)
      AND (indrec_.dop_netting)
      AND (Validate_SYS.Is_Changed(oldrec_.dop_netting, newrec_.dop_netting)) THEN
         Dop_Netting_API.Exist_Db(newrec_.dop_netting);
      END IF;
      IF (newrec_.co_reserve_onh_analys_flag IS NOT NULL)
      AND (indrec_.co_reserve_onh_analys_flag)
      AND (Validate_SYS.Is_Changed(oldrec_.co_reserve_onh_analys_flag, newrec_.co_reserve_onh_analys_flag)) THEN
         Inventory_Part_Onh_Analys_API.Exist_Db(newrec_.co_reserve_onh_analys_flag);
      END IF;
      IF (newrec_.lifecycle_stage IS NOT NULL)
      AND (indrec_.lifecycle_stage)
      AND (Validate_SYS.Is_Changed(oldrec_.lifecycle_stage, newrec_.lifecycle_stage)) THEN
         Inv_Part_Lifecycle_Stage_API.Exist_Db(newrec_.lifecycle_stage);
      END IF;
      IF (newrec_.frequency_class IS NOT NULL)
      AND (indrec_.frequency_class)
      AND (Validate_SYS.Is_Changed(oldrec_.frequency_class, newrec_.frequency_class)) THEN
         Inv_Part_Frequency_Class_API.Exist_Db(newrec_.frequency_class);
      END IF;
      IF (newrec_.putaway_zone_refill_option IS NOT NULL)
      AND (indrec_.putaway_zone_refill_option)
      AND (Validate_SYS.Is_Changed(oldrec_.putaway_zone_refill_option, newrec_.putaway_zone_refill_option)) THEN
         Putaway_Zone_Refill_Option_API.Exist_Db(newrec_.putaway_zone_refill_option);
      END IF;
      IF (newrec_.reset_config_std_cost IS NOT NULL)
      AND (indrec_.reset_config_std_cost)
      AND (Validate_SYS.Is_Changed(oldrec_.reset_config_std_cost, newrec_.reset_config_std_cost)) THEN
         Fnd_Boolean_API.Exist_Db(newrec_.reset_config_std_cost);
      END IF;
      IF (newrec_.mandatory_expiration_date IS NOT NULL)
      AND (indrec_.mandatory_expiration_date)
      AND (Validate_SYS.Is_Changed(oldrec_.mandatory_expiration_date, newrec_.mandatory_expiration_date)) THEN
         Fnd_Boolean_API.Exist_Db(newrec_.mandatory_expiration_date);
      END IF;
      IF (newrec_.excl_ship_pack_proposal IS NOT NULL)
      AND (indrec_.excl_ship_pack_proposal)
      AND (Validate_SYS.Is_Changed(oldrec_.excl_ship_pack_proposal, newrec_.excl_ship_pack_proposal)) THEN
         Fnd_Boolean_API.Exist_Db(newrec_.excl_ship_pack_proposal);
      END IF;
      IF (newrec_.contract IS NOT NULL)
      AND (indrec_.contract)
      AND (Validate_SYS.Is_Changed(oldrec_.contract, newrec_.contract)) THEN
         Site_API.Exist(newrec_.contract);
      END IF;
      IF (newrec_.part_no IS NOT NULL)
      AND (indrec_.part_no)
      AND (Validate_SYS.Is_Changed(oldrec_.part_no, newrec_.part_no)) THEN
         Part_Catalog_API.Exist(newrec_.part_no);
      END IF;
      IF (newrec_.accounting_group IS NOT NULL)
      AND (indrec_.accounting_group)
      AND (Validate_SYS.Is_Changed(oldrec_.accounting_group, newrec_.accounting_group)) THEN
         Accounting_Group_API.Exist(newrec_.accounting_group);
      END IF;
      IF (newrec_.asset_class IS NOT NULL)
      AND (indrec_.asset_class)
      AND (Validate_SYS.Is_Changed(oldrec_.asset_class, newrec_.asset_class)) THEN
         Asset_Class_API.Exist(newrec_.asset_class);
      END IF;
      IF (newrec_.country_of_origin IS NOT NULL)
      AND (indrec_.country_of_origin)
      AND (Validate_SYS.Is_Changed(oldrec_.country_of_origin, newrec_.country_of_origin)) THEN
         Iso_Country_API.Exist(newrec_.country_of_origin);
      END IF;
      IF (newrec_.hazard_code IS NOT NULL)
      AND (indrec_.hazard_code)
      AND (Validate_SYS.Is_Changed(oldrec_.hazard_code, newrec_.hazard_code)) THEN
         Safety_Instruction_API.Exist(newrec_.hazard_code);
      END IF;
      IF (newrec_.part_product_code IS NOT NULL)
      AND (indrec_.part_product_code)
      AND (Validate_SYS.Is_Changed(oldrec_.part_product_code, newrec_.part_product_code)) THEN
         Inventory_Product_Code_API.Exist(newrec_.part_product_code);
      END IF;
      IF (newrec_.part_product_family IS NOT NULL)
      AND (indrec_.part_product_family)
      AND (Validate_SYS.Is_Changed(oldrec_.part_product_family, newrec_.part_product_family)) THEN
         Inventory_Product_Family_API.Exist(newrec_.part_product_family);
      END IF;
      IF (newrec_.part_status IS NOT NULL)
      AND (indrec_.part_status)
      AND (Validate_SYS.Is_Changed(oldrec_.part_status, newrec_.part_status)) THEN
         Inventory_Part_Status_Par_API.Exist(newrec_.part_status);
      END IF;
      IF (newrec_.planner_buyer IS NOT NULL)
      AND (indrec_.planner_buyer)
      AND (Validate_SYS.Is_Changed(oldrec_.planner_buyer, newrec_.planner_buyer)) THEN
         Inventory_Part_Planner_API.Exist(newrec_.planner_buyer);
      END IF;
      IF (newrec_.prime_commodity IS NOT NULL)
      AND (indrec_.prime_commodity)
      AND (Validate_SYS.Is_Changed(oldrec_.prime_commodity, newrec_.prime_commodity)) THEN
         Commodity_Group_API.Exist(newrec_.prime_commodity);
      END IF;
      IF (newrec_.second_commodity IS NOT NULL)
      AND (indrec_.second_commodity)
      AND (Validate_SYS.Is_Changed(oldrec_.second_commodity, newrec_.second_commodity)) THEN
         Commodity_Group_API.Exist(newrec_.second_commodity);
      END IF;
      IF (newrec_.unit_meas IS NOT NULL)
      AND (indrec_.unit_meas)
      AND (Validate_SYS.Is_Changed(oldrec_.unit_meas, newrec_.unit_meas)) THEN
         Iso_Unit_API.Exist(newrec_.unit_meas);
      END IF;
      IF (newrec_.catch_unit_meas IS NOT NULL)
      AND (indrec_.catch_unit_meas)
      AND (Validate_SYS.Is_Changed(oldrec_.catch_unit_meas, newrec_.catch_unit_meas)) THEN
         Iso_Unit_API.Exist(newrec_.catch_unit_meas);
      END IF;
      IF (newrec_.abc_class IS NOT NULL)
      AND (indrec_.abc_class)
      AND (Validate_SYS.Is_Changed(oldrec_.abc_class, newrec_.abc_class)) THEN
         Abc_Class_API.Exist(newrec_.abc_class);
      END IF;
      IF (newrec_.customs_stat_no IS NOT NULL)
      AND (indrec_.customs_stat_no)
      AND (Validate_SYS.Is_Changed(oldrec_.customs_stat_no, newrec_.customs_stat_no)) THEN
         Customs_Statistics_Number_API.Exist(newrec_.customs_stat_no);
      END IF;
      IF (newrec_.eng_attribute IS NOT NULL)
      AND (indrec_.eng_attribute)
      AND (Validate_SYS.Is_Changed(oldrec_.eng_attribute, newrec_.eng_attribute)) THEN
         Characteristic_Template_API.Exist(newrec_.eng_attribute);
      END IF;
      IF (newrec_.std_name_id IS NOT NULL)
      AND (indrec_.std_name_id)
      AND (Validate_SYS.Is_Changed(oldrec_.std_name_id, newrec_.std_name_id)) THEN
         Standard_Names_API.Exist(newrec_.std_name_id);
      END IF;
      IF (newrec_.technical_coordinator_id IS NOT NULL)
      AND (indrec_.technical_coordinator_id)
      AND (Validate_SYS.Is_Changed(oldrec_.technical_coordinator_id, newrec_.technical_coordinator_id)) THEN
         Technical_Coordinator_API.Exist(newrec_.technical_coordinator_id);
      END IF;
      IF (newrec_.cust_warranty_id IS NOT NULL)
      AND (indrec_.cust_warranty_id)
      AND (Validate_SYS.Is_Changed(oldrec_.cust_warranty_id, newrec_.cust_warranty_id)) THEN
         Cust_Warranty_API.Exist(newrec_.cust_warranty_id);
      END IF;
      IF (newrec_.supply_chain_part_group IS NOT NULL)
      AND (indrec_.supply_chain_part_group)
      AND (Validate_SYS.Is_Changed(oldrec_.supply_chain_part_group, newrec_.supply_chain_part_group)) THEN
         Supply_Chain_Part_Group_API.Exist(newrec_.supply_chain_part_group);
      END IF;
      IF (newrec_.input_unit_meas_group_id IS NOT NULL)
      AND (indrec_.input_unit_meas_group_id)
      AND (Validate_SYS.Is_Changed(oldrec_.input_unit_meas_group_id, newrec_.input_unit_meas_group_id)) THEN
         Input_Unit_Meas_Group_API.Exist(newrec_.input_unit_meas_group_id);
      END IF;
      IF (Site_API.Get_Company(newrec_.contract) IS NOT NULL AND newrec_.statistical_code IS NOT NULL)
      AND (indrec_.contract OR indrec_.statistical_code)
      AND (Validate_SYS.Is_Changed(Site_API.Get_Company(oldrec_.contract), Site_API.Get_Company(newrec_.contract))
        OR Validate_SYS.Is_Changed(oldrec_.statistical_code, newrec_.statistical_code)) THEN
         Statistical_Code_API.Exist(Site_API.Get_Company(newrec_.contract), newrec_.statistical_code);
      END IF;
      IF (Site_API.Get_Company(newrec_.contract) IS NOT NULL AND newrec_.acquisition_origin IS NOT NULL)
      AND (indrec_.contract OR indrec_.acquisition_origin)
      AND (Validate_SYS.Is_Changed(Site_API.Get_Company(oldrec_.contract), Site_API.Get_Company(newrec_.contract))
        OR Validate_SYS.Is_Changed(oldrec_.acquisition_origin, newrec_.acquisition_origin)) THEN
         Acquisition_Origin_API.Exist(Site_API.Get_Company(newrec_.contract), newrec_.acquisition_origin);
      END IF;
      IF (Site_API.Get_Company(newrec_.contract) IS NOT NULL AND newrec_.acquisition_reason_id IS NOT NULL)
      AND (indrec_.contract OR indrec_.acquisition_reason_id)
      AND (Validate_SYS.Is_Changed(Site_API.Get_Company(oldrec_.contract), Site_API.Get_Company(newrec_.contract))
        OR Validate_SYS.Is_Changed(oldrec_.acquisition_reason_id, newrec_.acquisition_reason_id)) THEN
         Acquisition_Reason_API.Exist(Site_API.Get_Company(newrec_.contract), newrec_.acquisition_reason_id);
      END IF;
      Error_SYS.Check_Not_Null(lu_name_, 'CONTRACT', newrec_.contract);
      Error_SYS.Check_Not_Null(lu_name_, 'PART_NO', newrec_.part_no);
      Error_SYS.Check_Not_Null(lu_name_, 'ASSET_CLASS', newrec_.asset_class);
      Error_SYS.Check_Not_Null(lu_name_, 'PART_STATUS', newrec_.part_status);
      Error_SYS.Check_Not_Null(lu_name_, 'PLANNER_BUYER', newrec_.planner_buyer);
      Error_SYS.Check_Not_Null(lu_name_, 'UNIT_MEAS', newrec_.unit_meas);
      Error_SYS.Check_Not_Null(lu_name_, 'DESCRIPTION', newrec_.description);
      Error_SYS.Check_Not_Null(lu_name_, 'COUNT_VARIANCE', newrec_.count_variance);
      Error_SYS.Check_Not_Null(lu_name_, 'CYCLE_CODE', newrec_.cycle_code);
      Error_SYS.Check_Not_Null(lu_name_, 'CYCLE_PERIOD', newrec_.cycle_period);
      Error_SYS.Check_Not_Null(lu_name_, 'EXPECTED_LEADTIME', newrec_.expected_leadtime);
      Error_SYS.Check_Not_Null(lu_name_, 'LEAD_TIME_CODE', newrec_.lead_time_code);
      Error_SYS.Check_Not_Null(lu_name_, 'MANUF_LEADTIME', newrec_.manuf_leadtime);
      Error_SYS.Check_Not_Null(lu_name_, 'OE_ALLOC_ASSIGN_FLAG', newrec_.oe_alloc_assign_flag);
      Error_SYS.Check_Not_Null(lu_name_, 'ONHAND_ANALYSIS_FLAG', newrec_.onhand_analysis_flag);
      Error_SYS.Check_Not_Null(lu_name_, 'PURCH_LEADTIME', newrec_.purch_leadtime);
      Error_SYS.Check_Not_Null(lu_name_, 'SUPPLY_CODE', newrec_.supply_code);
      Error_SYS.Check_Not_Null(lu_name_, 'TYPE_CODE', newrec_.type_code);
      Error_SYS.Check_Not_Null(lu_name_, 'ZERO_COST_FLAG', newrec_.zero_cost_flag);
      Error_SYS.Check_Not_Null(lu_name_, 'AVAIL_ACTIVITY_STATUS', newrec_.avail_activity_status);
      Error_SYS.Check_Not_Null(lu_name_, 'SHORTAGE_FLAG', newrec_.shortage_flag);
      Error_SYS.Check_Not_Null(lu_name_, 'FORECAST_CONSUMPTION_FLAG', newrec_.forecast_consumption_flag);
      Error_SYS.Check_Not_Null(lu_name_, 'STOCK_MANAGEMENT', newrec_.stock_management);
      Error_SYS.Check_Not_Null(lu_name_, 'DOP_CONNECTION', newrec_.dop_connection);
      Error_SYS.Check_Not_Null(lu_name_, 'INVENTORY_VALUATION_METHOD', newrec_.inventory_valuation_method);
      Error_SYS.Check_Not_Null(lu_name_, 'NEGATIVE_ON_HAND', newrec_.negative_on_hand);
      Error_SYS.Check_Not_Null(lu_name_, 'INVOICE_CONSIDERATION', newrec_.invoice_consideration);
      Error_SYS.Check_Not_Null(lu_name_, 'INVENTORY_PART_COST_LEVEL', newrec_.inventory_part_cost_level);
      Error_SYS.Check_Not_Null(lu_name_, 'EXT_SERVICE_COST_METHOD', newrec_.ext_service_cost_method);
      Error_SYS.Check_Not_Null(lu_name_, 'AUTOMATIC_CAPABILITY_CHECK', newrec_.automatic_capability_check);
      Error_SYS.Check_Not_Null(lu_name_, 'DOP_NETTING', newrec_.dop_netting);
      Error_SYS.Check_Not_Null(lu_name_, 'CO_RESERVE_ONH_ANALYS_FLAG', newrec_.co_reserve_onh_analys_flag);
      Error_SYS.Check_Not_Null(lu_name_, 'QTY_CALC_ROUNDING', newrec_.qty_calc_rounding);
      Error_SYS.Check_Not_Null(lu_name_, 'MIN_DURAB_DAYS_CO_DELIV', newrec_.min_durab_days_co_deliv);
      Error_SYS.Check_Not_Null(lu_name_, 'MIN_DURAB_DAYS_PLANNING', newrec_.min_durab_days_planning);
      Error_SYS.Check_Not_Null(lu_name_, 'RESET_CONFIG_STD_COST', newrec_.reset_config_std_cost);
      Error_SYS.Check_Not_Null(lu_name_, 'MANDATORY_EXPIRATION_DATE', newrec_.mandatory_expiration_date);
      Error_SYS.Check_Not_Null(lu_name_, 'EXCL_SHIP_PACK_PROPOSAL', newrec_.excl_ship_pack_proposal);
   END Base;

   PROCEDURE Core (
      oldrec_ IN     inventory_part_tab%ROWTYPE,
      newrec_ IN OUT NOCOPY inventory_part_tab%ROWTYPE,
      indrec_ IN OUT NOCOPY Indicator_Rec,
      attr_   IN OUT NOCOPY VARCHAR2 )
   IS
   BEGIN
      Base(oldrec_, newrec_, indrec_, attr_);
      IF ((newrec_.decline_issue_counter IS NOT NULL) AND 
          (newrec_.decline_issue_counter != ROUND(newrec_.decline_issue_counter)) AND 
          (newrec_.decline_issue_counter <= 0)) THEN
         Error_SYS.Record_General(lu_name_,'DECISSUECOUNT: Number of issues for decline must be a positive integer.');
      END IF;
      IF ((newrec_.expired_issue_counter IS NOT NULL) AND 
          (newrec_.expired_issue_counter != ROUND(newrec_.expired_issue_counter)) AND 
          (newrec_.expired_issue_counter <= 0)) THEN
         Error_SYS.Record_General(lu_name_,'EXPISSUECOUNT: Number of issues for expired must be a positive integer.');
      END IF;
   END Core;

BEGIN
   Core(oldrec_, newrec_, indrec_, attr_);
END Check_Common___;


PROCEDURE Prepare_Insert___ (
   attr_ IN OUT NOCOPY VARCHAR2 )
IS
   
   PROCEDURE Base (
      attr_ IN OUT NOCOPY VARCHAR2 )
   IS
   BEGIN
      Client_SYS.Clear_Attr(attr_);
   END Base;

   PROCEDURE Core (
      attr_ IN OUT NOCOPY VARCHAR2 )
   IS
      asset_class_ VARCHAR2(240);
      contract_    INVENTORY_PART.contract%TYPE;
   
   BEGIN
      contract_ := USER_ALLOWED_SITE_API.Get_Default_Site;
      Base(attr_);
      Client_SYS.Add_To_Attr('PART_STATUS', Inventory_Part_Status_Par_API.Get_Default_Status, attr_);
      Client_SYS.Add_To_Attr('CONTRACT',contract_,attr_);
   
      asset_class_ := Mpccom_Defaults_API.Get_Char_Value('*','PART_DESCRIPTION','ASSET_CLASS');
      Client_SYS.Add_To_Attr('ASSET_CLASS', asset_class_, attr_);
      Client_SYS.Add_To_Attr('STOCK_MANAGEMENT_DB', 'SYSTEM MANAGED INVENTORY', attr_);
      Client_SYS.Add_To_Attr('DOP_CONNECTION', Dop_Connection_API.Decode('AUT'), attr_);
      Client_SYS.Add_To_Attr('DOP_NETTING', Dop_Netting_API.Decode('NONET'), attr_);
      Client_SYS.Add_To_Attr('PLANNER_BUYER', User_Default_API.Get_Planner_Id(Fnd_Session_API.Get_Fnd_User), attr_);
      Client_SYS.Add_To_Attr('MANDATORY_EXPIRATION_DATE_DB', Fnd_Boolean_API.DB_FALSE, attr_);
      Client_SYS.Add_To_Attr('EXCL_SHIP_PACK_PROPOSAL_DB', Fnd_Boolean_API.DB_FALSE, attr_);
      ----------------------------------------
      -- Set default values for maintenance
      ----------------------------------------
      Client_SYS.Add_To_Attr('CYCLE_PERIOD', 0, attr_);
      Client_SYS.Add_To_Attr('CYCLE_CODE_DB', 'N', attr_);
   
      Client_SYS.Add_To_Attr('MANUF_LEADTIME', 0, attr_);
      Client_SYS.Add_To_Attr('PURCH_LEADTIME', 0, attr_);
      Client_SYS.Add_To_Attr('EXPECTED_LEADTIME', 0, attr_);
      Client_SYS.Add_To_Attr('SUPPLY_CODE', Material_Requis_Supply_API.Decode('IO'),attr_);
      Client_SYS.Add_To_Attr('TYPE_CODE', Inventory_Part_Type_API.Decode('4'), attr_);
      Client_SYS.Add_To_Attr('ZERO_COST_FLAG', Inventory_Part_Zero_Cost_API.Decode('N'),attr_);
      Client_SYS.Add_To_Attr('LEAD_TIME_CODE', Inv_Part_Lead_Time_Code_API.Decode('P'), attr_);
      Client_SYS.Add_To_Attr('AVAIL_ACTIVITY_STATUS', Inventory_Part_Avail_Stat_API.Decode('CHANGED'),attr_);
      ----------------------------------------
      -- Set default values for costing
      ----------------------------------------
      Client_SYS.Add_To_Attr('ESTIMATED_MATERIAL_COST', 0, attr_);
   
      Client_SYS.Add_To_Attr('MIN_DURAB_DAYS_CO_DELIV', 0, attr_);
      Client_SYS.Add_To_Attr('MIN_DURAB_DAYS_PLANNING', 0, attr_);
   END Core;

BEGIN
   Core(attr_);
END Prepare_Insert___;


PROCEDURE Check_Insert___ (
   newrec_ IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   indrec_ IN OUT NOCOPY Indicator_Rec,
   attr_   IN OUT NOCOPY VARCHAR2 )
IS
   
   PROCEDURE Base (
      newrec_ IN OUT NOCOPY inventory_part_tab%ROWTYPE,
      indrec_ IN OUT NOCOPY Indicator_Rec,
      attr_   IN OUT NOCOPY VARCHAR2 )
   IS
      oldrec_ inventory_part_tab%ROWTYPE;
   BEGIN
      Validate_SYS.Item_Insert(lu_name_, 'COUNT_VARIANCE', indrec_.count_variance);
      Validate_SYS.Item_Insert(lu_name_, 'CREATE_DATE', indrec_.create_date);
      Validate_SYS.Item_Insert(lu_name_, 'LAST_ACTIVITY_DATE', indrec_.last_activity_date);
      Validate_SYS.Item_Insert(lu_name_, 'EARLIEST_ULTD_SUPPLY_DATE', indrec_.earliest_ultd_supply_date);
      Validate_SYS.Item_Insert(lu_name_, 'FIRST_STAT_ISSUE_DATE', indrec_.first_stat_issue_date);
      Validate_SYS.Item_Insert(lu_name_, 'LATEST_STAT_ISSUE_DATE', indrec_.latest_stat_issue_date);
      Validate_SYS.Item_Insert(lu_name_, 'DECLINE_DATE', indrec_.decline_date);
      Validate_SYS.Item_Insert(lu_name_, 'EXPIRED_DATE', indrec_.expired_date);
      Validate_SYS.Item_Insert(lu_name_, 'DECLINE_ISSUE_COUNTER', indrec_.decline_issue_counter);
      Validate_SYS.Item_Insert(lu_name_, 'EXPIRED_ISSUE_COUNTER', indrec_.expired_issue_counter);
      Check_Common___(oldrec_, newrec_, indrec_, attr_);
   END Base;

   PROCEDURE Core (
      newrec_ IN OUT NOCOPY inventory_part_tab%ROWTYPE,
      indrec_ IN OUT NOCOPY Indicator_Rec,
      attr_   IN OUT NOCOPY VARCHAR2 )
   IS
      name_                         VARCHAR2(30);
      value_                        VARCHAR2(4000);
      unit_type_                    VARCHAR2(200);   
      part_catalog_rec_             Part_Catalog_API.Public_Rec;
      site_rec_                     Site_API.Public_Rec;
      country_code_                 VARCHAR2(3);
      noninv_sales_part_exist_      NUMBER;
      input_group_uom_              INPUT_UNIT_MEAS_GROUP_TAB.unit_code%TYPE;
      new_estimated_material_cost_  NUMBER;
      purchase_part_exist_          NUMBER;
      external_resource_db_         VARCHAR2(5);
      asset_class_rec_              Asset_Class_API.Public_Rec;
      site_invent_info_rec_ Site_Invent_info_API.Public_Rec; 
   BEGIN
      IF (newrec_.asset_class IS NULL) THEN
         newrec_.asset_class := Mpccom_Defaults_API.Get_Char_Value('*','PART_DESCRIPTION','ASSET_CLASS');
         newrec_.automatic_capability_check := 'NO AUTOMATIC CAPABILITY CHECK';
      END IF;
      
      IF (newrec_.part_status IS NULL) THEN
         newrec_.part_status := Inventory_Part_Status_Par_API.Get_Default_Status();  
      END IF;   
      
      asset_class_rec_      := Asset_Class_API.Get(newrec_.asset_class);
      part_catalog_rec_     := Part_Catalog_API.Get(newrec_.part_no);
      site_invent_info_rec_ := Site_Invent_Info_API.Get(newrec_.contract);
      
      IF (NOT indrec_.shortage_flag) THEN 
         newrec_.shortage_flag              := asset_class_rec_.shortage_flag;
      END IF;
      IF (NOT indrec_.onhand_analysis_flag) THEN 
         newrec_.onhand_analysis_flag       := asset_class_rec_.onhand_analysis_flag;
      END IF;
      IF (NOT indrec_.co_reserve_onh_analys_flag) THEN 
         newrec_.co_reserve_onh_analys_flag := asset_class_rec_.co_reserve_onh_analys_flag;
      END IF;
      IF (NOT indrec_.oe_alloc_assign_flag) THEN
         newrec_.oe_alloc_assign_flag       := asset_class_rec_.oe_alloc_assign_flag;
      END IF;
      IF (NOT indrec_.forecast_consumption_flag) THEN
         newrec_.forecast_consumption_flag  := asset_class_rec_.forecast_consumption_flag;
      END IF;
      IF (NOT indrec_.automatic_capability_check) THEN
         newrec_.automatic_capability_check := asset_class_rec_.automatic_capability_check;
      END IF;
      IF (NOT indrec_.stock_management) THEN
         newrec_.stock_management  := 'SYSTEM MANAGED INVENTORY';
      END IF;
      IF (NOT indrec_.dop_connection) THEN
         newrec_.dop_connection    := 'MAN';
      END IF;
      IF (NOT indrec_.count_variance) THEN
         newrec_.count_variance    := 0;
      END IF;
      IF (NOT indrec_.cycle_code) THEN
         newrec_.cycle_code    := 'N';
      END IF;
      IF (NOT indrec_.cycle_period) THEN
         newrec_.cycle_period  := 0;
      END IF;
      IF (NOT indrec_.manuf_leadtime) THEN
         newrec_.manuf_leadtime := 0;
      END IF;
      IF (NOT indrec_.purch_leadtime) THEN
          newrec_.purch_leadtime := 0;
      END IF;
      IF (NOT indrec_.expected_leadtime) THEN
          newrec_.expected_leadtime := 0;
      END IF;
      IF (NOT indrec_.supply_code) THEN
          newrec_.supply_code := 'IO';
      END IF;
      IF (NOT indrec_.zero_cost_flag) THEN
          newrec_.zero_cost_flag := 'N';
      END IF;
      IF (NOT indrec_.lead_time_code) THEN
          newrec_.lead_time_code := 'P';
      END IF;
      IF (NOT indrec_.avail_activity_status) THEN
          newrec_.avail_activity_status := 'CHANGED';
      END IF;
      IF (NOT indrec_.invoice_consideration) THEN
          newrec_.invoice_consideration := site_invent_info_rec_.invoice_consideration;
      END IF;
      IF (NOT indrec_.inventory_part_cost_level) THEN
          newrec_.inventory_part_cost_level  := 'COST PER PART';
      END IF;
      IF (NOT indrec_.ext_service_cost_method) THEN
         newrec_.ext_service_cost_method := site_invent_info_rec_.ext_service_cost_method;
      END IF;
      IF (NOT indrec_.planner_buyer) THEN
         newrec_.planner_buyer := User_Default_API.Get_Planner_Id(Fnd_Session_API.Get_Fnd_User);
      END IF;
      IF (NOT indrec_.min_durab_days_co_deliv) THEN
         newrec_.min_durab_days_co_deliv := 0;
      END IF;
      IF (NOT indrec_.min_durab_days_planning) THEN
         newrec_.min_durab_days_planning := 0;
      END IF;
      IF (NOT indrec_.qty_calc_rounding) THEN
         newrec_.qty_calc_rounding := Site_Invent_Info_API.Get_Default_Qty_Calc_Round(newrec_.contract);
      END IF;
      
      IF (newrec_.type_code IS NULL)  THEN
         newrec_.type_code := '4';
      END IF; 
      
      IF (newrec_.reset_config_std_cost IS NULL) THEN
         newrec_.reset_config_std_cost := site_invent_info_rec_.reset_config_std_cost;
      END IF;
      
      IF (NOT indrec_.inventory_valuation_method) THEN   
         IF (newrec_.type_code IN ('1','2'))  THEN
            newrec_.inventory_valuation_method := site_invent_info_rec_.manuf_inv_value_method;
         ELSE
            newrec_.inventory_valuation_method := site_invent_info_rec_.purch_inv_value_method;
         END IF;
      END IF;
      
      IF (part_catalog_rec_.configurable = 'CONFIGURED') THEN
         IF (NOT indrec_.inventory_part_cost_level) THEN
            newrec_.inventory_part_cost_level := 'COST PER CONFIGURATION';
         END IF;
         IF (newrec_.inventory_valuation_method IN ('FIFO','LIFO')) THEN
            -- Inventory valuation methods FIFO and LIFO is not allowed for configured
            -- parts. Inventory valuation method will be set to Standard Cost instead.
            IF (NOT indrec_.inventory_valuation_method) THEN
               newrec_.inventory_valuation_method := 'ST';
            END IF;
         END IF;
      END IF;
   
      --When creating an Inventory Part for an existing catch unit handled part in Part Catalog or if the part is a tracked part
      --negative_on_hand should be NEG ONHAND NOT OK.
      IF (NOT indrec_.negative_on_hand) THEN 
         IF ((part_catalog_rec_.catch_unit_enabled          = Fnd_Boolean_API.db_true) OR 
             (part_catalog_rec_.receipt_issue_serial_track  = Fnd_Boolean_API.db_true) OR 
             (part_catalog_rec_.lot_tracking_code          != 'NOT LOT TRACKING')) THEN
            newrec_.negative_on_hand := 'NEG ONHAND NOT OK';
         ELSE
            newrec_.negative_on_hand := site_invent_info_rec_.negative_on_hand;
         END IF;
      END IF;
      
      IF ((newrec_.invoice_consideration = 'TRANSACTION BASED') AND (newrec_.inventory_valuation_method = 'ST')) THEN
         IF (part_catalog_rec_.serial_tracking_code = Part_Serial_Tracking_API.db_serial_tracking) THEN
            IF (NOT indrec_.inventory_part_cost_level) THEN 
               newrec_.inventory_part_cost_level  := 'COST PER SERIAL';
            END IF;
         ELSE
            IF (NOT indrec_.invoice_consideration) THEN 
               newrec_.invoice_consideration := 'IGNORE INVOICE PRICE';
            END IF;
         END IF;
      END IF;
      
      IF (newrec_.inventory_valuation_method IN ('FIFO', 'LIFO', 'AV')) THEN
         newrec_.negative_on_hand := 'NEG ONHAND NOT OK';
      END IF;
      
      unit_type_            := Iso_Unit_Type_API.Encode(Iso_Unit_API.Get_Unit_Type(newrec_.unit_meas));
      site_rec_             := Site_API.Get(newrec_.contract);
      new_estimated_material_cost_ := 0;
      
      IF Client_SYS.Item_Exist('ESTIMATED_MATERIAL_COST', attr_) THEN 
         new_estimated_material_cost_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('ESTIMATED_MATERIAL_COST', attr_));
         attr_ := Client_Sys.Remove_Attr('ESTIMATED_MATERIAL_COST', attr_);
      END IF;  
         
      IF (part_catalog_rec_.configurable = 'CONFIGURED') THEN
         -- Shortage notification is not allowed for configured parts.
         newrec_.shortage_flag := 'N';
      END IF;
   
      IF (newrec_.dop_netting IS NULL) THEN
         newrec_.dop_netting := 'NETT';
      END IF;
      
      IF (instr(newrec_.part_no, '%') > 0) THEN
         Error_SYS.Item_General(lu_name_, 'PART_NO', 'NOPERCENTSIGN: The field [:NAME] cannot contain % sign.');
      END IF;
      
      IF (newrec_.mandatory_expiration_date IS NULL) THEN 
         newrec_.mandatory_expiration_date := Fnd_Boolean_API.DB_FALSE;
      END IF;
      
      IF (newrec_.excl_ship_pack_proposal IS NULL) THEN 
         newrec_.excl_ship_pack_proposal := Fnd_Boolean_API.DB_FALSE;
      END IF;
      
      Base(newrec_, indrec_, attr_);
      
      IF Client_SYS.Item_Exist('DESCRIPTION_COPY', attr_) THEN  
         newrec_.description := Client_SYS.Get_Item_Value('DESCRIPTION_COPY', attr_);
      END IF;
      
      Error_SYS.Check_Not_Null(lu_name_, 'ESTIMATED_MATERIAL_COST', new_estimated_material_cost_);
      
      Check_Min_Durab_Days_Co_Del___(newrec_.durability_day, newrec_.min_durab_days_co_deliv);
      Check_Min_Durab_Days_Plan___(newrec_.durability_day, newrec_.min_durab_days_planning);
      
      IF (newrec_.supersedes IS NOT NULL) THEN
         Exist(newrec_.contract, newrec_.supersedes);
      END IF;
      -- always override default or user entered qty_calc_rounding for serial tracking and discrete parts with zero
      IF ((part_catalog_rec_.receipt_issue_serial_track = Fnd_Boolean_API.db_true) OR (unit_type_ = 'DISCRETE')) THEN
         newrec_.qty_calc_rounding := 0;
      END IF;
   
      Check_Qty_Calc_Rounding___(newrec_.qty_calc_rounding, part_catalog_rec_.receipt_issue_serial_track, newrec_.unit_meas);
   
   
      -- IF Catch Unit is enabled or whether the part is tracked or if the part is lot tracked, 
      -- negative_on_hand should be NEG ONHAND NOT OK
      Check_Negative_On_Hand(newrec_.negative_on_hand, 
                             part_catalog_rec_.catch_unit_enabled, 
                             part_catalog_rec_.receipt_issue_serial_track, 
                             part_catalog_rec_.lot_tracking_code);
   
      IF (newrec_.shortage_flag = 'Y') THEN
         IF (Mpccom_System_Parameter_API.Get_Parameter_Value1('SHORTAGE_HANDLING') = 'N') THEN
            Error_SYS.Record_General(lu_name_, 'NOSHORTAGEHANDLE: Cannot have shortages at part level if System flag is set to No.');
         END IF;
         IF (part_catalog_rec_.configurable = 'CONFIGURED') THEN
         -- shortage handling is not allowed for configured parts.
            Error_SYS.Record_General(lu_name_, 'NOSHORTCONFIG: Shortage handling is not allowed for configured parts.');
         END IF;
      END IF;
   
      IF newrec_.forecast_consumption_flag = 'FORECAST' THEN
         IF newrec_.onhand_analysis_flag = 'Y' THEN      
            Error_SYS.Record_General(lu_name_,'ERRORFORECASTCONSUMP: :P1 is not allowed when Availability Check is selected.',
            Inv_Part_Forecast_Consum_API.Decode(newrec_.forecast_consumption_flag));
         END IF;
         Client_SYS.Add_Info(lu_name_, 'ONLINECONSUMNOTALLOW: IF online consumption is allowed, it is not possible to set it back to not allowed when customer orders are in a state other than Delivered, Invoiced/Closed and/or sales quotation lines are in Released, Revised or Rejected status.'); 
      END IF;
   
      IF (newrec_.max_actual_cost_update IS NOT NULL) THEN
         IF (newrec_.max_actual_cost_update<0 or newrec_.max_actual_cost_update>1) THEN
            Error_SYS.Record_General(lu_name_, 'ERRORMAXACTCOST: Max Periodic Weighted Average Update can not be less than 0% or higher than 100%.');
         END IF;
      END IF;
   
      Validate_Lead_Time_Code___(newrec_.lead_time_code,
                                 newrec_.contract,
                                 newrec_.part_no,
                                 newrec_.type_code,
                                 NULL );
   
      IF(newrec_.type_code IN(1, 2)) THEN
         newrec_.purch_leadtime := 0;
         newrec_.expected_leadtime := newrec_.manuf_leadtime;
      ELSIF(newrec_.type_code IN(3, 4, 6)) THEN
         newrec_.manuf_leadtime := 0;
         newrec_.expected_leadtime := newrec_.purch_leadtime;
      END IF;
   
      Check_Unit_Meas___(newrec_.contract,
                         newrec_.part_no,
                         newrec_.unit_meas,
                         newrec_.catch_unit_meas,
                         part_catalog_rec_.receipt_issue_serial_track,
                         part_catalog_rec_.catch_unit_enabled);
   
      User_Allowed_Site_API.Exist(Fnd_Session_API.Get_Fnd_User,newrec_.contract);
   
      Check_Lead_Time___(newrec_.purch_leadtime);
      Check_Lead_Time___(newrec_.manuf_leadtime);
      Check_Lead_Time___(newrec_.expected_leadtime);
   
      IF (newrec_.type_code = '2') THEN
         IF unit_type_ NOT IN ('WEIGHT', 'VOLUME') THEN
            Error_SYS.Record_General(lu_name_, 'RECIPUNITTYPE: Unit of measure for part type :P1 must be of unit type :P2 or :P3.',
                                     Inventory_Part_Type_API.Decode(newrec_.type_code),
                                     Iso_Unit_Type_API.Decode('WEIGHT'),
                                     Iso_Unit_Type_API.Decode('VOLUME'));
         END IF;
   -- CTO Type code 2 is not allowed for configured parts
         IF (part_catalog_rec_.configurable = 'CONFIGURED') THEN
            Error_SYS.Record_General(lu_name_, 'NOCONFIGRECIPE: Type code must not be :P1 for a configured part.',
                                     Inventory_Part_Type_API.Decode(newrec_.type_code) );
         END IF;
   -- CTO End
      END IF;
   
      IF (newrec_.lead_time_code = 'M' AND newrec_.supply_code = 'P') THEN
         Error_SYS.Record_General(lu_name_,'NOTVALIDSUPPLYCODE: Supply code must not be :P1 for a manufactured part', Material_Requis_Supply_API.Decode(newrec_.supply_code));
      END IF;
   
      -- IF customs statistics number's unit measure has a value, check if intrastat conv factor and net weight have been entered too
      Check_Intrastat_And_Customs___(newrec_.customs_stat_no, newrec_.intrastat_conv_factor);
   
      IF (newrec_.part_cost_group_id IS NOT NULL) THEN
         $IF (Component_Cost_SYS.INSTALLED) $THEN
            Part_Cost_Group_API.Exist(newrec_.contract, newrec_.part_cost_group_id);
         $ELSE
            NULL;
         $END
      END IF;
      IF (newrec_.cycle_period < 0) THEN
         Error_SYS.Record_General(lu_name_, 'CYCLEPERIOD: The value for Cycle Period may not be negative.');
      END IF;
      --
   
      Check_Value_Method_Combinat___(newrec_,
                                     part_catalog_rec_.configurable,
                                     part_catalog_rec_.condition_code_usage,
                                     part_catalog_rec_.lot_tracking_code,
                                     part_catalog_rec_.serial_tracking_code,
                                     part_catalog_rec_.receipt_issue_serial_track);
   
      --Give an alert if the part is FIFO /LIFO and CC enabled
      IF (newrec_.inventory_valuation_method IN ('FIFO','LIFO')) THEN
   
         IF (part_catalog_rec_.condition_code_usage = 'ALLOW_COND_CODE') THEN
            Client_SYS.Add_Info(lu_name_,'FIFOLIFOANDCC: This part is set up using condition codes. The FIFO / LIFO valuation method will however not consider the condition code of the inventory transactions.');
         END IF;
      END IF;
   
      IF (newrec_.region_of_origin IS NOT NULL) THEN
         -- fetch country from delivery address and check it
         country_code_ := ISO_Country_API.Encode(Company_Address_API.Get_Country(site_rec_.company,
                                                                                 site_rec_.delivery_address));
         IF (country_code_ IS NULL) THEN
            Error_SYS.Record_General(lu_name_,'NORECEIVCOUNTRY: Site delivery address :P1 must have a country code.', site_rec_.delivery_address );
         ELSE
            Country_Region_API.Exist(country_code_, newrec_.region_of_origin);
         END IF;
      END IF;
   
      IF newrec_.type_code != '1' THEN
         IF part_catalog_rec_.position_part = 'POSITION PART' THEN
            Raise_Position_Part_Type_Error___;
         END IF;
      END IF;
   
      --Check whether the Inventory UM is equal to unit code of Input UoM Group and
      -- unit code of patca if part is inherited from partca.
      IF (newrec_.input_unit_meas_group_id IS NOT NULL) THEN
         input_group_uom_ := Input_Unit_Meas_Group_API.Get_Unit_Code(newrec_.input_unit_meas_group_id);
         IF (input_group_uom_ != newrec_.unit_meas) THEN
            Raise_Input_Uom_Error___;
         END IF;
      END IF;
   
      noninv_sales_part_exist_ := 0;
      $IF (Component_Order_SYS.INSTALLED) $THEN
         DECLARE
            temp_ VARCHAR2(4);
         BEGIN
            temp_ := Sales_Part_API.Get_Catalog_Type_Db(newrec_.contract, newrec_.part_no);
            IF (temp_ IS NOT NULL)THEN
               IF (temp_ = 'NON')THEN
                  noninv_sales_part_exist_ := 1 ;
               END IF;
            END IF;
         END;  
   
         IF (noninv_sales_part_exist_ = 1)THEN
            Error_SYS.Record_General(lu_name_, 'NONINVSALESPARTEXIST: Part number :P1 already exists on Site :P2 as a Non inventory sales part.',newrec_.part_no, newrec_.contract);
         END IF;
      $END
   
      -- XPR, not allowed to create inventory parts if part is already created with the external resource flag in purchase part.
      $IF (Component_Purch_SYS.INSTALLED) $THEN 
         purchase_part_exist_ := Purchase_Part_API.Check_Exist(newrec_.contract, newrec_.part_no);
         IF (purchase_part_exist_ = 1) THEN
            external_resource_db_ := Purchase_Part_API.Get_External_Resource_Db(newrec_.contract, newrec_.part_no);
            IF (external_resource_db_ = 'TRUE') THEN
               Error_SYS.Record_General(lu_name_, 'EXTRESEXIST: You cannot define :P1 as an inventory part as it already exists as a contractor purchase part on site :P2.', newrec_.part_no, newrec_.contract);
            END IF;
         END IF;     
      $END    
   
      Check_Invoice_Consideration___(newrec_.contract,
                                     site_rec_.company,
                                     newrec_.invoice_consideration);
   
      Check_Auto_Capability_Check___(newrec_);
      IF (newrec_.automatic_capability_check IN ('RESERVE AND ALLOCATE','ALLOCATE ONLY','NEITHER RESERVE NOR ALLOCATE')) THEN
         -- warn the user that an automatic order capability check could take time
         Client_SYS.Add_Info(lu_name_, 'AOCCWARNING: The current set up will start the Capability Check automatically when a customer order line is entered or updated. Please, be aware of that such a check can take time.');
      END IF;
      
      $IF (Component_Shpord_SYS.INSTALLED) $THEN
         Shop_Order_Operation_List_API.Check_Create_Inventory_Part(newrec_.contract, newrec_.part_no);
      $END 
      
      IF (newrec_.type_code = 6) THEN
         Check_Expense_Part_Allowed___(part_catalog_rec_.allow_as_not_consumed);
      END IF;     
   
      -- Check Storage Capacities and Conditions Requirement
      Part_Catalog_Invent_Attrib_API.Check_Cubic_Capacity(newrec_.storage_width_requirement);
      Part_Catalog_Invent_Attrib_API.Check_Cubic_Capacity(newrec_.storage_height_requirement);
      Part_Catalog_Invent_Attrib_API.Check_Cubic_Capacity(newrec_.storage_depth_requirement);
      Part_Catalog_Invent_Attrib_API.Check_Carrying_Capacity(newrec_.storage_weight_requirement);
      Part_Catalog_Invent_Attrib_API.Check_Humidity(newrec_.min_storage_humidity);
      Part_Catalog_Invent_Attrib_API.Check_Humidity(newrec_.max_storage_humidity);
   
      Check_Standard_Putaway_Qty___(newrec_.standard_putaway_qty);
      Check_Supersedes___(newrec_.contract, newrec_.part_no, newrec_.supersedes, newrec_.part_status);
      
      Client_Sys.Add_To_Attr('ESTIMATED_MATERIAL_COST', new_estimated_material_cost_, attr_ );
   EXCEPTION
      WHEN value_error THEN
         Error_SYS.Item_Format(lu_name_, name_, value_);
   END Core;

BEGIN
   Core(newrec_, indrec_, attr_);
END Check_Insert___;


PROCEDURE Insert___ (
   objid_                OUT    VARCHAR2,
   objversion_           OUT    VARCHAR2,
   newrec_               IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   attr_                 IN OUT NOCOPY VARCHAR2,
   create_purchase_part_ IN     VARCHAR2 DEFAULT 'TRUE',
   create_part_planning_ IN     VARCHAR2 DEFAULT 'TRUE')
IS
   
   PROCEDURE Base (
      objid_                OUT    VARCHAR2,
      objversion_           OUT    VARCHAR2,
      newrec_               IN OUT NOCOPY inventory_part_tab%ROWTYPE,
      attr_                 IN OUT NOCOPY VARCHAR2,
      create_purchase_part_ IN     VARCHAR2 DEFAULT 'TRUE',
      create_part_planning_ IN     VARCHAR2 DEFAULT 'TRUE')
   IS
      value_too_large  EXCEPTION;
      PRAGMA           EXCEPTION_INIT(value_too_large, -12899);
   BEGIN
      newrec_.rowversion := sysdate;
      newrec_.rowkey := sys_guid();
      Client_SYS.Add_To_Attr('OBJKEY', newrec_.rowkey, attr_);
      INSERT
         INTO inventory_part_tab
         VALUES newrec_
         RETURNING rowid INTO objid_;
      objversion_ := to_char(newrec_.rowversion,'YYYYMMDDHH24MISS');
   EXCEPTION
      WHEN dup_val_on_index THEN
         DECLARE
            constraint_ VARCHAR2(4000) := Utility_SYS.Get_Constraint_From_Error_Msg(sqlerrm);
         BEGIN
            IF (constraint_ = 'INVENTORY_PART_RK') THEN
               Error_SYS.Fnd_Rowkey_Exist(lu_name_, newrec_.rowkey);
            ELSIF (constraint_ = 'INVENTORY_PART_PK') THEN
               Raise_Record_Exist___(newrec_);
            ELSE
               Raise_Constraint_Violated___(newrec_, constraint_);
            END IF;
         END;
      WHEN value_too_large THEN
         Error_SYS.Fnd_Item_Length(lu_name_, sqlerrm);
   END Base;

   PROCEDURE Core (
      objid_                OUT    VARCHAR2,
      objversion_           OUT    VARCHAR2,
      newrec_               IN OUT NOCOPY inventory_part_tab%ROWTYPE,
      attr_                 IN OUT NOCOPY VARCHAR2,
      create_purchase_part_ IN     VARCHAR2 DEFAULT 'TRUE',
      create_part_planning_ IN     VARCHAR2 DEFAULT 'TRUE')
   IS
      inventory_flag_               VARCHAR2(20);
      site_date_                    DATE;   
      exist_                        NUMBER;
      new_estimated_material_cost_  NUMBER;
   BEGIN
   
      newrec_.note_id            := Document_Text_API.Get_Next_Note_Id;
      site_date_                 := Site_API.Get_Site_Date(newrec_.contract);
      newrec_.create_date        := trunc(site_date_);
      newrec_.last_activity_date := trunc(site_date_);
      IF (newrec_.abc_class IS NULL) THEN
         newrec_.abc_class          := 'C';
      END IF;
      IF (newrec_.lifecycle_stage IS NULL) THEN
         newrec_.lifecycle_stage    := 'DEVELOPMENT';
      END IF;
      IF (newrec_.frequency_class IS NULL) THEN
         newrec_.frequency_class    := Inv_Part_Frequency_Class_API.DB_VERY_SLOW_MOVER;
      END IF;
      IF (newrec_.invoice_consideration = 'PERIODIC WEIGHTED AVERAGE') THEN
         newrec_.actual_cost_activated := Inventory_Transaction_Hist_API.Get_Last_Transaction_For_Part(newrec_.contract, newrec_.part_no);
      END IF;
      $IF (Component_Purch_SYS.INSTALLED) $THEN
         IF (newrec_.technical_coordinator_id IS NULL) THEN
            IF (Purchase_Part_API.Check_Exist(newrec_.contract, newrec_.part_no) = 1) THEN
                newrec_.technical_coordinator_id := Purchase_Part_API.Get_Technical_Coordinator_ID(newrec_.contract, newrec_.part_no);
            END IF;    
         END IF;
      $END
      
      IF newrec_.lead_time_code = 'P' THEN
         $IF (Component_Purch_SYS.INSTALLED) $THEN 
            exist_ := Purchase_Part_API.Check_Exist(newrec_.contract, newrec_.part_no);
            IF (exist_ = 1) THEN
               newrec_.technical_coordinator_id := Purchase_Part_API.Get_Technical_Coordinator_ID(newrec_.contract, newrec_.part_no);          
           END IF;       
         $ELSE
            NULL;
         $END
      END IF;
   
      IF newrec_.storage_volume_requirement IS NOT NULL THEN
         newrec_.storage_width_requirement  := NVL(newrec_.storage_width_requirement, 0);
         newrec_.storage_height_requirement := NVL(newrec_.storage_height_requirement, 0);
         newrec_.storage_depth_requirement  := NVL(newrec_.storage_depth_requirement, 0);
      END IF;
      
      Base(objid_, objversion_, newrec_, attr_);
      
      -- Moved this code block right before calling Inventory_Part_Config_API.NEW()
      $IF (Component_Cost_SYS.INSTALLED) $THEN
          Cost_Set_API.Create_Part_Cost(newrec_.contract, newrec_.part_no, newrec_.lead_time_code);
      $END   
      
      new_estimated_material_cost_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('ESTIMATED_MATERIAL_COST', attr_));   
      Inventory_Part_Config_API.NEW(newrec_.contract,
                                    newrec_.part_no,
                                    '*',
                                    new_estimated_material_cost_);
                                    
      $IF (Component_Cfgchr_SYS.INSTALLED) $THEN
         FOR config_rec_ IN Configuration_Spec_API.Get_Valid_Configuration_Id(newrec_.part_no) LOOP
             IF NOT Inventory_Part_Config_API.Check_Exist(newrec_.contract, newrec_.part_no, config_rec_.configuration_id) THEN
                Inventory_Part_Config_API.NEW(newrec_.contract, newrec_.part_no, config_rec_.configuration_id,0);
             END IF;
         END LOOP;
      $END   
    
      IF (create_part_planning_ = 'TRUE') THEN
         Inventory_Part_Planning_API.Create_New_Part_Planning(newrec_.contract, newrec_.part_no);
   
      END IF;
      
      $IF (Component_Purch_SYS.INSTALLED) $THEN     
         exist_ := Purchase_Part_API.Check_Exist(newrec_.contract, newrec_.part_no);
         IF (exist_ = 1) THEN
            inventory_flag_ := Inventory_Flag_API.Decode('Y');
            Purchase_Part_API.Set_Inventory_Flag(newrec_.contract,  newrec_.part_no, inventory_flag_);      
         ELSE
            IF newrec_.lead_time_code = 'P' THEN
               IF (create_purchase_part_ = 'TRUE') THEN
                  Purchase_Part_API.New(newrec_.contract, newrec_.part_no, newrec_.description, newrec_.unit_meas);               
               END IF;
            END IF;
         END IF;     
      $END  
      
      $IF (Component_Mfgstd_SYS.INSTALLED) $THEN
         Part_Revision_API.Create_First_Part_Rev(newrec_.contract, newrec_.part_no);
      $END
      
      $IF (Component_Ecoman_SYS.INSTALLED) $THEN
         -- Create inv part emission head, should exist for all parts
         Inv_Part_Emission_Head_API.Create_If_Not_Exist(newrec_.contract, newrec_.part_no, '1', '*', '*');
      $END
      
      IF newrec_.part_cost_group_id IS NOT NULL THEN
         $IF (Component_Cost_SYS.INSTALLED) $THEN
            Part_Cost_API.Changed_Group_Id(newrec_.contract, newrec_.part_no, newrec_.part_cost_group_id);
         $ELSE
            NULL;
         $END
      END IF;
   
      IF newrec_.cust_warranty_id IS NOT NULL THEN
         Cust_Warranty_API.Inherit(newrec_.cust_warranty_id);
      END IF;
   
      IF newrec_.sup_warranty_id IS NOT NULL THEN
         Sup_Warranty_API.Inherit(newrec_.sup_warranty_id);
      END IF;
   
      -- Update Chemmate
      IF (Part_Catalog_Invent_Attrib_API.Get_Hse_Contract(newrec_.part_no) = newrec_.contract) THEN
         Pack_And_Post_Message__('ADDEDIT', newrec_.part_no, newrec_.contract);
      END IF;
   
      IF (newrec_.invoice_consideration = 'PERIODIC WEIGHTED AVERAGE') THEN
         IF (Site_Invent_Info_API.Get_Last_Actual_Cost_Calc(newrec_.contract) IS NULL) THEN
            Site_Invent_Info_API.Set_Last_Actual_Cost_Calc(newrec_.contract, site_date_);
         END IF;
      END IF;
      
      $IF (Component_Quaman_SYS.INSTALLED) $THEN
         Qman_Mandatory_Part_API.Insert_From_Invent(newrec_.part_no, newrec_.contract, newrec_.type_code);
      $END 
      
      -- These checks needs to be performed after storing the record
      -- because they are using the method for fetching the operative
      -- values which read the database.
      Check_Temperature_Range(newrec_.part_no, newrec_.contract);
      Check_Humidity_Range(newrec_.part_no, newrec_.contract);
       
   EXCEPTION
      WHEN dup_val_on_index THEN
         Error_SYS.Record_Exist(lu_name_, 'DUPLPART: Inventory part :P1 already exists on site :P2.',newrec_.part_no, newrec_.contract);
   END Core;

BEGIN
   Core(objid_, objversion_, newrec_, attr_, create_purchase_part_, create_part_planning_);
END Insert___;


PROCEDURE Check_Update___ (
   oldrec_            IN     inventory_part_tab%ROWTYPE,
   newrec_            IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   indrec_            IN OUT NOCOPY Indicator_Rec,
   attr_              IN OUT NOCOPY VARCHAR2,
   updated_by_client_ IN     BOOLEAN DEFAULT TRUE  )
IS
   
   PROCEDURE Base (
      oldrec_            IN     inventory_part_tab%ROWTYPE,
      newrec_            IN OUT NOCOPY inventory_part_tab%ROWTYPE,
      indrec_            IN OUT NOCOPY Indicator_Rec,
      attr_              IN OUT NOCOPY VARCHAR2,
      updated_by_client_ IN     BOOLEAN DEFAULT TRUE  )
   IS
   BEGIN
      Validate_SYS.Item_Update(lu_name_, 'CONTRACT', indrec_.contract);
      Validate_SYS.Item_Update(lu_name_, 'PART_NO', indrec_.part_no);
      Validate_SYS.Item_Update(lu_name_, 'NOTE_ID', indrec_.note_id);
      Validate_SYS.Item_Update(lu_name_, 'UNIT_MEAS', indrec_.unit_meas);
      Validate_SYS.Item_Update(lu_name_, 'CREATE_DATE', indrec_.create_date);
      Validate_SYS.Item_Update(lu_name_, 'LAST_ACTIVITY_DATE', indrec_.last_activity_date);
      Check_Common___(oldrec_, newrec_, indrec_, attr_);
   END Base;

   PROCEDURE Core (
      oldrec_            IN     inventory_part_tab%ROWTYPE,
      newrec_            IN OUT NOCOPY inventory_part_tab%ROWTYPE,
      indrec_            IN OUT NOCOPY Indicator_Rec,
      attr_              IN OUT NOCOPY VARCHAR2,
      updated_by_client_ IN     BOOLEAN DEFAULT TRUE  )
   IS
      name_                         VARCHAR2(30);
      value_                        VARCHAR2(4000);
      unit_type_                    VARCHAR2(200);  
      part_exist_                   NUMBER;
      order_requisition_            VARCHAR2(200);
      part_catalog_rec_             Part_Catalog_API.Public_Rec;
      site_rec_                     Site_API.Public_Rec;
      site_rec_fetched_             BOOLEAN := FALSE;
      country_code_                 VARCHAR2(3);  
      char_null_                    VARCHAR2(12) := 'VARCHAR2NULL';
      input_group_uom_              INPUT_UNIT_MEAS_GROUP_TAB.unit_code%TYPE;
      exist_invpart_                NUMBER;
      sched_capacity_               VARCHAR2(60);
      line_exist_                   NUMBER;
      part_catalog_fetched_         BOOLEAN := FALSE;
      part_catch_unit_meas_         VARCHAR2(30);
      number_null_                  NUMBER := -9999999;
      updated_control_type_         VARCHAR2(3);
      str_null_                     VARCHAR2(11) := Database_SYS.string_null_;
      new_estimated_material_cost_  NUMBER;
      asset_class_rec_              Asset_Class_API.Public_Rec;
   
      CURSOR get_catch_uom IS
        SELECT catch_unit_meas
        FROM   inventory_part_tab
        WHERE  part_no          = newrec_.part_no
        AND    contract        != newrec_.contract
        AND    catch_unit_meas != newrec_.catch_unit_meas;
   BEGIN
      
      IF (indrec_.asset_class AND newrec_.asset_class IS NOT NULL) THEN
         asset_class_rec_  := Asset_Class_API.Get(newrec_.asset_class);
         IF (NOT indrec_.shortage_flag) THEN 
            newrec_.shortage_flag  := asset_class_rec_.shortage_flag;
            Inventory_Part_Shortage_API.Exist_Db(newrec_.shortage_flag);
         END IF;
         IF (NOT indrec_.onhand_analysis_flag) THEN 
            newrec_.onhand_analysis_flag   := asset_class_rec_.onhand_analysis_flag;
            Inventory_Part_Onh_Analys_API.Exist_Db(newrec_.onhand_analysis_flag);
         END IF;
         IF (NOT indrec_.co_reserve_onh_analys_flag) THEN 
            newrec_.co_reserve_onh_analys_flag := asset_class_rec_.co_reserve_onh_analys_flag;
            Inventory_Part_Onh_Analys_API.Exist_Db(newrec_.co_reserve_onh_analys_flag);
         END IF;
         IF (NOT indrec_.oe_alloc_assign_flag) THEN 
            newrec_.oe_alloc_assign_flag       := asset_class_rec_.oe_alloc_assign_flag;
            Cust_Ord_Reservation_Type_API.Exist_Db(newrec_.oe_alloc_assign_flag);
         END IF;
         IF (NOT indrec_.forecast_consumption_flag) THEN 
            newrec_.forecast_consumption_flag  := asset_class_rec_.forecast_consumption_flag;
            Inv_Part_Forecast_Consum_API.Exist_Db(newrec_.forecast_consumption_flag);
         END IF;
         IF (NOT indrec_.automatic_capability_check) THEN 
            newrec_.automatic_capability_check := asset_class_rec_.automatic_capability_check;
            Capability_Check_Allocate_API.Exist_Db(newrec_.automatic_capability_check);
         END IF;
      END IF;
      
      new_estimated_material_cost_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('ESTIMATED_MATERIAL_COST', attr_));
      
      -- IF the global variable new_estimated_material_cost_ is NULL
      IF new_estimated_material_cost_ IS NULL THEN
         new_estimated_material_cost_ :=
            Inventory_Part_Config_API.Get_Estimated_Material_Cost(newrec_.contract, newrec_.part_no, '*');
      END IF;
   
     IF (newrec_.part_status != oldrec_.part_status) THEN
         IF (Inventory_Part_Status_Par_API.Get_Onhand_Flag_Db(newrec_.part_status) = 'N') THEN
            IF Invent_Part_Quantity_Util_API.Check_Part_Exist(newrec_.contract, newrec_.part_no) THEN
               Error_SYS.Record_General(lu_name_, 'HAS_QTY_ON_HAND: Invalid part status. This part has a quantity on hand, quantity in transit or quantity at customer not equal to 0.');
            END IF;
         END IF;
      END IF;
   
      IF (Inventory_Part_Status_Par_API.Get_Supply_Flag_Db(newrec_.part_status) = 'Y') AND 
         (Inventory_Part_API.Get_Superseded_By(newrec_.contract, newrec_.part_no) IS NOT NULL) THEN
         Error_SYS.Record_General(lu_name_, 'WRONGSTSSUPERSESEDBY: Supply status of part :P1 must be Supplies Not Allowed since it is a superseded part.', newrec_.part_no);      
      END IF;
   
      Validate_Lead_Time_Code___(newrec_.lead_time_code,
                                 newrec_.contract,
                                 newrec_.part_no,
                                 newrec_.type_code,
                                 oldrec_.type_code );
   
      IF (newrec_.forecast_consumption_flag != oldrec_.forecast_consumption_flag)
         OR (newrec_.onhand_analysis_flag != oldrec_.onhand_analysis_flag) THEN
         IF newrec_.forecast_consumption_flag = 'FORECAST' AND newrec_.onhand_analysis_flag = 'Y' THEN
             Error_SYS.Record_General(lu_name_, 'ERRORFORECASTCONSUMP: :P1 is not allowed when Availability Check is selected.',
                                      Inv_Part_Forecast_Consum_API.Decode(newrec_.forecast_consumption_flag));
         END IF;
      END IF;
   
      IF (newrec_.forecast_consumption_flag != oldrec_.forecast_consumption_flag) THEN
         IF (newrec_.forecast_consumption_flag = 'NOFORECAST') THEN
            $IF (Component_Order_SYS.INSTALLED) $THEN
               Customer_Order_API.Check_Forecast_Consumpt_Change(newrec_.contract, newrec_.part_no);
            $ELSE
               NULL;
            $END                                                                        
         ELSE
            Client_SYS.Add_Warning(lu_name_, 'ONLINECONSUMNOTALLOW: IF online consumption is allowed, it is not possible to set it back to not allowed when customer orders are in a state other than Delivered, Invoiced/Closed and/or sales quotation lines are in Released, Revised or Rejected status.');            
         END IF;
      END IF;
   
      IF (newrec_.max_actual_cost_update IS NOT NULL) THEN
         IF (newrec_.max_actual_cost_update<0 or newrec_.max_actual_cost_update>1) THEN
            Error_SYS.Record_General(lu_name_, 'ERRORMAXACTCOST: Max Periodic Weighted Average Update can not be less than 0% or higher than 100%.');
         END IF;
      END IF;
   
      --Check whether the Inventory UM is equal to unit code of input UoM Group.
      IF (newrec_.input_unit_meas_group_id IS NOT NULL) THEN
         input_group_uom_ := Input_Unit_Meas_Group_API.Get_Unit_Code(newrec_.input_unit_meas_group_id);
         IF (input_group_uom_ != newrec_.unit_meas) THEN
            Raise_Input_Uom_Error___;
         END IF;
      END IF;
   
      --Check the Input UoM Group against the Sales Parts.
      IF( (oldrec_.input_unit_meas_group_id IS NULL) AND (newrec_.input_unit_meas_group_id IS NOT NULL)) THEN 
         $IF (Component_Order_SYS.INSTALLED) $THEN
            exist_invpart_ := Sales_Part_API.Exist_Mum_Inv_Part(newrec_.contract, newrec_.part_no);       
            IF (exist_invpart_ = 1) THEN
               Error_SYS.Record_General(lu_name_,'NOSALESPART: Sales Part is connected to the Inventory Part with an Inventory Conversion factor / Invert Conversion factor not equal to 1, cannot attach an Input UoM for this Inventory Part.');
            END IF;
         $ELSE
            NULL;
         $END
      END IF;
      
      Base(oldrec_, newrec_, indrec_, attr_);
      
      IF Client_SYS.Item_Exist('DESCRIPTION_COPY', attr_) THEN 
         newrec_.description := Client_SYS.Get_Item_Value('DESCRIPTION_COPY', attr_);
      END IF;
      
      Error_SYS.Check_Not_Null(lu_name_, 'ESTIMATED_MATERIAL_COST', new_estimated_material_cost_);
      
      Check_Min_Durab_Days_Co_Del___(newrec_.durability_day, newrec_.min_durab_days_co_deliv);
      Check_Min_Durab_Days_Plan___(newrec_.durability_day, newrec_.min_durab_days_planning);
   
      IF (newrec_.supersedes IS NOT NULL) THEN
         Exist(newrec_.contract, newrec_.supersedes);
      END IF;
   
      IF (newrec_.purch_leadtime != oldrec_.purch_leadtime) THEN
         Check_Lead_Time___(newrec_.purch_leadtime);
      END IF;
      IF (newrec_.manuf_leadtime != oldrec_.manuf_leadtime) THEN
         Check_Lead_Time___(newrec_.manuf_leadtime);
      END IF;
      IF (newrec_.expected_leadtime != oldrec_.expected_leadtime) THEN
         Check_Lead_Time___(newrec_.expected_leadtime);
      END IF;
   
      IF (newrec_.qty_calc_rounding != oldrec_.qty_calc_rounding) THEN
         IF NOT (part_catalog_fetched_) THEN
            part_catalog_rec_     := Part_Catalog_API.Get(newrec_.part_no);
            part_catalog_fetched_ := TRUE;
         END IF;
         Check_Qty_Calc_Rounding___(newrec_.qty_calc_rounding, part_catalog_rec_.receipt_issue_serial_track, newrec_.unit_meas);
      END IF;
   
      IF (newrec_.type_code != oldrec_.type_code) THEN
      -- Validate the Type Code with the Order Requisition in corresponding InventoryPartPlanning
         order_requisition_ := Inventory_Part_Planning_API.Get_Order_Requisition(newrec_.contract, newrec_.part_no);
         Inventory_Part_Planning_API.Validate_Order_Requisition(newrec_.contract,
                                                                newrec_.part_no,
                                                                order_requisition_,
                                                                Inventory_Part_Type_API.Decode(newrec_.type_code));
   
         IF (newrec_.type_code = '2') THEN
            unit_type_ := Iso_Unit_Type_API.Encode(Iso_Unit_API.Get_Unit_Type(newrec_.unit_meas ));
            IF unit_type_ NOT IN ('WEIGHT', 'VOLUME') THEN
               Error_SYS.Record_General(lu_name_, 'RECIPUNITTYPE: Unit of measure for part type :P1 must be of unit type :P2 or :P3.',
                                        Inventory_Part_Type_API.Decode(newrec_.type_code),
                                        Iso_Unit_Type_API.Decode('WEIGHT'),
                                        Iso_Unit_Type_API.Decode('VOLUME'));
            END IF;
            IF NOT (part_catalog_fetched_) THEN
               part_catalog_rec_     := Part_Catalog_API.Get(newrec_.part_no);
               part_catalog_fetched_ := TRUE;
            END IF;
            IF (part_catalog_rec_.configurable = 'CONFIGURED') THEN
               Error_SYS.Record_General(lu_name_, 'NOCONFIGRECIPE: Type code must not be :P1 for a configured part.',
                                        Inventory_Part_Type_API.Decode(newrec_.type_code) );
            END IF;
         END IF;
   
         IF newrec_.type_code != '1' THEN
            IF NOT (part_catalog_fetched_) THEN
               part_catalog_rec_     := Part_Catalog_API.Get(newrec_.part_no);
               part_catalog_fetched_ := TRUE;
            END IF;
            IF (part_catalog_rec_.position_part = 'POSITION PART') THEN
               Raise_Position_Part_Type_Error___;
            END IF;
         END IF;
   
         IF (newrec_.type_code IN ('3', '6') AND oldrec_.type_code IN ('1', '2'))
            OR (newrec_.type_code IN ('3') AND oldrec_.type_code IN ('4'))THEN
            IF Split_Manuf_Acquired_Api.Encode(Inventory_Part_Planning_API.Get_Split_Manuf_Acquired(newrec_.contract, newrec_.part_no)) = 'SPLIT' THEN
               Error_SYS.Record_General(lu_name_, 'PRTTYPCANTSET: Part type cannot set to :P1 since the inventory part :P2 defines split on planing data.',
                                        Inventory_Part_Type_API.Decode(newrec_.type_code), newrec_.part_no);
            END IF;
         END IF;
         IF (newrec_.type_code = 6) THEN
            IF NOT (part_catalog_fetched_) THEN
               part_catalog_rec_     := Part_Catalog_API.Get(newrec_.part_no);
               part_catalog_fetched_ := TRUE;
            END IF;
            Check_Expense_Part_Allowed___(part_catalog_rec_.allow_as_not_consumed);
         END IF;
      END IF;
   
      IF (newrec_.lead_time_code = 'M' AND newrec_.supply_code = 'PO') THEN
          Error_SYS.Record_General(lu_name_,'NOTVALIDSUPPLYCODE: Supply code must not be :P1 for a manufactured part',
                                   Material_Requis_Supply_API.Decode(newrec_.supply_code));
      END IF;
   
      IF ((oldrec_.eng_attribute IS NOT NULL) AND (newrec_.eng_attribute IS NULL)) THEN
         IF (Inventory_Part_char_API.Part_Has_Char(newrec_.contract,newrec_.part_no)) THEN
            Error_SYS.Record_General(lu_name_,'CHARVALUESSEXIST: All characteristic codes must be deleted before characteristic template is removed');
         END IF;
      END IF;
   
      -- IF customs statistics number's unit measure has a value, check if intrastat conv factor and net weight have been entered too
      IF ((NVL(newrec_.intrastat_conv_factor, number_null_) != NVL(oldrec_.intrastat_conv_factor, number_null_)) OR 
          (NVL(newrec_.customs_stat_no, str_null_) != NVL(oldrec_.customs_stat_no, str_null_))) THEN
         Check_Intrastat_And_Customs___(newrec_.customs_stat_no, newrec_.intrastat_conv_factor);
      END IF;
   
      IF (newrec_.zero_cost_flag != oldrec_.zero_cost_flag) THEN
         Inventory_Part_Config_API.Check_Zero_Cost_Flag(newrec_.contract,
                                                        newrec_.part_no,
                                                        newrec_.zero_cost_flag,
                                                        newrec_.inventory_part_cost_level,
                                                        newrec_.inventory_valuation_method);
      END IF;
   
      IF (NVL(newrec_.part_cost_group_id, char_null_) !=
          NVL(oldrec_.part_cost_group_id, char_null_)) THEN
          IF (newrec_.part_cost_group_id IS NOT NULL) THEN
             $IF (Component_Cost_SYS.INSTALLED) $THEN
                Trace_SYS.Message('contract -' || newrec_.contract||' cost group -'||newrec_.part_cost_group_id);
                Part_Cost_Group_API.Exist(newrec_.contract, newrec_.part_cost_group_id);
             $ELSE
                NULL;
             $END      
         END IF;
      END IF;
   
      IF (oldrec_.stock_management = 'SYSTEM MANAGED INVENTORY') AND
         (newrec_.stock_management = 'VENDOR MANAGED INVENTORY') AND
         (newrec_.lead_time_code   = 'M') THEN
          Error_SYS.Record_General(lu_name_, 'NOVMIMANUF: Cannot have Vendor Managed Inventory when part is manufactured.');
      END IF;
   
      IF (newrec_.cycle_period < 0) THEN
         Error_SYS.Record_General(lu_name_, 'CYCLEPERIOD: The value for Cycle Period may not be negative.');
      END IF;
   
      IF (newrec_.invoice_consideration != oldrec_.invoice_consideration) THEN
         IF NOT (site_rec_fetched_) THEN
            site_rec_ := Site_API.Get(newrec_.contract);
            site_rec_fetched_ := TRUE;
         END IF;
         Check_Invoice_Consideration___(newrec_.contract,
                                        site_rec_.company,
                                        newrec_.invoice_consideration);
         IF (newrec_.invoice_consideration = 'PERIODIC WEIGHTED AVERAGE') THEN
            -- This section captures the following modifications of invoice_consideration:
            -- IGNORE INVOICE PRICE  ==>  PERIODIC WEIGHTED AVERAGE
            -- TRANSACTION BASED     ==>  PERIODIC WEIGHTED AVERAGE
            -- Activate Periodic Weighted Average.
            $IF (Component_Purch_SYS.INSTALLED) $THEN
               IF (Purchase_Order_Line_Comp_API.Component_Part_Used(newrec_.contract, newrec_.part_no)) THEN
                  part_exist_ := 1;
               ELSE
                  part_exist_ := 0;
               END IF;
               IF (part_exist_ = 1) THEN
                     Error_SYS.Record_General(lu_name_, 'ACPOLCOMP: Supplier Invoice Consideration :P1 is not allowed for parts entered as supplier material components on active purchase orders.', Invoice_Consideration_API.Decode(newrec_.invoice_consideration));
               END IF;
              
            
               IF (Pur_Ord_Charged_Comp_API.Not_Charged_Comp_Used(newrec_.contract, newrec_.part_no)) THEN
                  part_exist_ := 1;
               ELSE
                  part_exist_ := 0;
               END IF;
               IF (part_exist_ = 1) THEN
                   Error_SYS.Record_General(lu_name_, 'ACNOCHARGE: Supplier Invoice Consideration :P1 is not allowed for parts entered as No Charge material on active purchase orders.', Invoice_Consideration_API.Decode(newrec_.invoice_consideration));
               END IF;
            
           
               -- Note: Check if the inventory part is used as an exchange component in an open purchase order and/or requisition
               part_exist_ := Pur_Order_Exchange_Comp_API.Exchange_Comp_Used(newrec_.contract, newrec_.part_no);
               IF (part_exist_ = 1) THEN
                   Error_SYS.Record_General(lu_name_, 'ACEXCOMP: Supplier Invoice Consideration :P1 not allowed for parts entered as exchange components on active purchase orders and/or requisitions.', Invoice_Consideration_API.Decode(newrec_.invoice_consideration));
               END IF;
            $ELSE 
               NULL;
            $END
            
            -- Check if the inventory part is used on any MRO Shop Order
            $IF (Component_Mromfg_SYS.INSTALLED) $THEN        
               part_exist_ :=0;
               part_exist_ := Interim_Mro_Manager_API.Check_Part_In_Shop_Order(newrec_.contract, newrec_.part_no);
               IF (part_exist_ = 1) THEN
                   Error_SYS.Record_General(lu_name_, 'ACSHOPORD: Supplier Invoice Consideration :P1 is not allowed for parts existing on a MRO Shop Order.', Invoice_Consideration_API.Decode(newrec_.invoice_consideration));
               END IF;
            $ELSE 
               NULL;
            $END
          
          -- Check if the inventory part is used on a Shop Order is externally owned
            $IF (Component_Shpord_SYS.INSTALLED) $THEN        
               part_exist_ :=0;
               part_exist_ := Shop_Ord_Util_API.External_Part_In_Shop_Order(newrec_.contract, newrec_.part_no);          
               IF (part_exist_ = 1) THEN
                  Error_SYS.Record_General(lu_name_, 'ACEXTSHOP: Supplier Invoice Consideration :P1 is not allowed for externally owned parts existing on a Shop Order.', Invoice_Consideration_API.Decode(newrec_.invoice_consideration));
               END IF;
            $ELSE 
               NULL;
            $END
   
            -- This block will search for Purchase Order Lines which has wither 'Released' Milestone lines or
            -- No Milestone Lines with purchase payment type 'STAGE'. Found will raised error for PWA modification.
            $IF (Component_Purch_SYS.INSTALLED) $THEN
               IF (Purchase_Order_Milestone_API.Chk_Released_Or_No_Stage_Lines(newrec_.contract, newrec_.part_no)) THEN
                  line_exist_ := 1;
               ELSE
                  line_exist_ := 0;
               END IF;         
               IF (line_exist_ = 1) THEN
                  Error_SYS.Record_General(lu_name_, 'STAGELINEEXIST: Supplier Invoice Consideration :P1 is not allowed for parts in Purchase Order Lines with Stage Payments.', Invoice_Consideration_API.Decode(newrec_.invoice_consideration));
               END IF;
            $ELSE 
               NULL;
            $END
         ELSIF (oldrec_.invoice_consideration = 'PERIODIC WEIGHTED AVERAGE') THEN
            -- This section captures the following modifications of invoice_consideration:
            -- PERIODIC WEIGHTED AVERAGE  ==>  IGNORE INVOICE PRICE
            -- PERIODIC WEIGHTED AVERAGE  ==>  TRANSACTION BASED
            -- Periodic Weighted Average has been switched off for the part. Check that
            -- the accumulated differences are equal to zero for all configurations.
            Actual_Cost_Manager_API.Check_Actual_Cost_Closure(newrec_.contract,
                                                              newrec_.part_no);
         ELSE
            -- This section captures all other modifications of invoice_consideration:
            -- IGNORE INVOICE PRICE  ==>  TRANSACTION_BASED
            -- TRANSACTION BASED     ==>  IGNORE INVOICE PRICE
            NULL;
         END IF;
      END IF;
   
      IF (newrec_.inventory_valuation_method != oldrec_.inventory_valuation_method) OR
         (newrec_.inventory_part_cost_level  != oldrec_.inventory_part_cost_level)  OR
         (newrec_.invoice_consideration      != oldrec_.invoice_consideration)      OR
         (newrec_.zero_cost_flag             != oldrec_.zero_cost_flag)             OR
         (newrec_.negative_on_hand           != oldrec_.negative_on_hand)           OR
         (newrec_.ext_service_cost_method    != oldrec_.ext_service_cost_method)    OR
         (newrec_.lead_time_code             != oldrec_.lead_time_code)             THEN
   
         IF NOT (part_catalog_fetched_) THEN
            part_catalog_rec_     := Part_Catalog_API.Get(newrec_.part_no);
            part_catalog_fetched_ := TRUE;
         END IF;
   
         Check_Value_Method_Combinat___(newrec_,
                                        part_catalog_rec_.configurable,
                                        part_catalog_rec_.condition_code_usage,
                                        part_catalog_rec_.lot_tracking_code,
                                        part_catalog_rec_.serial_tracking_code,
                                        part_catalog_rec_.receipt_issue_serial_track);
   
         -- IF Catch Unit is enabled or whether the part is tracked or if the part is lot tracked, 
         -- negative_on_hand should be NEG ONHAND NOT OK
         IF (newrec_.negative_on_hand != oldrec_.negative_on_hand) THEN
            Check_Negative_On_Hand(newrec_.negative_on_hand, 
                                   part_catalog_rec_.catch_unit_enabled,
                                   part_catalog_rec_.receipt_issue_serial_track, 
                                   part_catalog_rec_.lot_tracking_code);
         END IF;
      END IF;
   
      IF ((oldrec_.inventory_valuation_method != newrec_.inventory_valuation_method) OR
          (oldrec_.inventory_part_cost_level  != newrec_.inventory_part_cost_level)) THEN
         -- Execute validations when changing valuation method or part cost level
         Check_Value_Method_Change___(newrec_, oldrec_);
      END IF;
   
      IF (newrec_.shortage_flag != oldrec_.shortage_flag) THEN
         IF (newrec_.shortage_flag = 'Y') THEN
            IF (Mpccom_System_Parameter_API.Get_Parameter_Value1('SHORTAGE_HANDLING') = 'N') THEN
               Error_SYS.Record_General(lu_name_, 'NOSHORTAGEHANDLE: Cannot have shortages at part level if System flag is set to No.');
            END IF;
            IF NOT (part_catalog_fetched_) THEN
               part_catalog_rec_     := Part_Catalog_API.Get(newrec_.part_no);
               part_catalog_fetched_ := TRUE;
            END IF;
            IF (part_catalog_rec_.configurable = 'CONFIGURED') THEN
            -- shortage handling is not allowed for configured parts.
               Error_SYS.Record_General(lu_name_, 'NOSHORTCONFIG: Shortage handling is not allowed for configured parts.');
            END IF;
         END IF;
      END IF;
   
      IF (NVL(newrec_.region_of_origin,char_null_) != NVL(oldrec_.region_of_origin,char_null_)) THEN
         IF (newrec_.region_of_origin IS NOT NULL) THEN
            IF NOT (site_rec_fetched_) THEN
               site_rec_ := Site_API.Get(newrec_.contract);
               site_rec_fetched_ := TRUE;
            END IF;
            -- fetch site/receivers country and check it
            country_code_ := ISO_Country_API.Encode(Company_Address_API.Get_Country(site_rec_.company,
                                                                                    site_rec_.delivery_address));
            IF (country_code_ IS NULL) THEN
               Error_SYS.Record_General(lu_name_,'NORECEIVCOUNTRY: Site delivery address :P1 must have a country code.', site_rec_.delivery_address );
            ELSE
               Country_Region_API.Exist(country_code_, newrec_.region_of_origin);
            END IF;
         END IF;
      END IF;
   
      IF (newrec_.ext_service_cost_method != oldrec_.ext_service_cost_method) THEN
         Check_Open_Eso_Exist___(newrec_.contract, newrec_.part_no);
      END IF;
   
      IF (updated_by_client_) THEN
         IF ((newrec_.type_code != oldrec_.type_code) OR (newrec_.purch_leadtime != oldrec_.purch_leadtime)) THEN
            IF ((newrec_.type_code IN ('3','4','6')) AND (newrec_.purch_leadtime = 0)) THEN
               $IF (Component_Mfgstd_SYS.INSTALLED) $THEN
                  sched_capacity_ := Inventory_Part_Planning_API.Get_Sched_Capacity_Db(newrec_.contract, newrec_.part_no);
                  IF (sched_capacity_ = 'F') THEN
                     Error_SYS.Record_General(lu_name_, 'FPURCHZEROLT: Leadtime for purchased part with finite capacity cannot be zero.');
                  END IF;
               $ELSE
                  NULL;  
               $END
            END IF;
         END IF; 
      END IF;
   
      Check_Auto_Capability_Check___(newrec_);
      IF (oldrec_.automatic_capability_check != newrec_.automatic_capability_check) AND
         (newrec_.automatic_capability_check IN ('RESERVE AND ALLOCATE','ALLOCATE ONLY','NEITHER RESERVE NOR ALLOCATE')) THEN
         -- warn the user that an automatic order capability check could take time
         Client_SYS.Add_Info(lu_name_, 'AOCCWARNING: The current set up will start the Capability Check automatically when a customer order line is entered or updated. Please, be aware of that such a check can take time.');
      END IF;
   
      -- Updating catch unit meas is not allowed if it is a not null value
      IF ((oldrec_.catch_unit_meas != newrec_.catch_unit_meas) OR
          (oldrec_.catch_unit_meas IS NOT NULL AND newrec_.catch_unit_meas IS NULL)) THEN
         Error_SYS.Record_General('InventoryPart','NOUPDATEINVEXIST: Catch UoM cannot be modified once specified.');
      END IF;
   
      -- checking catch unit meas
      IF (oldrec_.catch_unit_meas IS NULL AND newrec_.catch_unit_meas IS NOT NULL) THEN
         OPEN get_catch_uom;
         FETCH get_catch_uom INTO part_catch_unit_meas_;
   
         IF (get_catch_uom%FOUND) THEN
            IF (Iso_Unit_API.Get_Base_Unit(newrec_.catch_unit_meas) != Iso_Unit_API.Get_Base_Unit(part_catch_unit_meas_)) THEN
               CLOSE get_catch_uom;
               Error_SYS.Record_General(lu_name_, 'BASCATUNIT: The base unit :P1 for catch U/M :P2 is different from the base unit for this part on another site.', Iso_Unit_API.Get_Base_Unit(newrec_.catch_unit_meas), newrec_.catch_unit_meas );
            END IF;
         END IF;
         CLOSE get_catch_uom;
   
         IF NOT (part_catalog_fetched_) THEN
            part_catalog_rec_     := Part_Catalog_API.Get(newrec_.part_no);
            part_catalog_fetched_ := TRUE;
         END IF;
   
         IF (part_catalog_rec_.catch_unit_enabled = 'TRUE') THEN
            $IF (Component_Order_SYS.INSTALLED) $THEN
               Sales_Part_API.Check_Enable_Catch_Unit(newrec_.contract, newrec_.part_no, newrec_.catch_unit_meas);         
            $ELSE
               NULL;
            $END         
         END IF;
      END IF;
   
      IF (oldrec_.input_unit_meas_group_id IS NOT NULL) THEN
         IF (NVL(newrec_.input_unit_meas_group_id, Database_SYS.string_null_) != NVL(oldrec_.input_unit_meas_group_id, Database_SYS.string_null_)) THEN
            IF NOT (part_catalog_fetched_) THEN
               part_catalog_rec_     := Part_Catalog_API.Get(newrec_.part_no);
               part_catalog_fetched_ := TRUE;
            END IF;
            IF (oldrec_.input_unit_meas_group_id = part_catalog_rec_.input_unit_meas_group_id) THEN
               IF (Part_Gtin_Unit_Meas_API.Check_Exist_Any_Unit(newrec_.part_no)) THEN
                  -- Info message to user that connection to the GTIN 14 numbers are lost in Part Catalog
                  Client_SYS.Add_Info(lu_name_, 'GTIN14CONNLOST: IF you manually change or delete the input unit of measure group, the connection to the GTIN 14 for packages will be lost from the site :P1.', newrec_.contract);
               END IF;
            END IF;
         END IF;
      END IF;
   
      -- Check Storage Capacities and Conditions Requirements
      IF (NVL(newrec_.storage_width_requirement, number_null_) != NVL(oldrec_.storage_width_requirement, number_null_)) THEN
         Part_Catalog_Invent_Attrib_API.Check_Cubic_Capacity(newrec_.storage_width_requirement);
      END IF;
      IF (NVL(newrec_.storage_height_requirement, number_null_) != NVL(oldrec_.storage_height_requirement, number_null_)) THEN
         Part_Catalog_Invent_Attrib_API.Check_Cubic_Capacity(newrec_.storage_height_requirement);
      END IF;
      IF (NVL(newrec_.storage_depth_requirement, number_null_) != NVL(oldrec_.storage_depth_requirement, number_null_)) THEN
         Part_Catalog_Invent_Attrib_API.Check_Cubic_Capacity(newrec_.storage_depth_requirement);
      END IF;
      IF (NVL(newrec_.storage_weight_requirement, number_null_) != NVL(oldrec_.storage_weight_requirement, number_null_)) THEN
         Part_Catalog_Invent_Attrib_API.Check_Carrying_Capacity(newrec_.storage_weight_requirement);
      END IF;
      IF (NVL(newrec_.min_storage_humidity, number_null_) != NVL(oldrec_.min_storage_humidity, number_null_)) THEN
         Part_Catalog_Invent_Attrib_API.Check_Humidity(newrec_.min_storage_humidity);
      END IF;
      IF (NVL(newrec_.max_storage_humidity, number_null_) != NVL(oldrec_.max_storage_humidity, number_null_)) THEN
         Part_Catalog_Invent_Attrib_API.Check_Humidity(newrec_.max_storage_humidity);
      END IF;
      IF (NVL(newrec_.standard_putaway_qty, number_null_) != NVL(oldrec_.standard_putaway_qty, number_null_)) THEN
         Check_Standard_Putaway_Qty___(newrec_.standard_putaway_qty);
      END IF;
   
      IF (NVL(newrec_.standard_putaway_qty, number_null_) != NVL(oldrec_.standard_putaway_qty, number_null_)) THEN
         IF NOT (part_catalog_fetched_) THEN
            part_catalog_rec_     := Part_Catalog_API.Get(newrec_.part_no);
            part_catalog_fetched_ := TRUE;
         END IF;
      END IF;
      
      IF (newrec_.zero_cost_flag != 'O') THEN
         updated_control_type_ := Get_Updated_Control_Type___(oldrec_,
                                                           newrec_,
                                                           check_only_active_ => FALSE,
                                                           company_           => NULL);
         IF (updated_control_type_ IS NOT NULL) THEN
            IF NOT (site_rec_fetched_) THEN
               site_rec_ := Site_API.Get(newrec_.contract);
               site_rec_fetched_ := TRUE;
            END IF;
            IF (Company_Invent_Info_API.Stock_Ctrl_Types_Blocked(site_rec_.company)) THEN
               updated_control_type_ := Get_Updated_Control_Type___(oldrec_,
                                                                    newrec_,
                                                                    check_only_active_ => TRUE,
                                                                    company_           => site_rec_.company);
               IF (updated_control_type_ IS NOT NULL) THEN
                  IF (Company_Owned_Stock_Exists___(newrec_.contract, newrec_.part_no)) THEN
                     Error_SYS.Record_General(lu_name_, 'CTRLTYPEBLOCKED: Control type :P1 cannot be updated since modification of stock account control type values is blocked in company :P2.',Posting_Ctrl_Control_Type_API.Get_Description(updated_control_type_,'INVENT',site_rec_.company), site_rec_.company);
                  END IF;
               END IF;
            END IF;
         END IF;
      END IF;
   
      IF (NVL(newrec_.earliest_ultd_supply_date, Database_SYS.first_calendar_date_) != 
          NVL(oldrec_.earliest_ultd_supply_date, Database_SYS.first_calendar_date_)) THEN
         IF (newrec_.earliest_ultd_supply_date IS NOT NULL) THEN
            IF NOT (site_rec_fetched_) THEN
               site_rec_ := Site_API.Get(newrec_.contract);
               site_rec_fetched_ := TRUE;
            END IF;
   
            IF (Work_Time_Calendar_API.Is_Working_Day(site_rec_.dist_calendar_id,
                                                      newrec_.earliest_ultd_supply_date) = 0) THEN
                  Error_SYS.Record_General(lu_name_, 'NOTWORKDAY: :P1 is not a work day in calendar :P2 - :P3.', to_char(newrec_.earliest_ultd_supply_date, 'YYYY-MM-DD'), site_rec_.dist_calendar_id, Work_Time_Calendar_API.Get_Description(site_rec_.dist_calendar_id));
            END IF;
         END IF;
      END IF;
   
      IF (NVL(newrec_.supersedes, str_null_) != NVL(oldrec_.supersedes, str_null_)) THEN
         Check_Supersedes___(newrec_.contract, newrec_.part_no, newrec_.supersedes, newrec_.part_status);
      END IF;
   
      IF ((newrec_.mandatory_expiration_date = Fnd_Boolean_API.DB_TRUE )  AND
          (oldrec_.mandatory_expiration_date = Fnd_Boolean_API.DB_FALSE)) THEN
         IF (Inventory_Part_In_Stock_API.Expiration_Date_Is_Missing(newrec_.contract, newrec_.part_no)) THEN
            Error_SYS.Record_General(lu_name_, 'MANDEXPDATE: Expiration date must be specified for all stock records except on location types :P1 and :P2.', Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_ARRIVAL), Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_QUALITY_ASSURANCE));
         END IF;
      END IF;
      
      Client_Sys.Add_To_Attr('ESTIMATED_MATERIAL_COST', new_estimated_material_cost_, attr_ );
      
   EXCEPTION
      WHEN value_error THEN
         Error_SYS.Item_Format(lu_name_, name_, value_);
   END Core;

BEGIN
   Core(oldrec_, newrec_, indrec_, attr_, updated_by_client_);
END Check_Update___;


PROCEDURE Update___ (
   objid_             IN     VARCHAR2,
   oldrec_            IN     inventory_part_tab%ROWTYPE,
   newrec_            IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   attr_              IN OUT NOCOPY VARCHAR2,
   objversion_        IN OUT NOCOPY VARCHAR2,
   by_keys_           IN     BOOLEAN DEFAULT FALSE )
IS
   
   PROCEDURE Base (
      objid_      IN     VARCHAR2,
      oldrec_     IN     inventory_part_tab%ROWTYPE,
      newrec_     IN OUT NOCOPY inventory_part_tab%ROWTYPE,
      attr_       IN OUT NOCOPY VARCHAR2,
      objversion_ IN OUT NOCOPY VARCHAR2,
      by_keys_    IN     BOOLEAN DEFAULT FALSE )
   IS
      value_too_large  EXCEPTION;
      PRAGMA           EXCEPTION_INIT(value_too_large, -12899);
   BEGIN
      newrec_.rowversion := sysdate;
      IF by_keys_ THEN
         UPDATE inventory_part_tab
            SET ROW = newrec_
            WHERE contract = newrec_.contract
            AND   part_no = newrec_.part_no;
      ELSE
         UPDATE inventory_part_tab
            SET ROW = newrec_
            WHERE rowid = objid_;
      END IF;
      objversion_ := to_char(newrec_.rowversion,'YYYYMMDDHH24MISS');
      Invalidate_Cache___;
   EXCEPTION
      WHEN dup_val_on_index THEN
         DECLARE
            constraint_ VARCHAR2(4000) := Utility_SYS.Get_Constraint_From_Error_Msg(sqlerrm);
         BEGIN
            IF (constraint_ = 'INVENTORY_PART_RK') THEN
               Error_SYS.Fnd_Rowkey_Exist(Inventory_Part_API.lu_name_, newrec_.rowkey);
            ELSIF (constraint_ = 'INVENTORY_PART_PK') THEN
               Raise_Record_Exist___(newrec_);
            ELSE
               Raise_Constraint_Violated___(newrec_, constraint_);
            END IF;
         END;
      WHEN value_too_large THEN
         Error_SYS.Fnd_Item_Length(lu_name_, sqlerrm);
   END Base;

   PROCEDURE Core (
      objid_             IN     VARCHAR2,
      oldrec_            IN     inventory_part_tab%ROWTYPE,
      newrec_            IN OUT NOCOPY inventory_part_tab%ROWTYPE,
      attr_              IN OUT NOCOPY VARCHAR2,
      objversion_        IN OUT NOCOPY VARCHAR2,
      by_keys_           IN     BOOLEAN DEFAULT FALSE )
   IS
      site_date_                    DATE;   
      num_null_                     NUMBER       := -99999;
      str_null_                     VARCHAR2(11) := Database_SYS.string_null_;
      new_estimated_material_cost_  NUMBER;
   BEGIN
      site_date_                        := Site_API.Get_Site_Date(newrec_.contract);
      newrec_.last_activity_date        := trunc(site_date_);
      newrec_.earliest_ultd_supply_date := trunc(newrec_.earliest_ultd_supply_date);
   
      IF (newrec_.purch_leadtime != oldrec_.purch_leadtime) THEN
         newrec_.avail_activity_status := 'CHANGED';
      END IF;
   
      IF (oldrec_.lead_time_code = 'P' AND newrec_.lead_time_code = 'M') THEN
         newrec_.stock_management := 'SYSTEM MANAGED INVENTORY';
      END IF;
   
      IF (newrec_.invoice_consideration != oldrec_.invoice_consideration) THEN
         IF (newrec_.invoice_consideration = 'PERIODIC WEIGHTED AVERAGE') THEN
            -- Activate Periodic Weighted Average.
            newrec_.actual_cost_activated := Inventory_Transaction_Hist_API.Get_Last_Transaction_For_Part(newrec_.contract, newrec_.part_no);
         ELSE
            -- Deactivate Periodic Weighted Average.
            newrec_.actual_cost_activated := NULL;
         END IF;
      END IF;
   
      IF newrec_.storage_volume_requirement IS NOT NULL THEN
         IF Part_Catalog_Invent_Attrib_API.Get_Storage_Width_Requirement(newrec_.part_no) IS NULL AND
             newrec_.storage_width_requirement IS NULL THEN
            newrec_.storage_width_requirement := 0;
         END IF;
         IF Part_Catalog_Invent_Attrib_API.Get_Storage_Height_Requirement(newrec_.part_no) IS NULL AND
             newrec_.storage_height_requirement IS NULL THEN
            newrec_.storage_height_requirement := 0;
         END IF;
         IF Part_Catalog_Invent_Attrib_API.Get_Storage_Depth_Requirement(newrec_.part_no) IS NULL AND
             newrec_.storage_depth_requirement IS NULL THEN
            newrec_.storage_depth_requirement := 0;
         END IF;
      END IF;
      
      IF (Validate_SYS.Is_Changed(oldrec_.lifecycle_stage, newrec_.lifecycle_stage)) THEN    
         IF (newrec_.lifecycle_stage = Inv_Part_Lifecycle_Stage_API.DB_DECLINE) THEN
            newrec_.decline_date := trunc(site_date_);
            newrec_.expired_date := NULL;
            newrec_.expired_issue_counter := NULL;
         ELSIF (newrec_.lifecycle_stage = Inv_Part_Lifecycle_Stage_API.DB_EXPIRED)THEN
            newrec_.expired_date := trunc(site_date_);
            newrec_.decline_date := NULL;
            newrec_.decline_issue_counter := NULL;
         ELSE
            newrec_.decline_date := NULL;
            newrec_.expired_date := NULL;
            newrec_.decline_issue_counter := NULL;
            newrec_.expired_issue_counter := NULL;
         END IF;
      END IF;
   
      Base(objid_, oldrec_, newrec_, attr_, objversion_, by_keys_);
      
      new_estimated_material_cost_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('ESTIMATED_MATERIAL_COST', attr_));
      -------------------------------------------------------------
      --  The call to method Modify_Estimated_Material_Cost      --
      --  below must NOT under any circumstances be moved above  --
      --  the UPDATE statements for table INVENTORY_PART_TAB.    --
      --  That would lead to fatal database inconsistency.       --
      -------------------------------------------------------------
      Inventory_Part_Config_API.Modify_Estimated_Material_Cost(
                                newrec_.contract,
                                newrec_.part_no,
                                '*',
                                new_estimated_material_cost_);
   
      IF (nvl(newrec_.part_cost_group_id,'NOTNULL') != nvl(oldrec_.part_cost_group_id,'NOTNULL')) THEN    
         $IF (Component_Cost_SYS.INSTALLED) $THEN
            Part_Cost_API.Changed_Group_Id(newrec_.contract, newrec_.part_no, newrec_.part_cost_group_id);
         $ELSE
            NULL;
         $END   
      END IF;
   
      IF ( newrec_.type_code != oldrec_.type_code ) THEN
         IF (Split_Manuf_Acquired_API.Encode(Inventory_Part_Planning_API.Get_Split_Manuf_Acquired(newrec_.contract, newrec_.part_no)) = 'NO_SPLIT') THEN
            Inventory_Part_Planning_API.Modify_Manuf_Acq_Percent(newrec_.contract,
                                                                 newrec_.part_no,
                                                                 newrec_.type_code);
         END IF;
         
         $IF Component_Mfgstd_SYS.INSTALLED $THEN
            Manuf_Structure_Util_API.Handle_Type_Code_Change(newrec_.contract,
                                                             newrec_.part_no,
                                                             newrec_.type_code,
                                                             oldrec_.type_code);
   
         $END
    
         $IF Component_Expctr_SYS.INSTALLED $THEN
            Exp_License_Connect_Util_API.Handle_Type_Code_Change(newrec_.part_no);
         $END
      END IF;
   
      IF (newrec_.lead_time_code != oldrec_.lead_time_code) THEN      
         $IF (Component_Cost_SYS.INSTALLED) $THEN
            Cost_Int_API.New_Lead_Time_Code(newrec_.contract, newrec_.part_no, newrec_.lead_time_code);
         $ELSE
            NULL;
         $END  
   
         $IF (Component_Purch_SYS.INSTALLED) $THEN
            Purchase_Part_API.Handle_Lead_Time_Code_Change(newrec_.contract,
                                                           newrec_.part_no,
                                                           newrec_.lead_time_code,
                                                           newrec_.description,
                                                           newrec_.unit_meas);
         $ELSE
            NULL;
         $END        
      END IF;
   
      IF (newrec_.invoice_consideration != oldrec_.invoice_consideration) THEN
         IF (newrec_.invoice_consideration = 'PERIODIC WEIGHTED AVERAGE') THEN
            IF (Site_Invent_Info_API.Get_Last_Actual_Cost_Calc(newrec_.contract) IS NULL) THEN
               Site_Invent_Info_API.Set_Last_Actual_Cost_Calc(newrec_.contract, site_date_);
            END IF;
         END IF;
      END IF;
   
      IF (newrec_.inventory_part_cost_level != oldrec_.inventory_part_cost_level) THEN
         Inventory_Part_Unit_Cost_API.Handle_Part_Cost_Level_Change(newrec_.contract,
                                                                    newrec_.part_no,
                                                                    oldrec_.inventory_part_cost_level,
                                                                    newrec_.inventory_part_cost_level);
      END IF;
   
      IF (newrec_.inventory_valuation_method != oldrec_.inventory_valuation_method) THEN
         Inventory_Part_Unit_Cost_API.Handle_Valuation_Method_Change(newrec_.contract,
                                                                     newrec_.part_no,
                                                                     newrec_.inventory_part_cost_level,
                                                                     oldrec_.inventory_valuation_method,
                                                                     newrec_.inventory_valuation_method);
      END IF;
      
      $IF (Component_Order_SYS.INSTALLED) $THEN   
         IF (nvl(newrec_.customs_stat_no, CHR(2)) != nvl(oldrec_.customs_stat_no, CHR(2)) OR nvl(newrec_.intrastat_conv_factor, 0) != nvl(oldrec_.intrastat_conv_factor, 0)) THEN
            Sales_Part_API.Modify_Intrastat_And_Customs(newrec_.contract, newrec_.part_no, newrec_.customs_stat_no, newrec_.intrastat_conv_factor);
         END IF;
      $END
   
      -- Update Chemmate and doc reference
      IF ((newrec_.description != oldrec_.description) AND
         (Site_Invent_Info_API.Get_Use_Partca_Desc_Invent_Db(newrec_.contract) = 'FALSE'))THEN
         Handle_Description_Change___(newrec_.contract, newrec_.part_no);
      END IF;
   
      IF ((NVL(newrec_.prime_commodity,  str_null_) != NVL(oldrec_.prime_commodity,  str_null_)) OR
          (NVL(newrec_.second_commodity, str_null_) != NVL(oldrec_.second_commodity, str_null_)) OR
          (NVL(newrec_.durability_day,   num_null_) != NVL(oldrec_.durability_day,   num_null_)) OR
          (    newrec_.asset_class                  !=     oldrec_.asset_class                 ) OR
          (    newrec_.abc_class                    !=     oldrec_.abc_class                   ) OR
          (    newrec_.frequency_class              !=     oldrec_.frequency_class             ) OR
          (    newrec_.lifecycle_stage              !=     oldrec_.lifecycle_stage             ) OR
          (    newrec_.qty_calc_rounding            !=     oldrec_.qty_calc_rounding           ) OR
          (    newrec_.part_status                  !=     oldrec_.part_status                 ) OR
          (    newrec_.stock_management             !=     oldrec_.stock_management            ) OR
          (    newrec_.expected_leadtime            !=     oldrec_.expected_leadtime           )) THEN
         Handle_Planning_Attr_Change___(newrec_, oldrec_);
      END IF;
      
      IF (newrec_.part_status != oldrec_.part_status) THEN
         Handle_Part_Status_Change___(newrec_.contract,
                                      newrec_.part_no,
                                      oldrec_.part_status,
                                      newrec_.part_status);
      END IF;
      
      IF ((NVL(newrec_.min_storage_temperature, num_null_) != NVL(oldrec_.min_storage_temperature, num_null_)) OR
          (NVL(newrec_.max_storage_temperature, num_null_) != NVL(oldrec_.max_storage_temperature, num_null_))) THEN
         -- These checks needs to be performed after updating the record
         -- because it uses Get_Min_Storage_Temperature and Get_Max_Storage_Temperature which reads the database.
         Check_Temperature_Range(newrec_.part_no, newrec_.contract);
      END IF;
   
      IF ((NVL(newrec_.min_storage_humidity, num_null_) != NVL(oldrec_.min_storage_humidity, num_null_)) OR
          (NVL(newrec_.max_storage_humidity, num_null_) != NVL(oldrec_.max_storage_humidity, num_null_))) THEN
         -- These checks needs to be performed after updating the record
         -- because it uses Get_Min_Storage_Humidity and Get_Max_Storage_Humidity which reads the database.
         Check_Humidity_Range(newrec_.part_no, newrec_.contract);
      END IF;
   
   EXCEPTION
      WHEN dup_val_on_index THEN
         Error_SYS.Record_Exist(lu_name_);
   END Core;

BEGIN
   Core(objid_, oldrec_, newrec_, attr_, objversion_, by_keys_);
END Update___;


PROCEDURE Modify___ (
   newrec_              IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   lock_mode_wait_      IN     BOOLEAN DEFAULT TRUE,
   updated_by_client_   IN     BOOLEAN DEFAULT FALSE )
IS
   
   PROCEDURE Base (
      newrec_              IN OUT NOCOPY inventory_part_tab%ROWTYPE,
      lock_mode_wait_      IN     BOOLEAN DEFAULT TRUE,
      updated_by_client_   IN     BOOLEAN DEFAULT FALSE )
   IS
      objid_      VARCHAR2(20);
      objversion_ VARCHAR2(100);
      attr_       VARCHAR2(32000);
      indrec_     Indicator_rec;
      oldrec_     inventory_part_tab%ROWTYPE;
   BEGIN
      IF (lock_mode_wait_) THEN
         oldrec_ := Lock_By_Keys___(newrec_.contract, newrec_.part_no);
      ELSE
         oldrec_ := Lock_By_Keys_Nowait___(newrec_.contract, newrec_.part_no);
      END IF;
      indrec_ := Get_Indicator_Rec___(oldrec_, newrec_);
      Check_Update___(oldrec_, newrec_, indrec_, attr_);
      Update___(objid_, oldrec_, newrec_, attr_, objversion_, TRUE);
   END Base;

   PROCEDURE Core (
      newrec_              IN OUT NOCOPY inventory_part_tab%ROWTYPE,
      lock_mode_wait_      IN     BOOLEAN DEFAULT TRUE,
      updated_by_client_   IN     BOOLEAN DEFAULT FALSE )
   IS
      objid_      inventory_part.objid%TYPE;
      objversion_ inventory_part.objversion%TYPE;
      attr_       VARCHAR2(2000);
      indrec_     Indicator_rec;
      oldrec_     inventory_part_tab%ROWTYPE;
   BEGIN
      IF (updated_by_client_) THEN
         Base(newrec_, lock_mode_wait_);
      ELSE
         IF (lock_mode_wait_) THEN
            oldrec_ := Lock_By_Keys___(newrec_.contract, newrec_.part_no);
         ELSE
            oldrec_ := Lock_By_Keys_Nowait___(newrec_.contract, newrec_.part_no);
         END IF;
         indrec_ := Get_Indicator_Rec___(oldrec_, newrec_);
         Check_Update___(oldrec_, newrec_, indrec_, attr_, FALSE);
         Update___(objid_, oldrec_, newrec_, attr_, objversion_, TRUE); -- Update by keys
      END IF;
   END Core;

BEGIN
   Core(newrec_, lock_mode_wait_, updated_by_client_);
END Modify___;


PROCEDURE Check_Delete___ (
   remrec_ IN inventory_part_tab%ROWTYPE )
IS
   
   PROCEDURE Base (
      remrec_ IN inventory_part_tab%ROWTYPE )
   IS
      key_ VARCHAR2(2000);
   BEGIN
      key_ := remrec_.contract||'^'||remrec_.part_no||'^';
      Reference_SYS.Check_Restricted_Delete(lu_name_, key_);
   END Base;

   PROCEDURE Core (
      remrec_ IN inventory_part_tab%ROWTYPE )
   IS
      part_exist_in_demand_site_ NUMBER := 0;
   
   BEGIN
      IF (INSTR(remrec_.part_no, '^') > 0) OR (INSTR(remrec_.contract, '^') > 0) THEN
         Error_Sys.Record_General(lu_name_, 'INVALIDCHAR: Caret symbol is used in part no :P1 and/or on site :P2. Removal is not permitted.', remrec_.part_no, remrec_.contract);
      END IF;
      -- EBALL-37, Modified method call to use the fully encapsulated method from Invent_Part_Quantity_Util_API.
      IF (Invent_Part_Quantity_Util_API.Check_Quantity_Exist(remrec_.contract,
                                                             remrec_.part_no,
                                                             NULL)) THEN
         Error_Sys.Record_General(lu_name_, 'NOCOSTDEL: There are quantities in inventory for this part. Removal is not permitted');
      END IF;
      
      $IF (Component_Purch_SYS.INSTALLED) $THEN
         IF (Purchase_Part_Supplier_API.Is_Part_In_Demand_Site(remrec_.contract, remrec_.part_no, Supplier_API.Get_Vendor_No_From_Contract(remrec_.contract))  = 'TRUE') THEN
             part_exist_in_demand_site_ := 1;
         END IF;
         IF (part_exist_in_demand_site_ = 1)THEN
            Error_SYS.Record_General(lu_name_, 'NOPARTDEL: Inventory Part cannot be removed, Mult-site Planned Part exists in demand site(s)');
         END IF;
      $END
   
      $IF (Component_Callc_SYS.INSTALLED) $THEN
         Cc_Case_Business_Object_API.Check_Reference_Exist('INVENTORY_PART', remrec_.part_no, remrec_.contract );
         Cc_Case_Sol_Business_Obj_API.Check_Reference_Exist('INVENTORY_PART', remrec_.part_no, remrec_.contract );
      $END
      
      Base(remrec_);
   END Core;

BEGIN
   Core(remrec_);
END Check_Delete___;


PROCEDURE Delete___ (
   objid_  IN VARCHAR2,
   remrec_ IN inventory_part_tab%ROWTYPE )
IS
   
   PROCEDURE Base (
      objid_  IN VARCHAR2,
      remrec_ IN inventory_part_tab%ROWTYPE )
   IS
      key_ VARCHAR2(2000);
   BEGIN
      key_ := remrec_.contract||'^'||remrec_.part_no||'^';
      Reference_SYS.Do_Cascade_Delete(lu_name_, key_);
      IF (objid_ IS NOT NULL) THEN
         DELETE
            FROM  inventory_part_tab
            WHERE rowid = objid_;
      ELSE
         DELETE
            FROM  inventory_part_tab
            WHERE contract = remrec_.contract
            AND   part_no = remrec_.part_no;
      END IF;
      Invalidate_Cache___;
   END Base;

   PROCEDURE Core (
      objid_  IN VARCHAR2,
      remrec_ IN inventory_part_tab%ROWTYPE )
   IS
   BEGIN
      $IF (Component_Purch_SYS.INSTALLED) $THEN
         IF Purchase_Part_API.Check_Exist(remrec_.contract, remrec_.part_no) = 1 THEN
            Purchase_Part_API.Remove(remrec_.contract, remrec_.part_no);
         END IF;
      $END  
     
      Base(objid_, remrec_);
   
      Document_Text_API.Remove_Note(remrec_.note_id);
   
      -- Update Chemmate
      IF (Part_Catalog_Invent_Attrib_API.Get_Hse_Contract(remrec_.part_no) = remrec_.contract) THEN
         Pack_And_Post_Message__('DELETE', remrec_.part_no, remrec_.contract);
      END IF;
      
      $IF (Component_Quaman_SYS.INSTALLED) $THEN
         Qman_Mandatory_Part_API.Remove_From_Invent(remrec_.part_no, remrec_.contract, remrec_.type_code);
      $END      
   END Core;

BEGIN
   Core(objid_, remrec_);
END Delete___;


PROCEDURE Raise_Inv_Part_Not_Exist___ (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_Not_Exist(lu_name_,'NOTEXIST: Inventory part :P1 does not exist on site :P2.', part_no_, contract_);
END Raise_Inv_Part_Not_Exist___;


PROCEDURE Raise_Part_Not_Exist___ (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General(lu_name_, 'CONV_ERR_PART_MISS: Part :P1 does not exist on site :P2.', part_no_, contract_);
END Raise_Part_Not_Exist___;


PROCEDURE Raise_Lot_Bat_Cost_Lvl_Error___ (
   newrec_   IN inventory_part_tab%ROWTYPE )
IS
BEGIN
   Error_SYS.Record_General(lu_name_,'LOTBATCOSLEV: Part Cost Level :P1 is only allowed for Lot Tracked Parts.',Inventory_Part_Cost_Level_API.Decode(newrec_.inventory_part_cost_level));
END Raise_Lot_Bat_Cost_Lvl_Error___;


PROCEDURE Raise_Position_Part_Type_Error___
IS
BEGIN
   Error_SYS.Record_General(lu_name_, 'POSITIONPART: Position parts can only have part type :P1.', Inventory_Part_Type_API.Decode('1'));
END Raise_Position_Part_Type_Error___;


PROCEDURE Raise_Input_Uom_Error___
IS
BEGIN
   Error_SYS.Record_General(lu_name_,'NOINPUTUOM: The Inventory UoM of Input UoM Group must be equal to Inventory Part U/M.');
END Raise_Input_Uom_Error___;


PROCEDURE Validate_Lead_Time_Code___ (
   lead_time_code_ OUT VARCHAR2,
   contract_       IN  VARCHAR2,
   part_no_        IN  VARCHAR2,
   type_code_      IN  VARCHAR2,
   old_type_code_  IN  VARCHAR2 )
IS
   exist_ NUMBER;
BEGIN
   IF (type_code_ IN ('1', '2')) THEN
      lead_time_code_ := 'M';   
   ELSIF (type_code_ IN ('3', '6')) THEN
      IF ((old_type_code_ IS NOT NULL AND old_type_code_ != type_code_ ) OR (old_type_code_ IS NULL ))THEN
         $IF (Component_Mfgstd_SYS.INSTALLED) $THEN
            exist_ := Manuf_Structure_Util_API.Part_Is_A_Product_Head(part_no_, contract_);  
            IF (exist_ = 1) THEN
               Error_SYS.Record_General(lu_name_, 'PARENT_NOT_3: The parent part cannot be of type :P1 when there exists routing head and structure head.', Inventory_Part_Type_API.Decode(type_code_));
            END IF;
         $ELSE
            NULL;
            -- Manufacturing component not installed.
         $END
      END IF;
      lead_time_code_ := 'P';
   ELSIF (type_code_ = '4') THEN
      lead_time_code_ := 'P';
   ELSE
      Error_SYS.Record_General(lu_name_, 'INVALID_PART_TYPE: Invalid part type. Enter 1 or 2 or 3 or 4 or 6.');
   END IF;
END Validate_Lead_Time_Code___;


PROCEDURE Check_Unit_Meas___ (
  contract_                      IN VARCHAR2,
  part_no_                       IN VARCHAR2,
  unit_meas_                     IN VARCHAR2,
  catch_unit_meas_               IN VARCHAR2,
  receipt_issue_serial_track_db_ IN VARCHAR2,
  catch_unit_enabled_            IN VARCHAR2 )
IS
   part_unit_meas_        VARCHAR2(10);
    part_catch_unit_meas_  VARCHAR2(30);
    
    CURSOR get_part_uom IS
      SELECT unit_meas
      FROM   inventory_part_tab
      WHERE  part_no    = part_no_
      AND    contract  != contract_
      AND    unit_meas != unit_meas_;

    CURSOR get_catch_uom IS
      SELECT catch_unit_meas
      FROM   inventory_part_tab
      WHERE  part_no    = part_no_
      AND    contract  != contract_
      AND    catch_unit_meas != catch_unit_meas_;
BEGIN
   OPEN get_part_uom;
   FETCH get_part_uom INTO part_unit_meas_;

   IF (get_part_uom%FOUND) THEN

      IF (Iso_Unit_API.Get_Base_Unit(unit_meas_) != Iso_Unit_API.Get_Base_Unit(part_unit_meas_)) THEN
         CLOSE get_part_uom;
         Error_SYS.Record_General(lu_name_, 'BASEUNITDIFF: The base unit :P1 for U/M :P2 is different from the base unit for this part on another site.', Iso_Unit_API.Get_Base_Unit(unit_meas_), unit_meas_ );
      ELSE
         IF (receipt_issue_serial_track_db_ = Fnd_Boolean_API.db_true) THEN
            IF Unit_Meas_Different_On_Sites(part_no_, unit_meas_) THEN
               Error_SYS.Record_General(lu_name_, 'CONVFACTOR: A part that is serial tracked cannot have different U/M in different sites.');
            END IF;
         END IF;
      END IF;
   END IF;
   CLOSE get_part_uom;

   IF catch_unit_meas_ IS NOT NULL THEN
      OPEN get_catch_uom;
      FETCH get_catch_uom INTO part_catch_unit_meas_;

      IF (get_catch_uom%FOUND) THEN
         IF (Iso_Unit_API.Get_Base_Unit(catch_unit_meas_) != Iso_Unit_API.Get_Base_Unit(part_catch_unit_meas_)) THEN
            CLOSE get_catch_uom;
            Error_SYS.Record_General(lu_name_, 'BASCATUNIT: The base unit :P1 for catch U/M :P2 is different from the base unit for this part on another site.', Iso_Unit_API.Get_Base_Unit(catch_unit_meas_), catch_unit_meas_ );
         END IF;
      END IF;
      CLOSE get_catch_uom;
      IF (catch_unit_enabled_ = 'TRUE') THEN
         $IF (Component_Order_SYS.INSTALLED) $THEN
            Sales_Part_API.Check_Enable_Catch_Unit(contract_, part_no_, catch_unit_meas_);
         $ELSE
            NULL;
         $END            
      END IF;
   ELSE
      IF (catch_unit_enabled_ = 'TRUE') THEN
         Error_SYS.Record_General(lu_name_, 'MANCATCH: The Catch UoM has to be entered when the Catch Unit functionality is enabled in Part Catalog.');
      END IF;
   END IF;
END Check_Unit_Meas___;


PROCEDURE Copy_Impl___ (
   new_contract_             IN VARCHAR2,
   new_part_no_              IN VARCHAR2,
   old_contract_             IN VARCHAR2,
   old_part_no_              IN VARCHAR2,
   attr_                     IN VARCHAR2,
   error_when_no_source_     IN VARCHAR2,
   error_when_existing_copy_ IN VARCHAR2,
   create_purchase_part_     IN VARCHAR2 )
IS
   oldrec_                  inventory_part_tab%ROWTYPE;
   estimated_material_cost_ NUMBER;
   exit_procedure           EXCEPTION;
   part_cost_group_id_      inventory_part_tab.part_cost_group_id%TYPE := NULL;
   part_rec_                Inventory_Part_API.Public_Rec;
   to_storage_width_requirement_    inventory_part_tab.storage_width_requirement%TYPE;
   to_storage_height_requirement_   inventory_part_tab.storage_height_requirement%TYPE;
   to_storage_depth_requirement_    inventory_part_tab.storage_depth_requirement%TYPE;
   to_storage_volume_requirement_   inventory_part_tab.storage_volume_requirement%TYPE;
   to_storage_weight_requirement_   inventory_part_tab.storage_weight_requirement%TYPE;
   to_min_storage_temperature_      inventory_part_tab.min_storage_temperature%TYPE;
   to_max_storage_temperature_      inventory_part_tab.max_storage_temperature%TYPE;
   to_min_storage_humidity_         inventory_part_tab.min_storage_humidity%TYPE;
   to_max_storage_humidity_         inventory_part_tab.max_storage_humidity%TYPE;

   CURSOR get_oldrec IS
      SELECT *
      FROM   inventory_part_tab
      WHERE  contract = old_contract_
      AND    part_no  = old_part_no_;
BEGIN
   OPEN get_oldrec;
   FETCH get_oldrec INTO oldrec_;
   IF (get_oldrec%NOTFOUND) THEN
      CLOSE get_oldrec;
      IF (error_when_no_source_ = 'TRUE') THEN
         Raise_Inv_Part_Not_Exist___(old_part_no_, old_contract_);
      ELSE
         RAISE exit_procedure;
      END IF;
   ELSE
      CLOSE get_oldrec;
   END IF;
   IF (error_when_existing_copy_ = 'FALSE') THEN
      IF (Check_Exist___(new_contract_, new_part_no_)) THEN
         RAISE exit_procedure;
      END IF;
   END IF;
   Overwrite_Record_With_Attr___ (oldrec_, attr_);
   estimated_material_cost_ := Inventory_Part_Config_API.Get_Estimated_Material_Cost(old_contract_,
                                                                                     old_part_no_,
                                                                                     '*');
   estimated_material_cost_ := Site_API.Get_Currency_Converted_Amount(old_contract_,
                                                                      new_contract_,
                                                                      estimated_material_cost_);

   IF (new_contract_ = old_contract_) THEN
      part_cost_group_id_ := oldrec_.part_cost_group_id;
   ELSE
      Convert_Storage_Req_Uom___(to_storage_width_requirement_,
                                 to_storage_height_requirement_,
                                 to_storage_depth_requirement_,
                                 to_storage_volume_requirement_,
                                 to_storage_weight_requirement_,
                                 to_min_storage_temperature_,
                                 to_max_storage_temperature_,
                                 to_min_storage_humidity_,
                                 to_max_storage_humidity_,
                                 oldrec_,
                                 new_contract_);
   END IF;

   IF (Inventory_Part_Planner_API.Get_Objstate(oldrec_.planner_buyer) = 'Blocked') THEN
      oldrec_.planner_buyer := User_Default_API.Get_Planner_Id(Fnd_Session_API.Get_Fnd_User);
   END IF;
   -- gelr: good_service_statistical_code, acquisition_origin and  brazilian_specific_attributes added.
   New_Part(contract_                      => new_contract_ ,
            part_no_                       => new_part_no_ ,
            accounting_group_              => oldrec_.accounting_group ,
            asset_class_                   => oldrec_.asset_class ,
            country_of_origin_             => oldrec_.country_of_origin ,
            hazard_code_                   => oldrec_.hazard_code ,
            part_product_code_             => oldrec_.part_product_code ,
            part_product_family_           => oldrec_.part_product_family ,
            part_status_                   => oldrec_.part_status ,
            planner_buyer_                 => oldrec_.planner_buyer ,
            prime_commodity_               => oldrec_.prime_commodity ,
            second_commodity_              => oldrec_.second_commodity ,
            unit_meas_                     => oldrec_.unit_meas ,
            description_                   => oldrec_.description ,
            abc_class_                     => NULL ,
            count_variance_                => NULL ,
            create_date_                   => NULL ,
            cycle_code_                    => Inventory_Part_Count_Type_API.Decode(oldrec_.cycle_code) ,
            cycle_period_                  => oldrec_.cycle_period ,
            dim_quality_                   => oldrec_.dim_quality ,
            durability_day_                => oldrec_.durability_day ,
            expected_leadtime_             => oldrec_.expected_leadtime ,
            inactive_obs_flag_             => NULL ,
            last_activity_date_            => NULL ,
            lead_time_code_                => Inv_Part_Lead_Time_Code_API.Decode(oldrec_.lead_time_code) ,
            manuf_leadtime_                => oldrec_.manuf_leadtime ,
            note_text_                     => oldrec_.note_text ,
            oe_alloc_assign_flag_          => Cust_Ord_Reservation_Type_API.Decode(oldrec_.oe_alloc_assign_flag) ,
            onhand_analysis_flag_          => Inventory_Part_Onh_Analys_API.Decode(oldrec_.onhand_analysis_flag) ,
            purch_leadtime_                => oldrec_.purch_leadtime ,
            supersedes_                    => NULL ,
            supply_code_                   => Material_Requis_Supply_API.Decode(oldrec_.supply_code) ,
            type_code_                     => Inventory_Part_Type_API.Decode(oldrec_.type_code) ,
            customs_stat_no_               => oldrec_.customs_stat_no ,
            type_designation_              => oldrec_.type_designation ,
            zero_cost_flag_                => Inventory_Part_Zero_Cost_API.Decode(oldrec_.zero_cost_flag) ,
            avail_activity_status_         => NULL ,
            eng_attribute_                 => NULL ,
            forecast_consumption_flag_     => Inv_Part_Forecast_Consum_API.Decode(oldrec_.forecast_consumption_flag),
            intrastat_conv_factor_         => oldrec_.intrastat_conv_factor,
            invoice_consideration_         => Invoice_Consideration_API.Decode(oldrec_.invoice_consideration),
            max_actual_cost_update_        => oldrec_.max_actual_cost_update,
            shortage_flag_                 => Inventory_Part_Shortage_API.Decode(oldrec_.shortage_flag),
            inventory_part_cost_level_     => Inventory_Part_Cost_Level_API.Decode(oldrec_.inventory_part_cost_level),
            std_name_id_                   => oldrec_.std_name_id,
            input_unit_meas_group_id_      => oldrec_.input_unit_meas_group_id,
            dop_connection_                => Dop_Connection_API.Decode(oldrec_.dop_connection),
            supply_chain_part_group_       => oldrec_.supply_chain_part_group,
            ext_service_cost_method_       => Ext_Service_Cost_Method_API.Decode(oldrec_.ext_service_cost_method),
            stock_management_              => Inventory_Part_Management_API.Decode(oldrec_.stock_management),
            technical_coordinator_id_      => oldrec_.technical_coordinator_id,
            sup_warranty_id_               => oldrec_.sup_warranty_id,
            cust_warranty_id_              => oldrec_.cust_warranty_id,
            estimated_material_cost_       => estimated_material_cost_,
            automatic_capability_check_    => Capability_Check_Allocate_API.Decode(oldrec_.automatic_capability_check),
            create_purchase_part_          => create_purchase_part_,
            inventory_valuation_method_    => Inventory_Value_Method_API.Decode(oldrec_.inventory_valuation_method),
            negative_on_hand_              => Negative_On_Hand_API.Decode(oldrec_.negative_on_hand),
            create_part_planning_          => 'TRUE',
            catch_unit_meas_               => oldrec_.catch_unit_meas,
            part_cost_group_id_            => part_cost_group_id_,
            qty_calc_rounding_             => oldrec_.qty_calc_rounding,
            min_durab_days_co_deliv_       => oldrec_.min_durab_days_co_deliv,
            min_durab_days_planning_       => oldrec_.min_durab_days_planning,
            storage_width_requirement_     => to_storage_width_requirement_,
            storage_height_requirement_    => to_storage_height_requirement_,
            storage_depth_requirement_     => to_storage_depth_requirement_,
            storage_volume_requirement_    => to_storage_volume_requirement_,
            storage_weight_requirement_    => to_storage_weight_requirement_,
            min_storage_temperature_       => to_min_storage_temperature_,
            max_storage_temperature_       => to_max_storage_temperature_,
            min_storage_humidity_          => to_min_storage_humidity_,
            max_storage_humidity_          => to_max_storage_humidity_,
            standard_putaway_qty_          => oldrec_.standard_putaway_qty,
            putaway_zone_refill_option_    => Putaway_Zone_Refill_Option_API.Decode(oldrec_.putaway_zone_refill_option),
            dop_netting_db_                => oldrec_.dop_netting,
            reset_config_std_cost_db_      => oldrec_.reset_config_std_cost,
            co_reserve_onh_analys_flag_db_ => oldrec_.co_reserve_onh_analys_flag,
            mandatory_expiration_date_db_  => oldrec_.mandatory_expiration_date,
            statistical_code_              => oldrec_.statistical_code,
            acquisition_origin_            => oldrec_.acquisition_origin,
            acquisition_reason_id_         => oldrec_.acquisition_reason_id);            
   part_rec_ := Get(new_contract_, new_part_no_);
   -- Copy inventory part connected custom fields values.
   Custom_Objects_SYS.Copy_Cf_Instance(lu_name_, oldrec_.rowkey, part_rec_.rowkey);
EXCEPTION
   WHEN exit_procedure THEN
      NULL;
END Copy_Impl___;


PROCEDURE Convert_Storage_Req_Uom___(
   to_storage_width_requirement_    OUT NUMBER,
   to_storage_height_requirement_   OUT NUMBER,
   to_storage_depth_requirement_    OUT NUMBER,
   to_storage_volume_requirement_   OUT NUMBER,
   to_storage_weight_requirement_   OUT NUMBER,
   to_min_storage_temperature_      OUT NUMBER,
   to_max_storage_temperature_      OUT NUMBER,
   to_min_storage_humidity_         OUT NUMBER,
   to_max_storage_humidity_         OUT NUMBER,
   from_rec_                        IN  inventory_part_tab%ROWTYPE,
   to_contract_                     IN  VARCHAR2)
IS
   from_company_            VARCHAR2(20);
   to_company_              VARCHAR2(20);
   to_company_invent_rec_   Company_Invent_Info_API.Public_Rec;
   from_company_invent_rec_ Company_Invent_Info_API.Public_Rec;
BEGIN
   from_company_ := Site_API.Get_Company(from_rec_.contract);
   to_company_   := Site_API.Get_Company(to_contract_);
   IF (from_company_ != to_company_) THEN
      from_company_invent_rec_ := Company_Invent_Info_API.Get(from_company_);
      to_company_invent_rec_   := Company_Invent_Info_API.Get(to_company_);

      IF(from_rec_.storage_width_requirement IS NOT NULL OR from_rec_.storage_height_requirement IS NOT NULL OR from_rec_.storage_depth_requirement IS NOT NULL) THEN
         IF (from_company_invent_rec_.uom_for_length != to_company_invent_rec_.uom_for_length) THEN
            IF (from_rec_.storage_width_requirement IS NOT NULL) THEN
               to_storage_width_requirement_ := Iso_Unit_API.Get_Unit_Converted_Quantity( from_rec_.storage_width_requirement,
                                                                                          from_company_invent_rec_.uom_for_length,
                                                                                          to_company_invent_rec_.uom_for_length);
            END IF;
            IF (from_rec_.storage_height_requirement IS NOT NULL) THEN
               to_storage_height_requirement_ := Iso_Unit_API.Get_Unit_Converted_Quantity( from_rec_.storage_height_requirement,
                                                                                           from_company_invent_rec_.uom_for_length,
                                                                                           to_company_invent_rec_.uom_for_length);
            END IF;
            IF (from_rec_.storage_depth_requirement IS NOT NULL) THEN
               to_storage_depth_requirement_ := Iso_Unit_API.Get_Unit_Converted_Quantity( from_rec_.storage_depth_requirement,
                                                                                          from_company_invent_rec_.uom_for_length,
                                                                                          to_company_invent_rec_.uom_for_length);
            END IF;
         ELSE
            to_storage_width_requirement_    := from_rec_.storage_width_requirement;
            to_storage_height_requirement_   := from_rec_.storage_height_requirement;
            to_storage_depth_requirement_    := from_rec_.storage_depth_requirement;
         END IF;
      END IF;
      
      IF(from_rec_.storage_volume_requirement IS NOT NULL) THEN
         IF (from_company_invent_rec_.uom_for_volume != to_company_invent_rec_.uom_for_volume) THEN
            to_storage_volume_requirement_ := Iso_Unit_API.Get_Unit_Converted_Quantity( from_rec_.storage_volume_requirement,
                                                                                        from_company_invent_rec_.uom_for_volume,
                                                                                        to_company_invent_rec_.uom_for_volume);
         ELSE
            to_storage_volume_requirement_ := from_rec_.storage_volume_requirement;
         END IF;
      END IF;
      
      IF(from_rec_.storage_weight_requirement IS NOT NULL) THEN
         IF (from_company_invent_rec_.uom_for_weight != to_company_invent_rec_.uom_for_weight) THEN
            to_storage_weight_requirement_ := Iso_Unit_API.Get_Unit_Converted_Quantity( from_rec_.storage_weight_requirement,
                                                                                        from_company_invent_rec_.uom_for_weight,
                                                                                        to_company_invent_rec_.uom_for_weight);
         ELSE
            to_storage_weight_requirement_ := from_rec_.storage_weight_requirement;
         END IF;
      END IF;
      
      IF (from_rec_.min_storage_temperature IS NOT NULL OR from_rec_.max_storage_temperature IS NOT NULL) THEN
         IF (from_company_invent_rec_.uom_for_temperature != to_company_invent_rec_.uom_for_temperature) THEN
            IF (from_rec_.min_storage_temperature IS NOT NULL) THEN
               to_min_storage_temperature_ := Iso_Unit_API.Get_Unit_Converted_Quantity( from_rec_.min_storage_temperature,
                                                                                        from_company_invent_rec_.uom_for_temperature,
                                                                                        to_company_invent_rec_.uom_for_temperature);
            END IF;
            IF (from_rec_.max_storage_temperature IS NOT NULL) THEN
               to_max_storage_temperature_ := Iso_Unit_API.Get_Unit_Converted_Quantity( from_rec_.max_storage_temperature,
                                                                                        from_company_invent_rec_.uom_for_temperature,
                                                                                        to_company_invent_rec_.uom_for_temperature);
            END IF;
         ELSE
            to_min_storage_temperature_ := from_rec_.min_storage_temperature;
            to_max_storage_temperature_ := from_rec_.max_storage_temperature;
         END IF;
      END IF;

      to_min_storage_humidity_ := from_rec_.min_storage_humidity;
      to_max_storage_humidity_ := from_rec_.max_storage_humidity;
   END IF;
END Convert_Storage_Req_Uom___;


PROCEDURE Check_Value_Method_Combinat___ (
   newrec_                        IN inventory_part_tab%ROWTYPE,
   configurable_db_               IN VARCHAR2,
   condition_code_usage_db_       IN VARCHAR2,
   lot_tracking_code_db_          IN VARCHAR2,
   serial_tracking_code_db_       IN VARCHAR2,
   receipt_issue_serial_track_db_ IN VARCHAR2 )
IS
BEGIN
   IF (newrec_.inventory_valuation_method = 'ST') THEN
--    **********************************************
--    *                                            *
--    *      The "Standard Cost" section           *
--    *                                            *
--    **********************************************
      IF (configurable_db_ = 'CONFIGURED') THEN
         IF (newrec_.inventory_part_cost_level NOT IN ('COST PER CONFIGURATION',
                                                       'COST PER PART',
                                                       'COST PER SERIAL')) THEN
            Error_SYS.Record_General(lu_name_,'STCONFLEVERR: Part Cost Level :P1 is not allowed for Configured Parts.',Inventory_Part_Cost_Level_API.Decode(newrec_.inventory_part_cost_level));
         END IF;
      ELSE
         IF (newrec_.inventory_part_cost_level = 'COST PER CONFIGURATION') THEN
            Error_SYS.Record_General(lu_name_,'STCONFCOSLEV: Part Cost Level :P1 is only allowed for Configured Parts.',Inventory_Part_Cost_Level_API.Decode(newrec_.inventory_part_cost_level));
         END IF;
      END IF;
      IF ((condition_code_usage_db_ != 'ALLOW_COND_CODE') AND
          (newrec_.inventory_part_cost_level = 'COST PER CONDITION')) THEN
            Error_SYS.Record_General(lu_name_, 'CONDCOSTLEV: Cost Level :P1 is only allowed for Condition Code enabled parts.',Inventory_Part_Cost_Level_API.Decode(newrec_.inventory_part_cost_level));
      END IF;
      IF ((serial_tracking_code_db_ = Part_Serial_Tracking_API.db_not_serial_tracking)  AND
          (newrec_.inventory_part_cost_level = 'COST PER SERIAL')) THEN
         Error_SYS.Record_General(lu_name_,'SERIALCOSLEV: Part Cost Level :P1 is only allowed for parts that use the serial tracking option of ''In Inventory''.',Inventory_Part_Cost_Level_API.Decode(newrec_.inventory_part_cost_level));
      END IF;
      IF (newrec_.inventory_part_cost_level = Inventory_Part_Cost_Level_API.db_cost_per_lot_batch) THEN
         IF (lot_tracking_code_db_ = Part_Lot_Tracking_API.db_not_lot_tracking) THEN
            Raise_Lot_Bat_Cost_Lvl_Error___(newrec_);
         ELSE
            IF ((serial_tracking_code_db_       = Part_Serial_Tracking_API.db_not_serial_tracking) AND 
                (receipt_issue_serial_track_db_ = Fnd_Boolean_API.db_true)) THEN
               Error_SYS.Record_General(lu_name_,'STLOTBATCOSSER: Part Cost Level :P1 can only be used on a serial tracked part if it uses the serial tracking option of ''In Inventory''.',Inventory_Part_Cost_Level_API.Decode(newrec_.inventory_part_cost_level));
            END IF;
         END IF;
      END IF;
      IF (newrec_.invoice_consideration = 'PERIODIC WEIGHTED AVERAGE') THEN
         IF (configurable_db_ = 'CONFIGURED') THEN
            IF (newrec_.zero_cost_flag = 'N') THEN
               Error_SYS.Record_General(lu_name_,'CONFIGACTUAL: Zero Cost must be allowed when using :P1 for a Configured part.',Invoice_Consideration_API.Decode(newrec_.invoice_consideration));
            END IF;
            IF (newrec_.inventory_part_cost_level != 'COST PER CONFIGURATION') THEN
               Error_SYS.Record_General(lu_name_,'CONFIGCOST: :P2 on configured parts is only allowed for part cost level :P1.',Inventory_Part_Cost_Level_API.Decode('COST PER CONFIGURATION'), Invoice_Consideration_API.Decode(newrec_.invoice_consideration));
            END IF;
         ELSE
            IF (newrec_.inventory_part_cost_level != 'COST PER PART') THEN
               Error_SYS.Record_General(lu_name_,'NOCONFIGCOST: :P2 is only allowed for part cost level :P1.',Inventory_Part_Cost_Level_API.Decode('COST PER PART'), Invoice_Consideration_API.Decode(newrec_.invoice_consideration));
            END IF;
         END IF;
         IF (newrec_.zero_cost_flag = 'O') THEN
            Error_SYS.Record_General(lu_name_,'ZEROCOST: :P2 needs to be able to alter the cost. Therefore :P1 is not allowed.',Inventory_Part_Zero_Cost_API.Decode(newrec_.zero_cost_flag), Invoice_Consideration_API.Decode(newrec_.invoice_consideration));
         END IF;
      END IF;
      IF (newrec_.invoice_consideration ='TRANSACTION BASED') THEN
         IF (newrec_.inventory_part_cost_level != 'COST PER SERIAL') THEN
            Error_SYS.Record_General(lu_name_,'STTRANBSER: Supplier invoice consideration :P1 in combination with inventory valuation method :P2 is only allowed for part cost level :P3 ',Invoice_Consideration_API.Decode(newrec_.invoice_consideration),Inventory_Value_Method_API.Decode(newrec_.inventory_valuation_method),Inventory_Part_Cost_Level_API.Decode('COST PER SERIAL'));
         END IF;
      END IF;
      IF (newrec_.ext_service_cost_method = 'INCLUDE SERVICE COST') THEN
         IF (newrec_.inventory_part_cost_level != 'COST PER SERIAL') THEN
            Error_SYS.Record_General(lu_name_,'SERVICECOST: This combination of External Service Cost Method and the Inventory Valuation Method can only be used with Inventory Part Cost Level :P1.' ,Inventory_Part_Cost_Level_API.Decode('COST PER SERIAL'));
         END IF;
      END IF;
--    ******  End of the "Standard Cost" section  ******

   ELSIF (newrec_.inventory_valuation_method = 'AV') THEN
--    ***************************************************
--    *                                                 *
--    *  The "Weighted Average Purchase Price" section  *
--    *                                                 *
--    ***************************************************
      IF ((newrec_.negative_on_hand = 'NEG ONHAND OK')) THEN
         Error_SYS.Record_General(lu_name_, 'NEGQTYONHAND: Negative quantity onhand is not allowed for :P1 valuation method.',Inventory_Value_Method_API.Decode(newrec_.inventory_valuation_method));
      END IF;
      IF (newrec_.inventory_part_cost_level NOT IN ('COST PER PART',
                                                    'COST PER CONFIGURATION',
                                                    'COST PER CONDITION',
                                                    'COST PER LOT BATCH')) THEN
         Error_SYS.Record_General(lu_name_, 'AVGCOSTLEVEL: Cost Level :P1 is not allowed in combination with Inventory Valuation Method :P2.',Inventory_Part_Cost_Level_API.Decode(newrec_.inventory_part_cost_level),Inventory_Value_Method_API.Decode(newrec_.inventory_valuation_method));
      END IF;
      IF (newrec_.inventory_part_cost_level = Inventory_Part_Cost_Level_API.db_cost_per_lot_batch) THEN
         IF (lot_tracking_code_db_ = Part_Lot_Tracking_API.db_not_lot_tracking) THEN
            Raise_Lot_Bat_Cost_Lvl_Error___(newrec_);
         ELSE
            IF ((serial_tracking_code_db_       = Part_Serial_Tracking_API.db_not_serial_tracking) AND 
                (receipt_issue_serial_track_db_ = Fnd_Boolean_API.db_true)) THEN
               Error_SYS.Record_General(lu_name_,'AVLOTBATCOSSER: Part Cost Level :P1 can be used on a serial tracked part only if it is serial tracked in inventory.',Inventory_Part_Cost_Level_API.Decode(newrec_.inventory_part_cost_level));
            END IF;
         END IF;
      END IF;
      IF ((condition_code_usage_db_ != 'ALLOW_COND_CODE') AND
          (newrec_.inventory_part_cost_level = 'COST PER CONDITION')) THEN
            Error_SYS.Record_General(lu_name_, 'CONDCOSTLEV: Cost Level :P1 is only allowed for Condition Code enabled parts.',Inventory_Part_Cost_Level_API.Decode(newrec_.inventory_part_cost_level));
      END IF;
      IF (configurable_db_ = 'CONFIGURED') THEN
         IF (newrec_.inventory_part_cost_level NOT IN ('COST PER CONFIGURATION', 'COST PER LOT BATCH')) THEN
            Error_SYS.Record_General(lu_name_, 'AVCONFCOLEV: For a Configured part Inventory Valution Method :P1 is only allowed on Cost Level :P2.',Inventory_Value_Method_API.Decode(newrec_.inventory_valuation_method),Inventory_Part_Cost_Level_API.Decode('COST PER CONFIGURATION'));
         END IF;
         IF (newrec_.invoice_consideration ='TRANSACTION BASED') THEN
            Error_SYS.Record_General(lu_name_, 'WATRNOCOCOPA: :P1 invoice consideration in combination with inventory valuation method :P2 is not allowed for configured parts.', Invoice_Consideration_API.Decode(newrec_.invoice_consideration), Inventory_Value_Method_API.Decode(newrec_.inventory_valuation_method));
         END IF;
      ELSE
         IF (newrec_.inventory_part_cost_level NOT IN ('COST PER PART',
                                                       'COST PER CONDITION',
                                                       'COST PER LOT BATCH')) THEN
            Error_SYS.Record_General(lu_name_, 'AVNOCOCOLEV: Inventory Valution Method :P1 is only allowed on Cost Levels :P2 and :P3.',Inventory_Value_Method_API.Decode(newrec_.inventory_valuation_method),Inventory_Part_Cost_Level_API.Decode('COST PER PART'),Inventory_Part_Cost_Level_API.Decode('COST PER CONDITION'));
         END IF;
      END IF;
      IF (newrec_.invoice_consideration ='PERIODIC WEIGHTED AVERAGE') THEN
         Error_SYS.Record_General(lu_name_,'NOSTACTCST: :P2 is only allowed with inventory valuation method :P1.',Inventory_Value_Method_API.Decode('ST'),Invoice_Consideration_API.Decode(newrec_.invoice_consideration));
      END IF;
      IF (newrec_.negative_on_hand = 'NEG ONHAND NOT OK') AND
         (newrec_.zero_cost_flag = 'O') THEN
         Error_SYS.Record_General(lu_name_, 'ZEROCOSTONLY: Zero Cost Only can only be used together with Inventory Valuaton Method Standard Cost.');
      END IF;
--    ******  End of the "Weighted Average Purchase Price" section  ******

   ELSIF (newrec_.inventory_valuation_method IN ('FIFO','LIFO')) THEN
--    **********************************************
--    *                                            *
--    *      The "FIFO and LIFO" section           *
--    *                                            *
--    **********************************************
      IF ((newrec_.negative_on_hand = 'NEG ONHAND OK')) THEN
         Error_SYS.Record_General(lu_name_, 'NEGQTYONHAND: Negative quantity onhand is not allowed for :P1 valuation method.',Inventory_Value_Method_API.Decode(newrec_.inventory_valuation_method));
      END IF;
      IF (newrec_.inventory_part_cost_level != 'COST PER PART') THEN
         Error_SYS.Record_General(lu_name_,'FIFOCOSTLEV: :P1 is the only allowed Part Cost Level in combination with Inventory Valuation Method :P2 or :P3.',Inventory_Part_Cost_Level_API.Decode('COST PER PART'),Inventory_Value_Method_API.Decode('FIFO'),Inventory_Value_Method_API.Decode('LIFO'));
      END IF;
      IF (configurable_db_ = 'CONFIGURED') THEN
         Error_SYS.Record_General(lu_name_, 'VALMETCONFIG: Inventory valuation method :P1 is not allowed for configured parts.',Inventory_Value_Method_API.Decode(newrec_.inventory_valuation_method));
      END IF;
      IF (newrec_.invoice_consideration = 'PERIODIC WEIGHTED AVERAGE') THEN
         Error_SYS.Record_General(lu_name_,'NOSTACTCST: :P2 is only allowed with inventory valuation method :P1.',Inventory_Value_Method_API.Decode('ST'),Invoice_Consideration_API.Decode(newrec_.invoice_consideration));
      END IF;
      IF (newrec_.invoice_consideration = 'TRANSACTION BASED') THEN
         Error_SYS.Record_General(lu_name_,'TRBAFILI: :P1 invoice consideration is only allowed with inventory valuation methods :P2 and :P3.',Invoice_Consideration_API.Decode(newrec_.invoice_consideration),Inventory_Value_Method_API.Decode('ST'),Inventory_Value_Method_API.Decode('AV'));
      END IF;
      IF (newrec_.negative_on_hand = 'NEG ONHAND NOT OK') AND
         (newrec_.zero_cost_flag = 'O') THEN
         Error_SYS.Record_General(lu_name_, 'ZEROCOSTONLY: Zero Cost Only can only be used together with Inventory Valuaton Method Standard Cost.');
      END IF;
--    ******  End of the "FIFO and LIFO" section  ******
   ELSE
      Error_SYS.Record_General(lu_name_,'VALMETNOSUPP: Inventory Valuation Method :P1 is not supported by IFS Applications.',Inventory_Value_Method_API.Decode(newrec_.inventory_valuation_method));
   END IF;
END Check_Value_Method_Combinat___;


PROCEDURE Check_Value_Method_Change___ (
   newrec_ IN inventory_part_tab%ROWTYPE,
   oldrec_ IN inventory_part_tab%ROWTYPE )
IS
   exist_                   NUMBER;
   part_exist_              NUMBER;
   quantity_exist_          BOOLEAN;   
   qty_to_deliv_confirm_    NUMBER;
   qty_in_consignment_      NUMBER;
   qty_in_exchange_         NUMBER;
   open_shop_orders_exist_  NUMBER := 0;
   qty_at_customer_fetched_ BOOLEAN := FALSE;
   consignment_exist_       BOOLEAN := FALSE;
BEGIN
   IF (newrec_.inventory_valuation_method != oldrec_.inventory_valuation_method) THEN
      IF (((oldrec_.inventory_valuation_method     IN ('FIFO', 'LIFO')) AND
           (newrec_.inventory_valuation_method NOT IN ('FIFO', 'LIFO'))) OR
          ((oldrec_.inventory_valuation_method NOT IN ('FIFO', 'LIFO')) AND
           (newrec_.inventory_valuation_method     IN ('FIFO', 'LIFO')))) THEN

         IF (Inventory_Part_In_Stock_API.Check_Quantity_Exist(newrec_.contract,newrec_.part_no,NULL) = 'TRUE') THEN
            quantity_exist_ := TRUE;
         ELSE
            quantity_exist_ := FALSE;
         END IF;

         IF NOT(qty_at_customer_fetched_) THEN
            Get_Our_Qty_At_Customer___(qty_to_deliv_confirm_,
                                       qty_in_consignment_,
                                       qty_in_exchange_,
                                       newrec_.contract,
                                       newrec_.part_no);

            qty_at_customer_fetched_ := TRUE;
         END IF;

         IF quantity_exist_ THEN
            -- It is only possible to change to and from FIFO/LIFO when inventory is empty.
            Error_SYS.Record_General(lu_name_, 'VMETHOD: Inventory must be empty when changing to :P1 valuation method.',Inventory_Value_Method_API.Decode(newrec_.inventory_valuation_method));
         END IF;

         IF (NVL(qty_in_consignment_, 0) > 0) THEN
            Error_SYS.Record_General(lu_name_, 'QTYCONS: Unconsumed customer consignment stocks exist for the part. Inventory Valuation Method can not be changed');
         END IF;

         IF (NVL(qty_to_deliv_confirm_, 0) > 0) THEN
            Error_SYS.Record_General(lu_name_, 'QTYDELV: This part is waiting for delivery confirmation. Inventory Valuation method can not be changed.');
         END IF;

         IF (NVL(qty_in_exchange_, 0) > 0) THEN
            Error_SYS.Record_General(lu_name_, 'QTYEXCHANGE: This part is in exchange. Inventory Valuation method can not be changed.');
         END IF;
      END IF;

      IF (oldrec_.inventory_valuation_method = 'ST') THEN
           consignment_exist_ := Inventory_Part_In_Stock_API.Check_Consignment_Exist(newrec_.contract, newrec_.part_no);
           IF (consignment_exist_) THEN
              Error_SYS.Record_General(lu_name_, 'PARTLOCCON: The inventory valuation method must be :P1 when there are goods in Consignment Stock.', Inventory_Value_Method_API.Decode('ST'));
           END IF;
           
           $IF (Component_Purch_SYS.INSTALLED) $THEN
              exist_ := Purchase_Part_Supplier_API.Check_Consignment_Exist(newrec_.contract, newrec_.part_no);           
              IF (exist_ = 1) THEN
                 Error_SYS.Record_General(lu_name_, 'PARTSUPPLIER: The inventory valuation method must be :P1 when there are Purchase part suppliers marked with consignment.', Inventory_Value_Method_API.Decode('ST'));
              END IF;
           $END

           $IF (Component_Purch_SYS.INSTALLED) $THEN
              exist_ := Purchase_Order_Line_Part_API.Check_Consignment_Exist(newrec_.contract, newrec_.part_no);
           
              IF (exist_ = 1) THEN
                 Error_SYS.Record_General(lu_name_, 'ORDERLINE: The inventory valuation method must be :P1 when there are Purchase order lines marked with consignment.', Inventory_Value_Method_API.Decode('ST'));
              END IF;
           $END
      END IF;

      IF newrec_.inventory_valuation_method != 'ST' THEN
         IF Inventory_Part_In_Stock_API.Is_Part_In_Fa_Rotable_Pool(newrec_.contract, newrec_.part_no) = 1 THEN
            Error_SYS.Record_General(lu_name_, 'PARTINPOOL: The inventory valuation method must be :P1 when the part exists in a fixed asset rotable part pool.', Inventory_Value_Method_API.Decode('ST'));
         END IF;
      END IF;
   END IF;

   IF (newrec_.inventory_part_cost_level != oldrec_.inventory_part_cost_level) THEN
      IF (newrec_.invoice_consideration = 'PERIODIC WEIGHTED AVERAGE') THEN
         Error_SYS.Record_General(lu_name_, 'ACLEVELERR: Cost Level can not be changed when Periodic Weighted Average is enabled.');
      END IF;

      IF (Inventory_Part_In_Stock_API.Check_Quantity_Exist(newrec_.contract,newrec_.part_no,NULL) = 'TRUE') THEN
         quantity_exist_ := TRUE;
      ELSE
         quantity_exist_ := FALSE;
      END IF;

      IF quantity_exist_ THEN
         Error_SYS.Record_General(lu_name_, 'WAINVEMTPY: It is not allowed to change Inventory Part Cost Level when you have a quantity in stock or in transit between stock locations.');
      END IF;

      IF NOT (qty_at_customer_fetched_) THEN
         Get_Our_Qty_At_Customer___(qty_to_deliv_confirm_,
                                    qty_in_consignment_,
                                    qty_in_exchange_,
                                    newrec_.contract,
                                    newrec_.part_no);
         qty_at_customer_fetched_ := TRUE;
      END IF;

      IF (nvl(qty_to_deliv_confirm_, 0) > 0) THEN
         Error_SYS.Record_General(lu_name_, 'WADELCONF: This part is waiting for delivery confirmation. Inventory Part Cost Level can not be changed.');
      END IF;

      IF (nvl(qty_in_consignment_, 0) > 0) THEN
         -- It is only possible to change weighted average level when inventory is empty.
         Error_SYS.Record_General(lu_name_, 'WACUSTCONS: Unconsumed customer consignment stocks exist for the part. Inventory Part Cost Level can not be changed');
      END IF;

      IF (NVL(qty_in_exchange_, 0) > 0) THEN
         Error_SYS.Record_General(lu_name_, 'WAEXCHANGE: This part is in exchange. Inventory Part Cost Level can not be changed.');
      END IF;

      IF newrec_.inventory_part_cost_level != 'COST PER SERIAL' THEN
         IF Inventory_Part_In_Stock_API.Is_Part_In_Fa_Rotable_Pool(newrec_.contract, newrec_.part_no) = 1 THEN
            Error_SYS.Record_General(lu_name_, 'PARTINPOOL2: The inventory part cost level must be :P1 when the part exists in a rotable part pool.', Inventory_Part_Cost_Level_API.Decode('COST PER SERIAL'));
         END IF;
      END IF;

      -- if part cost level is changed FROM Cost Per Part - check if there are orders using Delivery Confirmation
      -- and have order lines with this part that haven't been confirmed yet.
      $IF (Component_Order_SYS.INSTALLED) $THEN
         IF (oldrec_.inventory_part_cost_level = 'COST PER PART') THEN
            part_exist_ := Customer_Order_Line_API.Check_Part_Used(newrec_.contract, newrec_.part_no);        
            IF (part_exist_ = 1) THEN
               Error_SYS.Record_General(lu_name_, 'DELCONF_PARTUSED: The inventory part exists on customer order lines that haven''t been Delivery Confirmed yet. Inventory Part Cost Level can only be set to :P1 at this point.', Inventory_Part_Cost_Level_API.Decode('COST PER PART'));
            END IF;
         END IF;
      $END
   END IF;

   -- Check if open shop orders exist for the part
   $IF (Component_Shpord_SYS.INSTALLED) $THEN
      IF (Shop_Ord_Util_API.Active_Shop_Orders_Exist(newrec_.part_no, newrec_.contract)) THEN
         open_shop_orders_exist_ := 1;
      ELSE
         open_shop_orders_exist_ := 0;
      END IF;
   $END  

   IF (open_shop_orders_exist_ = 1) THEN
      IF (Cascade_Update_On_SO_Close___(oldrec_.inventory_valuation_method,
                                        oldrec_.inventory_part_cost_level)) THEN

         IF (Cascade_Update_On_SO_Close___(newrec_.inventory_valuation_method,
                                           newrec_.inventory_part_cost_level)) THEN
            -- Both settings would result in cascade updates for SO receipt transactions when the SO is
            -- closed, but changing valuation method or part cost level may result in variances
            -- being booked for open shop orders.
            -- Inform the user that variances may be booked for already open Shop Orders
            Client_SYS.Add_Info(lu_name_,
               'DIFFFORSO1: Open Shop Order(s) exist for this part. Change of Inventory Valuation Method or Inventory Part Cost Level may result in Variances being booked.');
         ELSE
            -- No cascade update of transactions will be executed for the new settings.
            -- Just inform the user that variances may be booked
            Client_SYS.Add_Info(lu_name_,
               'DIFFFORSO2: Open Shop Order(s) exist for this part. Variances may be booked for these as well as for new orders.');
         END IF;
      ELSIF (Cascade_Update_On_SO_Close___(newrec_.inventory_valuation_method,
                                           newrec_.inventory_part_cost_level)) THEN
         -- Cascade updates of transaction will be made for new SO:s but not for orders
         -- not closed for which receipts have already been made.
         -- Inform the user that variances may be booked for already open Shop Orders
         Client_Sys.Add_Info(lu_name_,
            'DIFFFORSO3: Open Shop Order(s) exist for this part. IF receipts have already been made Variances may be booked for these orders.');
      END IF;
   END IF;

   --Give an alert if the part is FIFO /LIFO and CC enabled
   IF (newrec_.inventory_valuation_method IN ('FIFO','LIFO') AND
       oldrec_.inventory_valuation_method NOT IN ('FIFO','LIFO')) THEN

      IF (Part_Catalog_API.Get_Condition_Code_Usage_Db(newrec_.part_no) = 'ALLOW_COND_CODE') THEN
         Client_SYS.Add_Info(lu_name_,'FIFOLIFOANDCC: This part is set up using condition codes. The FIFO / LIFO valuation method will however not consider the condition code of the inventory transactions.');
      END IF;
   END IF;
END Check_Value_Method_Change___;


PROCEDURE Check_Open_Eso_Exist___ (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 )
IS
   open_line_exist_ VARCHAR2(5);
BEGIN
   $IF (Component_Purch_SYS.INSTALLED) $THEN
      open_line_exist_  := Purchase_Order_Line_Util_API.Check_Open_Eso_Exist(contract_, part_no_);  
      IF (open_line_exist_ = 'TRUE') THEN
         Error_SYS.Record_General(lu_name_,'NOMODEXTCOSTORD: Since open service order(s) exist with the part :P1, External Service Cost Method cannot be modified.', part_no_);
      END IF;
      
      open_line_exist_  := Purchase_Req_Util_API.Check_Open_Eso_Exist(contract_, part_no_);
      IF (open_line_exist_ = 'TRUE') THEN
         Error_SYS.Record_General(lu_name_,'NOMODEXTCOSTREQ: Since open service requisition(s) exist with the part :P1, External Service Cost Method cannot be modified.', part_no_);
      END IF;
   $ELSE
      NULL;  
   $END
END Check_Open_Eso_Exist___;


PROCEDURE Overwrite_Record_With_Attr___ (
   lu_rec_ IN OUT NOCOPY inventory_part_tab%ROWTYPE,
   attr_   IN     VARCHAR2 )
IS
   ptr_   NUMBER;
   name_  VARCHAR2(30);
   value_ VARCHAR2(2000);
BEGIN
   ptr_ := NULL;
   WHILE (Client_SYS.Get_Next_From_Attr(attr_, ptr_, name_, value_)) LOOP
      IF (name_ = 'ACCOUNTING_GROUP') THEN
         lu_rec_.accounting_group := value_;
      ELSIF (name_ = 'ASSET_CLASS') THEN
         lu_rec_.asset_class := value_;
      ELSIF (name_ = 'COUNTRY_OF_ORIGIN') THEN
         lu_rec_.country_of_origin := value_;
      ELSIF (name_ = 'HAZARD_CODE') THEN
         lu_rec_.hazard_code := value_;
      ELSIF (name_ = 'NOTE_ID') THEN
         lu_rec_.note_id := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'PART_PRODUCT_CODE') THEN
         lu_rec_.part_product_code := value_;
      ELSIF (name_ = 'PART_PRODUCT_FAMILY') THEN
         lu_rec_.part_product_family := value_;
      ELSIF (name_ = 'PART_STATUS') THEN
         lu_rec_.part_status := value_;
      ELSIF (name_ = 'PLANNER_BUYER') THEN
         lu_rec_.planner_buyer := value_;
      ELSIF (name_ = 'PRIME_COMMODITY') THEN
         lu_rec_.prime_commodity := value_;
      ELSIF (name_ = 'SECOND_COMMODITY') THEN
         lu_rec_.second_commodity := value_;
      ELSIF (name_ = 'UNIT_MEAS') THEN
         lu_rec_.unit_meas := value_;
      ELSIF (name_ = 'DESCRIPTION') THEN
         lu_rec_.description := value_;
      ELSIF (name_ = 'ABC_CLASS') THEN
         lu_rec_.abc_class := value_;
      ELSIF (name_ = 'CYCLE_CODE') THEN
         lu_rec_.cycle_code := Inventory_Part_Count_Type_API.Encode(value_);
      ELSIF (name_ = 'CYCLE_PERIOD') THEN
         lu_rec_.cycle_period := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'DIM_QUALITY') THEN
         lu_rec_.dim_quality := value_;
      ELSIF (name_ = 'DURABILITY_DAY') THEN
         lu_rec_.durability_day := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'EXPECTED_LEADTIME') THEN
         lu_rec_.expected_leadtime := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'LEAD_TIME_CODE') THEN
         lu_rec_.lead_time_code := Inv_Part_Lead_Time_Code_API.Encode(value_);
      ELSIF (name_ = 'MANUF_LEADTIME') THEN
         lu_rec_.manuf_leadtime := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'NOTE_TEXT') THEN
         lu_rec_.note_text := value_;
      ELSIF (name_ = 'PURCH_LEADTIME') THEN
         lu_rec_.purch_leadtime := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'SUPERSEDES') THEN
         lu_rec_.supersedes := value_;
      ELSIF (name_ = 'SUPPLY_CODE') THEN
         lu_rec_.supply_code := Material_Requis_Supply_API.Encode(value_);
      ELSIF (name_ = 'TYPE_CODE') THEN
         lu_rec_.type_code := Inventory_Part_Type_API.Encode(value_);
      ELSIF (name_ = 'CUSTOMS_STAT_NO') THEN
         lu_rec_.customs_stat_no := value_;
      ELSIF (name_ = 'TYPE_DESIGNATION') THEN
         lu_rec_.type_designation := value_;
      ELSIF (name_ = 'ZERO_COST_FLAG') THEN
         lu_rec_.zero_cost_flag := Inventory_Part_Zero_Cost_API.Encode(value_);
      ELSIF (name_ = 'SHORTAGE_FLAG') THEN
         lu_rec_.shortage_flag := Inventory_Part_Shortage_API.Encode(value_);
      ELSIF (name_ = 'OE_ALLOC_ASSIGN_FLAG') THEN
         lu_rec_.oe_alloc_assign_flag := Cust_Ord_Reservation_Type_API.Encode(value_);
      ELSIF (name_ = 'ONHAND_ANALYSIS_FLAG') THEN
         lu_rec_.onhand_analysis_flag := Inventory_Part_Onh_Analys_API.Encode(value_);
      ELSIF (name_ = 'ENG_ATTRIBUTE') THEN
         lu_rec_.eng_attribute := value_;
      ELSIF (name_ = 'COUNT_VARIANCE') THEN
         Error_SYS.Item_Insert(lu_name_, name_);
      ELSIF (name_ = 'CREATE_DATE') THEN
         Error_SYS.Item_Insert(lu_name_, name_);
      ELSIF (name_ = 'AVAIL_ACTIVITY_STATUS') THEN
         Error_SYS.Item_Insert(lu_name_, name_);
      ELSIF (name_ = 'LAST_ACTIVITY_DATE') THEN
         Error_SYS.Item_Insert(lu_name_, name_);
      ELSIF (name_ = 'FORECAST_CONSUMPTION_FLAG') THEN
         lu_rec_.forecast_consumption_flag := Inv_Part_Forecast_Consum_API.Encode(value_);
      ELSIF (name_ = 'INTRASTAT_CONV_FACTOR') THEN
         lu_rec_.intrastat_conv_factor := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'INVOICE_CONSIDERATION') THEN
         lu_rec_.invoice_consideration := Invoice_Consideration_API.Encode(value_);
      ELSIF (name_ = 'MAX_ACTUAL_COST_UPDATE') THEN
         lu_rec_.max_actual_cost_update := value_;
      ELSIF (name_ = 'INVENTORY_PART_COST_LEVEL') THEN
         lu_rec_.inventory_part_cost_level := Inventory_Part_Cost_Level_API.Encode(value_);
      ELSIF (name_ = 'INPUT_UNIT_MEAS_GROUP_ID') THEN
         lu_rec_.input_unit_meas_group_id := value_;
      ELSIF (name_ = 'DOP_CONNECTION') THEN
         lu_rec_.dop_connection := Dop_Connection_API.Encode(value_);
      ELSIF (name_ = 'SUPPLY_CHAIN_PART_GROUP') THEN
         lu_rec_.supply_chain_part_group := value_;
      ELSIF (name_ = 'EXT_SERVICE_COST_METHOD') THEN
         lu_rec_.ext_service_cost_method := Ext_Service_Cost_Method_API.Encode(value_);
      ELSIF (name_ = 'STOCK_MANAGEMENT') THEN
         lu_rec_.stock_management := Inventory_Part_Management_API.Encode(value_);
      ELSIF (name_ = 'TECHNICAL_COORDINATOR_ID') THEN
         lu_rec_.technical_coordinator_id := value_;
      ELSIF (name_ = 'SUP_WARRANTY_ID') THEN
         lu_rec_.sup_warranty_id := value_;
      ELSIF (name_ = 'CUST_WARRANTY_ID') THEN
         lu_rec_.cust_warranty_id := value_;
      ELSIF (name_ = 'MIN_DURAB_DAYS_CO_DELIV') THEN
         lu_rec_.min_durab_days_co_deliv := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'MIN_DURAB_DAYS_PLANNING') THEN
         lu_rec_.min_durab_days_planning := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'PUTAWAY_ZONE_REFILL_OPTION') THEN
         lu_rec_.putaway_zone_refill_option := Putaway_Zone_Refill_Option_API.Encode(value_);
      ELSE
         Error_SYS.Item_Not_Exist(lu_name_, name_, value_);
      END IF;
   END LOOP;
END Overwrite_Record_With_Attr___;


PROCEDURE Check_Invoice_Consideration___ (
   contract_                 IN VARCHAR2,
   company_                  IN VARCHAR2,
   invoice_consideration_db_ IN VARCHAR2 )
IS
   company_dist_rec_ Company_Invent_Info_API.Public_Rec;
BEGIN
   IF (invoice_consideration_db_ = 'TRANSACTION BASED') THEN
      company_dist_rec_ := Company_Invent_Info_API.Get(company_);
      IF (company_dist_rec_.ownership_transfer_point = 'RECEIPT INTO INVENTORY') THEN
         Error_SYS.Record_General(lu_name_, 'TRBARECININ: You cannot use Transaction Based Supplier Invoice Consideration on site :P1 since the Ownership Transfer Point on company :P2 is :P3.', contract_, company_, Ownership_Transfer_Point_API.Decode(company_dist_rec_.ownership_transfer_point));
      END IF;
   END IF;
END Check_Invoice_Consideration___;


PROCEDURE Check_Auto_Capability_Check___ (
   newrec_ IN inventory_part_tab%ROWTYPE )
IS
   planning_method_     VARCHAR2(1);
   sourcing_option_db_  VARCHAR2(20);
   dop_or_so_           NUMBER;
BEGIN
   IF (newrec_.automatic_capability_check IN ('RESERVE AND ALLOCATE','ALLOCATE ONLY','NEITHER RESERVE NOR ALLOCATE')) THEN
      IF (newrec_.forecast_consumption_flag = 'FORECAST') THEN
         Error_SYS.Record_General(lu_name_, 'AOCCYESANDFORECAST: Online consumption cannot be set to active if Automatic Capability Check on inventory part is ":P1".',Capability_Check_Allocate_API.Decode(newrec_.automatic_capability_check));
      END IF;
      IF (newrec_.onhand_analysis_flag = 'Y') THEN
         Error_SYS.Record_General(lu_name_, 'AOCCYESANDAVAILCH: Availability check cannot be set to active if Automatic Capability Check on inventory part is ":P1".',Capability_Check_Allocate_API.Decode(newrec_.automatic_capability_check));
      END IF;
      planning_method_ := Get_Planning_Method___(newrec_.contract, newrec_.part_no);
      IF (planning_method_ IN ('P','N')) THEN
         Error_SYS.Record_General(lu_name_, 'AOCCYESANDMRPPN: Planning Method cannot be P or N if Automatic Capability Check on inventory part is ":P1".',Capability_Check_Allocate_API.Decode(newrec_.automatic_capability_check));
      END IF;
      $IF (Component_Order_SYS.INSTALLED) $THEN
         IF (newrec_.automatic_capability_check = 'RESERVE AND ALLOCATE') THEN
            sourcing_option_db_ := Sales_Part_API.Get_Sourcing_Option_Db(newrec_.contract, newrec_.part_no);
            IF sourcing_option_db_ = 'SHOPORDER' THEN
               Error_SYS.Record_General(lu_name_, 'AOANDSOINVALID: Capability Check cannot be set to ":P1" if Sourcing Option on any related sales part is set to ":P2".',
                                        Capability_Check_Allocate_API.Decode(newrec_.automatic_capability_check), 
                                        Sourcing_Option_API.Decode(sourcing_option_db_));
            END IF;
         ELSE 
            dop_or_so_ := Sales_Part_API.Src_Option_Must_Be_Dop_Or_So(newrec_.contract, newrec_.part_no);   
            IF (dop_or_so_ = 0) THEN
               Error_SYS.Record_General(lu_name_, 'INVPARTAOCCYES: Sourcing Option on any related sales part must be set to DOP Order or Shop Order if Automatic Capability Check on inventory part is ":P1".',Capability_Check_Allocate_API.Decode(newrec_.automatic_capability_check));
            END IF;
         END IF;
      $END
   END IF;
END Check_Auto_Capability_Check___;


FUNCTION Cascade_Update_On_SO_Close___ (
   inventory_valuation_method_db_ IN VARCHAR2,
   inventory_part_cost_level_db_  IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   IF ((inventory_valuation_method_db_ = 'AV') OR
       (inventory_part_cost_level_db_ = 'COST PER SERIAL')) THEN
      RETURN TRUE;
   ELSE
      RETURN FALSE;
   END IF;
END Cascade_Update_On_SO_Close___;


FUNCTION Get_Calc_Rounded_Qty___ (
   original_qty_      IN NUMBER,
   qty_calc_rounding_ IN NUMBER,
   action_            IN VARCHAR2,
   unit_meas_         IN VARCHAR2,
   ignore_unit_type_  IN BOOLEAN ) RETURN NUMBER
IS
   adjusted_qty_ NUMBER;
   unit_type_db_ VARCHAR2(10);
BEGIN
   adjusted_qty_ := original_qty_;
   IF (qty_calc_rounding_ IS NOT NULL) THEN
      -- Round adjust_qty_ only when the unit type of the used unit of measure is 'WEIGHT','VOLUME','LENGTH' 
      unit_type_db_ := Iso_Unit_API.Get_Unit_Type_Db(unit_meas_);
      IF (unit_type_db_ IN ('WEIGHT','VOLUME', 'LENGTH') OR (ignore_unit_type_)) THEN 
         adjusted_qty_ := ROUND(adjusted_qty_, qty_calc_rounding_ + 2);
      END IF;
      IF (adjusted_qty_ != TRUNC(adjusted_qty_, qty_calc_rounding_)) THEN
         IF (action_ = 'ADD') THEN
            adjusted_qty_ := TRUNC(adjusted_qty_, qty_calc_rounding_) +
                             POWER(10, qty_calc_rounding_ * -1);
         ELSIF (action_ = 'REMOVE') THEN
            adjusted_qty_ := TRUNC(adjusted_qty_, qty_calc_rounding_);
         ELSIF (action_ = 'ROUND') THEN
            adjusted_qty_ := ROUND(adjusted_qty_, qty_calc_rounding_);
         END IF;
      END IF;
   END IF;
   adjusted_qty_ := NVL(adjusted_qty_, 0);
   RETURN adjusted_qty_;
END Get_Calc_Rounded_Qty___;


PROCEDURE Check_Qty_Calc_Rounding___ (
   qty_calc_rounding_             IN NUMBER,
   receipt_issue_serial_track_db_ IN VARCHAR2,
   unit_meas_                     IN VARCHAR2 )
IS
BEGIN
   IF (receipt_issue_serial_track_db_ = Fnd_Boolean_API.db_true AND qty_calc_rounding_ != 0) THEN
      Error_SYS.Record_General(lu_name_, 'CALCROUNDSER: Qty Calc Rounding must be zero for parts that are serial tracked during receipt and issue.');
   ELSIF (Iso_Unit_Type_API.Encode(Iso_Unit_API.Get_Unit_Type(unit_meas_)) = 'DISCRETE' AND qty_calc_rounding_ != 0) THEN
      Error_SYS.Record_General(lu_name_, 'CALCROUNDDIS: Qty Calc Rounding must be zero for parts with a discrete unit of measure.');
   END IF;
   IF ((qty_calc_rounding_ > 20) OR (qty_calc_rounding_ < 0)
       OR (MOD(qty_calc_rounding_, 1) != 0)) THEN
      Error_SYS.Record_General(lu_name_, 'ERRORQTYCALCROUNDING: Qty Calc Rounding must be an integer between 0 and 20.');
   END IF;
END Check_Qty_Calc_Rounding___;


PROCEDURE Get_Our_Qty_At_Customer___ (
   qty_to_deliv_confirm_ OUT NUMBER,
   qty_in_consignment_   OUT NUMBER,
   qty_in_exchange_      OUT NUMBER,
   contract_             IN  VARCHAR2,
   part_no_              IN  VARCHAR2 )
IS
BEGIN
   Inventory_Part_At_Customer_API.Get_Our_Total_Qty_At_Customer (qty_to_deliv_confirm_,
                                                                 qty_in_consignment_,
                                                                 qty_in_exchange_,
                                                                 contract_,
                                                                 part_no_);
END Get_Our_Qty_At_Customer___;


PROCEDURE Handle_Description_Change___ (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 )
IS
   key_ref_ VARCHAR2(2000);
BEGIN
   IF (Part_Catalog_Invent_Attrib_API.Get_Hse_Contract(part_no_) = contract_) THEN
      Pack_And_Post_Message__('ADDEDIT', part_no_, contract_);
   END IF;
   
   $IF (Component_Docman_SYS.INSTALLED) $THEN   
      Client_SYS.Get_Key_Reference(key_ref_, lu_name_, Get_Objid__(contract_, part_no_));
      Doc_Reference_Object_API.Refresh_Object_Reference_Desc(lu_name_, key_ref_);      
   $END
   
   $IF (Component_Cbsint_SYS.INSTALLED) $THEN
      Cbs_So_Int_API.Modify_Part_Desc(contract_, part_no_);
   $END
END Handle_Description_Change___;


PROCEDURE Check_Lead_Time___ (
   lead_time_ IN NUMBER )
IS
BEGIN
   IF ((lead_time_ < 0) OR (lead_time_ != trunc(lead_time_)))THEN
      Error_SYS.Record_General(lu_name_, 'INVALIDLEADTIMES: Lead Time must have a positive integer value.');
   END IF;
END Check_Lead_Time___;


PROCEDURE Check_Expense_Part_Allowed___ (
   allow_not_consumed_ IN VARCHAR2)
IS
BEGIN
   IF (allow_not_consumed_ = 'FALSE') THEN
      Error_SYS.Record_General(lu_name_, 'NOTALLWCONSUMED: Allowed as Not Consumed must be selected in Part Catalog when Part Type is set to Expense.');
   END IF;
END Check_Expense_Part_Allowed___;


PROCEDURE Check_Min_Durab_Days_Co_Del___ (
   durability_day_          IN NUMBER,
   min_durab_days_co_deliv_ IN NUMBER )
IS
BEGIN
   IF ((min_durab_days_co_deliv_ < 0) OR
       (min_durab_days_co_deliv_ != ROUND(min_durab_days_co_deliv_))) THEN
      Error_SYS.Record_General(lu_name_, 'INVALIDCODURABLELE: The minimum remaining durability days for the customer order delivery must be a positive integer value.');
   END IF;
   
   IF (durability_day_ IS NOT NULL) THEN
      IF (min_durab_days_co_deliv_ > durability_day_) THEN
         Error_SYS.Record_General(lu_name_, 'CODURABLELESSTHANDURABLE: The minimum remaining durability days for the customer order delivery must not be greater than the shelf life of the inventory part.');
      END IF;
   END IF;
END Check_Min_Durab_Days_Co_Del___;


PROCEDURE Check_Min_Durab_Days_Plan___ (
   durability_day_          IN NUMBER,
   min_durab_days_planning_ IN NUMBER )
IS
BEGIN
   IF ((min_durab_days_planning_ < 0) OR
       (min_durab_days_planning_ != ROUND(min_durab_days_planning_))) THEN
      Error_SYS.Record_General(lu_name_, 'INVALIDMINDURABPLAN: The minimum remaining durability days for planning must be a positive integer value.');
   END IF;

   IF (durability_day_ IS NOT NULL) THEN
      IF (min_durab_days_planning_ > durability_day_) THEN
         Error_SYS.Record_General(lu_name_, 'MINDURABLESSTHANDURABLE: The minimum remaining durability days for planning must not be greater than the shelf life of the inventory part.');
      END IF;
   END IF;
END Check_Min_Durab_Days_Plan___;


PROCEDURE Handle_Planning_Attr_Change___ (
   newrec_ IN inventory_part_tab%ROWTYPE,
   oldrec_ IN inventory_part_tab%ROWTYPE)
IS
   new_status_rec_  Inventory_Part_Status_Par_API.Public_Rec;
   old_status_rec_  Inventory_Part_Status_Par_API.Public_Rec;   
   planning_method_ VARCHAR2(1);
   exit_procedure_  EXCEPTION;
BEGIN
   IF NOT (Component_Invpla_SYS.INSTALLED) THEN 
      RAISE exit_procedure_;
   END IF;
   $IF (Component_Invpla_SYS.INSTALLED) $THEN
      IF (Site_Ipr_Info_API.Get_Ipr_Active_Db(newrec_.contract) = Fnd_Boolean_API.DB_FALSE) THEN
         RAISE exit_procedure_;
      END IF;
   $END

   IF (oldrec_.expected_leadtime != newrec_.expected_leadtime) THEN
      $IF (Component_Invpla_SYS.INSTALLED) $THEN
         Inventory_Part_Invpla_Info_API.Handle_Expect_Leadtime_Change(newrec_.contract,
                                                                      newrec_.part_no,
                                                                      oldrec_.expected_leadtime,
                                                                      newrec_.expected_leadtime );
      $ELSE
         NULL;
      $END
   END IF;

   planning_method_ := Get_Planning_Method___(newrec_.contract, newrec_.part_no);

   IF (planning_method_ != 'B') THEN
      RAISE exit_procedure_;
   END IF;

   new_status_rec_ := Inventory_Part_Status_Par_API.Get(newrec_.part_status);

   IF (newrec_.part_status = oldrec_.part_status) THEN
      old_status_rec_ := new_status_rec_;
   ELSE
      old_status_rec_ := Inventory_Part_Status_Par_API.Get(oldrec_.part_status);
   END IF;

   IF (((newrec_.stock_management = 'SYSTEM MANAGED INVENTORY') AND
        (new_status_rec_.onhand_flag = 'Y') AND
        (new_status_rec_.supply_flag = 'Y'))
       OR
       ((oldrec_.stock_management = 'SYSTEM MANAGED INVENTORY') AND
        (old_status_rec_.onhand_flag = 'Y') AND
        (old_status_rec_.supply_flag = 'Y'))) THEN
           
         $IF (Component_Invpla_SYS.INSTALLED) $THEN
            Inventory_Part_Invpla_Info_API.Set_Latest_Plan_Activity_Time(newrec_.contract, newrec_.part_no);
         $ELSE
            NULL;
         $END           
   END IF;

   IF (((newrec_.stock_management = 'SYSTEM MANAGED INVENTORY') AND
        (new_status_rec_.onhand_flag = 'Y') AND
        (new_status_rec_.supply_flag = 'Y'))
       AND
       ((oldrec_.stock_management != 'SYSTEM MANAGED INVENTORY') OR
        (old_status_rec_.onhand_flag != 'Y') OR
        (old_status_rec_.supply_flag != 'Y'))) THEN
           
      $IF (Component_Invpla_SYS.INSTALLED) $THEN
         Inventory_Part_Invpla_Info_API.Refresh_Unit_Cost_Snapshot(newrec_.contract, newrec_.part_no);
      $ELSE
         NULL;   
      $END      
   END IF;
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Handle_Planning_Attr_Change___;


FUNCTION Get_Planning_Method___ (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN Inventory_Part_Planning_API.Get_Planning_Method(contract_, part_no_);
END Get_Planning_Method___;


PROCEDURE Check_Supersedes___ (
   contract_     IN VARCHAR2,
   part_no_      IN VARCHAR2,
   supersedes_   IN VARCHAR2,
   part_status_  IN VARCHAR2 )
IS
   dummy_        inventory_part_tab.part_no%TYPE;

   CURSOR get_supersedes_data IS
      SELECT part_no 
      FROM inventory_part_tab
      WHERE contract = contract_
      AND   supersedes = supersedes_
      AND   part_no != part_no_;
BEGIN
   IF (supersedes_ IS NOT NULL) THEN
      IF (part_no_ = supersedes_) THEN
         Error_SYS.Record_General(lu_name_, 'PARTREPLACE: This part cannot replace itself.');
      END IF;

      -- Check part status of the current part
      IF (Inventory_Part_Status_Par_API.Get_Supply_Flag_Db(Get_Part_Status(contract_, supersedes_)) = 'Y') THEN
         Error_SYS.Record_General(lu_name_, 'WRONGPARTSTATUS: Supply status of part :P1 being replaced must be Supplies Not Allowed.', supersedes_);
      END IF;
   
      -- Check part status of the current part
      IF (Inventory_Part_Status_Par_API.Get_Supply_Flag_Db(part_status_) = 'N') THEN
         Error_SYS.Record_General(lu_name_, 'WRONGPARTSTATUS2: Supply status of replacing part :P1 must be Supplies Allowed.', part_no_);
      END IF;
   
      -- Check for a part being replaced by multiple parts
      OPEN get_supersedes_data;
      FETCH get_supersedes_data INTO dummy_;
      IF get_supersedes_data%FOUND THEN
         CLOSE get_supersedes_data;
         Error_SYS.Record_General(lu_name_, 'MULTIPLEREPLACEMENTS: Part :P1 has already been replaced by :P2 and cannot be replaced by more than one part at a time.', supersedes_, dummy_);
      END IF;
      CLOSE get_supersedes_data;
   END IF;
END Check_Supersedes___;


PROCEDURE Handle_Part_Status_Change___ (
   contract_        IN VARCHAR2,
   part_no_         IN VARCHAR2,
   old_part_status_ IN VARCHAR2,
   new_part_status_ IN VARCHAR2 )
IS
   total_demand_     NUMBER;
   total_supply_     NUMBER;
   starting_balance_ NUMBER;
BEGIN
   IF (Inventory_Part_Status_Par_API.Get_Supply_Flag_Db(new_part_status_)= 'N') THEN
      total_demand_ := Order_Supply_Demand_API.Get_Total_Demand(contract_         => contract_,
                                                                part_no_          => part_no_,
                                                                configuration_id_ => NULL,
                                                                include_standard_ => 'TRUE',
                                                                include_project_  => 'TRUE',
                                                                project_id_       => NULL,
                                                                activity_seq_     => NULL,
                                                                date_required_    => NULL,
                                                                source_           => 'CUSTORD_SUPPLY_DEMAND',
                                                                exclude_reserved_ => 'TRUE');

      IF (total_demand_ > 0) THEN
         total_supply_ := Order_Supply_Demand_API.Get_Total_Supply(contract_         => contract_,
                                                                   part_no_          => part_no_,
                                                                   configuration_id_ => NULL,
                                                                   include_standard_ => 'TRUE',
                                                                   include_project_  => 'TRUE',
                                                                   project_id_       => NULL,
                                                                   activity_seq_     => NULL,
                                                                   date_required_    => NULL,
                                                                   source_           => 'CUSTORD_SUPPLY_DEMAND'); 
         IF (total_demand_ > total_supply_) THEN
            starting_balance_ := Inventory_Part_In_Stock_API.Get_Starting_Balance(contract_            => contract_, 
                                                                                  part_no_             => part_no_,
                                                                                  configuration_id_    => NULL, 
                                                                                  include_standard_    => 'TRUE',                                                                               
                                                                                  include_project_     => 'TRUE',
                                                                                  project_id_          => NULL,
                                                                                  activity_seq_        => NULL,
                                                                                  include_floor_stock_ => 'TRUE');    
            IF (total_demand_ > (total_supply_ + starting_balance_)) THEN
               Client_SYS.Add_Info(lu_name_, 'DEMANDEXCEEDSQTY: The sum of the quantity on hand and the supplies does not cover the demands.');
            END IF;
         END IF;
      END IF;
   END IF;
END Handle_Part_Status_Change___;


FUNCTION Company_Owned_Stock_Exists___(
   contract_     IN VARCHAR2,
   part_no_      IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   RETURN Invent_Part_Quantity_Util_API.Check_Quantity_Exist(contract_                      => contract_,
                                                             part_no_                       => part_no_,
                                                             configuration_id_              => NULL,
                                                             exclude_customer_owned_stock_  => 'TRUE',                                                                 
                                                             exclude_supplier_loaned_stock_ => 'TRUE',
                                                             exclude_supplier_owned_stock_  => 'TRUE',
                                                             exclude_supplier_rented_stock_ => 'TRUE',
                                                             exclude_company_rental_stock_  => 'TRUE');
END Company_Owned_Stock_Exists___;


FUNCTION Get_Updated_Control_Type___ (
   oldrec_            IN inventory_part_tab%ROWTYPE,
   newrec_            IN inventory_part_tab%ROWTYPE,
   check_only_active_ IN BOOLEAN,
   company_           IN VARCHAR2 ) RETURN VARCHAR2
IS
   updated_control_type_ VARCHAR2(3);
   today_                DATE;
   c32_                  CONSTANT VARCHAR2(3) := 'C32';
   c50_                  CONSTANT VARCHAR2(3) := 'C50';
   c49_                  CONSTANT VARCHAR2(3) := 'C49';
   c12_                  CONSTANT VARCHAR2(3) := 'C12';
   c10_                  CONSTANT VARCHAR2(3) := 'C10';
   c9_                   CONSTANT VARCHAR2(2) := 'C9';
   c6_                   CONSTANT VARCHAR2(3) := 'C6';
   c7_                   CONSTANT VARCHAR2(3) := 'C7';
   c8_                   CONSTANT VARCHAR2(3) := 'C8';
   m1_                   CONSTANT VARCHAR2(2) := 'M1';
   m3_                   CONSTANT VARCHAR2(2) := 'M3';
BEGIN
   IF (check_only_active_) THEN
      today_ := TRUNC(Site_API.Get_Site_Date(newrec_.contract));
   END IF;

   IF ((NVL(newrec_.accounting_group, Database_SYS.string_null_)) != 
       (NVL(oldrec_.accounting_group, Database_SYS.string_null_))) THEN
      IF (check_only_active_) THEN
         IF ((Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m1_,c32_,today_)) OR 
             (Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m3_,c32_,today_))) THEN
            updated_control_type_ := c32_;
         END IF;
      ELSE
         updated_control_type_ := c32_;
      END IF;
   END IF;

   IF (updated_control_type_ IS NULL) THEN
      IF ((NVL(newrec_.asset_class, Database_SYS.string_null_)) != 
          (NVL(oldrec_.asset_class, Database_SYS.string_null_))) THEN
         IF (check_only_active_) THEN
            IF ((Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m1_,c9_,today_)) OR 
                (Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m3_,c9_,today_))) THEN
               updated_control_type_ := c9_;
            END IF;
         ELSE
            updated_control_type_ := c9_;
         END IF;
      END IF;
   END IF;

   IF (updated_control_type_ IS NULL) THEN
      IF ((NVL(newrec_.part_product_code, Database_SYS.string_null_)) != 
          (NVL(oldrec_.part_product_code, Database_SYS.string_null_))) THEN
         IF (check_only_active_) THEN
            IF ((Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m1_,c50_,today_)) OR 
                (Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m3_,c50_,today_))) THEN
               updated_control_type_ := c50_;
            END IF;
         ELSE
            updated_control_type_ := c50_;
         END IF;
      END IF;
   END IF;

   IF (updated_control_type_ IS NULL) THEN
      IF ((NVL(newrec_.part_product_family, Database_SYS.string_null_)) != 
          (NVL(oldrec_.part_product_family, Database_SYS.string_null_))) THEN
         IF (check_only_active_) THEN
            IF ((Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m1_,c49_,today_)) OR 
                (Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m3_,c49_,today_))) THEN
               updated_control_type_ := c49_;
            END IF;
         ELSE
            updated_control_type_ := c49_;
         END IF;
      END IF;
   END IF;

   IF (updated_control_type_ IS NULL) THEN
      IF ((NVL(newrec_.planner_buyer, Database_SYS.string_null_)) != 
          (NVL(oldrec_.planner_buyer, Database_SYS.string_null_))) THEN
         IF (check_only_active_) THEN
            IF ((Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m1_,c12_,today_)) OR 
                (Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m3_,c12_,today_))) THEN
               updated_control_type_ := c12_;
            END IF;
         ELSE
            updated_control_type_ := c12_;
         END IF;
      END IF;
   END IF;

   IF (updated_control_type_ IS NULL) THEN
      IF ((NVL(newrec_.abc_class, Database_SYS.string_null_)) != 
          (NVL(oldrec_.abc_class, Database_SYS.string_null_))) THEN
         IF (check_only_active_) THEN
            IF ((Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m1_,c10_,today_)) OR 
                (Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m3_,c10_,today_))) THEN
               updated_control_type_ := c10_;
            END IF;
         ELSE
            updated_control_type_ := c10_;
         END IF;
      END IF;
   END IF;

   IF (updated_control_type_ IS NULL) THEN
      IF ((NVL(newrec_.type_code, Database_SYS.string_null_)) != 
          (NVL(oldrec_.type_code, Database_SYS.string_null_))) THEN
         IF (check_only_active_) THEN
            IF ((Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m1_,c6_,today_)) OR 
                (Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m3_,c6_,today_))) THEN
               updated_control_type_ := c6_;
            END IF;
         ELSE
            updated_control_type_ := c6_;
         END IF;
      END IF;
   END IF;

   IF (updated_control_type_ IS NULL) THEN
      IF ((NVL(newrec_.prime_commodity, Database_SYS.string_null_)) != 
          (NVL(oldrec_.prime_commodity, Database_SYS.string_null_))) THEN
         IF (check_only_active_) THEN
            IF ((Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m1_,c7_,today_)) OR 
                (Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m3_,c7_,today_))) THEN
               updated_control_type_ := c7_;
            END IF;
         ELSE
            updated_control_type_ := c7_;
         END IF;
      END IF;
   END IF;

   IF (updated_control_type_ IS NULL) THEN
      IF ((NVL(newrec_.second_commodity, Database_SYS.string_null_)) != 
          (NVL(oldrec_.second_commodity, Database_SYS.string_null_))) THEN
         IF (check_only_active_) THEN
            IF ((Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m1_,c8_,today_)) OR 
                (Posting_Ctrl_Public_API.Is_Ctrl_Type_Used_On_Post_Type(company_,m3_,c8_,today_))) THEN
               updated_control_type_ := c8_;
            END IF;
         ELSE
            updated_control_type_ := c8_;
         END IF;
      END IF;
   END IF;

   RETURN (updated_control_type_);
END Get_Updated_Control_Type___;


PROCEDURE Check_Standard_Putaway_Qty___(
   standard_putaway_qty_ IN NUMBER )
IS
BEGIN
   IF (standard_putaway_qty_ <= 0) THEN
      Error_SYS.Record_General('InventoryPart','STDPUTAWAYQTY: Standard putaway qty must be greater than zero.');
   END IF;
END Check_Standard_Putaway_Qty___;


PROCEDURE Check_Intrastat_And_Customs___ (
   customs_stat_no_       IN VARCHAR2,
   intrastat_conv_factor_ IN NUMBER )
IS
   customs_unit_meas_ VARCHAR2(10);
BEGIN
   IF (customs_stat_no_ IS NOT NULL) THEN
      customs_unit_meas_ := Customs_Statistics_Number_API.Get_Customs_Unit_Meas(customs_stat_no_);
   END IF;
      
   IF (customs_unit_meas_ IS NULL) THEN
      IF (intrastat_conv_factor_ IS NOT NULL) THEN
         Error_SYS.Record_General(lu_name_, 'NOINTRA1: Intrastat conversion factor cannot have a value if the customs statistics number does not have a unit of measure.');
      END IF;
   ELSE
      IF (intrastat_conv_factor_ IS NULL) THEN
         Error_SYS.Record_General(lu_name_, 'NOINTRA: Intrastat conversion factor must have a value when the customs statistics number has a defined customs unit of measure.');
      END IF;
   END IF;

   IF (intrastat_conv_factor_ <= 0) THEN
      Error_SYS.Record_General(lu_name_, 'INTRACONVGREATER0: The Intrastat conversion factor must be greater than zero.');
   END IF;
END Check_Intrastat_And_Customs___;


FUNCTION Get_Stop_Analysis_Date___ (
   contract_                    IN VARCHAR2,
   part_no_                     IN VARCHAR2,
   site_date_                   IN DATE,
   dist_calendar_id_            IN VARCHAR2,
   manuf_calendar_id_           IN VARCHAR2,
   detect_supplies_not_allowed_ IN BOOLEAN,
   use_expected_leadtime_       IN BOOLEAN,
   lead_time_code_db_           IN VARCHAR2 ) RETURN DATE
IS
   stop_analysis_date_          DATE;
   earliest_stop_analysis_date_ DATE;
   manuf_leadtime_              inventory_part_tab.manuf_leadtime%TYPE;
   purch_leadtime_              inventory_part_tab.purch_leadtime%TYPE;
BEGIN
   Update_Cache___(contract_, part_no_);

   IF (use_expected_leadtime_) THEN
      manuf_leadtime_ := micro_cache_value_.expected_leadtime; 
      purch_leadtime_ := micro_cache_value_.expected_leadtime; 
   ELSE
      manuf_leadtime_ := micro_cache_value_.manuf_leadtime; 
      purch_leadtime_ := micro_cache_value_.purch_leadtime; 
   END IF;

   IF (micro_cache_value_.earliest_ultd_supply_date IS NOT NULL) THEN
      earliest_stop_analysis_date_ := Work_Time_Calendar_API.Get_Previous_Work_Day(dist_calendar_id_,
                                                                                   micro_cache_value_.earliest_ultd_supply_date);
   END IF;

   IF ((detect_supplies_not_allowed_) AND
       (Inventory_Part_Status_Par_API.Get_Supply_Flag_Db(micro_cache_value_.part_status) =
                                                          Inventory_Part_Supply_Flag_API.DB_SUPPLIES_NOT_ALLOWED)) THEN
      -- Setting a stop analys date that indicates an "infinite" leadtime.
      -- The "minus 1" is because calling methods sometimes adds one day to the returned
      -- date and that causes an error.
      stop_analysis_date_ := Database_SYS.last_calendar_date_ -1;
   ELSE
      IF (lead_time_code_db_ = Inv_Part_Lead_Time_Code_API.DB_PURCHASED) THEN
         -- Purchased
         stop_analysis_date_ := trunc(site_date_) + purch_leadtime_;
         stop_analysis_date_ := GREATEST(stop_analysis_date_, NVL(earliest_stop_analysis_date_, stop_analysis_date_));
         -- The same method as Get_Closest_Work_Day but without internal error handling.
         stop_analysis_date_ := Work_Time_Calendar_API.Get_Nearest_Work_Day (dist_calendar_id_, stop_analysis_date_);
      ELSE
         -- Manufactured
         stop_analysis_date_ := Work_Time_Calendar_API.Get_End_Date(manuf_calendar_id_,
                                                                    site_date_,
                                                                    manuf_leadtime_);
      END IF;
   END IF;

   RETURN stop_analysis_date_;
END Get_Stop_Analysis_Date___;


PROCEDURE Get_Default_Site_And_Uom___ (
   contract_      OUT VARCHAR2,
   unit_meas_     OUT VARCHAR2,
   part_no_       IN  VARCHAR2,
   unit_category_ IN  VARCHAR2 DEFAULT 'INVENT' )
IS
   part_rec_        inventory_part_tab%ROWTYPE;
   catch_unit_meas_ inventory_part_tab.catch_unit_meas%TYPE;

   CURSOR get_attr IS
      SELECT unit_meas, catch_unit_meas, contract
      FROM inventory_part_tab
      WHERE part_no = part_no_
      ORDER BY create_date;
BEGIN
   contract_ := User_Allowed_Site_API.Get_Default_Site();
   part_rec_  := Get_Object_By_Keys___(contract_,part_no_);

   IF (unit_category_ = 'INVENT' AND part_rec_.unit_meas IS NULL) OR
      (unit_category_ = 'CATCH' AND part_rec_.catch_unit_meas IS NULL) THEN
      -- fetch first available unit_meas and contract if this part dont exist on user default site
      OPEN get_attr;
      FETCH get_attr INTO unit_meas_, catch_unit_meas_, contract_;
      CLOSE get_attr;
      IF (unit_category_ = 'CATCH' AND catch_unit_meas_ IS NOT NULL) THEN
         unit_meas_ := catch_unit_meas_;
      ELSIF (unit_category_ = 'CATCH' AND catch_unit_meas_ IS NULL) THEN
         unit_meas_ := NULL;
      END IF;
   ELSIF (unit_category_ = 'INVENT' AND part_rec_.unit_meas IS NOT NULL) THEN
      unit_meas_ := part_rec_.unit_meas;
   ELSIF (unit_category_ = 'CATCH' AND part_rec_.catch_unit_meas IS NOT NULL) THEN
      unit_meas_ := part_rec_.catch_unit_meas;
   END IF;

   -- do not return UoM for catch unit if it is not enabled on Part Catalog
   IF (unit_category_ = 'CATCH') AND (Part_Catalog_API.Get_Catch_Unit_Enabled_Db(part_no_) = 'FALSE') THEN
      unit_meas_ := NULL;
   END IF;
END Get_Default_Site_And_Uom___;


PROCEDURE Add_To_Purchase_Order___ (
   order_no_            OUT VARCHAR2,
   contract_            IN  VARCHAR2,
   part_no_             IN  VARCHAR2,
   inventory_unit_qty_  IN  NUMBER,
   inventory_unit_meas_ IN  VARCHAR2,
   wanted_receipt_date_ IN  DATE,
   authorize_code_      IN  VARCHAR2 )
IS
BEGIN
   $IF Component_Purch_SYS.INSTALLED $THEN
      Purchase_Order_API.Prepare_Order(order_no_, 
                                       contract_, 
                                       part_no_,
                                       inventory_unit_qty_, 
                                       inventory_unit_meas_, 
                                       Order_Supply_Type_API.Decode('IO'), 
                                       wanted_receipt_date_, 
                                       authorize_code_, 
                                       is_order_proposal_ => 'TRUE');
   $ELSE
      Error_SYS.Component_Not_Exist('PURCH');
   $END
END Add_To_Purchase_Order___;


PROCEDURE Mod_Earliest_Ultd_Sply_Date___ (
   date_modified_        OUT BOOLEAN, 
   contract_             IN  VARCHAR2,
   part_no_              IN  VARCHAR2,
   planned_receipt_date_ IN  DATE,
   backdate_allowed_db_  IN  VARCHAR2 )
IS
   earliest_ultd_supply_date_ DATE;
   oldrec_                    inventory_part_tab%ROWTYPE;
BEGIN
   IF (planned_receipt_date_ IS NOT NULL) THEN
      earliest_ultd_supply_date_ := Work_Time_Calendar_Api.Get_Nearest_Work_Day(Site_API.Get_Dist_Calendar_Id(contract_), (planned_receipt_date_ + 1));
   END IF;
   
   oldrec_        := Get_Object_By_Keys___(contract_, part_no_);
   date_modified_ := FALSE;
   
   IF (NVL(earliest_ultd_supply_date_       , Database_SYS.first_calendar_date_) != 
       NVL(oldrec_.earliest_ultd_supply_date, Database_SYS.first_calendar_date_)) THEN
       -- There is a difference and we have a reason to update
      IF ((backdate_allowed_db_ = Fnd_Boolean_API.DB_TRUE) OR
         (NVL(earliest_ultd_supply_date_       , Database_SYS.first_calendar_date_) >
          NVL(oldrec_.earliest_ultd_supply_date, Database_SYS.first_calendar_date_))) THEN
          -- If either the new date is greater than the old date OR we are allowed to update
          -- to an older date, then update.
         oldrec_ := Lock_by_Keys___(contract_, part_no_);
         oldrec_.earliest_ultd_supply_date := earliest_ultd_supply_date_;
         Modify___(oldrec_);
         date_modified_ := TRUE;
      END IF;
   END IF;
END Mod_Earliest_Ultd_Sply_Date___;

-----------------------------------------------------------------------------
-------------------- FOUNDATION1 METHODS ------------------------------------
-----------------------------------------------------------------------------


--@IgnoreMissingSysinit
PROCEDURE Init
IS
BEGIN
   NULL;
END Init;

PROCEDURE Post_Installation_View
IS
   stmt_ CLOB;
   eol_  VARCHAR2(2) := chr(13)||chr(10);
BEGIN
   General_SYS.Init_Method(Inventory_Part_API.lu_name_, 'Inventory_Part_API', 'Post_Installation_View');
      stmt_ := 'CREATE OR REPLACE VIEW INVENTORY_PART_LOV_MRP AS'||eol_;
      stmt_ := stmt_ || 'SELECT ip.contract                                                   contract,'||eol_;
      stmt_ := stmt_ || '       ip.part_no                                                    part_no,'||eol_;
      stmt_ := stmt_ || '       Inventory_Part_API.Get_Description(ip.contract, ip.part_no)   description,'||eol_;
      stmt_ := stmt_ || '       ip.dim_quality                                                dim_quality,'||eol_;
      stmt_ := stmt_ || '       Material_Requis_Supply_API.Decode(ip.supply_code)             supply_code,'||eol_;
      stmt_ := stmt_ || '       ip.supply_code                                                supply_code_db,'||eol_;
      stmt_ := stmt_ || '       ip.rowkey                                                     objkey'||eol_;
      stmt_ := stmt_ || 'FROM   inventory_part_tab ip, inventory_part_planning_tab ip_plan, user_allowed_site_pub ua, part_catalog_pub pc, inventory_part_status_par_pub ips'||eol_;
      stmt_ := stmt_ || 'WHERE  ip.contract = ua.site'||eol_;
      stmt_ := stmt_ || 'AND    ip.contract = ip_plan.contract'||eol_;
      stmt_ := stmt_ || 'AND    ip.part_no  = ip_plan.part_no'||eol_;
      stmt_ := stmt_ || 'AND    ip_plan.planning_method NOT IN (''O'',''T'',''K'')'||eol_;
      stmt_ := stmt_ || 'AND    ip.part_no       = pc.part_no'||eol_;
      stmt_ := stmt_ || 'AND    pc.position_part = ''NOT POSITION PART'''||eol_;
      stmt_ := stmt_ || 'AND    ip.part_status     = ips.part_status'||eol_;
      stmt_ := stmt_ || 'AND    ips.demand_flag_db = ''Y'''||eol_;
   IF Dictionary_SYS.Component_Is_Active('PURCH') THEN
      stmt_ := stmt_ || 'UNION ALL'||eol_;
      stmt_ := stmt_ || 'SELECT contract                                                      contract,'||eol_;
      stmt_ := stmt_ || '       part_no                                                       part_no,'||eol_;
      stmt_ := stmt_ || '       part_description_in_use                                       description,'||eol_;
      stmt_ := stmt_ || '       NULL                                                          dim_quality,'||eol_;
      stmt_ := stmt_ || '       Material_Requis_Supply_API.Decode(''PO'')                       supply_code,'||eol_;
      stmt_ := stmt_ || '       ''PO''                                                          supply_code_db,'||eol_;
      stmt_ := stmt_ || '       objkey                                                        objkey'||eol_;
      stmt_ := stmt_ || 'FROM   PURCHASE_PART_LOV6'||eol_;
   END IF;
      stmt_ := stmt_ || 'WITH READ ONLY';
      
      -- ifs_assert_safe codegen
      EXECUTE IMMEDIATE stmt_;
      -- ifs_assert_safe codegen
      EXECUTE IMMEDIATE 'COMMENT ON TABLE INVENTORY_PART_LOV_MRP
         IS ''LU=InventoryPart^PROMPT=Inventory Part^MODULE=INVENT^''';
      -- ifs_assert_safe codegen
      EXECUTE IMMEDIATE 'COMMENT ON COLUMN INVENTORY_PART_LOV_MRP.contract
         IS ''FLAGS=PMI--^DATATYPE=STRING(5)/UPPERCASE^PROMPT=Site^REF=Site/NOCHECK^''';
      -- ifs_assert_safe codegen
      EXECUTE IMMEDIATE 'COMMENT ON COLUMN INVENTORY_PART_LOV_MRP.part_no
         IS ''FLAGS=KMI-L^DATATYPE=STRING(25)/UPPERCASE^PROMPT=Part No^REF=PartCatalog/NOCHECK^''';
      -- ifs_assert_safe codegen
      EXECUTE IMMEDIATE 'COMMENT ON COLUMN INVENTORY_PART_LOV_MRP.description
         IS ''FLAGS=A---L^DATATYPE=STRING(200)^PROMPT=Description^''';
      -- ifs_assert_safe codegen
      EXECUTE IMMEDIATE 'COMMENT ON COLUMN INVENTORY_PART_LOV_MRP.dim_quality
         IS ''FLAGS=A---L^PROMPT=Dim/Quality^DATATYPE=STRING(25)^''';
      -- ifs_assert_safe codegen
      EXECUTE IMMEDIATE 'COMMENT ON COLUMN INVENTORY_PART_LOV_MRP.supply_code
         IS ''FLAGS=AMIUL^DATATYPE=STRING(200)^ENUMERATION=MaterialRequisSupply^PROMPT=Default Mtr Req Supply^''';
      -- ifs_assert_safe codegen
      EXECUTE IMMEDIATE 'COMMENT ON COLUMN INVENTORY_PART_LOV_MRP.supply_code_db
         IS ''FLAGS=A----^DATATYPE=STRING(3)^PROMPT=Default Mtr Req Supply^''';
END Post_Installation_View;

BEGIN
   Init;
END Inventory_Part_API;
-- [END IFS COMPLETE BLOCK]
/
SHOW ERROR

GRANT EXECUTE ON Inventory_Part_API TO IFSSYS
/
