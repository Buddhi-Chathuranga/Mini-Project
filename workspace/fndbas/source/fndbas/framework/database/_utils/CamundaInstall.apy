PROMPT Creating CAMUNDA_INSTALL_SYS implementation

-- [IFS COMPLETE BLOCK PACKAGEBODY CAMUNDA_INSTALL_SYS]
CREATE OR REPLACE PACKAGE BODY &CAMUNDA_APPOWNER..CAMUNDA_INSTALL_SYS IS

-----------------------------------------------------------------------------
-------------------- PRIVATE DECLARATIONS -----------------------------------
-----------------------------------------------------------------------------

begin_mark_    CONSTANT VARCHAR2(2)   := '[';

end_mark_      CONSTANT VARCHAR2(2)   := ']';

begin_         CONSTANT VARCHAR2(2)   := '[';

end_           CONSTANT VARCHAR2(2)   := ']';

nl_            CONSTANT VARCHAR2(2)   := chr(10);

verbose_                BOOLEAN       := FALSE;

-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION METHOD DECLARATIONS ---------------------
-----------------------------------------------------------------------------

PROCEDURE Alter_Table_Column___ (
   procedure_name_  IN VARCHAR2,
   table_name_      IN VARCHAR2,
   alter_type_      IN VARCHAR2,
   column_          IN ColRec,
   show_info_       IN BOOLEAN DEFAULT FALSE );

FUNCTION Is_Table_Temporary___ (
   table_name_ IN VARCHAR2 ) RETURN BOOLEAN;

PROCEDURE Move_Index___ (
   procedure_name_  IN VARCHAR2,
   index_name_      IN VARCHAR2,
   tablespace_name_ IN VARCHAR2 DEFAULT 'IFSAPP_INDEX',
   show_info_       IN BOOLEAN  DEFAULT FALSE,
   forced_offline_  IN BOOLEAN  DEFAULT FALSE);

PROCEDURE Move_Table___ (
   procedure_name_  IN VARCHAR2,
   table_name_      IN VARCHAR2,
   tablespace_name_ IN VARCHAR2 DEFAULT 'IFSAPP_DATA',
   show_info_       IN BOOLEAN  DEFAULT FALSE );

PROCEDURE Rebuild_Index___ (
   procedure_name_   IN VARCHAR2,
   index_name_       IN VARCHAR2,
   show_info_        IN BOOLEAN  DEFAULT FALSE,
   table_name_       IN VARCHAR2 DEFAULT NULL);

PROCEDURE Remove_Constraints___ (
   procedure_name_  IN VARCHAR2,
   table_name_      IN VARCHAR2,
   constraint_name_ IN VARCHAR2 DEFAULT '%',
   show_info_       IN BOOLEAN  DEFAULT FALSE );

PROCEDURE Remove_Extended_Stats___ (
   table_name_ IN VARCHAR2,
   column_name_  IN VARCHAR2 );

PROCEDURE Remove_Indexes___ (
   procedure_name_  IN VARCHAR2,
   table_name_ IN VARCHAR2,
   index_name_ IN VARCHAR2 DEFAULT '%',
   show_info_  IN BOOLEAN  DEFAULT FALSE );

PROCEDURE Remove_Triggers___ (
   procedure_name_ IN VARCHAR2,
   table_name_     IN VARCHAR2,
   trigger_name_   IN VARCHAR2 DEFAULT '%',
   show_info_      IN BOOLEAN  DEFAULT FALSE );

PROCEDURE Run_Ddl_Command___ (
   stmt_      IN VARCHAR2,
   procedure_ IN VARCHAR2,
   show_info_ IN BOOLEAN DEFAULT FALSE,
   raise_     IN BOOLEAN DEFAULT TRUE,
   debug_     IN BOOLEAN DEFAULT FALSE );


PROCEDURE Show_Message___ (
   message_ IN VARCHAR2 );

FUNCTION Is_Column_Modified___(table_name_ VARCHAR2,
                               column_rec_ IN OUT NOCOPY ColRec) RETURN BOOLEAN;

PROCEDURE Create_Empty_View___ (
   view_name_    IN VARCHAR2,
   columns_      IN ColumnViewType,
   lu_           IN VARCHAR2 DEFAULT NULL,
   module_       IN VARCHAR2 DEFAULT NULL,
   server_only_  IN VARCHAR2 DEFAULT NULL,
   show_info_    IN BOOLEAN  DEFAULT FALSE );

PROCEDURE Alter_View___ (
   view_name_    IN VARCHAR2,
   columns_      IN ColumnViewType,
   show_info_    IN BOOLEAN  DEFAULT FALSE );

PROCEDURE Remove_Context___ (
   procedure_name_  IN VARCHAR2,
   context_name_    IN VARCHAR2,
   show_info_       IN BOOLEAN  DEFAULT FALSE );

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC PUBLIC METHODS -----------------------------
-----------------------------------------------------------------------------

PROCEDURE Add_Lob_Column (
   table_name_  IN VARCHAR2,
   column_      IN ColRec,
   show_info_   IN BOOLEAN DEFAULT FALSE )
IS
   stmt_       VARCHAR2(4000);
   lob_column_ ColRec := column_;
BEGIN
   IF (NOT Column_Exist(table_name_, column_.column_name)) THEN
      IF (lob_column_.data_type NOT IN ('CLOB', 'NCLOB', 'BLOB')) THEN
         Show_Message___('Add_Lob_Column error: This method can only be used for BLOB or CLOB columns.');
         RETURN;
      END IF;
      lob_column_.nullable := 'Y'; -- First set the column to NULLABLE
      stmt_ := 'ALTER TABLE ' || table_name_ || ' ADD ' || lob_column_.column_name || ' ' || lob_column_.data_type;
      IF NOT Is_Table_Temporary___(table_name_) THEN
         IF (Upper(lob_column_.lob_parameter) LIKE Upper('%LOB%(%' || lob_column_.column_name || '%)%')) THEN -- Check if column name is supplied as lob parameter
            NULL;
         ELSE
            stmt_ := stmt_ || ' LOB (' || lob_column_.column_name || ') ';
         END IF;
         stmt_ := stmt_ || ' ' || Replace(Upper(lob_column_.lob_parameter), 'DISABLE STORAGE IN ROW', 'ENABLE STORAGE IN ROW');
         -- Look for STORE AS and replace it with STORE AS SECUREFILE if SECUREFILE is missing
         stmt_ := Regexp_Replace(upper(stmt_), 'STORE +AS *\(', 'STORE AS SECUREFILE (');
      END IF;
      Run_Ddl_Command___ (stmt_, 'Add_Lob_Column', show_info_, TRUE);
      IF column_.nullable = 'N' THEN
         stmt_ := 'UPDATE '||table_name_||' SET '||lob_column_.column_name||'='||
                  CASE lob_column_.data_type
                  WHEN 'CLOB' THEN
                     'empty_clob() '
                  WHEN 'NCLOB' THEN
                     'empty_clob() '
                  WHEN 'BLOB' THEN
                     'empty_blob() '
                  END
                  ||' WHERE '||lob_column_.column_name||' IS NULL';
         IF show_info_ THEN
            Show_Message___('Add_Lob_Column: Updated Lob column to empty Lob.');
         END IF;
         Run_Ddl_Command___ (stmt_, 'Add_Lob_Column', show_info_, TRUE);
         lob_column_.nullable      := 'N'; -- Set column to NOT NULLABLE
         lob_column_.lob_parameter := NULL;
         lob_column_.data_type := NULL;
         Alter_Table_Column___('Add_Lob_Column', table_name_, 'MODIFY', lob_column_, show_info_);
      END IF;
   ELSE
      IF show_info_ AND verbose_ THEN
         Show_Message___('Add_Lob_Column: Column ' || column_.column_name || ' already exist in table ' || table_name_||'.');
      END IF;
      RETURN;
   END IF;
END Add_Lob_Column;


PROCEDURE Alter_Lob_Column (
   table_name_  IN VARCHAR2,
   column_      IN ColRec,
   show_info_   IN BOOLEAN DEFAULT FALSE )
IS
   stmt_       VARCHAR2(4000);
   lob_column_ ColRec := column_;
BEGIN
   IF (Column_Exist(table_name_, column_.column_name)) THEN
      IF (column_.data_type NOT IN ('CLOB', 'BLOB')) THEN
         Show_Message___('Alter_Lob_Column error: This method can only be used for BLOB or CLOB columns.');
         RETURN;
      END IF;
      IF Is_Table_Temporary___(table_name_) THEN
         Show_Message___('Alter_Lob_Column error: Lob columns in temporary tables should not be modified. Drop and recreate the table instead.');
         RETURN;
      END IF;
      IF (column_.lob_parameter IS NOT NULL) THEN
         stmt_ := 'ALTER TABLE ' || table_name_ || ' MODIFY LOB (' || column_.column_name || ') ' || column_.lob_parameter;
         -- Look for STORE AS and replace it with STORE AS SECUREFILE if SECUREFILE is missing
         stmt_ := Regexp_Replace(upper(stmt_), 'STORE +AS *\(', 'STORE AS SECUREFILE (');
         Run_Ddl_Command___(stmt_, 'Alter_Lob_Column', show_info_);
         Show_Message___('Alter_Lob_Column' || ': Lob parameters of Column ' || column_.column_name || ' in table ' || table_name_||' are modified.'); 
      END IF;
      lob_column_.lob_parameter := NULL;
      lob_column_.data_type := NULL;
      Alter_Table_Column___('Alter_Lob_Column', table_name_, 'MODIFY', lob_column_, show_info_); 
   ELSE
      Show_Message___('Alter_Lob_Column error: Column ' || column_.column_name || ' does not exist in table ' || table_name_||'.');
      RETURN;
   END IF;
END Alter_Lob_Column;


PROCEDURE Alter_Table (
   table_name_    IN VARCHAR2,
   columns_       IN ColumnTabType,
   show_info_     IN BOOLEAN DEFAULT FALSE )
IS
   column_           ColRec;
   alter_type_       VARCHAR2(10);
BEGIN
   FOR i IN columns_.FIRST..columns_.LAST LOOP
      column_ := columns_(i);
      IF (Column_Exist(table_name_, column_.column_name)) THEN
         alter_type_ := 'MODIFY';
      ELSE
         alter_type_ := 'ADD';
      END IF;
      Alter_Table_Column___('Alter_Table', table_name_, alter_type_, column_, show_info_);
   END LOOP;
END Alter_Table;


PROCEDURE Alter_Table_Column (
   table_name_  IN VARCHAR2,
   alter_type_  IN VARCHAR2,
   column_      IN ColRec,
   show_info_   IN BOOLEAN DEFAULT FALSE )
IS
BEGIN
   IF (column_.data_type IN ('CLOB', 'BLOB')) THEN
      Show_Message___('Alter_Table_Column error: This method cannot be used for BLOB or CLOB columns.');
      RETURN;
   END IF;
   Alter_Table_Column___('Alter_Table_Column', table_name_, alter_type_, column_, show_info_);
END Alter_Table_Column;


PROCEDURE Alter_Table_Rowmovement (
   table_name_  IN VARCHAR2,
   enable_      IN BOOLEAN,
   show_info_   IN BOOLEAN DEFAULT FALSE )
IS
   stmnt_   VARCHAR2(1000);
   text_    VARCHAR2(10);
BEGIN
   IF enable_ THEN
      text_ := 'ENABLE';
   ELSE
      text_ := 'DISABLE';
   END IF;
   stmnt_ := 'ALTER TABLE ' || table_name_ || ' ' || text_ || ' ROW MOVEMENT';
   Run_Ddl_Command___(stmnt_, 'Alter_Table_Rowmovement', show_info_);
END Alter_Table_Rowmovement;


FUNCTION Column_Exist (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_          NUMBER := 0;
   CURSOR check_column IS
      SELECT   1
      FROM     user_tab_columns
      WHERE    table_name  = UPPER(table_name_)
      AND      column_name = UPPER(column_name_);
BEGIN
   OPEN  check_column;
   FETCH check_column INTO dummy_;
   IF (check_column%FOUND) THEN
      CLOSE check_column;
      RETURN TRUE;
   ELSE
      CLOSE check_column;
      RETURN FALSE;
   END IF;
END Column_Exist;


FUNCTION Constraint_Exist (
   constraint_name_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_          NUMBER := 0;
   CURSOR check_constraint IS
      SELECT  1
      FROM    user_constraints
      WHERE   constraint_name = UPPER(constraint_name_);
BEGIN
   OPEN  check_constraint;
   FETCH check_constraint INTO dummy_;
   IF (check_constraint%FOUND) THEN
      CLOSE check_constraint;
      RETURN TRUE;
   ELSE
      CLOSE check_constraint;
      RETURN FALSE;
   END IF;
END Constraint_Exist;

PROCEDURE Create_Constraint (
   table_name_       IN VARCHAR2,
   constraint_name_  IN VARCHAR2,
   columns_          IN ColumnTabType,
   type_             IN VARCHAR2 DEFAULT 'P',
   index_tablespace_ IN VARCHAR2 DEFAULT NULL,
   storage_          IN VARCHAR2 DEFAULT NULL,
   replace_          IN BOOLEAN  DEFAULT TRUE,
   show_info_        IN BOOLEAN  DEFAULT FALSE,
   use_index_        IN BOOLEAN  DEFAULT TRUE,
   reference_clause_ IN VARCHAR2 DEFAULT NULL,
   on_delete_clause_ IN VARCHAR2 DEFAULT NULL )
IS
   ok_              NUMBER := 1;
   stmnt_           VARCHAR2(32000);
   chk_type_        VARCHAR2(20);
   old_columns_     VARCHAR2(4000);
   old_ref_clause_  VARCHAR2(4000);
   new_columns_     VARCHAR2(4000) := UPPER(Format_Columns(columns_, 'CONSTRAINT'));
BEGIN
   chk_type_    := type_;
   old_columns_ := NULL;
   IF (type_ LIKE 'U%') THEN
      chk_type_ := 'UNIQUE';
   ELSIF (type_ LIKE 'P%') THEN
      chk_type_ := 'PRIMARY KEY';
   ELSIF (type_ LIKE 'F%') THEN
      chk_type_ := 'FOREIGN KEY';
   END IF;
   IF NOT (Table_Exist ( table_name_ ) ) THEN
      IF show_info_ THEN
         Show_Message___ ('Create_Constraint: Table ' || table_name_ || ' does not exist.');
      END IF;
      ok_ := 0;
   END IF;
   IF (Constraint_Exist ( constraint_name_ )) THEN
      IF (replace_ = FALSE) THEN
         IF show_info_ AND verbose_ THEN
            Show_Message___ ('Create_Constraint: Constraint ' || constraint_name_ || ' already exist.');
         END IF;
         ok_ := 0;
      ELSE
         old_columns_ := UPPER(Get_Constraint_Columns ( table_name_, constraint_name_ ));
         IF chk_type_ = 'FOREIGN KEY' THEN
            old_ref_clause_ := UPPER(Get_Referenced_Columns ( table_name_, constraint_name_ ));
         END IF;
         IF new_columns_ = old_columns_ AND (chk_type_ != 'FOREIGN KEY' OR UPPER(reference_clause_) = old_ref_clause_ ) THEN
            IF show_info_ AND verbose_ THEN
               Show_Message___ ('Create_Constraint: Constraint ' || constraint_name_ || ' already exist with same columns.');
            END IF;
            ok_ := 0;
         ELSE
            Remove_Constraints___('Create_Constraint', table_name_, constraint_name_, show_info_);
            IF (Constraint_Exist ( constraint_name_ ) ) THEN
               Show_Message___ ('Create_Constraint: Constraint ' || constraint_name_ || ' exists for other table with same name.');
               ok_ := 0;
            END IF;
         END IF;
      END IF;
   ELSIF (chk_type_ = 'PRIMARY KEY' AND
          Primary_Key_Constraint_Exist(table_name_)) THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___ ('Create_Constraint: Primary Key Constraint for table ' || table_name_|| ' already exist.');
      END IF;
      ok_ := 0;
   END IF;
   IF (ok_ = 1) THEN
      stmnt_ :=  'ALTER TABLE ' || table_name_ || ' ADD CONSTRAINT ' || constraint_name_ || ' ';
      stmnt_ :=  stmnt_ || chk_type_ || ' (' || new_columns_ || ') ';
      IF (reference_clause_ IS NOT NULL) THEN
         IF (chk_type_ = 'FOREIGN KEY') THEN
            stmnt_ := stmnt_ || ' ' || reference_clause_;
         END IF;
      END IF;
      IF (use_index_) THEN
         stmnt_ :=  stmnt_ || ' USING INDEX  ';
         IF NOT Is_Table_Temporary___(table_name_) THEN
               stmnt_ := stmnt_ || ' TABLESPACE ' || index_tablespace_;
            IF (storage_ IS NOT NULL) THEN
               IF Upper(storage_) LIKE '%INITIAL%' THEN
                  stmnt_ := stmnt_ || ' STORAGE (' || storage_ || ')';
               ELSE
                  stmnt_ := stmnt_ || ' STORAGE (INITIAL ' || storage_ || ')';
               END IF;
            END IF;
         END IF;
      END IF;
      IF (on_delete_clause_ IS NOT NULL) THEN
         IF (chk_type_ = 'FOREIGN KEY') THEN
            stmnt_ := stmnt_ || ' ' || on_delete_clause_;
         END IF;
      END IF;
      Run_Ddl_Command___(stmnt_, 'Create_Constraint', show_info_);
      IF show_info_ THEN
         Show_Message___ ('Create_Constraint: Constraint ' || constraint_name_ || ' (' || new_columns_ || ') created.');
      END IF;
   END IF;
END Create_Constraint;


PROCEDURE Create_Context (
   context_name_      IN VARCHAR2,
   context_package_   IN VARCHAR2,
   initialized_       IN VARCHAR2 DEFAULT NULL,
   accessed_          IN VARCHAR2 DEFAULT NULL,
   show_info_         IN BOOLEAN  DEFAULT FALSE )
IS
   stmnt_          VARCHAR2(32000);
   init_stmnt_     VARCHAR2(100);
   accessed_stmnt_ VARCHAR2(100);

   context_exists  EXCEPTION;
   PRAGMA          EXCEPTION_INIT(context_exists, -1408);
BEGIN
   IF (initialized_ IS NULL) THEN
      init_stmnt_       := NULL;
   ELSIF (initialized_ = 'GLOBALLY') THEN
      init_stmnt_       := ' INITIALIZED GLOBALLY ';
   ELSIF (initialized_ = 'EXTERNALLY') THEN
      init_stmnt_       := ' INITIALIZED EXTERNALLY ';
   ELSE
      NULL;
   END IF;
   IF (accessed_ IS NULL) THEN
      accessed_stmnt_   := NULL;
   ELSIF (accessed_ = 'GLOBALLY') THEN
      accessed_stmnt_   := ' ACCESSED GLOBALLY ';
   ELSE
      NULL;
   END IF;
   stmnt_ :=  'CREATE OR REPLACE CONTEXT ' || context_name_ ||' USING ' || context_package_ || init_stmnt_ || accessed_stmnt_;
   Run_Ddl_Command___(stmnt_, 'Create_Context', show_info_);
   IF show_info_ THEN
      Show_Message___ ('Create_Context: Context ' || context_name_ || ' created.');
   END IF;
EXCEPTION
   WHEN context_exists THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___('Create_Context: Context ' || context_name_ || ' already exists.');
      END IF;
END Create_Context;


PROCEDURE Create_Directory (
   directory_name_  IN VARCHAR2,
   path_            IN VARCHAR2,
   read_grant_      IN BOOLEAN  DEFAULT TRUE,
   write_grant_     IN BOOLEAN  DEFAULT TRUE,
   show_info_       IN BOOLEAN  DEFAULT FALSE )
IS
   stmnt_          VARCHAR2(32000);
BEGIN
   stmnt_ :=  'CREATE OR REPLACE DIRECTORY ' || directory_name_ ||' AS ''' || path_ || '''';
   Run_Ddl_Command___(stmnt_, 'Create_Directory', show_info_);
   IF read_grant_ THEN
      stmnt_ := ' GRANT read ON DIRECTORY ' || directory_name_ || ' TO ' || Sys_Context('USERENV', 'CURRENT_SCHEMA');
      --Run_Ddl_Command___(stmnt_, 'Create_Directory (Grant read): ', show_info_);
   END IF;
   IF write_grant_ THEN
      stmnt_ := 'GRANT write ON DIRECTORY ' || directory_name_ || ' TO ' || Sys_Context('USERENV', 'CURRENT_SCHEMA');
      --Run_Ddl_Command___(stmnt_, 'Create_Directory (Grant write): ', show_info_);
   END IF;
   IF show_info_ THEN
      Show_Message___ ('Create_Directory: Directory ' || directory_name_ || ' created.');
   END IF;
END Create_Directory;


PROCEDURE Create_Index (
   table_name_      IN VARCHAR2,
   index_name_      IN VARCHAR2,
   columns_         IN ColumnTabType,
   type_            IN VARCHAR2 DEFAULT 'N',
   tablespace_      IN VARCHAR2 DEFAULT NULL,
   storage_         IN VARCHAR2 DEFAULT NULL,
   replace_         IN BOOLEAN  DEFAULT TRUE,
   show_info_       IN BOOLEAN  DEFAULT FALSE,
   exception_       IN BOOLEAN  DEFAULT FALSE,
   expression_      IN BOOLEAN  DEFAULT FALSE  )
IS
   ok_             NUMBER := 1;
   stmnt_          VARCHAR2(32000);
   chk_type_       VARCHAR2(20);
   old_columns_    VARCHAR2(4000);
   new_columns_    VARCHAR2(4000) := UPPER(Format_Columns(columns_, 'INDEX'));
   old_uniqueness_ VARCHAR2(10);
   new_uniqueness_ VARCHAR2(10);
   temp_table_     BOOLEAN := FALSE;
   old_expression_ VARCHAR2(32767);
   
   column_already_indexed EXCEPTION;
   PRAGMA                 EXCEPTION_INIT(column_already_indexed, -1408);
   non_unique_values_exists  EXCEPTION;
   PRAGMA                 EXCEPTION_INIT(non_unique_values_exists, -1452);
BEGIN
   chk_type_       := type_;
   old_columns_    := NULL;
   old_uniqueness_ := NULL;
   IF (UPPER(type_) LIKE 'U%') THEN
      chk_type_       := 'UNIQUE';
      new_uniqueness_ := 'UNIQUE';
   ELSIF (UPPER(type_) LIKE 'N%') THEN
      chk_type_       := NULL;
      new_uniqueness_ := 'NONUNIQUE';
   END IF;
   IF NOT (Table_Exist ( table_name_ ) ) THEN
      IF show_info_ THEN
         Show_Message___ ('Create_Index: Table ' || table_name_ || ' does not exist.');
      END IF;
      ok_ := 0;
   ELSIF (Index_Exist ( index_name_ ) ) THEN
      IF (replace_ = FALSE) THEN
         IF show_info_ AND verbose_ THEN
            Show_Message___ ('Create_Index: Index ' || index_name_ || ' already exist.');
         END IF;
         ok_ := 0;
      ELSE
         old_columns_    := UPPER(Get_Index_Columns ( table_name_, index_name_ ));
         old_uniqueness_ := Get_Index_Uniqueness ( table_name_, index_name_ );
         
         IF expression_ THEN
            old_expression_ := Get_Index_Expression(table_name_, index_name_);
         END IF;
         
         IF (expression_ AND old_expression_ = UPPER(new_columns_)) OR (old_columns_ = new_columns_ AND
                                                                 old_uniqueness_ = new_uniqueness_) THEN
            IF show_info_ AND verbose_ THEN
               Show_Message___ ('Create_Index: Index ' || index_name_ || ' already exist with same uniqueness/columns/expression.');
            END IF;
            ok_ := 0;
         ELSE
            Remove_Indexes___('Create_Index', table_name_, index_name_, show_info_ );
            IF (Index_Exist ( index_name_ ) ) THEN
               Show_Message___ ('Create_Index: Index ' || index_name_ || ' exists for other table with same name.');               
               ok_ := 0;
            END IF;
         END IF;
      END IF;
   END IF;
   IF (ok_ = 1) THEN
      stmnt_ :=  'CREATE ' || chk_type_ || ' INDEX ' || index_name_ || ' ';
      stmnt_ :=  stmnt_ || ' ON '||table_name_ || '(' || new_columns_ || ') ';
      temp_table_ := Is_Table_Temporary___ (table_name_);
      IF (tablespace_ IS NOT NULL) THEN
         IF (NOT temp_table_) THEN --Temporary tables cant have tablespaces
            stmnt_ := stmnt_ || ' TABLESPACE ' || tablespace_;
         END IF;
      END IF;
      IF temp_table_ = FALSE THEN
         stmnt_ := stmnt_ || ' PARALLEL NOLOGGING ';
      END IF;
      IF (storage_ IS NOT NULL) THEN
         IF Upper(storage_) LIKE '%INITIAL%' THEN
            stmnt_ := stmnt_ || ' STORAGE (' || storage_ || ')';
         ELSE
            stmnt_ := stmnt_ || ' STORAGE (INITIAL ' || storage_ || ')';
         END IF;
      END IF;
      Run_Ddl_Command___(stmnt_, 'Create_Index', show_info_);
      IF show_info_ THEN
         Show_Message___ ('Create_Index: Index ' || index_name_ || ' (' || LOWER(new_columns_) || ') (' || LOWER(new_uniqueness_) || ') created.');
      END IF;
   END IF;
EXCEPTION
   WHEN column_already_indexed THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___('Create_Index: Columns (' || new_columns_ || ') for table ' || table_name_ || ' already indexed.');
      END IF;
      IF (exception_) THEN
         RAISE;
      END IF;
   WHEN non_unique_values_exists THEN
      Show_Message___('Create_Index: Non unique values for columns (' || new_columns_ || ') for table ' || table_name_ || ' exists.');
      IF (exception_) THEN
         RAISE;
      END IF;
END Create_Index;


PROCEDURE Create_Sequence (
   sequence_     IN VARCHAR2,
   parameters_   IN VARCHAR2,
   show_info_    IN BOOLEAN  DEFAULT FALSE )
IS
   stmnt_           VARCHAR2(2000);
   ok_              NUMBER := 1;
BEGIN
   IF (Object_Exist ( sequence_, 'SEQUENCE')) THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___ ('Create_Sequence: Sequence ' || sequence_ || ' already exist.');
      END IF;
      ok_ := 0;
   END IF;
   IF (ok_ = 1) THEN
      stmnt_ := 'CREATE SEQUENCE ' || sequence_ || ' ' || parameters_;
      Run_Ddl_Command___(stmnt_, 'Create_Sequence', show_info_);
      IF show_info_ THEN
         Show_Message___('Create_Sequence: Sequence ' || sequence_ || ' created.');
      END IF;
   END IF;
END Create_Sequence;


PROCEDURE Create_Text_Index (
   index_name_      IN VARCHAR2,
   table_name_      IN VARCHAR2,
   column_name_     IN VARCHAR2,
   parameters_      IN VARCHAR2,
   replace_         IN BOOLEAN  DEFAULT TRUE,
   show_info_       IN BOOLEAN  DEFAULT FALSE )
IS
   ok_             NUMBER := 1;
   stmnt_          VARCHAR2(32000);
   --
BEGIN
   IF NOT (Table_Exist ( table_name_ ) ) THEN
      IF show_info_ THEN
         Show_Message___ ('Create_Text_Index: Table ' || table_name_ || ' does not exist.');
      END IF;
      ok_ := 0;
   ELSIF (Text_Index_Exist ( index_name_ ) ) THEN
      IF (replace_ = FALSE) THEN
         IF show_info_ AND verbose_ THEN
            Show_Message___ ('Create_Text_Index: Index ' || index_name_ || ' already exist.');
         END IF;
         ok_ := 0;
      ELSE
         Remove_Indexes___('Create_Text_Index', table_name_, index_name_, show_info_ );
         IF (Text_Index_Exist ( index_name_ ) ) THEN            
            Show_Message___ ('Create_Text_Index: Index ' || index_name_ || ' exists for other table with same name.');
            ok_ := 0;
         END IF;
      END IF;
   END IF;
   IF (ok_ = 1) THEN
      stmnt_ := 'CREATE INDEX '||index_name_||' ON '||table_name_||'('||column_name_||') INDEXTYPE IS CTXSYS.CONTEXT ';
      IF (Is_Option_Available('Online Index Build')) THEN -- Check if Online Index Rebuild is available.
         stmnt_ := stmnt_ || ' ONLINE ';
      END IF;
      stmnt_ := stmnt_ || ' PARAMETERS ('||parameters_||') ';
      Run_Ddl_Command___(stmnt_, 'Create_Text_Index', show_info_);
      IF show_info_ THEN
         Show_Message___ ('Create_Text_Index: Index ' || index_name_ || ' created.');
      END IF;
   END IF;
END Create_Text_Index;


PROCEDURE Create_Trigger (
   trigger_name_  IN VARCHAR2,
   trigger_type_  IN VARCHAR2,
   dml_event_     IN VARCHAR2,
   columns_       IN ColumnTabType,
   table_name_    IN VARCHAR2,
   condition_     IN VARCHAR2,
   plsql_block_   IN VARCHAR2,
   show_info_     IN BOOLEAN  DEFAULT FALSE ) 
IS
   stmnt_            VARCHAR2(32000);
   new_line_         VARCHAR2(2) := chr(13)||chr(10);
   indent_           VARCHAR2(3) := '   ';
BEGIN
   stmnt_ := 'CREATE OR REPLACE TRIGGER ' || UPPER(trigger_name_) || new_line_;
   stmnt_ := stmnt_ || indent_ || UPPER(trigger_type_) || ' ';   
   IF dml_event_ = 'UPDATE' AND columns_.First IS NOT NULL THEN      
      stmnt_ := stmnt_ || 'UPDATE OF ' || UPPER(Format_Columns (columns_, 'TRIGGER')); 
   ELSE
      stmnt_ := stmnt_ || UPPER(dml_event_);
   END IF;
   stmnt_ := stmnt_ || ' ON ' || table_name_ || new_line_;
   stmnt_ := stmnt_ || indent_ || 'FOR EACH ROW ' || new_line_;
   IF condition_ IS NOT NULL THEN
      stmnt_ := stmnt_ || indent_ || 'WHEN (' || condition_ ||')'|| new_line_;
   END IF;
   stmnt_ := stmnt_ || 'BEGIN ' || new_line_;   
   stmnt_ := stmnt_ || indent_ || REPLACE(LTRIM(plsql_block_, ' '), chr(10), chr(10) || indent_) || new_line_;
   stmnt_ := stmnt_ || 'END;';
   Run_Ddl_Command___(stmnt_, 'Create_Trigger', show_info_);
   IF show_info_ THEN
      Show_Message___ ('Create_Trigger: Trigger ' || trigger_name_ || ' created.');
   END IF;
EXCEPTION
   WHEN OTHERS THEN
      Disable_Trigger(trigger_name_, show_info_);
      Raise_Application_Error(-20150,'Error when creating trigger.');
END Create_Trigger;


PROCEDURE Disable_Trigger (
   trigger_name_  IN VARCHAR2,
   show_info_     IN BOOLEAN  DEFAULT FALSE ) 
IS
   stmnt_            VARCHAR2(32000);
BEGIN
   IF Trigger_Exist(trigger_name_) THEN
      stmnt_ := 'ALTER TRIGGER ' || trigger_name_ || ' DISABLE ';
      Run_Ddl_Command___(stmnt_, 'Disable_Trigger', show_info_);
      IF show_info_ THEN
         Show_Message___ ('Disable_Trigger: Trigger ' || trigger_name_ || ' disabled.');
      END IF;
   ELSE
      IF show_info_ THEN
         Show_Message___ ('Disable_Trigger: Trigger ' || trigger_name_ || ' does not exist.');
      END IF;
   END IF;
END Disable_Trigger;


PROCEDURE Enable_Trigger (
   trigger_name_  IN VARCHAR2,
   show_info_     IN BOOLEAN  DEFAULT FALSE ) 
IS
   stmnt_            VARCHAR2(32000);
BEGIN
   IF Trigger_Exist(trigger_name_) THEN
      stmnt_ := 'ALTER TRIGGER ' || trigger_name_ || ' ENABLE ';
      Run_Ddl_Command___(stmnt_, 'Enable_Trigger', show_info_);
      IF show_info_ THEN
         Show_Message___ ('Enable_Trigger: Trigger ' || trigger_name_ || ' enabled.');
      END IF;
   ELSE
      IF show_info_ THEN
         Show_Message___ ('Enable_Trigger: Trigger ' || trigger_name_ || ' does not exist.');
      END IF;
   END IF;
END Enable_Trigger;


PROCEDURE Create_Table (
   table_name_    IN VARCHAR2,
   columns_       IN ColumnTabType,
   tablespace_    IN VARCHAR2 DEFAULT NULL,
   storage_       IN VARCHAR2 DEFAULT NULL,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
   stmnt_            VARCHAR2(32000);
BEGIN
   FOR i IN Nvl(columns_.first, 0)..Nvl(columns_.last, 0) LOOP
      IF (columns_(i).data_type IN ('CLOB', 'BLOB')) THEN
         Show_Message___('Create_Table error: This method cannot be used for BLOB or CLOB columns.');
         RETURN;
      END IF;
   END LOOP;
   IF NOT (Table_Exist ( table_name_ ) ) THEN
      stmnt_ := 'CREATE TABLE ' || table_name_ || ' ( ';
      stmnt_ := stmnt_ || Format_Columns (columns_, 'TABLE', TRUE);
      stmnt_ := stmnt_ || ') ';
      IF (NOT dbms_db_version.ver_le_11_1 AND Functionality_Exist('Deferred Segment Creation') = 'TRUE') THEN -- Enterprise Edition functionality
         stmnt_ := stmnt_ || ' SEGMENT CREATION DEFERRED ';
      END IF;
      IF (tablespace_ IS NOT NULL) THEN
         stmnt_ := stmnt_ || ' TABLESPACE ' || tablespace_;
      END IF;
      IF (storage_ IS NOT NULL) THEN
         IF Upper(storage_) LIKE '%INITIAL%' THEN
            stmnt_ := stmnt_ || ' STORAGE (' || storage_ || ')';
         ELSE
            stmnt_ := stmnt_ || ' STORAGE (INITIAL ' || storage_ || ')';
         END IF;
      END IF;
      Run_Ddl_Command___(stmnt_, 'Create_Table', show_info_);
      IF show_info_ THEN
         Show_Message___ ('Create_Table: Table ' || table_name_ || ' created.');
      END IF;
   ELSE
      IF show_info_ AND verbose_ THEN
         Show_Message___ ('Create_Table: Table ' || table_name_ || ' already created.');
      END IF;
   END IF;
END Create_Table;


PROCEDURE Create_Table_Iot (
   table_name_    IN VARCHAR2,
   columns_       IN ColumnTabType,
   primary_key_   IN ColumnTabType,
   tablespace_    IN VARCHAR2 DEFAULT NULL,
   storage_       IN VARCHAR2 DEFAULT NULL,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
   stmnt_            VARCHAR2(32000);
BEGIN
   FOR i IN Nvl(columns_.first, 0)..Nvl(columns_.last, 0) LOOP
      IF (columns_(i).data_type IN ('CLOB', 'BLOB')) THEN
         Show_Message___('Create_Table error: This method cannot be used for BLOB or CLOB columns.');
         RETURN;
      END IF;
   END LOOP;
   IF NOT (Table_Exist ( table_name_ ) ) THEN
      stmnt_ := 'CREATE TABLE ' || table_name_ || ' ( ';
      stmnt_ := stmnt_ || Format_Columns (columns_, 'TABLE', TRUE);
      stmnt_ := stmnt_ || ', CONSTRAINT '|| replace(upper(table_name_), '_TAB', '') || '_PK PRIMARY KEY ( ' || Format_Columns (primary_key_, 'INDEX', TRUE);
      stmnt_ := stmnt_ || ')) ORGANIZATION INDEX ';
      IF (tablespace_ IS NOT NULL) THEN
         stmnt_ := stmnt_ || ' TABLESPACE ' || tablespace_;
      END IF;
      IF (storage_ IS NOT NULL) THEN
         IF Upper(storage_) LIKE '%INITIAL%' THEN
            stmnt_ := stmnt_ || ' STORAGE (' || storage_ || ')';
         ELSE
            stmnt_ := stmnt_ || ' STORAGE (INITIAL ' || storage_ || ')';
         END IF;
      END IF;
      Run_Ddl_Command___(stmnt_, 'Create_Table_Iot', show_info_);
      IF show_info_ THEN
         Show_Message___ ('Create_Table_Iot: Table ' || table_name_ || ' created.');
      END IF;
   ELSE
      IF show_info_ AND verbose_ THEN
         Show_Message___ ('Create_Table_Iot: Table ' || table_name_ || ' already created.');
      END IF;
   END IF;
END Create_Table_Iot;


PROCEDURE Create_Or_Replace_Table (
   table_name_    IN VARCHAR2,
   columns_       IN ColumnTabType,
   tablespace_    IN VARCHAR2 DEFAULT NULL,
   storage_       IN VARCHAR2 DEFAULT NULL,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   FOR i IN Nvl(columns_.first, 0)..Nvl(columns_.last, 0) LOOP
      IF (columns_(i).data_type IN ('CLOB', 'BLOB')) THEN
         Show_Message___('Create_Table error: This method cannot be used for BLOB or CLOB columns.');
         RETURN;
      END IF;
   END LOOP;
   IF (Table_Exist ( table_name_ ) ) THEN
      Alter_Table (table_name_,
                   columns_,
                   show_info_ );
   ELSE
      Create_Table(table_name_,
                   columns_   ,
                   tablespace_,
                   storage_   ,
                   show_info_ );
   END IF;
END Create_Or_Replace_Table;


PROCEDURE Create_Or_Replace_Type (
   type_name_     IN VARCHAR2,
   columns_       IN ColumnTabType,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
   PROCEDURE Remove_Dependencies___ (
      type_name_     IN VARCHAR2,
      show_info_     IN BOOLEAN  DEFAULT FALSE )
   IS
      CURSOR get_dep IS 
      SELECT name, type
        FROM user_dependencies
       WHERE referenced_name = type_name_
         AND type = 'TYPE';
   BEGIN
      FOR rec IN get_dep LOOP
         CASE rec.type
         WHEN 'TYPE' THEN 
            Remove_Type(rec.name, show_info_);
         ELSE
            NULL;
         END CASE;
      END LOOP;
   END Remove_Dependencies___;
   PROCEDURE Create_Type___ (
      type_name_     IN VARCHAR2,
      columns_       IN ColumnTabType,
      show_info_     IN BOOLEAN  DEFAULT FALSE )
   IS
      stmnt_            VARCHAR2(32000);
   BEGIN
      stmnt_ := 'CREATE OR REPLACE TYPE ' || type_name_ || ' AS OBJECT ( ' || nl_;
      stmnt_ := stmnt_ || Format_Columns (columns_, 'TABLE', TRUE) || nl_;
      stmnt_ := stmnt_ || ') ';
      Run_Ddl_Command___(stmnt_, 'Create_Type', show_info_);
      IF show_info_ THEN
         Show_Message___ ('Create_Type: Type ' || type_name_ || ' created.');
      END IF;
   END Create_Type___;
BEGIN
   Remove_Dependencies___(type_name_, show_info_);
   Create_Type___(type_name_, columns_, show_info_);
END Create_Or_Replace_Type;


PROCEDURE Create_Or_Replace_Type (
   type_name_     IN VARCHAR2,
   type_table_    IN VARCHAR2,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
   PROCEDURE Remove_Dependencies___ (
      type_name_     IN VARCHAR2,
      show_info_     IN BOOLEAN  DEFAULT FALSE )
   IS
      CURSOR get_dep IS 
      SELECT name, type
        FROM user_dependencies
       WHERE referenced_name = type_name_
         AND type = 'TYPE';
   BEGIN
      FOR rec IN get_dep LOOP
         CASE rec.type
         WHEN 'TYPE' THEN 
            Remove_Type(rec.name, show_info_);
         ELSE
            NULL;
         END CASE;
      END LOOP;
   END Remove_Dependencies___;
   PROCEDURE Create_Type___ (
      type_name_     IN VARCHAR2,
      type_table_    IN VARCHAR2,
      show_info_     IN BOOLEAN  DEFAULT FALSE )
   IS
      stmnt_            VARCHAR2(32000);
   BEGIN
      stmnt_ := 'CREATE OR REPLACE TYPE ' || type_name_ || ' AS TABLE OF ' || type_table_;
      Run_Ddl_Command___(stmnt_, 'Create_Type', show_info_);
      IF show_info_ THEN
         Show_Message___ ('Create_Type: Type ' || type_name_ || ' created.');
      END IF;
   END Create_Type___;
BEGIN
   Remove_Dependencies___(type_name_, show_info_);
   Create_Type___(type_name_, type_table_, show_info_);
END Create_Or_Replace_Type;


PROCEDURE Create_Type (
   type_name_     IN VARCHAR2,
   columns_       IN ColumnTabType,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
   PROCEDURE Create_Type___ (
      type_name_     IN VARCHAR2,
      columns_       IN ColumnTabType,
      show_info_     IN BOOLEAN  DEFAULT FALSE )
   IS
      stmnt_            VARCHAR2(32000);
   BEGIN
      stmnt_ := 'CREATE OR REPLACE TYPE ' || type_name_ || ' AS OBJECT ( ' || nl_;
      stmnt_ := stmnt_ || Format_Columns (columns_, 'TABLE', TRUE) || nl_;
      stmnt_ := stmnt_ || ') ';
      Run_Ddl_Command___(stmnt_, 'Create_Type', show_info_);
      IF show_info_ THEN
         Show_Message___ ('Create_Type: Type ' || type_name_ || ' created.');
      END IF;
   END Create_Type___;
BEGIN
   IF (Object_Exist ( type_name_, 'TYPE')) THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___ ('Create_Type: Type ' || type_name_ || ' already exists.');
      END IF;
   ELSE
      Create_Type___(type_name_, columns_, show_info_);
   END IF;
END Create_Type;


PROCEDURE Create_Type (
   type_name_     IN VARCHAR2,
   type_table_    IN VARCHAR2,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
   PROCEDURE Create_Type___ (
      type_name_     IN VARCHAR2,
      type_table_    IN VARCHAR2,
      show_info_     IN BOOLEAN  DEFAULT FALSE )
   IS
      stmnt_            VARCHAR2(32000);
   BEGIN
      stmnt_ := 'CREATE OR REPLACE TYPE ' || type_name_ || ' AS TABLE OF ' || type_table_;
      Run_Ddl_Command___(stmnt_, 'Create_Type', show_info_);
      IF show_info_ THEN
         Show_Message___ ('Create_Type: Type ' || type_name_ || ' created.');
      END IF;
   END Create_Type___;
BEGIN
   IF (Object_Exist ( type_name_, 'TYPE')) THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___ ('Create_Type: Type ' || type_name_ || ' already exists.');
      END IF;
   ELSE
      Create_Type___(type_name_, type_table_, show_info_);
   END IF;
END Create_Type;


PROCEDURE Create_Or_Replace_Empty_View (
   view_name_    IN VARCHAR2,
   columns_      IN ColumnViewType,
   lu_           IN VARCHAR2 DEFAULT NULL,
   module_       IN VARCHAR2 DEFAULT NULL,
   server_only_  IN VARCHAR2 DEFAULT NULL,
   show_info_    IN BOOLEAN  DEFAULT FALSE )
IS
   comment_   user_tab_comments.comments%TYPE;
   CURSOR get_view_comment IS
      SELECT comments
      FROM user_tab_comments
      WHERE table_name = UPPER(view_name_);
BEGIN
   OPEN get_view_comment;
   FETCH get_view_comment INTO comment_;
   CLOSE get_view_comment;
   IF (View_Exist(view_name_)
   AND NVL(comment_,'xx') != 'MODULE=IGNORE^') THEN
      Alter_View___(view_name_,
                    columns_,
                    show_info_);
   ELSE
      Create_Empty_View___(view_name_,
                           columns_,
                           lu_,
                           module_,
                           server_only_,
                           show_info_);
   END IF;
END Create_Or_Replace_Empty_View;


PROCEDURE Create_Temporary_Table (
   table_name_    IN VARCHAR2,
   columns_       IN ColumnTabType,
   show_info_     IN BOOLEAN  DEFAULT FALSE ) 
IS
   stmnt_            VARCHAR2(32000);
BEGIN
   FOR i IN Nvl(columns_.first, 0)..Nvl(columns_.last, 0) LOOP
      IF (columns_(i).data_type IN ('CLOB', 'BLOB')) THEN
         Show_Message___('Create_Temporary_Table error: This method cannot be used for BLOB or CLOB columns.');
         RETURN;
      END IF;
   END LOOP;
   IF NOT (Table_Exist ( table_name_ ) ) THEN
      stmnt_ := 'CREATE GLOBAL TEMPORARY TABLE ' || table_name_ || ' ( ';
      stmnt_ := stmnt_ || Format_Columns (columns_, 'TABLE');
      stmnt_ := stmnt_ || ') ON COMMIT DELETE ROWS';
      Run_Ddl_Command___(stmnt_, 'Create_Temporary_Table', show_info_);
      IF show_info_ THEN
         Show_Message___ ('Create_Temporary_Table: Table ' || table_name_ || ' created.');
      END IF;
   ELSE
      IF show_info_ AND verbose_ THEN
         Show_Message___ ('Create_Temporary_Table: Table ' || table_name_ || ' already created.');
      END IF;
   END IF;
END Create_Temporary_Table;


FUNCTION Format_Column (
   colrec_ IN ColRec,
   type_ IN VARCHAR2 DEFAULT 'TABLE',
   create_table_ IN BOOLEAN  DEFAULT FALSE ) RETURN VARCHAR2
IS
   column_              ColRec := colrec_;
   stmt_                VARCHAR2(4000);
   old_default_value_   VARCHAR2(4000) := Get_Default_Value(column_.table_name, column_.column_name);
   old_nullable_        VARCHAR2(100)  := Get_Column_Nullable(column_.table_name, column_.column_name);
   old_on_null_         VARCHAR2(100)  := Get_Column_On_Null(column_.table_name, column_.column_name);
   nullable_stmt_       VARCHAR2(30);
BEGIN
   stmt_ := NULL;
   IF type_ = 'TABLE' THEN
      -- Data Type
      IF (column_.data_type IS NOT NULL) THEN
         IF (column_.data_type = 'IDENTITY') THEN
            stmt_ := stmt_ || ' NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY ';
         ELSE
            stmt_ := stmt_ || ' ' || column_.data_type;
         END IF;
      END IF;
      -- Default value
      IF (column_.default_value IS NOT NULL) THEN
         IF column_.keep_default = 'N' AND create_table_ THEN
            NULL;
         ELSE
            IF (column_.default_value = '$DEFAULT_NULL$') THEN -- $DEFAULT_NULL$ is a special value for setting DEFAULT NULL
               stmt_ := stmt_ || ' DEFAULT NULL';
            ELSIF (column_.default_value LIKE 'ON NULL%') 
            OR (nvl(old_nullable_, 'N') = 'N'
               AND column_.nullable = 'Y'
               AND old_on_null_ = 'YES') THEN
               stmt_ := stmt_ || ' DEFAULT ' || column_.default_value;
            ELSE
               stmt_ := stmt_ || ' DEFAULT ON NULL ' || column_.default_value;
            END IF;
         END IF;
      ELSE
         IF (nvl(old_nullable_, 'N') = 'N'
         AND column_.nullable = 'Y'
         AND old_on_null_ = 'YES'
         AND old_default_value_ IS NOT NULL) THEN
            stmt_ := stmt_ || ' DEFAULT ' || old_default_value_;
         END IF;
      END IF;
      -- Mandatory
      IF (column_.nullable IS NOT NULL) THEN
         IF (nvl(old_nullable_, 'Y') = column_.nullable) THEN
             nullable_stmt_ := '';
         ELSIF (column_.nullable = 'Y') THEN
             nullable_stmt_ := ' NULL';
         ELSIF (column_.nullable = 'N') THEN
             nullable_stmt_ := ' NOT NULL';
         END IF;
         stmt_ := stmt_ || nullable_stmt_;
      END IF;
      -- Lob parameter
      IF (column_.lob_parameter IS NOT NULL) THEN
         IF(stmt_ IS NOT NULL) THEN
            stmt_ := column_.column_name || stmt_ || ' ' || 'MODIFY LOB (' || column_.column_name || ') ' || column_.lob_parameter;
         ELSE
            stmt_ := 'LOB (' || column_.column_name || ') ' || column_.lob_parameter;
         END IF;
      ELSE
         stmt_ := RTRIM(column_.column_name ||' '|| stmt_);
      END IF;
   ELSE
      stmt_ := column_.column_name;
   END IF;
   RETURN (stmt_);
END Format_Column;


FUNCTION Format_Columns (
   columns_ IN ColumnTabType,
   type_    IN VARCHAR2 DEFAULT 'TABLE',
   create_table_ IN BOOLEAN  DEFAULT FALSE ) RETURN VARCHAR2
IS
   stmt_             VARCHAR2(32000);
BEGIN
   FOR i IN columns_.FIRST..columns_.LAST LOOP
      IF i = 1 THEN
         stmt_ := stmt_ || Format_Column(columns_(i), type_, create_table_);
      ELSE
         stmt_ := stmt_ || ', ' || Format_Column(columns_(i), type_, create_table_);
      END IF;
   END LOOP;
   RETURN (stmt_);
END Format_Columns;


FUNCTION Functionality_Exist (
   functionality_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   exist_   VARCHAR2(5) := 'FALSE';
   CURSOR get_functionality IS
      SELECT value
      FROM   sys.v_$option
      WHERE  parameter = functionality_;
BEGIN
   OPEN  get_functionality;
   FETCH get_functionality INTO exist_;
   CLOSE get_functionality;
   RETURN(exist_);
END Functionality_Exist;


FUNCTION Get_Column_Nullable (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   nullable_          VARCHAR2(1);
   CURSOR get_nullable IS
      SELECT   nullable
      FROM     user_tab_columns
      WHERE    table_name  = UPPER(table_name_)
      AND      column_name = UPPER(column_name_);
BEGIN
   OPEN  get_nullable;
   FETCH get_nullable INTO nullable_;
   CLOSE get_nullable;
   RETURN nullable_;
END Get_Column_Nullable;


FUNCTION Get_Column_On_Null (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   on_null_          VARCHAR2(5);
   CURSOR get_on_null IS
      SELECT   default_on_null
      FROM     user_tab_columns
      WHERE    table_name  = UPPER(table_name_)
      AND      column_name = UPPER(column_name_);
BEGIN
   OPEN  get_on_null;
   FETCH get_on_null INTO on_null_;
   CLOSE get_on_null;
   RETURN on_null_;
END Get_Column_On_Null;


FUNCTION Get_Column_Type (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   type_          VARCHAR2(20);
   CURSOR get_type IS
      SELECT   data_type
      FROM     user_tab_columns
      WHERE    table_name  = UPPER(table_name_)
      AND      column_name = UPPER(column_name_);
BEGIN
   OPEN  get_type;
   FETCH get_type INTO type_;
   CLOSE get_type;
   RETURN type_;
END Get_Column_Type;


FUNCTION Get_Object_Type (
   object_name_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   type_ user_objects.object_type%TYPE;
   CURSOR get_type IS
      SELECT   object_type
      FROM     user_objects
      WHERE    object_name  = UPPER(object_name_);
BEGIN
   OPEN  get_type;
   FETCH get_type INTO type_;
   CLOSE get_type;
   RETURN type_;
END Get_Object_Type;


FUNCTION Get_Default_Value (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2 ) RETURN LONG
IS
   default_value_ LONG;
   CURSOR get_default_value IS
      SELECT   data_default
      FROM     user_tab_columns t
      WHERE    table_name  = UPPER(table_name_)
      AND      column_name = UPPER(column_name_);
BEGIN
   OPEN  get_default_value;
   FETCH get_default_value INTO default_value_;
   CLOSE get_default_value;
   RETURN default_value_;
END Get_Default_Value;


FUNCTION Get_Index_Columns (
   index_name_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   ind_columns_    VARCHAR2(4000);
   CURSOR get_ind_columns IS
      SELECT column_name
      FROM   user_ind_columns
      WHERE  index_name = UPPER(index_name_)
      ORDER BY column_position;
BEGIN
   FOR rec_ IN get_ind_columns LOOP
      IF (ind_columns_ IS NULL) THEN
         ind_columns_ := rec_.column_name;
      ELSE
         ind_columns_ := ind_columns_ || ', ' || rec_.column_name;
      END IF;
   END LOOP;
   RETURN ind_columns_;
END Get_Index_Columns;


FUNCTION Get_Index_Columns (
   table_name_  IN VARCHAR2,
   index_name_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   ind_columns_    VARCHAR2(4000);
   CURSOR get_ind_columns IS
      SELECT column_name
      FROM   user_ind_columns
      WHERE    table_name = UPPER(table_name_)
      AND      index_name = UPPER(index_name_)
      ORDER BY column_position;
BEGIN
   FOR rec_ IN get_ind_columns LOOP
      IF (ind_columns_ IS NULL) THEN
         ind_columns_ := rec_.column_name;
      ELSE
         ind_columns_ := ind_columns_ || ', ' || rec_.column_name;
      END IF;
   END LOOP;
   RETURN ind_columns_;
END Get_Index_Columns;


FUNCTION Get_Index_Table (
   index_name_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   table_name_    user_indexes.table_name%TYPE;
   CURSOR get_table_name IS
      SELECT table_name
      FROM   user_indexes
      WHERE  index_name = UPPER(index_name_);
BEGIN
   OPEN  get_table_name;
   FETCH get_table_name INTO table_name_;
   CLOSE get_table_name;
   RETURN table_name_;
END Get_Index_Table;


FUNCTION Get_Index_Type (
   index_name_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   index_type_    user_indexes.index_type%TYPE;
   CURSOR get_index_type IS
      SELECT index_type
      FROM   user_indexes
      WHERE  index_name = UPPER(index_name_);
BEGIN
   OPEN  get_index_type;
   FETCH get_index_type INTO index_type_;
   CLOSE get_index_type;
   RETURN index_type_;
END Get_Index_Type;

FUNCTION Get_Index_Expression (
   table_name_  IN VARCHAR2,
   index_name_  IN VARCHAR2) RETURN VARCHAR2
IS
   expression_ VARCHAR2(32767);
BEGIN
   FOR rec_ IN (SELECT column_expression
                FROM user_ind_expressions t
                WHERE t.index_name = index_name_ AND t.table_name = table_name_
                ORDER BY t.column_position) LOOP
      expression_ := expression_ || TRIM(rec_.column_expression)||', ';              
   END LOOP;
   --Oracle adds additional spaces to expressions, this is to remove them             
   RETURN RTRIM(REPLACE(expression_, '  ',' '), ', '); 
END Get_Index_Expression;

FUNCTION Get_Index_Uniqueness (
   table_name_  IN VARCHAR2,
   index_name_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   uniqueness_     VARCHAR2(10);
   CURSOR get_uniqueness IS
      SELECT   uniqueness
      FROM     user_indexes
      WHERE    table_name = UPPER(table_name_)
      AND      index_name = UPPER(index_name_);
BEGIN
   OPEN  get_uniqueness;
   FETCH get_uniqueness INTO uniqueness_;
   CLOSE get_uniqueness;
   RETURN uniqueness_;
END Get_Index_Uniqueness;


FUNCTION Get_Constraint_Columns (
   constraint_name_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   cons_columns_    VARCHAR2(4000);
   CURSOR get_cons_columns IS
      SELECT column_name
      FROM   user_cons_columns
      WHERE  constraint_name = UPPER(constraint_name_)
      ORDER BY position;
BEGIN
   FOR rec_ IN get_cons_columns LOOP
      IF (cons_columns_ IS NULL) THEN
         cons_columns_ := rec_.column_name;
      ELSE
         cons_columns_ := cons_columns_ || ', ' || rec_.column_name;
      END IF;
   END LOOP;
   RETURN cons_columns_;
END Get_Constraint_Columns;


FUNCTION Get_Constraint_Columns (
   table_name_      IN VARCHAR2,
   constraint_name_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   cons_columns_    VARCHAR2(4000);
   CURSOR get_cons_columns IS
      SELECT column_name
      FROM   user_cons_columns
      WHERE  table_name = UPPER(table_name_)
      AND    constraint_name = UPPER(constraint_name_)
      ORDER BY position;
BEGIN
   FOR rec_ IN get_cons_columns LOOP
      IF (cons_columns_ IS NULL) THEN
         cons_columns_ := rec_.column_name;
      ELSE
         cons_columns_ := cons_columns_ || ', ' || rec_.column_name;
      END IF;
   END LOOP;
   RETURN cons_columns_;
END Get_Constraint_Columns;


FUNCTION Get_Referenced_Columns (
   table_name_      IN VARCHAR2,
   constraint_name_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   cons_columns_    VARCHAR2(4000);
   tbl_name_        VARCHAR2(50);
   CURSOR get_cons_columns IS
      SELECT a_r.column_name, a_r.table_name
      FROM user_cons_columns a
      JOIN user_constraints c ON a.constraint_name = c.constraint_name
      JOIN user_cons_columns a_r ON c.r_constraint_name = a_r.constraint_name
                                 AND a.position = a_r.position
      WHERE c.constraint_type = 'R'
      AND a.table_name = UPPER(table_name_)
      AND a.constraint_name = UPPER(constraint_name_)
      ORDER BY a.position;
BEGIN
   FOR rec_ IN get_cons_columns LOOP
      IF (cons_columns_ IS NULL) THEN
         cons_columns_ := rec_.column_name;
      ELSE
         cons_columns_ := cons_columns_ || ', ' || rec_.column_name;
      END IF;
      
      IF (tbl_name_ IS NULL) THEN
         tbl_name_ := rec_.table_name;
      END IF;
   END LOOP;
   RETURN 'references ' || tbl_name_ || ' (' || cons_columns_ || ')';
END Get_Referenced_Columns;


FUNCTION Index_Exist (
   index_name_  IN VARCHAR2,
   table_name_  IN VARCHAR2 DEFAULT NULL ) RETURN BOOLEAN
IS
   dummy_          NUMBER := 0;
   CURSOR check_index IS
      SELECT  1
      FROM    user_indexes
      WHERE   index_name = UPPER(index_name_)
      AND     table_name = NVL(UPPER(table_name_), table_name);
BEGIN
   OPEN  check_index;
   FETCH check_index INTO dummy_;
   IF (check_index%FOUND) THEN
      CLOSE check_index;
      RETURN TRUE;
   ELSE
      CLOSE check_index;
      RETURN FALSE;
   END IF;
END Index_Exist;


FUNCTION Is_Option_Available (
   option_ IN  VARCHAR2 ) RETURN BOOLEAN
IS
   CURSOR get_option IS
   SELECT value
     FROM v$option
    WHERE parameter = option_;

   value_   VARCHAR2(10);
BEGIN
   OPEN  get_option;
   FETCH get_option INTO value_;
   CLOSE get_option;
   IF (value_ = 'TRUE') THEN
      RETURN TRUE;
   ELSE
      RETURN FALSE;
   END IF;
END Is_Option_Available;


FUNCTION Is_Rowmovement_Enabled (
   table_name_   IN VARCHAR2 ) RETURN BOOLEAN
IS
      CURSOR get_tab IS
   SELECT row_movement 
   FROM user_tables
   WHERE table_name = table_name_;
BEGIN
   FOR rec IN get_tab LOOP 
      CASE (rec.row_movement)
      WHEN 'ENABLED' THEN
         RETURN(TRUE);
      ELSE
         RETURN(FALSE);
      END CASE;
   END LOOP;
END Is_Rowmovement_Enabled;


FUNCTION Is_Table_Iot (
   table_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_          NUMBER := 0;
   CURSOR is_iot_table IS
      SELECT 1
      FROM user_tables
      WHERE table_name = table_name_
      AND   iot_type = 'IOT';
BEGIN
   OPEN  is_iot_table;
   FETCH is_iot_table INTO dummy_;
   IF (is_iot_table%FOUND) THEN
      CLOSE is_iot_table;
      RETURN TRUE;
   ELSE
      CLOSE is_iot_table;
      RETURN FALSE;
   END IF;
END Is_Table_Iot;


FUNCTION Is_Table_Temporary (
   table_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   RETURN(Is_Table_Temporary___(table_name_));
END Is_Table_Temporary;


FUNCTION Is_Table_Queue (
   table_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_          NUMBER := 0;
   CURSOR is_queue_table IS
      SELECT 1
      FROM user_queue_tables
      WHERE queue_table = table_name_;
BEGIN
   OPEN  is_queue_table;
   FETCH is_queue_table INTO dummy_;
   IF (is_queue_table%FOUND) THEN
      CLOSE is_queue_table;
      RETURN TRUE;
   ELSE
      CLOSE is_queue_table;
      RETURN FALSE;
   END IF;
END Is_Table_Queue;


FUNCTION Is_Table_Mw (
   table_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_          NUMBER := 0;
   CURSOR is_mw_table IS
      SELECT 1
      FROM user_mviews
      WHERE mview_name = table_name_;
BEGIN
   OPEN  is_mw_table;
   FETCH is_mw_table INTO dummy_;
   IF (is_mw_table%FOUND) THEN
      CLOSE is_mw_table;
      RETURN TRUE;
   ELSE
      CLOSE is_mw_table;
      RETURN FALSE;
   END IF;
END Is_Table_Mw;

FUNCTION Object_Exist (
   object_name_  IN VARCHAR2,
   object_type_  IN VARCHAR2,
   status_       IN VARCHAR2 DEFAULT NULL ) RETURN BOOLEAN
IS
   dummy_          NUMBER := 0;
   CURSOR check_object IS
      SELECT   1
      FROM     user_objects
      WHERE    object_name IN (UPPER(object_name_), object_name_)  -- Names of Java classes are not stored in upper case 
      AND      object_type = UPPER(object_type_)
      AND      status = nvl(status_, status);
BEGIN
   OPEN  check_object;
   FETCH check_object INTO dummy_;
   IF (check_object%FOUND) THEN
      CLOSE check_object;
      RETURN TRUE;
   ELSE
      CLOSE check_object;
      RETURN FALSE;
   END IF;
END Object_Exist;

PROCEDURE Rebuild_Index (
   index_name_       IN VARCHAR2,
   show_info_        IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   Rebuild_Index___('REBUILD_INDEX', index_name_, show_info_);
END Rebuild_Index;


PROCEDURE Remove_Constraints(
   table_name_      IN VARCHAR2,
   constraint_name_ IN VARCHAR2 DEFAULT '%',
   show_info_       IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   Remove_Constraints___('Remove_Constraints', table_name_, constraint_name_, show_info_);
END Remove_Constraints;


PROCEDURE Remove_Context(
   context_name_    IN VARCHAR2,
   show_info_       IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   Remove_Context___('Remove_Context', context_name_, show_info_);
END Remove_Context;


PROCEDURE Remove_Indexes (
   table_name_ IN VARCHAR2,
   index_name_ IN VARCHAR2 DEFAULT '%',
   show_info_  IN BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   Remove_Indexes___('Remove_Indexes', table_name_, index_name_, show_info_);
END Remove_Indexes;


PROCEDURE Remove_Lob_Column (
   table_name_  IN VARCHAR2,
   column_      IN ColRec,
   show_info_   IN BOOLEAN DEFAULT FALSE )
IS
BEGIN
   IF (column_.data_type NOT IN ('CLOB', 'BLOB')) THEN
      Show_Message___('Remove_Lob_Column error: This method can only be used for BLOB or CLOB columns.');
      RETURN;
   END IF;
   Alter_Table_Column___('Remove_Lob_Column', table_name_, 'DROP COLUMN', column_, show_info_);
END Remove_Lob_Column;


PROCEDURE Remove_Materialized_View (
   view_name_ IN VARCHAR2,
   show_info_ IN BOOLEAN  DEFAULT FALSE )
IS
   stmt_      VARCHAR2(200);
BEGIN
   IF (Mtrl_View_Exist ( view_name_ ) ) THEN
      stmt_ := 'DROP MATERIALIZED VIEW ' || view_name_;
      Run_Ddl_Command___(stmt_, 'Remove_Materialized_View', show_info_);

      /*
      --NOT possible to remove criteria or other related MV info from this method since it is a low
      --level method ONLY removing a specific object, nothing else. To remove related things, please
      --refer to methods in Xlr_Mv_Util_API, Xlr_Mv_Category_API, Xlr_Mv_Criteria_API
      --stmt_ := 'DELETE FROM XLR_MV_CRITERIA_TAB WHERE MV_NAME = ' || CHR(39) || view_name_ || CHR(39);
      --Run_Ddl_Command___(stmt_, 'Remove_Materialized_View_Parameters', show_info_);
      */

      IF show_info_ THEN
         Show_Message___('Remove_Materialized_View: Materialized View ' || view_name_ || ' dropped.');
      END IF;
   ELSE
      IF show_info_ THEN
         Show_Message___('Remove_Materialized_View: Materialized View ' || view_name_ || ' does not exist.');
      END IF;
   END IF;
END Remove_Materialized_View;


PROCEDURE Remove_Materialized_View_Log (
   table_name_ IN VARCHAR2,
   show_info_  IN BOOLEAN  DEFAULT FALSE )
IS
   stmnt_      VARCHAR2(200);
BEGIN
   IF (Mtrl_View_Log_Exist ( table_name_ ) ) THEN
      stmnt_ := 'DROP MATERIALIZED VIEW LOG ON ' || table_name_;
      Run_Ddl_Command___(stmnt_, 'Remove_Materialized_View', show_info_);
      IF show_info_ THEN
         Show_Message___('Remove_Materialized_View_Log: Materialized View Log on ' || table_name_ || ' dropped.');
      END IF;
   ELSE
      IF show_info_ THEN
         Show_Message___('Remove_Materialized_View_Log: Materialized View Log on ' || table_name_ || ' does not exist.');
      END IF;
   END IF;
END Remove_Materialized_View_Log;


PROCEDURE Remove_Package (
   package_name_ IN VARCHAR2,
   show_info_    IN BOOLEAN  DEFAULT FALSE )
IS
   stmnt_ VARCHAR2(200);
BEGIN
   IF (Object_Exist ( package_name_, 'PACKAGE')) THEN
      stmnt_ := 'DROP PACKAGE ' || package_name_;
      Run_Ddl_Command___(stmnt_, 'Remove_Package', show_info_);
      IF show_info_ THEN
         Show_Message___('Remove_Package: Package ' || package_name_ || ' dropped.');
      END IF;
   ELSE
      IF show_info_ THEN
         Show_Message___('Remove_Package: Package ' || package_name_ || ' does not exist.');
      END IF;
   END IF;
END Remove_Package;

PROCEDURE Remove_Sequence (
   sequence_name_ IN VARCHAR2,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
   stmnt_ VARCHAR2(200);
BEGIN
   IF (Object_Exist (sequence_name_, 'SEQUENCE')) THEN
      stmnt_ := 'DROP SEQUENCE ' || sequence_name_;
      Run_Ddl_Command___(stmnt_, 'Remove_Sequence', show_info_);
      IF show_info_ THEN
         Show_Message___('Remove_Sequence: Sequence ' || sequence_name_ || ' dropped.');
      END IF;
   ELSE
      IF show_info_ THEN
         Show_Message___('Remove_Sequence: Sequence ' || sequence_name_ || ' does not exist.');
      END IF;
   END IF;
END Remove_Sequence;


PROCEDURE Remove_Synonym (
   synonym_name_ IN VARCHAR2,
   show_info_    IN BOOLEAN  DEFAULT FALSE )
IS
   stmnt_ VARCHAR2(200);
BEGIN
   IF (Object_Exist ( synonym_name_, 'SYNONYM' ) ) THEN
      stmnt_ := 'DROP SYNONYM ' || synonym_name_;
      Run_Ddl_Command___(stmnt_, 'Remove_Synonym', show_info_);
      IF show_info_ THEN
         Show_Message___('Remove_Synonym: Synonym  ' || synonym_name_ || ' dropped.');
      END IF;
   ELSE
      IF show_info_ THEN
         Show_Message___('Remove_Synonym: Synonym ' || synonym_name_ || ' does not exist.');
      END IF;
   END IF;
END Remove_Synonym;


PROCEDURE Remove_Table (
   table_name_ IN VARCHAR2,
   show_info_  IN BOOLEAN DEFAULT FALSE,
   purge_      IN BOOLEAN DEFAULT FALSE )
IS
   stmnt_ VARCHAR2(200);
BEGIN
   IF (Table_Exist ( table_name_ ) ) THEN
      stmnt_ := 'DROP TABLE ' || table_name_ || ' CASCADE CONSTRAINTS';
      IF purge_ THEN
         stmnt_ := stmnt_ || ' PURGE';
      END IF;
      Run_Ddl_Command___(stmnt_, 'Remove_Table', show_info_);
      IF show_info_ THEN
         Show_Message___('Remove_Table: Table ' || table_name_ || ' dropped with cascade constraints.');
      END IF;
   ELSE
      IF show_info_ THEN
         Show_Message___('Remove_Table: Table ' || table_name_ || ' does not exist.');
      END IF;
   END IF;
END Remove_Table;


PROCEDURE Remove_Type (
   type_name_ IN VARCHAR2,
   show_info_  IN BOOLEAN  DEFAULT FALSE )
IS
   stmnt_ VARCHAR2(200);
BEGIN
   IF (Type_Exist ( type_name_ ) ) THEN
      stmnt_ := 'DROP TYPE ' || type_name_ || ' FORCE';
      Run_Ddl_Command___(stmnt_, 'Remove_Type', show_info_);
      IF show_info_ THEN
         Show_Message___('Remove_Type: Type ' || type_name_ || ' dropped.');
      END IF;
   ELSE
      IF show_info_ THEN
         Show_Message___('Remove_Type: Type ' || type_name_ || ' does not exist.');
      END IF;
   END IF;
END Remove_Type;


PROCEDURE Remove_Trigger (
   trigger_name_  IN VARCHAR2,
   show_info_     IN BOOLEAN  DEFAULT FALSE )
IS
   stmnt_ VARCHAR2(200);
BEGIN
   IF (Trigger_Exist ( trigger_name_ ) ) THEN
      stmnt_ := 'DROP TRIGGER ' || trigger_name_;
      Run_Ddl_Command___(stmnt_, 'Remove_Trigger', show_info_);
      IF show_info_ THEN
         Show_Message___('Remove_Trigger: Trigger ' || trigger_name_ || ' dropped.');
      END IF;
   ELSE
      IF show_info_ THEN
         Show_Message___('Remove_Trigger: Trigger ' || trigger_name_ || ' does not exist.');
      END IF;
   END IF;
END Remove_Trigger;


PROCEDURE Remove_View (
   view_name_ IN VARCHAR2,
   show_info_ IN BOOLEAN  DEFAULT FALSE )
IS
   stmnt_ VARCHAR2(200);
BEGIN
   IF (View_Exist ( view_name_ ) ) THEN
      stmnt_ := 'DROP VIEW ' || view_name_;
      Run_Ddl_Command___(stmnt_, 'Remove_View', show_info_);
      IF show_info_ THEN
         Show_Message___('Remove_View: View ' || view_name_ || ' dropped.');
      END IF;
   ELSE
      IF show_info_ THEN
         Show_Message___('Remove_View: View ' || view_name_ || ' does not exist.');
      END IF;
   END IF;
END Remove_View;


PROCEDURE Rename_Column (
   table_name_       IN VARCHAR2,
   new_column_name_  IN VARCHAR2,
   old_column_name_  IN VARCHAR2,
   show_info_        IN BOOLEAN  DEFAULT FALSE,
   exception_        IN BOOLEAN  DEFAULT TRUE )
IS
   stmnt_            VARCHAR2(500);
   old_exists_       BOOLEAN := Column_Exist(table_name_, old_column_name_);
   new_exists_       BOOLEAN := Column_Exist(table_name_, new_column_name_);
BEGIN
   IF (NOT old_exists_ AND new_exists_) THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___('Rename_Column: Column ' || old_column_name_ || ' in Table ' || table_name_ || ' is already renamed to ' || new_column_name_ || '.');
      END IF;
   ELSIF (old_exists_ AND new_exists_) THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___('Rename_Column: Column ' || new_column_name_ || ' already exist.');
      END IF;
      IF exception_ THEN
         Raise_Application_Error(-20105, 'Rename_Column: Column ' || new_column_name_ || ' already exist.');
      END IF;
   ELSIF (NOT old_exists_ AND NOT new_exists_) THEN
      IF show_info_ THEN
         Show_Message___('Rename_Column: Column ' || old_column_name_ || ' does not exist.');
      END IF;
   ELSE
      Remove_Extended_Stats___(table_name_, old_column_name_);
      stmnt_ := 'ALTER TABLE ' || table_name_ || ' RENAME COLUMN ' || old_column_name_ || ' TO ' || new_column_name_;
      Run_Ddl_Command___(stmnt_, 'Rename_Column', show_info_);
      IF show_info_ THEN
         Show_Message___('Rename_Column: Column ' || old_column_name_ || ' in Table ' || table_name_ || ' renamed to ' || new_column_name_ || '.');
      END IF;
   END IF;
END Rename_Column;


PROCEDURE Rename_Table (
   source_table_       IN VARCHAR2,
   target_table_       IN VARCHAR2,
   show_info_          IN BOOLEAN DEFAULT FALSE,
   exception_          IN BOOLEAN DEFAULT TRUE,
   remove_indexes_     IN BOOLEAN DEFAULT TRUE,
   remove_constraints_ IN BOOLEAN DEFAULT TRUE,
   remove_triggers_    IN BOOLEAN DEFAULT TRUE )
IS
   stmnt_            VARCHAR2(400);
   old_exists_       BOOLEAN := Table_Exist(source_table_);
   new_exists_       BOOLEAN := Table_Exist(target_table_);
BEGIN
   IF (NOT old_exists_ AND new_exists_) THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___('Rename_Table: Table ' || source_table_ || ' is already renamed to ' || target_table_ || '.');
      END IF;
   ELSIF (old_exists_ AND new_exists_) THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___('Rename_Table: Target table ' || target_table_ || ' already exist.');
      END IF;
      IF exception_ THEN
         Raise_Application_Error(-20105, 'Rename_Table: Target table ' || target_table_ || ' already exist.');
      END IF;
   ELSIF (NOT old_exists_ AND NOT new_exists_) THEN
      IF show_info_ THEN
         Show_Message___('Rename_Table: Source table ' || source_table_ || ' does not exist.');
      END IF;
   ELSE
      -- Remove constraints, indexes, and triggers related to the source table if wanted
      IF remove_constraints_ THEN
         Remove_Constraints___('Rename_Table', source_table_, '%', show_info_);
      END IF;
      IF remove_indexes_ THEN
         Remove_Indexes___('Rename_Table', source_table_, '%', show_info_);
      END IF;
      IF remove_triggers_ THEN
         Remove_Triggers___('Rename_Table', source_table_, '%', show_info_);
      END IF;
      stmnt_ := 'RENAME ' || source_table_ || ' TO ' || target_table_;
      Run_Ddl_Command___(stmnt_, 'Rename_Table', show_info_);
      IF show_info_ THEN
         Show_Message___('Rename_Table: Table ' || source_table_ || ' renamed to ' || target_table_ || '.');
      END IF;
   END IF;
END Rename_Table;


PROCEDURE Rename_Sequence (
   source_sequence_    IN VARCHAR2,
   target_sequence_    IN VARCHAR2,
   show_info_          IN BOOLEAN  DEFAULT FALSE,
   exception_          IN BOOLEAN  DEFAULT TRUE )
IS
   stmnt_            VARCHAR2(400);
   old_exists_       BOOLEAN := Sequence_Exist(source_sequence_);
   new_exists_       BOOLEAN := Sequence_Exist(target_sequence_);
BEGIN
   IF (NOT old_exists_ AND new_exists_) THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___('Rename_Sequence: Sequence ' || source_sequence_ || ' is already renamed to ' || target_sequence_ || '.');
      END IF;
   ELSIF (old_exists_ AND new_exists_) THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___('Rename_Sequence: Target sequence ' || target_sequence_ || ' already exist.');
      END IF;
      IF exception_ THEN
         Raise_Application_Error(-20105, 'Rename_Sequence: Target sequence ' || target_sequence_ || ' already exist.');
      END IF;
   ELSIF (NOT old_exists_ AND NOT new_exists_) THEN
      IF show_info_ THEN
         Show_Message___('Rename_Sequence: Source sequence ' || source_sequence_ || ' does not exist.');
      END IF;
   ELSE
      stmnt_ := 'RENAME ' || source_sequence_ || ' TO ' || target_sequence_;
      Run_Ddl_Command___(stmnt_, 'Rename_Sequence', show_info_);
      IF show_info_ THEN
         Show_Message___('Rename_Sequence: Sequence ' || source_sequence_ || ' renamed to ' || target_sequence_ || '.');
      END IF;
   END IF;
 END Rename_Sequence;


PROCEDURE Rename_Constraint (
   table_name_         IN VARCHAR2,
   source_constraint_  IN VARCHAR2,
   target_constraint_  IN VARCHAR2,
   show_info_          IN BOOLEAN  DEFAULT FALSE,
   exception_          IN BOOLEAN  DEFAULT TRUE )
IS
   stmnt_            VARCHAR2(600);
   old_exists_       BOOLEAN := Constraint_Exist(source_constraint_);
   new_exists_       BOOLEAN := Constraint_Exist(target_constraint_);
BEGIN
   IF (NOT Table_Exist(table_name_)) THEN
      IF show_info_ THEN
         Show_Message___('Rename_Constraint: Table ' || table_name_ || ' does not exist.');
      END IF;
   END IF;
   IF (NOT old_exists_ AND new_exists_) THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___('Rename_Constraint: Constraint ' || source_constraint_ || ' in Table ' || table_name_ || ' is already renamed to ' || target_constraint_ || '.');
      END IF;
   ELSIF (old_exists_ AND new_exists_) THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___('Rename_Constraint: Target constraint ' || target_constraint_ || ' already exist.');
      END IF;
      IF exception_ THEN
         Raise_Application_Error(-20105, 'Rename_Constraint: Target constraint ' || target_constraint_ || ' already exist.');
      END IF;
   ELSIF (NOT old_exists_ AND NOT new_exists_) THEN
      IF show_info_ THEN
         Show_Message___('Rename_Constraint: Source constraint ' || source_constraint_ || ' does not exist.');
      END IF;
   ELSE
      IF Index_Exist(source_constraint_, table_name_) THEN
         Rename_Index(source_constraint_, target_constraint_, show_info_, exception_);
      END IF;
      stmnt_ := 'ALTER TABLE ' || table_name_ || ' RENAME CONSTRAINT ' || source_constraint_ || ' TO ' || target_constraint_;
      Run_Ddl_Command___(stmnt_, 'Rename_Constraint', show_info_);
      IF show_info_ THEN
         Show_Message___('Rename_Constraint: Constraint ' || source_constraint_ || ' renamed to ' || target_constraint_ || '.');
      END IF;
   END IF;
END Rename_Constraint;


PROCEDURE Rename_Index (
   source_index_       IN VARCHAR2,
   target_index_       IN VARCHAR2,
   show_info_          IN BOOLEAN  DEFAULT FALSE,
   exception_          IN BOOLEAN  DEFAULT TRUE )
IS
   stmnt_            VARCHAR2(400);
   old_exists_       BOOLEAN := Index_Exist(source_index_);
   new_exists_       BOOLEAN := Index_Exist(target_index_);
BEGIN
   IF (NOT old_exists_ AND new_exists_) THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___('Rename_Index: Index ' || source_index_ || ' is already renamed to ' || target_index_ || '.');
      END IF;
   ELSIF (old_exists_ AND new_exists_) THEN
      IF show_info_ AND verbose_ THEN
         Show_Message___('Rename_Index: Target index ' || target_index_ || ' already exist.');
      END IF;
      IF exception_ THEN
         Raise_Application_Error(-20105, 'Rename_Index: Target index ' || target_index_ || ' already exist.');
      END IF;
   ELSIF (NOT old_exists_ AND NOT new_exists_) THEN
      IF show_info_ THEN
         Show_Message___('Rename_Index: Source index ' || source_index_ || ' does not exist.');
      END IF;
   ELSE
      stmnt_ := 'ALTER INDEX ' || source_index_ || ' RENAME TO ' || target_index_;
      Run_Ddl_Command___(stmnt_, 'Rename_Index', show_info_);
      IF show_info_ THEN
         Show_Message___('Rename_Index: Index ' || source_index_ || ' renamed to ' || target_index_ || '.');
      END IF;
   END IF;
END Rename_Index;


PROCEDURE Reset_Column (
   column_ IN OUT NOCOPY ColRec )
IS
BEGIN
   column_.table_name    := NULL;
   column_.column_name   := NULL;
   column_.data_type     := NULL;
   column_.nullable      := NULL;
   column_.default_value := NULL;
   column_.keep_default  := NULL;
END Reset_Column;


PROCEDURE Reset_Column_Table (
   columns_ IN OUT NOCOPY ColumnTabType )
IS
BEGIN
   columns_.DELETE;
END Reset_Column_Table;


FUNCTION Set_Column_Values (
   column_name_   IN     VARCHAR2,
   data_type_     IN     VARCHAR2 DEFAULT NULL,
   nullable_      IN     VARCHAR2 DEFAULT NULL,
   default_value_ IN     VARCHAR2 DEFAULT NULL,
   lob_parameter_ IN     VARCHAR2 DEFAULT NULL,
   keep_default_  IN     VARCHAR2 DEFAULT NULL ) RETURN ColRec
IS
   column_               ColRec;
BEGIN
   column_.column_name   := column_name_;
   column_.data_type     := data_type_;
   column_.nullable      := nullable_;
   column_.default_value := default_value_;
   column_.lob_parameter := lob_parameter_;
   column_.keep_default  := keep_default_;
   RETURN (column_);
END Set_Column_Values;


PROCEDURE Set_Table_Column (
   columns_ IN OUT NOCOPY ColumnTabType,
   column_  IN     ColRec )
IS
   col_ix_        NUMBER;
BEGIN
   col_ix_ := columns_.COUNT + 1;
   columns_(col_ix_) := column_;
END Set_Table_Column;


PROCEDURE Set_Table_Column (
   columns_       IN OUT NOCOPY ColumnTabType,
   column_name_   IN     VARCHAR2,
   data_type_     IN     VARCHAR2 DEFAULT NULL,
   nullable_      IN     VARCHAR2 DEFAULT NULL,
   default_value_ IN     VARCHAR2 DEFAULT NULL,
   lob_parameter_ IN     VARCHAR2 DEFAULT NULL,
   keep_default_  IN     VARCHAR2 DEFAULT NULL )
IS
BEGIN
   Set_Table_Column (columns_, Set_Column_Values(column_name_, data_type_, nullable_, default_value_, lob_parameter_, keep_default_));
END Set_Table_Column;


FUNCTION Set_View_Column_Values (
   column_name_    IN     VARCHAR2,
   column_source_  IN     VARCHAR2,
   column_comment_ IN     VARCHAR2 DEFAULT NULL ) RETURN ColViewRec
IS
   column_               ColViewRec;
BEGIN
   column_.column_name    := column_name_;
   column_.column_source  := column_source_;
   column_.column_comment := column_comment_;
   RETURN (column_);
END Set_View_Column_Values;


PROCEDURE Set_View_Column (
   columns_ IN OUT NOCOPY ColumnViewType,
   column_  IN     ColViewRec )
IS   
   col_ix_        NUMBER;
BEGIN
   col_ix_ := columns_.COUNT + 1;
   columns_(col_ix_) := column_;
END Set_View_Column;


PROCEDURE Set_View_Column (
   columns_        IN OUT NOCOPY ColumnViewType,
   column_name_    IN     VARCHAR2,
   column_source_  IN     VARCHAR2,
   column_comment_ IN     VARCHAR2 DEFAULT NULL )
IS
BEGIN
   Set_View_Column (columns_, Set_View_Column_Values(column_name_, column_source_, column_comment_));
END Set_View_Column;


FUNCTION Sequence_Exist (
   sequence_name_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_          NUMBER := 0;
   CURSOR check_sequence IS
      SELECT  1
      FROM    user_sequences
      WHERE   sequence_name = UPPER(sequence_name_);
BEGIN
   OPEN  check_sequence;
   FETCH check_sequence INTO dummy_;
   IF (check_sequence%FOUND) THEN
      CLOSE check_sequence;
      RETURN TRUE;
   ELSE
      CLOSE check_sequence;
      RETURN FALSE;
   END IF;
END Sequence_Exist;


FUNCTION Table_Exist (
   table_name_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_          NUMBER := 0;
   CURSOR check_table IS
      SELECT  1
      FROM    user_tables
      WHERE   table_name = UPPER(table_name_);
BEGIN
   OPEN  check_table;
   FETCH check_table INTO dummy_;
   IF (check_table%FOUND) THEN
      CLOSE check_table;
      RETURN TRUE;
   ELSE
      CLOSE check_table;
      RETURN FALSE;
   END IF;
END Table_Exist;


FUNCTION Type_Exist (
   type_name_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_          NUMBER := 0;
   CURSOR check_type IS
      SELECT  1
      FROM    user_types
      WHERE   type_name = UPPER(type_name_);
BEGIN
   OPEN  check_type;
   FETCH check_type INTO dummy_;
   IF (check_type%FOUND) THEN
      CLOSE check_type;
      RETURN TRUE;
   ELSE
      CLOSE check_type;
      RETURN FALSE;
   END IF;
END Type_Exist;


FUNCTION Text_Index_Exist (
   index_name_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_          NUMBER := 0;
   CURSOR check_index IS
      SELECT  1
      FROM    ctx_user_indexes
      WHERE   idx_name = UPPER(index_name_);
BEGIN
   OPEN  check_index;
   FETCH check_index INTO dummy_;
   IF (check_index%FOUND) THEN
      CLOSE check_index;
      RETURN TRUE;
   ELSE
      CLOSE check_index;
      RETURN FALSE;
   END IF;
END Text_Index_Exist;


FUNCTION Trigger_Exist (
   trigger_name_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_          NUMBER := 0;
   CURSOR check_trigger IS
      SELECT  1
      FROM    user_triggers
      WHERE   trigger_name = UPPER(trigger_name_);
BEGIN
   OPEN  check_trigger;
   FETCH check_trigger INTO dummy_;
   IF (check_trigger%FOUND) THEN
      CLOSE check_trigger;
      RETURN TRUE;
   ELSE
      CLOSE check_trigger;
      RETURN FALSE;
   END IF;
END Trigger_Exist;


FUNCTION View_Exist (
   view_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_          NUMBER := 0;
   CURSOR check_view IS
      SELECT  1
      FROM    user_views
      WHERE   view_name = UPPER(view_name_);
BEGIN
   OPEN  check_view;
   FETCH check_view INTO dummy_;
   IF (check_view%FOUND) THEN
      CLOSE check_view;
      RETURN TRUE;
   ELSE
      CLOSE check_view;
      RETURN FALSE;
   END IF;
END View_Exist;


FUNCTION Package_Exist (
   package_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
BEGIN
   RETURN Object_Exist(package_name_, 'PACKAGE');
END Package_Exist;


FUNCTION Primary_Key_Constraint_Exist (
   table_name_      IN VARCHAR2) RETURN BOOLEAN
IS
   dummy_          NUMBER := 0;
   CURSOR check_constraint IS
      SELECT  1
      FROM    user_constraints
      WHERE   table_name = upper(table_name_)
      AND     constraint_type = 'P';
BEGIN
   OPEN  check_constraint;
   FETCH check_constraint INTO dummy_;
   IF (check_constraint%FOUND) THEN
      CLOSE check_constraint;
      RETURN TRUE;
   ELSE
      CLOSE check_constraint;
      RETURN FALSE;
   END IF;
END Primary_Key_Constraint_Exist;


FUNCTION Method_Exist (
   package_name_ IN VARCHAR2,
   method_name_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   temp_ NUMBER;
BEGIN  
   SELECT 1 INTO temp_
     FROM user_procedures
    WHERE object_name    = upper(package_name_)
      AND procedure_name = upper(method_name_);
   
   RETURN TRUE;
EXCEPTION
   WHEN no_data_found THEN
      RETURN FALSE;
   WHEN too_many_rows THEN
      -- There are overloads
      RETURN TRUE;
END Method_Exist;


FUNCTION Mtrl_View_Exist (
   mtrl_view_ IN VARCHAR2) RETURN BOOLEAN 
IS
   dummy_   NUMBER;
   CURSOR get_mtrl_view IS
      SELECT 1 
      FROM user_mviews
      WHERE mview_name = Upper(mtrl_view_);
BEGIN
   OPEN get_mtrl_view;
   FETCH get_mtrl_view INTO dummy_;
   IF get_mtrl_view%FOUND THEN
      CLOSE get_mtrl_view;
      RETURN TRUE;
   ELSE
      CLOSE get_mtrl_view;
      RETURN FALSE;
   END IF;
END Mtrl_View_Exist;


FUNCTION Mtrl_View_Log_Exist (
   mtrl_view_log_tbl_ IN VARCHAR2) RETURN BOOLEAN 
IS
   dummy_   NUMBER;
   CURSOR get_mtrl_view IS
      SELECT 1 
      FROM user_mview_logs
      WHERE master = Upper(mtrl_view_log_tbl_);
BEGIN
   OPEN get_mtrl_view;
   FETCH get_mtrl_view INTO dummy_;
   IF get_mtrl_view%FOUND THEN
      CLOSE get_mtrl_view;
      RETURN TRUE;
   ELSE
      CLOSE get_mtrl_view;
      RETURN FALSE;
   END IF;
END Mtrl_View_Log_Exist;

PROCEDURE Move_Lob_Segment (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2, 
   tablespace_  IN VARCHAR2 DEFAULT 'IFSAPP_LOB',
   show_info_   IN BOOLEAN  DEFAULT TRUE )
IS
   stmt_ VARCHAR2(600) := 'ALTER TABLE ' || table_name_ || ' MOVE LOB (' || column_name_ ||  ') STORE AS SECUREFILE (TABLESPACE '||tablespace_||')';
BEGIN
   --
   -- Note! This command locks the table, possibly a long time for a large table, meaning endusers cannot use the table during the operation
   --       Enable row movement must be enabled on the table in order to make the shrink command available
   --       May lead to unusable Search Domain indexes
   IF Is_Table_Temporary___(table_name_) THEN
      Show_Message___('Move_Lob_Segment error: Lob columns in temporary tables should not be modified. Drop and recreate the table instead.');
      RETURN;
   END IF;
   Run_Ddl_Command___(stmt_, 'Move_Lob_Segment', show_info_);
   IF show_info_ THEN
      Show_Message___('Move_Lob_Segment: Lob Segment ' || table_name_ || ', ' || column_name_ || ' moved and shrinked.');
   END IF;
END Move_Lob_Segment;


PROCEDURE Move_Object (
   object_name_      IN VARCHAR2,    
   tablespace_       IN VARCHAR2 DEFAULT NULL,
   show_info_        IN BOOLEAN  DEFAULT FALSE,
   forced_offline_   IN BOOLEAN  DEFAULT FALSE)
IS
   
BEGIN  
   IF Object_Exist(object_name_, 'TABLE') THEN
      Move_Table___('Move_Table', object_name_, tablespace_, show_info_);
   ELSIF Object_Exist(object_name_, 'INDEX') THEN
      Move_Index___('Move_Index', object_name_, tablespace_, show_info_,forced_offline_);
   ELSE
      IF show_info_ THEN
         Show_Message___ ('Move_Objects: Object ' || object_name_ || ' does not exists.');
      END IF;  
   END IF;
END Move_Object;


FUNCTION Get_TableSpace_Name (
   object_name_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   CURSOR get_table_tablespace IS
      SELECT   tablespace_name
      FROM     user_tables
      WHERE    table_name  = UPPER(object_name_);
      
   CURSOR get_index_tablespace IS
      SELECT   tablespace_name
      FROM     user_indexes
      WHERE    index_name  = UPPER(object_name_);
   
   tablespace_name_      VARCHAR2(ORA_MAX_NAME_LEN);
BEGIN
   IF Object_Exist(object_name_, 'TABLE') THEN
      OPEN get_table_tablespace;
      FETCH get_table_tablespace INTO tablespace_name_;
      CLOSE get_table_tablespace;
   ELSIF Object_Exist(object_name_, 'INDEX') THEN
      OPEN get_index_tablespace;
      FETCH get_index_tablespace INTO tablespace_name_;
      CLOSE get_index_tablespace;
   END IF;
   RETURN tablespace_name_;
END Get_TableSpace_Name;


FUNCTION Get_Lob_Freepools (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2 ) RETURN NUMBER
IS
   CURSOR get_lob IS 
   SELECT nvl(freepools, 1)
   FROM user_lobs
   WHERE table_name = table_name_
   AND   column_name = column_name_;
   freepools_  NUMBER;
BEGIN
   OPEN  get_lob;
   FETCH get_lob INTO freepools_;
   CLOSE get_lob;
   RETURN (freepools_);
END Get_Lob_Freepools;


PROCEDURE Get_Lob_Sizes (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2,
   total_blocks_ OUT NUMBER,
   total_bytes_ OUT NUMBER,
   unused_blocks_ OUT NUMBER,
   unused_bytes_ OUT NUMBER,
   last_used_extent_file_id_ OUT NUMBER,
   last_used_extent_block_id_ OUT NUMBER,
   last_used_block_ OUT NUMBER )
IS
   CURSOR get_lob IS 
   SELECT segment_name
   FROM user_lobs
   WHERE table_name = table_name_
   AND   column_name = column_name_;
   
   segment_name_  VARCHAR2(ORA_MAX_NAME_LEN);
BEGIN
   OPEN  get_lob;
   FETCH get_lob INTO segment_name_;
   CLOSE get_lob;
   Dbms_Space.Unused_Space(Sys_Context('USERENV', 'CURRENT_SCHEMA'), segment_name_, 'LOB', total_blocks_, total_bytes_, unused_blocks_, unused_bytes_, 
                           last_used_extent_file_id_, last_used_extent_block_id_, last_used_block_); 

END Get_Lob_Sizes;


PROCEDURE Alter_Lob_Freepools (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2, 
   show_info_   IN BOOLEAN  DEFAULT TRUE )
IS
   freepools_   VARCHAR2(10)  := Get_Lob_Freepools(table_name_, column_name_);
   stmt_        VARCHAR2(600) := 'ALTER TABLE ' || table_name_ || ' MODIFY LOB (' || column_name_ ||  ') (FREEPOOLS '||freepools_||')';
BEGIN
   IF Is_Table_Temporary___(table_name_) THEN
      Show_Message___('Alter_Lob_Freepools error: Lob columns in temporary tables should not be modified. Drop and recreate the table instead.');
      RETURN;
   END IF;
   --
   -- Note! This command locks the table, possibly a long time for a large table, meaning endusers cannot use the table during the operation
   --       Enable row movement must be enabled on the table in order to make the shrink command available
   --
   Run_Ddl_Command___(stmt_, 'Alter_Lob_Freepools', show_info_);
   IF show_info_ THEN
      Show_Message___('Alter_Lob_Freepools: Lob Segment ' || table_name_ || ', ' || column_name_ || ' have altered freepool to '||freepools_||'.');
   END IF;
END Alter_Lob_Freepools;


PROCEDURE Change_Lob_Row_Movement (
   table_name_  IN VARCHAR2,
   column_name_ IN VARCHAR2, 
   tablespace_  IN VARCHAR2 DEFAULT 'IFSAPP_LOB',
   show_info_   IN BOOLEAN  DEFAULT TRUE )
IS
   stmt_ VARCHAR2(600) := 'ALTER TABLE ' || table_name_ || ' MOVE lob (' || column_name_ ||  ') STORE AS SECUREFILE (TABLESPACE '||tablespace_||' ENABLE STORAGE IN ROW )';
BEGIN
   IF Is_Table_Temporary___(table_name_) THEN
      Show_Message___('Change_Lob_Row_Movement error: Lob columns in temporary tables should not be modified. Drop and recreate the table instead.');
      RETURN;
   END IF;
   --
   -- Note! This command locks the table, possibly a long time for a large table, meaning endusers cannot use the table during the operation
   --       Enable row movement must be enabled on the table in order to make the shrink command available
   --
   Run_Ddl_Command___(stmt_, 'Change_Lob_Row_Movement', show_info_);
   IF show_info_ THEN
      Show_Message___('Change_Lob_Row_Movement: Lob Segment ' || table_name_ || ', ' || column_name_ || ' moved and shrinked.');
   END IF;
END Change_Lob_Row_Movement;

PROCEDURE Register_Sub_Section (
   module_        IN VARCHAR2,
   register_id_   IN VARCHAR2,
   sub_section_   IN NUMBER  DEFAULT 1,
   processed_ok_  IN VARCHAR2,
   status_info_   IN VARCHAR2 DEFAULT NULL,
   file_name_     IN VARCHAR2 DEFAULT NULL,
   description_   IN VARCHAR2 DEFAULT NULL )
IS
   stmt_  VARCHAR2(4000);
   PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
   stmt_ :=
   'BEGIN '||
   '   INSERT INTO db_script_register_tab '||
   '   (module, register_id, processed_ok, no_sub_sections, file_name, rowversion, rowkey) '||
   '   VALUES '||
   '   (UPPER(:module_), :register_id_, ''FALSE'', 0, :file_name_, sysdate, sys_guid()); '||
   'EXCEPTION '||
   '   WHEN dup_val_on_index THEN '||
   '      NULL; '||
   'END; ';
   --@ApproveDynamicStatement(2015-06-30,mabose)
   EXECUTE IMMEDIATE stmt_ USING module_, register_id_, file_name_;

   stmt_ :=
   'DECLARE '||
   '   module_        db_script_register_detail_tab.module%TYPE := UPPER(:module); '||
   '   register_id_   db_script_register_detail_tab.register_id%TYPE  := :register_id; '||
   '   sub_section_   db_script_register_detail_tab.sub_section%TYPE := :sub_section; '||
   '   processed_ok_  db_script_register_detail_tab.processed_ok%TYPE := :processed_ok; '||
   '   description_   db_script_register_detail_tab.description%TYPE := :description; '||
   '   status_info_   db_script_register_detail_tab.status_info%TYPE := :status_info; '||
   'BEGIN '||
   '   INSERT INTO db_script_register_detail_tab '||
   '      (module, register_id, sub_section, processed_ok, description, status_info, rowversion, rowkey) '||
   '   VALUES '||
   '      (module_, register_id_, sub_section_, NVL(processed_ok_, ''FALSE''), description_, status_info_, sysdate, sys_guid()); '||
   '   UPDATE db_script_register_tab '||
   '   SET no_sub_sections = NVL(no_sub_sections, 0) + 1, '||
   '       rowversion = sysdate '||
   '   WHERE module = module_ '||
   '   AND   register_id = register_id_; '||
   'EXCEPTION '||
   '   WHEN dup_val_on_index THEN '||
   '      UPDATE db_script_register_detail_tab '||
   '      SET processed_ok = processed_ok_, '||
   '          description = NVL(description_, description), '||
   '          status_info = status_info_, '||
   '          rowversion = sysdate '||
   '      WHERE module = module_ '||
   '      AND   register_id = register_id_ '||
   '      AND   sub_section = sub_section_; '||
   'END;';
   --@ApproveDynamicStatement(2015-06-30,mabose)
   EXECUTE IMMEDIATE stmt_ USING module_, register_id_, sub_section_, processed_ok_, description_, status_info_;
   
   stmt_ :=
   'DECLARE '||
   '   module_        db_script_register_detail_tab.module%TYPE := UPPER(:module); '||
   '   register_id_   db_script_register_detail_tab.register_id%TYPE  := :register_id; '||
   '   processed_ok_  db_script_register_detail_tab.processed_ok%TYPE; '||
   'BEGIN '||
   '   SELECT MIN(processed_ok) '||
   '   INTO processed_ok_ '||
   '   FROM db_script_register_detail_tab '||
   '   WHERE module = module_ '||
   '   AND register_id = register_id_; '||
   '   UPDATE db_script_register_tab '||
   '   SET processed_ok = NVL(processed_ok_, ''FALSE''), '||
   '       rowversion = sysdate '||
   '   WHERE module = module_ '||
   '   AND   register_id = register_id_; '||
   'END;';
   --@ApproveDynamicStatement(2015-06-30,mabose)
   EXECUTE IMMEDIATE stmt_ USING module_, register_id_;

   --@ApproveTransactionStatement(2015-06-30,mabose)
   COMMIT;
END Register_Sub_Section;


PROCEDURE Clear_Sub_Section (
   module_        IN VARCHAR2,
   register_id_   IN VARCHAR2,
   sub_section_   IN NUMBER )
IS
   stmt_  VARCHAR2(4000);
   PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
   stmt_ :=
   'DECLARE '||
   '   module_        db_script_register_detail_tab.module%TYPE := UPPER(:module); '||
   '   register_id_   db_script_register_detail_tab.register_id%TYPE  := :register_id; '||
   '   sub_section_   db_script_register_detail_tab.sub_section%TYPE := :sub_section; '||
   'BEGIN '||
   '   DELETE FROM db_script_register_detail_tab '||
   '      WHERE module = module_ '||
   '      AND   register_id = register_id_ '||
   '      AND   sub_section = sub_section_; '||
   '   UPDATE db_script_register_tab '||
   '   SET no_sub_sections = GREATEST((NVL(no_sub_sections, 0) - 1), 0), '||
   '       rowversion = sysdate '||
   '   WHERE module = module_ '||
   '   AND   register_id = register_id_; '||
   'EXCEPTION '||
   '   WHEN no_data_found THEN '||
   '      NULL; '||
   'END;';
   --@ApproveDynamicStatement(2015-06-30,mabose)
   EXECUTE IMMEDIATE stmt_ USING module_, register_id_, sub_section_;

   stmt_ :=
   'DECLARE '||
   '   module_        db_script_register_detail_tab.module%TYPE := UPPER(:module); '||
   '   register_id_   db_script_register_detail_tab.register_id%TYPE  := :register_id; '||
   '   processed_ok_  db_script_register_detail_tab.processed_ok%TYPE; '||
   'BEGIN '||
   '   SELECT MIN(processed_ok) '||
   '   INTO processed_ok_ '||
   '   FROM db_script_register_detail_tab '||
   '   WHERE module = module_ '||
   '   AND register_id = register_id_; '||
   '   UPDATE db_script_register_tab '||
   '   SET processed_ok = NVL(processed_ok_, ''FALSE''), '||
   '       rowversion = sysdate '||
   '   WHERE module = module_ '||
   '   AND   register_id = register_id_; '||
   'END;';
   --@ApproveDynamicStatement(2015-06-30,mabose)
   EXECUTE IMMEDIATE stmt_ USING module_, register_id_;

   --@ApproveTransactionStatement(2015-06-30,mabose)
   COMMIT;
END Clear_Sub_Section;


FUNCTION Is_Sub_Section_Registered (
   module_        IN VARCHAR2,
   register_id_   IN VARCHAR2,
   sub_section_   IN VARCHAR2 ) RETURN BOOLEAN
IS
   stmt_              VARCHAR2(4000);
   sub_section_exist_ VARCHAR2(5);
BEGIN
   IF Method_Exist ('Db_Script_Register_Detail_API', 'Is_Sub_Section_Registered') THEN
      stmt_ :=
      'DECLARE '||
      '   sub_section_exist_ VARCHAR2(5); '||
      'BEGIN '||
      '   IF Db_Script_Register_Detail_API.Is_Sub_Section_Registered(:module_, :register_id_, :sub_section_) THEN'||
      '      :sub_section_exist_ := ''TRUE''; '||
      '   ELSE '||
      '      :sub_section_exist_ := ''FALSE''; '||
      '   END IF; '||
      'END;';
      --@ApproveDynamicStatement(2015-06-30,mabose)
      EXECUTE IMMEDIATE stmt_ USING module_, register_id_, sub_section_, OUT sub_section_exist_;
      IF sub_section_exist_ = 'TRUE' THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   ELSE
      RETURN FALSE;
   END IF;
END Is_Sub_Section_Registered;

PROCEDURE Reset_Module_Delivery_Flags
IS
   stmt_   VARCHAR2(32000) := '
BEGIN
   Module_API.Reset_Module_Delivery_Flags;
END;';
BEGIN
   -- Safe due to executed with Invokers rights
   --@ApproveDynamicStatement(2017-10-02,mabose)
   EXECUTE IMMEDIATE stmt_;
END Reset_Module_Delivery_Flags;

PROCEDURE Grant_Ifssys (
   show_info_ IN BOOLEAN  DEFAULT FALSE )
IS
   grantee_ VARCHAR2(30) := 'IFSSYS';
   method_  VARCHAR2(30) := 'Grant_Ifssys';
   stmt_    VARCHAR2(200);
--
   not_user_or_role   EXCEPTION;
   PRAGMA             EXCEPTION_INIT(not_user_or_role, -1917);
   CURSOR get_tables IS
      SELECT object_name
        FROM user_objects
       WHERE object_type = 'TABLE';

BEGIN
   FOR rec_ IN get_tables LOOP
      -- Camunda data should be editted by the system account directly in the tables; this grant is required for execution
      Run_Ddl_Command___('GRANT SELECT, UPDATE, DELETE, INSERT ON '||rec_.object_name||' TO '||grantee_, 'Grant_Ifssys', show_info_);
   END LOOP;
END Grant_Ifssys;

PROCEDURE Grant_Appowner (
   show_info_ IN BOOLEAN  DEFAULT FALSE )
IS
   grantee_ VARCHAR2(30) := '&APPLICATION_OWNER';
   method_  VARCHAR2(30) := 'Grant_Appowner';
   stmt_    VARCHAR2(200);
--
   not_user_or_role   EXCEPTION;
   PRAGMA             EXCEPTION_INIT(not_user_or_role, -1917);
   CURSOR get_tables IS
      SELECT object_name
        FROM user_objects
       WHERE object_type = 'TABLE';

BEGIN
   FOR rec_ IN get_tables LOOP
      -- Camunda data may be accessed outside the schema for display purposes
      Run_Ddl_Command___('GRANT SELECT ON '||rec_.object_name||' TO '||grantee_||' WITH GRANT OPTION', 'Grant_Appowner', show_info_);
      -- Camunda data should be editted by the system account directly in the tables; this grant is for simplicity
      Run_Ddl_Command___('GRANT UPDATE, DELETE, INSERT ON '||rec_.object_name||' TO '||grantee_, 'Grant_Appowner', show_info_);
   END LOOP;
END Grant_Appowner;

PROCEDURE Set_Verbose
IS
BEGIN
   verbose_ := TRUE;
END Set_Verbose;

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC PROTECTED METHODS --------------------------
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC PRIVATE METHODS ----------------------------
-----------------------------------------------------------------------------

PROCEDURE Change_Index_Buffer_Pool__ (
   index_name_  IN VARCHAR2,
   buffer_pool_ IN VARCHAR2 DEFAULT 'DEFAULT' )
IS
BEGIN
   IF Index_Exist(index_name_) THEN
      --@ApproveDynamicStatement(2006-01-05,utgulk)
      EXECUTE IMMEDIATE 'ALTER INDEX "'||index_name_||'" STORAGE ( BUFFER_POOL '||buffer_pool_||')';
   ELSE
      Show_Message___('Change_Index_Buffer_Pool__: Index (' || index_name_ || ') does not exists.');
   END IF;
END Change_Index_Buffer_Pool__;


PROCEDURE Change_Table_Buffer_Pool__ (
   table_name_  IN VARCHAR2,
   buffer_pool_ IN VARCHAR2 DEFAULT 'DEFAULT' )
IS
BEGIN
   IF Table_Exist(table_name_) THEN
      --@ApproveDynamicStatement(2006-01-05,utgulk)
      EXECUTE IMMEDIATE 'ALTER TABLE "'||table_name_||'" STORAGE ( BUFFER_POOL '||buffer_pool_||')';
   ELSE
      Show_Message___('Change_Table_Buffer_Pool__: Table (' || table_name_ || ') does not exists.');
   END IF;
END Change_Table_Buffer_Pool__;


PROCEDURE Coalesce_Index__ (
   index_name_ IN  VARCHAR2 )
IS
BEGIN
   IF Index_Exist(index_name_) THEN
      --@ApproveDynamicStatement(2006-01-05,utgulk)
      EXECUTE IMMEDIATE 'ALTER INDEX "'||index_name_||'" COALESCE ';
   ELSE
      Show_Message___('Coalesce_Index__: Index (' || index_name_ || ') does not exists.');
   END IF;
END Coalesce_Index__;

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC IMPLEMENTATION METHODS ---------------------
-----------------------------------------------------------------------------

PROCEDURE Alter_Table_Column___ (
   procedure_name_  IN VARCHAR2,
   table_name_      IN VARCHAR2,
   alter_type_      IN VARCHAR2,
   column_          IN ColRec,
   show_info_       IN BOOLEAN DEFAULT FALSE )
IS
   chk_alter_type_  VARCHAR2(20);
   ok_              NUMBER := 1;
   stmnt_           VARCHAR2(4000);
   col_string_      VARCHAR2(4000);
   wrong_alter_type EXCEPTION;
   column_rec_      ColRec := column_;
   column_rec2_     ColRec := column_;

   alter_domain_index EXCEPTION;
   PRAGMA             EXCEPTION_INIT(alter_domain_index, -29885);
BEGIN
   column_rec_.table_name := table_name_;
   IF NOT (Table_Exist ( table_name_ ) ) THEN
      IF show_info_ THEN
         Show_Message___ (procedure_name_ || ': Table ' || table_name_ || ' does not exist.');
      END IF;
      ok_ := 0;
   ELSE
      chk_alter_type_ := alter_type_;
      IF (alter_type_ LIKE 'A%') THEN
         chk_alter_type_ := 'ADD';
      ELSIF (alter_type_ LIKE 'M%') THEN
         chk_alter_type_ := 'MODIFY';
      ELSIF (alter_type_ LIKE 'D%') THEN
         chk_alter_type_ := 'DROP COLUMN';
      ELSE
         RAISE wrong_alter_type;
      END IF;
      IF (chk_alter_type_ = 'ADD') THEN
         IF (column_rec_.data_type IS NULL) THEN
            IF show_info_ THEN
               Show_Message___ (procedure_name_ || ': Table/Column ' || table_name_ || '/' || column_rec_.column_name || ' must have a datatype to be added.');
            END IF;
            ok_ := 0;
         END IF;
         IF (Column_Exist ( table_name_, column_rec_.column_name)) THEN
            IF show_info_ AND verbose_ THEN
               Show_Message___ (procedure_name_ || ': Table/Column ' || table_name_ || '/' || column_rec_.column_name || ' already exist.');
            END IF;
            ok_ := 0;
         END IF;
      ELSIF (chk_alter_type_ = 'MODIFY') THEN
         IF NOT (Column_Exist ( table_name_, column_rec_.column_name)) THEN
            IF show_info_ THEN
               Show_Message___ (procedure_name_ || ' error: Table/Column ' || table_name_ || '/' || column_rec_.column_name || ' does not exist.');
            END IF;
            ok_ := 0;
         ELSIF NOT Is_Column_Modified___(table_name_,column_rec_) THEN
            IF show_info_ AND verbose_ THEN
               Show_Message___ (procedure_name_ || ': Table/Column ' || table_name_ || '/' || column_rec_.column_name || ' already modified.');
            END IF;
            ok_ := 0;
         ELSIF (column_rec_.column_name = 'ROWKEY' AND               -- Special handling for ROWKEY
                nvl(column_rec_.keep_default, 'N') != 'D' AND                  -- If Disable let it run
                Is_Column_Modified___(table_name_, column_rec_)) THEN -- if it is changed
            -- Special handling for ROWKEY
               Show_Message___ (procedure_name_ || ': Table/Column ' || table_name_ || '/' || column_rec_.column_name || ' cannot be enabled or disabled with this interface.');
            ok_ := 0;            
         END IF;
      ELSIF (chk_alter_type_ = 'DROP COLUMN') THEN
         IF NOT (Column_Exist ( table_name_, column_rec_.column_name)) THEN
            IF show_info_ THEN
               Show_Message___ (procedure_name_ || ': Table/Column ' || table_name_ || '/' || column_rec_.column_name || ' does not exist.');
            END IF;
            ok_ := 0;
         END IF;
      END IF;
   END IF;
   IF (ok_ = 1) THEN
      IF (chk_alter_type_ = 'DROP COLUMN') THEN
         col_string_ := Format_Column(column_rec_, 'INDEX');
      ELSE
         col_string_ := Format_Column(column_rec_, 'TABLE');
      END IF;
      Remove_Extended_Stats___(table_name_, column_.column_name);
      stmnt_ := 'ALTER TABLE ' || table_name_ || ' ' || chk_alter_type_ || ' ' || col_string_;
      Run_Ddl_Command___(stmnt_, procedure_name_, show_info_);
      IF (chk_alter_type_ = 'ADD') THEN
         IF  column_rec_.default_value IS NOT NULL
         AND column_rec_.default_value != '$DEFAULT_NULL$'
         AND UPPER(column_rec_.keep_default) = 'N' THEN
            stmnt_ := 'ALTER TABLE ' || table_name_ || ' MODIFY ' || column_rec_.column_name || ' DEFAULT NULL';
            Run_Ddl_Command___(stmnt_, procedure_name_, show_info_);
            IF  column_rec_.nullable = 'N' THEN
               stmnt_ := 'ALTER TABLE ' || table_name_ || ' MODIFY ' || column_rec_.column_name || ' NOT NULL';
               Run_Ddl_Command___(stmnt_, procedure_name_, show_info_);
            END IF;
         END IF;
         IF show_info_ THEN
            Show_Message___(procedure_name_ || ': Column ' || column_rec_.column_name || ' in table ' || table_name_ || ' is added.');
         END IF;
      ELSIF (chk_alter_type_ = 'MODIFY') THEN
         IF  column_rec_.default_value IS NOT NULL
         AND column_rec_.default_value != '$DEFAULT_NULL$'
         AND UPPER(column_rec_.keep_default) = 'N' THEN
            stmnt_ := 'ALTER TABLE ' || table_name_ || ' MODIFY ' || column_rec_.column_name || ' DEFAULT NULL';
            Run_Ddl_Command___(stmnt_, procedure_name_, show_info_);
         END IF;
         IF  column_rec_.nullable = 'N' AND Get_Column_Nullable(table_name_, column_.column_name) = 'Y' THEN
            stmnt_ := 'ALTER TABLE ' || table_name_ || ' MODIFY ' || column_rec_.column_name || ' NOT NULL';
            Run_Ddl_Command___(stmnt_, procedure_name_, show_info_);
         END IF;
         IF show_info_ THEN
            Show_Message___(procedure_name_ || ': Column ' || column_rec_.column_name || ' in table ' || table_name_||' is modified.');
         END IF;
      ELSIF (chk_alter_type_ = 'DROP COLUMN') THEN
         IF show_info_ THEN
            Show_Message___(procedure_name_ || ': Column ' || column_rec_.column_name || ' in table ' || table_name_ || ' is dropped.');
         END IF;
      END IF;
   END IF;
EXCEPTION
   WHEN wrong_alter_type THEN
      Show_Message___('Alter_Table_Column error: Wrong alter type, alter type must be ''A[LTER]'',''M[ODIFY]'' or ''D[ROP COLUMN]''.');
   WHEN alter_domain_index THEN
      Show_Message___('Alter_Table_Column error: Cannot alter a column which has a DOMAIN INDEX. To alter the column, drop the DOMAIN INDEX and rerun the script.');
   WHEN OTHERS THEN
      RAISE;
END Alter_Table_Column___;


FUNCTION Is_Table_Temporary___ (
   table_name_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   temporary_ VARCHAR2(10);
   CURSOR get_table_info IS
      SELECT temporary
      FROM   user_tables
      WHERE  table_name = UPPER(table_name_);
BEGIN
   OPEN  get_table_info;
   FETCH get_table_info INTO temporary_;
   CLOSE get_table_info;
   IF (temporary_ = 'Y') THEN
      RETURN(TRUE);
   ELSE
      RETURN(FALSE);
   END IF;
END Is_Table_Temporary___;


PROCEDURE Move_Index___ (
   procedure_name_  IN VARCHAR2,
   index_name_      IN VARCHAR2,
   tablespace_name_ IN VARCHAR2 DEFAULT 'IFSAPP_INDEX',
   show_info_       IN BOOLEAN  DEFAULT FALSE,
   forced_offline_  IN BOOLEAN  DEFAULT FALSE)
IS
   stmt_          VARCHAR2(2000);
   current_ts_    VARCHAR2(ORA_MAX_NAME_LEN);
BEGIN
   current_ts_ := UPPER(Get_TableSpace_Name(index_name_));
   IF current_ts_ != UPPER(tablespace_name_) THEN
      stmt_ := 'ALTER INDEX "'||index_name_||'" REBUILD TABLESPACE '|| tablespace_name_;
      IF Is_Option_Available('Online Index Build') AND NOT forced_offline_ THEN
         stmt_ := stmt_ || ' ONLINE ';
      END IF;
      IF Is_Table_Temporary___(Get_Index_Table(index_name_)) = FALSE 
      AND Get_Index_Type(index_name_) IN ('NORMAL', 'FUNCTION-BASED NORMAL') THEN
         stmt_ := stmt_ || ' PARALLEL NOLOGGING ';
      END IF;
      Run_Ddl_Command___(stmt_, procedure_name_, show_info_);
      IF show_info_ THEN
         Show_Message___(procedure_name_ || ': Index ' || index_name_ || ' moved to tablespace '||tablespace_name_||'.');
      END IF;   
   ELSE
      IF show_info_ AND verbose_ THEN
         Show_Message___(procedure_name_ || ': Index ' || index_name_ || ' is already in tablespace '|| tablespace_name_ || '.');
      END IF;
   END IF;   
END Move_Index___;   


PROCEDURE Move_Table___ (
   procedure_name_  IN VARCHAR2,
   table_name_      IN VARCHAR2,
   tablespace_name_ IN VARCHAR2 DEFAULT 'IFSAPP_DATA',
   show_info_       IN BOOLEAN  DEFAULT FALSE )
IS
   stmt_          VARCHAR2(2000);
   
   objects_ ObjectArray;   
   tab_   VARCHAR2(ORA_MAX_NAME_LEN) := UPPER(table_name_);
   current_ts_ VARCHAR2(128);

   CURSOR get_ind IS
      SELECT index_name
      FROM   user_indexes i
      WHERE  i.table_name = tab_
      AND    i.index_type != 'LOB';
       
BEGIN
   current_ts_ := UPPER(Get_TableSpace_Name(tab_));
   IF current_ts_ != UPPER(tablespace_name_) THEN
      stmt_ := 'ALTER TABLE "'||table_name_||'" MOVE TABLESPACE ' || tablespace_name_;    
      Run_Ddl_Command___(stmt_, procedure_name_, show_info_);
      IF show_info_ THEN
         Show_Message___(procedure_name_ || ': Table ' || table_name_ || ' moved.');
      END IF;
      -- Rebuild indexes for this table
      OPEN  get_ind;
      FETCH get_ind BULK COLLECT INTO objects_;
      CLOSE get_ind;
      FOR i IN Nvl(objects_.FIRST,0)..Nvl(objects_.LAST,-1) LOOP
         Rebuild_Index___ ('Move_Table___', objects_(i).object_name, show_info_, table_name_);
      END LOOP;
   ELSE
      IF show_info_ AND verbose_ THEN
         Show_Message___(procedure_name_ || ': Table ' || table_name_ || ' is already in tablespace '|| tablespace_name_ || '.');
      END IF;
   END IF;   
END Move_Table___;  


PROCEDURE Rebuild_Index___ (
   procedure_name_   IN VARCHAR2,
   index_name_       IN VARCHAR2,
   show_info_        IN BOOLEAN  DEFAULT FALSE,
   table_name_       IN VARCHAR2 DEFAULT NULL)
IS
   stmt_          VARCHAR2(200) := 'ALTER INDEX "'||index_name_||'" REBUILD ';
   stmt2_         VARCHAR2(200) := stmt_;
   online_error   EXCEPTION;
   PRAGMA         EXCEPTION_INIT(online_error, -1450);
BEGIN
   IF Is_Option_Available('Online Index Build') THEN
      stmt_ := stmt_ || ' ONLINE ';
   END IF;
   IF Is_Table_Temporary___(NVL(table_name_, Get_Index_Table(index_name_))) = FALSE 
   AND Get_Index_Type(index_name_) IN ('NORMAL', 'FUNCTION-BASED NORMAL') THEN
      stmt_ := stmt_ || ' PARALLEL NOLOGGING ';
   END IF;
   Run_Ddl_Command___(stmt_, procedure_name_, show_info_);
   IF show_info_ THEN
      Show_Message___(procedure_name_ || ': Index ' || index_name_ || ' rebuilt.');
   END IF;
EXCEPTION
   WHEN online_error THEN
      Run_Ddl_Command___(stmt2_, procedure_name_, show_info_);
      IF show_info_ THEN
         Show_Message___(procedure_name_ || ': Index ' || index_name_ || ' rebuilt.');
      END IF;
END Rebuild_Index___;


PROCEDURE Remove_Constraints___ (
   procedure_name_  IN VARCHAR2,
   table_name_      IN VARCHAR2,
   constraint_name_ IN VARCHAR2 DEFAULT '%',
   show_info_       IN BOOLEAN  DEFAULT FALSE )
IS
   objects_ ObjectArray;
   
   tab_   VARCHAR2(ORA_MAX_NAME_LEN) := UPPER(table_name_);
   cons_  VARCHAR2(ORA_MAX_NAME_LEN) := UPPER(constraint_name_);
   stmnt_ VARCHAR2(400);
   
   CURSOR get_cons IS
      SELECT constraint_name
      FROM  user_constraints
      WHERE constraint_name LIKE cons_
      AND   constraint_type IN ('P', 'R', 'U') -- Primary key, referential integrity and unique constraints
      AND   table_name = tab_;

BEGIN
   OPEN  get_cons;
   FETCH get_cons BULK COLLECT INTO objects_;
   CLOSE get_cons;
   FOR i IN Nvl(objects_.FIRST,0)..Nvl(objects_.LAST,-1) LOOP
      stmnt_ := 'ALTER TABLE ' || table_name_ || ' DROP CONSTRAINT ' || objects_(i).object_name || ' CASCADE DROP INDEX';
      Run_Ddl_Command___(stmnt_, procedure_name_, show_info_);
      IF show_info_ THEN
         Show_Message___(procedure_name_ || ': Constraint ' || objects_(i).object_name || ' dropped with cascade.');
      END IF;
   END LOOP;
END Remove_Constraints___;


PROCEDURE Remove_Extended_Stats___ (
   table_name_ IN VARCHAR2,
   column_name_  IN VARCHAR2 )
IS
   app_owner_   VARCHAR2(30);
   CURSOR get_extended_stats IS 
      SELECT extension
      FROM user_stat_extensions
      WHERE table_name = table_name_
      AND INSTR(extension, '"' ||column_name_ ||  '"') > 0
      AND droppable = 'YES';
BEGIN
   BEGIN
      --@ApproveDynamicStatement(2015-08-19,haarse)
      EXECUTE IMMEDIATE 'BEGIN :app_owner_ := Fnd_Session_API.Get_App_Owner; END;' USING OUT app_owner_;
   EXCEPTION
      WHEN OTHERS THEN
         app_owner_ := NULL;
   END;
   IF app_owner_ IS NOT NULL THEN
      FOR rec IN get_extended_stats LOOP 
         Dbms_Stats.Drop_Extended_Stats(app_owner_, table_name_, rec.extension);
      END LOOP;
   END IF;
END Remove_Extended_Stats___;


PROCEDURE Remove_Indexes___ (
   procedure_name_  IN VARCHAR2,
   table_name_ IN VARCHAR2,
   index_name_ IN VARCHAR2 DEFAULT '%',
   show_info_  IN BOOLEAN  DEFAULT FALSE )
IS
   objects_ IndexArray;
   
   tab_         VARCHAR2(ORA_MAX_NAME_LEN) := UPPER(table_name_);
   ind_         VARCHAR2(ORA_MAX_NAME_LEN) := UPPER(index_name_);
   stmnt_       VARCHAR2(400);
   queue_table_ BOOLEAN := FALSE;
   mw_table_    BOOLEAN := FALSE;
   temp_table_  BOOLEAN := FALSE;
   iot_table_   BOOLEAN := FALSE;
   
   CURSOR get_ind IS
      SELECT index_name, index_type
      FROM   user_indexes i
      WHERE  i.index_name LIKE ind_
      AND    i.table_name = tab_
      AND    i.index_type != 'LOB'
      AND NOT EXISTS (SELECT 1
                      FROM  user_constraints u
                      WHERE i.index_name = u.constraint_name
                      AND   u.table_name = tab_);                      
BEGIN
   OPEN  get_ind;
   FETCH get_ind BULK COLLECT INTO objects_;
   CLOSE get_ind;
   queue_table_ := Is_Table_Queue(tab_);
   mw_table_ := Is_Table_Mw(tab_);
   temp_table_ := Is_Table_Temporary(tab_);
   iot_table_ := Is_Table_Iot(tab_);
   FOR i IN Nvl(objects_.FIRST,0)..Nvl(objects_.LAST,-1) LOOP 
      IF queue_table_ OR mw_table_ OR temp_table_ OR iot_table_ OR objects_(i).index_type IN ('DOMAIN', 'CLUSTER') THEN
         stmnt_ := 'DROP INDEX ' || objects_(i).index_name;
      ELSE   
         stmnt_ := 'DROP INDEX ' || objects_(i).index_name ||' ONLINE';
      END IF;  
      Run_Ddl_Command___(stmnt_, procedure_name_, show_info_);
      IF show_info_ THEN
         Show_Message___(procedure_name_ || ': Index ' ||  objects_(i).index_name || ' dropped.');
      END IF;
   END LOOP;
END Remove_Indexes___;


PROCEDURE Remove_Triggers___ (
   procedure_name_ IN VARCHAR2,
   table_name_     IN VARCHAR2,
   trigger_name_   IN VARCHAR2 DEFAULT '%',
   show_info_      IN BOOLEAN  DEFAULT FALSE )
IS
   objects_ ObjectArray;
   
   tab_   VARCHAR2(ORA_MAX_NAME_LEN) := UPPER(table_name_);
   trg_   VARCHAR2(ORA_MAX_NAME_LEN) := UPPER(trigger_name_);
   stmnt_ VARCHAR2(400);
   
   CURSOR get_triggers IS
      SELECT trigger_name
      FROM  user_triggers
      WHERE trigger_name LIKE trg_
      AND   table_name = tab_;

BEGIN
   OPEN  get_triggers;
   FETCH get_triggers BULK COLLECT INTO objects_;
   CLOSE get_triggers;
   FOR i IN Nvl(objects_.FIRST,0)..Nvl(objects_.LAST,-1) LOOP
      stmnt_ := 'DROP TRIGGER ' || objects_(i).object_name;
      Run_Ddl_Command___(stmnt_, procedure_name_, show_info_);
      IF show_info_ THEN
         Show_Message___(procedure_name_ || ': Trigger ' || objects_(i).object_name || ' dropped.');
      END IF;
   END LOOP;
END Remove_Triggers___;


PROCEDURE Run_Ddl_Command___ (
   stmt_      IN VARCHAR2,
   procedure_ IN VARCHAR2,
   show_info_ IN BOOLEAN DEFAULT FALSE,
   raise_     IN BOOLEAN DEFAULT TRUE,
   debug_     IN BOOLEAN DEFAULT FALSE )
IS
   security_error EXCEPTION;
BEGIN
--   IF user != Sys_Context('USERENV', 'CURRENT_SCHEMA') THEN 
--      RAISE security_error;
--   END IF;
   IF debug_ THEN
      dbms_output.put_line(stmt_);
   END IF;
   -- Safe due to not exposed in Package specification
   --@ApproveDynamicStatement(2006-06-01,haarse)
   EXECUTE IMMEDIATE stmt_;
EXCEPTION
   WHEN security_error THEN 
         Raise_Application_Error(-20106, 'Installation_SYS: You are not allowed to use this method.');
   WHEN OTHERS THEN
      Show_Message___ (procedure_ || ' generates error when executing: ');
      Show_Message___ (stmt_);
      IF raise_ THEN
         RAISE;
      END IF;
END Run_Ddl_Command___;

PROCEDURE Show_Message___ (
   message_ IN VARCHAR2 )
IS
   temp_msg_         VARCHAR2(32000);
   space_position_   NUMBER;
BEGIN
   temp_msg_ := message_;
   WHILE (LENGTH(temp_msg_) > 255) LOOP
      space_position_ := INSTR(SUBSTR(temp_msg_,1,255), ' ', -1);
      IF space_position_ < 240 THEN
         space_position_ := 240;
      END IF;
      Dbms_Output.Put_Line(SUBSTR(temp_msg_,1,space_position_));
      temp_msg_ := SUBSTR(temp_msg_, space_position_+1); 
   END LOOP;
   IF temp_msg_ IS NOT NULL THEN
      Dbms_Output.Put_Line(temp_msg_);
   END IF;
END Show_Message___;


FUNCTION Is_Column_Modified___(table_name_ VARCHAR2,
                               column_rec_ IN OUT NOCOPY ColRec) RETURN BOOLEAN 
IS

   CURSOR get_column_info IS
      SELECT data_type, char_length, nullable, data_default, data_precision,data_scale,default_on_null
      FROM   user_tab_columns
      WHERE  table_name = UPPER(table_name_)
      AND    column_name = UPPER(column_rec_.column_name);
   old_column_        get_column_info%ROWTYPE;
   column_datatype_   VARCHAR2(100);
   is_modified_       BOOLEAN := TRUE;
   is_dt_modified_    BOOLEAN := TRUE;
BEGIN
   OPEN get_column_info;
   FETCH get_column_info INTO old_column_;
   CLOSE get_column_info;

   IF (column_rec_.nullable IS NOT NULL) THEN
      IF (old_column_.nullable != column_rec_.nullable) THEN
         RETURN(TRUE);
      END IF;
   END IF;
   IF (column_rec_.default_value IS NOT NULL) THEN
      IF (Rtrim(Ltrim(Nvl(old_column_.data_default, 'NULL'))) != Rtrim(Ltrim(Nvl(column_rec_.default_value, 'NULL')))) THEN
         RETURN(TRUE);
      END IF;
   END IF;
   IF old_column_.data_type = 'VARCHAR2' THEN
      column_datatype_ := 'VARCHAR2(' || old_column_.char_length || ')';
      IF NOT column_datatype_ = column_rec_.data_type THEN
         RETURN(TRUE);
      END IF;
   ELSIF old_column_.data_type = 'NUMBER' THEN
      column_datatype_ := 'NUMBER';
      IF old_column_.data_precision IS NULL THEN
         column_datatype_ := column_datatype_ ||'(*';
         IF old_column_.data_scale != 0 THEN
            column_datatype_ := column_datatype_ ||','||old_column_.data_scale;
         END IF;
         column_datatype_ := column_datatype_ ||')';
      ELSE
         column_datatype_ := column_datatype_ ||'('||old_column_.data_precision;
         IF old_column_.data_scale != 0 THEN
            column_datatype_ := column_datatype_ ||','||old_column_.data_scale;
         END IF;
         column_datatype_ := column_datatype_ ||')';
      END IF;
      IF NOT column_datatype_ = column_rec_.data_type THEN
         RETURN(TRUE);
      END IF;
   ELSIF old_column_.data_type = 'NVARCHAR2' THEN
      column_datatype_ := 'NVARCHAR2(' || old_column_.char_length || ')';
      IF NOT column_datatype_ = column_rec_.data_type THEN
         RETURN(TRUE);
      END IF; 
   ELSIF NOT old_column_.data_type = column_rec_.data_type THEN
      RETURN(TRUE);
   END IF;
   IF  old_column_.default_on_null = 'NO'
   AND column_rec_.default_value IS NOT NULL
   AND column_rec_.default_value != '$DEFAULT_NULL$' THEN
      RETURN(TRUE);
   END IF;   
   IF (is_dt_modified_) THEN
      column_rec_.data_type :=NULL;
   ELSE
      is_modified_ :=FALSE;  
   END IF;
   
   RETURN FALSE;
END Is_Column_Modified___;


PROCEDURE Create_Empty_View___ (
   view_name_    IN VARCHAR2,
   columns_      IN ColumnViewType,
   lu_           IN VARCHAR2 DEFAULT NULL,
   module_       IN VARCHAR2 DEFAULT NULL,
   server_only_  IN VARCHAR2 DEFAULT NULL,
   show_info_    IN BOOLEAN  DEFAULT FALSE )
IS
   stmnt_     VARCHAR2(32000);
BEGIN
   stmnt_ := 'CREATE OR REPLACE VIEW '||view_name_||' AS'||nl_||'SELECT ';
   FOR i IN Nvl(columns_.first, 0)..Nvl(columns_.last, 0) LOOP
      stmnt_ := stmnt_ || columns_(i).column_source||' '||columns_(i).column_name;
      IF i < columns_.last THEN
         stmnt_ := stmnt_ ||','||nl_;
      ELSE
         stmnt_ := stmnt_ ||nl_;
      END IF;
   END LOOP;
   stmnt_ := stmnt_ ||'FROM dual'||nl_||'WHERE 1 = 2'||nl_||'WITH READ ONLY';
   Run_Ddl_Command___ (stmnt_, 'Create_View', show_info_);
   IF lu_ IS NULL
   OR module_ IS NULL THEN
      stmnt_ := 'COMMENT ON TABLE '||view_name_||' IS ''MODULE=IGNORE^''';
   ELSE
      stmnt_ := 'COMMENT ON TABLE '||view_name_||' IS ''MODULE='||module_||'^LU='||lu_||'^';
      IF server_only_ IS NOT NULL THEN
         stmnt_ := stmnt_||'SERVER_ONLY='||server_only_||'^';
      END IF;
      stmnt_ := stmnt_||'''';
   END IF;
   Run_Ddl_Command___ (stmnt_, 'Create_View', show_info_);
   FOR i IN Nvl(columns_.first, 0)..Nvl(columns_.last, 0) LOOP
      IF columns_(i).column_comment IS NOT NULL THEN
         stmnt_ := 'COMMENT ON COLUMN '||view_name_||'.'||columns_(i).column_name||' IS '''||REPLACE(columns_(i).column_comment,'$TO_NULL$',NULL)||'''';
         Run_Ddl_Command___ (stmnt_, 'Create_View', show_info_);
      END IF;
   END LOOP;
END Create_Empty_View___;


PROCEDURE Alter_View___ (
   view_name_    IN VARCHAR2,
   columns_      IN ColumnViewType,
   show_info_    IN BOOLEAN  DEFAULT FALSE )
IS
   i_                  NUMBER;
   changed_            BOOLEAN := FALSE;
   view_stmt_          LONG;
   org_stmt_           LONG;
   org_comment_        user_tab_comments.comments%TYPE;
   org_comments_       ColumnViewType;
   stmnt_              VARCHAR2(32000);
   CURSOR get_view IS
      SELECT text
      FROM user_views
      WHERE view_name = UPPER(view_name_);
   CURSOR get_view_comment IS
      SELECT comments
      FROM user_tab_comments
      WHERE table_name = UPPER(view_name_);
   CURSOR get_view_col_comments IS
      SELECT column_name, comments
      FROM user_col_comments
      WHERE table_name = UPPER(view_name_);
   FUNCTION View_Column_Exist (
      view_name_ IN VARCHAR2,
      col_name_  IN VARCHAR2 ) RETURN BOOLEAN
   IS
      exist_ NUMBER;
      CURSOR check_exist IS
         SELECT 1
         FROM user_tab_columns
         WHERE table_name = UPPER(view_name_)
         AND column_name = UPPER(col_name_);
   BEGIN
      OPEN check_exist;
      FETCH check_exist INTO exist_;
      IF check_exist%FOUND THEN
         CLOSE check_exist;
         RETURN TRUE;
      ELSE
         CLOSE check_exist;
         RETURN FALSE;
      END IF;
   END View_Column_Exist;
BEGIN
   OPEN get_view;
   FETCH get_view INTO view_stmt_;
   CLOSE get_view;
   org_stmt_ := view_stmt_;
   OPEN get_view_comment;
   FETCH get_view_comment INTO org_comment_;
   CLOSE get_view_comment;
   i_ := 1;
   FOR comm_rec IN get_view_col_comments LOOP
      org_comments_(i_).column_name := comm_rec.column_name;
      org_comments_(i_).column_comment := comm_rec.comments;
      i_ := i_ + 1;
   END LOOP;
   FOR i IN Nvl(columns_.first, 0)..Nvl(columns_.last, 0) LOOP
      IF NOT View_Column_Exist(view_name_, columns_(i).column_name) THEN
         changed_ := TRUE;
         view_stmt_ := SUBSTR(view_stmt_, 1, INSTR(view_stmt_, 'SELECT')+6)||columns_(i).column_source||' '||columns_(i).column_name||','||nl_||SUBSTR(view_stmt_, INSTR(view_stmt_, 'SELECT')+7, LENGTH(view_stmt_));
      END IF;
   END LOOP;
   IF changed_ THEN
      BEGIN
         view_stmt_ := 'CREATE OR REPLACE VIEW '||view_name_||' AS'||nl_||view_stmt_;
         Run_Ddl_Command___ (view_stmt_, 'Create_View', show_info_);
         stmnt_ := 'COMMENT ON TABLE '||view_name_||' IS '''||org_comment_||'''';
         Run_Ddl_Command___ (stmnt_, 'Create_View', show_info_);
         FOR i IN Nvl(org_comments_.first, 0)..Nvl(org_comments_.last, 0) LOOP
            IF org_comments_(i).column_comment IS NOT NULL THEN
               stmnt_ := 'COMMENT ON COLUMN '||view_name_||'.'||org_comments_(i).column_name||' IS '''||org_comments_(i).column_comment||'''';
               BEGIN
                   Run_Ddl_Command___ (stmnt_, 'Create_View', show_info_);
               EXCEPTION
                   WHEN OTHERS THEN
                     NULL;
               END;
            END IF;
         END LOOP;
         FOR i IN Nvl(columns_.first, 0)..Nvl(columns_.last, 0) LOOP
            IF columns_(i).column_comment IS NOT NULL THEN
               stmnt_ := 'COMMENT ON COLUMN '||view_name_||'.'||columns_(i).column_name||' IS '''||REPLACE(columns_(i).column_comment,'$TO_NULL$',NULL)||'''';
               BEGIN
                  Run_Ddl_Command___ (stmnt_, 'Create_View', show_info_);
               EXCEPTION
                   WHEN OTHERS THEN
                     NULL;
               END;
            END IF;
         END LOOP;
      EXCEPTION
         WHEN OTHERS THEN
            Dbms_Output.Put_Line('');
            Dbms_Output.Put_Line('Error when recreating view '||view_name_||'. Reverting to original view');
            Dbms_Output.Put_Line('');
            BEGIN
               view_stmt_ := 'CREATE OR REPLACE VIEW '||view_name_||' AS'||nl_||org_stmt_;
               Run_Ddl_Command___ (view_stmt_, 'Create_View', show_info_);
               stmnt_ := 'COMMENT ON TABLE '||view_name_||' IS '''||org_comment_||'''';
               Run_Ddl_Command___ (stmnt_, 'Create_View', show_info_);
               FOR i IN Nvl(org_comments_.first, 0)..Nvl(org_comments_.last, 0) LOOP
                  IF org_comments_(i).column_comment IS NOT NULL THEN
                     stmnt_ := 'COMMENT ON COLUMN '||view_name_||'.'||org_comments_(i).column_name||' IS '''||org_comments_(i).column_comment||'''';
                     BEGIN
                        Run_Ddl_Command___ (stmnt_, 'Create_View', show_info_);
                     EXCEPTION
                        WHEN OTHERS THEN
                           NULL;
                     END;
                  END IF;
               END LOOP;
            EXCEPTION
               WHEN OTHERS THEN
                  NULL;
            END;
      END;
   END IF;
END Alter_View___;


PROCEDURE Remove_Context___ (
   procedure_name_  IN VARCHAR2,
   context_name_    IN VARCHAR2,
   show_info_       IN BOOLEAN  DEFAULT FALSE )
IS
   stmnt_ VARCHAR2(2000);
BEGIN
   stmnt_ := 'DROP CONTEXT ' || context_name_;
   Run_Ddl_Command___(stmnt_, procedure_name_, show_info_, FALSE);
   IF show_info_ THEN
      Show_Message___(procedure_name_ || ': Context ' || context_name_ || ' dropped.');
   END IF;
END Remove_Context___;
-----------------------------------------------------------------------------
-------------------- FOUNDATION1 METHODS ------------------------------------
-----------------------------------------------------------------------------


--@IgnoreMissingSysinit
PROCEDURE Init
IS
   
   PROCEDURE Base
   IS
   BEGIN
      verbose_ := FALSE;
   END Base;

BEGIN
   Base;
END Init;

-----------------------------------------------------------------------------

END CAMUNDA_INSTALL_SYS;
-- [END IFS COMPLETE BLOCK]
/
SHOW ERROR
