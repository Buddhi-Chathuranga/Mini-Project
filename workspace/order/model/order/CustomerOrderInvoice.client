-----------------------------------------------------------------------------------------------------
-- Date        Sign     History
-- ----------  ------   -----------------------------------------------------------------------------
-- 2022-02-01  PumJlk   SCZ-17478, Added 'Details' command in YourReferenceRef lov in InvoiceGeneralGroup.
-- 2022-01-26  kusplk   FI21R2-8710, Enabled CancelInvoiceCommand and CreateCreditInvoiceCommand to prepayment tax documents.
-- 2022-01-20  KiSalk   Bug 161969(SC21R2-7035), Added service item chek to commands CreateCreditInvoiceCommand and CreateCorrectionInvoiceCommand.
-- 2022-01-18  PraWlk   FI21R2-8578, Modified CancelInvoiceCommand to check Sefaz Status Code as well when using cancel_postedauth_customer_inv functionality.
-- 2022-01-14  PraWlk   FI21R2-8033, Modified CancelInvoiceCommand to check only PostedAuth state for cancel_postedauth_customer_inv funationality.
-- 2022-01-10  Hiralk   FI21R2-6563, Added advance invoices for prepayment_tax_document functionality.
-- 2022-01-04  Kgamlk   FI21R2-7201, Added tax_category1 and tax_category2 to invoice line level.
-- 2021-12-15  Jratlk   FI21R2-7243, Adding above_tax_control_limit to InvoiceIndicatorsGroup.
-- 2021-12-10  Ckumlk   FI21R2-8021, Added DocumentTypeCode for it_xml_invoice functionality.
-- 2021-12-08  Utbalk   FI21R2-8032, Renamed command CancelPrelimInvCommand to CancelInvoiceCommand, group PrelCustInvoiceCancelationGroup to CustInvoiceCancelationGroup
--                      dialog PrelCustInvoiceCancelationDialog to CustInvoiceCancelationDialog
-- 2021-10-14  Utbalk   FI21R2-4832, Added ElectronicFiscalNoteCmdGroup and VoidFiscalNoteCommand.
-- 2021-09-28  NiDalk   SC21R2-2983, Removed AdvOrPrepayBasedInv as it is same as AdvancePrepayInvoice.
-- 2021-08-13  ThKrlk   Bug 160454(SCZ-15912), Modified Description field to enable adding multiple lines of text in CustomerInvoiceItemList
-- 2021-08-10  MaEelk   SC21R2-2244, Called the condition parent.DiscPriceRound instead of DiscPriceRound in AmountsValidationCommand
-- 2021-08-06  Chgulk   FI21R2-3530, Allowed to Modify the Domestic tax amount in invoice line section only for self-billing invoices.
-- 2021-07-07  Skanlk   Bug 158318(SCZ-15449), Added the field Objstate to the InvoiceGeneralGroup group in order to show the status in the subscription dialog.
-- 2021-06-30  Sacnlk   FI21R2-2137, Added Posting Prepayments Based on Prepayment Type functionality.
-- 2021-06-30  NiDalk   SC21R2-1661, Modified attribute name DeliveryDate to LatestDeliveryDate in CustomerOrderInvHead.
-- 2021-06-14  Shdilk   FI21R2-1647, Added new group CurrRateAndVoucherBaseDateGroup for OUT_INV_CURR_RATE_VOUCHER_DATE Polish functionalty.
-- 2021-03-05  ErFelk   Bug 156198(SCZ-12927), Modified CustomerInvoiceItemList by making InvoicedQty editable even when ChargePercent is null.
-- 2021-03-04  WaSalk   SC2020R1-12578, Removed fragment LocalizationControlCenterHandler and modified gelr functionality applied conditions
-- 2021-03-04           fields and columns using EnabledLccParams.
-- 2021-03-03  MalPlk   SC2020R1-12695, Changed Label Send as Send Invoice in command SendInvoiceCommand
-- 2021-02-24  PamPlk   Bug 158096(SCZ-13812), Modified CustomerInvoiceItemList to allow changing the additional discount for any kind of sales part.
-- 2020-10-23  PraWlk   GEFALL20-3253, Disabled PrintBoletoCommand if the Boleto is already printed.
-- 2020-09-16  MaEelk   GESPRING20-5400, Added OriginalDiscount, OriginalOrderDiscount and OriginalAddDiscount to CustomerInvoiceItemList.
-- 2020-07-15  PraWlk   GEFALL20-2778, Added boleto functionality.
-- 2020-06-16  Kagalk   GESPRING20-4693, Added it_xml_invoice functionality.
-- 2020-06-09  NWeelk   GESPRING20-4706, Added ValidateSendInvoice for mx_xml_doc_reporting functionality.
-- 2020-04-17  Dihelk   gelr:fr_service_code , GESPRING20-4018, Adding service_code.
-- 2020-04-15  Utbalk   GEFALL20-2448, Moved Fiscal Note Response related snippets to FiscalNoteResponseTab.fragment
-- 2020-02-27  Utbalk   GEFALL20-123, Altered enabling condition for PrintInvoiceCommand and PrintWorkCopyCommand commands.
-- 2020-02-17  BudKlk   FIXTEND-1060, Added a field DeliveryCountry to the list CustomerInvoiceItemList.
-- 2020-02-12  Utbalk   GEFALL20-734, Added Fiscal Note Response Tab.
-- 2020-02-11  HAHALK   SCXTEND-2182, Changed the Invoice Line Discount dialog from full page to modal assistant to improve the usability.
-- 2020-01-14  ThKrLk   Bug 151775(SCZ-8439), Enabled 'Delete' crud action in CustomerInvoiceItemList.
-- 2020-01-09  Hiralk   GESPRING20-1895, Added invoice_reason functionality.
-- 2019-10-16  Hairlk   SCXTEND-896, Avalara integration, Added lov CustomerTaxUsageTypeRef to CustomerInvoiceItemList.
-- 2019-08-19  KHVESE   SCUXXW4-23534, Added extra validation in BeforeModifySaveCommand for field InvoiceDate when invoice is Currency Rate Correction Invoice(CORRECTION_INV).
-- 2019-06-02  KhVese   SCUXXW4-22764, Added preserveprecision to fields SaleUnitPrice, UnitPriceInclTax and ChargePercent.
-- 2019-06-26  KHVESE   SCUXXW4-16318, Modified enabled conditions in ReprintModifiedCommand
-- 2018-06-01  KHVESE   SCUXXW4-821, Converted from tbwCustOrderInvoicHistory using MTG Version: 1.19
-- 2018-06-01  KHVESE   SCUXXW4-764, Converted from tbwCustomerInvoiceItem using MTG Version: 1.19
-- 2018-06-01  KHVESE   SCUXXW4-8975, Converted from frmChangeCustomerInvoice using MTG Version: 1.19
-- 2020-10-15  Shdilk   FISPRING20-7834, Modified validation of correction reason.
-- 2021-11-22  sacnlk   FI21R2-6433, Add Prepayment Tax related fields to prepayment_tax_document functionality.
-----------------------------------------------------------------------------------------------------

client           CustomerOrderInvoice;
component        ORDER;
layer            Core;
projection       CustomerOrderInvoiceHandling;
include fragment CustomerOrderInvoiceStateIndicator;
include fragment UserAllowedSiteLovSelector;
include fragment CustAddressShipLovSelector;
include fragment CustBillAddressLovSelector;
include fragment OrdInvoiceTypeLovSelector;
include fragment OrdInvoiceSeriesLovSelector;
include fragment CustOrdCust1Selector;
include fragment TaxCodeRestrictedSelector;
include fragment CustInfoContactLovPubSelector;
include fragment IncomeTypePerCustomerLovSelector;
include fragment TaxCalcStructureActiveSelector;
include fragment ReprintModifiedCustomerInvoiceDialog;
include fragment SendInvoiceAssistant;
include fragment FinNotesDialog;
include fragment RateCorrectionInvoiceDialog;
include fragment TaxLinesCommonAssistant;
include fragment TaxLinesWithholdingInvoicAssistant;
-- gelr: acquisition_origin, begin
include fragment AcquisitionOriginSelector;
-- gelr: acquisition_origin, end
-- gelr:outgoing_fiscal_note, begin
include fragment FiscalNoteResponseTab;
-- gelr:outgoing_fiscal_note, end
-- gelr: acquisition_origin, begin
include fragment StatisticalCodeSelector;
-- gelr: acquisition_origin, end
-- gelr:prepayment_tax_document, begin
include fragment AdvanceInvoiceReferenceDialog;
@DynamicComponentDependency PAYLED
include fragment AdvancePaymentOpenLovSelector;
include fragment AdvSeriesSelector;
-- gelr:prepayment_tax_document, end
----------------------------- NAVIGATOR ENTRIES -----------------------------

navigator {
   entry ChangeCustomerInvoiceNavEntry parent OrderNavigator.SalesInvoicing at index 100 {
      label = "Customer Invoice";
      page Form home CustomerOrderInvHead;
   }
}

-------------------------------- MAIN PAGES ---------------------------------

page Form using CustomerOrderInvHeadSet {
   label = "Customer Invoice";
   startupmode = search;
   stateindicator CustomerOrderInvHeadStateIndicator;
   crudactions {
      before command BeforeModifySaveCommand;
   }
   selector CustomerOrderInvHeadSelector;
   -- gelr:outgoing_fiscal_note, begin
   singleton FiscalNoteResponseSingleton(FiscalNoteResponseArray) bind CustomerOrderInvHeadSelector;
   -- gelr:outgoing_fiscal_note, end
   group InvoiceHeaderGroup;
   group InvoiceAmountsGroup;
   tabs {
      tab {
         label = "Lines";
         visible = [Identity != null];
         list CustomerInvoiceItemList(CustomerOrderInvItems);
      }
      tab {
         label = "General";
         arrange {
            group InvoiceGeneralGroup;
            group InvoiceIndicatorsGroup;
         }
         arrange {
            group PaymentGroup {
               collapsed = [true];
            }
            group DeliveryGroup {
               collapsed = [true];
            }
         }
         arrange {
            group ReferenceGroup {
               collapsed = [true];
            }
            arrange {
               group InvoiceTextGroup {
                  collapsed = [true];
               }
               -- gelr:it_xml_invoice, begin
               group ItEinvoiceDataGroup {
                  collapsed = [true];
               }
               -- gelr:it_xml_invoice, end
            }
         }
         -- gelr:alt_invoice_no_per_branch, begin
         @DynamicComponentDependency INVOIC
         group OfficialInvoiceNoGroup {
            visible = ["ALT_INVOICE_NO_PER_BRANCH" in EnabledLccParams];
         }
         -- gelr:alt_invoice_no_per_branch, end
         -- gelr:out_inv_curr_rate_voucher_date, begin
         @DynamicComponentDependency INVOIC
         group CurrRateAndVoucherBaseDateGroup {
            visible = [("OUT_INV_CURR_RATE_VOUCHER_DATE" in EnabledLccParams) and(InvoiceType in("CUSTORDDEB", "CUSTCOLDEB") or InvoiceType = CompanyDefInvoiceTypeRef.DefCoPrepayDebInvType)];
         }
         -- gelr:out_inv_curr_rate_voucher_date, end
      }
      -- gelr:outgoing_fiscal_note, begin
      tab {
         label = "NF-e Information";
         visible = ["OUTGOING_FISCAL_NOTE" in EnabledLccParams];
         group FiscalNoteResponseGroup bind FiscalNoteResponseSingleton;
      }
      -- gelr:outgoing_fiscal_note, end
      tab {
         label = "History";
         visible = [Identity != null];
         list CustOrderInvoicHistoryList(CustomerOrderInvoiceHistories);
      }
   }
   commandgroup ShareCmdGroup {
      commandgroup ShareCmdSubGroup {
         label = "Share";
         command PrintInvoiceCommand;
         command PrintWorkCopyCommand;
         command ReprintOriginalfromArchiveCommand {
            enablefunction CheckOrgReportExist(Company, InvoiceId);
         }
         command ReprintOriginalDuplicateCommand {
            enablefunction CheckOrgReportExist(Company, InvoiceId);
         }
         command ReprintModifiedCommand {
            enablefunction CheckConnectedCoExist(Company, InvoiceId, CreatorsReference, InvoiceType);
         }
         command EmailInvoiceCommand;
         command SendInvoiceCommand;
         command ResendInvoiceCommand;
         --gelr: boleto, begin
         @DynamicComponentDependency PAYLED
         command PrintBoletoCommand;
         --gelr: boleto, end
      }
   }
   commandgroup CreditCorrectionInvoiceCmdGroup {
      commandgroup CreditCorrectionInvoiceCmdSubGroup {
         label = "Credit/Correction Invoice";
         command CreateCreditInvoiceCommand;
         command CreateCorrectionInvoiceCommand;
         command CreateRateCorrectionCommand;
         command RemoveCreditCorrInvoiceCommand;
      }
   }
   commandgroup RemoveCancelCmdGroup {
      command RemovePrepaymentBasedInvoiceCommand;
      command CancelInvoiceCommand;
   }
   commandgroup ViewInvoicesCmdGroup {
      commandgroup ViewInvoicesCmdSubGroup {
         label = "View";
         command ViewDebitInvoicesCommand;
         command ViewCreditInvoicesCommand;
         command ViewCorrectionInvoiceCommand;
         command ViewPreviousReferenceInvoiceCommand;
      }
   }
   commandgroup PostingCmdGroup {
      commandgroup PostingCmdSubGroup {
         label = "Posting";
         command PrePostingCommand;
         command CustomerInvoicePostingsAnalyCommand;
      }
      command InstallmentPlanandDiscountsCommand;
   }
   command NotesCommand;
   -- gelr:outgoing_fiscal_note, begin
   commandgroup ElectronicFiscalNoteCmdGroup {
      commandgroup ElectronicFiscalNoteCmdSubGroup {
         label = "Electronic Fiscal Note";
         command SendFiscalNoteCommand;
         command VoidFiscalNoteCommand {
            enablefunction IsValidToVoid(FiscalNoteResponseValue);
         }
         command CancelFiscalNoteCommand;
      }
   }
   -- gelr:outgoing_fiscal_note, end
   -- gelr:it_xml_invoice, begin
   command AddRemoveInvFeeCommand;
   -- gelr:it_xml_invoice, end
   -- gelr:prepayment_tax_document, begin
   command AdvanceInvoicesCommand;
   -- gelr:prepayment_tax_document, end
}

---------------------------------- GROUPS -----------------------------------

group InvoiceHeaderGroup for CustomerOrderInvHead {
   label = "";
   lov IdentityRef with ReferenceCustOrdCust1Selector {
      editable = [false];
      size = Small;
      contactwidget {
         enabled = [true];
         source = Customer;
      }
   }
   field CustomerAddressName {
      size = Small;
   }
   lov SeriesIdRef with ReferenceOrdInvoiceSeriesLovSelector {
      editable = [false];
      size = Small;
   }
   field InvoiceNo {
      editable = [false];
      size = Small;
   }
   field CompanyRef {
      editable = [false];
      size = Small;
   }
   lov ContractRef with UserAllowedSiteLovSelector {
      editable = [false];
      size = Small;
   }
   field CreationDate {
      size = Small;
      editable = [false];
   }
   field OrderDate {
      size = Small;
      editable = [false];
   }
}

group InvoiceAmountsGroup for CustomerOrderInvHead {
   label = "Amounts";
   field Currency {
      editable = [false];
      size = Small;
   }
   field GrossAmount {
      size = Small;
   }
   field NetAmount {
      size = Small;
   }
   field VatAmount {
      size = Small;
   }
   field FinCurrRate {
      size = Small;
   }
   field TaxCurrRate {
      label = "Tax Currency Rate";
      editable = [false];
      size = Small;
   }
}

group InvoiceGeneralGroup for CustomerOrderInvHead {
   label = "";
   lov InvoiceTypeRef with ReferenceOrdInvoiceTypeLovSelector {
      editable = [false];
      size = Large;
      description = InvoiceTypeRef.Description;
   }
   lov InvoiceAddressIdRef with ReferenceCustBillAddressLovSelector {
      editable = [Objstate = "Preliminary"];
      preview = CustBillAddressLovCard;
      validate command {
         execute {
            call ValidateInvoiceAddressId(Identity, InvoiceAddressId) into ValidateEditStrucVar;
            set YourReference = ValidateEditStrucVar.YourReference;
            set CustomerRefName = ValidateEditStrucVar.CustomerRefName;
         }
      }
   }
   field InvoiceDate {
      editable = [Objstate = "Preliminary"];
      validate command {
         execute {
            if [original.InvoiceDate = PayTermBaseDate] {
               set PayTermBaseDate = InvoiceDate;
               call GetUnblockedDueDate(Company, Identity, PartyType, PayTermId, PayTermBaseDate) into DueDate;
            }
         }
      }
   }
   field PrintDate {
      label = "Printed Date";
      editable = [false];
   }
   field InvoiceId {
      label = "Preliminary Invoice No";
      editable = [false];
   }
   field OurReference {
      editable = [Objstate = "Preliminary"];
      contactwidget {
         enabled = [OurReference != null];
         source = Person;
         key = CreatorsReferenceRef.AuthorizeCode;
      }
   }
   lov YourReferenceRef with ReferenceCustInfoContactLovPubSelector {
      editable = [Objstate != "Cancelled"];
      freeinput = [true];
      validate command {
         execute {
            call GetCustContactName(Identity, InvoiceAddressId, YourReference) into CustomerRefName;
         }
      }
      contactwidget {
         enabled = [YourReference != null];
         source = Customer;
      }
      details = "page/Customer/AddressInfo?$filter=CustomerId eq $[Identity]";
   }
   field CustomerRefName;
   field BranchRef {
      editable = [Objstate = "Preliminary"];
   }
   field CustomerInfoAddressRef.CustomerBranch {
      label = "Customer Branch";
   }
   field JsInvoiceState {
      label = "Jinsui Status";
      editable = [false];
   }
   field Objstate {
      visible = [false];
   }
   -- gelr:fr_service_code, begin
   lov ServiceCodeRef with ReferenceCustomerServiceCodeSelector {
      description = ServiceCodeRef.Description;
      visible = ["FR_SERVICE_CODE" in EnabledLccParams];
   }
   -- gelr:fr_service_code, end
}

group InvoiceIndicatorsGroup for CustomerOrderInvHead {
   label = "Indicators";
   field PriceAdjustment {
      editable = [Objstate = "Preliminary" and RmaNo = null and InvoiceTypeRate != "CORRECTION_INV" and
      (InvoiceType in("CUSTORDCRE", "CUSTCOLCRE", "SELFBILLCRE") or InvoiceType = CompanyDefInvoiceTypeRef.DefCoCorInvType or InvoiceType = CompanyDefInvoiceTypeRef.DefColCorInvType)];
   }
   field AdvancePrepayInvoice {
      editable = [false];
   }
   field UsePriceInclTaxDb {
      editable = [false];
   }
   field Notes {
      editable = [false];
   }
   field CorrectionExists {
      editable = [false];
   }
   field CorrectionInvoice {
      editable = [false];
   }
   field CorrectionReasonIdRef {
      editable = [Objstate = "Preliminary" and InvoiceId != null];
      validate command {
         execute {
            call ValidateCorrectionReasonId(Company, CorrectionReasonId) into CorrectionReason;
         }
      }
   }
   field CorrectionReason {
      editable = [Objstate = "Preliminary" and InvoiceId != null];
      validate command {
         execute {
            set CorrectionReasonId = null;
         }
      }
   }
   field CancelReason {
      visible = [Objstate = "Cancelled"];
      editable = [false];
      size = Large;
   }
   -- gelr: invoice_reason, begin
   lov InvoiceReasonIdRef with ReferenceInvoiceReasonSelector {
      description = InvoiceReasonIdRef.InvoiceReason;
      visible = ["INVOICE_REASON" in EnabledLccParams];
      editable = [Objstate = "Preliminary" and InvoiceId != null];
   }
   -- gelr: invoice_reason, end
   -- gelr:cz_tax_reporting, begin
   field AboveTaxControlLimit {
      visible = ["CZ_TAX_REPORTING" in EnabledLccParams];
      editable = [Objstate = "Preliminary"];
   }
   -- gelr:cz_tax_reporting, end
}

group PaymentGroup for CustomerOrderInvHead {
   label = "Payment";
   field PayTermBaseDate {
      editable = [Objstate = "Preliminary"];
      validate command {
         execute {
            call GetUnblockedDueDate(Company, Identity, PartyType, PayTermId, PayTermBaseDate) into DueDate;
         }
      }
   }
   field DueDate {
      editable = [Objstate = "Preliminary" and InstallmentCount <= 1];
      validate command {
         execute {
            call ValidateDueDate(Company, Identity, PartyType, PayTermId, DueDate) into ValidateEditStrucVar;
            if [ValidateEditStrucVar.DueDate != null and DueDate != ValidateEditStrucVar.DueDate] {
               alert("Due Date is in a Vacation Period.");
            }
         }
      }
   }
   lov PayTermIdRef with ReferencePaymentTermSelector {
      label = "Payment Terms";
      editable = [Objstate = "Preliminary"];
      description = PayTermIdRef.Description;
      validate command {
         execute {
            call ValidatePayTermId(Company, Identity, PartyType, PayTermId, PayTermBaseDate) into ValidateEditStrucVar;
            set DueDate = ValidateEditStrucVar.DueDate;
            set InstallmentCount = ValidateEditStrucVar.InstallmentCount;
         }
      }
   }
   field NcfReference {
      editable = [(Objstate = "Preliminary" and RefMethod = "CJIN" and(JsInvoiceState = "NonJinsui" or(IsJinsuiOrder = "TRUE" and(JsInvoiceState = "JinsuiOpen" or(JsInvoiceState = "Transferred" and IsAllowedToModify = "TRUE"))))) or
      (RefMethod = "NONE" and(Objstate = "Preliminary" or Objstate = null))];
   }
   @DynamicComponentDependency PAYLED
   lov PrepaymentTypeCodeRef with ReferencePrepaymentTypeSelector {
      search = PrepaymentTypeCode, Description;
      description = PrepaymentTypeCodeRef.Description;
      editable = [Objstate = "Preliminary" and InvoiceType != CompanyDefInvoiceTypeRef.DefAdvCoCrInvType];
      visible = [PrepayBasedEnabled = "TRUE"];
   }
}

group DeliveryGroup for CustomerOrderInvHead {
   label = "Delivery";
   lov DeliveryAddressIdRef with ReferenceCustAddressShipLovSelector {
      preview = CustAddressShipLovCard;
      editable = [false];
   }
   field LatestDeliveryDate {
      editable = [Objstate = "Preliminary"];
   }
   field WantedDeliveryDate {
      editable = [false];
   }
   field ShipVia {
      editable = [Objstate = "Preliminary"];
   }
   field DeliveryTerms {
      label = "Delivery Terms Description";
      editable = [Objstate = "Preliminary"];
   }
   field DelTermsLocation {
      label = "Delivery Terms Location";
      editable = [Objstate = "Preliminary"];
   }
   field ForwardAgentIdRef {
      editable = [Objstate = "Preliminary"];
   }
   field LabelNote {
      editable = [Objstate = "Preliminary"];
   }
}

group ReferenceGroup for CustomerOrderInvHead {
   label = "References";
   field CreatorsReferenceRef {
      editable = [false];
   }
   field ShipmentId {
      editable = [false];
   }
   field RmaNo {
      editable = [false];
   }
   field SeriesReference {
      label = "Debit/Corr Invoice Series";
      editable = [false];
   }
   field NumberReference {
      label = "Debit/Corr Invoice No";
      editable = [false];
   }
   field ProjectId {
      editable = [false];
   }
   field SbReferenceNo {
      label = "SBI Ref No";
      editable = [false];
   }
   field AggregationNo {
      editable = [false];
   }
   field FinalSettlement {
      editable = [false];
   }
}

group InvoiceTextGroup for CustomerOrderInvHead {
   label = "Invoice Text";
   lov InvoiceTextIdRef with ReferenceInvoiceItemTextSelector {
      editable = [Objstate = "Preliminary" and InvoiceId != null];
      validate command {
         execute {
            call GetInvoiceText(Company, InvoiceTextId) into InvoiceText;
         }
      }
   }
   field InvoiceText {
      label = "Invoice Text";
      size = Large;
      multiline = true;
      editable = [Objstate = "Preliminary" and InvoiceId != null];
   }
}

-- gelr:alt_invoice_no_per_branch, begin
group OfficialInvoiceNoGroup for CustomerOrderInvHead {
   label = "Official Invoice Number";
   field ComponentA {
      label = "${ComponentAName}";
      filterlabel = "Component A";
      editable = [Objstate = "Preliminary" and SerialNumber = null];
   }
   field ComponentB {
      label = "${ComponentBName}";
      filterlabel = "Component B";
      editable = [false];
   }
   field ComponentC {
      label = "${ComponentCName}";
      filterlabel = "Component C";
      editable = [false];
   }
   field SerialNumber {
      label = "${SerialNumberName}";
      filterlabel = "Sequence Number";
      editable = [false];
   }
   field OfficialInvoiceNo {
      editable = [false];
   }
}
-- gelr:alt_invoice_no_per_branch, end
-- gelr:out_inv_curr_rate_voucher_date, begin
group CurrRateAndVoucherBaseDateGroup for CustomerOrderInvHead {
   label = "Currency Rate and Voucher Base Date";
   field OutInvVouDateBase {
      editable = [(Objstate = "Preliminary") and(NumberReference = null)];
   }
   field OutInvCurrRateBase {
      editable = [(Objstate = "Preliminary") and(NumberReference = null)];
   }
   field TaxSellCurrRateBase {
      editable = [(Objstate = "Preliminary") and(NumberReference = null) and(UseSpecificRates = "TRUE")];
   }
}
-- gelr:out_inv_curr_rate_voucher_date, end

-- gelr:it_xml_invoice, begin
group ItEinvoiceDataGroup for CustomerOrderInvHead {
   label = "Italian E-invoice";
   visible = ["IT_XML_INVOICE" in EnabledLccParams];
   lov DocumentTypeCodeRef with ReferenceDocumentTypeCodeSelector {
      search = DocumentTypeCode, Description;
      description = DocumentTypeCodeRef.Description;
      editable = [Objstate = "Preliminary"];
   }
}
-- gelr:it_xml_invoice, end

------------------------------ DIALOGS GROUPS -------------------------------

group CustInvoiceCancelationGroup for CustInvoiceCancelationStructure {
   label = "Cancel Customer Invoice";
   field CancelReason {
      multiline = true;
      size = Large;
   }
}

group EmailGroup for CustomerInvoiceEmailVirtual {
   label = "Email Customer Invoice";
   field InvoiceId {
      label = "Invoice No";
   }
   field YourReference;
   field Email {
      label = "E-mail";
   }
   field Contract {
      label = "Site";
      visible = [false];
   }
}

----------------------------------- LISTS -----------------------------------

list CustOrderInvoicHistoryList for CustOrderInvoiceHist {
   field DateEntered;
   field UserId {
      contactwidget {
         enabled = [true];
         source = Person;
      }
   }
   field MessageText;
}

list CustomerInvoiceItemList for CustomerOrderInvItem {
   orderby = Company, InvoiceId, ItemId;
   crudactions {
      edit {
         enabled = [parent.Objstate = "Preliminary"];
      }
      delete {
         enabled = [parent.Objstate = "Preliminary" and InvoiceType = "CUSTORDCRE"];
      }
   }
   field Pos {
      size = Small;
   }
   field CatalogNo;
   field Description {
      size = Large;
      editable = [condition.ListEditCondition and RentalTransactionId = null];
      multiline = true;
   }
   field InvoicedQty {
      editable = [condition.ListEditCondition and RentalTransactionId = null];
      validate command InvoicedQtyValidationCommand;
   }
   field SaleUm {
      size = Small;
   }
   field PriceQty {
      size = Small;
   }
   field PriceUm {
      size = Small;
   }
   field SaleUnitPrice {
      editable = [condition.ListEditCondition and RentalTransactionId = null and ChargePercent = null and not parent.UsePriceInclTaxDb];
      preserveprecision = [true];
      validate command SaleUnitPriceValidationCommand;
   }
   field UnitPriceInclTax {
      editable = [condition.ListEditCondition and RentalTransactionId = null and ChargePercent = null and parent.UsePriceInclTaxDb];
      preserveprecision = [true];
      validate command UnitPriceInclTaxValidationCommand;
   }
   field ChargePercent {
      editable = [condition.ListEditCondition and RentalTransactionId = null and SaleUnitPrice = null];
      preserveprecision = [true];
      validate command AmountsValidationCommand;
   }
   field ChargePercentBasis {
      preserveprecision = [true];
   }
   -- gelr:disc_price_rounded, added condition for columnexclude
   field Discount {
      columnexclude = [parent.DiscPriceRound];
   }
   -- gelr:disc_price_rounded, added condition for columnexclude
   field OrderDiscount {
      columnexclude = [parent.DiscPriceRound];
      editable = [condition.ListEditCondition and RentalTransactionId = null and not Charges];
      validate command AmountsValidationCommand;
   }
   -- gelr:disc_price_rounded, added condition for columnexclude
   field AdditionalDiscount {
      columnexclude = [parent.DiscPriceRound];
      editable = [condition.ListEditCondition and parent.SbReferenceNo = null and not Charges and not AdvancePrepayInvoice and
      (parent.InvoiceType in("CUSTORDDEB", "CUSTCOLDEB", "CUSTORDCRE", "CUSTCOLCRE") or(PrelUpdateAllowed and(parent.InvoiceType = parent.CompanyDefInvoiceTypeRef.DefCoCorInvType or parent.InvoiceType = parent.CompanyDefInvoiceTypeRef.DefColCorInvType)))];
      validate command AmountsValidationCommand;
   }
   -- gelr:disc_price_rounded, begin
   field OriginalDiscount {
      columnexclude = [not parent.DiscPriceRound];
   }
   field OriginalOrderDiscount {
      columnexclude = [not parent.DiscPriceRound];
      editable = [condition.ListEditCondition and RentalTransactionId = null and not Charges];
      validate command AmountsValidationCommand;
   }
   field OriginalAddDiscount {
      columnexclude = [not parent.DiscPriceRound];
      editable = [condition.ListEditCondition and SalesPartRef.PartNo != null and parent.SbReferenceNo = null and not Charges and not AdvancePrepayInvoice and
      (parent.InvoiceType in("CUSTORDDEB", "CUSTCOLDEB", "CUSTORDCRE", "CUSTCOLCRE") or(PrelUpdateAllowed and(parent.InvoiceType = parent.CompanyDefInvoiceTypeRef.DefCoCorInvType or parent.InvoiceType = parent.CompanyDefInvoiceTypeRef.DefColCorInvType)))];
      validate command AmountsValidationCommand;
   }
   -- gelr:disc_price_rounded, end
   field TotalOrderLineDiscount;
   field CustomerPoNo;
   field DelivTypeIdRef {
      editable = [condition.ListEditCondition and RentalTransactionId = null];
   }
   lov IncomeTypeIdRef with ReferenceIncomeTypePerCustomerLovSelector using  IncomeTypeLov(parent.Identity, ShipAddrNo) {
      editable = [parent.TaxWithholding = "TAXWITHHOLD"];
   }
   lov VatCodeRef with ReferenceTaxCodeRestrictedSelector using  TaxCodeLov(Company, parent.InvoiceDate) {
      size = Small;
      editable = [condition.ListEditCondition and parent.TaxCalcMethod = "NOT_USED"];
      validate command VatCodeValidationCommand;
   }
   lov TaxCalcStructureIdRef with ReferenceTaxCalcStructureActiveSelector {
      editable = [condition.ListEditCondition and parent.TaxCalcMethod = "NOT_USED"];
      validate command TaxCalcStructureIdValidationCommand;
   }
   -- gelr:br_business_operation, begin
   lov BusinessOperationRef with BusinessOperationSelector {
      size = Small;
      columnexclude = [not "BR_BUSINESS_OPERATION" in parent.EnabledLccParams];
   }
   -- gelr:br_business_operation, end
   -- gelr:acquisition_origin, begin
   lov AcquisitionOriginRef with ReferenceAcquisitionOriginSelector {
      columnexclude = [not "ACQUISITION_ORIGIN" in parent.EnabledLccParams];
      description = AcquisitionOriginRef.Description;
   }
   -- gelr:acquisition_origin, end
   -- gelr:good_service_statistical_code, begin
   lov StatisticalCodeRef with ReferenceStatisticalCodeSelector {
      columnexclude = [not "GOOD_SERVICE_STATISTICAL_CODE" in parent.EnabledLccParams];
      description = StatisticalCodeRef.Description;
   }
   -- gelr:good_service_statistical_code, end
   field TaxCodePercentage {
      size = Small;
   }
   field MultipleTaxLines {
      size = Small;
   }
   field NetCurrAmount;
   field VatCurrAmount;
   field VatDomAmount {
      editable = [parent.Currency != parent.BaseCurrencyCode and parent.InvoiceType = "SELFBILLDEB" and parent.Objstate = "Preliminary" and MultipleTaxLines = false and TaxCurrAmountEditable = "TRUE"];
   }
   field WithheldTaxCurrAmount {
      label = "Withheld Tax Amount/Curr";
      editable = [false];
   }
   field FreeOfCharge {
      size = Small;
   }
   field WithheldTaxDomAmount;
   -- gelr:prepayment_tax_document, begin
   field PrepayTaxCurrAmount {
      columnexclude = [not "PREPAYMENT_TAX_DOCUMENT" in parent.EnabledLccParams];
      editable = [false];
      preserveprecision = [true];
   }
   field PrepayTaxBaseCurrAmt {
      columnexclude = [not "PREPAYMENT_TAX_DOCUMENT" in parent.EnabledLccParams];
      editable = [false];
      preserveprecision = [true];
   }
   -- gelr:prepayment_tax_document, end
   field FreeOfChargeTaxBasis {
      editable = [FreeOfCharge];
   }
   field BaseCompBearingTaxAmt;
   field ManTaxLiabilityDate {
      editable = [RentalTransactionId = null and(condition.ListEditCondition or ManualLiabltyTaxcode = "TRUE")];
   }
   field GrossCurrAmount {
      editable = [parent.InvoiceType = parent.CompanyDefInvoiceTypeRef.DefCoPrepayCreInvType];
      validate command {
         execute {
            if [GrossCurrAmount != original.GrossCurrAmount] {
               set Reconsume = 1;
            }
         }
      }
   }
   field Charges {
      size = Small;
   }
   field OrderNoRef;
   field LineNo {
      size = Small;
   }
   field ReleaseNo {
      size = Small;
   }
   field ChargeSeqNo;
   field RmaNo;
   field RmaLineNo;
   field RmaChargeNo;
   field SeriesReference {
      size = Small;
   }
   field NumberReference;
   field Stage;
   field OrderLineStagedBillingRef.Description {
      size = Large;
      label = "Billing Stage Description";
   }
   field OrderLineStagedBillingRef.TotalPercentage {
      label = "% of Total";
   }
   field ConfigurationId;
   field ConditionCode {
      size = Small;
   }
   field ConditionCodeDescription {
      size = Large;
   }
   field SalesPartRebateGroup {
      size = Small;
      editable = [RentalTransactionId = null];
   }
   field AssortmentId {
      size = Small;
      editable = [RentalTransactionId = null];
   }
   field AssortmentNodeId {
      editable = [RentalTransactionId = null];
   }
   field PrelUpdateAllowed {
      size = Small;
   }
   @DynamicComponentDependency RENTAL
   field RentalTransactionRef.TransactionDate {
      label = "Transaction Start Date";
   }
   @DynamicComponentDependency RENTAL
   field RentalTransactionRef.TransactionEndDate {
      label = "Transaction End Date";
   }
   @DynamicComponentDependency RENTAL
   field InvoicedDurationDays;
   @DynamicComponentDependency RENTAL
   field RentalTransactionRef.OnRentalQty {
      label = "On Rental Qty";
   }
   @DynamicComponentDependency RENTAL
   field RentalTransactionRef.RentalModeId {
      size = Small;
      label = "Rental Mode ID";
   }
   @DynamicComponentDependency RENTAL
   field RentalModeDescription {
      size = Large;
   }
   lov InvoiceTextIdRef with ReferenceInvoiceItemTextSelector {
      editable = [InvoiceId != null];
      validate command {
         execute {
            call GetInvoiceText(Company, InvoiceTextId) into InvoiceText;
         }
      }
   }
   field InvoiceText {
      label = "Invoice Text";
      size = Large;
      multiline = true;
      editable = [InvoiceId != null];
   }
   field DeliveryCountry;
   field CorrectionReasonIdRef {
      columnvisible = [parent.CorrectionInvoice];
      editable = [PrelUpdateAllowed and InvoiceId != null];
      validate command {
         execute {
            call ValidateCorrectionReasonId(Company, CorrectionReasonId) into CorrectionReason;
         }
      }
   }
   field CorrectionReason {
      columnvisible = [parent.CorrectionInvoice];
      editable = [PrelUpdateAllowed and InvoiceId != null];
      size = Large;
      validate command {
         execute {
            set CorrectionReasonId = null;
         }
      }
   }
   field PriceConv {
      columnexclude = [true];
   }
   lov CustomerTaxUsageTypeRef with ReferenceCustomerTaxUsageTypeSelector {
      description = CustomerTaxUsageTypeRef.Description;
   }
   lov TaxCategory1Ref with ReferenceTaxCategory1Selector {
      search = TaxCategory1, Description;
      description = TaxCategory1Ref.Description;
   }
   lov TaxCategory2Ref with ReferenceTaxCategory2Selector {
      search = TaxCategory2, Description;
      description = TaxCategory2Ref.Description;
   }

   fieldranking Pos, CatalogNo, InvoicedQty, SaleUnitPrice, OrderNoRef;

   commandgroup CustomerInvItemTaxCmdGroup {
      command CustomerInvItemTaxLinesCommand;
      command CustomerInvItemWhtTaxLinesCommand;
   }
   command CustomerInvItemInvoiceLineDiscountCommand;
   command CustomerInvItemPrePostingCommand;
   @DynamicComponentDependency CFGCHR
   command CustomerInvItemViewConfigurationCommand;
}

--------------------------------- COMMANDS ----------------------------------

command BeforeModifySaveCommand for CustomerOrderInvHead {
   variable ValidateEditStrucVar Structure(ValidateInvoiceStruc);

   execute {
      if [JsInvoiceState != "NonJinsui" and JsInvoiceState != ""] {
         if [original.NcfReference != NcfReference] {
            messagebox("", warning, "It is not recommended to specify the Payment Reference for a Jinsui invoice manually. Do you want to continue?") {
               when "Yes" {
                  log("Continue with NcfReference change.");
               }
               when "No" {
                  bulkset NcfReference = original.NcfReference;
                  exit CANCEL;
               }
            }
         }
      }
      if [original.InvoiceDate != InvoiceDate and InvoiceTypeRate = "CORRECTION_INV"] {
         messagebox("", warning, "Changing the invoice date will cause a mismatch in dates against the first currency rate correction invoice. Do you still want to proceed?") {
            when "Yes" {
               log("Continue with InvoiceDate change.");
            }
            when "No" {
               exit CANCEL;
            }
         }
      }
      call CheckInvDatePeriodClose(Company, InvoiceId, InvoiceDate, Objstate) into ValidateEditStrucVar;
      if [ValidateEditStrucVar.IsPeriodClose] {
         messagebox("", warning, "The modified invoice date falls on a closed accounting period for the user group ${ValidateEditStrucVar.UserGroup}. Do you want to save the customer invoice?") {
            when "Yes" {
               log("Continue with period close.");
            }
            when "No" {
               exit CANCEL;
            }
         }
      }
   }
}

command EmailInvoiceCommand for CustomerOrderInvHead {
   label = "E-mail Invoice";
   enabled = [Objstate = "Preliminary" and CustomerEmail != null and(CreatorsReferenceRef = null or CreatorsReferenceRef.BlockedType != "ManualBlocked") and MediaCode = null];
   variable ValidatePrintStrucVar {
      type = Structure(ValidatePrintStruc);
   }
   execute {
      call ValidatePrintInvoice(Company, InvoiceId, Identity, SeriesId, InvoiceNo, InvoiceType) into ValidatePrintStrucVar;
      if [ValidatePrintStrucVar.CustomerInvPostConfirmMsg != null] {
         set ConfirmMessage = ValidatePrintStrucVar.CustomerInvPostConfirmMsg;
         // !TODO TEUXX-14211 CustomerInvPostConfirmMsg has break lines in the confirmation message and needs to be handled in client for line break
         messagebox("", question, "${ConfirmMessage}") {
            when "Yes" {
               log("Confirmed yes");
            }
            when "No" {
               exit;
            }
         }
      }
      if [ValidatePrintStrucVar.TaxCodeInfoMsg != null] {
         set InfoMessage = ValidatePrintStrucVar.TaxCodeInfoMsg;
         alert("${InfoMessage}");
      }
      if [ValidatePrintStrucVar.TaxCodeConfirmMsg != null] {
         set ConfirmMessage = ValidatePrintStrucVar.TaxCodeConfirmMsg;
         messagebox("", question, "${ConfirmMessage}") {
            when "Yes" {
               log("Confirmed yes");
            }
            when "No" {
               exit;
            }
         }
      }
      assistant CustomerInvoiceEmailAssistant(InvoiceId, YourReference, CustomerEmail, Contract) {
         when OK {
            exit OK;
         }
      }
   }
}

command CancelInvoiceCommand for CustomerOrderInvHead {
   label = "Cancel Invoice";
   enabled = [(Objstate = "Preliminary" and(InvoiceType = "CUSTORDDEB" or InvoiceType = "CUSTCOLDEB" or InvoiceType = "SELFBILLDEB" or InvoiceType = CompanyDefInvoiceTypeRef.DefAdvCoDrInvType or("PREPAYMENT_TAX_DOCUMENT" in EnabledLccParams and InvoiceType = CompanyDefInvoiceTypeRef.DefCoTaxDocType))) or(Objstate in("PostedAuth") and InvoiceType in("CUSTORDDEB", "CUSTCOLDEB") and "CANCEL_POSTEDAUTH_CUSTOMER_INV" in EnabledLccParams and FiscalNoteResponseValue = 155)];
   variable CancelReasonVar {
      type = Text;
   }
   execute {
      dialog CustInvoiceCancelationDialog into(CancelReasonVar) {
         when OK {
            call CancelDebitInvoice(Company, Identity, InvoiceId, CancelReasonVar);
         }
      }
   }
}

command SendInvoiceCommand for CustomerOrderInvHead {
   label = "Send Invoice";
   enabled = [Objstate = "Preliminary" and(MediaCode != null or("E-INVOICING_COMPLIANCE" in EnabledLccParams and ComplianceMediaCode != null))];
   mode = SingleRecord;
   execute {
      -- gelr:mx_xml_doc_reporting, begin
      call ValidateSendInvoice();
      -- gelr:mx_xml_doc_reporting, end
      assistant SendInvoiceAssistant("CUSTOMERINVOICESUPPLYCHAIN", Company, InvoiceId) {
         when OK {
            exit OK;

         }
         when CANCEL {
            exit CANCEL;
         }
      }
   }
}

command PrintInvoiceCommand for CustomerOrderInvHead {
   label = "Print Invoice";
   enabled = [Objstate = "Preliminary" and(("OUTGOING_FISCAL_NOTE" in EnabledLccParams and FiscalNoteResponseValue = 100) or(not "OUTGOING_FISCAL_NOTE" in EnabledLccParams and(CreatorsReferenceRef = null or CreatorsReferenceRef.BlockedType != "ManualBlocked") and MediaCode = null and ComplianceMediaCode = null))];

   variable ValidatePrintStrucVar {
      type = Structure(ValidatePrintStruc);
   }
   variable ReportResultStrucVar {
      type = Structure(ReportResultStruc);
   }
   variable ResultKeysVar {
      type = Text;
   }

   execute {
      confirm("The customer invoice will be printed.") {
         when CANCEL {
            exit;
         }
      }
      call ValidatePrintInvoice(Company, InvoiceId, Identity, SeriesId, InvoiceNo, InvoiceType) into ValidatePrintStrucVar;
      if [ValidatePrintStrucVar.CustomerInvPostConfirmMsg != null] {
         set ConfirmMessage = ValidatePrintStrucVar.CustomerInvPostConfirmMsg;
         // !TODO TEUXX-14211 CustomerInvPostConfirmMsg has break lines in the confirmation message and needs to be handled in client for line break
         messagebox("", question, "${ConfirmMessage}") {
            when "Yes" {
               log("Confirmed yes");
            }
            when "No" {
               exit;
            }
         }
      }
      if [ValidatePrintStrucVar.TaxCodeInfoMsg != null] {
         set InfoMessage = ValidatePrintStrucVar.TaxCodeInfoMsg;
         alert("${InfoMessage}");
      }
      if [ValidatePrintStrucVar.TaxCodeConfirmMsg != null] {
         set ConfirmMessage = ValidatePrintStrucVar.TaxCodeConfirmMsg;
         messagebox("", question, "${ConfirmMessage}") {
            when "Yes" {
               log("Confirmed yes");
            }
            when "No" {
               exit;
            }
         }
      }
      call PrintInvoice(NcfReference) into ReportResultStrucVar;
      set ResultKeysVar = ReportResultStrucVar.ResultKey;
      if [ResultKeysVar != null] {
         printdialog ResultKeysVar;
      }
      else {
         if [ReportResultStrucVar.PrintError != null] {
            alert("${ResultsVar.PrintError}");
            exit;
         }
      }
   }
}

command PrintWorkCopyCommand for CustomerOrderInvHead {
   label = "Print Work Copy";
   enabled = [(Objstate = "Preliminary" and "OUTGOING_FISCAL_NOTE" in EnabledLccParams and FiscalNoteResponseValue = 100) or(not "OUTGOING_FISCAL_NOTE" in EnabledLccParams and Objstate = "Preliminary")];
   variable ResultKeyVar {
      type = Text;
   }
   execute {
      call PrintWorkCopy() into ResultKeyVar;
      printdialog ResultKeyVar;
   }
}

command ReprintOriginalfromArchiveCommand for CustomerOrderInvHead {
   label = "Reprint Original from Archive";
   -- check enablefunction in command definition
   enabled = [Objstate != "Preliminary" and Objstate != "Cancelled" and Objstate != null];
   variable ReportResultStrucVar {
      type = Structure(ReportResultStruc);
   }
   variable ResultKeyVar {
      type = Text;
   }
   execute {
      call ReprintOriginalFromArchive() into ReportResultStrucVar;
      if [ReportResultStrucVar.InfoMessage != null] {
         alert("${ReportResultStrucVar.InfoMessage}");
      }
      if [ReportResultStrucVar.ResultKey != null] {
         set ResultKeyVar = ReportResultStrucVar.ResultKey;
         printdialog ResultKeyVar;
      }
   }
}

command ReprintOriginalDuplicateCommand for CustomerOrderInvHead {
   label = "Reprint Original Duplicate";
   -- check enablefunction in command definition
   enabled = [Objstate != "Preliminary" and Objstate != "Cancelled" and Objstate != null];
   variable ReportResultStrucVar {
      type = Structure(ReportResultStruc);
   }
   variable ResultKeyVar {
      type = Text;
   }
   execute {
      call ReprintOriginalDuplicate() into ReportResultStrucVar;
      if [ReportResultStrucVar.InfoMessage != null] {
         alert("${ReportResultStrucVar.InfoMessage}");
      }
      if [ReportResultStrucVar.ResultKey != null] {
         set ResultKeyVar = ReportResultStrucVar.ResultKey;
         printdialog ResultKeyVar;
      }
   }
}

command ReprintModifiedCommand for CustomerOrderInvHead {
   label = "Reprint Modified";
   -- check enablefunction in command definition
   enabled = [Objstate in("Printed", "Posted", "PostedAuth", "PaidPosted", "PartlyPaidPosted")];
   variable ResultKeyListStrVar {
      type = Text;
   }
   execute {
      call GetNoInvoiceCopies(Company, Identity, PartyType) into MaxCopyNo;
      dialog ReprintModifiedInvoiceDialog(MaxCopyNo) into(PrintOption, Duplicate, CopyNo) {
         when OK {
            call ReprintModifiedInvoice(Identity, PartyType, InvoiceType, AggregationNo, Collect, Duplicate, CopyNo, PrintOption) into ResultKeyListStrVar;
            if [ResultKeyListStrVar != null] {
               printdialog ResultKeyListStrVar;
            }
            exit OK;
         }
         when CANCEL {
            exit;
         }
      }
   }
}

command ResendInvoiceCommand for CustomerOrderInvHead {
   label = "Resend Invoice";
   enabled = [(not Objstate in("Preliminary", "Preliminary")) and InvoiceTypeRate != "CREDIT_INV" and(MediaCode != null or("E-INVOICING_COMPLIANCE" in EnabledLccParams and ComplianceMediaCode != null))];
   execute {
      assistant SendInvoiceAssistant("CUSTOMERINVOICESUPPLYCHAIN", Company, InvoiceId) {
         when OK {
            exit OK;
         }
         when CANCEL {
            exit CANCEL;
         }
      }
   }
}

command CreateCreditInvoiceCommand for CustomerOrderInvHead {
   label = "Create Credit Invoice";
   enabled = [Objstate in("PostedAuth", "PaidPosted", "PartlyPaidPosted") and
   (InvoiceType = CompanyDefInvoiceTypeRef.DefAdvCoDrInvType or InvoiceType = CompanyDefInvoiceTypeRef.DefCoPrepayDebInvType or InvoiceType in("CUSTORDDEB", "SELFBILLDEB", "CUSTCOLDEB") or("PREPAYMENT_TAX_DOCUMENT" in EnabledLccParams and InvoiceType = CompanyDefInvoiceTypeRef.DefCoTaxDocType))];
   variable ValidateCreateCreditStrucVar {
      type = Structure(ValidateCreateCreditStruc);
   }
   execute {
      confirm("This will create a credit invoice for the customer invoice.") {
         when CANCEL {
            exit;
         }
      }
      call ValidateCreateCredit(Company, InvoiceId, CreatorsReference, SeriesId, InvoiceNo, Currency, "CREDIT") into ValidateCreateCreditStrucVar;

      if [ValidateCreateCreditStrucVar.CreditAmtPerOrderConfirmMsg != null] {
         confirm("${ValidateCreateCreditStrucVar.CreditAmtPerOrderConfirmMsg}") {
            when CANCEL {
               exit;
            }
         }
      }
      if [ValidateCreateCreditStrucVar.CreditAmtPerDebitConfirmMsg != null] {
         confirm("${ValidateCreateCreditStrucVar.CreditAmtPerDebitConfirmMsg}") {
            when CANCEL {
               exit;
            }
         }
      }
      if [ValidateCreateCreditStrucVar.CorrInvoicePerRefInvoiceConfirmMsg != null] {
         confirm("${ValidateCreateCreditStrucVar.CorrInvoicePerRefInvoiceConfirmMsg}") {
            when CANCEL {
               exit;
            }
         }
      }
      set UseDebitInvRateVar = 0;
      if [ValidateCreateCreditStrucVar.CorrencyRateReferenceConfirmMsg != null] {
         inquire("${ValidateCreateCreditStrucVar.CorrencyRateReferenceConfirmMsg}") {
            when YES {
               set UseDebitInvRateVar = 1;
            }
            when CANCEL {
               exit;
            }
         }
      }
      if [ValidateCreateCreditStrucVar.CreditDebitInvoiceFeeConfirmMsg != null] {
         messagebox("", question, "${ValidateCreateCreditStrucVar.CreditDebitInvoiceFeeConfirmMsg}") {
            when "Yes" {
               set AllowCreditInvFeeVar1 = "TRUE";
            }
            when "No" {
               set AllowCreditInvFeeVar = "FALSE";
            }
         }
      }
      set ExcludeServiceItems = "FALSE";
      if [ValidateCreateCreditStrucVar.CreateInvoiceExcludeServiceMsg != null] {
         messagebox("", question, "${ValidateCreateCreditStrucVar.CreateInvoiceExcludeServiceMsg}") {
            when "Yes" {
               set ExcludeServiceItems = "TRUE";
            }
            when "No" {
               exit;
            }
         }
      }
      if [ValidateCreateCreditStrucVar.PrepaymentInvoice = "TRUE"] {
         set InvoiceCategoryVar = "PREPAYMENT";
      }
      else {
         set InvoiceCategoryVar = "CREDIT";
      }
      call CreateCreditInvoices(InvoiceId, UseDebitInvRateVar, InvoiceCategoryVar, AllowCreditInvFeeVar, ExcludeServiceItems);
   }
}

command CreateCorrectionInvoiceCommand for CustomerOrderInvHead {
   label = "Create Correction Invoice";
   enabled = [Objstate in("PostedAuth", "PaidPosted", "PartlyPaidPosted") and(not CorrectionExists) and InvoiceTypeRate != "CREDIT_INV" and
   (InvoiceType = CompanyDefInvoiceTypeRef.DefCoCorInvType or InvoiceType = CompanyDefInvoiceTypeRef.DefColCorInvType or InvoiceType in("CUSTORDDEB", "CUSTCOLDEB"))];

   variable ValidateCreateCreditStrucVar {
      type = Structure(ValidateCreateCreditStruc);
   }
   execute {
      confirm("This will create a correction invoice for the customer invoice.") {
         when CANCEL {
            exit;
         }
      }
      call ValidateCreateCredit(Company, InvoiceId, CreatorsReference, SeriesId, InvoiceNo, Currency, "CORRECTION") into ValidateCreateCreditStrucVar;

      if [ValidateCreateCreditStrucVar.CreditAmtPerOrderConfirmMsg != null] {
         confirm("${ValidateCreateCreditStrucVar.CreditAmtPerOrderConfirmMsg}") {
            when CANCEL {
               exit;
            }
         }
      }
      if [ValidateCreateCreditStrucVar.CreditAmtPerDebitConfirmMsg != null] {
         confirm("${ValidateCreateCreditStrucVar.CreditAmtPerDebitConfirmMsg}") {
            when CANCEL {
               exit;
            }
         }
      }
      if [ValidateCreateCreditStrucVar.CorrInvoicePerRefInvoiceConfirmMsg != null] {
         confirm("${ValidateCreateCreditStrucVar.CorrInvoicePerRefInvoiceConfirmMsg}") {
            when CANCEL {
               exit;
            }
         }
      }
      set UseRefInvCurrRateVar = 1;
      set ExcludeServiceItems = "FALSE";
      if [ValidateCreateCreditStrucVar.CreateInvoiceExcludeServiceMsg != null] {
         messagebox("", question, "${ValidateCreateCreditStrucVar.CreateInvoiceExcludeServiceMsg}") {
            when "Yes" {
               set ExcludeServiceItems = "TRUE";
            }
            when "No" {
               exit;
            }
         }
      }

      call CreateCreditInvoices(InvoiceId, UseRefInvCurrRateVar, "CORRECTION", "FALSE", ExcludeServiceItems);
   }
}

command CreateRateCorrectionCommand for CustomerOrderInvHead {
   label = "Currency Rate Correction";
   enabled = [Objstate = "PostedAuth" and InvoiceType in("CUSTORDDEB", "CUSTCOLDEB") and AdvancePrepayInvoice = false and
   CorrectionInvoice = false and CorrectionExists = false and Currency != BaseCurrencyCode and Company != null and CreditInvoices = null];

   execute {
      call GetTaxSell(Company) into TaxSellVar;
      dialog RateCorrectionInvoiceDialog(Company, InvoiceId, TaxSellVar, Currency, TaxCurrRate, FinCurrRate) {
         when OK {
            exit;
         }
      }
   }
}

command RemoveCreditCorrInvoiceCommand for CustomerOrderInvHead {
   label = "Remove Credit/Corr.Invoice";
   enabled = [(InvoiceType = CompanyDefInvoiceTypeRef.DefCoCorInvType or InvoiceType = CompanyDefInvoiceTypeRef.DefColCorInvType or InvoiceType = CompanyDefInvoiceTypeRef.DefAdvCoCrInvType or InvoiceType in("CUSTORDCRE", "CUSTCOLCRE", "SELFBILLCRE", "COREBCRE") or("PREPAYMENT_TAX_DOCUMENT" in EnabledLccParams and InvoiceType = CompanyDefInvoiceTypeRef.DefCoCreTaxDocType)) and
   Objstate = "Preliminary" and InvoiceTypeRate != "CORRECTION_INV" and not(JsInvoiceState in("ReadyForTransfer", "Transferred", "Updated"))];
   execute {
      confirm("This will remove the credit/correction invoice.") {
         when CANCEL {
            exit;
         }
      }
      call RemoveInvoice(Company, PartyType, Identity, SeriesId, InvoiceNo);
   }
}

command RemovePrepaymentBasedInvoiceCommand for CustomerOrderInvHead {
   label = "Remove Prepayment Based Invoice";
   enabled = [Objstate = "Preliminary" and(InvoiceType = CompanyDefInvoiceTypeRef.DefCoPrepayDebInvType or InvoiceType = CompanyDefInvoiceTypeRef.DefCoPrepayCreInvType) and PrepaymentInvMethod = "PREPAYMENT_BASED_INVOICE" and
   InvoiceTypeRate != "CORRECTION_INV" and not(JsInvoiceState in("ReadyForTransfer", "Transferred", "Updated"))];
   execute {
      confirm("This will Remove the Prepayment Based Invoice.") {
         when CANCEL {
            exit;
         }
      }
      call RemoveInvoice(Company, PartyType, Identity, SeriesId, InvoiceNo);
   }
}

command ViewDebitInvoicesCommand for CustomerOrderInvHead {
   label = "Debit Invoices";
   enabled = [DebitInvoices != null];
   variable UrlVar {
      type = Text;
   }
   execute {
      call GetCustomerInvoicesUrl(DebitInvoices) into UrlVar;
      if [UrlVar != null] {
         navigate "${UrlVar}";
      }
   }
}

command ViewPreviousReferenceInvoiceCommand for CustomerOrderInvHead {
   label = "Previous Reference Invoices";
   enabled = [PrevRefInvoices != null];
   variable UrlVar {
      type = Text;
   }
   execute {
      call GetCustomerInvoicesUrl(PrevRefInvoices) into UrlVar;
      if [UrlVar != null] {
         navigate "${UrlVar}";
      }
   }
}

command ViewCreditInvoicesCommand for CustomerOrderInvHead {
   label = "Credit Invoices";
   enabled = [CreditInvoices != null];
   variable UrlVar {
      type = Text;
   }
   execute {
      call GetCustomerInvoicesUrl(CreditInvoices) into UrlVar;
      if [UrlVar != null] {
         navigate "${UrlVar}";
      }
   }
}

command ViewCorrectionInvoiceCommand for CustomerOrderInvHead {
   label = "Correction Invoice";
   enabled = [CorrectionExists];
   execute {
      navigate "page/CustomerOrderInvoices/List?$filter=Company eq $[Company] and InvoiceId eq $[CorrectionInvoiceId]";
   }
}

command PrePostingCommand for CustomerOrderInvHead {
   label = "Pre Posting";
   enabled = [PreAccountingId != null];
   execute {
      set SourceIdentifierVar = "for Customer Invoice" {
         translatable = true;
      }
      assistant PrepostingWithSource.PrePostingWithSourceAssistant(null, PreAccountingId, Contract, true, SourceIdentifierVar) {
         when CANCEL {
            exit;
         }
      }
   }
}

command CustomerInvoicePostingsAnalyCommand for CustomerOrderInvHead {
   label = "Customer Invoice Postings Analysis";
   enabled = [InvoiceId != null];
   execute {
      navigate "page/CustomerInvoicePostingsAnalysis/Form?contexts=Company:$[Company]&$filter=InvoiceId eq $[InvoiceId]";
   }
}

command InstallmentPlanandDiscountsCommand for CustomerOrderInvHead {
   label = "Installment Plan and Discounts";
   enabled = [InvoiceId != null];
   execute {
      assistant InstallmentPlanAndDisc.InstallmentPlanAndDiscAssistant(Company, InvoiceId, "FALSE") {
         when OK {
            call RefreshHeader();
            exit;
         }
      }
   }
}

command NotesCommand for CustomerOrderInvHead {
   label = "Notes";
   enabled = [InvoiceId != null];
   variable NoteIdNum {
      type = Number;
   }
   execute {
      set PackageNameStr = "INVOICE_NOTE_API";
      set CallingProjectionNameStr = "CustomerOrderInvoiceHandling";
      assistant NotesAssistant(PackageNameStr, CallingProjectionNameStr, keyref, luname, "") into(NoteIdNum) {
         when OK {
            call RefreshHeader();
            exit;
         }
      }
   }
}

-- gelr: outgoing_fiscal_note, begin
command SendFiscalNoteCommand for CustomerOrderInvHead {
   label = "Send Electronic Fiscal Note";
   enabled = [Objstate = "Preliminary" and "OUTGOING_FISCAL_NOTE" in EnabledLccParams and FiscalNoteResponseValue != 110];
   execute {
      confirm("This will send the Fiscal Note.") {
         when OK {
            call SendFiscalNote(Company, InvoiceId);
         }
         when CANCEL {
            exit;
         }
      }
   }
}
command VoidFiscalNoteCommand for CustomerOrderInvHead {
   label = "Send Void Request";
   -- check enablefunction in command definition
   enabled = [Objstate = "Preliminary" and "OUTGOING_FISCAL_NOTE" in EnabledLccParams];
   execute {
      confirm("This will send the Void Request.") {
         when OK {
            call VoidFiscalNote(Company, InvoiceId);
         }
         when CANCEL {
            exit;
         }
      }
   }
}

command CancelFiscalNoteCommand for CustomerOrderInvHead {
   label = "Send Cancel Request";
   enabled = [Objstate = "PostedAuth" and "OUTGOING_FISCAL_NOTE" in EnabledLccParams and FiscalNoteResponseValue = 100];
   execute {
      confirm("This will cancel the Fiscal Note.") {
         when OK {
            call CancelFiscalNote(Company, InvoiceId);
         }
         when CANCEL {
            exit;
         }
      }
   }
}
-- gelr: outgoing_fiscal_note, end

-- gelr:it_xml_invoice, begin
command AddRemoveInvFeeCommand for CustomerOrderInvHead {
   label = "Add/Remove Invoice Fee";
   variable InfoVar Text;
   enabled = ["IT_XML_INVOICE" in EnabledLccParams and InvoiceFeeEnabled = true and Objstate = "Preliminary" and not(component.CustomerInvoiceItemList.IsDirty)];
   execute {
      call AddRemoveInvFee() into InfoVar;
      if [InfoVar != null] {
         info("${InfoVar}");
      }
   }
}
-- gelr:it_xml_invoice, end


-- gelr:prepayment_tax_document, begin
command AdvanceInvoicesCommand for CustomerOrderInvHead {
   label = "Advance Invoices";
   enabled = ["PREPAYMENT_TAX_DOCUMENT" in EnabledLccParams and CorrectionInvoice = false and InvoiceType != CompanyDefInvoiceTypeRef.DefCoTaxDocType and not AdvancePrepayInvoice];
   execute {
      assistant AdvanceInvReferenceAssistant(Identity, IdentityRef.Name, PartyType, SeriesId, InvoiceNo, InvoiceId, "CUSTOMER_ORDER_INV_HEAD_API", null, Currency, ProjectId, Objstate, GrossAmount, Company, true) {
         when OK {
            exit OK;
         }
      }
   }
}
-- gelr:prepayment_tax_document, end


--gelr: boleto, begin
@DynamicComponentDependency PAYLED
command PrintBoletoCommand for CustomerOrderInvHead {
   label = "Print Boleto";
   enabled = [BoletoPrinted = "FALSE" and Objstate = "PostedAuth" and "BOLETO" in EnabledLccParams];
   variable ResultKeyVar {
      type = Text;
   }
   execute {
      call PrintBoleto() into ResultKeyVar;
      printdialog ResultKeyVar;
   }
}
--gelr: boleto, end
---------------------------- LINES TAB COMMANDS -----------------------------

command CustomerInvItemCustomerOrderCommand for CustomerOrderInvItem {
   label = "Customer Order";
   enabled = [true];
   execute {
      navigate "page/CustomerOrder/Form?$filter=OrderNo eq $[OrderNo]";
   }
}

command CustomerInvItemCustomerOrderLineCommand for CustomerOrderInvItem {
   label = "Customer Order Line";
   enabled = [true];
   execute {
      navigate "page/CustomerOrderLines/List?$filter=OrderNo eq $[OrderNo] and LineNo eq $[LineNo] and RelNo eq $[ReleaseNo]";
   }
}

command CustomerInvItemRMACommand for CustomerOrderInvItem {
   label = "RMA";
   enabled = [RmaNo != null];
   execute {
      navigate "page/ReturnMaterialAuthorization/Form?$filter=RmaNo eq $[RmaNo]";
   }
}

command CustomerInvItemTaxLinesCommand for CustomerOrderInvItem {
   label = "Tax Lines";
   mode = SingleRecord;
   enabled = [true];
   variable PackageNameVar {
      type = Text;
   }
   variable ReadOnlyVar {
      type = Boolean;
   }
   variable CalcBaseVar {
      type = Text;
   }
   variable TitleVar {
      type = Text;
   }
   variable SetDefaultCmdVisibleVar {
      type = Boolean;
   }
   execute {
      set ReadOnlyVar = false;
      set CalcBaseVar = "NET_BASE";
      set PackageNameVar = "CUSTOMER_ORDER_INV_ITEM_API";
      set TitleVar = "Customer Invoice Tax Lines" {
         translatable = true;
      }
      if [Objstate = "Posted" or parent.Objstate in("Printed", "Cancelled") or(parent.InvoiceType = parent.CompanyDefInvoiceTypeRef.DefCoPrepayDebInvType) or
      (not PrelUpdateAllowed) or(parent.InvoiceTypeRate = "CORRECTION_INV") or(parent.TaxCalcMethod != "NOT_USED")] {
         set ReadOnlyVar = true;
      }
      if [parent.UsePriceInclTaxDb] {
         set CalcBaseVar = "GROSS_BASE";
      }
      set SetDefaultCmdVisibleVar = true;
      assistant TaxLinesCommonAssistant(keyref, PackageNameVar, ReadOnlyVar, CalcBaseVar, TitleVar, null, SetDefaultCmdVisibleVar) {
         when OK {
            if [not ReadOnlyVar] {
               call RefreshItems();
            }
            exit;
         }
         when CANCEL {
            exit;
         }
      }
   }
}

command CustomerInvItemWhtTaxLinesCommand for CustomerOrderInvItem {
   label = "Tax Lines, Withholding";
   mode = SingleRecord;
   enabled = [(parent.TaxWithholding = "TAXWITHHOLD" or WithheldTaxCurrAmount != null) and IncomeTypeId != null and not parent.PrepayBasedInv];
   variable ReadOnlyVar {
      type = Boolean;
   }
   execute {
      set ReadOnlyVar = true;
      if [parent.Objstate = "Preliminary" and PrelUpdateAllowed] {
         set ReadOnlyVar = false;
      }
      assistant TaxLinesWithholdingInvoicAssistant(Company, InvoiceId, ItemId, GrossCurrAmount, NetCurrAmount, ReadOnlyVar) {
         when OK {
            if [not ReadOnlyVar] {
               call RefreshItems();
            }
            exit;
         }
         when CANCEL {
            exit;
         }
      }
   }
}

command CustomerInvItemInvoiceLineDiscountCommand for CustomerOrderInvItem {
   label = "Invoice Line Discount";
   enabled = [not Charges];
   mode = SingleRecord;
   execute {
      set CompanyVar = parent.Company;
      set InvoiceIdVar = parent.InvoiceId;
      set ItemIdVar = ItemId;
      assistant CustomerInvoiceLineDiscount.CustIvcItemDiscountAssistant(InvoiceIdVar, ItemIdVar, Company) {
         when OK {
            call RefreshItems();
            exit;
         }
         when CANCEL {
            exit;
         }
      }
   }
}

@DynamicComponentDependency CFGCHR
command CustomerInvItemViewConfigurationCommand for CustomerOrderInvItem {
   label = "View Configuration";
   enabled = [ConfigurationId != "*" and OrderNo != null];
   mode = SingleRecord;
   execute {
      set Usage = "CustomerOrder";
      navigate "assistant/PartConfigurationAssistant/EditConfiguration?$action=InitConfiguration{  VarUsage:$[Usage],
                                                                                                   VarMode:'View',
                                                                                                   VarIdentity1:$[OrderNo],
                                                                                                   VarIdentity2:$[LineNo],
                                                                                                   VarIdentity3:$[ReleaseNo],
                                                                                                   VarIdentity4:$[LineItemNo]}";
   }
}

command CustomerInvItemPrePostingCommand for CustomerOrderInvItem {
   label = "Pre Posting";
   enabled = [PreAccountingId != null];
   mode = SingleRecord;
   execute {
      set SourceIdentifierVar = "for Customer Invoice Lines" {
         translatable = true;
      }
      assistant PrepostingWithSource.PrePostingWithSourceAssistant(null, PreAccountingId, Contract, true, SourceIdentifierVar) {
         when CANCEL {
            exit;
         }
      }
   }
}

---------------------------- VALIDATION COMMANDS ----------------------------

command AmountsValidationCommand for CustomerOrderInvItem {
   execute {
      -- gelr:disc_price_rounded, begin
      if [parent.DiscPriceRound] {
         if [OriginalAddDiscount != original.OriginalAddDiscount] {
            set AdditionalDiscount = OriginalAddDiscount;
         }
         if [OriginalOrderDiscount != original.OriginalOrderDiscount] {
            set OrderDiscount = OriginalOrderDiscount;
         }
      }
      -- gelr:disc_price_rounded, end
      call GetAmounts(Company, InvoiceId, ItemId, PriceQty, UnitPriceInclTax, SaleUnitPrice, ChargePercentBasis, ChargePercent, OrderDiscount,
      Discount, AdditionalDiscount, NetCurrAmount, GrossCurrAmount, VatCurrAmount, VatDomAmount, VatCode, TaxCalcStructureId)into InvoiceItemStructureVar;
      set VatDomAmount = InvoiceItemStructureVar.VatDomAmount;
      set VatCurrAmount = InvoiceItemStructureVar.VatCurrAmount;
      set GrossCurrAmount = InvoiceItemStructureVar.GrossCurrAmount;
      set NetCurrAmount = InvoiceItemStructureVar.NetCurrAmount;
      set VatCodeRef = InvoiceItemStructureVar.TaxCode;
      set TaxCalcStructureIdRef = InvoiceItemStructureVar.TaxCalcStrucId;
   }
}

command InvoicedQtyValidationCommand for CustomerOrderInvItem clone AmountsValidationCommand {
   execute {
      set PriceConvVar = PriceConv;
      set PriceQty = "#{(InvoicedQty * PriceConvVar)}";
      super;
   }
}

command PriceQtyValidationCommand for CustomerOrderInvItem clone AmountsValidationCommand {
   execute {
      set PriceConvVar = PriceConv;
      set InvoicedQty = "#{(PriceQty / PriceConvVar)}";
      super;
   }
}

command UnitPriceValidationCommand for CustomerOrderInvItem clone AmountsValidationCommand {
   variable FromDefaultsVar;

   execute {
      if [not parent.UsePriceInclTaxDb] {
         if [SaleUnitPrice = null and ChargePercent != null] {
            set UnitPriceInclTax = null;
         }
         else {
            call GetPrices(Company, InvoiceId, ItemId, SaleUnitPrice, UnitPriceInclTax, VatCode, TaxCalcStructureId, ShipAddrNo, CatalogNo, FromDefaultsVar)into InvoiceItemStructureVar;
            set SaleUnitPrice = InvoiceItemStructureVar.NetCurrPrice;
            set UnitPriceInclTax = InvoiceItemStructureVar.GrossCurrPrice;
            set MultipleTaxLines = InvoiceItemStructureVar.MultipleTaxLines;
            set VatCode = InvoiceItemStructureVar.TaxCode;
            set TaxCalcStructureId = InvoiceItemStructureVar.TaxCalcStrucId;
         }
      }
      super;
   }
}

command SaleUnitPriceValidationCommand for CustomerOrderInvItem clone UnitPriceValidationCommand {
   execute {
      set FromDefaultsVar = "FALSE";
      super;
   }
}

command UnitPriceInclTaxValidationCommand for CustomerOrderInvItem clone AmountsValidationCommand {
   execute {
      if [UnitPriceInclTax = null and ChargePercent != null] {
         set SaleUnitPrice = null;
      }
      else {
         set FromDefaultsVar = "FALSE";
         call GetPrices(Company, InvoiceId, ItemId, SaleUnitPrice, UnitPriceInclTax, VatCode, TaxCalcStructureId, ShipAddrNo, CatalogNo, FromDefaultsVar)into InvoiceItemStructureVar;
         set SaleUnitPrice = InvoiceItemStructureVar.NetCurrPrice;
         set UnitPriceInclTax = InvoiceItemStructureVar.GrossCurrPrice;
         set MultipleTaxLines = InvoiceItemStructureVar.MultipleTaxLines;
         set VatCode = InvoiceItemStructureVar.TaxCode;
         set TaxCalcStructureId = InvoiceItemStructureVar.TaxCalcStrucId;
      }
      super;
   }
}

command TaxCalcStructureIdValidationCommand for CustomerOrderInvItem clone UnitPriceValidationCommand {
   execute {
      if [original.TaxCalcStructureId = null and VatCode != null] {
         messagebox("", warning, "This will overwrite the existing tax code. Do you want to continue?") {
            when "Yes" {
               log("Confirmed yes");
            }
            when "No" {
               set TaxCalcStructureId = null;
               exit;
            }

         }
      }
      if [MultipleTaxLines and TaxCalcStructureId = null] {
         messagebox("", warning, "This will overwrite the existing multiple tax lines. Do you want to continue?") {
            when "Yes" {
               log("Confirmed yes");
            }
            when "No" {
               set TaxCalcStructureId = original.TaxCalcStructureId;
               exit;
            }
         }
      }
      set VatCode = null;
      set TaxCodePercentage = null;
      super;
   }
}

command VatCodeValidationCommand for CustomerOrderInvItem clone UnitPriceValidationCommand {
   execute {
      if [original.VatCode = null and VatCode != null and TaxCalcStructureId != null] {
         messagebox("", warning, "This will overwrite the existing tax calculation structure. Do you want to continue?") {
            when "Yes" {
               log("Confirmed yes");
            }
            when "No" {
               set VatCode = null;
               exit;
            }
         }
      }
      if [MultipleTaxLines and TaxCalcStructureId = null] {
         messagebox("", warning, "This will overwrite the existing multiple tax lines. Do you want to continue?") {
            when "Yes" {
               log("Confirmed yes");
            }
            when "No" {
               set VatCode = original.VatCode;
               exit;
            }
         }
      }
      set TaxCalcStructureId = null;
      call GetTaxRate(Company, VatCode) into TaxCodePercentage;
      call GetCategories(Company, VatCode) into InvoiceItemStructureVar;
      set TaxCategory1 = InvoiceItemStructureVar.TaxCategory1;
      set TaxCategory2 = InvoiceItemStructureVar.TaxCategory2;

      set FromDefaultsVar = "FALSE";
      if [VatCode = null] {
         set FromDefaultsVar = "DO_NOT_FETCH";
      }

      if [parent.UsePriceInclTaxDb] {
         if [UnitPriceInclTax = null and ChargePercent != null] {
            set SaleUnitPrice = null;
         }
         else {
            call GetPrices(Company, InvoiceId, ItemId, SaleUnitPrice, UnitPriceInclTax, VatCode, TaxCalcStructureId, ShipAddrNo, CatalogNo, FromDefaultsVar)into InvoiceItemStructureVar;
            set SaleUnitPrice = InvoiceItemStructureVar.NetCurrPrice;
            set UnitPriceInclTax = InvoiceItemStructureVar.GrossCurrPrice;
            set MultipleTaxLines = InvoiceItemStructureVar.MultipleTaxLines;
            set VatCode = InvoiceItemStructureVar.TaxCode;
            set TaxCalcStructureId = InvoiceItemStructureVar.TaxCalcStrucId;
         }
      }
      super;
   }
}

-------------------------------- CONDITIONS ---------------------------------

condition ListEditCondition = parent.InvoiceType != parent.CompanyDefInvoiceTypeRef.DefCoPrepayDebInvType and parent.InvoiceType != parent.CompanyDefInvoiceTypeRef.DefCoPrepayCreInvType
and parent.InvoiceTypeRate != "CORRECTION_INV";

-------------------------------- ASSISTANTS ---------------------------------

assistant CustomerInvoiceEmailAssistant using CustomerInvoiceEmailVirtualSet {
   label = "E-mail Customer Invoice";
   input(InvoiceId, YourReference, Email, Contract);
   steps {
      step {
         group EmailGroup;
      }
      final step {
      }
   }
   finish command {
      enabled = [Email != null];
      execute {
         call EmailCustomerInvoice(Objkey);
         exit OK;
      }
   }
}

---------------------------------- DIALOGS ----------------------------------

dialog CustInvoiceCancelationDialog for CustInvoiceCancelationStructure {
   label = "Cancel Customer Invoice";
   output(CancelReason);
   group CustInvoiceCancelationGroup;

   commandgroup ButtonCmdGroup {

      command Ok {
         execute {
            exit OK;
         }
      }
      command Cancel;
   }
}


----------------------------------- CARDS -----------------------------------

---------------------------------- DIALOGS ----------------------------------

---------------------------------- CHARTS -----------------------------------

--------------------------------- CALENDARS ---------------------------------

---------------------------------- SHEETS -----------------------------------

----------------------------- STATE INDICATORS ------------------------------

----------------------------------- TREES -----------------------------------

---------------------------------- PLUGINS ----------------------------------

------------------------------- IMAGE VIEWERS -------------------------------

