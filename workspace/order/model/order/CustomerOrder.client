---------------------------------------------------------------------------------------------------------------------------------------------
-- Date        Sign    History
-- ----------  ------  ----------------------------------------------------------------------------------------------------------------------
-- 2022-02-01  PumJlk  SCZ-17478, Added 'Details' command in CustRefRef lov in CustomerOrderGeneralGroup.
-- 2022-01-05  Skanlk  SCZ-17302, Modified Form page by adding homepage definition and removed the deprecated syntax form CroCustomerOrderNavEntry navigator.
-- 2021-12-23  Skanlk  Bug 161134(SC21R2-6825), Modified command BulkValidateTaxIdNumberCommand by passing the TAX_ID_TYPE to validate Tax ID other than EU countires.
-- 2021-10-27  NiDalk  SC21R2-5202, Set BusinessTransactionId editable only in Planned state.
-- 2021-10-14  cecobr  FI21R2-4615, Move Entity and associated clint/logic of BusinessTransactionCode from MPCCOM to DISCOM
-- 2021-09-15  NiRalk  SC21R2-2707, Added ValidatePaymentTermIdCommand to get payment term description.
-- 2021-08-12  NiRalk  SC21R2-2228, Included CustomerOrderStateBadge.fragemnt and used CustomerOrderStateFieldSet.
-- 2021-06-18  ChFolk  SC21R2-1407, Added CustomerOrderHistoryAssistant and CustomerOrderHistoryList. Modified CustomerOrderHistoryCommand to load the new assistant instead of history page.
-- 2021-05-10  Hahalk  SC21R2-981, Revert correction done from SC2020R1-11767.
-- 2021-02-22  Skanlk  SC2020R1-12672, Modified the enabled condition of HandlePrepaymentBasedInvoiceCommand by adding a condition to check whether the TaxCalcMethod is NOT USED.
-- 2021-02-08  RavDlk  SC2020R1-11767, Handled the enuemration values for IntrastatExempt
-- 2021-01-18  KiSalk  Bug 157485(SCZ-13238), Corrected search for the Name on Customer fields.
-- 2020-12-17  MaRalk  SC2020R1-11406, Reflected changes done in the projection for the attributes IntrastatExempt, PickInventoryType, SmConnection,
-- 2020-12-17          SchedulingConnection, AddrFlag as enumerations in the client.
-- 2020-12-01  MaEelk  SC2020R1-11510, lovswitch in CustomerNo was replaced with two lovs CustomerNoRef and CustomerNoWithoutCompanyRef
-- 2020-11-20  MaEelk  SC2020R1-11396, Midified the command ValidateAddressNoCommand in order to support validating Delivery Address and Document Address at the same time.
-- 2020-11-20          This would skip additional call to ValidateAddressNo.
-- 2020-10-14  ApWilk  SCZ-11789, Enabled the zoom for CustomerNo in CustomerOrderGroup.
-- 2020-09-17  WaSalk  GESPRING20-5808, Modified command ValidateContractCommand by adding gelr support attributes.
-- 2020-07-28  cecobr  gelr:brazilian_specific_attributes, Added BrazilianSpecificAttributesGroup\BUSINESS_TRANSACTION_ID field
-- 2020-09-03  RaVdlk  SC2021R1-302, Modified the condition for enabling pre posting assistant
-- 2020-07-15  RoJalk  Bug 154273 (SCZ-10310), Added ShipAddrNoChangedVar to the ValidateAddressNo call.
-- 2020-07-06  NiDalk  SCXTEND-4444, Added new command FetchExternalTaxCommand.
-- 2020-06-15  RaVdlk  SC2020R1-7428, Modified the condition before calling for CheckCustPoExist
-- 2020-05-20  MaRalk  SCXTEND-1749, Corrected value setting with the corresponding structure after calling GetDefaultDeliveryInformation in ValidateContractCommand.
-- 2020-04-27  MaRalk  SCXTEND-4101, Added search columns for the CustomerNo field in CustomerOrderGroup in order to have correct search functionality.
-- 2020-03-17  ChBnlk  Bug 152831 (SCZ-9358), Modified ReferenceGroup groupbox by adding the missing conditions to 'visible' property to display all the reference fields properly.
-- 2020-03-06  RaVdlk  SCXTEND-2212, Enabled the Duplicate Functionality.
-- 2020-02-24  AyAmlk  SCXTEND-1749, Altered the code so that the correct default information is fetched when changing either contract or customer.
-- 2020-02-20  MaRalk  SCXTEND-2838, Removed setting AgreementChangedVar to false in AfterSaveCommand, ValidateAddressNoCommand commands in order to
-- 2020-02-20          avoid the issue of not calling the method Fetch_Default_Delivery_Info when delivery address get changed.
-- 2020-02-05  Dihelk  GESPRING20-1789, Added Delivery Reason functionality.
-- 2020-01-31  MaEelk  SCXTEND-2309, Addded enable function CheckServiceRequestCreated to ConnectedWorkOrdersCommand
-- 2020-01-31  RaVdlk  SCXTEND-458, Modified the alert into error message and enabled free input in block customer order dialog
-- 2020-01-27  MaRalk  SCXTEND-451, Modified ValidateAddressNoCommand, AfterSaveCommand to reflect the changes of the ValidateAddressNo method.
-- 2010-01-27          Added validate command ValidateAgreementIdCommand to AgreementId field instead of ValidateAddressNoCommand.
-- 2020-01-23  RaVdlk  SCXTEND-458, Modified the validations of OrderIdRef and BlockReason
-- 2020-01-17  Maeelk  SCXTEND-769, Merged GetSupplyCountry and GetTaxPayingParty together and created GetContractDefaults.
-- 2020-01-17          OrderConfFlagDb, PackListFlagDb, PickListFlagDb, OrderConfDb, SummarizedSourceLinesDb and SummarizedFreightChargesDb were converted to enumerations
-- 2020-01-17          and removed the two letters from their names. Dynamically addded CustOrdCust7 to CustomernoRef when the company is not fetched the the customer order.
-- 2020-01-02  Hiralk  GESPRING20-1557, Added Invoice Reason functionality.
-- 2019-12-05  MaEelk  SCXTEND-342, Initila Focus was set to CustomerNoRef.
-- 2019-10-16  Hairlk  SCXTEND-795, Avalara integration, Added lov CustomerTaxUsageTypeRef to Order Details tab.
-- 2019-09-04  Rulilk  SCFALL19-62, Modified ValidateAddressNoCommand to set values for boolean variables if null. Copied AddressRec values to nullable fields.
-- 2019-08-02  ChLeLK  SCUXXW4-23412, Modified the width of the field "Shipment Creation" in the CO header from small to medium.
-- 2019-07-12  RuLiLk  SCUXXW4-22187, Modified validate commands to calculate WantedDelvieryDate based on freight parameters if not manually entered.
-- 2019-07-02  Satglk  SCUXXW4-22663, Modified CreateProjectCommand, added additional attribute CustomerId for navigation.
-- 2019-07-01  MeAblk  SCUXXW4-22422, Modified BeforeSaveCommand to remove order confirmation message as it is only relavent to order line modifications.
-- 2019-06-27  KhVese  SCUXXW4-20571, Modified enabled condition on command StagedBillingTemplateCommand
-- 2019-06-20  Satglk  SCUXXW4-21621, Contact Widget removed from Reference.
-- 2019-05-29  ChBnlk  SCUXXW4-18662, Modified FreightInfoCommand in order to navigate to the freight information properly based on the company.
-- 2019-05-27  ChBnlk  SCUXXW4-18127, Modified SendOrderConfirmationCommand and CustomerOrderTemplateCommand in order to replace CustomerNoRef.Name by CustomerName.
-- 2019-05-21  bajelk  SCUXXW4-18845, Changed Access Deferred Enabled Commands inside second level Access command groups as required.
-- 2019-05-16  fgusse  SCUXXW4-20685, Added translatable in documenttextcommand.
-- 2019-04-29  JeLise  SCUXXW4-15292, Implemented Calculate Earliest Delivery Date command.
-- 2019-04-29  ChBnlk  SCUXXW4-8515, Corrected according to the code review suggestions of the Template assistant.
-- 2019-04-24  bajelk  SCUXXW4-18423, Called GetRmAccGivenPrivAllParentDetails function and Passed ParentFilterNameVar,ParentObjectIdVar
--                     attributes to RelationshipManagementAccessPage by navigate entry to increase UXX Performance.
-- 2019-04-19  ChBnlk  SCUXXW4-15295, Implemented Print Order Confirmation command.
-- 2019-04-08  bajelk  SCUXXW4-18225, Added IsFilterEnabled, PossibleToShare functions in Access command to increase UXXPerformance.
-- 2019-03-31  ChBnlk  SCUXXW4-18290, Enabled warnings for CustOrderTemplateLineVirtual.
-- 2019-03-28  ChBnlk  SCUXXW4-8377, Implemented command CustomerOrderTemplateCommand.
-- 2019-03-27  Akhalk  SCUXXW4-15289, Added Command "Manual Credit Check" to  Customer Order.
-- 2019-03-22  LaThlk  SCUXXW4-15264, Implemented the command EnterPrePostingCommand and the AfterSaveCommand to handle pre accounting.
-- 2019-03-18  ErRalk  SCUXXW4-17229, Modified code to apply dynamic dependency only for relevent code segment.
-- 2019-03-12  ErRalk  SCUXXW4-17229, Added Dependency Annotation for the relevant fields.
-- 2019-03-03  bajelk  SCUXXW4-15372, Made IsFilterEnabled attribute as "True" for the visibility of Access command
-- 2019-03-03          And added PossibleToShare attribute in the navigation url of Access command.
-- 2019-02-25  Akhalk  SCUXXW4-15293,Added Command "Calculate Sales Promotions" to  Customer Order.
-- 2019-02-20  bajelk  SCUXXW4-4356, Added Command "Access" in Customer Order.
-- 2019-02-13  Akhalk  SCUXXW4-15268,Added Command "Return Material" to  Customer Order.
-- 2019-02-04  HaPulk  SCUXXW4-769, Added AdjustedWeightGrossInCharges/AdjustedVolumeInCharges in CustomerOrderAmounts used in Freight Group.
-- 2019-01-23  bajelk  SCUXXW4-4299, Added Details command in Access All tab.
-- 2019-01-23  bajelk  SCUXXW4-4491, Added list view for Access All inside the relationship management access tab.
-- 2019-01-10  bajelk  SCUXXW4-4501, Added list view for Access User inside the relationship management access tab.
-- 2019-01-10  bajelk  SCUXXW4-4496, Added the relationship management access tab and the list view for Access Group.
-- 2019-01-07  Akhalk  SCUXXW4-15245, Added Command "Shipment Info" to  Customer Order Line.
-- 2018-12-17  Akhalk  SCUXXW4-8340, Added Command "Order Line Milestone" to  Customer Order Line.
-- 2018-12-08  ShWtlk  MFUXXW4-1850, Added fragments for "FindExistingConfigurationCommand"
-- 2018-12-01  Sajklk  SAUXXW4-3390, Added Command "ConnectedWorkOrdersCommand" for CO Lines.
-- 2018-11-21  RuLiLk  SCUXXW4-8810, Added AfterCrud command for CustomerOrderLine to call SuggestedSalesPartAssistant.
-- 2018-11-13  HaPulk  SCUXXW4-8295, Added command "Create Corrective Inter-Site Price Postings" from 'Order Lines'.
-- 2018-11-13  JeLise  SCUXXW4-8302, Added Command "Create Advance Invoice" for Customer Order.
-- 2018-10-29  MalLlk  SCUXXW4-8817, Added Command "Supply Site Reservations" for CO Lines.
-- 2018-10-29  Akhalk  SCUXXW4-9225, Added Command "Order Line History" to Customer Order Line.
-- 2018-10-18  MalLlk  SCUXXW4-8177, Added Command "Cancel Order Line" to cancel Customer Order Line.
-- 2018-10-17  Akhalk  SCUXXW4-8207, Added  dlgCapabilityCheck using MTG Version: 1.23
-- 2018-09-14  Akhalk  SCUXXW4-1396, Added  tbwReturnMaterialOverview using MTG Version: 1.23
-- 2018-08-31  HaPulk  SCUXXW4-8170, Added Command "Cancel Order" to cancel Customer Order.
-- 2018-08-17  HaPulk  SCUXXW4-8380, Added Command "Send Order" to send Customer Order Messages.
-- 2018-08-17  Akhalk  SCUXXW4-8737, Added  dlgReturnMaterialCustomerOrder using MTG Version: 1.23
-- 2018-08-14  MalLlk  SCUXXW4-8372, Converted from dlgCustomerOrderEmail using MTG Version: 1.23
-- 2018-08-13  HaPulk  SCUXXW4-8270, Added 'Copy Order' Command to load CopyCustomerOrder Assistant.
-- 2018-08-03  SeJalk  SCUXXW4-9557, Added code to support frmStagedBillingTemplate.
-- 2018-07-18  MalLlk  SCUXXW4-8157, Converted from dlgBlockCustomerOrder using MTG Version: 1.22
-- 2018-07-05  MalLlk  SCUXXW4-12488, Converted from frmCustomerOrder using MTG Version: 1.22
--------------------------------------------------------------------------------------------------------------------------------------------------

client CustomerOrder;
component ORDER;
layer Core;
projection CustomerOrderHandling;

--------------------------------- FRAGMENTS ---------------------------------

include fragment CustomerOrderStateIndicator;
include fragment RunCapabilityCheck;
include fragment OrderBlockReasonLovSelector;
include fragment ReturnMaterialCustomerOrder;
-- Command "Send Order"
include fragment CustomerOrderMessageHandlerDialog;
-- Command "Cancel Order" and "Cancel Order Line"
include fragment OrderCancelReasonLovSelector;
include fragment SalesPartActiveLovSelector;
@DynamicComponentDependency DOP
include fragment DopDemandCustOrdList;
include fragment SupplySiteReservationDialog;
-- Command "Create Advance Invoice"
include fragment TaxCalcStructureActiveSelector;
include fragment TaxCodeRestrictedSelector;
-- Use for "Create Corrective Inter-Site Price Postings" command
include fragment CreateCorrectiveInterSitePricePostingsDialog;
include fragment CustOrdCust6Selector;
include fragment CustOrdCust7Selector;
include fragment UserAllowedSiteLovSelector;
include fragment OrderCoordinatorLovSelector;
include fragment CustInfoContactLovPubSelector;
include fragment CustAddressShipLovSelector;
include fragment CustBillAddressLovSelector;
@DynamicComponentDependency PURCH
include fragment ValidSupplierLovSelector;
include fragment OrderDeliveryTermLovSelector;
include fragment SalesPartSalesmanLovSelector;
include fragment CustomerAgreementLovSelector;
include fragment CustOrdCust2Selector;
include fragment CustomerAssortmentStructLovSelector;
@DynamicComponentDependency CALLC
include fragment CcCaseTaskHeaderSelector;
@DynamicComponentDependency PROJ
include fragment ProjectSiteLov2Selector;
@DynamicComponentDependency CONMGT
include fragment ConItemCustOrderLovSelector;
include fragment OrderQuotationLovSelector;
-- Used for "Representatives" List
@DynamicComponentDependency RMCOM
include fragment BusinessObjectRepresentativeHandling;
@DynamicComponentDependency RMCOM
include fragment BusinessRepresentativeLov;
@DynamicComponentDependency RMCOM
include fragment BusinessRepresentativeLovSelector;
-- Used for "Contacts" List
@DynamicComponentDependency RMCOM
include fragment BusinessObjectContactTab;
-- fragments for CustomerOrderLine
include fragment CustomerOrderLineBaseList;
include fragment CustomerOrderLineTab;
include fragment CustomerTemplateLovSelector;
include fragment SalesPartGtinNoLovSelector;
include fragment SalesPartClassificationLovSelector;
@DynamicComponentDependency EQUIP
include fragment EquipmentObjCustNoScrappedSelector;
@DynamicComponentDependency PURCH
include fragment PurchasePartSupplierLovSelector;
include fragment CustOrdCust1Selector;
@DynamicComponentDependency CFGCHR
include fragment ConfigSpecOrderUsageSelector;
include fragment TaxLiabilityLovSelector;
include fragment SalesPriceListJoinLovSelector;
include fragment SalesInterimOrderCommands;
--fragments for ConfigurationFindExistingCommand
@DynamicComponentDependency CFGCHR
include fragment BasePartOptionValueLov3Selector;
@DynamicComponentDependency CFGCHR
include fragment ConfigPartCatalogLovSelector;
include fragment LimitToAssortSalesPartLovSelector;
-- rental tab
@DynamicComponentDependency RENTAL
include fragment CustomerOrderLineRentalTab;
include fragment AllSalesPartActiveLovSelector;
@DynamicComponentDependency RENTAL
include fragment ActiveRentalTransScheduleSelector;
@DynamicComponentDependency PURCH
include fragment PurchPartSuppAllAcquisLovSelector;
include fragment CustomerOrderChargeTab;
--Quick register customer
include fragment OutputTypeLovSelector;
include fragment MpccomPhraseTextLovSelector;

include fragment CustomerOrderAddressDialog;
@DynamicComponentDependency RMCOM
include fragment RelationshipManagementAccessGeneral;
include fragment TaxIdNumbersValidation;
include fragment ReplicateOrderChangesDialog;
-- gelr:localization_control_center, begin
include fragment LocalizationControlCenterHandler;
-- gelr:localization_control_center, end
include fragment ShipmentTypeSelector;
-- gelr:brazilian_specific_attributes, begin
include fragment BusinessTransactionIdOutboundSelector;
-- gelr:brazilian_specific_attributes, end
include fragment CustomerOrderStateBadge;

warningsenabled = CustomerOrder, CheckEditConfigAllowed;
warningsenabled = ProcessCancelOrder;
warningsenabled = CustomerOrderCharge;
warningsenabled = CustOrderTemplateLineVirtual;
warningsenabled = ProcessUnreserve, UnreserveCustOrderLines;
warningsenabled = CustomerOrderLine, Unpeg, UnpegIpd;

----------------------------- NAVIGATOR ENTRIES -----------------------------
navigator {
   entry CustomerOrderNavEntry parent OrderNavigator.SalesOrder at index 100 {
      label = "Customer Order";
      page Form;
   }
   @DynamicComponentDependency CROMFG
   entry CroCustomerOrderNavEntry parent CromfgNavigator.ComponentMROExecutionNavEntry at index 600 {
      label = "Customer Order";
      page Form;
   }
}

-------------------------------- MAIN PAGES ---------------------------------
page Form using CustomerOrderSet {
   label = "Customer Order";
   homepage = true;
   startupmode = search;
   stateindicator CustomerOrderStateIndicator;

   crudactions {
      before command BeforeSaveCommand;
      after command AfterSaveCommand;
   }

   editmode = MultiField;
   selector CustomerOrderSelector;

   group CustomerOrderGroup;
   singleton CustomerOrderCustomerSingleton(OrderAddressArray) bind CustomerOrderSelector;

   group OrderAmountsGroup {
      visible = [not isNew];
   }

   tabs {
      tab {
         visible = [not isNew];
         label = "Lines";
         list CustomerOrderLineList(OrderLinesArray) {
            copyoncruddefault(OrderNo, CustomerNo, CustomerNo, ShipmentType, ShipmentCreation)
            to(OrderNo, CustomerNo, DeliverToCustomerNo, ShipmentType, ShipmentCreation);
         }
      }
      @DynamicComponentDependency RENTAL
      tab {
         visible = [not isNew];
         label = "Rental Lines";
         list CustomerOrderLineRentalList(RentalOrderLinesArray) {
            copyoncruddefault(OrderNo, CustomerNo, CustomerNo, ShipmentType, ShipmentCreation)
            to(OrderNo, CustomerNo, DeliverToCustomerNo, ShipmentType, ShipmentCreation);
         }
      }
      tab {
         label = "Order Details";
         arrange {
            arrange {
               group CustomerOrderGeneralGroup;
               group DeliverySettingsGroup;
               group DeliveryConfirmationGroup;
            }
            arrange {
               group DeliveryAddrGroup;
               group OrderAddressSingleOccurenceGroup bind CustomerOrderCustomerSingleton {
                  visible = [AddrFlag = "Yes"];
               }
               group DocumentAddressGroup;
               group InvoiceInfoGroup;
               group OrderPickingGroup;
               group ShipmentInfoGroup;
               -- gelr:brazilian_specific_attributes, begin
               group BrazilianSpecificAttributesGroup {
                  visible = ["BRAZILIAN_SPECIFIC_ATTRIBUTES" in EnabledLccParams];
               }
               -- gelr:brazilian_specific_attributes, end
            }
         }
         group FreightInfoGroup;
         group DocumentGroup {
            collapsed = [true];
         }
         arrange {
            group DocumentsToPrintGroup {
               collapsed = [true];
            }
            group DocumentsPrintedGroup {
               collapsed = [true];
               visible = [not isNew];
            }
         }
         group ReferenceGroup;
         arrange {
            group ProjectGroup;
            group SalesContractReferenceGroup;
         }

      }
      tab {
         visible = [not isNew];
         label = "Charges";
         list CustomerOrderChargeList(CustomerOrderChargeArray);
      }
      @DynamicComponentDependency DOP
      tab {
         visible = [not isNew and DopConnectionExists];
         label = "DOP";
         list DopInfoCustomerOrderList(DopDemandCustOrdArray);
      }
      @DynamicComponentDependency RMCOM
      tab {
         visible = [not isNew];
         label = "Involved Parties";

         list BusObjRepresentativeList(BusObjRepresentativeDetailsArray);
         list BusObjContactList(BusinessObjectContactDetailsArray);
      }
   }
   defaultsearchfields = OrderNo, CustomerNoRef, AuthorizeCodeRef, WantedDeliveryDate, CustomerPoNo, Objstate;


   -- CO Header Commands
   commandgroup StatusL1CmdGroup {

      commandgroup StatusCmdGroup {
         label = "Status";
         command ReleaseOrderCommand;
         command CancelOrderCommand;
         command CloseOrderCommand;
      }
   }

   commandgroup PrintShareL1CmdGroup {

      commandgroup ShareCmdGroup {
         label = "Share";
         command SendOrderConfirmationCommand {
            enablefunction CheckAllowedToSend(OrderNo, "ORDRSP");
         }
         command EmailOrderConfirmationCommand;
         command EmailProFormaInvoiceCommand;
         command PrintOrderConfirmationCommand;
         command PrintProFormaInvoiceCommand;
      }
   }

   commandgroup OperationsL1CmdGroup {

      commandgroup OperationsCmdGroup {
         label = "Operations";
         command OrderAddressCommand;
         command CustomerOrderTemplateCommand;
         command CalculateGroupDiscountCommand;
         command CalculateEarliestDeliveryDatCommand;
         command BulkValidateTaxIdNumberCommand;
         command ManuallyBlockOrderCommand;
         command ManualCreditCheckCommand {
            enablefunction CreditCheckValidLinesExist(OrderNo);
         }
         command StagedBillingTemplateCommand;
         command EnterPrePostingCommand;
         command FetchExternalTaxCommand;
      }
   }

   commandgroup FreightL1CmdGroup {

      commandgroup FreightCmdGroup {
         label = "Freight";
         command CalculateConsolidateFreightCommand;
         command FreightInfoCommand;
      }
   }
   command BlockedInfoCommand;
   command ShipmentLinesCommand;
   commandgroup InvoiceL1CmdGroup {

      commandgroup InvoiceCmdGroup {
         label = "Invoice";
         command CreateAdvanceInvoiceCommand {
            enablefunction EnableCreateAdvanceInvoiceCommand(OrderNo, Company);
         }
         command HandlePrepaymentBasedInvoiceCommand {
            enablefunction EnableHandlePrepaymentBasedInvoiceCommand(OrderNo, Company);
         }
         command InvoiceInfoCommand {
            enablefunction CheckInvoiceExist(OrderNo);
         }
      }
   }
   commandgroup RMAL1CmdGroup {

      commandgroup RMACmdGroup {
         label = "RMA";
         command ReturnMaterialAuthorizeCreateCommand {
            enabled = [(substring(AllowedOperations, 17, 1) != "*") and(substring(AllowedOperations, 18, 1) != "*") and ExternalRef != "FSM"];
         }
         command ViewEditReturnMaterialAuthorizationCommand;
      }
   }
   commandgroup RelatedPagesL1CmdGroup {

      commandgroup RelatedPagesCmdGroup {
         label = "Related Pages";
         @DynamicComponentDependency WO
         command ConnectedWorkOrdersCommand {
            enablefunction CheckServiceRequestCreated(OrderNo);
         }
         @DynamicComponentDependency CONMGT
         command SalesContractDetailsCommand;
         @DynamicComponentDependency WO
         command EnterServiceRequestCommand {
            enablefunction CheckServiceRequestNotCreated(OrderNo);
         }
      }
   }
   command CopyCustomerOrderCommand;
   command CustomerOrderHistoryCommand;
   commandgroup SalesPromotionsL1CmdGroup {

      commandgroup SalesPromotionsCmdGroup {
         label = "Sales Promotions";
         command CalculateSalesPromotionsCommand {
            enablefunction EnableSalesPromotionCommand(OrderNo, Company, CustomerNo);
         }
         command ViewSalesPromotionsCommand {
            enablefunction EnableSalesPromotionCommand(OrderNo, Company, CustomerNo);
         }
         command ClearSalesPromotionsCommand {
            enablefunction EnableSalesPromotionCommand(OrderNo, Company, CustomerNo);
         }
      }
   }

   commandgroup CommissionsL1CmdGroup {

      commandgroup CommissionsCmdGroup {
         label = "Commissions";
         command UpdateCalculatedCommissionsCommand;
         command UpdateAllCommissionsCommand;
      }
   }

   @DynamicComponentDependency PROJ
   commandgroup ProjectsL1CmdGroup {

      commandgroup ProjectsCmdGroup {
         label = "Project";
         command CreateProjectCommand {
            enablefunction CheckAnyLineNotProjConnected(OrderNo);
         }
         command ProjectDetailsCommand;
      }
   }

   command DocumentTextCommand;

   @DynamicComponentDependency RMCOM
   commandgroup AccessL1CmdGroup {

      commandgroup AccessL2CmdGroup {
         label = "Access";
         command AccessCommand {
            enablefunction IsFilterEnabled(SourceRef);
         }
      }
   }
}
-------------------------------- ASSISTANTS ---------------------------------
assistant CustomerOrderHistoryAssistant for CustomerOrderHistoryStructure {
   label = "Order History";
   input(OrderNo);
   singlestep {
      list CustomerOrderHistoryList using FetchCustomerOrderHistory(OrderNo);
   }
   command Cancel {
      label = "Close";
   }
}
--------------------------------- COMMANDS ----------------------------------
command BeforeSaveCommand for CustomerOrder {
   variable DeliveryInfoInPOLChangedVar    Boolean;
   variable DeliveryInfoNotInPOLChangedVar Boolean;
   variable DeliveryInfoOnlyIPDVar         Boolean;
   variable LabelNoteChangedVar            Text;
   variable SupplyCodeIpdExistVar          Text;
   variable WantedDeliveryDateChangedVar   Text;
   variable DataExistVar                   Structure(DataExistenceStructure);
   variable CustPOExistVar                 Structure(CustomerPoNoInfoStructure);
   variable SameCustomerVar                Text;
   variable HasAdvanceInvoiceVar           Boolean;
   variable AllowSendChangeRequestVar      Boolean;
   variable SendChangeRequestVar           Text;
   variable ReplicateVar                   Text;
   variable DoReplicateVar                 Boolean;
   variable UpdateLinesVar                 Boolean;
   variable DifferentCustomerProceedVar    Boolean;
   execute {
      if [isDirty] {
         if [AgreementId = null and AgreementId != original.AgreementId] {
            info("No Agreement registered - Please verify the Ship Via and Delivery Terms.");
         }

         if [LabelNote != original.LabelNote] {
            set LabelNoteChangedVar = "TRUE";
         }
         else {
            set LabelNoteChangedVar = "FALSE";
         }
         if [WantedDeliveryDate != original.WantedDeliveryDate] {
            set WantedDeliveryDateChangedVar = "TRUE";
         }
         else {
            set WantedDeliveryDateChangedVar = "FALSE";
         }

         if [OrderNo != null] {
            call CheckDataExistence(OrderNo, Contract, WantedDeliveryDate, LabelNoteChangedVar, WantedDeliveryDateChangedVar) into DataExistVar;
         }

         if [LabelNote != original.LabelNote or CustomerNo != original.CustomerNo or CustomerPoNo != original.CustomerPoNo or
         BackorderOption != original.BackorderOption or PrintDeliveredLines != original.PrintDeliveredLines or LanguageCode != original.LanguageCode] {
            set SupplyCodeIpdExistVar = DataExistVar.IpdExist;
         }
         else {
            set SupplyCodeIpdExistVar = "FALSE";
         }

         if [CustRef != original.CustRef and SupplyCodeIpdExistVar = "TRUE"] {
            set DeliveryInfoOnlyIPDVar = true;
         }
         else {
            set DeliveryInfoOnlyIPDVar = false;
         }

         if [PickingLeadtime != original.PickingLeadtime or CustCalendarId != original.CustCalendarId or RegionCode != original.RegionCode or
         DistrictCode != original.DistrictCode or RouteId != original.RouteId] {
            set DeliveryInfoNotInPOLChangedVar = true;
         }
         else {
            set DeliveryInfoNotInPOLChangedVar = false;
         }

         if [DeliveryLeadtime != original.DeliveryLeadtime or ExtTransportCalendarId != original.ExtTransportCalendarId or
         DeliveryTerms != original.DeliveryTerms or DelTermsLocation != original.DelTermsLocation or ForwardAgentId != original.ForwardAgentId] {
            set DeliveryInfoInPOLChangedVar = true;
         }
         else {
            set DeliveryInfoInPOLChangedVar = false;
         }

         if [WantedDeliveryDateChangedVar = "TRUE" or(DeliveryInfoInPOLChangedVar or DeliveryInfoNotInPOLChangedVar or DeliveryInfoOnlyIPDVar)] {
            if [DataExistVar.RowExist = 1 and WantedDeliveryDateChangedVar = "TRUE"] {
               messagebox("", question, "Wanted Delivery Date on the order header has been changed. Do you want to change Wanted Delivery Date on all order lines?") {
                  when "Yes" {
                     set ChangeLineDate = "Y";
                     set PlannedDeliveryDate = WantedDeliveryDate;
                     if [DataExistVar.UpdatePriceEffectiveDate = "TRUE" and Objstate = "Planned"] {
                        set UpdatePriceEffectiveDate = "TRUE";
                     }
                     if [DataExistVar.UpdatePriceEffectiveDate = "TRUE" and Objstate != "Planned"] {
                        messagebox("", question, "Changing the price effective date may result in a new price on the order line(s). Do you want to apply new price?") {
                           when "Yes" {
                              set UpdatePriceEffectiveDate = "TRUE";
                           }
                           when "No" {
                              set UpdatePriceEffectiveDate = "FALSE";
                           }
                        }
                     }
                     if [DataExistVar.ExpLinesExist = "TRUE"] {
                        messagebox("", question, "The specified date might not be within the range as given in the connected export license(s). For the date change to be accepted, such export license(s) will be disconnected. Do you wish to proceed?") {
                           when "Yes" {
                              set DisconnectExpLicense = "TRUE";
                           }
                           when "No" {
                              set DisconnectExpLicense = "FALSE";
                           }
                        }
                     }
                  }
                  when "No" {
                     log("Confirmed No");
                  }
               }
            }
         }
         // set a default value here in case only default lines exist
         set UpdateLinesVar = true;

         if [ShipAddrNo != original.ShipAddrNo and DataExistVar.NonDefLinesExist > 0] {
            inquire("Do you want to update all lines with the same delivery address as the header regardless of the Default Info check box?") {
               when YES {
                  set CopyAddrToLine = "TRUE";
                  set UpdateLinesVar = true;
               }
               when NO {
                  set CopyAddrToLine = "FALSE";
                  set UpdateLinesVar = false;
               }
               when CANCEL {
                  exit CANCEL;
               }
            }
         }
         if [DataExistVar.ReservedInvalidConfig > 0] {
            info("Order has reserved lines with other part configuration revisions effective for this date. Current revision will be used for reserved lines.");
         }
         if [DataExistVar.UnreservedInvalidConfig > 0] {
            messagebox("", question, "Order has lines with other part configuration revisions effective for this date. Do you want to update the configurations to these revisions?") {
               when "Yes" {
                  call UpdateConfigRevisions(WantedDeliveryDate);
                  info("Configuration status will be set to Parked. Please edit configurations in order to Complete the configurations.");
               }
               when "No" {
                  log("Confirmed No");
               }
            }
         }
         // Replication, start
         if [(ReplicateValuesModified = "TRUE") and(DataExistVar.PeggingExist = "TRUE") and(UpdateLinesVar)] {
            // Replicate CO header changes
            if [(((DataExistVar.IpdExist = "TRUE") and(DataExistVar.IptExist = "FALSE")) and((BackorderOption != original.BackorderOption) or(PrintDeliveredLines != original.PrintDeliveredLines))) or
            ((DataExistVar.IpdExist = "TRUE") and(CustomerPoNo != original.CustomerPoNo)) or
            ((DataExistVar.OnlyIptExist = "TRUE") and(CustomerPoNo != original.CustomerPoNo)) or
            ((DataExistVar.OnlyIptExist = "TRUE") and(CustRef != original.CustRef)) or
            (DataExistVar.ReplicateLabelNote = "TRUE")] {

               if [DataExistVar.SendChange = "TRUE"] {
                  set AllowSendChangeRequestVar = true;
               }
               else {
                  set AllowSendChangeRequestVar = false;
               }

               if [(DataExistVar.OnlyIptExist = "TRUE") and(CustRef != original.CustRef)] {
                  // if only IPT lines, then nothing should be replicated
                  set DoReplicateVar = false;
               }
               else {
                  set DoReplicateVar = true;
               }
            }
            else {
               // Replicate CO header changes to lines
               if [((DeliveryInfoNotInPOLChangedVar or DeliveryInfoOnlyIPDVar) and not(DeliveryInfoInPOLChangedVar)) or
               ((LanguageCode != original.LanguageCode) and(DataExistVar.IpdExist = "TRUE"))] {
                  set ChangedAttribNotInPol = "TRUE";
               }
               else {
                  set ChangedAttribNotInPol = "FALSE";
               }
               if [DataExistVar.LineSendChange = "TRUE"] {
                  set AllowSendChangeRequestVar = true;
               }
               else {
                  set AllowSendChangeRequestVar = false;
               }
               if [(WantedDeliveryDateChangedVar = "TRUE") and(ChangeLineDate = "N")] {
                  set DoReplicateVar = false;
               }
               else {
                  set DoReplicateVar = true;
               }
               set PeggingExist = DataExistVar.PeggingExist;
            }
            if [DoReplicateVar] {
               dialog ReplicateOrderChangesDialog(AllowSendChangeRequestVar, AllowSendChangeRequestVar) into(SendChangeRequestVar, ReplicateVar) {
                  when CANCEL {
                     exit CANCEL;
                  }
                  when OK {
                     set ReplicateChanges = ReplicateVar;
                     set ChangeRequest = SendChangeRequestVar;
                  }
               }
            }
         }
         // Replication, end
      }

      if [isDirty or isNew] {
         if [SalesContractNo != null and ContractRevSeq != null and ContractLineNo != null and ContractItemNo != null] {
            confirm("The contract line item is already connected to another CO, this connection will be removed. Do you want to proceed?") {
               when CANCEL {
                  exit;
               }
            }
         }
         if [OrderNo != null] {
            call HasAdvanceInvoice(OrderNo) into HasAdvanceInvoiceVar;
            if [HasAdvanceInvoiceVar] {
               set TotalAmount = OrderAmountRef.TotalGrossAmountCurr;
            }
         }
         if [CustomerPoNo != original.CustomerPoNo and CustomerPoNo != null] {
            call CheckCustPoExist(OrderNo, CustomerNo, CustomerPoNo) into CustPOExistVar;
            if [CustomerPoNo != CustPOExistVar.CustomerPoNo and CustPOExistVar.Result = 1] {
               confirm("Customer's purchase order number ${CustomerPoNo} already exists for this customer. Do you want to save the customer order?") {
                  when CANCEL {
                     exit CANCEL;
                  }
               }
            }
         }
         if [ProjectId != null and ProjectId != original.ProjectId] {
            call GetValidProjectCustomer(CustomerNo, ProjectId) into SameCustomerVar;
            if [SameCustomerVar = "FALSE"] {
               messagebox("", question, "The customer on Customer Order and customer on Project are not the same. Still want to save the record?") {
                  when "Yes" {
                     set DifferentCustomerProceedVar = true;
                  }
                  when "No" {
                     set DifferentCustomerProceedVar = false;
                  }
               }
               if [DifferentCustomerProceedVar = false] {
                  exit CANCEL;
               }
            }
         }
         if [SalesContractNo != original.SalesContractNo or ContractRevSeq != original.ContractRevSeq or ContractLineNo != original.ContractLineNo or ContractItemNo != original.ContractItemNo] {
            if [SalesContractNo = null] {
               set ContractRevSeq = null;
               set ContractLineNo = null;
               set ContractItemNo = null;
            }
         }
      }
   }
}

command AfterSaveCommand for CustomerOrder {
   variable CustomerNoVar {
      type = Text;
   }
   variable AddrNoVar {
      type = Text;
   }
   variable TaxInfoVar {
      type = Structure(OrderTaxInfoStructure);
   }
   variable AddressVar Structure(AddressStructure);
   variable ReturnAddressVar Structure(AddressStructure);
   variable DeliveryAddressVar {
      type = Boolean;
   }
   variable AgreementChangedVar {
      type = Text;
   }
   variable ShipAddrNoChangedVar {
      type = Text;
   }
   variable VarSourceIdentifier {
      type = Text;
   }
   variable MandatoryPreAccountingVar Boolean;

   execute {
      set VarSourceIdentifier = "for Customer Order ${OrderNo}" {
         translatable = true;
      }
      call IsPrePostingMandatory(Company) into MandatoryPreAccountingVar;

      if [CrudOperation = "create" and MandatoryPreAccountingVar] {
         assistant PrepostingWithSource.PrePostingWithSourceAssistant("M103", PreAccountingId, Contract, false, VarSourceIdentifier) {
            when OK {
               exit OK;
            }
         }
      }
      if [isDirty or isNew] {
         if [DeliveryAddressVar = true and(ShipAddrNo = null or CustomerNo = null)] {
            exit;
         }
         if [DeliveryAddressVar = false and(BillAddrNo = null or CustomerNo = null)] {
            exit;
         }
         if [AgreementId != original.AgreementId] {
            set AgreementChangedVar = "TRUE";
         }
         if [ShipAddrNo != original.ShipAddrNo] {
            set ShipAddrNoChangedVar = "TRUE";
         }
         copy this into AddressVar;
         call ValidateAddressNo(AddressVar, true, false, false, AgreementChangedVar, ShipAddrNoChangedVar) into ReturnAddressVar;
         copy ReturnAddressVar into this;

         if [ShipAddrNo != original.ShipAddrNo] {
            if [CustomerNoPay = null] {
               set CustomerNoVar = CustomerNo;
               set AddrNoVar = BillAddrNo;
            }
            else {
               set CustomerNoVar = CustomerNoPay;
               set AddrNoVar = CustomerNoPayAddrNo;
            }
            call GetTaxInfo(CustomerNoVar, AddrNoVar, Company, SupplyCountry, DeliveryCountryCode, CustomerNoPay, CustomerNoPayAddrNo, CustomerNo, BillAddrNo, AddrFlag, ShipAddrNo) into TaxInfoVar;
            set TaxIdNo = TaxInfoVar.TaxIdNo;
            set TaxIdValidatedDate = TaxInfoVar.TaxIdValidatedDate;
         }

         if [HasAdvanceInvoiceVar and OrderAmountRef.TotalGrossAmountCurr < TotalAmount] {
            info("Advance Invoice(s) exist for this customer order, existing advances may exceed the customer order total.");
         }
      }
   }
}

command ValidateReplicateValuesCommand for CustomerOrder {
   execute {
      if [isDirty and not(Objstate in("Planned", "Invoiced", "Cancelled")) and not(isNew)] {
         set ReplicateValuesModified = "TRUE";
      }
   }
}

command ValidateAddressNoCommand for CustomerOrder clone ValidateReplicateValuesCommand {
   variable AddressVar Structure(AddressStructure);
   variable ReturnAddressVar Structure(AddressStructure);
   variable DeliveryAddressVar {
      type = Boolean;
   }
   variable DocumentAddressVar {
      type = Boolean;
   }
   variable ValidatingCustomerVar {
      type = Boolean;
   }
   variable AgreementChangedVar {
      type = Text;
   }
   variable ShipAddrNoChangedVar {
      type = Text;
   }
   variable ExecuteValidateAddressNoVar {
      type = Boolean;
   }
   execute {
      set ExecuteValidateAddressNoVar = false;
      if [DeliveryAddressVar and ShipAddrNo != null and CustomerNo != null] {
         set ExecuteValidateAddressNoVar = true;
      }
      else {
         if [DocumentAddressVar and BillAddrNo != null and CustomerNo = null] {
            set ExecuteValidateAddressNoVar = true;
         }
         else {
            exit;
         }
      }

      if [ExecuteValidateAddressNoVar] {
         if [AgreementId != original.AgreementId] {
            set AgreementChangedVar = "TRUE";
         }
         if [ShipAddrNo != original.ShipAddrNo] {
            set ShipAddrNoChangedVar = "TRUE";
         }
         copy this into AddressVar;
         call ValidateAddressNo(AddressVar, DeliveryAddressVar, DocumentAddressVar, ValidatingCustomerVar, AgreementChangedVar, ShipAddrNoChangedVar) into ReturnAddressVar;
         copy ReturnAddressVar into this;
      }
      super;
   }
}

command ValidateDeliveryAddressCommand for CustomerOrder clone ValidateAddressNoCommand {
   variable CustomerNoVar {
      type = Text;
   }
   variable AddrNoVar {
      type = Text;
   }
   variable TaxInfoVar {
      type = Structure(OrderTaxInfoStructure);
   }
   execute {
      set DeliveryAddressVar = true;
      set DocumentAddressVar = false;
      set ValidatingCustomerVar = false;
      super;
      if [ShipAddrNo != original.ShipAddrNo] {
         if [CustomerNoPay = null] {
            set CustomerNoVar = CustomerNo;
            set AddrNoVar = BillAddrNo;
         }
         else {
            set CustomerNoVar = CustomerNoPay;
            set AddrNoVar = CustomerNoPayAddrNo;
         }
         call GetTaxInfo(CustomerNoVar, AddrNoVar, Company, SupplyCountry, DeliveryCountryCode, CustomerNoPay, CustomerNoPayAddrNo, CustomerNo, BillAddrNo, AddrFlag, ShipAddrNo) into TaxInfoVar;
         set TaxIdNo = TaxInfoVar.TaxIdNo;
         set TaxIdValidatedDate = TaxInfoVar.TaxIdValidatedDate;
      }
   }
}

command ValidateDocumentAddressCommand for CustomerOrder clone ValidateAddressNoCommand {
   variable CustomerNoVar {
      type = Text;
   }
   variable AddrNoVar {
      type = Text;
   }
   variable TaxInfoVar {
      type = Structure(OrderTaxInfoStructure);
   }
   execute {
      set DeliveryAddressVar = false;
      set DocumentAddressVar = true;
      set ValidatingCustomerVar = false;
      super;
      if [BillAddrNo != original.BillAddrNo] {
         if [CustomerNoPay = null] {
            set CustomerNoVar = CustomerNo;
            set AddrNoVar = BillAddrNo;
         }
         else {
            set CustomerNoVar = CustomerNoPay;
            set AddrNoVar = CustomerNoPayAddrNo;
         }
         call GetTaxInfo(CustomerNoVar, AddrNoVar, Company, SupplyCountry, DeliveryCountryCode, CustomerNoPay, CustomerNoPayAddrNo, CustomerNo, BillAddrNo, AddrFlag, ShipAddrNo) into TaxInfoVar;
         set TaxIdNo = TaxInfoVar.TaxIdNo;
         set TaxIdValidatedDate = TaxInfoVar.TaxIdValidatedDate;
      }
   }
}

command ValidateCustomerNoCommand for CustomerOrder clone ValidateAddressNoCommand {
   variable DefaultsVar {
      type = Structure(CustomerDefaultsStructure);
   }
   variable WantedDeliveryDateVar Timestamp;
   execute {
      if [CustomerNo != original.CustomerNo] {
         if [CustomerNo = null] {
            set ShipAddrNo = null;
            set BillAddrNo = null;
            exit;
         }
         if[WantedDeliveryDateChanged = "TRUE"] {
            set WantedDeliveryDateVar = WantedDeliveryDate;
         }
         else {
            set WantedDeliveryDateVar = null;
         }
         copy this into DefaultsVar;
         call GetCustomerDefaults(OrderNo, Contract, CustomerNo, SupplyCountry, VenderNo, WantedDeliveryDateVar, DefaultsVar) into DefaultsVar;
         copy DefaultsVar into this;
         if [OrderId != null and UsePreShipDelNoteDb = true and PickInventoryType = "OrdinaryInventory"] {
            set UsePreShipDelNoteDb = false;
         }

         set ValidatingCustomerVar = true;
         set DeliveryAddressVar = true;
         set DocumentAddressVar = true;
         super;
      }
   }
}

command ValidateNewCustomerNoCommand for CustomerOrder clone ValidateAddressNoCommand {
   variable NewCustomerIdVar {
      type = Text;
   }
   variable DefaultsVar {
      type = Structure(CustomerDefaultsStructure);
   }
   variable WantedDeliveryDateVar Timestamp;
   execute {
      if [IsNewCustomer] {
         assistant QuickRegisterCustomer.RegisterCustomerAssistant(true, Contract, Company, false, false, "") into(NewCustomerIdVar) {
            when OK {
               if [NewCustomerIdVar != null] {
                  set CustomerNo = NewCustomerIdVar;
                  if[WantedDeliveryDateChanged = "TRUE"] {
                     set WantedDeliveryDateVar = WantedDeliveryDate;
                  }
                  else {
                     set WantedDeliveryDateVar = null;
                  }
                  copy this into DefaultsVar;
                  call GetCustomerDefaults(OrderNo, Contract, CustomerNo, SupplyCountry, VenderNo, WantedDeliveryDateVar, DefaultsVar) into DefaultsVar;
                  copy DefaultsVar into this;
                  if [OrderId != null and UsePreShipDelNoteDb = true and PickInventoryType = "OrdinaryInventory"] {
                     set UsePreShipDelNoteDb = false;
                  }

                  set ValidatingCustomerVar = true;
                  set DeliveryAddressVar = true;
                  set DocumentAddressVar = true;
                  super;
               }
               set IsNewCustomer = false;
               exit;
            }
         }
         set IsNewCustomer = false;
      }
   }
}

command ValidateContractCommand for CustomerOrder clone ValidateAddressNoCommand {
   variable DefaultInfoVar {
      type = Structure(CustomerDefaultsStructure);
   }
   variable DefaultsVar {
      type = Structure(CustomerDefaultsStructure);
   }
   variable CompanyDefaultsVar {
      type = Structure(CompanyDefaultsStructure);
   }
   variable DeliveryInfoVar {
      type = Structure(DeliveryInfoStructure);
   }
   variable ValidateSourceVar {
      type = Text;
   }
   variable ContractDefaultsVar {
      type = Structure(ContractDefaultsStructure);
   }
   variable WantedDeliveryDateVar Timestamp;
   execute {
      if [Contract != original.Contract] {
         call GetContractDefaults(Contract)into ContractDefaultsVar;
         set SupplyCountry = ContractDefaultsVar.SupplyCountryDb;
         set FreeOfChgTaxPayParty = ContractDefaultsVar.FreeOfChgTaxPayParty;
      }
      call GetCompanyDefaults(Contract, CustomerNo, ShipAddrNo, SupplyCountry, CustomerNoPay) into CompanyDefaultsVar;
      set Company = CompanyDefaultsVar.Company;
      if [CompanyDefaultsVar.TaxLiabilityType != null and CustomerNo != null and ShipAddrNo != null] {
         set TaxLiability = CompanyDefaultsVar.TaxLiability;
      }
      set DelayCogsToDelivConfDb = CompanyDefaultsVar.DelayCogsToDelivConfDb;
      if [CompanyDefaultsVar.PayTermId != null] {
         set PayTermId = CompanyDefaultsVar.PayTermId;
      }
      -- gelr:localization_control_center, begin
      set EnabledLccParams = CompanyDefaultsVar.EnabledLccParams;
      -- gelr:localization_control_center, end
      -- gelr:alt_invoice_no_per_branch, begin
      if [CompanyDefaultsVar.ComponentA != null] {
         set ComponenetA = CompanyDefaultsVar.ComponentA;
      }
      -- gelr:alt_invoice_no_per_branch, end
      if[WantedDeliveryDateChanged = "TRUE"] {
         set WantedDeliveryDateVar = WantedDeliveryDate;
      }
      else {
         set WantedDeliveryDateVar = null;
      }
      if [CustomerNo != null] {
         if [Contract != original.Contract] {
            if [CustomerNo = null] {
               set ShipAddrNo = null;
               set BillAddrNo = null;
               exit;
            }
            copy this into DefaultsVar;
            call GetCustomerDefaults(OrderNo, Contract, CustomerNo, SupplyCountry, VenderNo, WantedDeliveryDateVar, DefaultsVar) into DefaultsVar;
            copy DefaultsVar into this;
            set ValidatingCustomerVar = false;
            set DeliveryAddressVar = true;
            set DocumentAddressVar = true;
            super;

            set ShipViaCode = null;

            call GetFirstValidAgreementId(CustomerNo, Contract, CurrencyCode) into AgreementId;
            call GetDefaultDeliveryInformation(OrderNo, Contract, CustomerNo, ShipAddrNo, AddrFlag, AgreementId, VendorNo, ShipViaCode, DeliveryTerms, DelTermsLocation, UsePriceInclTax) into DeliveryInfoVar;
            set RouteId = DeliveryInfoVar.RouteId;
            set ForwardAgentId = DeliveryInfoVar.ForwardAgentId;
            set ShipViaCode = DeliveryInfoVar.ShipViaCode;
            set DeliveryTerms = DeliveryInfoVar.DeliveryTerms;
            set DelTermsLocation = DeliveryInfoVar.DelTermsLocation;
            set DeliveryLeadtime = DeliveryInfoVar.DeliveryLeadtime;
            set PickingLeadtime = DeliveryInfoVar.PickingLeadtime;
            set ExtTransportCalendarId = DeliveryInfoVar.ExtTransportCalendarId;
            set ZoneId = DeliveryInfoVar.ZoneId;
            set FreightMapId = DeliveryInfoVar.FreightMapId;
            set FreightPriceListNo = DeliveryInfoVar.FreightPriceListNo;

            set AgreementId = DefaultInfoVar.AgreementId;
            set PayTermId = CompanyDefaultsVar.PayTermId;

            if [CustomerNoPay = null] {
               set CustomerNoVar = CustomerNo;
               set AddrNoVar = BillAddrNo;
            }
            else {
               set CustomerNoVar = CustomerNoPay;
               set AddrNoVar = CustomerNoPayAddrNo;
            }
            call GetTaxInfo(CustomerNoVar, AddrNoVar, Company, SupplyCountry, DeliveryCountryCode, CustomerNoPay, CustomerNoPayAddrNo, CustomerNo, BillAddrNo, AddrFlag, ShipAddrNo) into TaxInfoVar;
            set TaxIdNo = TaxInfoVar.TaxIdNo;
            set TaxIdValidatedDate = TaxInfoVar.TaxIdValidatedDate;
            if [ShipViaCode != null] {
               if [CustomerNo = null or ShipAddrNo = null or Contract = null or WantedDeliveryDate = null] {
                  exit;
               }

               set ValidateSourceVar = "SHIP_VIA_CODE";

               call GetDefaultInformation(ValidateSourceVar, Contract, CustomerNo, ShipAddrNo, SupplyCountry, ShipViaCode, VendorNo, ConfirmDeliveriesDb, OrderId, WantedDeliveryDateVar, Priority, AgreementId) into DefaultInfoVar;
               set RouteId = DefaultInfoVar.RouteId;
               set ForwardAgentId = DefaultInfoVar.ForwardAgentId;
               set DeliveryLeadtime = DefaultInfoVar.DeliveryLeadtime;
               set PickingLeadtime = DefaultInfoVar.PickingLeadtime;
               set ExtTransportCalendarId = DefaultInfoVar.ExtTransportCalendarId;
               set FreightMapId = DefaultInfoVar.FreightMapId;
               set ZoneId = DefaultInfoVar.ZoneId;
               set ShipmentType = DefaultInfoVar.ShipmentType;
               set ShipmentCreation = DefaultInfoVar.ShipmentCreation;
               if [WantedDeliveryDate != null] {
                  set WantedDeliveryDate = DefaultInfoVar.WantedDeliveryDate;
               }
               call GetActiveFreightPriceListNo(Contract, ShipViaCode, FreightMapId, ForwardAgentId, UsePriceInclTax, VendorNo) into FreightPriceListNo;
            }
            else {
               set FreightMapId = null;
               set ZoneId = null;
               set FreightPriceListNo = null;
               set ExtTransportCalendarId = null;
            }
         }

         if [Contract != null and Contract != original.Contract] {
            if [ShipAddrNo = null or WantedDeliveryDate = null] {
               exit;
            }
            set ValidateSourceVar = "CONTRACT";

            call GetDefaultInformation(ValidateSourceVar, Contract, CustomerNo, ShipAddrNo, SupplyCountry, ShipViaCode, VendorNo, ConfirmDeliveriesDb, OrderId, WantedDeliveryDateVar, Priority, AgreementId) into DefaultInfoVar;
            set AgreementId = DefaultInfoVar.AgreementId;
            set ShipViaCode = DefaultInfoVar.ShipViaCode;
            set DeliveryTerms = DefaultInfoVar.DeliveryTerms;
            set DelTermsLocation = DefaultInfoVar.DelTermsLocation;
            set DeliveryLeadtime = DefaultInfoVar.DeliveryLeadtime;
            set ExtTransportCalendarId = DefaultInfoVar.ExtTransportCalendarId;
            set RouteId = DefaultInfoVar.RouteId;
            set ForwardAgentId = DefaultInfoVar.ForwardAgentId;
            set WantedDeliveryDate = DefaultInfoVar.WantedDeliveryDate;
            set DelayCogsToDelivConfDb = DefaultInfoVar.DelayCogsToDelivConfDb;
            set UsePreShipDelNoteDb = DefaultInfoVar.UsePreShipDelNoteDb;
            set ShipmentType = DefaultInfoVar.ShipmentType;
            set ShipmentCreation = DefaultInfoVar.ShipmentCreation;
            set OrderId = DefaultInfoVar.OrderId;
         }
         if [UsePreShipDelNoteDb = true and PickInventoryType = "OrdinaryInventory"] {
            set UsePreShipDelNoteDb = false;
         }
      }
      call GetUsePriceInclTaxDb(Company, CustomerNo) into UsePriceInclTax;
      call GetActiveFreightPriceListNo(Contract, ShipViaCode, FreightMapId, ForwardAgentId, UsePriceInclTax, VendorNo) into FreightPriceListNo;
   }
}

command ValidateRouteIdCommand for CustomerOrder clone ValidateReplicateValuesCommand {
   execute {
      if [RouteId != original.RouteId] {
         call GetForwardAgentId(RouteId, Contract, CustomerNo) into ForwardAgentId;
      }
      super;
   }
}

command ValidateCustomerReferenceCommand for CustomerOrder clone ValidateReplicateValuesCommand {
   execute {
      if [CustRefRef != original.CustRefRef] {
         call GetCustRefName(CustomerNo, BillAddrNo, CustRef) into CustRefName;
      }
      super;
   }
}

command ValidateForwardAgentIdCommand for CustomerOrder clone ValidateReplicateValuesCommand {
   execute {
      call GetActiveFreightPriceListNo(Contract, ShipViaCode, FreightMapId, ForwardAgentId, UsePriceInclTax, VendorNo) into FreightPriceListNo;
      call GetForwardName(ForwardAgentId) into ForwardName;

      super;
   }
}

command ValidateDeliveryTermsCommand for CustomerOrder clone ValidateReplicateValuesCommand {
   execute {
      if [DeliveryTerms != original.DeliveryTerms] {
         set DelTermsLocation = "";
      }
      super;
   }
}

command ValidateWantedDeliveryDateCommand for CustomerOrder clone ValidateReplicateValuesCommand {
   execute {
      if [WantedDeliveryDate != original.WantedDeliveryDate] {
         set WantedDeliveryDateChanged = "TRUE";
      }
      super;
   }
}

command ValidatShipViaCodeCommand for CustomerOrder clone ValidateReplicateValuesCommand {
   variable ShipViaDependantsVar Structure(ShipViaDependantsStructure);
   variable DefaultInfoVar Structure(CustomerDefaultsStructure);
   variable ShipViaCodeChangedVar Text;
   variable ValidateSourceVar Text;
   variable WantedDeliveryDateVar Timestamp;
   execute {
      if [ShipViaCode != null] {
         if [isNew] {
            if [CustomerNo = null or ShipAddrNo = null or Contract = null or WantedDeliveryDate = null] {
               exit;
            }
            if[WantedDeliveryDateChanged = "TRUE"] {
               set WantedDeliveryDateVar = WantedDeliveryDate;
            }
            else {
               set WantedDeliveryDateVar = null;
            }
            set ValidateSourceVar = "SHIP_VIA_CODE";
            call GetDefaultInformation(ValidateSourceVar, Contract, CustomerNo, ShipAddrNo, SupplyCountry, ShipViaCode, VendorNo, ConfirmDeliveriesDb, OrderId, WantedDeliveryDateVar, Priority, AgreementId) into DefaultInfoVar;

            set RouteId = DefaultInfoVar.RouteId;
            set ForwardAgentId = DefaultInfoVar.ForwardAgentId;
            set DeliveryLeadtime = DefaultInfoVar.DeliveryLeadtime;
            set PickingLeadtime = DefaultInfoVar.PickingLeadtime;
            set ExtTransportCalendarId = DefaultInfoVar.ExtTransportCalendarId;
            set FreightMapId = DefaultInfoVar.FreightMapId;
            set ZoneId = DefaultInfoVar.ZoneId;
            set ShipmentType = DefaultInfoVar.ShipmentType;
            set ShipmentCreation = DefaultInfoVar.ShipmentCreation;
            if [WantedDeliveryDate != null] {
               set WantedDeliveryDate = DefaultInfoVar.WantedDeliveryDate;
            }
            call GetActiveFreightPriceListNo(Contract, ShipViaCode, FreightMapId, ForwardAgentId, UsePriceInclTax, VendorNo) into FreightPriceListNo;
         }
         else {
            if [ShipViaCode != original.ShipViaCode] {
               set ShipViaCodeChangedVar = "TRUE";
            }
            else {
               set ShipViaCodeChangedVar = "FALSE";
            }
            call GetShipViaDependants(OrderNo, Contract, CustomerNo, ShipAddrNo, AddrFlag, ShipViaCode, ShipViaCodeChangedVar, VendorNo, DeliveryTerms, DelTermsLocation, ForwardAgentId, ShipmentType, RouteId, DeliveryLeadtime, PickingLeadtime) into ShipViaDependantsVar;

            set RouteId = ShipViaDependantsVar.RouteId;
            set DeliveryLeadtime = ShipViaDependantsVar.DeliveryLeadtime;
            set ExtTransportCalendarId = ShipViaDependantsVar.ExtTransportCalendarId;
            set ZoneId = ShipViaDependantsVar.ZoneId;
            set PickingLeadtime = ShipViaDependantsVar.PickingLeadtime;
            set ShipmentType = ShipViaDependantsVar.ShipmentType;
            set ForwardAgentId = ShipViaDependantsVar.ForwardAgentId;
            set FreightMapId = ShipViaDependantsVar.FreightMapId;
            set DeliveryTerms = ShipViaDependantsVar.DeliveryTerms;
            set DelTermsLocation = ShipViaDependantsVar.DelTermsLocation;
            set ShipmentCreation = ShipViaDependantsVar.ShipmentCreation;

            call GetActiveFreightPriceListNo(Contract, ShipViaCode, FreightMapId, ForwardAgentId, UsePriceInclTax, VendorNo) into FreightPriceListNo;
         }
      }
      else {
         set FreightMapId = null;
         set ZoneId = null;
         set FreightPriceListNo = null;
         set ExtTransportCalendarId = null;
      }
      super;
   }
}

command OrderAddressCommand for CustomerOrder {
   label = "Single Occurrence Address";
   execute {
      dialog SingleOccuranceAddressDialog(OrderNo, Company, CustomerNo, ShipAddrNo, AddrFlag) {
         when CANCEL {
            exit;
         }
      }
   }
}

command ReleaseOrderCommand for CustomerOrder {
   label = "Release";
   enabled = [substring(AllowedOperations, 0, 1) != "*"];

   variable ValuesForReleaseVar Structure(ValuesForReleaseStructure);

   execute {

      call GetValuesForRelease(CustomerNo, Company) into ValuesForReleaseVar;
      if [ValuesForReleaseVar.ProceedOrder = "FALSE"] {
         error("The order cannot be released when there are order lines that are blocked due to the export license status being either in the Planned, Denied or Blocked for Usage status.");
         exit;
      }
      if [ValuesForReleaseVar.DemandCode = "DO"] {
         error("Cannot release Customer Orders connected to Distribution Orders.");
         exit;
      }

      confirm("The order will be released.") {
         when OK {
            if [TaxCalcMethod != "NOT_USED"] {
               call RefreshTaxOnCoRelease();
            }
            if [ValuesForReleaseVar.CustomerMinSalesAmount != null and ValuesForReleaseVar.CustomerMinSalesAmount > OrderAmountRef.TotalAmountBase] {
               confirm("The minimum sales amount for customer ${CustomerNo} is ${ValuesForReleaseVar.CustomerMinSalesAmount} ${CompanyCurrencyCode}.") {
                  when CANCEL {
                     exit;
                  }
               }
            }
            if [ValuesForReleaseVar.SourcedLines = "FALSE"] {
               confirm("Order lines exist that have not yet been completely sourced - Supply Code is 'Not Decided' - would you like to continue with order release?") {
                  when CANCEL {
                     exit;
                  }
               }
            }
            if [ValuesForReleaseVar.UnutilizedDealExist = "TRUE"] {
               confirm("Unutilized sales promotion deal(s) exist, can be analyzed via operations menu Calculate and View Sales Promotions. Do you want to release without analyzing?") {
                  when CANCEL {
                     exit;
                  }
               }
            }
            if [ValuesForReleaseVar.LicenseConnected = 1] {
               // User has override license connection authority. So raise the question.
               confirm("There are order line(s) which are not connected to an export license. Do you want to proceed?") {
                  when CANCEL {
                     exit;
                  }
               }
            }
            if [ValuesForReleaseVar.LicenseConnected = 2] {
               // There are mix of export controlled and non-export controlled CO lines. So raise the question to exclude export controlled CO lines which are not license connected.
               confirm("Customer order lines which are not connected to an export license will not be included in the created pick list. Do you want to proceed?") {
                  when CANCEL {
                     exit;
                  }
               }
            }
            if [ValuesForReleaseVar.LicenseConnected = 3] {
               // Only have export controlled lines. So need to connect license before proceeding.
               error("Export Licenses must be connected to order line(s) to proceed, please use the Find and Connect License.");
               exit;
            }
            call ReleaseOrder(CustomerNo, Company);
         }
      }
   }
}

command CancelOrderCommand for CustomerOrder {
   label = "Cancel";
   enabled = [substring(AllowedOperations, 11, 1) != "*"];
   variable OrderSelectionVar
      {
      type = Text;
   }
   bulkexecute {
      stringify(records, "ORDER_NO=${OrderNo}^ORDER_CODE=${OrderCode}^CUSTOMER_NO=${CustomerNo}^", JSON) into OrderSelectionVar;
      assistant CancelCustomerOrder.CancelCustomerOrderAssistant(OrderSelectionVar, "CO", "CO", "Cancel Customer Order", "FALSE") {
         when OK {
            exit OK;
         }
      }
   }
}

command CloseOrderCommand for CustomerOrder {
   label = "Close Order";
   enabled = [substring(AllowedOperations, 12, 1) != "*"];
   variable OrderSelectionVar {
      type = Text;
   }

   bulkexecute {
      stringify(records, "ORDER_NO=${OrderNo}^", JSON) into OrderSelectionVar;
      assistant CloseCustomerOrder.CloseCustomerOrderAssistant(OrderSelectionVar, "CO", "Close Order") {
         when OK {
            exit OK;
         }
      }
   }
}

command PrintOrderConfirmationCommand for CustomerOrder {
   label = "Print Order Confirmation";
   enabled = [substring(AllowedOperations, 2, 1) != "*"];
   variable ResultKeyVar {
      type = Text;
   }
   execute {
      confirm("Order confirmation will be printed.") {
         when OK {

            if [OrderConfDb] {
               info("This order acknowledgement has already been printed");
               call PrintResultKey("CUSTOMER_ORDER_CONF_REP") into ResultKeyVar;
               printdialog ResultKeyVar;
               call OrderUsesStageBilling(OrderNo) into OrderUsesStageBillingVar;
               if [OrderUsesStageBillingVar] {
                  call PrintResultKey("ORDER_STAGED_BILLING_REP") into ResultKeyVar;
                  printdialog ResultKeyVar;
               }
            }
            else {
               call PrintResultKey("CUSTOMER_ORDER_CONF_REP") into ResultKeyVar;
               printdialog ResultKeyVar;
               call OrderUsesStageBilling(OrderNo) into OrderUsesStageBillingVar;
               if [OrderUsesStageBillingVar] {
                  call PrintResultKey("ORDER_STAGED_BILLING_REP") into ResultKeyVar;
                  printdialog ResultKeyVar;
               }
               call ProceedAfterPrintConf() {
                  when FAIL {
                     error("The rest of the order flow could not be successfully carried out after printing the order confirmation. Please proceed manually.");
                  }
               }
            }
         }
         when CANCEL {
            exit;
         }
      }
   }
}

command PrintProFormaInvoiceCommand for CustomerOrder {
   label = "Print Pro Forma Invoice";
   enabled = [Objstate != "Cancelled" and Objstate != "Invoiced"];
   variable ResultKeyVar {
      type = Text;
   }
   variable OrderUsesStageBillingVar Boolean;
   execute {
      confirm("Pro Forma Invoice will be printed.") {
         when OK {
            call PrintResultKey("PROFORMA_INVOICE_REP") into ResultKeyVar;
            printdialog ResultKeyVar;
            call OrderUsesStageBilling(OrderNo) into OrderUsesStageBillingVar;
            if [OrderUsesStageBillingVar] {
               call PrintResultKey("ORDER_STAGED_BILLING_REP") into ResultKeyVar;
               printdialog ResultKeyVar;
            }
         }
         when CANCEL {
            info("Pro Forma Invoice was not printed.");
         }
      }
   }
}

command SendOrderConfirmationCommand for CustomerOrder {
   label = "Send Order Confirmation";
   -- check enablefunction in the command definition too.
   enabled = [substring(AllowedOperations, 2, 1) != "*"];

   variable MessageTypeConstVar {
      type = Text;
   }
   execute {
      set MessageTypeConstVar = "MSGTYPE_Confirm";
      dialog CustomerOrderTransferMessageDialog(OrderNo, CustomerNo, CustomerName, null, MessageTypeConstVar)
         {
         when OK {
            exit;
         }
         when CANCEL {
            exit;
         }
      }
   }
}

command EmailOrderConfirmationCommand for CustomerOrder {
   label = "E-mail Order Confirmation";
   enabled = [substring(AllowedOperations, 15, 1) != "*"];

   variable ReportIdVar {
      type = Text;
   }
   variable InEmailVar {
      type = Text;
   }
   variable OutEmailVar {
      type = Text;
   }
   variable ContactTypeVar {
      type = Text;
   }
   variable DialogTitleVar {
      type = Text;
   }
   execute {
      if [InternalRef != null] {
         @DynamicComponentDependency PURCH
         call GetIntEmail(Company, InternalRef, InternalPoNo) into InEmailVar;
      }
      if [InEmailVar = null] {
         set ContactTypeVar = "External";
         call GetExtEmail(CustomerNo, CustRef, BillAddrNo) into InEmailVar;
      }
      else {
         set ContactTypeVar = "Internal";
      }
      set DialogTitleVar = "E-mail Order Confirmation";
      dialog CustomerOrderEmailDialog(OrderNo, CustomerNo, Contract, InEmailVar, CustRef, InternalRef, ContactTypeVar, ReportIdVar, DialogTitleVar) into(OutEmailVar) {
         when OK {
            set ReportIdVar = "CUSTOMER_ORDER_CONF_REP";
            call EmailCustomerOrder(CustRef, Contract, OutEmailVar, CustomerNo, ReportIdVar);
         }
         when CANCEL {
            exit;
         }
      }
   }
}

command EmailProFormaInvoiceCommand for CustomerOrder {
   label = "E-mail Pro Forma Invoice";
   enabled = [substring(AllowedOperations, 16, 1) != "*"];

   variable ReportIdVar {
      type = Text;
   }
   variable InEmailVar {
      type = Text;
   }
   variable OutEmailVar {
      type = Text;
   }
   variable ContactTypeVar {
      type = Text;
   }
   variable DialogTitleVar {
      type = Text;
   }
   execute {
      if [InternalRef != null] {
         @DynamicComponentDependency PURCH
         call GetIntEmail(Company, InternalRef, InternalPoNo) into InEmailVar;
      }
      if [InEmailVar = null] {
         set ContactTypeVar = "External";
         call GetExtEmail(CustomerNo, CustRef, BillAddrNo) into InEmailVar;
      }
      else {
         set ContactTypeVar = "Internal";
      }
      set DialogTitleVar = "E-mail Pro Forma Invoice";
      dialog CustomerOrderEmailDialog(OrderNo, CustomerNo, Contract, InEmailVar, CustRef, InternalRef, ContactTypeVar, ReportIdVar, DialogTitleVar) into(OutEmailVar) {
         when OK {
            set ReportIdVar = "PROFORMA_INVOICE_REP";
            call EmailCustomerOrder(CustRef, Contract, OutEmailVar, CustomerNo, ReportIdVar);
         }
         when CANCEL {
            exit;
         }
      }
   }
}

command CalculateGroupDiscountCommand for CustomerOrder {
   label = "Calculate Discount";
   enabled = [true];
   execute {
      confirm("Do you want to calculate group discount?") {
         when OK {
            call CalculateOrderDiscount() {
               when FAIL {
                  warning("Discount bonus has not been calculated.");
               }
            }
         }
         when CANCEL {
            exit;
         }
      }
   }
}

command CalculateConsolidateFreightCommand for CustomerOrder {
   label = "Calculate/Consolidate Freight";
   enabled = [Objstate in("Planned", "Released", "Reserved", "Picked")];
   execute {
      call CalculateConsolidateCharges();
   }
}
command CalculateEarliestDeliveryDatCommand for CustomerOrder {
   label = "Calculate Earliest Delivery Date";
   enabled = [Objstate in("Planned", "Released", "Reserved", "Picked")];
   variable OrderReplicationVar       Structure(OrderReplicationStructure);
   variable AllowSendChangeRequestVar Boolean;
   variable ReplicateVar              Text;
   execute {
      call CheckOrderReplication(OrderNo) into OrderReplicationVar;
      if [OrderReplicationVar.PeggingExist = "TRUE"] {
         if [OrderReplicationVar.AllowSendChange = "TRUE"] {
            set AllowSendChangeRequestVar = true;
         }
         else {
            set AllowSendChangeRequestVar = false;
         }
         set PeggingExist = DataExistVar.PeggingExist;
         dialog ReplicateOrderChangesDialog(AllowSendChangeRequestVar, AllowSendChangeRequestVar) into(SendChangeRequestVar, ReplicateVar) {
            when CANCEL {
               exit CANCEL;
            }
            when OK {
               set ReplicateChanges = ReplicateVar;
            }
         }
      }

      call CalculateEarliestDeliveryDate(ReplicateChanges);
   }
}

@Override
command BulkValidateTaxIdNumberCommand {
   enabled = [TaxIdNo != null];
   bulkexecute {
      stringify(records, "${keyref}TAX_ID_NUMBER=${TaxIdNo}^COUNTRY_CODE=${DeliveryCountryCode}^TAX_ID_TYPE=${TaxIdType}^;") into TaxIdNumberSelectionVar;
      set ProjectionNameVar = "CustomerOrderHandling";
      super;
   }
}

command ManualCreditCheckCommand for CustomerOrder {
   label = "Manual Credit Check";
   variable TempStruct Structure(GetCreditCheckOutputStruct);
   variable MsgTypeVar Text;
   variable InfoVar Text;
   variable BlockreasonVar Text;
   -- check enablefunction in command definition
   enabled = [not(Objstate in("Delivered", "Cancelled", "Invoiced"))];
   execute {
      call ManualCreditCheck(Info, MessageType, BlockReason)into TempStruct;
      set MsgTypeVar = TempStruct.MsgTypes;
      set InfoVar = TempStruct.InfoMsgs;
      set BlockreasonVar = TempStruct.BlockReason;
      if[MsgTypeVar = "InfoMessage"] {
         messagebox("",
         information, "${InfoVar}") {
            when "OK" {
               exit;
            }
         }
      }
      if[MsgTypeVar = "Question"] {
         messagebox("",
         question, "${InfoVar}") {
            when "Yes" {
               call CreditCheckOrder(CheckingState);
            }
            when "No" {
               call ManualCreditCheckHist("NO", ReleasedFromCreditCheck, "FALSE");
            }
         }
      }
      if[MsgTypeVar = "QuestionBlockRelease"] {
         messagebox("",
         question, "${InfoVar}") {
            when "Yes" {
               call ManualCreditCheckHist("OK", ReleasedFromCreditCheck, "TRUE");
            }
            when "No" {
               call ManualCreditCheckHist("OK", ReleasedFromCreditCheck, "FALSE");
            }
         }
      }
   }
}

command StagedBillingTemplateCommand for CustomerOrder {
   label = "Enter Staged Billing Template";
   enabled = [AdvancePrepaymInvExists = true or ConfirmDeliveriesDb = false];
   execute {
      assistant StagedBillingTemplate.StagedBillingTemplateAssistant(OrderNo) {
         when CANCEL {
            exit CANCEL;
         }
      }
   }
}

command EnterPrePostingCommand for CustomerOrder {
   label = "Enter Pre Posting";
   enabled = [PreAccountingId != null];

   variable SourceIdentifierVar Text;
   execute {
      set SourceIdentifierVar = "for Customer Order ${OrderNo}" {
         translatable = true;
      }
      assistant PrepostingWithSource.PrePostingWithSourceAssistant("M103", PreAccountingId, Contract, false, SourceIdentifierVar) {
         when OK {
            exit OK;
         }
      }
   }
}

command FetchExternalTaxCommand for CustomerOrder {
   label = "Fetch External Tax";
   enabled = [not(Objstate in("Cancelled", "Invoiced")) and TaxCalcMethod in("AVALARA_SALES_TAX", "AVALARA_TAX_BRAZIL")];
   execute {
      call FetchExternalTax();
   }
}

@DynamicComponentDependency WO
command EnterServiceRequestCommand for CustomerOrder {
   label = "Service Request";
   -- check enablefunction CheckServiceRequestNotCreated
   enabled = [Objstate != "Cancelled" and Objstate != "Invoiced"];
   execute {
      navigate "assistant/CreateServiceRequest/CreateServiceRequestAssistant?$action=SetAttrForService{OrderNoNew: $[OrderNo]}";
   }
}

command FreightInfoCommand for CustomerOrder {
   label = "Freight Price List";
   enabled = [FreightPriceListNo != null];
   execute {
      if [VendorNo = null] {
         navigate "page/FreightPriceList/FormForCo?$filter=Company eq $[Company] and PriceListNo eq $[FreightPriceListNo]";
      }
      else {
         navigate "page/DirectDeliveryFreightPriceList/Form?$filter=PriceListNo eq $[FreightPriceListNo] and SupplierId eq $[VendorNo]";
      }
   }
}

command ManuallyBlockOrderCommand for CustomerOrder {
   label = "Manually Block Order";
   enabled = [Objstate in("Planned", "Released", "Reserved", "Picked", "PartiallyDelivered")];
   variable BlockReasonVar {
      type = Text;
   }
   variable InfoVar {
      type = Text;
   }
   execute {
      dialog BlockCustomerOrderDialog into(BlockReasonVar) {
         when OK {
            call ManualBlock(BlockReasonVar) into InfoVar;
            if [InfoVar != null and InfoVar != ""] {
               alert("${InfoVar}");
            }
         }
         when CANCEL {
            exit;
         }
      }
   }
}

command BlockedInfoCommand for CustomerOrder {
   label = "Blocked Info";
   enabled = [Objstate = "Blocked"];
   execute {
      navigate "page/HandleBlockedCustomerOrders/List?$filter=OrderNo eq $[OrderNo]";
   }
}

command CreateAdvanceInvoiceCommand for CustomerOrder {
   label = "Create Advance Invoice";
   -- check conditions in the enable function too.
   enabled = [not(Objstate in("Delivered", "Cancelled", "Invoiced")) and JinsuiInvoiceDb != "TRUE" and(OrderAmountRef.TotalAmountBase > 0)];
   variable AllowWithDelivConfDbVar Text;
   variable BaseForAdvInvoiceVar Text;
   variable CustInvoiceTypeVar Text;
   execute {
      call GetAllowWithDelivConfDb(Company) into AllowWithDelivConfDbVar;
      if [AllowWithDelivConfDbVar = "FALSE" and ConfirmDeliveriesDb = true] {
         info("The customer order has requested to confirm deliveries. Company ${Company} does not allow using delivery confirmation for advance invoices.");
      }
      else {
         call GetBaseForAdvInvoice(Company) into BaseForAdvInvoiceVar;
         if [UsePriceInclTax = true and(BaseForAdvInvoiceVar in("NET AMOUNT", "NET AMOUNT WITH CHARGES"))] {
            warning("Price including tax cannot be used with the net amount or the net amount with charge as base for an advance invoice. Please select the gross amount or the gross amount with charges as base for the advance invoice on the Company / Distribution / Order tab.");
         }
         else {
            call GetCustInvoiceTypeDb(CustomerNo) into CustInvoiceTypeVar;
            if [CustInvoiceTypeVar = "C"] {
               messagebox("", question, "The Customer ${CustomerNo} has the collective invoice functionality activated. By creating an advance invoice, the order will be excluded from the collective invoice. Do you want to proceed?") {
                  when "Yes" {
                     assistant CreateAdvancePaymentInvoice.CreateAdvancePaymentInvoiceAssistant(OrderNo) {
                        when OK {
                           exit OK;
                        }
                     }
                  }
                  when "No" {
                     exit;
                  }
               }
            }
            else {
               assistant CreateAdvancePaymentInvoice.CreateAdvancePaymentInvoiceAssistant(OrderNo) {
                  when OK {
                     exit OK;
                  }
               }
            }
         }
      }
   }
}

command HandlePrepaymentBasedInvoiceCommand for CustomerOrder {
   label = "Handle Prepayment Based Invoice";
   -- refer enablefunction for the additional enabling conditions
   enabled = [OrderAmountRef.TotalGrossAmountCurr > 0 and TaxCalcMethod = "NOT_USED"];
   execute {
      navigate "page/HandlePrepaymentBasedInvoice/Form?$filter=OrderNo eq $[OrderNo]";
   }
}

command InvoiceInfoCommand for CustomerOrder {
   label = "Invoice Info";
   execute {
      navigate "page/CustomerOrderInvoiceLines/List?$filter=OrderNo eq $[OrderNo]";
   }
}

command CustomerOrderHistoryCommand for CustomerOrder {
   label = "Order History";
   enabled = [true];
   execute {
      assistant CustomerOrderHistoryAssistant(OrderNo) {
         when CANCEL {
            exit CANCEL;
         }
      }
   }
}

command ShipmentLinesCommand for CustomerOrder {
   label = "Shipment Lines";
   enabled = [ShipmentConnectedLinesExist = 1];
   execute {
      navigate "page/ShipmentLines/List?$filter=SourceRef1 eq $[OrderNo]";
   }
}

@DynamicComponentDependency WO
command ConnectedWorkOrdersCommand for CustomerOrder {
   label = "Connected Work Orders";
   enabled = [ExternalRef != "FSM"];
   execute {
      navigate "page/ConnectedWorkOrders/List?$filter=CustOrderNo eq $[OrderNo]";
   }
}

@DynamicComponentDependency CONMGT
command SalesContractDetailsCommand for CustomerOrder {
   label = "Sales Contract Details";
   enabled = [SalesContractNo != null];
   execute {
      navigate "page/SalesContract/Form?$filter=ContractNo eq $[SalesContractNo]";
   }
}

command CalculateSalesPromotionsCommand for CustomerOrder {
   variable UnutilizedDealExistVar Text;
   label = "Calculate";
   -- check enablefuntion EnableSalesPromotionCommand for other conditions
   enabled = [ExternalRef != "FSM"];
   variable PromoExistsVar Boolean;

   execute {
      call CheckPromoExists(OrderNo) into PromoExistsVar;

      if[Objstate != "Planned" and PromoExistsVar] {
         messagebox("",
         question, "Sales Promotion previously calculated. Do you want to re-calculate?") {
            when "Yes" {
               set UnutilizedDealExistVar = "FALSE";
            }
            when "No" {
               exit CANCEL;
            }
         }
      }
      call CalculateOrderPromotion() into UnutilizedDealExistVar {
         when FAIL {
            warning("Sales Promotion has not been calculated.");
         }
      }
      if[UnutilizedDealExistVar = "TRUE"] {
         alert("Unutilized sales promotion deal(s) exist, can be analyzed via operations menu Calculate and View Sales Promotions");
      }
   }
}

command ViewSalesPromotionsCommand for CustomerOrder {
   label = "Calculate and View";
   execute {
      if [Objstate = "Planned"] {
         call CalculateOrderPromotion();
      }
      navigate "page/CalculatedSalesPromotionDealsPerOrder/Form?$filter=OrderNo eq $[OrderNo]";
   }
}

command ClearSalesPromotionsCommand for CustomerOrder {
   label = "Clear";
   execute {
      messagebox("", question, "Do you really want to clear all Sales Promotions connected to this Customer Order?") {
         when "Yes" {
            call ClearSalesPromotion();
         }
         when "No" {
            exit;
         }
      }
   }
}

command UpdateCalculatedCommissionsCommand for CustomerOrder {
   label = "Update Calculated Commissions";
   enabled = [ExternalRef != "FSM" and Objstate != "Cancelled"];

   variable InfoVar {
      type = Text;
   }
   execute {
      call CalculateCommissions(0) into InfoVar;
      if [InfoVar != null and InfoVar != ""] {
         alert("${InfoVar}");
      }
   }
}
command UpdateAllCommissionsCommand for CustomerOrder {
   label = "Update All Commissions";
   enabled = [Objstate != "Cancelled"];

   variable InfoVar {
      type = Text;
   }
   execute {
      confirm("Do you want to overwrite the manually changed commissions?") {
         when OK {
            call CalculateCommissions(1) into InfoVar;
            if [InfoVar != null and InfoVar != ""] {
               alert("${InfoVar}");
            }
         }
         when CANCEL {
            exit;
         }
      }
   }
}

command ViewEditReturnMaterialAuthorizationCommand for CustomerOrder {
   label = "View/Edit";
   enabled = [(substring(AllowedOperations, 17, 1) != "*") and(substring(AllowedOperations, 19, 1) != "*")];

   execute {
      navigate "page/ReturnMaterialAuthorizationLines/List?$filter=OrderNo eq $[OrderNo]";
   }
}

command CreateProjectCommand for CustomerOrder {
   label = "Create Project";
   -- check enablefunction CheckAnyLineNotProjConnected
   enabled = [Objstate = "Planned" and ProjectId = null];
   variable FromCommand {
      type = Boolean;
   }
   variable CreateAndCopy {
      type = Boolean;
   }
   variable VarPageType {
      type = Text;
   }

   execute {
      set FromCommand = true;
      set CreateAndCopy = true;
      set VarPageType = "Customer Order";
      navigate "assistant/CreateCopyProject/CreateCopyProjectAssistant?$action=InitProjectNavigation
               {
                  ProjectId: $[ProjectId],
                  FromCommand:$[FromCommand],
                  CreateCopy:$[CreateAndCopy],
                  VarCompany:$[Company],
                  VarSite:$[Contract],
                  VarOrderNo:$[OrderNo],
                  PageType: $[VarPageType],
                  VarCustomerId: $[CustomerNo]
      }";
   }
}

command ProjectDetailsCommand for CustomerOrder {
   label = "Project Details";
   enabled = [ProjectId != null];
   execute {
      navigate "page/ProjectDefinition/Form?$filter=ProjectId eq $[ProjectId]";
   }
}

command CustomerOrderTemplateCommand for CustomerOrder {
   label = "Create Lines from Template";
   enabled = [(OrderNo != null) and(Objstate != "Delivered" and Objstate != "Invoiced" and Objstate != "Cancelled")];
   execute {
      assistant CreateSalesLinesFromTemplate.CreateSqLinesOrCoLinesFromTemplateAssistant(CustomerNo, CustomerName, Contract, null, OrderNo) {
         when CANCEL {
            exit CANCEL;
         }
      }
   }
}

command CopyCustomerOrderCommand for CustomerOrder {
   label = "Copy Order";
   enabled = [true];
   execute {
      navigate "assistant/CopyCustomerOrder/Assistant?$action=SetupCustomerOrderInfo{FromOrderNoStr:$[OrderNo]}";
   }
}

command DocumentTextCommand for CustomerOrder {
   label = "Document Text";
   enabled = [NoteId != null];
   variable LabelTextVar {
      type = Text;
   }
   execute {
      set LabelTextVar = "for Customer Order - ${OrderNo}" {
         translatable = true;
      }
      assistant DocumentText.DocumentText(NoteId, LabelTextVar) {
         when OK {
            exit OK;
         }
      }
   }
}

@DynamicComponentDependency RMCOM
command AccessCommand for CustomerOrder {
   label = "Access Details";
   variable PossibleToShareVar Boolean;
   variable ParentObjectIdVar Text;
   variable ParentFilterNameVar Text;
   variable ParentDetailsVar {
      type = Structure(RmAccGivenPrivAllParentDetailsStructure);
   }

   execute {
      call PossibleToShare(SourceRef, OrderNo) into PossibleToShareVar;
      call GetRmAccGivenPrivAllParentDetails(SourceRef, OrderNo) into ParentDetailsVar;
      set ParentObjectIdVar = ParentDetailsVar.ParentObjectId;
      set ParentFilterNameVar = ParentDetailsVar.ParentFilterName;

      navigate "page/RelationshipManagementAccess/Form?searchcontext=SourceRef:$[SourceRef],SourceRefId:$[OrderNo],PossibleToShare:$[PossibleToShareVar],SourceName:Customer Order,ParentSourceRef:$[ParentFilterNameVar],ParentSourceRefId:$[ParentObjectIdVar] ";
   }
}


command ValidateAgreementIdCommand for CustomerOrder clone ValidateAddressNoCommand {
   execute {
      set ValidatingCustomerVar = false;
      set DeliveryAddressVar = true;
      set DocumentAddressVar = false;
      super;
   }
}

command ValidatePaymentTermIdCommand for CustomerOrder {
   execute {
      if [PayTermIdRef != original.PayTermIdRef] {
         call GetPaymentTermIdDescription(Company, PayTermId) into PaymentTermDescription;
      }
   }
}

--------------------------------- SELECTORS ---------------------------------

@Override
@DynamicComponentDependency CONMGT
selector ReferenceConItemCustOrderLovSelector for ConItemCustOrderLov {
   static ContractNo;
   static ContractName;
}

---------------------------------- GROUPS -----------------------------------

group CustomerOrderGroup for CustomerOrder {
   label = "";

   field OrderNo {
      size = Small;
   }
   lov CustomerNoRef with ReferenceCustOrdCust6Selector {
      contactwidget {
         enabled = [CustomerNo != null];
         source = Customer;
      }
      visible = [Company != null];
      description = CustomerName;
      details = "page/Customer/Form?$filter=CustomerId eq $[CustomerNo]";
      search = CustomerNo, Name;
      searchable = true;
      initialfocus = [true];
      validate command ValidateCustomerNoCommand;
   }

   lov CustomerNoWithoutCompanyRef with ReferenceCustOrdCust7Selector {
      contactwidget {
         enabled = [CustomerNo != null];
         source = Customer;
      }
      visible = [Company = null];
      description = CustomerName;
      details = "page/Customer/Form?$filter=CustomerId eq $[CustomerNo]";
      search = CustomerNo, Name;
      searchable = true;
      initialfocus = [true];
      validate command ValidateCustomerNoCommand;
   }
   field IsNewCustomer {
      label = "New Customer";
      size = Small;
      visible = [isNew and Contract != null];
      validate command ValidateNewCustomerNoCommand;
   }
   lov ContractRef with ReferenceUserAllowedSiteLovSelector {
      size = Small;
      validate command ValidateContractCommand;
   }
   field OrderIdRef {
      size = Small;
   }
   field WantedDeliveryDate {
      size = Small;
      validate command ValidateWantedDeliveryDateCommand;
   }
   lov CancelReasonRef with ReferenceOrderCancelReasonSelector {
      description = CancelReasonRef.ReasonDescription;
      visible = [Objstate = "Cancelled"];
      editable = [Objstate = "Cancelled"];
      size = Small;
   }
   lov BlockedReasonRef with ReferenceOrderBlockReasonLovSelector {
      freeinput = true;
      description = BlockedReasonRef.BlockReasonDescription;
      visible = [Objstate = "Blocked"];
      editable = [Objstate = "Blocked" and BlockedTypeDb in("MANUAL_BLOCKED", "NOT_BLOCKED")];
      size = Medium;

      validate command {
         variable SystemDefinedVar {
            type = Text;
         }
         execute {
            call BlockReasonValidate(BlockedReason) into SystemDefinedVar;
            if [SystemDefinedVar = "TRUE"] {
               error("You are not allowed to enter system defined block reasons.");
               set BlockReason = "";
               set BlockReasonDesc = "";
            }
         }
      }
   }
}

group CustomerOrderGeneralGroup for CustomerOrder {
   label = "";
   lov AuthorizeCodeRef with ReferenceOrderCoordinatorLovSelector {
      description = AuthorizeCodeRef.Name;
      contactwidget {
         enabled = [AuthorizeCode != null];
         source = Person;
      }
   }
   field CurrencyCodeRef {
      size = Small;
      validate command {
         execute {
            if [CurrencyCode != original.CurrencyCode] {
               call GetFirstValidAgreementId(CustomerNo, Contract, CurrencyCode) into AgreementId;
            }
         }
      }
   }
   field CustomerPoNo {
      size = Small;
      validate command ValidateReplicateValuesCommand;
   }
   field AdditionalDiscount {
      size = Small;
      editable = [Objstate != "Cancelled" and Objstate != "Closed"];
   }
   field Priority {
      size = Small;
   }
   lov CustRefRef with ReferenceCustInfoContactLovPubSelector using ReferenceFilter {
      description = CustRefName;
      freeinput = [true];
      details = "page/Customer/AddressInfo?$filter=CustomerId eq $[CustomerNo] ";
      validate command ValidateCustomerReferenceCommand;
   }
   lov AgreementIdRef with ReferenceCustomerAgreementLovSelector using AgreementIdFilter(Contract, CurrencyCode, CustomerNo) {
      preview = CustomerAgreementLovCard;
      description = AgreementDescription;
      validate command ValidateAgreementIdCommand;
   }
   lov LanguageCodeRef with ReferenceApplicationLanguageSelector {
      description = LanguageCodeRef.Description;
      size = Small;
      validate command ValidateReplicateValuesCommand;
   }
   -- gelr: outgoing_fiscal_note, begin
   field FinalConsumerDb {
      size = Small;
      visible = ["OUTGOING_FISCAL_NOTE" in EnabledLccParams];
   }
   -- gelr: outgoing_fiscal_note, end
   lov SalesmanCodeRef with ReferenceSalesPartSalesmanLovSelector {
      description = SalesPartSalesmanName;
      contactwidget {
         enabled = [SalesmanCode != null];
         source = Person;
      }
   }
   lov RebateCustomerRef with ReferenceCustOrdCust2Selector {
      description = RebateCustomerName;
      contactwidget {
         enabled = [RebateCustomer != null];
         source = Customer;
      }
      validate command {
         variable PayerInfoVar {
            type = Structure(PayerInfoStructure);
         }
         execute {
            if [CustomerNoPay = null] {
               set CustomerNoPayAddrNo = null;
               set CustomerNoPayRef = null;
               call GetPayerInfo(Company, CustomerNo, CustomerNoPay) into PayerInfoVar;
               set PayTermId = PayerInfoVar.PaymentTerm;
            }
            else {
               call GetPayerInfo(Company, CustomerNo, CustomerNoPay) into PayerInfoVar;
               set PayTermId = PayerInfoVar.PaymentTerm;
               set CustomerNoPayAddrNo = PayerInfoVar.CustomerNoPayAddrNo;
               set CustomerNoPayRef = PayerInfoVar.CustomerNoPayRef;
               if [PayTermId = null] {
                  error("Payment terms have not been defined for the paying customer. Please choose another Payer.");
               }
            }
         }
      }
   }
   @DynamicComponentDependency RMCOM
   lov MainRepresentativeIdRef with ReferenceBusinessRepresentativeLovSelector {
      description = RepresentativeName;
      contactwidget {
         enabled = [MainRepresentativeId != null];
         source = Person;
      }
   }
   field RegionCodeRef {
      size = Small;
      validate command ValidateReplicateValuesCommand;
   }
   field DistrictCodeRef {
      size = Small;
      validate command ValidateReplicateValuesCommand;
   }
   field MarketCodeRef {
      size = Small;
   }
   lov ClassificationStandardRef with ReferenceCustomerAssortmentStructLovSelector {
      preview = CustomerAssortmentStructLovCard;
      size = Small;
   }
   field DateEntered {
      visible = [not isNew];
   }
   field LimitSalesToAssortmentsDb {
      size = Small;
      editable = [OverruleLimitSaleToAssort != null and OverruleLimitSaleToAssort = "TRUE"];
   }
   lov OrderAmountRef with ReferenceCustomerOrderAmountsSelector {
      label = "Order Net Weight";
      description = "${OrderAmountRef.OrderWeight}";
      size = Small;
      editable = [false];
      hidekey = [true];
      visible = [not isNew];
   }
   lov OrderAmountRef with ReferenceCustomerOrderAmountsSelector {
      label = "Order Volume";
      description = "${OrderAmountRef.OrderVolume}";
      size = Small;
      editable = [false];
      hidekey = [true];
      visible = [not isNew];
   }
   field DocumentText {
      size = Small;
   }
   field NoteText {
      multiline = true;
      size = Medium;
   }
   -- gelr:fr_service_code, begin
   lov ServiceCodeRef with ReferenceCustomerServiceCodeSelector {
      description = ServiceCodeRef.Description;
      visible = ["FR_SERVICE_CODE" in EnabledLccParams];
   }
   -- gelr:fr_service_code, end
}

group InvoiceInfoGroup for CustomerOrder {
   label = "Invoice";

   field TaxIdNo {
      size = Small;
      validate command {
         execute {
            if [TaxIdNo != original.TaxIdNo or TaxIdNo = null] {
               set TaxIdValidatedDate = null;
            }
         }
      }
   }
   field TaxIdValidatedDate {
      size = Small;
   }
   lov TaxLiabilityLovRef with ReferenceTaxLiabilityLovSelector using TaxLiabilityFilter(AddrFlag, DeliveryCountryCode, CustomerNo, ShipAddrNo) {
      size = Small;
   }

   lov PayTermIdRef with ReferencePaymentTermSelector {
      description = PaymentTermDescription;
      validate command ValidatePaymentTermIdCommand;
   }

   field PayTermBaseDate {
      size = Small;
   }
   lov CustomerNoPaymentRef with ReferenceCustOrdCust2Selector {
      description = CustomerNoPayName;
      contactwidget {
         enabled = [CustomerNoPay != null];
         source = Customer;
      }

      validate command {
         variable PayerInfoVar {
            type = Structure(PayerInfoStructure);
         }
         variable CustomerNoVar {
            type = Text;
         }
         variable AddrNoVar {
            type = Text;
         }
         variable TaxInfoVar {
            type = Structure(OrderTaxInfoStructure);
         }
         execute {
            if [CustomerNoPay = CustomerNo] {
               warning("Payer is same as the ordering customer.");
            }
            if [CustomerNoPay = null] {
               set CustomerNoPayAddrNo = null;
               set CustomerNoPayRef = null;
               call GetPayerInfo(Company, CustomerNo, CustomerNoPay) into PayerInfoVar;
               set PayTermId = PayerInfoVar.PaymentTerm;
            }
            else {
               call GetPayerInfo(Company, CustomerNo, CustomerNoPay) into PayerInfoVar;
               set PayTermId = PayerInfoVar.PaymentTerm;
               set CustomerNoPayAddrNo = PayerInfoVar.CustomerNoPayAddrNo;
               set CustomerNoPayRef = PayerInfoVar.CustomerNoPayRef;
               if [PayTermId = null] {
                  error("Payment terms have not been defined for the paying customer. Please choose another Payer.");
                  exit;
               }
            }
            if [CustomerNoPay = null] {
               set CustomerNoVar = CustomerNo;
               set AddrNoVar = BillAddrNo;
            }
            else {
               set CustomerNoVar = CustomerNoPay;
               set AddrNoVar = CustomerNoPayAddrNo;
            }
            call GetTaxInfo(CustomerNoVar, AddrNoVar, Company, SupplyCountry, DeliveryCountryCode, CustomerNoPay, CustomerNoPayAddrNo, CustomerNo, BillAddrNo, AddrFlag, ShipAddrNo) into TaxInfoVar;
            set TaxIdNo = TaxInfoVar.TaxIdNo;
            set TaxIdValidatedDate = TaxInfoVar.TaxIdValidatedDate;
         }
      }
   }
   field CustomerNoPayAddrNoRef {
      size = Small;
      editable = [CustomerNoPay != null];
      validate command {
         variable CustomerNoVar {
            type = Text;
         }
         variable AddrNoVar {
            type = Text;
         }
         variable TaxInfoVar {
            type = Structure(OrderTaxInfoStructure);
         }
         execute {
            if [CustomerNoPayAddrNo != original.CustomerNoPayAddrNo] {
               call GetCustomerNoPayReference(CustomerNoPay, CustomerNoPayAddrNo) into CustomerNoPayRef;
               if [CustomerNoPay = null] {
                  set CustomerNoVar = CustomerNo;
                  set AddrNoVar = BillAddrNo;
               }
               else {
                  set CustomerNoVar = CustomerNoPay;
                  set AddrNoVar = CustomerNoPayAddrNo;
               }
               call GetTaxInfo(CustomerNoVar, AddrNoVar, Company, SupplyCountry, DeliveryCountryCode, CustomerNoPay, CustomerNoPayAddrNo, CustomerNo, BillAddrNo, AddrFlag, ShipAddrNo) into TaxInfoVar;
               set TaxIdNo = TaxInfoVar.TaxIdNo;
               set TaxIdValidatedDate = TaxInfoVar.TaxIdValidatedDate;
            }
         }
      }

   }
   lov CustomerNoPayReferenceRef with ReferenceCustInfoContactLovPubSelector using ReferenceFilter {
      description = CustomerNoPayReferenceName;
      contactwidget {
         enabled = [CustomerNoPayRef != null];
         source = Customer;
      }
      freeinput = [true];
      editable = [CustomerNoPay != null];
   }
   field UsePriceInclTax {
      size = Small;
      validate command {
         execute {
            call GetActiveFreightPriceListNo(Contract, ShipViaCode, FreightMapId, ForwardAgentId, UsePriceInclTax, VendorNo) into FreightPriceListNo;
            if [UsePriceInclTax] {
               if [TaxCalcMethod != "NOT_USED"] {
                  error("Price including tax cannot be used when using an external tax system.");
                  set UsePriceInclTax = false;
               }
            }
         }
      }
   }
   field ProposedPrepaymentAmount {
      size = Small;
   }
   field AdvancePrepaymInvExists {
      size = Small;
      visible = [not isNew];
   }

   field SupplyCountry {
      size = Small;
      validate command {
         variable TaxInfoVar {
            type = Structure(OrderTaxInfoStructure);
         }
         variable CustomerNoVar {
            type = Text;
         }
         variable AddrNoVar {
            type = Text;
         }
         execute {
            if [SupplyCountry != original.SupplyCountry] {
               if [CustomerNoPay = null] {
                  set CustomerNoVar = CustomerNo;
                  set AddrNoVar = BillAddrNo;
               }
               else {
                  set CustomerNoVar = CustomerNoPay;
                  set AddrNoVar = CustomerNoPayAddrNo;
               }

               call GetTaxLiabilityInfo(CustomerNoVar, AddrNoVar, Company, SupplyCountry, DeliveryCountryCode, CustomerNoPay, CustomerNoPayAddrNo, CustomerNo, BillAddrNo, AddrFlag, ShipAddrNo) into TaxInfoVar;
               copy TaxInfoVar into this;

               if [TaxLiability = null] {
                  error("There is no Tax Liability defined for delivery address ${ShipAddrNo} and supply country ${SupplyCountry}.");
               }
            }
         }
      }
   }

   field FreeOfChgTaxPayParty {
      size = Small;
   }
   field CustomerBranch {
      size = Small;
      editable = [false];
   }
   field JinsuiInvoiceDb {
      size = Small;
   }
   lov CustomerTaxUsageTypeRef with ReferenceCustomerTaxUsageTypeSelector {
      description = CustomerTaxUsageTypeRef.Description;
   }
   -- gelr: invoice_reason, begin
   lov InvoiceReasonIdRef with ReferenceInvoiceReasonSelector {
      description = InvoiceReasonIdRef.InvoiceReason;
      visible = ["INVOICE_REASON" in EnabledLccParams];
   }
   -- gelr: invoice_reason, end
   -- gelr:alt_invoice_no_per_branch, begin
   lov ComponentARef with ReferenceOffInvNumCompTypeValSelector using FetchComponentA(Company) {
      label = "${ComponentAName}";
      filterlabel = "Component A";
      description = ComponentARef.Description;
      visible = ["ALT_INVOICE_NO_PER_BRANCH" in EnabledLccParams];
   }
   -- gelr:alt_invoice_no_per_branch, end
}
group DeliveryAddrGroup for CustomerOrder {
   label = "Delivery Address";
   visible = [AddrFlag = "No"];
   lov ShipAddrNoRef with ReferenceCustAddressShipLovSelector {
      size = Large;
      preview = CustAddressShipLovCard;
      description = DelAddrName;
      validate command ValidateDeliveryAddressCommand;
   }
   field AddrFlag {
      editable = [false];
      size = Small;
      enumerationtrue = "Yes";
      enumerationfalse = "No";
   }
   lov TaxFreeTaxCodeRef with ReferenceStatutoryFeeSelector {
      description = TaxFreeTaxCodeDescription;
      size = Small;
   }
}

group DocumentAddressGroup for CustomerOrder {
   label = "Document Address";
   lov BillAddrNoRef with ReferenceCustBillAddressLovSelector {
      size = Large;
      preview = CustBillAddressLovCard;
      description = BillAddrName;
      validate command ValidateDocumentAddressCommand;
   }
}

group OrderAmountsGroup for CustomerOrder {
   label = "Order Amounts";

   lov OrderAmountRef with ReferenceCustomerOrderAmountsSelector {
      label = "Total Net Amount/Base";
      description = "${OrderAmountRef.TotalAmountBase} ${CompanyCurrencyCode}";
      hidekey = [true];
      editable = [false];
      preview = TotalBaseAmountsCard;
      size = Small;
   }
   currency OrderAmountRef.TotalContributionBase(CompanyCurrencyCode) {
      label = "Total Contribution Margin/Base";
      size = Small;
   }
   field OrderAmountRef.TotalContributionPercent {
      label = "Contribution Margin(%)";
      size = Small;
   }
   lov OrderAmountRef with ReferenceCustomerOrderAmountsSelector {
      label = "Total Net Amount/Curr";
      description = "${OrderAmountRef.TotalAmountCurr} ${CurrencyCode}";
      hidekey = [true];
      editable = [false];
      preview = TotalCurrAmountsCard;
      size = Small;
   }
   lov OrderAmountRef with ReferenceCustomerOrderAmountsSelector {
      label = "Total Tax Amount/Curr";
      description = "${OrderAmountRef.ToatalTaxAmountCurr} ${CurrencyCode}";
      hidekey = [true];
      editable = [false];
      preview = ToatalTaxCurrAmountsCard;
      size = Small;
   }
   lov OrderAmountRef with ReferenceCustomerOrderAmountsSelector {
      label = "Total Gross Amount/Curr";
      description = "${OrderAmountRef.TotalGrossAmountCurr} ${CurrencyCode}";
      hidekey = [true];
      editable = [false];
      preview = TotalGrossCurrAmountsCard;
      size = Small;
   }
   field ChargesExist {
      showlabel = false;
      truelabel = "Charges Exist";
      falselabel = "No Charges Exist";
      visible = [ChargesExist];
      editable = [false];
      size = Small;
   }
}

group DeliverySettingsGroup for CustomerOrder {
   label = "Delivery Settings";
   @DynamicComponentDependency PURCH
   lov VendorNoRef with ReferenceValidSupplierLovSelector {
      preview = ValidSupplierLovCard;
      description = VendorName;
      contactwidget {
         enabled = [VendorNo != null];
         source = Supplier;
      }
      validate command {
         variable DeliveryInfoVar {
            type = Structure(DeliveryInfoStructure);
         }
         variable ShipmentCreationVar {
            type = Structure(ShipmentCreationStructure);
         }
         execute {
            if [VendorNo = null] {
               set ShipViaCode = null;
            }
            if [CustomerNo != null and Contract != null] {
               call GetDefaultDeliveryInformation(OrderNo, Contract, CustomerNo, ShipAddrNo, AddrFlag, AgreementId, VendorNo, ShipViaCode, DeliveryTerms, DelTermsLocation, UsePriceInclTax) into DeliveryInfoVar;

               set VendorName = DeliveryInfoVar.VendorName;
               set RouteId = DeliveryInfoVar.RouteId;
               set ForwardAgentId = DeliveryInfoVar.ForwardAgentId;
               set ShipViaCode = DeliveryInfoVar.ShipViaCode;
               set DeliveryTerms = DeliveryInfoVar.DeliveryTerms;
               set DelTermsLocation = DeliveryInfoVar.DelTermsLocation;
               set DeliveryLeadtime = DeliveryInfoVar.DeliveryLeadtime;
               set ExtTransportCalendarId = DeliveryInfoVar.ExtTransportCalendarId;
               set FreightMapId = DeliveryInfoVar.FreightMapId;
               set ZoneId = DeliveryInfoVar.ZoneId;
               set PickingLeadtime = DeliveryInfoVar.PickingLeadtime;
               set FreightPriceListNo = DeliveryInfoVar.FreightPriceListNo;
               set ShipmentType = DeliveryInfoVar.ShipmentType;
               call GetShipmentCreation(ShipmentType) into ShipmentCreationVar;
               set ShipmentCreation = ShipmentCreationVar.ShipmentCreation;
            }
         }
      }
   }
   lov ShipViaCodeRef with ReferenceMpccomShipViaSelector {
      description = ShipViaCodeRef.Description;
      validate command ValidatShipViaCodeCommand;
   }
   lov DeliveryTermsRef with ReferenceOrderDeliveryTermLovSelector {
      description = DeliveryTermsRef.Description;
      validate command ValidateDeliveryTermsCommand;
   }
   field DelTermsLocation {
      validate command ValidateReplicateValuesCommand;
   }
   lov RouteIdRef with ReferenceDeliveryRouteSelector {
      description = RouteIdRef.Description;
      validate command ValidateRouteIdCommand;
   }
   lov ForwardAgentIdRef with ReferenceForwarderInfoSelector {
      description = ForwardName;
      contactwidget {
         enabled = [ForwardAgentId != null];
         source = Person;
      }
      validate command ValidateForwardAgentIdCommand;
   }
   lov CustCalendarIdRef with ReferenceWorkTimeCalendarSelector {
      description = CustCalendarIdRef.Description;
      validate command ValidateReplicateValuesCommand;
   }
   lov ExtTransportCalendarIdRef with ReferenceWorkTimeCalendarSelector {
      description = ExtTransportCalendarIdRef.Description;
      validate command ValidateReplicateValuesCommand;
   }
   field BackorderOption {
      validate command ValidateReplicateValuesCommand;
   }
   field DeliveryLeadtime {
      size = Small;
      validate command ValidateReplicateValuesCommand;
   }
   field CustomsValueCurrencyRef {
      size = Small;
   }
   field IntrastatExempt {
      size = Small;
      enumerationtrue = "Exempt";
      enumerationfalse = "Include";
      truelabel = "Yes";
      falselabel = "No";
   }
   -- gelr: warehouse_journal, begin
   lov DeliveryReasonIdRef with ReferenceDeliveryReasonSelector {
      description = DeliveryReasonIdRef.Description;
      visible = ["WAREHOUSE_JOURNAL" in EnabledLccParams];
   }
   -- gelr: warehouse_journal, end
}

-- gelr:brazilian_specific_attributes, begin
group BrazilianSpecificAttributesGroup for CustomerOrder {
   label = "Brazilian Specific Attributes";

   lov BusinessTransactionIdRef with ReferenceOutboundBusinessTransactionIdSelector {
      description = BusinessTransactionIdRef.Description;
      editable = [Objstate = "Planned" or isNew];

   }
}
-- gelr:brazilian_specific_attributes, end

group ShipmentInfoGroup for CustomerOrder {
   label = "Shipment";

   lov ShipmentTypeRef with ShipmentTypeCoLovSelector {
      advancedview ShipmentTypeCoLovList;
      description = ShipmentTypeRef.Description;
      size = Large;
      validate command {
         variable ShipmentCreationVar {
            type = Structure(ShipmentCreationStructure);
         }
         execute {
            call GetShipmentCreation(ShipmentType) into ShipmentCreationVar;
            set ShipmentCreation = ShipmentCreationVar.ShipmentCreation;
         }
      }
   }
   field ShipmentCreation;
}

group FreightInfoGroup for CustomerOrder {
   collapsed = [true];
   label = "Freight";
   lov FreightMapIdRef with ReferenceFreightMapSelector {
      description = FreightMapIdRef.Description;
      validate command {
         execute {
            if [FreightMapId != original.FreightMapId] {
               set ZoneId = "";
               call GetActiveFreightPriceListNo(Contract, ShipViaCode, FreightMapId, ForwardAgentId, UsePriceInclTax, VendorNo) into FreightPriceListNo;
            }
         }
      }
   }
   lov ZoneIdRef with ReferenceFreightZoneSelector {
      description = FreightZoneDescription;
      size = Small;
   }
   field FreightPriceListNo {
      size = Small;
      lovswitch {
         when [VendorNo != null] {
            lov FreightPriceListNoRef with ReferenceFreightPriceListLovSelector using  FreightPriceListFilterWithVendor(UsePriceInclTax, VendorNo) {
               description = FreightPriceListNoRef.Description;
            }
         }
         when [true] {
            lov FreightPriceListNoRef with ReferenceFreightPriceListLovSelector using  FreightPriceListFilterWithoutVendor(UsePriceInclTax) {
               description = FreightPriceListNoRef.Description;
            }
         }
      }
   }
   field FixDelivFreight {
      size = Small;
      editable = [ApplyFixDelivFreightDb and Objstate != "Cancelled" and Objstate != "Closed" and Objstate != "Delivered" and Objstate != "PartiallyDelivered"];
   }
   field CompanyCurrencyCode {
      size = Small;
      editable = [false];
   }
   field ApplyFixDelivFreightDb {
      size = Small;
      editable = [Objstate != "Cancelled" and Objstate != "Closed" and Objstate != "Delivered" and Objstate != "PartiallyDelivered" and Objstate != "Invoiced"];
      validate command {
         variable ShipmentConnectedLinesExistVar {
            type = Number;
         }
         variable FixDelivFreightVar {
            type = Structure(FixDelivFreightStructure);
         }
         execute {
            if [ApplyFixDelivFreightDb] {
               call CheckShipmentConnectedLinesExist(OrderNo) into ShipmentConnectedLinesExistVar;
               if [ShipmentConnectedLinesExistVar = 1] {
                  confirm("There are Shipment connected Order lines. Do you want to continue?") {
                     when OK {
                        call GetFixDelivFreight(FreightPriceListNo, FreightMapId, ZoneId, Company) into FixDelivFreightVar;
                        set FixDelivFreight = FixDelivFreightVar.FixDelivFreight;
                        set CompanyCurrencyCode = FixDelivFreightVar.CompanyCurrencyCode;
                     }
                     when CANCEL {
                        set ApplyFixDelivFreightDb = false;
                        set FixDelivFreight = null;
                        set CompanyCurrencyCode = null;
                     }
                  }
               }
               else {
                  call GetFixDelivFreight(FreightPriceListNo, FreightMapId, ZoneId, Company) into FixDelivFreightVar;
                  set FixDelivFreight = FixDelivFreightVar.FixDelivFreight;
                  set CompanyCurrencyCode = FixDelivFreightVar.CompanyCurrencyCode;
               }
            }
            else {
               set FixDelivFreight = null;
               set CompanyCurrencyCode = null;
            }
         }
      }
   }

   lov OrderAmountRef with ReferenceCustomerOrderAmountsSelector {
      label = "Tot Adj Gross Weight";
      description = "${OrderAmountRef.AdjustedWeightGrossInCharges}";
      editable = [false];
      hidekey = [true];
      visible = [not isNew];
      size = Small;
   }
   lov OrderAmountRef with ReferenceCustomerOrderAmountsSelector {
      label = "Tot Adj Volume";
      description = "${OrderAmountRef.AdjustedVolumeInCharges}";
      editable = [false];
      hidekey = [true];
      visible = [not isNew];
      size = Small;
   }
}

group DeliveryConfirmationGroup for CustomerOrder {
   label = "Delivery Confirmation";
   field ConfirmDeliveriesDb {
      size = Small;
      validate command {
         variable DelayCogsVar {
            type = Text;
         }
         execute {
            if [ConfirmDeliveriesDb = true] {
               -- Fetches the Delay COGS flag from Company - if Confirm Deliveries flag is checked
               call GetDelayCogsToDelivCon(Company) into DelayCogsVar;
               if [DelayCogsVar = "TRUE"] {
                  set DelayCogsToDelivConfDb = true;
               }
               else {
                  set DelayCogsToDelivConfDb = false;
               }
            }
            else {
               set DelayCogsToDelivConfDb = false;
            }
         }
      }
   }
   field CheckSalesGrpDelivConfDb {
      size = Small;
   }
   field DelayCogsToDelivConfDb {
      editable = [false];
   }
}

group OrderPickingGroup for CustomerOrder {
   label = "Order Picking";
   field UsePreShipDelNoteDb {
      size = Small;
   }
   field PickInventoryType {
      size = Medium;
      enumerationtrue = "ShipmentInventory";
      enumerationfalse = "OrdinaryInventory";
      truelabel = "Yes";
      falselabel = "No";
   }
   field PickingLeadtime {
      size = Small;
      validate command ValidateReplicateValuesCommand;
   }
}

group ReferenceGroup for CustomerOrder {
   label = "Originates From";
   visible = [not isNew and not(InternalPoNo = null and InternalRef = null and ExternalRef = null
   and QuotationNo = null and BusinessOpportunityNo = null and CaseId = null and TaskId = null
   and SmConnection = "NotConnected" and SchedulingConnection = "NotSchedulingOrder" and B2bOrderDb = false)];
   field InternalPoNo {
      size = Small;
      visible = [InternalPoNo != null];
   }
   field InternalRef {
      size = Small;
      visible = [InternalRef != null];
   }
   field ExternalRef {
      visible = [ExternalRef != null];
   }
   @DynamicComponentDependency CALLC
   field CcCaseLocalId {
      size = Small;
      label = "Case ID";
      visible = [CaseId != null];
   }
   @DynamicComponentDependency CALLC
   lov TaskIdRef with ReferenceCcCaseTaskHeaderSelector {
      size = Small;
      preview = CcCaseTaskHeaderCard;
      visible = [TaskId != null];
   }
   @DynamicComponentDependency CRM
   field BusinessOpportunityNoRef {
      size = Small;
      visible = [BusinessOpportunityNo != null];
   }
   lov QuotationNoRef with ReferenceOrderQuotationLovSelector {
      preview = OrderQuotationLovCard;
      size = Small;
      visible = [QuotationNo != null];
   }
   field SmConnection {
      size = Small;
      enumerationtrue = "Connected";
      enumerationfalse = "NotConnected";
      truelabel = "Yes";
      falselabel = "No";
      visible = [SmConnection = "Connected"];
   }
   field SchedulingConnection {
      size = Small;
      enumerationtrue = "SchedulingOrder";
      enumerationfalse = "NotSchedulingOrder";
      truelabel = "Yes";
      falselabel = "No";
      visible = [SchedulingConnection = "SchedulingOrder"];
   }
   field B2bOrderDb {
      size = Small;
      visible = [B2bOrderDb = true];
   }
}

group ProjectGroup for CustomerOrder {
   visible = [not isNew];
   label = "Project Reference";
   @DynamicComponentDependency PROJ
   lov ProjectIdRef with ReferenceProjectSiteLov2Selector using ProjectIdFilter(Contract) {
      preview = ProjectSiteLov2Card;
      size = Small;
      validate command {
         variable CurrencyRateTypeVar {
            type = Text;
         }
         execute {
            call GetCurrencyRateType(ProjectId, Company, CustomerNo) into CurrencyRateTypeVar;
            set CurrencyRateType = CurrencyRateTypeVar;
         }
      }
   }
   lov CurrencyTypeRef with ReferenceCurrencyTypeSelector {
      description = CurrencyTypeRef.Description;
   }
}

group SalesContractReferenceGroup for CustomerOrder {
   label = "Sales Contract Reference";
   visible = [not isNew];
   @DynamicComponentDependency CONMGT
   lov SalesContractNoRef with ReferenceConItemCustOrderLovSelector using SalesContractNoFilter {
      preview = ConItemCustOrderLovCard;
   }
   field ContractRevSeq {
      size = Small;
   }
   field ContractLineNo {
      size = Small;
   }
   field ContractItemNo {
      size = Small;
   }
}

group DocumentGroup for CustomerOrder {
   label = "Document Information";
   field LabelNote {
      validate command ValidateReplicateValuesCommand;
   }
   field InternalPoLabelNote {
      editable = [InternalPoNo != null];
   }
   lov PrintControlCodeRef with ReferenceCustOrdPrintControlSelector {
      description = PrintControlCodeRef.Description;
      size = Small;
   }
   field SummarizedSourceLines {
      size = Small;
      enumerationtrue = "Yes";
      enumerationfalse = "No";
      truelabel = "Yes";
      falselabel = "No";

   }
   field SummarizedFreightCharges {
      size = Small;
      enumerationtrue = "Yes";
      enumerationfalse = "No";
      truelabel = "Yes";
      falselabel = "No";

   }
   field PrintDeliveredLines {
      size = Small;
      validate command ValidateReplicateValuesCommand;
   }
}

group DocumentsToPrintGroup for CustomerOrder {
   label = "Documents To Print";
   field OrderConfFlag {
      size = Small;
      enumerationtrue = "PrintOrderConf";
      enumerationfalse = "NoOrderConf";
      truelabel = "Yes";
      falselabel = "No";
   }
   field PackListFlag {
      size = Small;
      enumerationtrue = "PrintDeliveryNote";
      enumerationfalse = "NoDeliveryNote";
      truelabel = "Yes";
      falselabel = "No";
   }
   field PickListFlag {
      size = Small;
      enumerationtrue = "PrintPicklist";
      enumerationfalse = "NoPicklist";
      truelabel = "Yes";
      falselabel = "No";

   }
}

group DocumentsPrintedGroup for CustomerOrder {
   visible = [not isNew];
   label = "Documents Printed";
   field OrderConf {
      size = Small;
      enumerationtrue = "Printed";
      enumerationfalse = "NotPrinted";
      truelabel = "Yes";
      falselabel = "No";

   }
   field DelNotePrinted {
      size = Small;
   }
   field PickListPrinted {
      size = Small;
   }
}

-- Block Customer Order Dialog
group BlockCustomerOrderGroup for BlockCustomerOrderStructure {
   label = "";

   lov BlockReasonRef with ReferenceOrderBlockReasonLovSelector {
      label = "Block Reason";
      freeinput = true;
      description = BlockReasonRef.BlockReasonDescription;
      size = Large;
      validate command {
         execute {
            call GetBlockReasonInfo(BlockReasonRef.BlockReason) into BlockReasonInfoStructure;
            if [BlockReasonInfoStructure.SystemDefined = "TRUE"] {
               error("You are not allowed to enter system defined block reasons.");
               set BlockReason = "";
            }
            else {
               set BlockReasonDesc = BlockReasonInfoStructure.BlockReasonDesc;
            }
         }
      }
   }
}

-- Email Order Confirmation Dialog
group CustomerOrderEmailGroup for CustomerOrderEmailStructure {
   label = "";
   field OrderNo {
      size = Small;
      editable = [false];
   }
   field Contact {
      size = Small;
      editable = [false];
      visible = [ReportId != "CUSTOMER_ORDER_CONF_REP" or ContactType != "Internal"];
   }
   field InternalPORef {
      size = Small;
      editable = [false];
      visible = [ReportId = "CUSTOMER_ORDER_CONF_REP" and ContactType = "Internal"];
   }
   field Email;
}

----------------------------------- LISTS -----------------------------------
list CustomerOrderHistoryList for CustomerOrderHistoryQuery {
   multiselect = [false];
   orderby = HistoryNo desc;
   field DateEntered;
   fieldset CustomerOrderStateFieldSet;
   field Userid {
      contactwidget {
         enabled = [Userid != null];
         source = Person;
      }
   }
   field MessageText {
      size = Large;
   }
}

----------------------------------- CARDS -----------------------------------
card TotalBaseAmountsCard for CustomerOrderAmounts {
   label = "";
   fieldranking TotalAmountBase;
   currency OrderLineTotalBase(CompanyCurrencyCode) {
      label = "Order Lines";
   }
   currency TotalChargeBase(CompanyCurrencyCode) {
      label = "Charges";
      visible = [TotalChargeBase != 0];

   }
//   currency TotalContributionBase(CompanyCurrencyCode) {
//      label = "Total Contribution Margin/Base";
//   }
//   field TotalContributionPercent {
//      label = "Contrbution Margin(%)";
//   }
   currency TotalAmountBase(CompanyCurrencyCode) {
      label = "";
   }
}

card TotalCurrAmountsCard for CustomerOrderAmounts {
   label = "";
   fieldranking TotalAmountCurr;
   currency OrderLineTotalCurr(CurrencyCode) {
      label = "Order Lines";
   }
   currency TotalChargeCurr(CurrencyCode) {
      label = "Charges";
      visible = [TotalChargeCurr != 0];
   }
   currency AdditionalDiscountCurr(CurrencyCode) {
      label = "Additional Disc. Amount";
      visible = [AdditionalDiscountCurr != 0];
   }
   currency TotalAmountCurr(CurrencyCode) {
      label = "";
   }
}

card ToatalTaxCurrAmountsCard for CustomerOrderAmounts {
   label = "";
   fieldranking ToatalTaxAmountCurr;
   currency OrderLineTaxTotalCurr(CurrencyCode) {
      label = "Order Lines";
   }
   currency TotalChargeTaxCurr(CurrencyCode) {
      label = "Charges";
      visible = [TotalChargeTaxCurr != 0];
   }
   currency ToatalTaxAmountCurr(CurrencyCode) {
      label = "";
   }
}

card TotalGrossCurrAmountsCard for CustomerOrderAmounts {
   label = "";
   fieldranking TotalGrossAmountCurr;
   currency OrderLineGrossTotalCurr(CurrencyCode) {
      label = "Order Lines";
   }
   currency TotalChargeGrossCurr(CurrencyCode) {
      label = "Charges";
      visible = [TotalChargeGrossCurr != 0];
   }
   currency TotalGrossAmountCurr(CurrencyCode) {
      label = "";
   }
}

---------------------------------- DIALOGS ----------------------------------
-- Block Customer Order Dialog
dialog BlockCustomerOrderDialog for BlockCustomerOrderStructure {
   label = "Block Customer Order";

   output(BlockReason);
   markdowntext {
      text = "This will manually block the customer order.";
   }
   group BlockCustomerOrderGroup;

   commandgroup DialogActionsCmdGroup {
      label = "Dialog Actions";
      command Ok;
      command Cancel;
   }
}

-- Email Order Confirmation Dialog
dialog CustomerOrderEmailDialog for CustomerOrderEmailStructure {
   label = "${DialogTitle}";
   input(OrderNo, CustomerNo, Contract, Email, Contact, InternalPORef, ContactType, ReportId, DialogTitle);
   output(Email);

   group CustomerOrderEmailGroup;

   commandgroup DialogActionsCmdGroup {
      label = "Dialog Actions";
      command Ok;
      command Cancel;
   }
}

---------------------------------- CHARTS -----------------------------------


--------------------------------- CALENDARS ---------------------------------

---------------------------------- SHEETS -----------------------------------

----------------------------- STATE INDICATORS ------------------------------

----------------------------------- TREES -----------------------------------

---------------------------------- PLUGINS ----------------------------------

------------------------------- IMAGE VIEWERS -------------------------------
