-----------------------------------------------------------------------------
--
--  Logical unit: CustomerOrderLine
--  Component:    ORDER
--
--  IFS Developer Studio Template Version 3.0
--
--  Date    Sign     History
--  ------  ------   ---------------------------------------------------------------------------------------------------------
--  220203  ShWtlk   MF21R2-6812, Modified Update_Planning_Date() to fix spellings in the info message.
--  220201  Jayplk   MF21R2-6758, Modified Perform_Capability_Check___() to not modify due dates when completion date returned from CC is same as the due date sent into CC.
--  220125  ErFelk   Bug 162059(SC21R2-7170), Modified Check_Update___() to get the tax_id_no from end_customer when customer country code and end customer country code are different.    
--  220124  ShWtlk   MF21R2-6416, Modified Check_Update___ to remove remove interim order headers created by neither reserver nor allocate option in capability check.
--  220119  Skanlk   Bug 162080(SC21R2-7064), Increased the length of lowest_node_info_ from 200 to 400 because there are translations that exceed 200 characters.
--  220118  ShWtlk   MF21R2-6531, Modfied Update_Planning_Date() to remove incorrect parts of the info message shown when running capability check.
--  220117  ChBnlk   SC21R2-1083, Added method Handle_Replacement_Part() public method in order to support part replacement in quick customer order registration.
--  220112  ShWtlk   MF21R2-6416, Modified Delete___ to remove interim order headers created by neither reserver nor allocate option in capability check.
--  220111  KrRaLK   AM21R2-2950, Equipment object is given a sequence number as the primary key (while keeping the old Object ID 
--                   and Site as a unique constraint), so inline the business logic to handle the new design of the EquipmentObject.
--  211223  Skanlk   Bug 161134(SC21R2-6825), Added Fetch_And_Validate_Tax_Id() and Get_Tax_Id_Type() to validate Tax ID other than EU countires.
--  211214  Amiflk   Bug 161755(SC21R2-6468), Modified Copy_Customer_Order_Line by adding a new conditional statement to recalculate the tax amounts when tax details checkbox is not checked,
--  211214           when copying customer order line, modified Post_Insert_Actions___ to recalculate the tax amounts with passing TRUE values for recalc_amounts_, refetch_curr_rate_ additional 2 parameters. 
--  211208  Skanlk   Bug 161775(SC21R2-6470), Changed the Copy_Customer_Order_Line() and Add_Rental_Info_To_Attr___() methods to fetch correct Planned Rental Start Date and Planned Rental End Date.
--  211203  ShWtlk   MF21R2-6026, Modfied the info message in Update_Planning_Date() shown for critical path.
--  211122  Ersruk   PJ21R2-3527, New transaction_currency_rate_cost_ used to calculate cost reported to project.
--  211117  ChBnlk   SC21R2-5264, Modified Insert_Default_Address___ to insert addresses from address3, address4, address5, address6 to allow the proper update of the address.
--  211112  ThKrlk   Bug 161011(SC21R2-53507), Modified Pre_Unpack_Update___() to add a new condition before raising FREIGHT_ORDER error.
--  211110  ChBnlk   SC21R2-5901, Modified get_Catalog_Description___(),  Get_Vendor_No___() and Get_Supply_Site___() by defining the proper data types of the variables.
--  211109  NiRalk   SC21R2-5444,Modified Check_Insert___() and Check_Update___() methods to check Part_Ownership_API.DB_COMPANY_RENTAL_ASSET and make the cost zero.
--  211104  Skanlk   Bug 161321(SC21R2-5681), In Modify__() removed an error message which prevents the user from updating information on a customer order line 
--  211104           when there exists more items to be invoiced.
--  211103  GISSLK   MF21R2-5854, Modify Check_Before_Update___() and Delete___() to consider abnormal demands with online consumption.
--  211102  ChBnlk   SC21R2-1083, Added the methods get_Catalog_Description___(), Get_Condition_Code___(), Get_Supply_Code___(),
--  211102           Get_vendor_No___(), Get_Supply_Site___() in order to enable unit testing for the line validations.
--  211027  NiDalk   SC21R2-5202, Added Modify_Ref_Id to modify reference no for customer order line.
--  211022  ChBnlk   SC21R2-1083, Added new method Validate_Cust_Ord_Lin_Defaults() and called it from Get_Line_Defaults___().
--  211018  Amiflk   Bug 161020(SC21R2-3081), Modified value_ parameter into size 4000 from 2000 in the Client_SYS.Get_Next_From_Attr method.
--  211014  cecobr   FI21R2-4615, Move Entity and associated clint/logic of BusinessTransactionCode from MPCCOM to DISCOM
--  210928  Skanlk   Bug 160959(SC21R2-2964), Modified Check_Update___() Unpeg_Line() and Check_Before_Update___() by passing and checking unpeg_ipd_flag_ when unpegging the Customer Order Line.
--  210914  KiSalk   Bug 160803(SC21R2-2690), In Check_Before_Update___, added configuration_id_changed_ too in order to temporarily set release_planning to recalculate dates upon configuring.
--  210914  KiSalk   Bug 160578(SC21R2-2725), Modified Get_Qty_Shipped_And_State to fetch values from the CO line with the NULL valued demand_order_ref4 
--  210914           to ignore the order lines exist for component part lines for the same demand order. 
--  210819  ChJalk   SC21R2-2348, Modified Get_Qty_Shipped_And_State to reverse the bug correction 159135.
--  210801  MiKulk   SC21R2-2177, Added Unit Test Annotations for Unpack___, Check_Allow_Backorders___, Get_Amt_Ratio_Per_Tax_Deliv___, Get_Gross_Amnt_Ratio_Per_Tax__, Get_Amt_Ratio_Per_Tax_Deliv__, Get_Objversion 
--  210726  Skanlk   Bug 160187 (SCZ-15645), Added a Sales Part Cross Reference exist check in method Get_Default_Part_Attributes___ to prevent an incorrect error message 
--  210726           encountered when converting a sales quotation to a customer order.
--  210726  ManWlk   MF21R2-2621, Modified Perform_Capability_Check___() to send original planned due date of customer order line to CC engine instead of previous work day.
--  210715  UTSWLK   MFZ-7835, Merged Bug 159323, Modified code in Get_Elements_From_Manuf_Ord___ to get costs from Shop_Order_Project_Cost_API.Get_Plan_Project_Cost_Elements().
--  210618  MaEelk   SC21R2-1075, Introduced Get_Amt_Ratio_Per_Tax_Deliv__ and Get_Amt_Ratio_Per_Tax_Deliv___.
--  210618           Moved the code inside Get_Gross_Amnt_Ratio_Per_Tax__ to Get_Amt_Ratio_Per_Tax_Deliv___
--  210609  DhAplk   Bug 159747 (SCZ-15174), Modified Validate_Update_Service_Con___ by including 'CATALOG_DESC', 'NOTE_TEXT' attributes.
--  210609  Hahalk   Bug 159043(SCZ-15056), Modified If() condition in Check_Insert___() to prevent overriding original supply code when there is std_planned_item selected.
--  210608  ChFolk   SCZ-15099(Bug 159604), Modified Modify_Line___() to handle previously added info and removed the info handling in Modify() as it is no needed when it is handled in Modify_Line___().
--  210607  KETKLK   PJ21R2-749, Replaced Project Delivery supply code 'PRD' with Project Deliverables supply code 'PJD' as Project Delivery functionality will be removed.
--  210521  Skanlk   Bug 158908(SCZ-14920), Modified Validate_Pack_Instr_Id___ to keep the existing Packing Instruction ID on customer order line when the delivery address is changed on the header.
--  210521  ChJalk   Bug 159135(SCZ-14919), Modified Get_Qty_Shipped_And_State to check the demand_order_ref4 to be NULL to ignore the order lines exist for component part lines for the same demand order.
--  210506  KETKLK   PJ21R2-448, Removed the call to Pur_Ord_Charged_Comp_API.Update_Proj_Product_Items procedure since it will be reomved to remove PDMPRO references.
--  210505  ChFolk   Bug 159071(SCZ-14622), Modified Pre_Unpack_Insert___ to remove setting up shipment_type from order header when shipment_type_sent_ is FALSE. Modified Check_Insert__ to set the
--  210505           shipment_type from customer Order header if it is not set from Get_Supply_Chain_Defaults___ and change the default_addr_flag when shipment_type is differ in header and line.
--  210430  cecobr   FI21R2-916, gelr:brazilian_specific_attributes, Add Acquisition Reason to Business Transaction, Sales Part and CO Line
--  210421  PAMMLK   MF21R2-483, Modified the Check_Update___ to call Def_Contract_Order_Item_API.Validate_Co_Line_Changes.
--  210419  Jowise   MF21R2-729, Same Day Planning - Change Planned Due Date to Timestamp
--  210415  MaEelk   SC21R2-49, Modified Update___ and if the Discounted Price Rounded is enabled, assigned the Original Discount to the Discount field when the Discount field is changed with other operations.
--  210401  ApWilk   Bug 158558(SCZ-14264), Modified Build_Rec_For_Copy_Line___() to copy the owning customer correctly when performing Copy order.
--  210329  TGUNLK   Bug 158554(AM21R2-876), Added 2 new attributes names into a condition in the Validate_Update_Service_Con___ method to allow change the dlivery terms in Customer Order Line Address dialog box.
--  210325  ThKrlk   Bug 157855(SCZ-14013), Modified Check_Update___() Added new conditions to skip unnecessary calculations on revised_qty_due.
--  210325           And modified Update___() by passing new parameter newrec_.revised_qty_due to Shipment_Line_API.Update_From_Source_Line().
--  210302  AsZelk   SCZ-13858, Modified Modify_Order_Defaults__ method to restrict updating CO line delivery address and tax liability when updating tax liability on CO header.
--  210218  ApWilk   Bug 157707(SCZ-13528), Modified Check_Before_Update___() to prevent by changing the supply code in the CO line when there is a pegged supply.
--  210217  RavDlk   SCZ-13530, Modified a condition in Check_Before_Update___() so that contact is not fetched when change_request is TRUE.
--  210211  RavDlk   SC2020R1-12519, Modified Get_Backord_Value_Base_Curr___() to return correct net base value.
--  210201  MaRalk   SC2020R1-12157, Optimized code in order to reduce the trips to the database by replacing with referring to the main get record or 
--  210201           by reusing common variable for the code blocks where had two or more public Get_X calls to same entity. Changed methods below.  
--  210201           Assign_Rel_Mtrl_Planning___, Calculate_Order_Line_Dates___, Change_Package_Structure___, Check_Before_Insert___, Check_Before_Update___, Check_Delete___, 
--  210201           Check_Insert___, Check_Update___, Copy_Staged_Billing___, Create_Sourced_Co_Lines, Get_Backord_Value_Base_Curr___, Get_Backlog_Value_Ord_Curr___, Get_Base_Sale_Price_Total, 
--  210201           Get_Cust_Part_No_Defaults__, Get_Info_For_Desadv, Get_Line_Defaults___, Get_Possible_Sales_Promo_Deal, Get_Purchase_Order_Info, Get_Sum_Invoiced_Order_Curr__, 
--  210201           Get_Tax_Info, Insert___, Get_Total_Tax_Amount_Base, Get_Total_Tax_Amount_Curr, Modify_Delivery_Address__, Modify_Order_Defaults__, Perform_Capability_Check___, 
--  210201           Post_Insert_Actions___,  Update___, Update_Planning_Date, Validate_Prepayment___, Validate_Proj_Connect___, Validate_Proj_Disconnect___, Validate_Source_Pkg_Info.
--  201223  ThKrlk   Bug 157060(SCZ-13013), In Update___, merged 151215 and 156222 corrections, so that planned_ship_date check done for tax recalculation, only when a tax class is used.
--  201204  PamPlk   Bug 156222(SCZ-12747), Modified Update___()to fetch the default tax information when unchecking the single occurence check box and having a tax class is defined.
--  201202  PamPlk   Bug 154128(SCZ-12746), Modified Check_Insert___() and Check_Update___() by passing catalog_no when calling Sales_Part_API.Get_Supply_Site_Part_No__(). 
--  201202           Modified Calculate_Order_Line_Dates___() by passing Supply_Site_part_no to Cust_Ord_Date_Calculation_API.Calc_Order_Dates_Backwards(). 
--  201202  RasDlk   SCZ-11538, Modified Set_Rel_Mtrl_Planning(), Check_Insert___() and Check_Before_Update___() to set the rel_mtrl_planning flag according to the setting in site_to_site_reserve_setup.
--  201202           Added Assign_Rel_Mtrl_Planning___(). Modified Check_Before_Update___() to stop triggering error message PEGLINECANNOTUPDATE.
--  201125  PAMMLK   Merged LCS Bug 156432.
--  201109  PAWELK   Bug 156432(MFZ-5548), Modified the code inside Get_Elements_From_Manuf_Ord___() to increase the performance of the business logic.
--  201118  AsZelk   Bug 155793(SCZ-12085), Modified Get_Supply_Chain_Defaults___ to unchange the CO line picking_leadtime and delivery_leadtime when line ship_addr_no is changed.
--  201119  MaRalk   Bug 156251(SCZ-12222), Corrected incorrectly assigning sale_unit_price as part_price instead of assigning it from unit_price_incl_tax
--  201119           when CO header use_price_incl_tax is true and CO line price source change from Price List to Customer Agreement.  
--  201111  MalLlk   GESPRING20-5747, Modified Update___() to not set the sale unit price, if it is already set to zero and the line is free of charge.
--  201106  KiSalk   Bug 155793(SCZ-12085), Added oldrec_ parameter to Get_Supply_Chain_Defaults___ (to be passed from Check_Update___) and modified Supply Chain Defaults fetching depending on Delivery Address changed or not.
--  201102  RasDlk   SCZ-12233, Modified Set_Uninvoiced to consider invoiced rental transactions when CO line qty_invoiced is 0 due to resultant multiple invoiced transactions.
--  201029  MalLlk   GESPRING20-5276, Modified Check_Update___() to clear ctp record, after cancel interim order.
--  201027  RasDlk   SCZ-11052, Added Raise_Delnote_Info_Message___  and modified the method Check_Before_Insert___ by calling the method Raise_Sm_Object_Error___
--  201027           to solve MessageDefinitionValidation issue.
--  201019  RoJalk   Bug 154791(SCZ-11814), Modified Get_Info_For_Desadv() by calling Supply_Order_Analysis_API.Find_Source with extra parameter to notify it's for DESADV. Modified Get_Info_For_Desadv() to get the correct receiver_source_ref_type_.
--  201019  ApWilk   Bug 155813(SCZ-11987), Modified Update___() to update the tax amount correctly when changing the price in customer order line.
--  201017  Skanlk   Bug 155109(SCZ-11787), Modified Change_Package_Structure___ method by calling Check_Default_Addr_Flag___ method to retrive correct value for default info check box.
--  201016  PamPlk   Bug SCZ-11574, Modified Get_Info_For_Desadv(), by reallocating the assigment of receiver_uom_ to fetch the value.
--  201016  ThKrlk   Bug 155400 (SCZ-11543), Modified Calculate_Order_Line_Dates___() method by adding condition to check whether supply site reservation has done or not,
--  201016           to prevent the wrong dates calculation in Customer Order after manual Reservation on Supply Site.
--  201016  ThKrlk   Bug 154815 (SCZ-11790), Modified If() condition in Check_Supply_Code___ method to make project connected CT/CD behaves similar as non project connected CT/CD when releasing the PO.
--  201014  RasDlk   SCZ-11786, Modified Check_Before_Update___() to stop raising the error message when supply code is IPD.
--  201013  ThKrlk   SCZ-11836, Modified Calculate_Order_Line_Dates___() to pass delivery_leadtime which is used when no data in supply chain matrix.
--  201013           And track if the ship via code is changed and passing ship_via_code_changed_ to Cust_Order_Leadtime_Util_API.Get_Default_Leadtimes as a new parameter.
--  201007  NiDalk   SC2020R1-9937, Modified Update___ to correct tax calculation when tax_code is changed in line.
--  200908  JoAnSe   MF2020R1-6571, Added checks in Validate_Proj_Disconnect___ Check_Update___ for CO line connected to a defense contract item
--  200820  MaEelk   GESPRING20-5398, Added ORIGINAL_DISCOUNT, ORIGINAL_ADD_DISCOUNT, ORIGINAL_ORDER_DISCOUNT to the imlementation
--  200520           according to the Discounted Price Rounded localization Parameter.
--  200805  KiSalk   Bug 154235(SCZ-10311), In Update___, added condition to stop adding taxes during CO line creation from quotation, as taxes will be transferred later from quotation line.
--  200805           This will stop creating default tax lines other than those from quotation.
--  200723  MaRalk   SCXTEND-4307, Modified Update_Line__ in order to handle information message about internal orders connected to shipments in the IPD flow upon delivery address changes. 
--  200713  NiDalk   SCXTEND-4446, Modified Modify_Additional_Discount__ to fetch taxes from a bundle call when AVALARA sales tax is used.
--  200709  RoJalk   Bug 154274(SCZ-10589), Modified the conditions in Check_Update___ when calling Get_Supply_Chain_Defaults___ and removed CO status check and ensured only Supplier Ship Via Transit is overwritten when changing to IPT from IO. 
--  200709  Skanlk   Bug 153522 (SCZ-9892), Modified Change_Package_Structure__ and Check_Insert__ to solve the issue in shipment creation method when using a Pkg Part.
--  200709           Modified Insert_Package___ by changing shipment_creation_ parameter as an IN parameter and omitting the unwanted assignment to shipment_creation_ variable.
--  200709           Modified Update___ method by removing the Modify_Line___ method calling line and changed the error message by removing Internal Purchase Order Direct.
--  200709           Modified Check_Update___ method by removing the unnecessary code block.
--  200709  AjShlk   Bug 152776(SCZ-9340), Modified Calculate_Order_Line_Dates___ to pass delivery_leadtime which is used when no data in supply chain matrix.
--  200708  ErFelk   Bug 152094(SCZ-10712), Modified Check_Insert___() and Check_Before_Update___() to set the rel_mtrl_planning flag according to the flag in Site_To_Site_Reserve_Setup_API if supply code is in IPT or IPD.  
--  200702  Erlise   Bug 154336(SCZ-10323), Modified Post_Insert_Actions___. When using tax from external system, tax should be fetched for a new order line also in the scenario where there is a discount type defined on the customer that has the value 0%.
--  200625  NiDalk   SCXTEND-4438, Modified Post_Insert_Actions___ and Update___ to avoid fetch of taxes during insert when company_tax_control.fetch_tax_on_line_entry for Avalara sales tax is set to false.
--  200625           Also When attr_ has UPDATE_TAX set to false in Insert___ and Update___ that means taxes are fetched from a bundle call.
--  200622  KiSalk   Bug 153559(SCZ-9918), Moved code that creates/connects CO line to Shipment from Post_Insert_Actions___ and Update___, into new common method 
--  200622           Check_And_Add_To_Shipment___. Created Check_And_Add_To_Shipment as the public interface to that method.
--  200608  MalLlk   GESPRING20-4617, Removed Calc_Free_Of_Charge_Tax_Basis() amd moved the logic to Tax_Handling_Order_Util_API.Calc_And_Save_Foc_Tax_Basis().
--  200608           Added public method Modify_Foc_Tax_Basis().
--  200603  fiallk   GEFALL20-2627, Modified method Get_Line_Defaults___ to add STATISTICAL_CODE to attr.
--  200602  KiSalk   Bug 153266(SCZ-9738), In New__ and Modify__, called Cust_Ord_Date_Calculation_API.Show_Invalid_Calendar_Info to show App_Context_SYS value 
--  200602           stored in key 'CUST_ORD_DATE_CALCULATION_API.INVALID_CALENDAR_INFO_' as info message.
--  200526  ChWkLk   MF2020R1-417 ,Modified Delete___() to use CroLineMaterialRoute to clear cro connected customer orders.
--  200526  ThKrLk   Bug 153490 (SCZ-9890), Modified Check_Insert___() by adding new condition to retrieve zone info when it is default_addr_flag and addr_flag true even if freight_map_id and zone_id have values.
--  200525  KiSalk   Bug 154023(SCZ-10180), In Update___, Added condition to ignore Cancelled CO lines when calculating price when currency_type_ IS NOT NULL in order to stop error
--  200525           upon cancelling CO line connected Project with different Project Specific Currency Rate Type for Accounting.
--  200520  UdGnlk   Bug 153576 (SCZ-9888), Modified Pre_Unpack_Insert___() to avoid shipment type retreival from CO for the COL creation from Distribution Order. Modified 
--  200520           Check_Insert___() Forced re-evaluating default_addr_flag for DO as it can have shipment_type values different from order header.
--  200513  ThKrLk   Bug 153597 (SCZ-9929), Modified Get_Base_Sale_Price_Total() to filter only order lines which are not in Canceled state when calculating total base sales price.
--  200505  ThKrLk   Bug 153087 (SCZ-9625), Modified Update___ by allowing modify partial delivered charge lines.
--  200422  ErFelk   Bug 153350(SCZ-9815), Modified Build_Attr_For_Modfy_Ord_Def__() by increasing the packing_instruction_id_ length to 50.
--  200420  NiDalk   SCXTEND-1655, Modified Update___ to show more than one dop hearder connected message only once when qty and wanted delivery date changed in Aureana client.
--  200406  ApWilk   Bug 153085(SCZ-9635), Modified Update___() to allow the same information message when changing the route id with a connected shipment.
--  200312  Erlise   SCXTEND-1873, Modified Prepare_Insert___(), added 'CUSTOMER_NO' since it is used in references in the Aurena client and need to have the value fetched.
--  200303  Hahalk   Bug 152621 (SCZ-9194), Moved the code block which calls Sales_Part_API.Check_Limit_Sales_To_Assort() from Check_Common___ to Check_Insert___, in order to stop validation during an update.
--  200302  BudKlk   Bug 151684(SCZ-9277), Modified Check_Insert___() and Check_Update___() by setting the value to newely added feild supply_site_part_no base on supply code IPT or IPD.
--  200302  Hahalk   Bug 150894 (SCZ-7838), Modified Modify() by adding an NVL to the condition so that catalog_no is only taken if part_no is NULL.
--  200223  ThKrLk   Bug 150041 (SCZ-7159), Modified Get_Info_For_Desadv() to get PO Line number and PO Rel number as receiver_source_ref2_, receiver_source_ref3_ if the source supply code is 'IPD'.
--  200219  ThKrLk   Bug 150041 (SCZ-7159), Modified Get_Info_For_Desadv() to get customer PO number as receiver_source_ref1_ if the source demand code is 'Int Cust Dir'. 
--  200212  NiEdlk   Bug 152123 (SCZ-8776), Added Get_Packages_Shipped to get the full package qty shipped by considering the components shipped.
--  200205  ApWilk   Bug 152126 (SCZ-8680), Modified Check_Update___() to exclude the checking for supply code IPT for allowing re-fetch the supply chain default values when changing the supply code from a non transit(IO) 
--  200205           alternative to a transit alternative(IPT). 
--  200129  MalLlk   SCXTEND-2494, Avoid the duplicate requests to external tax systems, when discounts involved, upon saving.
--  200121  DhAplk   Bug 151734 (SCZ-8304), Modified Validate_Update_Service_Con___ by excluding 'TAX_CALC_STRUCTURE_ID', 'SET_TAX_FROM_ORIGINAL', 'FETCH_TAX_FROM_DEFAULTS', 'MULTIPLE_TAX_LINES' attributes from validation and
--                   removed unintentional change happened in GG-103 in strike project.
--  200103  KiSalk   Bug 150924(SCZ-7789), In Pre_Unpack_Insert___, stopped setting shipment_type, delivery_terms, del_terms_location from order header and reevaluated default_addr_flag for internal transit delivery.
--  200103  KiSalk   Bug 150924(SCZ-7789), In Pre_Unpack_Insert___, stopped setting shipment_type, delivery_terms and del_terms_location from order header for internal transit delivery 
--  191224  ChBnlk   Bug 151077 (SCZ-7915), Modified Update___() by replacing the condition to check for the change_request_ from price_refetch_, before refetching the price.
--  191220  ErFelk   Bug 151059 (SCZ-7896), Modified Post_Insert_Actions___() to set the release_planning flag for components parts.
--  191217  DhAplk   Bug 151215 (SCZ-7918), Modified Update___to fetch the correct Tax Code when wanted delivery date id changed.
--  191205  ApWilk   Bug 150524(SCZ-7432), Modified Check_Supply_Code___ to check if the part is connected with a product structure which is a Manufactured type when the supply code is a Shop order.
--  191125  DilMlk   Bug 150662 (SCZ-7464), Modified Check_Update___ to prevent re-fetching price information when FreeOfChargeDb is checked and price is zero.
--  191121  Cpeilk   Bug 151042 (SCZ-7820), Modified Validate_Price___ to ignore price less than zero error for FSM created orders.
--  191118  Hairlk   SCXTEND-1515, Avalara Integration. Refer to the comments in checkpoint EXTTAXSYS_ONE and checkpoint EXTTAXSYS_TWO. 
--  191029  ErFelk   Bug 150114 (SCZ-7051), Modified Create_Sourced_Co_Lines() by removing the DISCOUNT from the attr before inserting the new CO line.
--  191022  Hairlk   SCXTEND-876, Modified Prepare_Insert___, added code to fetch CUSTOMER_TAX_USAGE_TYPE from the header and added it to the attr.
--  191021  fiallk   GEFALL20-475, Modified method Get_Line_Defaults___ to add ACQUISITION_ORIGIN to attr_.
--  191003  Hairlk   SCXTEND-876, Modified Insert___, Added code to fetch customer_tax_usage_type from customer if its not available in the attr. 
--                   Modified Update___, Added customer_tax_usage_type to the condition when changed will recalculate the tax amount for that line.
--  191001  DaZase   SCSPRING20-133, Added Raise_Sm_Object_Error___, Raise_Scrapped_Object_Error___, Raise_Sales_Qty_Less_Error___  and Raise_Prepay_Amount_Error___ to solve MessageDefinitionValidation issues.
--  190927  KiSalk   Bug 150141 (SCZ-7079), Modified Update___ to re-fetch external taxes when price is changed from 0 to non-zero value and vice versa.
--  190923  JeLise   SCWTEND-466, Added in parameter replicate_changes_ to method Update_Line__.
--  190913  Cpeilk   Bug 146390 (SCZ-3309), Modified Create_Project_Connection___ by handling a condition for not allowing to proceed the background job and to end up with an error, if the 
--  190913           activity object is disconnected from the CO line when it executes.
--  190910  DiKulk   Bug 149528(SCZ-6342), Modified Update___() to add a info message when increasing sales qty in pegged orders.
--  190906  ErFelk   Bug 149079(SCZ-6031), Modified Get_Supply_Chain_Defaults___() to override the defaults values, if del_terms_locations has values in the passing record.
--  190901  ErFelk   Bug 149269(SCZ-5459), Removed the previous correction. Modified Get_Info_For_Desadv() by assigning customer_part_unit_meas to receiver_uom_.   
--  190829  SeJalk   SCUXXW4-24131, Modified Get_Next_Rel_No to return rel no even though line no is empty.
--  190821  KHVESE   SCUXXW4-16951, Modified method Update___ to add Is_Odp_Session for shortages attr.
--  190821  JeLise   SCUXXW4-8717, Added method Update_Line__, used from Aurena.
--  190823  Kisalk   Bug 146799(SCZ-3290), In Get_Default_Part_Attributes___, when supply_code_ = 'SEO', set attribute BASE_UNIT_PRICE_INCL_TAX if use_price_incl_tax = 'TRUE' condition; also stopped resetting PART_PRICE with Null.
--  190819  Janslk   Bug 149564 (PJZ-2515), used declarations in Public_Declarations_API instead of the ones in Project_Connection_Util_API to remove dependancy on PROJ in project connection related code.
--  190819  ErFelk   Bug 149269(SCZ-5459), Modified Get_Info_For_Desadv() by modifing a condition so that shipped_qty_ is calculated using customer_part_conv_factor and cust_part_invert_conv_fact.   
--  190808  SBalLK   Bug 149483(SCZ-6140), Modified Get_Line_Defaults___() method to re-evaluate the supply code when entering package component where package part connected to a project.
--  190726  UdGnlk   Bug 148421(SCZ-5014), Modified Check_Before_Update___() to allow updating condition code when supply code is PT and IPT. Validated for pegged ojects as PO and PR. Raised meaningful messages.
--  190725  AmPalk   Bug 146539, Modified Line_Is_Fully_Invoiced___() by adding a condition to set the line to closed state when part ownership is company owned and demand comes from component 
--  190725           repair exchange and order supply type is CRO.
--  190724  KiSalk   Bug 149239(SCZ-5775), In Fetch_Company_And_Rounding___, moved rounding_ assignment out of the condition not to return 0 when it is not set.
--  190710  UdGnlk   Bug 148954(SCZ-5636), Modified Get_Info_For_Desadv to retrieve correct PO information for IPD orders when three sites intersite scenario.
--  190709  KiSalk   Bug 149120(SCZ-5052) Modified Modify_Tax_Info not to handle taxes for package component lines.
--  190606  DiKuLk   Bug 147922(SCZ-4314), Modified Modify_Tax_Details_For_IPD() to add tax transaction info correctly for the IPD orders.
--  190625  MaAuse   SCUXXW4-22460, Added PACKING_INSTRUCTION_ID to attr_ in Get_Line_Defaults___.
--  100524  ChBnlk   Bug 145224(SCZ-1972), Modified Update___() by calling Shipment__Line_API.Unreserve_Non_Inventory() and Reserve_Non_Inventory() to modify the qty_to_ship in shipment line
--  100524           when modifying the qty_to_ship in customer order line.
--  190519  Cpeilk   Bug 147826 (SCZ-4760), Modified Check_Before_Update___() and Post_Insert_Actions___() to get the correct inventory part of supply site.
--  190519  NiNilk   Bug 148119 (SCZ-4683), Modified Modify_Order_Defaults__ by allowing to retain the tax code defined in sales part when going to update the tax free tax code defined in co address tab, for non-taxable lines.
--  190517  KiSalk   Bug 140365, Added Get_Price_Total___ and modified Get_Total_Tax_Amount_Curr, Get_Base_Sale_Price_Total, Get_Sale_Price_Incl_Tax_Total, Get_Base_Price_Incl_Tax_Total, Get_Total_Tax_Amount_Base, 
--  190517           Get_Sale_Price_Total, Validate_Prepayment___ to reduce accessing same tables and code blocks repeatedly.
--  190425  ChBnlk   Bug 147974 (SCZ-4312), Modified the Check_Delete___() by making the rowstate translatable in the error message NO_REMOVE. 
--  190402  NipKlk   Bug 147655 (SCZ-4122), Modified the method Modify_Tax_Info() by clearing the attr_ before adding values to TAX_CODE_CHANGED inside the loop.
--  190402  DilMlk   Bug 147459(SCZ-3298), Modified methods Retrieve_Default_Vendor__() and Get_Line_Defaults___() to fetch active primary supplier when inserting a CO line.
--  190327  Cpeilk   Bug 147555 (SCZ-3992), Modified Get_Total_Discount_Percentage to check rental_chargable_days_ is zero to avoid amount_ getting zero.
--  190302  ApWilk   Bug 146745 (SCZ-3223), Modified Build_Attr_For_New___ for setting the value of VAT_NO as TAX_ID_NO to prevent the Tax id getting a null value when creating the customer order line.
--  190219  Cpeilk   Bug 145616 (SCZ-2382), Modified Unpeg__ to include the info\warnings stored in current_info_ when unpegging.
--  190208  ShPrlk   Bug 145211(SCZ-1968), Modified Modify() by replacing newrec_.part_no with newrec_.catalog_no in a condition so that it support Non-Inventory Sales Part.
--  190311  niedlk   SCUXXW4-9047, Added Get_No_Of_Sold_Sales_Parts to get the details needed for Customer 360 in Aurena.
--  190227  RaVdlk   SCUXXW4-1374, Changed the text of the error message in Check_Before_Update
--  190223  MiKulk   SCUXXW4-781, Modified the Get_Line_Defaults___ and Prepare_Insert___ by adding ODP session specific value fetching.
--  190208  MaEelk   SCUXXW4-9032, Added two functions Get_Unit_Contribution_Margin and Get_Base_Contribution_Margin
--  190124  ErFelk   Bug 146346(SCZ-2814), Modified Prepare_Insert___() so that, REL_MTRL_PLANNING is unselected when Customer order is in state blocked and 
--  190124           Block Type is Manual and the Block Reason has the Exclude from Material Planning checkbox selected.
--  190122  ChJalk   Bug 146238(SCZ-2448), Modified Update_License_Connect_Head__ to check whether the sale_unit_price has been changed and gives an error if the update license is not allowed.
--  190106  UdGnlk   Bug 144611, Modified Validate_Prepayment___() messages to be more meaningful. Added Validate_Prepayment() to check connected prepayment or a prepayment invoice exits.
--  190106  UdGnlk   Bug 144824, Reversed bug correction of 137594, modified at Post_Insert_Actions___().    
--  181027  ShPrlk   Bug 132579, Modified Check_Default_Addr_Flag___ to avoid evaluating line_default_addr_flag_ against address values during insertion.
--  181024  ChBnlk   Bug 144881, Modified Copy_Customer_Order_Line() by adding ORDER BY clause to get the package lines and component lines in the proper order.
--  181003  ErRalk   Bug 144472, Modified Build_Rec_For_Copy_Line___ method to avoid fetching owning customer for Company Owned Stock.
--  180928  ErFelk   Bug 144402, Modified Pre_Unpack_Update___() by adding order line details to BILLED_ORD_LINE message.
--  180814  ShPrlk   Bug 143549, Modified Check_Insert___ by removing the newrec_.price_list_no being assigned to prevent price list no column being alterred.
--  180811  RasDlk   Bug 143514, Modified Check_Update___ by changing the translatable constant DO_condition_code.
--  180723  ChBnlk   Bug 142401, Modified Build_Attr_For_New___ by adding new condition to check if the sales price should be copied from another object and
--  180723           if so assign the sales price converted from the base price to the attr_ rather than directly assigning it, in order to get proper values based on currency rates.
--  180628  DiKuLk   Bug 142093, Modified Validate_Proj_Disconnect___() to allow cancel project connected lines with supply code SO.
--  180626  RasDlk   Bug 140953, Modified Post_Insert_Actions___() by moving the logic upwards to fetch the correct address information needed 
--  180626           to perform the tax calculation when the tax method is 'QUANTUM_SALES_USE_TAX'.
--  180625  KiSalk   Bug 142674, Modified Modify_Delivery_Address__ to stop resetting contact of lines, on request to change line ship address with header Delivery address change.
--  180618  AsZelk   Bug 142489, Modified Update_License_Connect_Head__() method in order to change the license date when changing the Planned Ship Date on the CO Line.
--  180516  DiKuLk   Bug 141977, Modified Pre_Unpack_Update___() to add 'TAX_CLASS_ID' to support update a value after Invoicing a CO.
--  180426  ChBnlk   Bug 140582, Added a new procedure Raise_Info_Message___ to prevent duplicating message constants.
--  180227  MeAblk   Modified Update___() to correctly update the prices from a change request(ORDCHG).
--  180226  MaEelk   STRSC-17014, price_list_no was always set to be fetched.
--  180226  RaVdlk   STRSC-17368, Added the value of supply_code to the attr_ in copy_customer_order_line(), before calling Build_Attr_For_New___()
--  180221  DiKuLk   Bug 140020, Modified Get_Supply_Chain_Defaults___() to track if the ship via code is changed.
--  180216  MaEelk   STRSC-16559, Added missing validations on address3, address4, address5, address6 to Check_Default_Addr_Flag___. 
--  180216           Added address3, address4, address5, address6 to Copy_Order_Line_Address___ too.
--  180216  TiRalk   STRSC-16784, Modified Check_Custord_For_Purord to fetch the correct inventory transaction as only for inventory parts.
--  180215  MaEelk   STRSC-17014, Introduced a new price source 'Copied' in Copy Co Functionality. price_source_id and price_list_no was made null.
--  180209  TiRalk   STRSC-10970, Modified Get_Sale_Price_Total by optimizing same logic. This correction has been done to improve perfomance in
--  180209           POST_ORDER_UpdateSourceTaxItem.sql when update tax_base_curr_amount and tax_base_dom_amount, but normal logic has been optimised as it will gain 
--  180209           the performance in normal code as well. Added another Get_Base_Sale_Price_Total to improve performance in POST_ORDER_UpdateSourceTaxItem.sql.
--  180209  MaEelk   STRSC-16910, Added 'IPD' and 'IPT' to the excluded demand code list in Copy_Cuatomer_Order_Line.
--  180209  MaEelk   STRSC-16887, customer_no of the order line was set as owning_customer_no when copying a customer order line.
--  180208  MaEelk   STRSC-16891, Modified Copy_Customer_Order_Line and moved the call to Cust_Order_Line_Discount_API.Calc_Discount_Upd_Co_Line__ 
--  180208           outside the loop copyng discount lines.
--  180207  MaEelk   STRSC-16847, Modified Build_Rec_For_Copy_Line___ and discount was set as 0. the real value will be calculated later.
--  180206  MaEelk   STRSC-16659, Modified Build_Rec_For_Copy_Line___ and Address information was set correctly when copying a order line
--  180125  MaEelk   STRSC-15983, Modified Customer_Order_Line. Passed TRUE to the parametr remove_external_project_ in the call to Pre_Accounting_API.Copy_Pre_Accounting.
--  180124  MaEelk   STRSC-16092, Removed the call to Document_Text_API.Copy_All_Note_Texts from Copy_Customer_Order_Line since it is being handled in Insert___
--  180123  MaEelk   STRSC-15989, Modified Build_Rec_for_copy_Line___ and allowed input_conv_factor and input_variable_values to be copied 
--  180119  ErFelk   Bug 139766, Added an implementation method Internal_Co_Line_Exists___(). Modified Check_Before_Update___() so that release_planning flag is NOT set to RELEASED if internal customer order line exists.
--  180112  MaAuse   STRSC-15714, Modified Modify_Staged_Billing method to fetch cost into attr_.
--  180111  DilMlk   Bug 139595, Modified Change_Package_Structure___ to prevent getting "Price less than zero" message when trying to reserve a CO with 100% discount added to CO Line for Package parts.
--  180111  RaVdlk   STRSC-15724, Copied 'supplier_ship_via_transit' and 'supplier_ship_via_transit_desc', when Delivery Information copy option is selected 
--  180111  MaEelk   STRSC-15727, Modified Copy_Customer_Order_LIne and made attr_ and new_attr_ null inside the get_order_line cursor loop.
--  180109  TiRalk   STRSC-13136, Modified Get_Serials_From_Demand_Info by adding OESHIP to show correct serials when register direct delivery
--  180109           for different company two sites IPD scenario. OESHIP has been removed earlier commit of this id, which has correctly added by BI-3266.
--  171228  KiSalk   Bug 139536, Stopped raising error message for DOP parts when supply codes 'IPT' &'IPD' in Check_Supply_Code___. 
--  171228  MaEelk   STRSC-15429, Corrected the line history message in Copy_Customer_Order_Line.
--  171220  MaEelk   STRSC-15350, Supply Codes 'Shop Order', 'Dop Order', 'Production Schedule' and 'Not Decided' were kept same when copying customer order lines.
--  171219  ErRalk   Bug 137175, Changes made to give priority to packing instruction in demand site if there's already defined packing instructions in both demand and supply site.
--  171214  ErFelk   Bug 139169, Modified Check_Before_Update___() and Check_Insert___() to set the release_planning flag inorder to facilitate availability check functionality.
--  171214           Modified Post_Insert_Actions___() and Check_Before_Update___() to reset the release_planning flag for all other sourcing options except inventory order.
--  171207  SBalLK   Bug 138918, Modified Set_Rel_Mtrl_Planning() and Update___() methods to validate update initiate during the customer order release to avoid
--  171207           creating connected orders since release process itself creates the connected orders.
--  171127  MAHPLK   STRFI-10886, Added new method Get_External_Tax_Info(), Added two our parameters to Get_Line_Address_Info(), 
--  171227           Modified Post_Insert_Actions___ and Update___ methods to fetch taxes from defaults when external tax calculation system has been used. 
--  171130  MaEelk   STRSC-14333, Copied Tax Information irrespective of the customer.
--  171128  MaEelk   STRSC-14333, Replaced the Copy Staged Billing Logic written in Create_Sourced_Co_Lines with a call to Copy_Staged_Billing___
--  171127  TiRalk   STRSC-13136, Modified Get_Serials_From_Demand_Info by removing MINUS logic which has included with transactions
--  171127           PODIRSH, INTPODIRSH, INTPODIRIM, PODIRINTEM. This correction has done by BI-3266 but as this method is used 
--  171127           only when Register Direct Delivery via transit we need only serials which has been delivery from internal CO.
--  171127  MaEelk   STRSC-12302, Called Order_Line_Commission_API.Copy_Manual_Commission_Lines to copy manual commission lines  in Copy_Customer_Order_Line.
--  171127  RaVdlk   STRSC-14780, Checked the value of free_of_charge when adding a new CO charge line
--  171127  RaVdlk   STRSC-14782, If the 'Invoiced block' check box is selected, copied it for the same customer scenario
--  171127  RaVdlk   STRSC-14780, Made the price details 0, when copying a CO with free of charge check box selected
--  171127  ApWilk   Bug 138679, Modified Check_Before_Update___ to restrict the replication dialog and prompt an error message when try to update the sales quantity in CO line 
--  171127           if there is a pegged order connected for a package part and added FUNCTION Check_Auto_Pegged_Comp_Exist.
--  171124  MaEelk   STRSC-14333, Added Copy_Staged_Billing___ to copy staged billing lines connected to an order line.
--  171124  ErRalk   Bug 137175, Modified Build_Attr_For_New___ to fetch packing instruction id from Get_Default_Part_Attributes___.
--  171121  UdGnlk   Bug 138594, Modified Calculate_Prices() to avoid price calculation for customer owned and supplier loaned stocks. 
--  171121  MaEelk   STRSC-14333, Copied Milestones in Copy_Customer_Order_Line 
--  171120  MaEelk   STRSC-14333, Copy Delivery Information Logic was moved from Copy_Order_Line to Build_Rec_For_Copy_Line___.
--  171120  MaEelk   STRSC-14333, Copy Tax Items were moved to Post_Insert_Actions___.
--  171117  MaEelk   STRSC-14333, Default_Addr_Flag was set to get the correct value Copy CO Functionality. Copy Options Delivery Information,
--  171117           Price and Discounts, Pre-Accounting were handled irrespective of the customer.
--  171117  RaVdlk   STRSC-13789, When Pricing and Discount is checked the discount lines are copied from the CO.  
--  171115  MaEelk   STRSC-14333, Enabled Copy Tax Detail option in Copy Customer Order Functionality. 
--  171115           Re-structured some codes in Copy_Customer_Order_Line and Build_Rec_For_Copy_Line___.
--  171110  MaEelk   STRSC-12302, Copied SALE_UNIT_PRICE and UNIT_PRICE_INCL_TAX
--  171108  MaEelk   STRSC-12302, Added Pricing Information  to Copy Customer Order Line. 
--  171102  UdGnlk   Bug 137594, Modified Post_Insert_Actions___() IF condition for discount by changing the values of copy_discount_ NVL.
--  171101  RaVdlk   STRSC-13840, Checked the value of COPY ORDER LINE when adding a new CO charge line, to fetch the Pack size charge lines when copying.
--  171030  MaEelk   STRSC-13747, Copy Delivery Information was considered when copying Delivery Information in CO Line. Copied Line address correctly.
--  171024  ChJalk   Bug 138240, Modified Check_Before_Update___ to change the shipment_creation method when the supply code is changed from 'PD' or 'SEO'.
--  171024  MalLlk   STRSC-12754, Removed the methods Get_Line_Total_Base_Amount().
--  171020  MaEelk   STRSC-13153, Copied Address information in Customer Order Line when copy option Address Information is given in Copy Customer Order Functionality.
--  171017  MaEelk   STRSC-13013, Modified the cursor get_order_line in copy_customer_Order_Line to filter records 
--  171017           where the demand code is not belonged to ('PO', 'DO', 'CRE', 'CRO', 'WO') and supply code is not belonged to ('MRO').
--  171016  DiKuLk   Bug 138039, Modified message content in UPDATE_NOT_ALLOWED_FSM in Modify_Additional_Discount__() , message constant of 
--  171017           Post_Insert_Actions___() from SHIPMENT_CHANGED to SHIPMENT_CHANGED_NEW and added three procedures, Raise_No_Update_Error___(), Raise_No_Update_Fsm_Error___() and Raise_Shipment_Chaged_New() to avoid overriding of language translation
--  171012  MaEelk   STRSC-12301, Restructured the Copy_Customer_Order_Line method and moved the code creating the newrec_ to Build_Rec_For_Copy_Line___ 
--  171012           Added code to copy custom fields in Customer Order Line.
--  171011  MaEelk   STRSC-12301, Added code to copy Configured Line Pricing in Copy Customer Order Functionalty.
--  171009  MaEelk   STRSC-12301, Added derived attribute COPY_ORDER_LINE so the TRUE value is passed in Copy Customer Order Line Functionality.
--  171004  MaEelk   STRSC-12301, Added Add_Rental_Info_To_Attr___ and called it from Copy_Customer_Order_Line when a rental line is going to be copied to a new Customer Order.
--  171004  MaEelk   STRSC-12301, Added new overloading method Copy_Customer_Order_Line. This will copy order lines and rental lines
--  171004           from an existing cutomer order to a new customer order according to the copy options passed in the parameter list.
--  170926  RaVdlk   STRSC-11152,Removed Get_State and Get_Objstate functions, since they are generated from the foundation
--  170922  Cpeilk   Bug 135315, Modified Unpeg_Line() by adding a default parameter unpeg_ipd_flag_. Removed IPD_NOT_ALLOWED error message and allowed IPD flow to proceed.
--  170913  ErFelk   Bug 137051, Modified Check_Update___() by calling Customer_Info_Address_API.Get_End_Customer_Id() if shipp_addr_no was changed.
--  170828  KiSalk   Bug 137545, Moved Handle_Activity_Seq___ to Post_Insert_Actions___ from Insert___ so that connected objects can fetch project detail from CO line while being created.
--  170824  ShPrlk   Bug 136668, Modified Get_Line_Defaults___ to adjust parameters for the method call Sales_Price_List_API.Get_Valid_Price_List and Modified Check_Insert___ to set price_list_no  correctly.
--  170811  ChBnlk   Bug 137266, Modify_Wanted_Delivery_Date__() by adding a new parameter 'MODIFIED_FROM_HEADER' to identify a change in the wanted_delivery_date_ and checked it inside the method
--  170811           Update___() in order to modify the delivery information of a connected Distribution order.
--  170809  UdGnlk   Bug 137138, Modified Update___() condition to check instead of newrec_.revised_qty_due to newrec_.buy_qty_due for the message LTMINIMUMQTY.
--  170801  BudKlk   Bug 137130, Modified the method Change_Package_Structure___() to make sure that we allow call the method Calculate_Order_Line_Dates___() when do_wanted() is true.
--  170728  ApWilk   Bug 136845, Modified Prepare_Insert___() to stop deliver_to_customer_no_ getting null and fetch the End customer information when adding a customer order line
--  170728           through a complementary part window.
--  170720  IzShlk   STRSC-10704, modified Pre_Unpack_Update___() to included 'SET_TAX_FROM_ORIGINAL', 'MULTIPLE_TAX_LINES', 'FETCH_TAX_FROM_DEFAULTS' to support update a value after Invoicing a CO. 
--  170706  PrYaLK   Bug 136384, Modified Get_Line_Defaults___() by adding a validation in order to prevent fetching Create SM Object check box value for rental lines.
--  170626  ErRalk   Bug 135979, Changed the error message constant from CONFIGSUPPSITE to CONFIGDELCTRY in Check_Update___. 
--  170614  ShPrlk   Bug 135986, Modified the condition in Validate_Update_Service_Con___ by including 'CUSTOMS_VALUE' to the list to allow update for order lines with supply code Service Order.
--  170522  niedlk   STRSC-8406, Change the size of new_attr_ in Pre_Unpack_Insert___() to avoid buffer too small error.
--  170512  MaIklk   STRSC-8368, Added Service_Management_Connect_API.Decode for converting db value when set SM_CONNECTION in Build_Attr_For_New___().
--  170515  NiNilk   Bug 134928, Modified Change_Package_Structure___() to make it enable to save the time of planned_ship_date of a customer order line with a package part
--  170515           and package components with supply code other than PD and IPD after being modified.
--  170511  MeAblk   STRSC-6420, Modified Remove_Project_Connection___() to avoid code part validation when disconnecting from a project activity disregarding the PO is cancelled.
--  170511  MeAblk   STRSC-6343, Avoided re-fetching delivery attributes when changing the supply code from IO to pegged/transit supply codes.
--  170506  ErFelk   Bug 133412, Modified Check_Insert___() and Check_Before_Update___() to set newrec_.release_planning flag only if the supply site Sourcing_Option is invent order and 
--  170506           supply_code is in IPT or IPD.
--  170506  CwIclk   Bug 135525, Passed TRUE as order_line_cancellation_ parameter to the calls Reserve_Customer_Order_API.Control_Ms_Mrp_Consumption().  
--  170418  DilMlk   Bug 134887, Modified Check_Before_Insert___ to make sure newrec_.rel_mtrl_planning check box is checked for Non Inventory parts before saving CO line.
--  170412  PrYaLK   Bug 134826, Modified Change_Package_Structure___ not to raise division by 0 error on calculating desired_qty of components when it is 0 in package header.
--  170411  KiSalk   Bug 135177, Made Connect_Customer_Order_API.Remove_Project_Connection called unconditionally in Remove_Project_Connection___.
--  170405  waSalk   Bug 132899, Modified Check_Update___() to add SENT_CONFIGURATION attribute to the attr if the configuration details are been sent when modifying.
--  170405           Modified Modify() by adding a condition so that only configuration related flow is pass through.
--  170324  TiRalk   LIM-10020, Modified Get_Info_For_Desadv to fetch the customer_part_desc_ for part lines as well.
--  170323  TiRalk   LIM-11166, Reversed the correction which is done through this task.
--  170323  NaLrlk   LIM-11163, Modified Get_Info_For_Desadv() to fetch customer po information for receiver_source_refs in IPD.
--  170322  Jhalse   LIM-10113, Added new method Uses_Shipment_Inventory.
--  170321  RuMelk   APPUXX-10011, Modified Build_Attr_For_New___ to set SM_CONNECTION_DB.
--  170321  NaLrlk   LIM-11230, Modified Modify_Connected_Order_Line___() to handle packing instruction in replicate changes.
--  170316  RoJalk   LIM-10061, Modified Get_Info_For_Desadv to send the demand code only when demand codes are 'IPT', 'IPD', 'DO', 'IPT_RO'.
--  170314  TiRalk   LIM-11166, Modified Check_Update___ to restrict editing Customer's PO Line No and Customer's PO Rel No when the CO line demand code is IPD.
--  170303  DilMlk   Bug 133558, Modified method call Create_Project_Connection___ by setting TRUE for replace_pre_posting_ parameter to replace the 
--  170303           coline's pre postings with project pre postings if it has value.
--  170217  MaIklk   LIM-10826, Removed Get_Note_Id() written in core layer and instead made note_id attribute public.
--  170214  MeAblk   Bug 134007, Modified Unpack_Check_Update___() to avoid re-fetching ship via code and delivery attributes when changing into Invent Order from some of pegged supply types.
--  170214           This can happen as aresult of unpegging or manual changing of the supply code.
--  170202  LaThlk   Bug 133797, Modified Check_Before_Insert___() by adding a condition in order to bypass user allowed site validation in online process flow.
--  170201  MeAblk   Bug 133759, Modified Handle_Activity_Seq__ () to pass the parameter skip_code_part_validation_ when removing the project connection as part of line cancelling. This is to avoid preposting code part validations.
--  170201  LaThlk   Bug 133169, Modified the Check_Insert___(), Check_Before_Update___() and Post_Insert_Actions___() by avoiding the change of the default_addr_flag in non-inventory 
--  170201           part lines and package part lines in CO in order to stop manual updates.
--  170125  MeAblk   STRSC-5210, Modified Check_Insert___() and Check_Update___() to correctly trunc the planned_due_date.
--  170125  MeAblk   STRSC-5269, Added method Set_First_Actual_Ship_Date() to set the first actual ship date of a CO line.
--  170124  JeeJlk   Bug 133724, Reversed the bug 122944.
--  161228  MalLlk   FINHR-5040, Introduced Tax Calculation Structures.
--  161222  MaIklk   LIM-8387, Added Receiver_Type as parameter when calling Add_Source_Line_To_Shipment().
--  161221  TiRalk   LIM-10095, Modified Get_Info_For_Desadv to fetch no part description.
--  161215  NiNilk   Bug 133083, Added an error msg to avoid unchecking the check box rel_mtrl_planning, when going to save a customer order line with a package part.
--  161209  KiSalk   Bug 132783, Stopped recalculating price if supply code is Service order, in Check_Update___.
--  161206  ChBnlk   STRSC-4284, Added a check to block automatic sales part substitution for internal customer orders and 
--  161206           removed the corrections done in Check_Before_Insert___() and Check_Before_Update___() to bypass the error message REPARTEXISTS.
--  161205  RoJalk   LIM-9774, Added the method Get_Info_For_Desadv to fetch order specific values for dispatch advice LINE segment.
--  161201  VISALK   STRMF-8432, Modified Post_Insert_Actions___(),Peforme_Capablity_Check__() to show the info message when performing CTP. 
--  161128  ChBnlk   STRSC-4284, Modified Pre_Unpack_Insert___() to check and substitute a sales part the requires automatic substitution and to refetch the part specific information.
--  161128           Modified Build_Attr_For_New___() to add BUY_QTY_DUE to the attr_. Modified Check_Before_Insert___() and Check_Before_Update___() to bypass the error message REPARTEXISTS
--  161128           when using automatic substitution.
--  161128  ThEdlk   Bug 129647, Modified Modify_Order_Defaults__() to update the value of tax_liability in customer order lines as to the changes done in header 
--  161128           when the default address flag of the line is unticked .
--  161031  ErFelk   Bug 131702, Modified Modify_Order_Defaults__() to update the REGION_CODE and DISTRICT_CODE fields only if the default_addr_flag is 'Y' and when the
--  161031           state is in Delivered or Invoiced/Closed. Code written from bug 129991 was changed from this bug.
--  161027  VISALK   STRMF-7237, Modified Peforme_Capablity_Check__(), Update_Planning_Date() to modify the info message and update some attributes in the InterimCtpCriticalPath Lu.
--  161026  RoJalk   LIM-8391, Replaced Shipment_Handling_Utility_API.Remove_Shipment_Lines with Shipment_Line_API.Remove_Shipment_Lines.
--  161020  NWeelk   FINHR-3143, Removed method Synchronize_Tax_Data.
--  161004  MeAblk   GG-103, Modified several methods to handle order lines created from FSM having the demand code as "FSM".
--  161003  SWeelk   Bug 131145, Modified Check_Insert___() and Check_Update___() to recalculate the value of revised_qty_due.
--  160921  ApWilk   Bug 131040, Modified Update___() to check whether the rowstate is not in Delivered,PartiallyDelivered,Invoiced, and Cancelled states in order to 
--  160821           stop getting the error when it tries to create a new charge line in receiving RMA.
--  160907  DilMlk   Bug 131236, Modified method Delete___ by adding NVL to parameter activity_seq, when call to method Reserve_Customer_Order_API.Control_Ms_Mrp_Consumption()
--  160824  ThEdlk   Bug 130823, Modified Create_Sourced_Co_Lines() by passing the rel_no accordingly.
--  160823  MaIklk   LIM-8426, Handled to popup message when changing customs value if order line is connected to shipment.
--  160805  KiSalk   Bug 130410, In Check_Before_Insert___ and Check_Before_Update___, setting ownership to Company Rental Asset restricted for internal deliveries.
--  160722  MaIklk   LIM-8053, Renamed SHIPMENT_CREATION to SHIPMENT_CREATION_CO in shipment_type_tab.
--  160721  BudKlk   Bug 129991, Modified the method Modify_Order_Defaults__() to update the value of the region code when the customer order region code is changed in order to avoid the erros happen when er-running the postings.
--  160714  ThEdlk   Bug 130021, Modified Check_Before_Insert___() to pop up an info message when creating a customer order for configured parts to an internal customer. 
--  160629  TiRalk   STRSC-2702, Changed the places where it has used CreditBlocked from CustomerOrder has changed to state Blocked.
--  160628  MUSHLK   STRMF-2197, Enabled the customer order line creation for CRO orders for dop parts.
--  160628  MalLlk   FINHR-1818, Added methods Get_Line_Total_Base_Amount and Get_Line_Address_Info.
--  160623  SudJlk   STRSC-2698, Replaced Cust_Order_Line_Address_API.Public_Rec with Cust_Order_Line_Address_API.Co_Line_Addr_Rec and 
--  160623           Cust_Order_Line_Address_API.Get() with Cust_Order_Line_Address_API.Get_Co_Line_Addr()
--  160623  SudJlk   STRSC-2697, Replaced customer_Order_Address_API.Public_Rec with customer_Order_Address_API.Cust_Ord_Addr_Rec and 
--  160623           customer_Order_Address_API.Get() with customer_Order_Address_API.Get_Cust_Ord_Addr().
--  160614  LaThlk   Bug 129445, Modified Insert___() in order to ready the project connected line with non-inventory part for the delivery.
--  160609  AyAmlk   APPUXX-1530, Modified Check_Update___() allow updating the demand code and demand code references for CO line created from SQ that were added from shopping cart.
--  160608  MaIklk   LIM-7442, Changed calls like Invalidate_Pre_Ship_Delnote due to moving delivery note to shpmnt.
--  160608  SWeelk   Bug 129410, Modified Update___() and Change_Package_Structure___() so that promised delivery date in a component line of a Cancelled Package part can be modified.
--  160606  ChBnlk   STRSC-2001, Modified the error message NONEWLINES in Check_Insert___() to allow creation of new order lines when the customer order is delivered.  
--  160526  ErFelk   Bug 128475, Modified Check_Insert___() by calling Assortment_Node_API.Get_Classification_Defaults() to get values to classification_part_no and
--  160526           classification_unit_meas when classification_standard is been defined.
--  160520  ErFelk   Bug 128983, Modified Post_Insert_Actions___() by adding a condition to avoid inserting manual discount lines when inserting Complementary Parts. 
--  160520           The value for the condition copy_discount was passed form the client.
--  160516  ThEdlk   Bug 129172, Modified Check_Common___() by checking whether revised_qty_due is getting an integer to match the requirement of having an integer for the qantity of serialized parts.
--  160518  SWeelk   Bug 128826, Modified Modify_Wanted_Delivery_Date__() by adding 'SERVER_DATA_CHANGE' to the attribute string to make possible to edit the discount when
--  160510           changing the wanted_delivery_date in the header
--  160516  NWeelk   STRLOC-415, Modified Post_Insert_Actions___ to update free_of_charge_tax_basis correctly for package parts.
--  160512  ChJalk   Bug 128646, Added the method Get_Uncancelled_Pkg_Line_Count.
--  160512  RoJalk   LIM-6946, Added the method Get_Inv_Qty_To_Ship_Connect to return qty available to connect to shipment.
--  160506  MeAblk   Bug 128168, Modified Get_Supply_Chain_Defaults___() to have the header ship_addr_no as a new parameter to avoid overriding header values when adding a new line.
--  160503  LaThlk   Bug 128591, Modified the method Check_Before_Update___ to avoid date calculation when canceling the CO Line.
--  160426  NWeelk   STRLOC-360, Modified Get_Sale_Price_Total and Get_Sale_Price_Incl_Tax_Total to set order line totals correctly for free of charge lines.
--  160420  NWeelk   STRLOC-244, Modified method Build_Attr_For_New___ to set free of charge data when the CO is created from a quotation.
--  160411  MalLlk   FINHR-1515, Added method Get_Total_Discount_Incl_Tax() to retrieve the total discount amount incluging tax for PIV scenario.
--  160331  RoJalk   LIM-6804, Renamed Shipment_Line_API.Update_From_Order_Line to Update_From_Source_Line. 
--  160324  SBalLK   Bug 128014, Modified Update_License_Connect_Head__() by adding validation for configuration_id since effect on the component when configuration rules are defined.
--  160325  NWeelk   STRLOC-242, Added method Get_Comp_Bearing_Tax_Amount to show the tax amount when the company pays tax for free of charge lines,
--  160325           Modified Get_Total_Tax_Amount_Curr and Get_Total_Tax_Amount_Base to consider free_of_chg_tax_pay_party_.
--  160310  NWeelk   STRLOC-257, Modified methods Update___ and Check_Update___ to set rebate_builder to false for free of charge lines.
--  160309  NWeelk   STRLOC-236, Modified methods Post_Insert_Actions___ and Update___ to stop creating commission lines for free of charge lines.
--  160310  NWeelk   STRLOC-259, Modified Calc_Free_Of_Charge_Tax_Basis to consider currency conversions.
--  160309  NWeelk   STRLOC-237, Modified Post_Insert_Actions___ to exclude free of charge lines from sales promotions. 
--  160304  MeAblk   Bug 127748, Modified Do_Uninvoice_Pkg_Component___() to correctly set the package component qty_invoiced when cancelling preliminary invoice.
--  160302  NWeelk   STRLOC-191, Modified method Update___ to execute tax calculation if the free_of_charge_tax_basis is changed,
--  160302           added free of charge line tax info to method Get_Tax_Info, added method Calc_Free_Of_Charge_Tax_Basis and added error message CANTCHGPRICE 
--  160302           to Check_Common___ to be raised if the prices changed for free of charge lines.
--  160301  RoJalk   LIM-6300, Added the method Check_Qty_To_Reserve.
--  160225  ChFolk   STRSC-860, Modified Calculate_Order_Line_Dates___ and Perform_Capability_Check___ to support newly added parameters transport_leadtime and arrival route id 
--  160225           in methods Cust_Order_Leadtime_Util_API.Get_Default_Leadtimes and Cust_Ord_Date_Calculation_API.Calc_Due_Date_Forwards.
--  160225  MaRalk   LIM-4102, Modified method Make_Service_Deliverable__ by moving the setting of shipment line qty_to_ship to 
--  160225           Shipment_Handling_Utility_API.Modify_Shipment_Qty_To_Ship method. Also referred shipment line record quantity values
--  160225           and order line quantities instead of Shipment_Line_API.Get_Deliverable_Quantities method call within the same method.
--  160225           Removed method Get_Deliverable_Qty. 
--  160219  MeAblk   Bug 126305, Added method Do_Uninvoice_Pkg_Component___() and Do_Uninvoice_Pkg_Head_State___() in order to correctly set the package component status and qty_invoiced correctly.
--  160219  AyAmlk   Bug 127038, Modified Unpack_Check_Update___() in order to prevent updating the sale_unit_price/ base_sale_unit_price/price values including tax
--  160219           when the price freeze flag is set and the CO header wanted delivery date is changed. Also added a condition to prevent updating the discount when
--  160219           discount freeze at price freeze is used.
--  160219  SBalLK   Bug 127171, Modified Update_Planning_Date() method to activate DELIVERY_DATE_OR_QTY_CHANGED event after the actual table update through the Update_Line___() method.
--  160216  DipeLK   STRLOC-28, Added new validation for free of charge lines to check_common___
--  160215  MaRalk   LIM-4102, Modified Make_Service_Deliverable__- get_ship_connected_lines cursor by replacing shipment_line_tab
--  160215           with shipment_line_pub. Added additional condition for source_ref_type.
--  160210  MAHPLK   FINHR-641, Added new attributes COUNTRY_CODE and TAX_LIABILITY_TYPE and new method Modify_Country_Code().
--  160210  MalLlk   FINHR-625, Added Add_Transaction_Tax_Info___ to add tax lines to source_tax_item_tab. 
--  160210           Modified Post_Insert_Actions___ and Update___ to use method Add_Transaction_Tax_Info___.
--  160202  IsSalk   FINHR-647, Redirect method calls to new utility LU TaxHandlingOrderUtil.
--  160202  MaIklk   LIM-6123, Changed Shipment_Handling_Utility_API.Add_Order_Line_To_Shipment method call to Add_Source_Line_To_Shipment().
--  160127  RasDlk   Bug 125466, Modified Refresh_Project_Connection to change the calculation of progress_cost for 'PT', 'PD', 'IPT', 'IPD' supply codes.
--  160122  ThEdlk   Bug 124315, Modified Post_Insert_Actions___() and Check_Before_Update___() to trigger an info message when changing the value 'shipment creation method' of pkg to 'NO AUTO CREATION'
--  160122           when any of the component line's shipment creation is 'NO AUTO CREATION'.
--  160111  RoJalk   LIM-5524, Included Source_Ref_Type when calling Shipment_Line_API.Modify_Qty_To_Ship.
--  160106  RoJalk   LIM-4095, Added source_ref_type_db_ to Shipment_Handling_Utility_API.Add_Order_Line_To_Shipment method call.
--  160105  PrYaLK   Bug 125877, Modified method Validate_Proj_Connect___ to change the supply_code when connecting a project activity to a package component line.
--  160104  RoJalk   LIM-5717, Replaced Shipment_Handling_Utility_API.Create_Automatic_Shipments with Shipment_Order_Utility_API.Create_Automatic_Shipments.
--  151230  IsSalk   FINHR-429, Added Get_Tax_Info() and Modify_Tax_Info();
--  151222  ApWilk   Bug 125475, Modified Change_Package_Structure___ to exclude the PD and IPD lead times in calculating planned_ship_date of package header,
--  151222           if there are other supply codes in package components.
--  151221  NipKlk   Bug 126037, Reversed the correction done by the bug 123920.
--  151217  DilMlk   Bug 125873, Modified Validate_Proj_Disconnect___ to allow cancelling project connected CO lines with PD and IPD supply codes.
--  151210  AyAmlk   Bug 126078, Modified Update___() and Check_Update___() by increasing the variable length of price_source_ in order to prevent
--  151210           raising oracle error for the client values which exceeds 15 characters for the Price Source.
--  151202  RoJalk   LIM-5178, Rename ORDER_NO, LINE_NO, REL_NO, LINE_ITEM_NO to SOURCE_REF1,
--  151202           SOURCE_REF2, SOURCE_REF3, SOURCE_REF4 in ShipmentLine and ShipmentLineHandlUnit. 
--  151119  RoJalk   LIM-4886, Make Shipment Line Generic - Rename SALES_QTY to SHIPMENT_QTY, REVISED_QTY_DUE to INVENTORY_QTY.
--  151119  IsSalk   FINHR-327, Renamed attribute VAT_NO to TAX_ID_NO in Customer Order Line and Customer Order.
--  151110  RoJalk   LIM-4610, Rename ShipmentOrderLine LU to ShipmentLine.
--  151105  MeAblk   Bug 125400, Removed method Qty_Shipped_Ok___ and replaced it by Is_Any_Delivery_Exist___ in order to correctly handle the package components. 
--  151105           Accordingly modified the events in the model.
--  151105  KiSalk   Bug 121540, Modified Init_Before_Check_Insert___, not to reset cost when CO line has supply code Service Order.
--  151103  IsSalk   FINHR-316, Renamed attribute FEE_CODE to TAX_CODE in Customer Order Line.
--  151103  MalLlk   FINHR-312, Removed methods Get_Total_Discount() and Get_Total_Discount_Unrounded().
--  151023  MalLlk   FINHR-139, Added methods Get_Total_Discount_Amount() and Get_Total_Discount_Percentage().
--  151021  IsSalk   FINHR-197, Used FndBoolean in taxable attribute in sales part.
--  151015  HimRlk   Bug 124366, Modified Unpack_Check_Insert___ by passing demand_code parameter to Source_Order_Lines_API.Source_Automatically__.
--  150915  RoJalk   AFT-1680, Modified the method Modify_Connected_Order_Line___ and checked for newrec_.qty_on_order instead of oldrec_.
--  150910  KhVeSE   AFT-1616, Modified Modify_Connected_Order_Line___() to consider COPY_ADDR_TO_LINE value when setting ipd_replication_.
--  150909  KhVeSE   AFT-1616, Modified Update___() mehtod to consider COPY_ADDR_TO_LINE value when setting replication_not_needed_ in copying 
--  150909           address from header to non default lines senarios. Also added new method Check_Address_Replication__()
--  150908  Wahelk   AFT-4157, Modified Refresh_Project_Connection to use PURCH conditional compilation constant
--  150907  TiRalk   AFT-3548, Modified Line_On_Delivery_Note to fetch data properly by the cursor. 
--  150903  KhVeSE   AFT-3410, Added new parameter copy_addr_to_line_ to the method Validate_Fee_Code___() to get correct tax information when copying 
--  150903           address from header to non default lines and address change from delivery address to Single Ocurrence. Also modified Check_Update___()
--  150903           to handle the corresponding scenario.
--  150825  MAHPLK   KES-1343, Added new default parameter add_hist_log_ to Set_Qty_Picked().
--  150819  MAHPLK   KES-1343, Added new default parameter from_undo_delivery_ to Set_Qty_Shipped(). 
--  150728  IsSalk   KES-1124, Modified Undo_Delivery() to update order line history when undoing a CO delivery for non inventory parts.
--  150710  Hecolk   KES-1027, Cancelling Preliminary Self-Billing CO invoice
--  150706  Hecolk   KES-880, Cancelling Preliminary Staged Billing CO invoice
--  150626  IsSalk   KES-870, Modified Undo_Delivery to correct spelling mistakes.
--  150724  NaLrlk   RED-725, Modified Check_Before_Insert___() and Check_Before_Update___ to allow supplier rented ownership for non-inventory sales part.
--  150701  KhVeSE   COB-14, Added 'IN_CITY' to attribute string in method Insert_Default_Address___().
--  150630  KhVeSE   COB-14, Modified Modify_Order_Defaults__() method by moving the attribute string manipulation to seperate method. Introduced new method Build_Attr_For_Modfy_Ord_Def__()
--  150630           for the attr_ manipulation. Also created new method Modify_Delivery_Address__().
--  150529  Hecolk   KES-538, Adding ability to cancel preliminary Customer Order Invoice
--  150528  MAHPLK   KES-508, Added new methods Undo_Delivery () and Do_Undo_Delivery___().
--  150526  IsSalk   KES-510, Modified cursors with Customer_Order_Delivery_TAB to filter out cancelled CO deliver lines.
--  150512  MAHPLK   KES-402, Renamed usages of order_no, release_no, sequence_no, line_item_no, order_type attributes of 
--  150512           InventoryTransactionHist to source_ref1, source_ref2, source_ref3, source_ref4, source_ref_type.
--  150611  ChBnlk   ORA-405, Modified New() and Create_Sourced_Co_Lines() by moving the attribute string manipulation to seperate methods. Introduced new method Build_Attr_For_New___()
--  150611           and Build_Attr_Sourced_Co_Lines___() for the attr_ manipulation. 
--  150915  SWiclk   Bug 124312, Modified Pre_Unpack_Insert___() in order to fetch deliver_to_customer's delivery address if no delivery address has been passed.
--  150910  ErFelk   Bug 123263, Reversed the previous correction of this bug.
--  150901  PrYaLK   Bug 121587, Modified Check_Before_Update___() to avoid the re-calculation of customer_part_buy_qty when the data is changed from client side.
--  150831  ChBnlk   Bug 123920, Added if condition to set the planned delivery date as target date only if the date is changed of the target date, 
--  150831           without only changing the time of target date in Unpack_Check_Update___().
--  150831  SBalLK   Bug 124163, Modified Validate_Vendor_No___() to check if the vendor_no is valid.
--  150819  PrYaLK   Bug 121587, Modified Update_Line___(), Get_Line_Defaults___(), Insert___(), Get_Default_Part_Attributes___(),
--  150819           Check_Before_Update___() and Get_Cust_Part_No_Defaults__() by adding cust_part_invert_conv_fact.
--  150817  RasDlk   Bug 120649, Added the method Get_Expctr_License_Order_Type.
--  150817           Modified Check_Delete___, Delete___, Post_Insert_Actions___, Update_License_Connect_Head__ and Check_Delete_Exp_License___
--  150817           to fetch the licensed_order_type_ correctly. 
--  150817           Modified Is_Expctr_Connected by passing the correct value for licensed_order_type_.
--  150728  KiSalk   Bug 123788, Added derived attribute 'PART_REPLACEMENT_ALLOWED', to be set as 0 in new line creation to stop changing catalog No with replacement part.
--  150728  ChBnlk   Bug 122944, Modified Update___ and Create_Sourced_Co_Lines to pass values to the parameter amount_changed_ in method call
--  150728           Order_Line_Staged_Billing_API.Recalculate.
--  150721  PrYaLK   Bug 123556, Modified Validate_Fee_Code___ in order to restructure the condition to fetch delivery_country_db_ in situations where
--  150721           the single occurrence and default info is used in CO line level and when single occurrence is used in CO header level. 
--  150720  ErFelk   Bug 123263, Modified Post_Insert_Actions___() so that CO header tax liability is modified when saving a line and display an info message.  
--  150713  AyAmlk   Bug 121498, Modified Update___() in order to allow fetching the discount info when buy_qty_due is changed and the change_request_ variable is NULL.
--  150710  HimRlk   Bug 122919, Modified Calculate_Order_Line_Dates___() to fetch default leadtime values in a Distribution Order flow.
--  150706  PeSulk   Bug 123160, Modified Validate_Proj_Connect___ to stop unreleased activities being connected to lines in a released Customer Order.
--  150626  BudKlk   Bug 123185, Modified the method Pre_Unpack_Insert___() to get the default value for COST only if the Check Capability checkbox is unchecked.
--  150608  SBalLK   Bug 121499, Modified Unpack_Check_Insert___ to stop raising PROJ_NEW error when the CO line is created from external service order.
--  150603  MeAblk   Bug 122829, Modified Check_Before_Update___ in order to handle the planned delivery date/time change when planned ship date/time is changed.
--  150529  RasDlk   Bug 122564, Modified Unpack_Check_Update___ by adding a condition to check whether the supply site reserve type is changed.
--  150529           Added a new error message to guide the user how to continue the customer order.
--  150525  JeeJlk   Bug 122563, Modified Check_Update___ not to fetch default tax code when planned ship date changed.
--  150521  ShKolk   Bug 122691, Modified Update___() to add charge lines if delivery terms are modified. 
--  150421  KiSalk   Bug 122154, In Post_Insert_Actions___, stopped raising error ACTIVITYNOTINST if newrec_.activity_seq is null
--  150323  JoAnSe   MONO-109, Removed inter-site restriction for Periodic Weighted Average parts in Check_Before_Insert___ and Check_Before_Update___.
--  150317  JeLise   COB-145, Added demand_code 'IPT' in cursor in Get_Parent_Cust_Order.
--  150309  CPriLK   ANPJ-22, Removed the object_staus from project_connection_util_api related method calls.
--  150901  VISALK   STRMF-124, Changed the DOP_ID data type into VARCHAR2(12).
--  150716  MalLlk   FINHR-74, Removed the method Get_Ipd_Vat_Liability and replaced the usages from Tax_Handling_Util_API.Get_Ipd_Tax_Info.
--  150227  MeAblk   EAP-970, Modified Pre_Unpack_Insert___ in order correctly pass the attribute sent from the client into the method Check_Default_Addr_Flag___. 
--  150227  NaSalk   PRSC-6310, Modified Get_Owning_Cust_After_Delivery considering CRA and SR ownerships.
--  150226  RasDlk   PRSC-4595, Added parameter refresh_vat_free_vat_code_ to the method Modify_Order_Defaults__() and modified it in order to
--  150226           set the fee code of the CO line according to CO header.
--  150226           Added a check for supply country in Update___() when refetching taxes.
--  150225  RoJalk   PRSC-4133, Modified Check_Update___ and used change_request_ instead of replicate_changes_ to identify IPD line update from ORDCHG. 
--  150224  DilMlk   Bug 120961, Moved the condition which assigns a value for project_id from Insert___ method to Post_Insert_Actions___, in order to fetch the 
--  150224           project_id from inserted CO line. Removed proj_unique_sale_ and order_project_id_ varibles from Insert___ and added them to Post_Insert_Actions___.
--  150223  RoJalk   PRSC-4133, Modified Check_Update___ and used the replicate_changes_ variable to identify IPD line update from ORDCHG.
--  150220  MAHPLK   PRSC-5852, Added new public method Check_Ipd_Pd_Comp_Exist(). Modified Modify_Connected_Order_Line___ to handle package component parts.
--  150220  ChJalk   PRSC-6233, Checked whether Purch is Installed before calling Purchase_Part_Supplier_API.Get_Currency_Code.
--  150218  ShKolk   PRSC-5731, Removed rounding from Get_Gross_Amnt_Ratio_Per_Vat__ as the correct calculation is handled from client.
--  150218  NaLrlk   PRSC-6168, Modified Copy_Customer_Order_Line() to include rental information.
--  150217  Chfose   PRSC-5905, Modified Calculate_Order_Line_Dates___ to change promised_delivery_date when no order confirmation exists instead of only in state 'Planned'.
--  150213  SURBLK   PRSC-6101, Added price values into attr, since Removed Calculate_Prices() in Get_Default_Part_Attributes___().
--  150213  MAHPLK   PRSC-5825, Removed method Check_Exist_For_Purord().
--  150211  MAHPLK   PRSC-5852, Added new parametrer changed_attrib_not_in_pol_ to Modify_Wanted_Delivery_Date__().
--  150211  NaLrlk   PRSC-6041, Modified Exist_Vendor_No___() to entend the functionality for rentals.
--  150210  ChJalk   PRSC-5783, Modified Updae___ to correctly round the unit_price_incl_tax before calling Modify_Discount__.
--  150209  HimRlk   PRSC-5606, Modified Check_Update___  to set supply_site_reserve_type to NOTALLOWED if the supply code is changed after releasing the order.
--  150208  MAHPLK   PRSC-5825, Added new method Check_Exist_For_Purord().
--  150206  NaSalk   PRSC-6003, Modified Updae___ to fetch project currency type only when unique billing is used.
--  150206  Vwloza   PRSC-5997. Updated Check_Update___ with an acquisition type check from supplier for purchase part.
--  150206  MeAblk   EAP-970, Modified Pre_Unpack_Insert___ in order to correctly set the default addr flag when an order lined is duplicating.
--  150205  Chfose   PRSC-5794, Rephrased the NO_REMOVE error message in Check_Delete___ to include rowstate.
--  150202  NWeelk   Bug 120817, Modified Modify_Delivery_Data by adding parameter revised_qty_due_ to the method to be able to 
--  150202           update revised_qty_due when modifying the connected distribution order.
--  150129  ChJalk   EAP-974, Modified Check_Before_Update___ to calculate planned_delivery_date from work time calendar before calling Calculate_Order_Line_Dates___.
--  150129  ShKolk   PRSC-5063, Removed re-calculating prices from Get_Line_Defaults___ and Get_Default_Part_Attributes___ as line info is not available before saving the line.
--  150129  MAHPLK   PRSC-4770, Merged Bug 119576, Modified Check_Update___() by removing a code which set the default_addr_flag to 'Y' when header and line ship_via_code, 
--  150129           addr_flag and vendor_no are the same. 
--  150129           Bug 119576, Added new method Modify_Line_Default_Addr_Flag() and Check_Default_Addr_Flag___() so that it correctly set the default address flag 
--  150129           by comparing the header and the line address details. Removed Modify_Line_Delivery_Info__().  
--  150128  SlKapl   PRSC-5757, Added Customer_Order_Charge_Util_API.Recalc_Percentage_Charge_Taxes method call to Post_Insert_Actions___, Update___, Remove__
--  150128  Vwloza   PRSC-5690. Updated Check_Update___() with a non-rental validation for company rental assets and supply codes.
--  150126  Chfose   EAP-359, Moved error and check for when supply code is IPD to Unpeg_Line instead of Unpeg__ to also account for when Unpegging via POL.
--  150121  NaLrlk   PRSC-4956, Modified Update___() to recalculate group discount for rental lines when chargeable days change.  
--  150120  HimRlk   PRSC-5042, Modified Get_Supply_Chain_Defaults___ to override the defaults values with the passed in values for delivery terms and del terms location.
--  150114  Chfose   EAP-359, Added error and check for when supply code is IPD in Unpeg__.
--  150113  RoJalk   PRSC-5028, Modified Modify_Connected_Order_Line___ and added a NVL for forward_agent_id and ship_via_code comparison.
--  150112  UdGnlk   PRSC-5024, Recorrect condition in Update___() for logic to recalculate tax lines inlcuding use_price_incl_tax.  
--  141222  UdGnlk   PRSC-4648, Modified Update___() by including newrec_.unit_price_incl_tax logic to recalculate tax lines. 
--  141218  RoJalk   PRSC-4387, Modified Line_Is_Fully_Invoiced___ and checked for order line state to skip the state machine proceeding as soon as order line is created from WO returns.
--  141218  SBalLK   Bug 118543, Modified Get_Backlog_Value_Ord_Curr___() method by handling NVL in gross and net amount and the tax percentage.
--  141216  Vwloza   PRPJ-3787, Updated Validate_Proj_Connect___() with an RCO check. Removed an older RCO validation from Handle_Activity_Seq___().
--  141216  ErFelk   Bug 118530, Modified Update___() so that the discount is updated in Cust_Order_Line_Discount_Tab when it comes from a change request and
--  141216           if it is a change request, not to call Customer_Order_Pricing_API.Modify_Default_Discount_Rec().
--  141215  MAHPLK   PRSC-4493, Modified derived attribute col_change_requestto changed_attrib_not_in_pol
--  141215  Hecolk   PRFI-3507, Additional Issues - Calculation errors when Tax liability is EXEMPT irrespective of Project connection  
--  141214  SBalLK   Bug 118543, Added Get_Backord_Value_Base_Curr___(), Get_Backlog_Value_Ord_Curr___() and Get_Backlog_Value_Base_Curr___() method to reuse the codes for new method.
--  141214           Modified Get_Backlog_Value_Base_Curr__(), Get_Backlog_Value_Order_Curr__() and Get_Backord_Value_Base_Curr__() method to re use new implimentation methods.
--  141214           Get_Backord_Value_Base_Curr(), Get_Backlog_Value_Base_Curr() methods to use in customer 360 outstanding order summary calculation.
--  141213  ErSrLK   PRMF-1600, Merged LCS Patch 117247.
--  141213  ErSrLK   Bug 117247, Added Get_Elements_From_Manuf_Ord___() to return planned project costs for Shop Order and DOP supply types.
--  141213           Modified Insert___() and Update___() to reflect activity information changes to the connected Interim Demand Header.
--  141203  Ersruk   PRPJ-2234, Created method Create_Project_Connection().
--  141203  RoJalk   Bug 119322, Modified Calculate_Order_Line_Dates___() by adding NVL to oldrec_.ship_via_code in a condition so that delivery_leadtime_ is fetched
--  141203           when a record is getting inserted. 
--  141202  Hecolk   PRFI-3507, Modified in Update___ to set the correct currency rate when connecting and disconnecting a project activity sequence.
--  141201  SBalLK   PRSC-3709, Modified Get_Supply_Chain_Defaults___() and Check_Insert___() methods to fetch delivery terms and delivery terms location from supply chain matrix.
--  141201  RoJalk   PRSC-4341, Modified Get_Send_Change_Msg_For_Supp to use Supplier_API.Get_Send_Change_Msg_For_Supp method.
--  141128  RoJalk   LCS 119048 merge, Modified Calculate_Order_Line_Dates___ to fetch delivery_leadtime by calling Cust_Order_Leadtime_Util_API.Get_Default_Leadtimes.
--  141128           For transit deliveries when the ship_via_code gets changed from demand site, leadtime should be fetched from site matrix and update the internal CO line.
--  141124  NaLrlk   Added Get_Rental_Line_Total() to calculate gross_curr_ammount and net_curr_amount according to the use_price_incl_tax value.
--  141124  MAHPLK   PRSC-380, modified Cust_Ord_Date_Calculation_API.Calc_Order_Dates_Backwards method call by passing rowstate as parameter.
--  141121  HimRlk   Modified Update___ method to send address replication after changing the address information in customer order line.
--  141122  JeeJlk   Bug 118992, In Validate_Update_Service_Con___, allowed changing CUSTOMER_PO_LINE_NO and CUSTOMER_PO_REL_NO disregard of supply code.
--  141120  RoJalk   PRSC-4338, Modified Check_Configuration_Id_Ref___ and added missing dynamic call.
--  141118  NaSalk   Added Rental_Is_Completed method.
--  141118  JeLise   Added new methods Get_Total_Qty_Returned and Get_Total_Qty_Shipped to be used from purch.
--  141112  NiDalk   Bug 119475, Modified Get_Sale_Price_Incl_Tax_Total and Get_Sale_Price_Excl_Tax_Total to round total_gross_amount_ before calculating discounts.
--  141110  RoJalk   Moved the replication code in Update___ to the mtehod Modify_Connected_Order_Line___.
--  141107  ChJalk   PRSC-3412, Modified the method New to change the default discount type when uses copy_discounts.
--  141107  NaSalk   Modifed the parameters of Order_Proj_Revenue_Manager_API.Get_Planned_Revenue_Elements inside Refresh_Project_Connection.
--  141105  SBalLK   PRSC-421, Modified Pre_Unpack_Insert___() method by removing codes where set delivery location to NULL when line and header delivery location changed and fetched from the agreement.
--  141103  SudJlk   Bug 119459, Modified Update_Planning_Date to trigger event action DELIVERY_DATE_OR_QTY_CHANGED when the Co line's planned delivery date has changed.
--  141029  RoJalk   Modified Update___ and Called Connect_Customer_Order_API.Modify_Connected_Order_Line when region_code, district_code, cust_calendar_id, packing_instruction_id, contact is changed.
--  141022  ChJalk   PRSC-3789, Modified the method Update___ to remove the check to see the price_freeze flag and discount_freeze flag for re-calculating the discount.
--  141021  NaLrlk   Added Rental_Is_Completed___(), Set_Rental_Completed() and Set_Rental_Reopened() to status handling for rental order line invoicing.
--  141020  UtSwLK   PRMF-3051, Added method custom method Check_Configuration_Id_Ref___().
--  141015  RoJalk   Modified Post_Insert_Actions___ and added a Get_Object_By_Keys___ method call to fetch the latest values for newrec_ before calling Update_Line___.
--  141015  Ersruk   PRPJ-2897, Modified Refresh_Project_Connection to make 'PT' include_in_ev_ is TRUE.
--  141013  UdGnlk   PRSC-3138, Modified Check_Before_Update___() to include the discount freeze functionality.
--  141013  UdGnlk   PRSC-3138, Modified Update___() to include the discount freeze functionality.
--  141010  CHSMLK   PRPJ-2626, Added demand code 'IO' to the list where EV is enabled
--  141009  AyAmlk   Bug 119076, Modified Unpack_Check_Update___() in order to prevent calculating the cost when the line status is PartiallyDelivered.
--  141008  SlKapl   FIPR19 Multiple tax handling in CO and PO flows - prepare Customer Order for Localization Hooks, renamed Cust_Order_Line_Tax_Lines_API.Add_Tax_Lines to Cust_Order_Line_Tax_Lines_API.Add_All_Tax_Lines
--  141001  MAHPLK   Modified Update___ by moving Connect_Customer_Order_API.Modify_Connected_Order_Line to after the super() method call.
--  140930  RoJalk   Removed the obsoloete method Feedback_From_Manufacturing.
--  140925  NaLrlk   Modified Handle_Activity_Seq___(), Rental_Is_Fully_Invoiced___() methods to exclude demand code IPR_RO(used by rental replacement).
--  140923  MAHPLK   Removed Get_Internal_Co_Qty__.
--  140919  NaLrlk   Modified Pre_Unpack_Insert___,Validate_Proj_Disconnect___, Handle_Activity_Seq___, Rental_Is_Fully_Invoiced___, Get_Qty_Shipped_And_State, Get_Internal_Or_Customer_Po_No, Get_Custord_From_Supply_Info
--  140919           to consider IPT_RO demand_code for replacement rental.
--  140917  AyAmlk   Bug 117407, Modified Validate_Fee_Code___() in order to restructure the condition used for fetch the delivery_country_db_ so that the CO line country is fetched
--  140917           when the address is single occurrence.
--  140909  RoJalk   Remove overtake in Customer_Order_Line_API.Finite_State_Machine___(User story PRSC-416) - removed the overtaken method.
--  140813  AyAmlk   Bug 118226, Modified Validate_Proj_Disconnect___() to allow cancelling a CO line when the connected DOP order is unpegged.
--  140707  KiSalk   Bug 117347, Modified Check_Before_Update___ to allow editing of condition code when supply code is IO and there are no reservations made.
--  140909  RoJalk   Remove overtake in Customer_Order_Line_API.Finite_State_Machine___ - model the Do_Set_Pkg_Header_State___ method and qty check.
--  140911  NaLrlk   Added Get_Demand_Contract() to retreive demand site in intersite flow.
--  140909  RoJalk   Remove overtake in Customer_Order_Line_API.Finite_State_Machine___ - Included Finite_State_Machine___(rec_, NULL, attr_) for state_ = PartiallyDelivered, event_ = SetQtyConfirmeddiff.
--  140903  RoJalk   Remove overtake in Customer_Order_Line_API.Finite_State_Machine___ - Added rec_.qty_shipped check to Do_Set_Pkg_Header_State___.
--  140908  ShVese   Removed overridden method Get_Consignment_Stock_Db since the cursor get_attr was never used and the rest of the code was standard.
--  140905  SlKapl   FIPR19 Multiple tax handling in CO and PO flows - changed Get_Base_Price_Incl_Tax_Total, Get_Base_Sale_Price_Total and Get_Sale_Price_Total to handle both setups with/without Price Including Tax used.
--  140905  Vwloza   Updated Rental_Is_Fully_Invoiced___ to support recent state machine updates.
--  140903  RoJalk   Remove overtake in Customer_Order_Line_API.Finite_State_Machine___ - Added the methods Do_Set_Partially_Delivered___, Do_Nothing___ and Qty_Ship_Greater_Than_Zero___.
--  140903  RoJalk   Remove overtake in Customer_Order_Line_API.Finite_State_Machine___ - Included Finite_State_Machine___(rec_, NULL, attr_) for state_ = PartiallyDelivered, event_ = SetQtyAssigned/SetQtyInvoiced/SetQtyPicked
--  140903  RoJalk   Remove overtake in Customer_Order_Line_API.Finite_State_Machine___ - Included Finite_State_Machine___(rec_, NULL, attr_) for state_ = Released/Picked/Reserved, event_ = SetQtyInvoiced
--  140902  RoJalk   Remove overtake in Customer_Order_Line_API.Finite_State_Machine___ - Included Finite_State_Machine___(rec_, NULL, attr_) for state_ = NULL, event_ = NULL
--  140902  RoJalk   Remove overtake in Customer_Order_Line_API.Finite_State_Machine___ - Included Finite_State_Machine___(rec_, NULL, attr_) for state_ = 'Delivered', event_ = 'SetQtyAssigned'/'SetQtyPicked'
--  140901  RoJalk   Remove overtake in Customer_Order_Line_API.Finite_State_Machine___ - Corrected the order of code in Finite_State_Machine___.
--  140828  MAHPLK   PRSC-2451, Modified Update___ method to change the parameter list of the Connect_Customer_Order_API.Modify_Connected_Order_Line.
--  140822  MAHPLK   PRSC-2227, Merged Bug 118118, Added new method Get_Order_Line_Contribution() to calculate the contribution amount of a customer order line.
--  140820  ChJalk   PRSC-2067, Modified method New to add parameter create_partial_sum_ in call Customer_Order_Pricing_API.Replace_Default_Discount_Rec.
--  140819  RoJalk   Modified Update___ and called Shipment_Handling_Utility_API.Remove_Shipment_Lines to remove created shipments when supply code is modified to PD/IPD.
--  140812  SlKapl   FIPR19 Multiple tax handling in CO and PO flows - renamed Get_Total_Tax_Amount to Get_Total_Tax_Amount_Base (and removed previous version of Get_Total_Tax_Amount_Base), changed Get_Total_Tax_Amount_Curr
--                   in order to retrieve tax amount directly from cust_order_line_tax_lines_tab without calculation.
--  140812  MeAblk   Modified Post_Insert_Actions___ in order to make it possible to register a discount value when a new order line is entered.
--  140808  RoJalk   Modified Check_Update___ and added a validation to check if the order header status is not Planned and stop the update of DOP Connection field on an order line.
--  140801  NWeelk   Bug 117996, Modified Validate_Proj_Disconnect___ by adding CQ as well to the condition to avoid setting null to the demand code when
--  140801           disconnecting the project activity of a CO line created from a sales quotation.
--  140728  MaEelk   Bug 117704, Modified Get_Total_Discount_Unrounded() to set the discount to 0 if the price_base_ is 0.
--  140725  Chdelk   PRMF-985, Merged LCS Patch 113519.
--  140725           140328  ManWlk   Bug 113519, Modified Delete___ to check the supply code before updating forecast in MS or MRP.
--  140709  MaEelk   In Check_Update___, added a check to see if there are multiple discount lines exist before modifying the discount in customer order line. This check is done only if the change is done from the client.
--  140709           In Update___ after the new discount value is updated, made a call to Cust_Order_Line_Discount_API.Add_Remove_Update_Line to do necessary chages in discount lines
--  140704  MaEelk   Bug 117218, Modified Check_Update___() in order to prevent re-fetching the tax code when default info flag is unchecked.
--  140703  NWeelk   Bug 117026, Modified Update_License_Connect_Head__ to update Find and connect head when the forwarder is edited in the CO.  
--  140702  MaEdlk   Bug 117072, Removed rounding of adjusted_weight_net, adjusted_weight_gross and adjusted_volume attributes in Check_Insert___ and Check_Update___.
--  140701  SudJlk   Bug 117090, Modified Change_Package_Structure___ and Check_Before_Update___ to avoid date recalculation unnecessarily for order lines
--  140701           where the sales quantity is reduced to the already delivered quantity.
--  140623  ShKolk   Added Get_Total_Discount_Unrounded() to return unrounded discount percentage.
--  140613  IsSalk   Bug 117198, Modified Update___() and Post_Insert_Actions___() in order to avoid adding of CO lines with Supply Code IPD to a Shipment on demand site.
--  140612  Jeguse   PRPJ-541, Modified Handle_Activity_Seq___, Calculate_Revenue___, Calculate_Cost_And_Progress and added Refresh_Connection
--  140610  NaLrlk   Added Get_Planned_Rental_Start_Dt___() to consider planned start date as price_effective_date in price fetching for rentals.
--  140610  Vwloza   Updated Get_Activity_Info___, Handle_Activity_Seq___ and Calculate_Cost_And_Progress to exclude replacement COs.
--  140704  ChJalk   PRSC-1599, Modified the method New to handle paramters passed from BO.
--  140530  MeAblk   Added new method Validate_Update_Service_Con___ and modified Modify__ in order to correctly work the bug merge 113029.
--  140528  RoJalk   Modified Check_Insert___ and moved the value assignment for release_planning before Calculate_Order_Line_Dates___.
--  140523  NipKlk   Bug 117045, Removed PT and IPT supply codes from the IF condition in Validate_Proj_Disconnect___ method to allow cancelling project connected PT and IPT CO lines.
--  140523  JeLise   Bug 113029, Added check on 'PRICE_SOURCE' in loop to add data in new_attr_, to make sure that the value
--  140523           from Get_Default_Part_Attributes___ is not replaced.
--  140522  AyAmlk   Bug 117009, Modified Modify__() to prevent raising an error message when tax related data are modified in a Service Order CO line.
--  140522  RoJalk   Modified Check_Insert___, Check_Update___ and added code to fetch the value for ADD_INFO from attr_.
--  140522  RoJalk   Modified Check_Before_Insert___  and fetched supplier_acquisition_site_, supplier_company_ in a company.
--  140521  RoJalk   Modified Update___ and fetched the latest rowstate just before calling the main Update to avoid state reverting to a old value.
--  140521  MaIklk   PBSC-9302, Passed the delvier_to_cust_no to prepare_insert() in New().
--  140521  KoDelk   Bug 116634, Modified method Recalc_Line_Tot_Net_Weight to filter records by rowstate in the cursor get_co_lines.
--  140519  HiWeGB   Modified Check_Before_Insert___ to by-pass consignment functionality for rental parts.
--  140519  MeAblk   Modified method Validate_Pack_Instr_Id___ in order to correctly get the packing instruction id when changing the delivery address id.
--  140516  NaLrlk   Added Is_Rental_Dates_Changed___() and Modified Update___() to support replicate changes when rental dates modified.
--  140514  NIWESE   PBSC-8638 Added call to custom validation for Cancel Reason codes.
--  140513  Vwloza   Updated Get_Activity_Info___, Calculate_Cost_And_Progress, New_Rental_Replacement_Line with RCO validations.
--  140513  JeLise   Added Check_Common___ and added a check to make sure that buy_qty_due is an integer when serialized.
--  140513  RoJalk   Added the qty_on_order as an OUT parameter to the usages of Connect_Customer_Order_API.Create_Connected_Order_Line.
--  140512  MuShlk   Bug 116671, Modified Calculate_Order_Line_Dates___() to check if the c/o line is fully reserved and passed it along Cust_Ord_Date_Calculation_API.Calc_Order_Dates_Backwards().
--  140512  NaLrlk   Modified the Check_Insert___() to allow new rental lines for project connection orders.
--  140509  SuJalk   PBMF-6932, Modified Update___ procedure to only call Order_Config_Util_API.Update_Configuration__ if the configuration id has changed.
--  140508  NaSalk   Modified Get_Activity_Info___ to prevent cost of goods reporting for project connections for rental lines.
--  140502  UdGnlk   PBSC-8181, Mergd bug 115917, Removed method Check_Exp_Conn_And_Auth and added Is_Expctr_Connected to return true if the line is connected to an export license.
--  140429  Vwloza   Updated Check_Before_Insert___ to allow Company Rental Assets for intra-company inter-site orders.
--  140429  RoJalk   Replaced Company_Order_Info_API.Get_Delay_Cogs_To_Dc_Db with Company_Order_Info_API.Get_Delay_Cogs_To_Deliv_Con_Db
--  140423  ChFolk   Modified Check_Custord_For_Purord to add PODIRSH transaction code to get CO Po connection when multi tire COs exists.
--  140423  KiSalk   Bug 111264, Modified Update___ to send one change request per internal PO of the PO connected package component lines.
--  140415  NaSalk   Modified Rental_Is_Fully_Invoiced___ to consider planned invoice date.
--  140415  Vwloza   Updated Rental_Is_Fully_Invoiced___ with inter-site data.
--  140410  NaSalk   Modified Check_Insert___ to set cost to 0 for rental lines.
--  140409  NaSalk   Modified Get_Line_Defaults___, New to consider rental information when creating new lines.
--  140403  AyAmlk   Bug 114045, Modified Check_Before_Insert___() to pass sales_part_rec_.part_no when calling Check_Active_Part___(). Modified Get_Default_Part_Attributes___()
--  140403           to pass the DEMAND_ORDER_REF1 before calling Get_Line_Defaults___() in order to avoid the error message for external service orders.
--  140401  RoJalk   Modified Validate_Jinsui_Constraints__ and removed comments added below UncheckedAccess tag.
--  140331  TiRalk   Bug 113856, Modified Modify, Post_Insert_Actions___ and Update___ to avoid creating shop order when the configuration is not completed state.
--  140331  MeAblk   Modified method Make_Service_Deliverable__ by removing some cursors and replaced them with appropriate methods. Added new method Get_Deliverable_Qty.
--  140331  AwWelk   PBSC-7852, Modified Get_Default_Part_Attributes___() to fetch unit_price_incl_tax_, base_unit_price_incl_tax_ when supply code is SEO.
--  140325  AndDse   PBMF-4700, Merged in LCS bug 113040, Passed FALSE as order_line_cancellation_ parameter to the calls Reserve_Customer_Order_API.Control_Ms_Mrp_Consumption().
--  140324  MeAblk   Modified method Update___ by moving some code segment into Shipment_Order_Line_API.Update_From_Order_Line.
--  140321  NaSalk   Modified New_Rental_Replacement_Line to set cost to 0.
--  140321  HimRlk   Modified logic to pass use_price_incl_tax value when fetching freight price lists.
--  140321  MeAblk   Removed some cursors in the methods Check_Update___ and Update___ and modified then accordingly.
--  140321  KiSalk   Bug 115190, In Post_Insert_Actions___, renamed menu name from "View Calculated Sales Promotions" to "Calculate and View Sales Promotions" in info messages.
--  140320  NiDalk   Bug 112499, Added function Get_Total_Tax_Amount_Base to clculate total tax amount per line in base currency.
--  140318  BudKlk   Bug 115092, Assigned current_info_ variable to NULL as relevent.
--  140318  RuLiLk   Bug 114315, Modified method Get_Sale_Price_Incl_Tax_Total() to return total with tax when use price including tax is not specified.
--  140318  MeAblk   Modified method Update___ by adding a new handling unit related info message. Modified Check_Update___ by adding a new cursor to retrieve the no of order line
--  140318           connected preliminary shipments.
--  140317  NaSalk   Modified Update___ to consider changes in rental chargeable days.
--  140312  AyAmlk   Bug 114737, Modified Change_Package_Structure___() to avoid incorrect calculation of the qty_per_assembly when conv factor is different than 1.
--  140213  ChBnlk   Bug 113704, Modified Update___() to add an entry to the line history when the configuration id is changed. Modified Check_Before_Update___() to
--  140213           stop updating configuration id when the customer order line is not in Released status.
--  140213  ChFolk   Modified Get_Serials_From_Demand_Info to exclude registerd serials from the delivered serials and to list only the serials which are to be registered.
--  140210  SURBLK   Modified Unpack_Check_ by checking send_changes variable before calling the Validate_Customer_Calendar().
--  131227  MaEdlk   Bug 114531, Modified Set_Cancelled() to cancel linked commission lines by moving 'Order_Line_Commission_API.Cancel_Order_Commission_Lines' from 'Cancel_Customer_Order_API.Cancel_Simple_Line___'.
--  131217  AyAmlk   Bug 113764, Modified Check_Before_Update___() by changing a condition to prevent raising an info message when the change is done through a PO component.
--  131210  AyAmlk   Bug 113764, Added po_charged_comp_change to the CUSTOMER_ORDER_LINE view and modified Unpack_Check_Update___() and Update___() in order to replicate
--  131210           changes to the pegged objects if the change is done from the PO charged components.
--  130830  HimRLk   Merged Bug 110133-PIV, Modified methods Get_Sale_Price_Total, Get_Base_Sale_Price_Total, Validate_Prepayment___,
--  130830           Get_Sum_Invoiced_Base_Curr__, Get_Sum_Invoiced_Order_Curr__, Get_Backlog_Value_Base_Curr__,  Get_Backord_Value_Base_Curr__
--  130830           by changing Calculation logic of line discount amount to be consistent with discount postings.
--  130830           Removed methods Get_Sum_Shipped_Base_Curr__, Get_Sum_Shipped_Order_Curr__.
--  140307  SBalLK   Bug 112938, Modified the INTORDEXISTS error message in Unpack_Check_Update___() method to be more descriptive.
--  140306  NaLrlk   Added method Rental_Period_Exists()to validate price update when rental events exist.
--  140306  GayDLK   Bug 115022, Added method Check_Purch_Supply_Code___ and moved the purch related supply code ('PD', 'PT', 'IPD', 'IPT') validation check to it. Called
--  140306           Check_Purch_Supply_Code___() inside Unpack_Check_Insert___() and Check_Before_Update___() to ensure that the above codes are used with a valid purchase part.
--  140306  RoJalk   Removed the method Rental_Event_Added__ since it should genearte by the state machine, removed Override annotation from custom validation methods.
--  140304  NaSalk   Modifed Prepare_Insert___ to add order_no to attribute string.
--  140304  IsSalk   Bug 114093, Added a new method Qty_On_Order_Exist__ to check pegged quantity for both normal and package part lines.
--  140304  FAndSE   PBSC-3168: Merge issue - Changes due to functional conflict between support bug 108291 and Billabong, change of COL quantity when connected to shipment.
--  140303  NWeelk   Bug 115635, Modified method Update_License_Connect_Head__ to update the license connect head when the vendor number is modified in the CO line.
--  140303  NWeelk   Bug 113825, Added derived attribute disconnect_exp_license, added parameter disconnect_exp_license_ to Modify_Wanted_Delivery_Date__,
--  140303           added parameter attr_ to Update_License_Connect_Head__ and modified logic to change the license date when changing the dates on the pegged PO or SO.
--  140303           Added method Check_Exp_Conn_And_Auth to check whether the CO line is connected to an export license and the user has authority
--  140303           to disconnect the license. Modified method Update_Planning_Date to change the license date when changing the dates on the pegged PO or SO.
--  140228  RoJalk   Bug 114140, In Pre_Unpack_Insert___, set newrec_.part_ownership with the db value instead of client value.
--  140227  AyAmlk   Bug 115041, Modified Get_Line_Defaults___() by reversing the previous correction and allowing the supply code to be set as 'Not Decided' when the CO line
--  140227           is not created from a  Sales Quotation but supply code is 'Invent Order' and the part is configured.
--  140227  ErFelk   Bug 115041, Modified Get_Line_Defaults___() by removing a code block which set supply code to 'ND' when the part is CONFIGURED and supply code is 'IO'.
--  140226  AndDse   Modified Level_1_Proj_Part_API calls to Level_1_Part_API, since Level_1_Proj_Part_API has been removed.
--  140225  SudJlk   Bug 112804, Modified Check_Update___ and Update___ to rectify the faults in tax line adding and removing when tax regime is Sales Tax.
--  140220  KiSalk   Bug 115357, Modified Unpack_Check_Update___ to add info message on qty or price change if connected sales promotion charge lines exist.
--  140213  NaSalk   Modified Post_Insert_Actions___ and Update___ to include rental chargeable days for discount calculations.
--  140131  RoJalk   Modified Post_Insert_Actions___ and Update___ and used NVL when using the value for local_site_reservation_exist_.
--  140124  SudJlk   Bug 113029, Modified Get_Line_Defaults___ to set price source as Service Price and not run the CO price logic for CO lines created from WO.
--  140124  SudJlk   Bug 113029, Modified Check_Insert___ and Check_Update___ to set price source as Unspecified for customer owned or supplier loaned parts.
--  140124           Modified Get_Line_Defaults___, Get_Default_Part_Attributes___ and Post_Insert_Actions___ to set price source as Service Price and fetch/retain prices correctly
--  140124           without running the CO price logic for CO lines created from service contracts and CRO.
--  140124  MeAblk   Modified Check_Update___ and Update___ methods in order to correctly update the shipment connected qty when order line sales qty is modified.
--  140108  RoJalk   Modified Modify_Order_Defaults__ and passed the correct values for attribute string when calling update.
--  140101  MaRalk   PBSC-5332, Modified Check_Insert__by moving Calculate_Order_Line_Dates___ after calling Get_Supply_Chain_Defaults___.
--  131213  RoJalk   Hooks implementation - Added the method Pre_Unpack_Update___.
--  131211  RoJalk   Hooks implementation - Removed Exist_Job_Id___ and added the state machine generated method Check_Delete_Exp_License___.
--  131211  RoJalk   Hooks implementation - Added the method Get_Addr_Flag_Db.
--  131210  RoJalk   Hooks implementation - Modified Get_Abnormal_Demand_Db and removed NVL statement since it is a NOT NULL column.
--  131209  RoJalk   Hooks implementation - refactor files, removed the STATEPKG.
--  131206  MaEelk   Replaced the usage of Inventory_Part_Planning_.Mrp_Order_Code with Inventory_Part_Planning.Planning_Method
--  131205  RoJalk   Hooks implementation - refactor files.
--  131119  RoJalk   Hooks implementation - refactor files.
--  131106  SBalLK   Bug 109432, Modified Get_Purchase_Order_Info() method to get requisition line state from PurchaseReqLine Lu where PurchaseReqUtill method has removed.
--  131103  RoJalk   Hooks implementation - align the base view with the model.
--  131021  RoJalk   Corrected code indentation issues after merge.
--  130917  PraWlk   Bug 107715, Modified Calculate_Order_Line_Dates___() to set use_current_date_ to TRUE upon target_date change. Passed use_current_date_ when
--  130917           calling Cust_Ord_Date_Calculation_API.Calc_Order_Dates_Backwards().
--  130913  JanWse   Bug 111463, Recalculate buy_qty_due and revised_qty_due for package parts using qty_per_assembly in Unpack_Check_Update___.
--  130911  IsSalk   Bug 111274, Modified Unpack_Check_Update___() to fetch vat_no according  to the changing delivery country.
--  130903  AyAmlk   Bug 110034, Added the parameter dop_replicate_msg_ to Update_Package___() and Change_Package_Structure___(). Modified Update___(), Post_Insert_Actions___()
--  130903           and Recalc_Package_Structure__() to pass NULL for the newly added parameter. Modified Update___() and Change_Package_Structure___() handle qty/date change
--  130903           when a CO line is connected to multiple DOP headers.
--  130902  VISALK   Bug 112121, Modified Delete___() to pass the parameter value as demand_order_ref4 instead of demand_order_ref3 to Srv_Sales_Lines_API.Undo_Transfer().
--  130903  TiRalk   Bug 111842, Modified Unpack_Check_Update___() to avoid update tax free tax code in CO line when changing route id.
--  130822  TiRalk   Bug 111842, Modified Modify_Order_Defaults__ and Unpack_Check_Update___() to update tax free tax code properly when
--  130822           changing delivery address and information in Delivery Information tab in Customer Order window when multiple CO lines exist.
--  130805  TiRalk   Bug 111163, Modified Remove_Project_Connection___ to avoid removing preposting from project connected package part line when there exists
--  130805           component lines which are not cancelled.
--  130730  RuLiLk   Bug 110133, Modified methods Insert_Package___, Change_Package_Structure___, Create_Sourced_Co_Lines, Get_Total_Discount,
--  130730           by changing Calculation logic of line discount amount to be consistent with discount postings.
--  130730           Modified methods Get_Sum_Invoiced_Base_Curr__, Get_Backlog_Value_Base_Curr__, Get_Backord_Value_Base_Curr__, Get_Base_Sale_Price_Total,
--  130730           Calculations are done using order currency, then final values are converted to base currency.
--  130725  NWeelk   Bug 111445, Modified method Unpack_Check_Insert___ by checking inv_part_cost_level_db_ as well before setting the cost to zero.
--  130719  SeJalk   Bug 110131, Modified Validate_Proj_Disconnect___ to retain the demand code DO when disconnecting from the project.
--  130719  ChBnlk   Bug 110980, Modified Unpack_Check_Update___() to stop modifying the SHIP_VIA_CODE when the order lines are invoiced with freight information.
--  130719  NWeelk   Bug 110975, Modified method Insert_Package___ to pass language_code when fetching sales_part_desc_ to get the sales_part_desc_
--  130719           for the language specified and passed correct customer_part_no_ to fetch cross reference catalog_desc_.
--  130708  ErSrLK   Bug 107012, Modified Get_Elements_Project_Inv___() and Get_Activity_Planned_Cost___(), redirected the calls to Part_Cost_Bucket_One_API
--  130708           which concerns Cost Set 1. Also dynamic code is changed to use Conditional Compilation. Removed unused global variables inst_PartCostBucket_ and inst_ManufStructure_.
--  130701  ErSrLK   Bug 110859, Modified view CUST_ORDER_LINE_CONFIG_USAGE by removing NVL clause on the part_no/catalog_no, and using
--  130701           a union of inventory and non-inventory parts in order to pick existing indexes when queries are made against it.
--  130630  RuLiLk   Bug 110133, Modified methods Get_Sale_Price_Total, Get_Base_Sale_Price_Total, Validate_Prepayment___,
--  130630           Get_Sum_Invoiced_Base_Curr__, Get_Sum_Invoiced_Order_Curr__, Get_Backlog_Value_Base_Curr__,  Get_Backord_Value_Base_Curr__
--  130630           by changing Calculation logic of line discount amount to be consistent with discount postings.
--  130630           Removed methods Get_Sum_Shipped_Base_Curr__, Get_Sum_Shipped_Order_Curr__,
--  130620  AyAmlk   Bug 110764, Modified Update___(), Change_Package_Structure___() and Calculate_Order_Line_Dates___() by constructing the code to prevent unnecessary sever calls.
--  130613  IsSalk   Bug 110270, Added method Set_Rel_Mtrl_Planning() to set value to Release for Material Planning.
--  130606  ChBnlk   Bug 107515, Modified Update___(), Post_Insert_Actions___() and Recalc_Package_Structure__() to recalculate the reserved qty on package part structure.
--  130603  ChBnlk   Bug 109515, Modified function Get_Next_Rel_No to display the proper error message when entering values beyond 9999 to the column rel_no.
--  130613  MADGLK   BLACK-65 ,  Removed MAINTENANCE_OBJECT_API method calls.
--  -----------------------------Project Black Pearl---------------------------------------------------------------
--  130905  UdGnlk   EBALL-145, Modified Get_Ownership_After_Delivery() for code review comments receive part from stock at customer.
--  130823  AwWelk   TIBE-2969, Removed global variable inst_PurOrdChargedComp_ and introduced conditional compilation.
--  130819  CHRALK   Modified Post_Insert_Actions___() by adding validations for rental lines when having prepayment invoices for CO.
--  130813  CHRALK   Modified Modify_Staged_Billing() and Post_Insert_Actions___ by adding staged billing validations for rental order lines.
--  130729  KaNilk   Modified Get_Rental_Chargeable_Days___ and Get_Latest_Rent_Charge_Days___ methods.
--  130723  UdGnlk   TIBE-2445, Modified Unpack_Check_Update___() to include attribute INSERT_PACKAGE_MODE_ when order line reached status 'Invoiced'.
--  130716  AwWelk   TIBE-983, Removed global variables insert_package_mode_, block_component_info_ and current_info_.
--  130709  AwWelk   TIBE-983, Removed global variables and introduced conditional compilation.
--  130624  UdGnlk   EBALL-94, Added Get_Ownership_After_Delivery() to retrieve ownership and its owner once customer order line is delivered.
--  130619  Disklk   BRZ-4737 scalability, Modified Calculate_Cost_And_Progress method after removing project_element_info_tab_ global variable in Project_Conn_Refresh_Util_API.
--  130617  NaSalk   Modifed Line_Is_Fully_Invoiced___.
--  130617  NaSalk   Modifed Line_Is_Fully_Invoiced___ to handle rental lines.
--  130606  ChJalk   EBALL-72. Added new method Check_Demand_Code___ and called it in Unpack_Check_Insert___ and Unpack_Check_Update___. Added error message NO_CON_STOCK.
--  130531  RaNhlk   Bug 108373, Modified Unpack_Check_Update___() to pass configuration_id as a parameter to Config_Char_Price_API.Get_Calculated_Char_Prices().
--  130530  PraWlk   Bug 109943, Modified Generate_Next_Level_Demands___() by removing the call to Inventory_Part_In_Stock_API.Get_Inventory_Quantity() as the on hand
--  130530           qty calculation logic moved to Order_Supply_Demand_API.Generate_Next_Level_Demands(). Also passed the condition_code when calling it.
--  130521  ChJalk   EBALL-72, Modified the methods Unpack_Check_Insert___, Unpack_Check_Update___ and Validate_Delivery_Conf__ to add the error message NO_PARTEXCH. Modified the view VIEW_RMA_LOV
--  130521           for avoiding part exchange lines in list of values in RMA.
--  130516  NaSalk   Added method Get_Rental_No.
--  130508  KiSalk   Bug 106680, Replaced Installed_Component_SYS.<component> with Component_<component>_SYS.<component>.
--  130503  AyAmlk   Bug 109635, Modified Get_Gross_Amnt_Ratio_Per_Vat__() by altering the calculation done to improve performance.
--  130430  MaArlk   Bug 109700, Removed the error message COLCONFIG in Validate_Proj_Connect___() and Check_Supply_Code() to allow to connect configuralbe parts in project connected CO lines for supply type IPT.
--  130409  Harplk   ONESA-630, Modified Delete___().
--  130406  SBalLK   Bug 107802, Added method All_Components_Supply_Ipd() to validate the package does not component part or all component part are supply through the IPD. Modified Unpack_Check_Insert___(),
--  130406           Update___(), Post_Insert_Actions___() and Check_Before_Update___() methods to have shipment creation method when supply code is IPD.
--  130405  AyAmlk   Bug 108291, Modified Check_Before_Update___() by removing the validation that prevent updating the buy_qty_due_  when the CO is shipment connected. Modified Update___()
--  130405           to update the shipment Freight charges, when the line is connected to the shipment and charges are need to be calculated.
--  130327  ArAmLk   Modified Finite_State_Set___() to chnage CRO exchange line state to 'InExchange' when CO line 'PartiallyDelivered' or 'Delivered'.
--  130322  IsSalk   Bug 108922, Made implementation method Validate_Jinsui_Constraints___() private. Added parameter company_max_jinsui_amt_ to the method Validate_Jinsui_Constraints___().
--  130322           Modified methods Validate_Jinsui_Constraints__(), Insert___() and Update___() in order to perform validation with the Jinsui Invoice Constraints for all the lines in a CO.
--  130321  CPriLK   Added acquisition type to Purchase_Part_Supplier_API.Exist.
--  130313  KiSalk   Bug 108548, In Post_Insert_Actions___, assigned the fetched discount to newrec_.discount to be used in discount comparison at the end of New().
--  130226  SALIDE   EDEL-2020, changed the use of company_name2 to name
--  130222  NaLrlk   Added Get_Rental_Chargeable_Days___ to get rental_chargable_days for sales price total calculation.
--  130212  SBalLK   Bug 107802, Modified Unpack_Check_Insert___(), Init_Before_Check_Insert___(), Unpack_Check_Update___() and Check_Before_Update___() methods to have shipment creation method
--  130212           when supply code is IPD.
--  130211  SBalLK   Bug 107364, Modified Check_Before_Update___() and Modify_Order_Defaults__() method to restrict update the shipment creation method to "Create Shipment at Order Release"
--  130211           and "Add to Existing Shipment at Order Release" when customer order in release state.
--  130208  Vwloza   Renamed auto_start_rental_option references to start_rental_option.
--  130201  AwWelk   Bug 107413, Modified Update_License_Connect_Head__() to disable modifications for planned_ship_date,revised_qty_due in customer order when an export license is connected.
--  130201  Vwloza   Added rental flag to Get_Next_Line_No calls in Unpack_Check_Insert and Create_Sourced_Co_Lines.
--  130131  THTHLK   Modified Modify_Rental___ and New_Rental___, Moved RETURNDATEEARLY to rental side.
--  130131  MalLlk   Bug 108126, Modified Check_Before_Insert___() to call Check_Active_Part___() in order to validate if it's a active inventory part.
--  130129  RuLiLk   Bug 106274, Modified method Update___. Changes of the planned_delivery_date should trigger Customer_Order_Charge_Util_API.New_Cust_Order_Charge_Line.
--  130128  THTHLK   Added Prepare_Rental___.
--  130123  AwWelk   Bug 107413, Added method Update_License_Connect_Head__ to check and update the Export License Find and Connect header when attributes of Customer Order is modified.
--  130123           Moved existing relavent logics to this method and also included the functionality to handle planned ship date changes.
--  130122  THTHLK   Modified Prepare_Insert___ to set default value for AUTO_START_RENTAL_OPTION
--  130121  THTHLK   Added AutoStartRentalOption attribute to rental.
--  130118  THTHLK   Modified procedures New_Rental___ and Modify_Rental___. Added new Information message RETURNDATEEARLY.
--  130116  NWeelk   Bug 98604, Added method Update_Package_Dates to update package order line dates upon replicating from a PO and moved package date update code from Update_Planning_Date to Update_Package_Dates.
--  130111  HimRlk   Modified Get_Total_Tax_Amount_Curr() to fetch the total tax percentage when use_price_incl_tax value is true.
--  130110  Dinklk   Modified Check_Supply_Code___ to support Supply Code 'CRO' with the Demand Code Order_Supply_Type_API.DB_COMPONENT_REPAIR_EXCHANGE.
--  130102  SBalLK   Bug 105372, Modified Unpack_Check_Update___() to update cost of configured part after set configuration and source form Invent Order. Removed Update_Configuration_Id().
--  121219  CHRALK   Modified Get_Sale_Price_Total() by adding rental related calculation changes.
--  121219  Vwloza   Updated RENTAL defaults of FALSE to RENTAL_DB instead.
--  121218  KiSalk   Bug 106585, In Create_Sourced_Co_Lines, client value is added with db value to attribute string not to replace default_addr_flag with the default value with later method calls from New.
--  121212  CHRALK   Modified New__, Modify__ and Remove__ methods to handle rental information.So that Create_Rental_Attr___(),New_Rental___(),Modify_Rental___() and Remove_Rental___() methods introduced.
--  121212  MaRalk   Added private attribute End_Customer_Id and modified base methods.
--  121212           Modified Prepare_Insert___ to add the END_CUSTOMER_ID value to the attribute string.
--  121207  ShKolk   Modified Get_Total_Tax_Amount_Curr() to return correct tax_amount when use price incl tax is true.
--  121206  CHRALK   Added new column rental.
--  121123  NaSalk   Modified Get_Owner_For_Part_Ownership to include company rental asset ownership.
--  130902  ChFolk   Added new view DELIVERED_CATALOG_NO_LOV which is used for catalog no in rma line.
--  130829  MaMalk   Modified several methods to retain the value of shipment_type and shipment_creation when it's sent from the client at insert.
--  130828  JeLise   Added check on line_item_no in Unpack_Check_Insert___ to make sure no component lines get a packing_instruction_id.
--  130828           And removed packing_instruction_id from Change_Package_Structure___.
--  130828  MaMalk   Made Shipment_Creation mandatory.
--  130826  JeLise   Added call to Part_Handling_Unit_API.Check_Combination in Unpack_Check_Insert___ and Validate_Pack_Instr_Id___.
--  130826  RoJalk   Modified Make_Service_Deliverable__and changed the get_shipment_qty cursor to consider already reserved qty_to_ship in shipment line.
--  130820  JeLise   Added packing_instruction_id_ to the attribute string in Get_Default_Part_Attributes___.
--  130813  HimRlk   Added new private method Get_Internal_Co_Qty__().
--  130729  SURBLK   Modified Get_Supply_Chain_Defaults___() by getting forward_agent_id from attribute string.
--  130725  JeeJlk   Added Get_Serials_From_Demand_Info to get list of serials which have been delivered by the supply site.
--  130718  MaMalk   Added Get_Connectable_Sales_Qty to get the available quantity to connect for a shipment.
--  130716  MaEelk   Added new paramter to the Sales_Weight_Volume_Util_API.Get_Total_Weight_Volume calls
--  130626  SURBLK   Modified Unpack_Check_Update___ with not to send Validate_Customer_Calendar when planned_delivery_date is changed.
--  030530  HimRlk   Added new method Modify_Line_Delivery_Info__().
--  030528  HimRlk   Modified Get_Supply_Chain_Defaults___ to pass vendor_no to method call Cust_Order_Leadtime_Util_API.Get_Supply_Chain_Defaults.
--  130515  SURBLK   Added Get_Custord_From_Supply_Info().
--  130508  MaMalk   Reversed the correction did for shipment_creation.
--  130507  MeAblk   Added new method Check_All_Comp_Non_Inv.
--  130424  MaMalk   Modified several methods to support for combining 5 shipment creation methods exist to 3.
--  130422  MeAblk   Added new method Validate_Pack_Instr_Id___.
--  130422  MaMalk   Replaced all the messages mentioned shipment_creation with the shipment_type.
--  130422  MaMalk   Excluded Shipment_Creation for setting a value for Default_Addr_Flag since now the Shipment_Creation is not visible in the client.
--  130419  MaMalk   Made Planned_Ship_Period public.
--  130417  MeAblk   Modified method Unpack_Check_Insert___ by setting the packing_instruction_id correctly when the order line is created for an internal customer when deman code is IPT.
--  130417  JeeJlk   Added new column ORIGINATING_CO_LANG_CODE.
--  130417  MaMalk   Made ShipmentCreation not mandatory and not insertable in the logic since it will be fetched from the server.
--  130409  MeAblk   Modified methods Unpack_Check_Update___ and Modify_Order_Defaults__ in order to correctly pass the packing_instruction_id value.
--  130401  MeAblk   Added new attribute packing_instruction_id and accordingly modified the package methods.
--  130220  UdGnlk   Modified Get_Custord_From_Demand_Info() by adding a parameter as demand_code. Added Get_Supply_Code_Db.
--  130215  ChFolk   Added supply_code into the view CUSTOMER_ORDER_LINE_RMA_LOV to support filteration based on supply code when multisite return is done.
--  130130  UdGnlk   Added Get_Custord_From_Demand_Info() to retrieve customer order information passing demand order information.
--  130107  MeAblk   Modified Make_Service_Deliverable__ in order to correctly update the qty_to_ship value in customer_order_line_tab when reserving non-inventory part lines through a shipment.
--  130104  MeAblk   Modified Make_Service_Deliverable__ in order to correctly retrieve the deliverable qty for the non-inventory part lines from the shipment_order_line_tab.
--  130101  MeAblk   Modified methods Unpack_Check_Update___ and Update___  in order to make it possible to update the shipment type of the order line while it is connected with a shipment.
--  121211  RoJalk   Modified Unpack_Check_Update___ and included OPEN_SHIPMENT_QTY to be updatable even if the order is Invoiced.
--  121120  MeAblk   Modified method Make_Service_Deliverable__ in order to handle the reservations done for the shipment connected quantities of non-inventory part lines.
--  121119  UdGnlk   Modified CUSTOMER_ORDER_LINE_RMA_LOV to support outer join inorder to get orders none pegging purchase orders.
--  121115  RoJalk   Modified Check_Before_Update___ and removed the error message DISCONSHIPMENT since COLINESHIPCONNECT added before that.
--  121113  UdGnlk   Modified CUSTOMER_ORDER_LINE_RMA_LOV to support purchasing information.
--  121030  MaMalk   Modified Update___ to change the condition and the message text given by constant SHIPCONADDR, when the delivery information is changed in shipment connected COLines.
--  120926  MaEelk   Addded  the public attribute open_shipment_qty tto the LU. Added parameter open_shipment_qty_ to  Modify_Shipment_Connection
--  120926           that would change the open_shipment_qty also when changing the tthe value of shipment_connection. Also  Added Modify_Open_Shipment_Qty_
--  120914  RoJalk   Removed the method Get_Pick_List_No.
--  120921  MeAblk   Removed parameter shipment type from the method calls Shipment_Handling_Utility_API.Add_Order_Line_To_Shipment.
--  120913  MAHPLK   Added new method Is_Route_Exp_Date_On_Shipdate.
--  120903  MeAblk   Modified Unpack_Check_Update___ in order to raise an error when updating the shipment type of already shipment connected order line.
--  120824  MeAblk   Modified Get_Supply_Chain_Defaults___ in order to get the default shipment type from Cust_Order_Leadtime_Util_API.Get_Ship_Via_Values.
--  120823  MeAblk   Added new attribute shipment_type. Modified Get_Supply_Chain_Defaults___ in order to correctly get the default shipment type.
--  120711  RoJalk   Added the parameter shipment type to the Shipment_Handling_Utility_API.Add_Order_Line_To_Shipment method call.
--  120711  MaHplk   Added picking lead time as parameter to Cust_Ord_Date_Calculation_API.Calc_Order_Dates_Backwards in Calculate_Order_Line_Dates___ and Calc_Dates_Forwards___.
--  120709  MaHplk   Added attribute picking lead time.
--  120705  MaMalk   Added route and forwarder to method Cust_Order_Leadtime_Util_API.Get_Ship_Via_Values, Get_Supply_Chain_Defaults and
--  120705           Source_Order_Lines_API.Source_Automatically__.
--  121012  IsSalk   Bug 105837, Modified view CUST_ORDER_LINE_CONFIG_USAGE to use the catalog_no as part_no when part_no is null.
--  121008  MaEelk   Bug 104958, Removed Supplier_Is_Internal() since it is not used any more after this bug correction. Implementation of Supplier_Is_Internal() is moved to
--  121008           Purchase_Order_API.
--  120927  AyAmlk   Bug 104504, Modified Update___(), to pass TRUE for the do_price_ parameter and modified Change_Package_Structure___() in order to calculate and update the sale_unit_price of a
--  120927           component part only if it's value not updated manually.
--  120918  GiSalk   Bug 103562, Modified Insert___() by modifying supply country vs delivery country validation, to use Customer_Order_Tax_Util_API.Check_Ipd_Tax_Registration().
--  120918           Modified Update___() by modifying supply country vs delivery country validation, to use Customer_Order_Tax_Util_API.Check_Ipd_Tax_Registration() and to be performed
--  120918           when ship_addr_no is modified and single occurrence address is not used.
--  120913  Cpeilk   Bug 102273, Modified Change_Package_Structure___ by adding call Add_Info___ in order to avoid clearing package component level info messages generated inside by the first
--  120913           function call of Calculate_Order_Line_Dates___. Modified the function Calculate_Order_Line_Dates___ by adding the parameter catalog_type_ into call Calc_Order_Dates_Backwards and
--  120913           modified Validate_Proj_Connect___ by adding catalog_type_ as a parameter in order to avoid appearing some package component level info messages. Also removed default FALSE
--  120913           in parameter new_pkg_component_line_ in method Validate_Proj_Connect___.
--  120910  NiDalk   Bug 104794, Modified Check_Before_Update___ to disallow changing of part ownership after releasing the order when supply code is 'SO'.
--  120820  ShKolk   Modified Modify_Sale_Unit_Price() to consider price incl tax values.
--  120820  HimRlk   Modified Create_Sourced_Co_Lines() and Update___ to send new parameters to Order_Line_Staged_Billing_API.Recalculate and modified Post_Insert_Actions___ to pass correct
--  120820           values to Order_Line_Staged_Billing_API.Create_Stages_From_Template().
--  120814  ShKolk   Modified Update___ to recalculate prices if tax is changed.
--  120813  JeeJlk   Modified Change_Package_Structure___.
--  120808  HimRlk   Modified Post_Insert_Actions___() to recalulate prices after adding new tax lines.
--  120727  ShKolk   Added columns base_unit_price_incl_tax and unit_price_incl_tax. Handle server calculations.
--  120717  VWLOZA   BRZ-365, replaced Project_Connection_API calls with Project_Connection_Util_API.
--  120629  GiSalk   Bug 102469, Removed the function Is_Delivered() and introduced the procedure Get_Qty_Shipped_And_State() instead.
--  120622  Darklk   Bug 102362, Modifed the procedure Set_Qty_Shipped in order to log the Delivered state when the internal CO is delivered for a same company.
--  120621  AyAmlk   Bug 103279, Modified Perform_Capability_Check___() to include customer order line information to the messages result from the capability check.
--  120620  AyAmlk   Bug 102644, Modified Check_Before_Insert___() to allow CO creation when parts are owned by the Customer and the supply code is either SEO or CRO.
--  120620  GiSalk   Bug 103041, Modified the parameters of the info message SUPCOUNTRYDIFF, by showing country name instead of country code.
--  120614  MaEelk   Removed the unused variable comp_uom_weight_ from Unpack_Check_Insert___ and Unpack_Update___
--  120614  GiSalk   Bug 103041, Modified the validation of supply country of CO header, to raise an information message only when the delivery address country on the CO line is different
--  120614           than the supply country stated in the CO header, and the company has a tax registration in the delivery address country, when supply code is IPD.
--  120613  NWeelk   Bug 102511, Modified method Update___ to call Change_Package_Structure___ when the buy_qty_due of a component line is changed and modified
--  120613           Change_Package_Structure___ to calculate and update the qty_per_assembly.
--  120608  MaAnlk   Bug 103216, Added new method Is_Change_Config_Allowed.
--  120106  GiSalk   Bug 102669, Modified Init_Before_Check_Insert___() to Set DEFAULT_ADDR_FLAG_DB of a package component to be same as the value from the package header value,
--  120106           only if, DEFAULT_ADDR_FLAG_DB is null or supply code is not IPD or PD.
--  120426  RoJalk   Modified Transaction_SYS.Package_Is_Installed for the LU Level1ProjPart.
--  120425  RoJalk   Modified Get_Activity_Info___ and assigned FALSE for active_forecast_part_.
--  120418  MaMalk   Added method Modify_Tax_Details_For_IPD and added an extra parameter ipd_tax_update_ to Validate_Fee_Code___ to set this to true when the customer order lines gets created with
--  120418           demand code IPD and a single occurence address. Moved the code which executes tax lines update from Modify__ to Update___ since this has to be executed always when an update takes place.
--  120418  NaLrlk   Modified Calculate_Cost_And_Progress to handle progress_cost_ value inside the LOOP.
--  120418  ErFelk   Modified Update_Proj_Ms_Forecast___ by moving the EXECUTE IMMEDIATE block inside the IF condition to avoid errors when PMRP is not installed.
--  120416  RoJalk   Modified Get_Elements_Project_Inv___ and passed a value to activity_seq in method call Part_Cost_Bucket_API.Get_Project_Cost_Elements to exclude the cost for forecast part.
--  120412  AyAmlk   Bug 100608, Increased the length to 5 of column delivery_terms in view CUSTOMER_ORDER_LINE and changed the type of delivery_terms_ in Init_Before_Check_Insert___().
--  120409  GayDLK   Bug 101727, Modified Check_Before_Update___() by restricting the user from changing the supply code to 'Invent Order' from 'Project Inventory' or 'Project Delivery' while
--  120409           having parts reserved from the project inventory and vice versa while having parts reserved from the standerd inventory.
--  120405  MeAblk   Bug 101348, Modifed the functions Check_Pegged_Component_Exist() and Update___()  in order to check whether the pegged compoment have been removed due to any other reason.
--  120404  NaLrlk   Modified the column length of DEMAND_ORDER_REF2 from 4 to 10 in view comment.
--  120403  NaLrlk   Modified methods Post_Insert_Actions___, New_Cust_Sched to handle the info.
--  120403  SURBLK   Modified Calculate_Cost_And_Progress() by adding procedure name soon after the procedure end.
--  120402  RoJalk   Modified the Is_External_Service_Order___ and moved the conditional IF as the outer condition.
--  120330  RoJalk   Added the method Is_External_Service_Order___ and called from Calculate_Cost_And_Progress to stop the cost calculation for external service orders.
--  120330           Replaced the possible usages with the method Is_External_Service_Order___.
--  120326  RoJalk   Modified Validate_Proj_Disconnect___ and added an error message to prevent project disconnect if supply options has been created.
--  120326  NaLrlk   Modified Unpeg_Line to enable order line history when unpeg connected shop order.
--  120326  MaMalk   Modified Validate_Fee_Code___ to handle the fee_code correctly when a tax class is used and the demand code is IPD.
--  120321  RoJalk   Modified Calculate_Revenue___ and passed refresh_old_data_ to the method call Order_Proj_Revenue_Manager_API.Get_Planned_Revenue_Elements.
--  120314  DaZase   Added Init_Method call to Clear_Current_Info.
--  120313  MoIflk   Bug 99430, Added function Get_Inverted_Conv_Factor and Modified view CUSTOMER_ORDER_LINE,
--  120313           methods Prepare_Insert___, Unpack_Check_Insert___, Insert___, Unpack_Check_Update___, Update_Line___
--  120313           and include the inverted_conv_factor into calculation where conv_factor used.
--  120305  RoJalk   Merged 100572, Modified Calculate_Revenue and used the method Transaction_SYS.Get_Posted_Job_Arguments to execute the background job.
--  120301  SudJlk   Bug 100963, Modified method Update___ to restrict shipment creation for cancelled CO lines.
--  120301  ChJalk   Made the parameter planned_delivery_date_ an IN OUT parameter in the method Modify_Wanted_Delivery_Date__ because the new planned delivery date is needed for the CO header to raise
--  120301           messages if it has been changed. Modified Check_Before_Update___ to raise info message if the items are expired when the wanted_delivery_date is changed.
--  120213  HaPulk   Write Dynamic code to static component ENTERP (SupplierInfoMsgSetup) as static
--  120130  ChJalk   Modified the method Finite_State_Events___ to add missing events for each state.
--  120126  DaZase   Added method Get_Possible_Sales_Promo_Deal and a call to it from Post_Insert_Actions___.
--  111219  Kaellk   Modified Get_Activity_Planned_Cost___ to correct planned cost for supply code SO.
--  111216  NWeelk   Bug 100062, Reversed the correction done from the bug 86220 and 93056 since it is not needed to consider internal CO quantities when changing the states of the external CO.
--  111216  SurBlk   Bug 99817, Modified method Finite_State_Set___ in STATEPACKAGE and moved method Close_Financial_Project___ and Removed Global LU Constant inst_AccountingProjUtil_
--  111216           in order to close financial project when the COL state changed to 'Invoiced'.
--  111215  MaMalk   Modified Insert___ to remove the setting of objversion_ and move Get_Id_Version_By_Keys___ to the end of this procedure.
--  111205  MaMalk   Converted Retrieve_Default_Vendor__ to a function and added pragma to Get_Vendor_Contract__.
--  111124  GiSalk   Bug 94416, Added attribute new_comp_after_delivery to the Get method and added function Get_New_Comp_After_Delivery and added attributes qty_per_assembly,
--  111124           new_comp_after_delivery and added function Get_Qty_Per_Assembly. Modified method Insert___ by setting values for qty_per_assembly and new_comp_after_delivery.
--  111116  ChJalk   Modified the view CAMPAIGN_CUST_ORD_LINE to use User_Finance_Auth_Pub instead of Company_Finance_Auth_Pub.
--  111114  Darklk   Bug 99746, Modified the procedure Modify__ to allow update the column BLOCKED_FOR_INVOICING when the supply code is SEO.
--  111109  Cpeilk   Bug 99641, Modified method Unpeg_Line to create line history record when CO line is unpegged.
--  111108  AwWelk   Bug 99616, Modified the procedure Validate_Block_For_Invoic___ by removing the validation check for Delivery Confirmation together with Blocked for Invoicing.
--  111101  KiSalk   Bug 99443, Modified cursor check_exist in Is_Delivered to check rowstate instead of qty_shipped to use CUSTOMER_ORDER_LINE_3_IX.
--  111101  NaLrlk   Modified the method Modify to update configuration weight to customer order load list.
--  111026  Darklk   Bug 99082, Modified the procedure Post_Insert_Actions___ to release created purchase orders by package component parts
--  111026           and modified procedures Update___ and Modify by adding a new parameter to the procedure Create_Connected_Order_Line.
--  111025  NWeelk   Bug 94992, Added column rel_mtrl_planning to Get method and added function Get_Rel_Mtrl_Planning, set default value for rel_mtrl_planning in Prepare_Insert___,
--  111025           modified checks in Update___ to create pegged supplies if rel_mtrl_planning has changed from FALSE to TRUE, modified Check_Before_Update___ by introducing error messages
--  111025           to stop updating the rel_mtrl_planning when it is not necessary. Modified method Calculate_Order_Line_Dates___ to send correct values for new_mrp_demand_qty_
--  111025           and old_mrp_demand_qty_. Modified method Unpack_Check_Update___ to remove the created interim order when the rel_mtrl_planning is un selected and
--  111025           to raise an error message when the flag is changed after the supplies are created. Modified view DOP_CUSTOMER_ORDER_LINE_LOV by adding rel_mtrl_planning check
--  111025           to the where clause and added function Is_Comp_Not_Rel_Mtrl_Planned.
--  111024  GiSalk   Bug 99169, Modified the procedure Unpack_Check_Update___ to check whether the revised sales quantity is greater than the shipped quantity before updating the costs
--  111024           of the components using database values, in order to avoid updating costs of already delivered customer order lines.
--  111021  MaAnlk   Bug 99492, Modified Calculate_Order_Line_Dates___() to set demand values used by ms and mrp consumption logic to zero when order line is Cancelled.
--  111021  NaLrlk   Modified the line_total_qty, line_total_weight,line_total_weight_gross attributes to public.
--  111024  ChJalk   Added user_allowed_company filter to the view CAMPAIGN_CUST_ORD_LINE.
--  111018  MaRalk   Modified methods Unpack_Check_Update___, Get_Line_Defaults___, Update___, Post_Insert_Actions___, Insert_Package___
--  111018           by adjusting the parameters for the method calls in Sales_Price_List_API and Customer_Order_Pricing_API packages.
--  111018           Modified method Insert_Package___.
--  111012  ChJalk   Modified method Update___ to calculate customer calendar date if the customer calendar is changed.
--  111012  MaMalk   Modified methods Validate_Proj_Disconnect___, Unpack_Check_Update___ and Check_Before_Update___ to raise an error message when
--  111012           trying to disconnect the project connection from line  and when the order header is connected to a project and the header state is higher than Planned.
--  111006  ChJalk   Modified method Update___ to calculate SALE_UNIT_PRICE and BASE_SALE_UNIT_PRICE when the price_freeze flag is un selected.
--  110929  MaRalk   Modified INVALID_PRICELIST as en error message in both Check_Before_Insert___ and Check_Before_Update___ methods.
--  110928  MaMalk   Modified Unpack_Check_Update___ to prevent having part ownership other than Company Owned when sales promotions exist.
--  110927  Darklk   Bug 99091, Modified the procedure Create_Sourced_Co_Lines to add a new CO line history record with the original desired qty when sourcing that CO line.
--  110926  MaRalk   Modified methods Check_Before_Insert___, Check_Before_Update___ to remove unused parameter currency_code from method calls Sales_Price_List_API.Is_Valid and Is_Valid_Assort.
--  110922  MaRalk   Modified methods Check_Before_Insert___ and Check_Before_Update___ by adding the check Sales_Price_List_API.Is_Valid_Assort
--  110922           to avoid the info INVALID_PRICELIST for parts in an assortment node.
--  110922  MaMalk   Modified Modify_Order_Defaults__ to pass the tax free tax code of the header only when a single occurence address is used on a order
--  110922           default address on a line. Also removed some unwanted code in Unpack_Check_Insert___ to trigger the tax free tax code retrieval according
--  110922           to the delivery type.
--  110917  NaLrlk   Bug 98881, Modified Update___ by changing the info message ORILNEITMNO_NULL.
--  110915  MaRalk   Moved EDITNOTALLOWEDSB error message from Insert___ to Unpack_Check_Insert___.
--  110915           Modified Insert___ to assign self billing value to newly added component parts.
--  110912  MaMalk   Modified the message text given by constant SUPCOUNTRYDIFF.
--  110910  SudJlk   Bug 98653, Modified Get_Line_Defaults___ and CUSTOMER_ORDER_LINE to reflect the length change of demand_order_ref1 in customer_order_line_tab.
--  110908  Darklk   Bug 98372, Added the procedure Clear_Current_Info.
--  110907  MoIflk   Bug 98621, Modified Get_Activity_Info___ in order to avoid committed cost calculation when order line state equal to 'Invoiced'
--  110905  MaMalk   Passed extra parameter to Customer_Order_Charge_Util_API.New_Cust_Order_Charge_Line to calculate only freight charges when a CO created from a SQ.
--  110825  ChJalk   Bug 95597, Modified the methods Check_Before_Insert___ and Check_Before_Update___ to add IN parameter catalog_no to the method call Sales_Price_List_API.Is_Valid.
--  110824  IsSalk   Bug 97542, Modified Check_Before_Insert___ and Check_Before_Update___ by modifing code added by bug 84300 inorder to consider all customer types.
--  110824  NWeelk   Bug 98040, Modified method Update___ to change the dates for package part line as well when the supply code is IPD or PD.
--  110812  SudJlk   Bug 93948, Modified Unpack_Check_Update___ changing the method call to Set_Demand_Qty from Set_Demand_Qty_And_Date.
--  110811  ChJalk   Modified the method Init_Before_Check_Insert___ to set the default value of REBATE_BUILDER the value is NULL.
--  110808  MaMalk   Bug 94425, Modified Validate_Fee_Code___ and update___ to prevent tax retrieval in an update for demand code IPD.
--  110804  MaAnlk   Bug 96097, Modified Calculate_Order_Line_Dates___ to pass new parameters to Cust_Ord_Date_Calculation_API.Calc_Order_Dates_Backwards.
--  110718  ChJalk   Removed the view CUSTOMER_ORDER_LINE_UIV.
--  110717  ChJalk   Added user_allowed_site filter to the view CUSTOMER_ORDER_LINE.
--  110713  ChJalk   Added user_allowed_site filter to the view CUSTOMER_ORDER_LINE_RMA_LOV.
--  110713  MaMalk   Modified DOP_Customer_Order_Line_Lov to add the user allowed site filter.
--  110704  Cpeilk   Bug 94508, Added load_id to the public attribute list.
--  110622  AmPalk   Bug 93777, Made create_sm_object_option, able to modify from CREATESMOBJECT to DONOTCREATESMOBJECT, when the part is not serial tracked at the moment, in Check_Before_Update___.
--  110701  IsSalk   Bug 96677, Moved NOTINVPROVPRICE error message to Check_Before_Update___ from Unpack_Check_Update___ and added check if provisional_price changed.
--  110628  NiDalk   Bug 95237, Modified Check_Before_Update___ to consider demand code when supply code is changed from 'IO'.
--  110614  NaLrlk   Modified the method Unpack_Check_Update___ to handle the fee_code_changed_.
--  110603  ChJalk   Modified Modify_Fee_Code to update FEE_CODE_CHANGED to 'TRUE'.
--  110530  RoJalk   Added the source_ref parameters to the method Get_Elements_From_Purch___ to fetch the Customer Order and line related control types.
--  110527  ChJalk   Modified Get_Gross_Amnt_Ratio_Per_Vat__ to round the value.
--  110527  MaMalk   Modified Update___ and Insert___ to reaise an information message when supply country differs from IPD lines supply country.
--  110526  KaEllk   Modified Calculate_Revenue___ to correct transaction currency calculation.
--  110526  ChJalk   Added the column FEE_CODE_CHANGED and modified the methods Insert___, Unpack_Check_Insert___, Update___ and Unpack_Check_Update___ to handle it. Modified the method Update___ to
--  110526           update the fee codes of charge lines when there are multiple tax lines for the charge line.
--  110524  IsSalk   Bug 97128, Modified Insert_Package___ by adding new attribute DEMAND_CODE_DB to the attr_.
--  110523  MaMalk   Modified Validate_Fee_Code___ to consider the supply country when no value for the delivery country is found for the tax class.
--  110514  AmPalk   Bug 95151, Removed net_amount_ from call Cust_Order_Line_Tax_Lines_API.Recalculate_Tax_Lines.
--  110506  JaBalk   Bug 95920, Added procedure Modify_Purchase_Part_No() to update the purchase part no in COL when inventory part is connected to purchase part.
--  110514  MaMalk   Modified methods Handle_Activity_Seq___ and  Calculate_Cost_And_Progress to add missing ifs_assert_safe statements.
--  110512  HimRlk   Bug 96751, Modified Check_Before_Update___ and Insert___ to give an error message when trying to modify the self_billing value if there is no
--  110512           sales part cross reference.
--  110512  AmPalk   Bug 94640, Blocked supplier loaned lines to be entered if no owner for the ownership specified in Unpack_Check_Insert___ and Unpack_Check_Update___.
--  110512           Modified Get_Owner_For_Part_Ownership to return Database_SYS.String_NULL_ constant if a vendor number not found for the supplier loaned ownership.
--  110512  MiKulk   Modified Calculate_Cost_And_Progress to pass the correct trans_curr_code_ to Currency_Rate_API.Get_Project_Currency_Rate.
--  110511  ErFelk   Bug 96889, Modified a condition in Validate_Fee_Code___ so that tax free tax code is fetched when the Demand code is IPD and when the record is getting inserted.
--  110511           When the demand code is IPD and if the record gets Updated, tax free tax code should not be fetched like mention in bug 94425. Modified Unpack_Check_Update___,
--  110511           Unpack_Check_Insert___ and Validate_Fee_Code___ methods by adding a parameter at_insert_.
--  110510  MalLlk   Modified Post_Insert_Actions___ to passed NULL as qty_to_move to Distribution_Order_API.Modify_From_Connected_Order.
--  110510  ChJalk   Modified Get_Line_Defaults___ to avoid fetching default values of INPUT_UNIT_MEAS and INPUT_CONV_FACTOR when there is a buy_qty_due.
--  110509  AmPalk   Bug 96073, Added Recalc_Line_Tot_Net_Weight.
--  110505  ChJalk   Modified the methods Insert___ and Update___ to change the calculation of weight_net to consider the weight defined in configuration specification.
--  110504  ShVese   In Check_Before_Insert___ replaced several calls to Cust_Ord_Customer_API.Get_Acquisition_Site and
--                   Site_API.Get_Company(cust_acquisition_site_) with variables. Also fixed wrong comaprision of serial tracking for sm objects.
--  110503  KaEllk   Modified Calculate_Revenue___ to pass correct company value.
--  110427  HimRlk   Bug 96751, Modified CUSTOMER_ORDER_LINE view by changing self_billing to update allowed. Modified Unpack_Check_Update___ to allow self_billing
--  110427           and self_billing_db to be updated. Modified Check_Before_Update___ by introducing an error message to raise when trying to update the self_billing field
--  110427           if qty_invoiced exist for the CO line.
--  110427  MaRalk   Moved some validations related to CO lines created from a component repair order from Unpack_Check_Update___ to Check_Before_Update___.
--  110426  UdGnlk   Modified Update_Pegged_Orders__() remove method calls which modified demand code in POL and PRL to 'IO'.
--  110425  MaMalk   Modified Validate_Fee_Code___ to handle the tax free tax code correctly when demand code is IPD.
--  110411  MaMalk   Modified Update___ and Post_Insert_Actions___ to trigger the info message related to company tax id correctly when different line delivery address is used.
--  110405  MaMalk   Corrected an error in Get_Internal_Or_Customer_Po_No to remove the oracle error raised when populating available order lines in Shipment.
--  110331  ShVese   Moved the correction done in 92042 from Unpack_Check_Insert__ to Check_Before_Insert___ and replaced with receipt_issue_serial_track.
--  110330  MaRalk   Added validations inside Unpack_Check_Update___ and Check_Supply_Code___ methods
--  110330           for customer order lines created from a component repair order.
--  110329  AndDse   BP-4754, Modified Unpack_Check_Update___, we decided that ship via etc should not be changed when unchecking single occurence flag.
--  110328  MiKulk   Added some information messaged for tax liability country validations.
--  110323  MiKulk   Modified the vat_no fetching logic to consider document address id instead of ship addr no.
--  110321  MaMalk   Modified Unpack_Check_Update___ to fetch the taxes correctly when the delivery_type is changed.
--  110321           Modified Get_Line_Defaults___ to add the delivery_type to the attribute string.
--  110321  MiKulk   Added the method Modify_Vat_No_Details__ to update the line vat_no and tax_id_validated_date when the header document address id is changed.
--  110316  AndDse   BP-4434, Modified Perform_Capability_Check___, added parameter in call to Cust_Ord_Date_Calculation_API.Calc_Due_Date_Forwards.
--  110316  MaMalk   Removed some unwanted code related to tax_class_id from Unpack_Check_Update___.
--  110316  MaMalk   Modified Validate_Fee_Code___ to execute a certain logic only when the new_fee_code_ is null.
--  110128  ShVese   Replaced use of Part Catalog serial tracking_code with the receipt_issue_serial_track.
--  110125  Darklk   Bug 95211, Modified Unpack_Check_Update___ to consider supply code 'ND' when supply code is modified for Non Inventory parts.
--  110303  MalLlk   Added new view CUSTOMER_ORDER_LINE_UIV with user allowed site filter to be used in the client.
--  110202  Nekolk   EANE-3744  added where clause to View CUSTOMER_ORDER_LINE.
--  110309  MaMalk   Modified Validate_Fee_Code___ to fetch the vat free vat code from the CO header when a single occurence address is used.
--  110309  Kagalk   RAVEN-1074, Added tax_id_validated_date field
--  110224  MaRalk   Modified method Delete___ to Clear CO Line information when the
--  110224           CO line was created by a Component Repair Order Line.
--  110223  MaMalk   Replaced Delivery_Fee_Code_Pub with Customer_Delivery_Fee_Code_Pub.
--  110223  MaMalk   Replaced Customer_Info_Vat_API with new APIs.
--  110221  MaMalk   Modified method Update___ to retrieve taxes correctly when the tax liability is changed.
--  110216  AndDse   BP-4296, Fixed so there is a recalculation when the external transport calendar is removed.
--  110214  AndDse   BP-4146, Add info message when planned delivery date is moved within the date calculations.
--  110203  MiKulk   Modified the Validate_Fee_Code___ method to fix some tax fetching issue.
--  110111  MiKulk   Modified the method Get_Ipd_Vat_Liability to fix some tax identity fetching errors.
--  110111  MiKulk   Modified the logic to pass the tax liability stored in the customer order lines.
--  110111  MiKulk   Replaced the calls to Ipd_Tax_Info_Addr_API and Ipd_Tax_Info_Inv_API with the new methods.
--  110111           Removed the methods Get_Vat_Liability_Addr___ and Get_Vat_Liability_Inv___.
--  110110  MaMalk   Added Tax Liability and Delivery Country Code as attributes.
--  110106  MiKulk   Updated the Validate_Fee_Code___ to fetch the correct fee code and the tax class id..
--  110104  MaMalk   Added method Modify_Tax_Class_Id.
--  110103  MaMalk   Handled NVL when calling method Customer_Tax_Free_Tax_Code_API.Get_Vat_Free_Vat_Code with delivery type.
--  101231  MaMalk   Modified Change_Package_Structure___ to reflect the package fee code and tax class to the package lines.
--  101222  MiKulk   Modified the logic for retriving tax regime, tax liability, tax identity and tax free tax code.
--  101222  MaMalk   Added Tax_Class_Id to the LU.
--  110208  UTSWLK   Modified code in Unpack_Check_Update__ to move the planning delivery date forward when it falls on a non working day when re-genarate a calendar.
--  110107  AndDse   BP-3776, Added EXT_TRANSPORT_CALENDAR_ID to LU.
--  110122  MalLlk   Modified method Check_Supply_Code___ to validate the Supply Code 'CRO'.
--  110120  MaEelk   Passed demand code to Get_Next_Line_No when it is being called from Unpack_Check_Insert___.
--  110106  MaEelk   Modified Delete___ to send a call to Srv_Sales_Lines to change the
--  110106           Srv Sales Line back to Invoiceable state.
--  101217  AndDse   BP-3565, Modified Unpack_Check_Update__ and Unpack_Check_Insert__ so that a warning is shown if wanted delivery date is a non working day.
--  101223  Vwloza   HIGHPK-2468, merged 91803
--                   100824  Chselk   Bug 91803. Modified Validate_Proj_Connect___ to add SEO to supply_code_db_ changing check.
--  101102  NiBalk   Bug 93898, Modified Get_Line_Defaults___ to avoid raising an unwanted error message when creating a CO from an external service order.
--  101011  THTHLK   HIGHPK-2601, Modified PROCEDURE Calculate_Cost_And_Progress and Handle_Activity_Seq___.
--  100927  THTHLK   HIGHPK-2220, Modified PROCEDURE Calculate_Cost_And_Progress, Calculate_Revenue___ and Handle_Activity_Seq___
--  100818  THTHLK   HIGHPK-1904, Modified PROCEDURE Calculate_Revenue___.
--  100707  THTHLK   HIGHPK-1032, Modified PROCEDURE Calculate_Cost_And_Progress, PROCEDURE Calculate_Revenue___ and PROCEDURE Handle_Activity_Seq___ to report transaction currency.
--  101214  UTSWLK   Added public attribute cust_calendar_id.
--  100930  ShKolk   Modified Get_Line_Defaults___ to select input uom group passing the inventory part number.
--  100923  MalLlk   Added function Check_Exist to check if the specified record exists.
--  101013  NWeelk   Bug 93306, Modified method Check_State by adding a condition to check the objstate_ before calling Finite_State_Machine___
--  101013           and modified function Line_Is_Fully_Invoiced___ by restructuring the code to handle state transition of package header correctly.
--  101006  JuMalk   Bug 93363, Modified Update method to check whether the value of ship_addr_no has been changed, and add a new customer order history line record.
--  101006  Cpeilk   Bug 93365, Assigned value for dop_connection when NULL in Unpack_Check_Insert___.
--  100921  ChFolk   Modified Unpack_Check_Insert___, Unpack_Check_Update___ and Modify_Freight_Info to get active freight_price_List_No based on supply_code.
--  100820  MaHplk   Added new parameter price_effec_date_changed_ to Modify_Wanted_Delivery_Date__ and modified Unpack_Check_Update___.
--  100818  ChFolk   Modified Update___ to allow inserting charge lines when freight informations are changed.
--  100817  ChFolk   Added new procedure Modify_Freight_Info which is a public interface to update freight info in CO line.
--  100816  ChFolk   Modified Unpack_Check_Insert___ and Unpack_Check_Update___ to allow to fetch freight information even if no supply chain parameters are set.
--  100816           Modified Update___ to avoid inserting vat type taxes twice as Cust_Ord_Charge_Tax_Lines_API.Add_Tax_Lines support for all tax types.
--  100806  ChFolk   Removed method Update_Freight_Info as the functionality was changed.
--  100729  ChFolk   Added new procedure Update_Freight_Info which updates the freight information in CO line.
--  100714  ChFolk   Removed attributes bonus_basis and bonus_value. Removed methods Modify_Bonus_Basis and Modify_Bonus_Value.
--  100714           Removed methods calls for bonus calculations as bonus functionality is obsoleted.
--  100702  ShKolk   Modified Get_Supply_Chain_Defaults___() to add a validation for supply code.
--  100830  MoNilk   Added code to generate state package related code automatically from the entity model.
--  100629  ShVese   Removed call to Finite_State_Machine(NULL) for state and event NULL in Finite_State_Machine___ method.
--  100621  MoNilk   Modified Ref AccountingProject by passing company as a parameter in CUSTOMER_ORDER_LINE view comments.
--  100520  KRPELK   Merge Rose Method Documentation.
--  100928  NWeelk   Bug 93056, Modified the function Line_Is_Fully_Delivered___ by dividing int_revised_qty_due_ by the internal CO conversion factor.
--  100927  ChJalk   Bug 93032, Modified the method Update_Pegged_Orders__ to change the demand code to 'IO' upon delivering a connected Customer Order Line.
--  100903  SudJlk   Bug 92536, Modified method Check_Before_Update___ to stop unnecessary error message display for records with staged billing.
--  100806  AmPalk   Bug 91492, Added Copy_Prepostings_To_Line.
--  100810  ChJalk   Bug 92303, Modified the method Calculate_Qty_To_Load to use the table CUSTOMER_ORDER_TAB to get the order
--  100810           lines where the order state is not equal to 'Planned'.
--  100805  NWeelk   Bug 92042, Modified method Unpack_Check_Insert___ by introducing an error message to raise when serial tracked parts
--  100805           with the option to create S/M object are entered to a package part in an intersite flow between different companies.
--  100728  ChJalk   Bug 91913, Modified methods Insert_Package___ and Change_Package_Structure___ to avoid assigning the package header values for SHIP_VIA_CODE,
--  100728           DEFAULT_ADDR_FLAG_DB and DELIVERY_LEADTIME if the supply code of the component line is 'IPD' or 'PD'.
--  100716  ChJalk   Bug 91972, Reversed the change done in previous version of this bug and inserted a while loop and changed the condition to raise the error in Modify__.
--  100716  ChJalk   Bug 91972, Moved the error message UPDATE_NOT_ALLOWED from Modify__ to Unpack_Check_Update___ and modified the
--  100716           condition to raise the error.
--  100712  ChJalk   Bug 91135, Modified method Calculate_Order_Line_Dates___ to add parameters demand_ref and demand_code to the
--  100712           method call Cust_Ord_Date_Calculation_API.Calc_Order_Dates_Backwards.
--  100707  ChJalk   Bug 91223, Modified Calculate_Order_Line_Dates___ to avoid making old_demand_qty_ 0 for the supply codes 'PT', 'PD', 'IPT' and 'IPD'.
--  100702  PaWelk   Bug 91146, Modified Unpack_Check_Update___() to raise an error when necessary in charged item functionality.
--  100507  ShVese   Modified Finite_State_Machine to match the developer studio state machine model and created method Do_Set_Pkg_Header_State___. .
--  100615  KaEllk   Fixed merge error in Get_Activity_Planned_Cost___.
--  100609  KaEllk   Fixed merge errors in Validate_Proj_Connect___.
--  100525  MaAnlk   Bug 90829, Removed function Get_Object_Version.
--  100506  SaJjlk   Bug 89120, Modified methods Unpack_Check_Update___ and Init_Before_Check_Insert___ to correctly set the
--  100506           default address flag and the delivery terms when manual editing is done on client.
--  100504  NuVelk   Merged Twin Peaks.
--  100430  ErFelk   Bug 89205, Added customer_po_rel_no and customer_po_line_no to the Get().
--  100427  MaGuse   Bug 90050, Modified Change_Package_Structure___() by adding a condition to allow saving a change done to promised_delivery_date.
--  100422  MaAnlk   Bug 79609, Added Get_Object_Version. Modified Check_Before_Update___ and Unpack_Check_Update___.
--  100420  MaGuse   Bug 89278, Removed sending addr_flag to the method call Customer_Order_Charge_API.Add_All_Tax_Lines in method Update___.
--  100326  SaJjlk   Bug 88020, Modified method Validate_Fee_Code___ and modified the condition added to check the demand code.
--  100326  MaRalk   Bug 89568, Bug 89568, Modified Validate_Proj_Disconnect___ to retain the demand code IPD when disconnecting from the project.
--  100322  MaRalk   Bug 89568, Modified Handle_Activity_Seq___ to add validation for incoming customer order. Added error message SAMEDEMANDSITEPROJECT.
--  100315  SaJjlk   Bug 87532, Modified method Unpack_Check_Update___ to check values of new and old records for column
--  100315           create_sm_object_option before raising the error message for customer order lines with demand code DO.
--  100310  SudJlk   Bug 89094, Modified method Insert___ to allow creating credit invoices when supply code is SEO.
--  100309  SudJlk   Bug 88020, Modified method Validate_Fee_Code___ to allow changing of the delivery address in the IPD flow.
--  100304  JuMalk   Bug 89249, Modified Init_before_Check_Insert___ to check for null values of DISTRICT_CODE and REGION_CODE in attr_, before calling Client_SYS.Set_Item_Value().
--  100311  AmDilk   Jira Key TWINPK-548 Altered Handle_Activity_Seq___(), Calculate_Cost_And_Progress() to prevent reporting cost for COLs created through WOs
--  100226  ShRalk   Jira Key TWINPK-675 Modified Handle_Activity_Seq___ to restructure the IF condition to handle the system_ctrl_connection_.
--  100201  NiBalk   Bug 88558, Modified Line_Is_Fully_Delivered___, to consider the revised qty due in
--  100201           internal customer order, only at intersite direct delivery flow.
--  100121  Cpeilk   Bug 88377, Modified view PREPAY_TAX_INFO to remove Cancelled lines and zero priced parts from the view.
--  100118  JuMalk   Bug 86936, Introduced company to the base view. Site_API.Get_Cpmpany call can get elimanated from client form.
--  100115  NWeelk   Bug 87822, Modified method Unpack_Check_Insert___ to get the correct value for shipment_creation when the
--  100115           Deliver-to-Customer ID is different from the customer stated in the CO header.
--  100115  CWICLK   DE546, Added new error message to Check_Before_Update___.
--  091223  NirSlk   Added check for demand code in Handle_Activity_Seq___, to exclude automatically connected COs.
--  091202  RoJalk   Modified Check_Supply_Code___ to support SEO in project related validations.
--  091127  RoJalk   Moved some of the project related validations in Unpack_Check_Update___ to Check_Supply_Code___ to be applicable for
--  091127           new package lines added for a project connected customer order line.
--  091120  NuVelk   Modified method Handle_Activity_Seq___ to set the system_ctrl_connection_ to FALSE for package part headers.
--  091119  RoJalk   Modified project cost element generation logic to consider sales overhead only if charged_item = 'CHARGED ITEM'.
--  091116  RoJalk   Modified Validate_Proj_Connect___, Unpack_Check_Insert___, Change_Package_Structure___,Init_Before_Check_Insert___
--  091116           and Validate_Proj_Connect___ to improve the project cost reporting for package parts.
--  091116  KaEllk   Modified Calculate_Revenue___ to make system connection check box TRUE.
--  091110  NuVelk   Modified Get_Elements_From_Purch___, Get_Elements_From_Invent___ and the calling method Get_Activity_Planned_Cost___ to use part_no.
--  091112  Janslk   Modified Get_Activity_Info___ to only report planned and committed when part_ownership
--                   is not 'CUSTOMER OWNED' or 'SUPPLIER LOANED'.
--  091112  RoJalk   Modified Calculate_Revenue___ and moved the method call to fetch the value for company.
--  091112  RoJalk   Modified Insert___, Update___ and called Calculate_Revenue only when charged_item = 'CHARGED ITEM'.
--  091110  Kaellk   Modified Handle_Activity_Seq___ to add validation for incoming customer order.
--  091109  Nirslk   Modified Calculate_Revenue___ to handle revenue elements and cost elements separately.
--  091103  ShRalk   Modified Update__ to restructure the call Create_Connected_Order_Line when supply code is changed from Non NI,PRJ to PT,PD,PDT,IPD.
--  091109  RoJalk   Modified Unpack_Check_Update___ and assigned 0 to newrec_.qty_to_ship when oldrec_.supply_code is PRJ.
--  091105  RoJalk   Modified Calculate_Revenue___ to skip the revenue calculation for PKG part component lines.
--  091104  RoJalk   Modified Check_Released_Activity__ to consider Reserved CO lines.
--  091103  ShRalk   Modified Update__ to call Create_Connected_Order_Line when supply code is changed from Non NI,PRJ to PT,PD,PDT,IPD.
--  091023  RoJalk   Modified Get_Activity_Info___ to stop the used cost reporting when supply option is IPD - sites from different companies.
--  091021  KaEllk   Added Update_Proj_Ms_Forecast___. Modified Update___ to update forecast when qty delivered or returned.
--  091016  ShRalk   Modified Check_Before_Update___ to include to update supply from Non NI/PRJ to PT,PD,PDT,IPD.
--  091015  RoJalk   Added General_SYS.Init_Method to Remove_Project_Connection___ and Calculate_Revenue___.
--  091014  RoJalk   Modified Check_Supply_Code___ and Validate_Proj_Connect___ to support project connection for DOP. PT, PD and SO configured parts.
--  091012  AmDilk   Altered method Unpack_Check_Insert___() and Validate_Proj_Connect___(). Allowed project validations for COLs with supply code 'SEO'
--  091012  THTHLK   Defect DE303, Modified Calculate_Cost_And_Progress.
--  091007  RoJalk   Removed the method call Order_proj_Revenue_Manager_API.Clear_Temporary_Table from Calculate_Revenue___.
--  091007  KaEllk   Renamed method Report_Revenue to Calculate_Revenue. Removed Handle_Activity_Revenue__. Modified Calculate_Revenue.
--  091007  RoJalk   Created the method Calculate_Revenue___ which will perform the functions of Calculate_Revenue.
--  091001  RoJalk   Added the method Project_Connection_Exist___ and called from Calculate_Cost_And_Progress, Calculate_Revenue.
--  090930  KaEllk   Renamed and changed scope of Process_Report_Revenue___ to Report_Revenue. Modified Report_Revenue.
--  090925  RoJalk   Modified Delete___ and used the method Connect_Customer_Order_API.Remove_Project_Connection to remove project connections.
--  090924  ShRalk   Modified Handle_Activity_Seq___ and Calculate_Revenue to pass activity_rev_info_tab_ to
--  090924           Project_Connection_Util_API.Create_Connection and Project_Connection_Util_API.Refresh_Activity_Info
--  090923  RoJalk   Modified Handle_Activity_Seq___ and passed proj_lu_name to Connect_Customer_Order_API.Remove_Project_Connection.
--  090923  KaEllk   Added methods Process_Report_Revenue___, Calculate_Revenue, Handle_Activity_Revenue__ to be used as background jobs.
--  090923  RoJalk   Added methods Calculate_Revenue, Handle_Activity_Revenue__ to be used in project revenue calculation.
--  090923  THTHLK   Defect DE176, Modified Calculate_Cost_And_Progress.
--  090923  SHRALK   Added condition to calcualte Revenue in Update___().
--  090908  JANSLk   Changed Calculate_Cost_And_Progress to fetch hours progress from DOP when supply option is DOP.
--  090907  JANSLk   Changed Calculate_Cost_And_Progress to fetch hours progress from SO when supply option is SO.
--  090903  RoJalk   Added some missing tags
--  090902  KAELLK   Added check for active forecast part in Get_Activity_Info.
--  090901  JANSLK   Corrected LU name for inst_DOPHead_.
--  090901  RoJalk   Modified Get_Activity_Info___ to report the used cost for ICD - Non Inventory Parts.
--  090825  RoJalk   Modified Get_Elements_Project_Inv___ and called from Get_Activity_Planned_Cost___ to calculate planned cost for Project Inventory - PI supply option.
--  090825  MaRalk   Removed the error message COLCONFIG in Check_Before_Update___ and replaced in Validate_Proj_Connect___ and Check_Supply_Code.
--  090824  MaRalk   Removed the error message COLCONFIG in Unpack_Check_Update___ and Validate_Proj_Connect___ and replaced with a new error text within Check_Before_Update___.
--  090821  NuVelk   Modified Procedures Check_Before_Update___ and Update___ to allow supply code change from 'PI' to 'SO', 'PT', 'PD', 'IPT' and 'IPD'.
--  090820  RoJalk   Modified Handle_Activity_Seq___ to handle planned hours.
--  090819  MaRalk   Modified Procedures Check_Before_Update___, Unpack_Check_Update___ and Update___ to allow supply code change from 'IO'/'PI' to 'DOP' when the CO line is Released.
--  090819           Removed error message CONNECT_NOCHANGE: DOP connection may not be changed after release of the order! since it is no longer valid.
--  090818  RoJalk   Modified Check_Before_Update___ to handle the unpegging of project connected,released Customer Orders with PT, IPT, PD and IPD supply type.
--  090817  RoJalk   Modified Get_Activity_Planned_Cost___ to support planned cost calculation for supply option - DOP.
--  090813  RoJalk   Modified Get_Activity_Info___ to support cost calculation for supply option - DOP.
--  090813  MaRalk   Modified Validate_Proj_Connect___ to allow project connection for supply option DOP and to restrict project connection for configurable parts with the same supply option.
--  090812  MaRalk   Modified Get_Activity_Info___ to report committed and used cost for supply option - Project Delivery.
--  090812  RoJalk   Modified Unpeg_Line and Get_Activity_Info___ to consider customer order lines with supply type - Int Purchase Order Direct.
--  090811  MaRalk   Modified Unpack_Check_Update___ in order to raise an error message when changing the supply code to Purch Order Trans, Int Purch Trans or Shop Order
--  090811           for of a project connected configured part line.
--  090810  MaRalk   Modified Validate_Proj_Connect___ in order to raise an error message when trying to make a project connection for a configured part line
--  090810           for supply options Purch Order Trans, Int Purch Trans and Shop Order.
--  090810           Modified Unpeg_Line in order to modify supply code for non inventory parts when unpegging.
--  090806  RoJalk   Modified Get_Elements_Non_Inv___ to stop the cost element simulation when sales_part_cost_ is 0 or null.
--  090804  Ersruk   Renamed text Project Unique Sale to Project Unique Billing in error message.
--  090730  RoJalk   Modified Calculate_Cost_And_Progress to support planned hours calculation when the supply type is Shop Order.
--  090730  RoJalk   Modified Get_Activity_Planned_Cost___ to report planned cost for supply option - Shop Order.
--  090727  RoJalk   Modified Check_Before_Update___ and Unpeg_Line to change the supply code to PI when project connected customer order is unpegged.
--  090710  RoJalk   Modified Get_Activity_Info___ and Get_Activity_Planned_Cost___ to correctly handle the cost calculation for PI.
--  090710  RoJalk   Modified Get_Activity_Info___ and restructured the code related to used cost calculation.
--  090708  RoJalk   Modified Get_Activity_Info___ to handle the correct cost calculation for PT, PD and IPT.
--  090708  RoJalk   Modified Get_Activity_Info___ to support the cost calculation when The supply option is Purchase Order Direct.
--  090708           Modified Validate_Proj_Connect___ so the supply option will remain same for IPT, PD after the project connection.
--  090702  Chselk   Modified Calculate_Cost_And_Progress to pass the earned cost value to the project side.
--  090630  NuVelk   Modified Get_Activity_Planned_Cost___ to report planned cost for supply option ND.
--  090624  NuVelk   Modified Validate_Proj_Connect___, Get_Activity_Info___ to support CO supply type - Not Decided.
--  090623  RoJalk   Modified Get_Activity_Info___ to calculate the commited and used cost for Sales OH - Int Purch Trans.
--  090623  RoJalk   Modified Unpack_Check_Update___ and Validate_Proj_Connect___ to allow project connection for supply option - Int Purch Trans.
--  090623           Modified Get_Activity_Planned_Cost___ to generate planned cost for Int Purchase Trans.
--  090622  RoJalk   Modified Get_Activity_Planned_Cost___ to generate planned cost for Purchase Order Trans.
--  090522  THTHLK   Modified Calculate_Cost_And_Progress to report cost element level cost progress to project activity
--                   for Project Delivery, Purch Order Trans, Purch Order Dir, Int Purch Trans, Int Purch Dir, Shop Order and DOP Order.
--  090513  Ersruk   PA recommended changes, changed Is_Diff_Proj_Exist___ to Diff_Proj_Exist___ returning boolean.
--  090511  Ersruk   Passed in pre_posting_source when calling Pre_Accounting_API.Copy_Pre_Accounting in Insert___.
--  090429  Ersruk   Added Is_Diff_Proj_Exist___() and validations for project unique sale.
--  090427  NuVelk   Modified Check_Before_Update___ and Unpeg_Line to support CO supply type - Purch Order Trans.
--  090421  THTHLK   Modified Calculate_Cost_And_Progress to report cost element level cost progress to project activity
--                   for Supply-Options IO: Invent Order, NO: Non Inventory, PI: Project Inventory.
--  090407  NuVelk   Modified Unpack_Check_Update___ to allow the project connection for supply type - Purch Order Trans
--                   for non inventory parts.Modified Get_Activity_Info___ to not to report CO line committed_cost for
--                   supply option Purch Order Trans.
--  090403  NuVelk   Modified Get_Activity_Info___ to fetch commited and used costs when supply option PT.
--  090324  RoJalk   Modified Get_Activity_Info___ to fetch the Used Cost - Sales OH when supply option is Shop Order.
--  090319  RoJalk   Modified Unpack_Check_Update___ to allow project connection for supply option - Shop Order.
--  090318  RoJalk   Modified Validate_Proj_Disconnect___ and Unpeg__ to support the project connection
--                   removal for pegged shop orders.
--  090313  RoJalk   Modified the Get_Activity_Info___ to stop the committed cost reporting when supply option is Shop Order.
--  090313  NuVelk   Modified Unpack_Check_Update___ to allow project connection for supply type - Purch Order Trans.
--  090311  NuVelk   Modified Validate_Proj_Connect___ to allow the project connection for supply type - Purch Order Trans.
--  090302  RoJalk   Modified Validate_Proj_Connect___ to allow the project connection for supply type - Shop Order.
--                   Modified Get_Activity_Planned_Cost___ to use inventory priority to fetch the
--                   planned cost when supply option is Project Inventory.
--  090212  RoJalk   Modified the conditions for calling Get_Activity_Planned_Cost___ inside Get_Activity_Info___.
--  090212  RoJalk   Added method Check_Released_Activity__.
--  090210  RoJalk   Minor code improvements.
--  090210  RoJalk   Replaced contract with supply site inside Get_Activity_Planned_Cost___
--                   when calling project cost element generation methods for IPD supply option.
--                   Modified the check to identify if the sites are connected to the same company.
--  090206  RoJalk   Modified Purchase_Part_Supplier_API.Get_Project_Cost_Elements method call inside
--                   Get_Elements_From_Purch___ and added new parameter to indicate source_ref_type_db_.
--  090205  NuVelk   Modified Get_Activity_Planned_Cost___ to support supply option Invent Order.
--  090103  RoJalk   Modified the methods Get_Activity_Planned_Cost___, Get_Elements_From_Purch___,
--                   Get_Elements_From_Invent___ to consider catalog_no instead of part_no column.
--  090102  RoJalk   Modified Get_Activity_Planned_Cost___ to consider the supply option project delivery.
--  090130  RoJalk   Modified and used Get_Elements_Non_Inv___ inside Get_Activity_Info___ to calculate the commited cost.
--  090130  RoJalk   Modified Get_Activity_Planned_Cost___ to consider supply options PI, NO, PD and IPD.
--  090130  RoJalk   Modifications to the method Get_Elements_From_Purch___.
--  090129  RoJalk   Modified the methods Get_Activity_Info___, Calculate_Cost_And_Progress
--                   and Handle_Activity_Seq___ to support planned cost reporting.Added method
--                   Get_Elements_Non_Inv___ and called from Get_Activity_Info___.
--  090129  RoJalk   Added methods Get_Elements_From_Purch___,Get_Elements_From_Invent___, Get_Activity_Planned_Cost___.
--  090127  RoJalk   Added the method Get_Elements_From_Purch___.
--  090127  RoJalk   Modified Validate_Proj_Connect___ to allow the connection of planned activities.
--  100114  KAYOLK   Replaced the obsolete usages of Shop_Order_Int_API calls to other relevant methods.
--  100105  MaRalk   Modified the state machine according to the new developer studio template - 2.5.
--  091224  MaEelk   Replaced the obsolete method calls Interim_Order_Int_API.Set_Demand_Qty_And_Date,
--  091224           Interim_Order_Int_API.Remove_Interim_Head_By_Usage and Interim_Order_Int_API.Get_Int_Head_By_Usage
--  091224           respectively with Interim_Demand_Head_API.Set_Demand_Qty_And_Date, Interim_Demand_Head_API.Remove_Interim_Head_By_Usage
--  091224           and Interim_Demand_Head_API.Get_Int_Head_By_Usage.
--  091222  KAYOLK   Modified the method Is_Pre_Posting_Mandatory() for renaming the code part
--  091222           cost_center, object_no, and project_no as codeno_b, codeno_e and codeno_f respectively.
--  091203  KiSalk   Changed backorder option values to new IID values in Customer_Backorder_Option_API.
--  091123  MaRalk   Added reference CustOrdCustomer to customer_no in CUSTOMER_ORDER_LINE view.
--  091120  MaRalk   Added reference Site to contract in CUSTOMER_ORDER_LINE view and modified Unpack_Check_Insert___.
--  091104  MaRalk   Modified CUSTOMER_ORDER_LINE - company column view comments.
--  090930  MaMalk   Removed unused constants inst_PurchaseOrderLine_, inst_AccountingProject_, state_separator_ and views CUST_ORDER_LINE_PACK_VER_LOV, CUST_ORDER_LINE_PACK_VER_LOV2,
--  090930           CUSTOMER_ORDER_LINE_ADDRESS and CUSTOMER_ORD_LINE_PROMISE_LOV. Modified Insert___, Unpack_Check_Update___, Update___, Change_Package_Structure___, Get_Line_Defaults___,
--  090930           Check_Before_Insert___, Check_Before_Update___, Init_Before_Check_Insert___, Post_Insert_Actions___, Handle_Activity_Seq___, Get_Total_Tax_Amount_Curr, Insert_Package___,
--  090930           Validate_Proj_Connect___, Calc_Dates_Forwards__, Finite_State_Machine___ and Finite_State_Init___ to remove unused code.
--  ------------------------- 14.0.0 ----------------------------------------------
--  091027  MaRalk   Added dummy column company to the view CUSTOMER_ORDER_LINE and rollback the modifcation done to the view comments delivery_type and fee_code.
--  100426  JeLise   Renamed zone_definition_id to freight_map_id.
--  100312  ShKolk   Changed Update_Freight_Free___() to public Update_Freight_Free().
--  100310  ShKolk   Added error message COLINESHIPCONNECT.
--  100201  KiSalk   Added view CAMPVIEW.
--  100111  SudJlk   Bug 87997, Modified method Line_Is_Fully_Invoiced___ to correctly handle CO staus change when the line is fully delivered.
--  091222  SudJlk   Bug 87997, Reverse bug 86969 and modified method Line_Is_Fully_Invoiced___.
--  091124  SudJlk   Bug 86969, Modified method Line_Is_Fully_Invoiced___ to correctly set status correctly for internal Customer Orders with an Invoicing Customer.
--  091217  NiBalk   Bug 87000, Modified Init_Before_Check_Insert___() to handle Del Terms and Del Terms Location in the Intersite Flow.
--  091215  SaJjlk   Bug 86683, Modified method Handle_Activity_Seq___ to check only the line_item_no when setting system_ctrl_connection_.
--  091211  Castse   Bug 87472, Removed check of comp_rec_.addr_flag from condition in Update___.
--  091211  Castse   Bug 86107, Modified the method Modify_Wanted_Delivery_Date__ to add parameters replicate_changes_, change_request_  and dop_changed_ .
--  091210  JuMalk   Bug 85282, Modified method Make_Service_Deliverable__ to consider the qty_on_order when setting the value of qty_to_ship.
--  091204  Castse   Bug 86220, Modified method Line_Is_Fully_Delivered___ to consider the revised qty due in internal customer order in intersite direct delivery.
--  091203  ShKolk   Bug 86199, Rollback bug 69675.
--  091202  ShKolk   Bug 87224, Modified Unpack_Check_Update___ to allow changing abnormal_demand when the CO is Invoiced.
--  091126  Castse   Bug 86813, Added condition in Unpack_Check_Update___ to check if default_addr_flag was modified in the client.
--  091103  NaLrlk   Bug 86768, Merge IPR to APP75 Core.
--  091025  SaJjlk   Bug 86683, Modified method Handle_Activity_Seq___ to set the system_ctrl_connection_ to FALSE for package part headers.
--  091021  NWeelk   Bug 86041, Modified method Update___ to add the db_value of price source to newrec_ and to add the corect value for part_price.
--  091013  NWeelk   Bug 86041, Modified method Update___ to re-fetch the price information when the customer order line gets modified through server.
--  091001  TiRalk   Bug 86125, Modified Post_Insert_Actions___ by adding qty_to_move for dynamic call to display correct value in Distribution Order History tab.
--  090928  AmPalk   Bug 70316, Modified Get_Base_Sale_Price_Total to calculate the base amount using curr amount as in the invoice.
--  090928           Modified rounding settings of Get_Total_Tax_Amount. Modified Get_Sale_Price_Total and Get_Total_Tax_Amount_Curr to tally with calculations on client.
--  090925  ChJalk   Bug 82611, Modified Unpack_Check_Update___ to allow updating CUSTOMS_VALUE when the status is 'Invoiced'.
--  090901  ChJalk   Bug 82611, Added public attribute customs_value and modified all corresponding methods to handle it.
--  090901           Added new column to customer_order_line view.
--  090826  ChJalk   Bug 83838, Modified the method Update___ to modify discounts when price source is changed.
--  090824  ChJalk   Bug 75274, Modified the method Update___ to add IN parameters qty_shipped_ and qty_assigned_ to the call Connect_Customer_Order_API.Modify_Connected_Order_Line and
--  090824           Check_Before_Update___ to allow changing supply codes 'SO' and 'DOP' to 'IO'in Released and Reserved states as well.
--  090819  SudJlk   Bug 83218, Modified methods Modify_Additional_Discount__ and Modify__ to change some error message texts.
--  090813  PraWlk   Bug 84300, Modified Check_Before_Insert___ and Check_Before_Update___ to create order line for a sales part with replacement part
--  090813           in supply for an external customer in supply site.
--  090812  ChFolk   Bug 81668, Modified Unpack_Check_Insert___ in order to avoid inserting expired tax codes and modified Post_Insert_Actions___ and Update___
--  090812           to avoid validating expired tax_codes and to give an information when there is no any valid tax code is defined.
--  090810  SudJlk   Bug 83218, Modified Modify_Additional_Discount__ and Modify__ to restrict any changes in the customer order line when the supply code is 'SEO'.
--  090806  PraWlk   Bug 84300, Modified Check_Before_Insert___ and Check_Before_Update___ to verify that the customer part and replacement part
--  090806           have the same inventory part and if they do not, to raise an error to stop order line creation.
--  090724  RanRlk   Bug 83774, Removed the condition to check the status of the oldrec_.default_addr_flag = 'N', in Unpack_Check_Update___
--  090724           in order to set the attribute string with default address information all the time if default_addr_flag_ set to Y from the header.
--  090709  SaWjlk   Bug 82404, Removed the rounding in the cursor get_gross_amount_ratio of the function Get_Gross_Amnt_Ratio_Per_Vat__ and modified the rounding in the function Get_Sale_Price_Total.
--  ------  ----     --------------------------------------------------------------
--  091203  SudJlk   Bug 85927, Modified method Init_Before_Check_Insert___ to set REBATE_BUILDER_DB to eliminate the error displayed
--  091203           when saving a new part on package structure in the CO line.
--  091120  DaZase   Changed the view so price_source_net_price_db/price_source_net_price is showing the correct db/client values.
--  091019  RiLase   Added Sales Promotion Tax Code check in Unpack_Check_Update___.
--  090930  DaZase   Changed length on view comment for price_source_net_price.
--  090708  IrRalk   Bug 82835, Modified Unpack_Check_Insert___ and Unpack_Check_Update___ to round weight
--  090708           and volume to 4 and 6 decimals respectively.
--  090618  DaGulk   Bug 83946, Modified view PREPAY_TAX_INFO to get data from cust_order_line_tax_lines_tab.
--  090605  ChJalk   Bug 83275, Reversed the previous correction and modified Update_Pegged_Orders__ to check the qty before updating SO or PO.
--  090604  ChJalk   Bug 83432, Modified Unpack_Check_Insert___ to add NVL to the demand_code check.
--  090604  ChJalk   Bug 83275, Modified Check_Before_Update___ to allow change the supply code from 'PT', 'PD', 'IPT', 'IPD' OR 'SO' to 'IO' OR 'NO' if the line is fully reserved.
--  090527  SuJalk   Bug 83173, Modified the error constant to COLWRONGSTATUS in order to make it unique in method Validate_Proj_Connect___. Also modified the error message NOVENDPART to have a fullstop and formatted it.
--  090525  SudJlk   Bug 81907, Added method Get_Part_Ownership_And_Owner.
--  090522  SudJlk   Bug 82921, Modified method Unpack_Check_Insert___ to allow merging of CO lines to an existing CO when demand code is DO.
--  090520  SuJalk   Bug 82486, Added view PREPAY_INVOICE_INFO. Modifid the Get_Gross_Amnt_Ratio_Per_Vat__ to use the PREPAY_INVOICE_INFO view.
--  090516  AmPalk   Bug 82483, Restricted cost fetch in Unpack_Check_Update___ for customer owned or supplier loaned parts.
--  090513  NWeelk   Bug 82484, Modified Procedures Check_Before_Update___ and Update___ to allow supply code change from 'IO' to 'SO', 'PT', 'PD', 'IPT' and 'IPD'.
--  090505  ShRalk   Bug 76762, Added method Check_Or_Modify_Activity_Seq. Modified methods Validate_Proj_Connect___, Validate_Proj_Disconnect___ and
--  090505           Check_Before_Update___ to further support activity sequence changes.
--  090430  DaGulk   Bug 81231, Modified method Update___ to set the QTY_INVOICED amount to zero if the zero price customer order line changes it's price in a staged billing situation.
--  090429  SuJalk   Bug 81637, Modified the Check_Before_Update___ to allow the user to change between supply codes even if the CO header is in released state for configurable non-configured parts.
--  090429           However the supply codes would still be validated. Also restructured the ELSIF conditions in Check_Before_Update___ for better readability.
--  090410  SuJalk   Bug 79924, Modified the Update___ method to save the correct value for sale_unit_price.
--  090320  SuJalk   Bug 80870, Added method Get_Calculated_Pkg_Cost.
--  090316  SudJlk   Bug 80264, Modified Init_Before_Check_Insert___ to modify value setting for del_terms_location when a customer agreement exists.
--  090318  ChJalk   Bug 77720, Modified the method Finite_State_Set___ to update the project details if the demand code is 'PO'.
--  090212  MaMalk   Bug 80285, Modified Validate_Delivery_Conf___ to have a check on CO Header delay_cogs_to_deliv_conf instead of CO Header confirm_deliveries to raise an error
--  090212           when Inventory Part is set up with any other part cost level than cost per part.
--  090130  SaJjlk   Bug 79846, Removed the length declaration for NUMBER type variable old_note_id_ in method Insert___.
--  090130  SudJlk   Bug 76805, Modified the method call to Reserve_Customer_Order_API.Control_Ms_Mrp_Consumption in Delete___.
--  080107  SudJlk   Bug 78030, Removed the check for newrec_.demand_code = 'IPD' in Get_Supply_Chain_Defaults___.
--  081230  ChJalk   Bug 70877, Added new column load_id and methods Connect_To_Load_List, Disconnect_From_Load_List.
--  081223  SuJalk   Bug 79451, Made the promised_delivery_date attribute public.
--  081222  SudJlk   Bug 78030, Modified method Get_Supply_Chain_Defaults___ to retrieve correct delivery information when supply code or delivery address is changed on CO line.
--  081219  SudJlk   Bug 79158, Modified Init_Before_Check_Insert___ to set newrec_.qty_shipped to zero.
--  081218  SuJalk   Bug 79233, Added checks in Unpack_Check_Insert___ and Unpack_Check_Update___  to raise error messages if the qty_assigned is negative.
--  081215  ThAylk   Bug 74645, Added function Get_Current_Info and global variable current_info_.
--  081215  ChJalk   Bug 77014, Modified Get_Base_Sale_Price_Total replacing base_sale_unit_price with sale_unit_price * currency_rate.
--  081211  SaRilk   Bug 77033, Modified Update___ and Post_Insert_Actions___ methods by changing the variable temp_ to dummy_.
--  081205  ThAylk   Bug 78554, Modified method Get_Line_Defaults___ to add FEE_CODE to attr_.
--  081205  SaRilk   Bug 77033, Modified Update___ and Post_Insert_Actions___ by modyfying the call to Shipment_Handling_Utility_API.Add_Order_Line_To_Shipment.
--  081201  HoInlk   Bug 78456, Moved global LU CONSTANTS defined in specification to implementation.
--  081125  ChJalk   Bug 77780, Modified the method Unpack_Check_Insert___ to avoid changing the supply_code for the newly created project
--  081125           connected Customer Order Lines, if it is creted from a Purchase Order.
--  081124  SaRilk   Bug 77973, Modified the procedures Insert___, Update___ and Unpack_Check_Update___ by checking the catalog type and the backorder_option before updating the value
--  081124           of newrec_.qty_to_ship and modified the procedure Change_Package_Structure___ by checking the backorder_option before updating the value of newrec_.qty_to_ship.
--  081124  ThAylk   Bug 74643, Modified method Create_Sourced_Co_Lines to add a call to Cust_Order_Line_Discount_API.Calc_Discount_Upd_Co_Line__.
--  081031  ChJalk   Bug 76959, Added DEFAULT 'TRUE' parameter add_hist_log_ to Set_Qty_Assigned and modified the method Set_Qty_Shipped.
--  081029  SuJalk   Bug 76539, Added method Get_Internal_Or_Customer_Po_No.
--  081028  MaMalk   Bug 75418, Modified procedure Modify_Delivery_Data to handle the info.
--  081025  SaRilk   Bug 78033, Modified the Procedure Check_Supply_Code___ by restructuring the code for non inventory parts.
--  081024  ChJalk   Bug 77109, Added Procedure Update_Pegged_Orders__ and called it in method Finite_State_Set___ to make the qty_on_order of pegged orders to 0 after the COL is delivered.
--  081020  SaRilk   Bug 77664, Modified the attribute purchase_part_no by allowing it to update. Modified Check_Supply_Code method
--  081020           by replace newrec_.catalog_type with sales_part_rec_.catalog_type.
--  080908  MaEelk   Bug 75750, Attributes DemandOrderRef1, DemandOrderRef2, DemandOrderRef3 and DemandOrderRef4 were made public.
--  080825  ChJalk   Bug 75647, Modified methods Unpack_Check_Update___ and Check_Before_Update___ to handle suply code PRD in the Customer Order Line.
--  080821  DaZase   Bug 74605, Removed bug 69540 implementation in method Calculate_Order_Line_Dates___. Added a check on planned_ship_date in method Update_Package___.
--  080821  SudJlk   Bug76450, Modified the call to Sales_Part_API.Get_Conv_Factor in methods Check_Before_Insert___ and Unpack_Check_Update___.
--  080806  ChJalk   Bug 76093, Modified the methods Insert___ and Update___ to take the weight_net from Inventory part if that information is not
--  080806           available in sales part table.
--  080801  NiBalk   Bug 74688, Added new implementation method Generate_Next_Level_Demands___.
--  080801           Modified Update___ and Post_Insert_Actions___ in order to create a supply when
--  080801           increasing the quantity of CO line, for next level demand parts.
--  080729  ThAylk   Bug 76006, Modified method Check_Before_Update___ to give an error message if configuration is changed when there exist a manual pegging.
--  080709  RoJalk   Bug 74811, Removed parameters pre_accounting_id, activity_seq and project_id and transaction_id from the calls
--  080709           Invent_Proj_Cost_Manager_API.Get_Project_Cost_Elements and Mpccom_Accounting_API.Get_Project_Cost_Element in Get_Activity_Info___.
--  080625  ChJalk   Bug 72631, Replaced the attribute HEADER_DATE_CHANGED with UPDATE_PEGGED_ORDERS. Modified method Update___ to modify the connected
--  080625           Order line if the UPDATE_PEGGED_ORDERS flag is TRUE. Also modified method Check_Pegged_Component_Exist to see whether there are objects pegged to a 'SO'.
--  ------  ----     -------------------------------------------------------------
--  090706  RiLase   Added Sales Promotion connection check in Check_Delete___.
--  090624  KiSalk   Changed call Customer_Order_Pricing_API.Get_Valid_Price_List to Sales_Price_List_API.Get_Valid_Price_List.
--  090323  DaZase   Added new columns part_level, part_level_id, customer_level and customer_level_id used these in calls to Get_Order_Line_Price_Info.
--  090306  ShKolk   Added freight_free to Init_Before_Check_Insert___().
--  090304  ShKolk   Added freight_free to Prepare_Insert___().
--  090227  ShKolk   Added column freight_free.
--  090224  KiSalk   Added curser get_manual_pick_lines and modified Unpack_Check_Update___.
--  090220  MaHplk   Modified Get_Supply_Chain_Defaults___.
--  090122  DaZase   Resizing price_source_ variable in methods Insert_Package___, Init_Before_Check_Insert___ and Get_Line_Defaults___
--  090121  ShKolk   Added Get_Base_Sale_Price_Total().
--  090120  DaZase   Added parameters to call Customer_Order_Pricing_API.Get_Valid_Price_List inside method Get_Line_Defaults___.
--  090119  ShKolk   Modified Get_Supply_Chain_Defaults___() to pass vendor_no when fetching freight_price_list_no.
--  090113  ShKolk   Modified Get_Supply_Chain_Defaults___() to fetch value for freight_price_list_no.
--  090108  ShKolk   Modified Update___() to consider buy_qty_due when entering charges.
--  090107  ShKolk   Added column freight_price_list_no.
--  081015  MaJalk   Set call for Escm_Quick_Ord_Entry_Head_API as dynamic at Get_Line_Defaults___.
--  081002  MaJalk   Set zone details to NULL at Unpack_Check_Update___ when addr_flag is changed.
--  081001  MaJalk   At Get_Line_Defaults___, set INPUT_UNIT_MEAS and INPUT_CONV_FACTOR when demand code
--  081001           is NULL and when order has not created with direct sales order.
--  080926  AmPalk   Added columns adjusted_weight_net, adjusted_weight_gross and adjusted_volume to customer_order_line_tab in order to use for freight charges.
--  080925  MaJalk   At Get_Line_Defaults___, check for cust_usage_allowed when adding INPUT_UNIT_MEAS and INPUT_CONV_FACTOR.
--  080919  MaJalk   Added reference for zone_definition_id at VIEW comments.
--  080915  AmPalk   Modified conditions to call Modify_Cust_Order_Charge_Line and New_Cust_Order_Charge_Line of Customer_Order_Charge_Util_API.
--  080912  MaJalk   Added zone details to call Cust_Order_Leadtime_Util_API.Get_Ship_Via_Values.
--  080911  MaJalk   Added zone_definition_id and zone_id to call Cust_Order_Leadtime_Util_API.Get_Supply_Chain_Defaults at Get_Supply_Chain_Defaults___.
--  080911           Set zone_definition_id and zone_id at Modify_Order_Defaults__.
--  080908  MaJalk   Added attributes zone_definition_id and zone_id.
--  080904  MaJalk   Set DEFAULT_CHARGES to TRUE at Modify__.
--  080902  MaJalk   At update___, set creation of charge lines when price_source_net_price is FALSE.
--  080829  MaJalk   Modified conditions to create new charge lines at Update___.
--  080825  AmPalk   Added Sales_Weight_Volume_Util_API.Get_Total_Weight_Volume to calculate total net and gross weight and total volume.
--  080819  MaJalk   Modified Post_Insert_Actions___ to create charge lines when default charge is true.
--  080818  AmPalk   Added line_total_weight_gross.
--  080815  MaJalk   Moved the logic which create, remove or modify charge line to Customer_Order_Charge_Util_API.
--  080812  MaJalk   Corrected the call Cust_Ord_Customer_API.Get_Receive_Pack_Size_Chg to get Db value at Post_Insert_Actions___.
--  080811  MaJalk   Added INPUT_UNIT_MEAS and INPUT_CONV_FACTOR to attr_ at Get_Line_Defaults___.
--  080808  MaJalk   Modified Post_Insert_Actions___ and Update___.
--  080730  MaJalk   Added methods Get_Input_Qty, Get_Input_Unit_Meas and Get_Input_Conv_Factor. Modified Update___, Post_Insert_Actions___ to create CO charge lines.
--  080701  KiSalk   Merged APP75 SP2.
--  ----------------------------- APP75 SP2 Merge - End -----------------------------
--  080528  KaEllk   Bug 74045, Modified Get_Activity_Info___ to include sales overhead project cost elements. Used revised_due_qty to get qty in Inventory UoM.
--  080526  ChJalk   Bug 72771, Modified method Update__ to handle tax lines of charge lines when changing the single occurrence check box.
--  080523  ChJalk   Bug 73229, Added condition to check whether line no and rel_no are not NULL before calling the method Is_Number___ in Unpack_Check_Insert___.
--  080522  ChJalk   Bug 73229, Added method Is_Number___ and checks whether the line_no and rel_no are numeric values. If not raises an error.
--  080521  SuJalk   Bug 74080, Modified the Line_Is_Fully_Invoiced___ method to change the number of decimal places to TRUNC to be 10 from 12.
--  080515  SuJalk   Bug 70772, Modified Check_Before_Update___ method to evaluate dates and availability check for configurable parts.
--  080508  KaEllk   Bug 73185, Modified method Get_Activity_Info___ to exclude PRJ supply option and to correct OrderStatus check for Non inventory parts.
--  080508           Added some minor corections for coding standards.
--  080508  ChJalk   Bug 71395, Modified method Modify_Cost to modify the cost only if the cost is different from the exsisting cost of the Customer Order Line.
--  080428  KaEllk   Bug 73185, Modified methods Get_Activity_Info___,Calculate_Cost_And_Progress and Handle_Activity_Seq___.
--  080428           Added Get_Progress_Info___. Removed Get_Project_Cost_Element.
--  080428  ThAylk   Bug 73334, Added ELSE part to return NULL in the method Get_Owner_For_Part_Ownership.
--  080425  NaLrlk   Bug 73075, Modified method Check_Qty_From_Repair_Order___ to remove the error messages when purch is not installed.
--  080408  ChJalk   Bug 72396, Modified method Update__ to pass parameter do_price_ as FALSE to the method Change_Package_Structure___.
--  080403  Asawlk   Bug 72598, Modified Set_Qty_Picked to check new_state_ = 'Released' before creating a history record.
--  080403           Also added message when creating history record when zero is delivered.
--  080328  MaMalk   Bug 70007, Made supply_site_due_date public and Modified Unpack_Check_Update___ to allow the target date to be set
--  080328           to a date less than the wanted delivery date.
--  080328  Asawlk   Bug 72598, Modified method Set_Qty_Picked to create a history record when a state transition occurs.
--  080318  ThAylk   Bug 69894, Added if condition to remove unnecessary calls to refresh project activity cost in method Update___.
--  080318  MaRalk   Bug 71926, Modified method Update_Planning_Date in order to set the target date when planned due date is changed in Distribution Allocation.
--  080311  ThAylk   Bug 72069, Added missing ifs_assert_safe annotation.
--  080310  NaLrlk   Bug 72012, Modified method Update___ to calculate the discount when price_source is changed.
--  080229  ChJalk   Bug 69654, Modified Calculate_Order_Line_Dates___ to pass release_planning for date calculation.
--  ----------------------------- APP75 SP2 Merge - Start -----------------------------
--  080502  MaJalk   Added method Get_Classification_Unit_Meas and classification_unit_meas to Get method.
--  080429  MaJalk   Added method Get_Rebate_Builder_Db.
--    080428   MaJalk   Modified Get_Line_Defaults___, Insert_Package___ to fetch rebate builder.
--  080324  MaJalk   Added attribute rebate_builder.
--  080318  KiSalk   Added attributes classification_part_no, classification_unit_meas, classification_standard and methods Get_Classification_Part_No, Get_Classification_Standard.
--  080313  AmPalk   Merged APP75 SP1.
--  ------------------------------------------ APP75 SP1 merge - End --------------------------------------------------------------------------
--  080206  LaBolk   Bug 71008, Modified method Modify_Sale_Unit_Price to make the cursor get_order_line compare correct values.
--  080205  NaLrlk   Bug 70005, Added minor changes for del_terms_location to Modify_Order_Defaults__ and Unpack_Check_Insert___.
--  080205  SaJjlk   Bug 69853, Added code to perform validations for company tax id in methods Unpack_Check_Insert___ and Unpack_Check_Update___.
--  080203  LaBolk   Bug 71008, Modified method Create_Sourced_Co_Lines to make the cursor old_discount_lines compare correct values.
--  080130  NaLrlk   Bug 70005, Added public attribute del_terms_location and Modified for del_terms_location in methods Insert_Package___, Change_Package_Structure___,
--  080130           Check_Before_Update___, Init_Before_Check_Insert___, Modify_Order_Defaults__ and Copy_Customer_Order_Line.
--  080124  ThAylk   Bug 69675, Modified prcodure Modify_Order_Defaults__.
--  080123  OSALLK   Bug 68763, Removed the information message for the updated of the buy_qty_due when the demand code is PO.
--  080123  OSALLK   Bug 68763, Modifed the method unpack_check_Update to raise a warning when updating the quantity.
--  080117  ChJalk   Bug 69540, Modified Calculate_Order_Line_Dates___.
--  080102  MaMalk   Bug 65955, Made customer_part_conv_factor a public attribute and modified all the corresponding methods to handle it.
--  071231  NaLrlk   Bug 68349, Modified method Update___ with project connection for pkg-components and added PKG in if stmt/err msg in Validate_Proj_Connect___.
--  071231  NaLrlk   Bug 70143, Modified the method Get_Line_Defaults___ to handle the Replacement Part call for all COL parts.
--  071224  MaRalk   Bug 64486, Mofdified Modify_Sale_Unit_Price, Update___, Get_Default_Part_Attributes___, Log_Price_Changes___,
--  071224           to consider currency rate type in CO when calculate price in currency.
--  071218  ThAylk   Bug 68685, Modified Unpack_Check_Insert___ to fetch values when only rel_no is null in CO line
--  071218           and change the parameter order of procedure Get_Next_Line_No.
--  071217  NuVelk   Bug 70009, Modified Check_Ship_Via_Code__ by modifying the cursor exist_control.
--  071213  MaMalk   Bug 69811, Modified Validate_Proj_Connect___ to remove the validations existed for project-prepayment combination.
--  071212  RoJalk   Bug 69803, Added the public attribute allocation_id.
--  071211  SaJjlk   Bug 69796, Modified method Update__ and removed code used to set the customer part no to null.
--  071210  MaRalk   Bug 66201, Modified Insert___ and Update___ in order to correctly calculate order line net weight and volume.
--  071201  MaMalk   Bug 69137, Modified Get_Total_Tax_Amount_Curr to consider negative tax amounts.
--  071130  MaRalk   Bug 67755, Modified New in order to correctly set Target Date when creating a Customer Order via Incoming Customer Order.
--  071127  MaRalk   Bug 66013, Modified method Get_Activity_Info___ in order to assign value inv_cost_ to the variable misc_used_.
--  071123  SaJjlk   Bug 69223, Modified method Update___ to avoid updating of non-inventory qty to deliver when updating sales qty.
--  071119  MaRalk   Bug 67755, Added public attribute target_date and modified all corresponding methods to handle it. Added new column to
--  071119           customer_order_line view. Modified methods Calc_Dates_Forwards___, Calculate_Order_Line_Dates___, Update_Planning_Date,
--  071119           Prepare_Insert___, Update_Line___, Post_Insert_Actions___, Perform_Capability_Check___, New, Insert_Package___ and
--  071119           Change_Package_Structure___. Added parameter pkg_target_date_ to Insert_Package___. Added parameter do_target_
--  071119           to Change_Package_Structure___.  Updated message text in TARGETDATECHG2, TARGETDATECHG wihtin Update___, Change_Package_Structure___ ,
--  071119           Update_Planning_Date and modified other places in order to go with increased length of MESSAGE_TEXT column in CUSTOMER_ORDER_LINE_HIST_TAB.
--  071114  SaJjlk   Bug 68665, Added parameters oldrec_.planned_delivery_date, oldrec_.revised_qty_due and newrec_.part_no
--  071114           to method call Cust_Order_Event_Creation_API.Delivery_Date_Or_Qty_Changed in method Update___.
--  071022  ThAylk   Bug 67984, Added Valid_Project_Customer__ and modified Validate_Proj_Connect___ by removing error and proj_customer_id fetching.
--  071022  MaRalk   Bug 66630, Modified Line_Is_Fully_Invoiced___, changed the rounding of some values to 10 decimal places.
--  071018  LeSvse   Bug 67815, Added warning message if quantity modified for configured line in Unpack_Check_Update.
--  071015  NaLrlk   Bug 68042, Added 'do_planned_ := TRUE' in check if buy_qty_due or desired_qty has been updated in Update_Package___.
--  ------------------------------------------ APP75 SP1 merge - Start --------------------------------------------------------------------------
--  080214  AmPalk   Modified method calls to Get_Order_Line_Price_Info by receiving net_price_fetched value and then inserted it to the CO Line.
--  080213  AmPalk   Added price_source_net_price to the LU.
--  ------------------------------------------ NicePrice ----------------------------------------------------------------------------------------
--  070913  ChBalk   Bug 67061, Modified method Check_Before_Insert___, validation was introduced for pkg parts.
--  070830  KaDilk   Bug 67143, Modified the method Check_Before_Update___ to prevent a connected shipment line going to Delivered state erronously,
--  070827           when the sales quantity is changed in the partially delivered order line.
--  070809  AmPalk   Bug 66718, Added the DELIVER_TO_CUSTOMER_NO attribute to the template_attr_ in the Insert_Package___ Method.
--  070808  NaLrlk   Added General_SYS.Init_Method for Get_Project_Cost_Element.
--  070801  NuVelk   Bug 65015, Modified procedures Unpack_Check_Update___, Check_Supply_Code___, Validate_Proj_Connect___,
--  070801           Validate_Proj_Disconnect___, Handle_Activity_Seq___ and Get_Activity_Info___.
--  070801           Modified the function Is_Purch_Comp_Part_Line___. Added new error message DELIVERY_PROJECT.
--  070801           Modified the procedure Unpack_Check_Update___. Added new error message NOTALLOWED_IP_PRD instead of NOTALLOWEIP.
--  070727  MaMalk   Bug 66649, modified the method Check_Before_Update___.Restricted the changing of supply type to
--  070727           'Production Schedule' when the order line is fully reserved.
--  070717  MaJalk   Bug 65855, Added parameters to Calc_Order_Dates_Backwards within Calculate_Order_Line_Dates___.
--  070717           Added condition to check the part_ownership has changed in Check_Before_Update___.
--  070716  ChBalk   Bug 65135, Replaced UNISTR with new constant in Database_SYS.
--  070703  MaJalk   Bug 64918, Removed 'P' from mrp_order_code list, for supply_code = 'DOP' check.
--  070628  DAYJLK   Project Enterprise Merge.
--  070621  MiKulk   Bug 61765, Added parameter to Calc_Order_Dates_Backwards within Calculate_Order_Line_Dates___.
--  070621           Modified Delete___ by changing the Control_Ms_Mrp_Consumption__ as public method call.
--  070621  KaDilk   Bug 65314, Added parameters line_no_, rel_no_ and line_item_no_ to procedure Check_Qty_From_Repair_Order___.
--  070621           If sales part is serialized part raise the error to avoid quantity been modified, otherwise allow the quantity to modify in the CO.
--  070619  ChBalk   Added public function Get_Catch_Qty_Del_On_Delivnote which summarize catch_qty_delivered to a delivery note.
--  070619  MaJalk   Bug 65436, Added supply codes Purchase Order Direct and Internal Purchase Direct to if condition as valid supply codes for project connected CO lines.
--  070619  NaLrlk   Added procedure Handle_Replacement_Part___ and Modified the method Get_Line_Defaults___.
--  070530  ChBalk   Bug 64640, Removed General_SYS.Init_Method from function Get_Owner_For_Part_Ownership.
--  070530  MaMalk   Bug 65249, Moved the block of code that raise minimum sales quantity warning in the Post_Insert_Actions___ to the end of the procedure,
--  070530           to avoid info getting cleared.
--  070529  AmPalk   Bug 65083, Modifed the method Unpack_Check_Update___ to recalculate qty_shipdiff when revised_qty_due is changed on a closed CO line.
--  070529  MaJalk   Bug 64949, Modified method Update___ to raise an information message if the ship_addr_no, delivery_terms
--  070529           or ship_via_code is updated when the CO Line is already connected to an open shipment.
--  070525  MaJalk   Bug 61583, Modified Update___ by changing the order of creating the connected order line and changing the package structure.
--  070523  RaKalk   Modified Unpack_Check_Update___ to recalculate the cost when the qty changes.
--  070523  RaKalk   Modified Init_Before_Check_Insert___ to change the condition for cost calculation.
--  070519  RaKalk   Modified Unpack_Check_Update___,Insert_Package___, Get_Line_Dafaults___ and Init_Before_Check_Insert___
--  070519           to pass the correct config_id to Sales_Cost_Util_API.Get_Cost_Incl_Sales_Overhead method
--  070516  KaDilk   Call 144750, Modified Post_Insert_Actions,check for self billing when creating stage billing.
--  070515  NiDalk   Bug 63877, Added 'NOCHECK' to reference in Column sup_sm_object in view CUSTOMER_ORDER_LINE comments.
--  070515  MiKulk   Added a new parameter ignore_wanted_delivery_date_ to the method Update_Planning_Date.
--  070509  NiDalk   Bug 64080, Added method All_Non_Inv_Parts___ and modified methods Unpack_Check_Insert___,
--  070509           Check_Before_Update___, Post_Insert_Actions___.
--  070405  NuVelk   Bug 64184, Modified Unpack_Check_Update___ to check the existence of delivery address of deliver_to_customer, whatever the demand code is.
--  070426  Cpeilk   Modified the customer_no_ variable definition in method Customer_Is_Internal.
--  070425  Haunlk   Checked and added assert_safe comments where necessary.
--  070423  NuVelk   Bug 63470, Modified procedure Unpack_Check_Update___, to retrive the correct vat_no.
--  070418  MaJalk   Modified method Post_Insert_Actions___ to collect info messages.
--  070405  NaLrlk   Bug 64170, Modified method modify() to add substr to current_info_ to limit it to 1024.
--  070322  MalLlk   Bug 60882, Added public attribute vat_no, and modified all corresponding methods to handle it.
--  070314  MaMalk   Bug 63846, Modified Unpack_Check_Update___, to update SHIPMENT_CONNECTED and SHIPMENT_CONNECTED_DB when CO line is in Invoiced state.
--  070313  NiDalk   Modified method Update___ to invalidate Pre-Shipping Delnote_no.
--  070308  NiDalk   Added method Get_Qty_Picked_On_Deliv_Note.
--  070302  MaMalk   Bug 63189, Modified the condition that raises the error when discount exceeds 100, by removing the condition added by Bug 62020 in Unpack_Check_Update___.
--  070227  MoMalk   Bug 63388, Modified method Init_Before_Check_Insert___ in order to get the value for
--  070227           newrec_.addr_flag from attr_ and modify the condition for demand_code_ to handle null values.
--  070226  SenSlk   LCS Merge 63079, Modified the refernce parameter of ship_addr_no to deliver_to_customer_no from customer_no in view CUSTOMER_ORDER_LINE.
--  070226  SenSlk   LCS Merge 62541, Nodified Check_Before_Insert___,Check_Before_Update___ to validate customer_no and ship_addr_no.
--  070221  WaJalk   Bug 61985, Modified view CUSTOMER_ORDER_LINE_RMA_LOV, to increase length of column customer_po_no from 15 to 50, in view comments.
--  070216  SaJjlk   Modified method Update___ to check value for supply code when connecting to new shipments.
--  070215  NaWilk   Renamed public method Handle_Pre_Acc_Change as Handle_Pre_Posting_Change.
--  070215  PrPrlk   Modified method Update___ to correctly connect CO lines to shipments when updating the line.
--  070214  SaJjlk   Modified method Post_Insert_Actions___ to check more conditions when connecting new CO Lines to Shipment.
--  070213  NaWilk   Added public method Handle_Pre_Acc_Change.
--  070205  PrPrlk   Modified the call to Shipment_Handling_Utility_API.Add_Order_Line_To_Shipment to correctly sort the parameter list.
--  070207  SaJjlk   Removed previously added conditions for setting shipment creation method for packaged parts.
--  070206  SaJjlk   Added conditions to check the shipment creation method of the order header when
--  070206           setting default address flag for packaged parts.
--  070205  PrPrlk   Modified the call to Shipment_Handling_Utility_API.Add_Order_Line_To_Shipment.
--  070201  SaJjlk   Modified methods Change_Package_Structure___ and Post_Insert_Actions___ to handle the default_addr_flag
--  070201           according to the value of the shipment creation method.
--  070131  NaWilk   Bug 61797, Modofied object_status_ length in Calculate_Cost_And_Progress and Handle_Activity_Seq___.
--  070130  NuVelk   Bug 62910, Modified method Modify_Delivery_Data to calculate revised qty using conv factor.
--  070130  NaWilk   Bug 62020, Modified Unpack_Check_Update___ to change the condition that raises the error when discount exceeds 100.
--  070130           Modified the error msg in both Unpack_Check_Insert___ and Unpack_Check_Update___ to be meaningful.
--  070129  NaWilk   Bug 62645, Modified the cursor in Unpack_Check_Update___ to select from delivery_fee_code_pub only the values with party_type = 'CUSTOMER'.
--  070124  NaWilk   Added implementation method Validate_Prepayment___ to raise error message PREPAYEXCEED
--  070124           and modified methods Check Delete___ and Update___ to call Validate_Prepayment___.
--  070125  SaJjlk   Modified methods Prepare_Insert___, Unpack_Check_Insert___, Unpack_Check_Update___, Check_Before_Update___,
--  070125           Init_Before_Check_Insert___ and Modify_Order_Defaults__ to correctly set the value for column SHIPMENT_CREATION
--  070125           Increased length of column SHIPMENT_CREATION on view CUSTOMER_ORDER_LINE.
--  070125  ChBalk   Modified SalesOverhead cost calculation, BuyQtyDue multiplied by sales_conv_fact to get the revised_qty_due.
--  070124  WaJalk   Bug 61835, Modified the method Post_Insert_Actions___ to allow updation of the connected DO's dates according to the calculated CO dates.
--  070124  ChBalk   Passed correct value for the CHARGED_ITEM when creating CustomerOrderLine, specially from component part in PO.
--  070122  SuSalk   Removed Get_Delivery_Terms_Desc and Get_Ship_Via_Desc methods. Called Mpccom_Ship_Via_API.Get_Description,
--  070122           Order_Delivery_Term_API.Get_Description methods for DELIVERY_TERMS_DESC and SHIP_VIA_DESC references.
--  070110  KaDilk   LCS Merge 58965, Modified Unpeg__ to change the structure of logic of raising info messages.
--  070109  SeNslk   LCS Merge 60753, Modified Update___ not to replicate the changes when CO is Planned.
--  070105  KaDilk   LCS Merge 62343, Added method calls to remove shortages in method Finite_State_Set___.
--  070104  RaKalk   Added Sales_Qty_ parameter to the calls to Sales_Cost_Util_API.Get_Cost_Incl_Sales_Overhead method
--  061229  NaWilk   Bug 60612, Modified Check_Before_Update___ to raise an error when the supply code of a pegged line is changed in a released order.
--  061221  NaLrlk   Modified the method Check_Allow_Backorders___.
--  061220  ChBalk   Replaced Inventory_Part_Cost_API.Get_Cost with Sales_Cost_Util_API.Get_Cost_Incl_Sales_Overhead
--  061219  Cpeilk   Call 140121, Modified method Validate_Proj_Connect___ to check for prepayment amount exists.
--  061211  MaJalk   Bug 60301, Added condition to check the ship_addr_no before raising error for fee_code in method Unpack_Check_Update___.
--  061207  MaJalk   Bug 60569, Added method Validate_Vendor_No__ and modified method Retrieve_Default_Vendor__.
--  061206  ThAylk   LCS Merge 61834, Modified the Line_Is_Fully_Invoiced___ method to consider staged billings.
--  061205  DaZase   Added a qty conversion in method Perform_Capability_Check___.
--  061205  NaLrlk   Bug 61896, Modified Unpack_Check_Update___() to check the user changes of default addr flag and delivery terms.
--  061129  JaJalk   Bug 60371, Removed the history update for picked from the Set_Qty_Picked since a separate history has been implemented when pick list is picked.
--  061127  Cpeilk   Modified error message for self billing when prepayments exists in Unpack_Check_Insert___.
--  061126  MaJalk   Bug 61021, Modified Line_Is_Fully_Invoiced___, changed the rounding of some values to 11 decimal places.
--  061125  KaDilk   Bug 61168, Modified Update___ in order to allow modifying qty_to_ship value for project connected non inventory parts.
--  061123  OsAllk   Bug 61250, Modified Check_Supply_code___ to allow supply code PI for configured parts and DOP parts.
--  061114  MaJalk   Modified method Check_Allow_Backorders___.
--  061108  ChBalk   Added new private method which calculates and returns gross amount ratio per vat code.
--  061030  DaZase   Added a conversion from supply site inv UoM to demand site inv UoM on supply_site_qty_ in Unpack_Check_Update___.
--  061025  Cpeilk   Modified Unpack_Check_Insert___ and Modify_Sm_Connection to restrict self billing and work order connection when prepayments exists.
--  061023  IsWilk   Bug 60326, Modified method Validate_Proj_Connect___ to check demand code also if customer is different.
--  061020  MiErlk   Bug 60485, Modified the condition to perform date calculation in method Unpack_Check_Update___.
--  061020  IsWilk   Bug 60599, Added a condition for assigning VENDOR_NO in method Unpack_Check_Update___.
--  061020  NiDalk   Bug 60250, Modified where clause of cursor get_package_structure in procedure Change_Package_Structure___.
--  061019  MiErlk   Bug 60846, Added the supply code project inventory in the Validate_Proj_Connect___.
--  061003  IsWilk   Bug 60339, Modified Update___ to correctly calculate qty_on_order and replicate changes for pkg component lines.
--  061003           Modified Change_Package_Structure___ to remove the calculation for qty_on_order.
--  060926  MiKulk   Added the first_actual_ship_date to a condition in Unpack_Check_Update___ to avoid errors in the Intersite flow
--  060919  MiKulk   Added the first_actual_ship_date.
--  060915  IsWilk   Bug 58816, Added the CREATED_BY_SERVER attribute to the attr_ in the Insert_Package___ Method.
--  060914  SaJjlk   Bug 59928, Modified Post_Insert_Actions___ by changing the order of creating the connected order line and changing the package structure.
--  060911  MalLlk   Bug 52710, Added functions Get_Create_Sm_Object_Option_Db,Customer_Is_Internal and Supplier_Is_Internal.
--  060901  MaMalk   Bug 59576, Modified Update___ to update qty_to_ship for Non Inventory parts when dates are changed.
--  060828  LaBolk   Bug 60017, Modified Get_Line_Defaults___ to add supply site to the attr.
--  060824  IsWilk   Bug 59092, Changed rowstate from 'cancelled' to 'Cancelled' in PROCEDURE Update_Package_Cost___.
--  060817  IsWilk   Modified view Comments of addr_1 in VIEW_ADDRESS, removed the SUBSTR of name_
--  060817           in Insert_Default_Address___, modified the length of the customer_name_ in Perform_Capability_Check___.
--  060816  HaPulk   Bug 56553, Modified Validate_Proj_Connect___ so that project connection for
--  060816           customer order line is validated successfully when supply code is PD or IPD.
--  060804  NaWilk   Added lamguage code parameter in call to Sales_Part_API.Get_Catalog_Desc in method Get_Line_Defaults___.
--  060801  ChJalk   Replaced Mpccom_Ship_Via_Desc with Mpccom_Ship_Via and Order_Delivery_Term_Desc with Order_Delivery_Term.
--  060720  RoJalk   Centralized Part Desc - Use Sales_Part_API.Get_Catalog_Desc.
--  060728  KaDilk   Make ship via desc and delivery term desc language independant.
--  060713  YaJalk   Bug 59255, Changed cursor old_discount_lines in PROCEDURE Create_Sourced_Co_Lines.
--  060602  NaLrlk   Enlarge Part Desc- Changed variable definitions.
--  060601  MiErlk   Enlarge Description - Changed view comments .
--  060531  KanGlk   Bug 56825, Added function Is_Delivered used by PurchaseOrderLine.
--  060524  MiKulk   Changed the coding to remove LU dependancies.
--  060519  LaBolk   Bug 56521, Modified Update___ to add extra condition to check changes of sale_unit_price between 0 and non zero, to allow tax recalculation.
--  060518  MaRalk   Bug 57349, Modified the view CUSTOMER_ORDER_LINE_RMA_LOV.
--  060517  MiErlk   Enlarge Identity - Changed view comment
--  060515  RoJalk   Enlarge Address - Changed variable definitions.
--  060508  KanGlk   Added derived private attribute default_charges and Modified procedure Insert___, Unpack_Check_Insert___ and Post_Insert_Actions___.
--  060504  SeNslk   Modified the method Post_Insert_Actions___ to insert the charges to
--  060504           Customer_Order_Charges_TAB.
--  060502  MaJalk   Bug 56776, At part ownership validations in methods Check_Before_Insert___ and Check_Before_Update___,
--  060502           moved the supply code SEO to upper ELSIF condition.
--  060424  MaJalk   Enlarge Supplier - Changed variable definitions.
--  060421  LaBolk   Bug 56696, Modified Line_Is_Fully_Invoiced___: rounded some values to eliminate rounding errors in the comparisons.
--  060419  MaJalk   Enlarge Customer - Changed variable definitions.
--  060418  NaLrlk   Enlarge Identity - Changed view comments of deliver_to_customer_no.
--  060412  RoJalk   Enlarge Identity - Changed view comments.
--  -------------------- 13.4.0 ---------------------------------------------------
--  060328  IsWilk   Modified the PROCEDURE Update___ to update the calculated invoiced qty in CO Line when using STAGED BILLING.
--  060320  JaBalk   If delivery address is changed in Planned CO, then change the value of shipment creation to fetch the value
--  060320           related to the delivery address in Check_Before_Update___.
--  060316  MiKulk   Modified the Check_Before_Insert___ and Check_Before_Update___ to pass customer order header information when deliver-to-customer exists.
--  060315  KanGlk   Modified Check_Before_Update___ procedure.
--  060313  MiKulk   Modified the Check_Before_Insert___ and Check_Before_Update___ to pass customer order header information when deliver-to-customer exists.
--  060306  MiKulk   Modified the Unpack_Check_Update___ and Validate_Fee_Code to handle the non taxable parts.
--  060306  JaJalk   Added Assert safe annotation.
--  060302  DaZase   Added handling of info string from CC in method Perform_Capability_Check.
--  060301  MiKulk   Modified the Update___ to correctly add tax lines based on the deliver to customer value.
--  060228  IsAnlk   Added method Get_Full_Qty_Assigned which is used in shipment.
--  060227  SuJalk   Modified an IF condition in Check_Before_Update___ to check the correct value in variable server_data_change_.
--  060225  JaJalk   Added an error message in Unpack_Check_Update___ for shipment connected line.
--  060224  MaJalk   Bug 56229, Modified method Check_Supply_Code___ to allow supply code 'SEO' to DOP parts.
--  060223  MiKulk   Manual merge of the bug 51197 to store the tax free tax code in the tax code column.
--  060223  NuFilk   Modified method New_Cust_Sched to allow the info variable to return the information.
--  060222  SaJjlk   Added code to set the fee code correctly when ship address is changed in method Unpack_Check_Update___.
--  060221  SaNalk   Added Info Message in Unpack_Check_Update___, for changing configuration of a DOP part.
--  060210  DaZase   Changed so supply code PRJ is used when project connection on non inventory part order line is made.
--  060208  MaGuse   Bug 55612, Added method New_Comp_Lines_Allowed.
--  060202  LaBolk   Bug 55868, Modified Update___ to restrict the call to Set_Line_Qty_Invoiced to instances where qty_invoiced has actually changed.
--  060130  IsWilk   Added the PROCEDURE Check_Delivery_Type__ and mofified the reference of delivery_type.
--  060125  MaJalk   Bug 55160, Modified Insert___, Update___, Unpack_Check_Update___, Change_Package_Structure___
--                   to use revised_qty_due when assigning a value to qty_to_ship.
--  060124  RaSilk   Removed check for configured parts in method Unpeg_Line.
--  060124  JaJalk   Added Assert safe annotation.
--  060124  KeFelk   Added Get_Vat_Liability_Addr___, Get_Vat_Liability_Inv___ and Get_Ipd_Vat_Liability.
--  060120  MaJalk   Bug 55317, Modified Check_Before_Update___ to raise error messages for positive or negative ship diffs, when using staged billing.
--  060120  KeFelk   Changes to Check_Before_Insert___ and Check_Before_Update___ to get the correct customer.
--  060118  IsAnlk   Modified Purchase_Util_API.Unpeg_Order as Purchase_Order_Line_Part_API.Unpeg_Order.
--  060106  UsRalk   Removed the restriction on self billing lines from CUSTOMER_ORDER_LINE_CHARGE_LOV.
--  060103  JoEd     Vendor_no sent to Cust_Ord_Date_Calculation_API.Calc_Due_Date_Forwards.
--  060102  PrPrlk   Bug 54547, Modified the procedures Check_Before_Insert___ to stop creation of internal order lines
--  060102           containing package parts when both demand and supply site belong to the same company.
--  051221  ChJalk   Bug 55197, Modified the Procedure Delete___ to remove a Financial Job if any when Customer Order Line is deleted.
--  051221  MaJalk   Bug 54771, Modified procedure Check_Supply_Code___ for supply code MRO and order_requisition_ R.
--  051209  LaBolk   Bug 54951, Modified Update___ to change conditions that set qty_to_ship for non-inventory lines with supply codes PT and IPT.
--  051208  ChJalk   Bug 54563, Added two attributes sup_sm_object and sup_sm_contract in Insert_Package___ and Change_Package_Structure___.
--  051202  ThGulk   Bug 54587, Added method Modify_condition_code, modified check_before_update__
--  051122  GeKalk   Modified Line_Is_Fully_Invoiced___ to set the customer order to Invoiced/Closed state
--  051122           if it is connected to a sales contract.
--  051031  UsRalk   Added a validation on receiving_advice_type.
--  051031  NuFilk   Modified Update___ to calculate discounts when price_source_refreshed_ is true.
--  051031  JaBalk   Changed Post_Insert_Actions___ by including Partially Delivered status to call
--  051031           Shipment_Handling_Utility_API.Add_Order_Line_To_Shipment
--  051027  DaZase   Removed obsolete ctp/cc check in method Check_Before_Update___.
--  051026  ChJalk   Bug 54165, Modified the method Check_Before_Insert___ to fire an Error message when trying to save an inactive sales part.
--  051026  UsRalk   Added new public attributes receiving_advice_type and receiving_advice_type_db.
--  051026  RaSilk   Modified Unpeg_Line to suppress error message when unpegging configured parts if supply code is SO.
--  051025  IsWilk   Modified the PROCEDURE Unpack_Check_Insert___ to remove added code for fetching delivery_type.
--  051024  IsWilk   Modified the PROCEDURE Prepare_Insert___ to remove the default value for delivery_type.
--  051020  IsWilk   Modified the PROCEDURE Unpack_Check_Insert___ to fetch delivery_type from the Sales_Part_API.
--  051019  GeKalk   Modified Validate_Proj_Connect___ to give a proper error message when connecting objcets to an activity
--  051019           which is not in released state.
--  051012  IsWilk   Modified the PROCEDUREs Perform_Capability_Check___, Create_Sourced_Co_Lines
--  051012           to replace the deliver_to_customer_no instead of customer_no.
--  051011  JaBalk   Added order lines to shipment if the customer order is in Released, Reserved and Picked status.
--  051011  KeFelk   Added Site_Discom_Info_API in some places for Site_API.
--  051011  IsWilk   Modified the PROCEDURE Get_Default_Part_Attributes___ to pass correct parameters.
--  051011  IsWilk   Modified PROCEDUREs Check_Before_Insert___ and Check_Before_Update___
--  051011           to replace the deliver_to_customer_no instead of the customer_no.
--  051007  GaSolk   Bug 53712, Called the method Deliver_Customer_Order_API.Deliver_Package_If_Complete
--  051007           in Update___ in order to deliver the Package header when all component parts
--  051007           are delivered. Also added parentheses for the computation of poss_qty_to_return in CUSTOMER_ORDER_LINE_RMA_LOV view
--  051007           in order to make sure delta can be extracted using Delta Engine.
--  051006  UsRalk   Modified Unpack_Check_Update___ to include Edge columns also for the info message added in bug 53251.
--  051003  Cpeilk   Bug 53468, Modified Check_Before_Insert___ and Check_Before_Update___ to check delivery address got modified or single occurrence is removed.
--  050929  SaJjlk   Modified reference in view comments for delivery_type in view CUSTOMER_ORDER_LINE.
--  050929  JeLise   Bug 53456, Added new ELSIF to check on exchange_item in both Check_Before_Insert___
--                   and Check_Before_Update___.
--  050928  ErFelk   Bug 53568, Moved the event call for Delivery_Date_Or_Qty_Changed to Update__ from Unpack_Check_Update___ and Check_Before_Update___.
--  050927  IsAnlk   Modified calls to Customer_Order_Pricing_API.Get_Base_Price_In_Currency, Get_Sales_Price_In_Currency to pass customer_no.
--  050923  ErFelk   Bug 53428, Modified Delete___ by adding an IF condition so that pre-accounting id is not deleted when a package component got removed.
--  050922  NuFilk   Modified Unpack_Check_Update___ to give info message when provisional flag for canceled order line is changed.
--  050922  NaLrlk   Removed unused variables.
--  050915  LaBolk   Bug 53303, Modified Init_Before_Check_Insert___ to prevent system from fetching int customer's route, rather than keeping the route sent by ext customer.
--  050607  RaSilk   Modified Unpeg_Line to display an error message when trying to unpeg configured parts.
--  050913  UsRalk   Modified Unpack_Check_Insert___ and Unpack_Check_Update___ to clear supply_site and supply_site_reserve_type when they are not valid.
--  050912  LaBolk   Bug 53251, Modified Unpack_Check_Update___ to raise the info message added in bug 51378 for every column
--  050912           updateable by the user. Removed the variables and condition added in 51378 and introduced a new condition.
--  050909  DaZase   Added a fetch to get original order line keys if this order is the internal order in an IPT/IPD flow in method Perform_Capability_Check___.
--  050909  SaMelk   Replace 'Get_Max_Amt_Js_Trans_Batch' with 'Get_Virtual_Inv_Max_Amount'.
--  050907  KanGlk   Call 126707. Modified Validate_Jinsui_Constraints___ to do the Jinsui validations when Quantity Overpicked.
--  050906  JaBalk   Corrected Numeric/Value error in Insert_Default_Address___ by substring the name_.
--  050905  HoInlk   Bug 52976, Modified Get_Total_Tax_Amount_Curr to not use tax percentage if tax amount is zero.
--  050901  IsWilk   Modified the PROCEDUREs Unpack_Check_UPdate___ and Check_Before_Update___
--  050901           to correctly fetch the route, forward_agent_id, contact when modifying the ship_addr_no.
--  050830  JoEd     Added methods Modify_Qty_Confirmeddiff__, Set_Qty_Confirmeddiff__
--                   and Set_Qty_Confirmeddiff. Also added new state event SetQtyConfirmeddiff.
--                   Made Delivery_Confirmed and Qty_Confirmddiff updateable after Invoiced/Closed status.
--  050829  HoInlk   Bug 52976, Modified Get_Total_Tax_Amount_Curr to use tax percentage of CO line.
--  050825  KanGlk   Bug ID 125059. Added some extra info handling in method Modify_Line___.
--  050824  MaJalk   Bug 51940, Modified supply code check for cto parts in PROCEDURE Check_Supply_Code___.
--  050818  IsAnlk   Modified Modify_Sale_Unit_Price to update provisional_price correctly.
--  050817  DaZase   Changed some history handling in methods Update_Planning_Date and Perform_Capability_Check___.
--  050808  NuFilk   Modified Get_Line_Defaults___ to include buy_qty_due_ to the attr, Reversing Bug 52071.
--  050803  KanGlk   Changed the error message in Validate_Jinsui_Constraints___ method.
--  050803  IsWilk   Modified the PROCEDURE Unpack_Check_Update___ to set the supply_site_reserve_type
--  050803           as NOTALLOWED when the supply code is not in IPT or IPD.
--  050726  KanGlk   Modified Finite_State_Machine___.
--  050722  IsAnlk   Modified Get_Default_Part_Attributes___ to set provisional_price_db = 'FALSE'
--                   when price is sent from the message.
--  050718  HoInlk   Bug 50280, Added new function Get_Total_Tax_Amount_Curr.
--  050715  VeMolk   Bug 52071, Modified Get_Line_Defaults___ to remove BUY_QTY_DUE from the returned attribute string.
--  050715  IsWilk   (LCS 51740), Modified the method Calculate_Order_Line_Dates___,
--  050715           to pass the parameter old_due_date_to Calc_Order_Dates_Backwards.
--  050714  MaMalk   Bug 52408, Modified Unpack_Check_Insert___ to remove package components considered for a check.
--  050708  MaEelk   Supply Code 'PI' was enabled for Non Inventory Customer Order Lines. Modified Check_Supply_Code___.
--  050705  KanGlk   Added method Validate_Jinsui_Constraints___ and Modified Insert___, Update___.
--  050705  IsAnlk   Added public methods Get_Provisional_Price_Db and Modify_Provisional_Price.
--  050705  SaLalk   Bug 51171, Added catalog_desc to the SELECT staement in CUSTOMER_ORDER_LINE_RMA_LOV.
--  050704  KanGlk   Modified Finite_State_Machine___.
--  050704  MaEelk   Modified error messages in Validate_Block_For_Invoic___.
--  050701  MaMalk   Bug 51007, Removed methods Calc_Route_Departure_Date___ and Calculate_Route_Departure_Date, modified methods Modify_Order_Defaults__ and Unpack_Check_Update___.
--  050701  DaZase   Moved ctp/interim order updates functionality from Update___ to Unpack_Check_Update___ because we
--                   need to do this before the date calculations so we can get new default dates.
--                   Also made Modify__ use current_info_ gathered from Unpack_Check_Update___.
--  050701  MaEelk   Added implementation method Validate_Block_For_Invoic___ and
--  050701           moved the validations of Block for Invoicing into that method.
--  050630  PrPrlk   Bug 51773, Made changes in methods Finite_State_Set___ and Finite_State_Machine___
--                   to correctly trigger the event ORDER_LINE_STATUS_CHANGE for partially delivered order lines.
--  050630  JaBalk   Modified the cursor to select free CO line in Modify_Sale_Unit_Price.
--  050630  IsAnlk   Made private method Modify_Sale_Unit_Price__ as public.
--  050628  DaZase   Added some extra info handling in method Modify_Line___ so auto CC CTO lines will show info messages.
--  050623  ChJalk   Bug 50354, Modified Method Modify_Order_Defaults__ to assign the correct value for default_addr_flag.
--  050622  MaEelk   Invoiced blocked lines were not allowed to have stage billing lines.
--  050622           Modified Unpack_Check_Insert___ and Unpack_Check_Update___
--  050620  MaEelk   Modified the error message we get when modifying an invoiced/blocked order line .
--  050616  KaDilk   Bug 51318, Modified procedure Update_Planning_Date__. Added supplementary changes
--  050616           for bug correction 44599 to generate missing history lines.
--  050614  NuFilk   Modified procedure Unpack_Check_Update___ to include a check on invoiced quantity.
--  050614  JaJalk   Modified the Update___ method to correct the Provisional price message.
--  050613  LaPrlk   Bug 51378, Added info CANCELLED_LINE in Unpack_Check_Update___
--  050610  NiRulk   Bug 49797, Added method Modify_Default_Addr_Flag__.
--  050609  SaLalk   Bug 51151, Modified procedure Update___ to generate history lines when price changed in package component lines.
--  050609  WaJalk   Added the method Modify_Blocked_For_Invoicing.
--  050609  NaWalk   Added the method Get_Shipment_Connected_Db.
--  050608  UsRalk   Changed Check_Before_Update___ to fix problems with disconnecting from Project Activity.
--  050608  IsWilk   Modified the error message according to BLOCKINVOICESTOP in
--  050608           PROCEDURE Unpack_Check_Insert___ and Unpack_Check_Update___.
--  050607  RaSilk   Added parameter supply_code to call Order_Config_Util_API.Update_Configuration__ in method Update___.
--  050607  NuFilk   Modified procedure Unpack_Check_Insert___, Check_Before_Update___ and Update___ to include
--  050607           logic/error messages related to provisional price.
--  050606  IsWilk   Modified the PROCEDURE Post_Insert_Actions___ and Update___ by
--  050606           calling Customer_Order_Line_Hist_API.New and modified the PROCEDUREs
--  050606           Unpack_Check_Insert___ and Unpack_Check_Update to added the error
--  050606           message for blocked_for_invoicing.
--  050601  JoEd     Modified New method.
--  050601  NuFilk   Modified method Get_Line_Defaults___ and Insert_Package___ to include provisional_price to the attr_.
--  050601  IsWilk   Removed the column warranty.
--  050527  DaZase   Added planned_delivery_date to the attribute string in method Clear_Ctp_Planned.
--  050526  SaMelk   Modified 'Update_Line___' to insert values to 'blocked_for_invoicing' column .
--  050525  JaJalk   Made the CUSTOMER_PO_LINE_NO and CUSTOMER_PO_REL_NO public.
--  050523  JoEd     Added a new status action Check_Delivery_Confirmed___ to set delivery_confirmed
--                   when Delivery Confirmation is not used and the order line is Delivered.
--                   (otherwise that flag is set when all deliveries have been confirmed).
--  050520  JoEd     Added qty_shipped in call to Outstanding Sales.
--                   Changed validation of sales group's delivery confirmation setting
--                   for package components.
--  050519  SaJjlk   Added column PROVISIONAL_PRICE.
--  050519  IsAnlk   Added private method Modify_Sale_Unit_Price__.
--  050519  RaKalk   Modified Unpack_Check_Update___ to refresh the discount values when the Price Source if refreshed instead of when Price List No is chenged.
--  050518  SaMelk   Added new column BLOCKED_FOR_INVOICING to CUSTOMER_ORDER_LINE_TAB. Added new function 'Get_Blocked_For_Invoicing_Db'.
--  050517  SaLalk   Bug 49825, Removed the condition on addr_flag in Check_Before_Update___ and change the NOTVATFREEVAT info message.
--  050517  MiKulk   Bug 50947, Modified some conditions in the correction earlier added in the the methods Post_Insert_Actions___ and Update___.
--  050511  MiKulk   Bug 50947, Modified the methods Post_Insert_Actions___ and Update___ to raise the new event CUST_ORD_LINE_PRICE_CHANGED,
--  050511           and also to enter a log in the CUST_ORD_PRICE_HIST_TAB, whenever a change in the sale_unit_price is made
--  050511           and the sle_unit_price and the calculated price per unit are different.
--  050509  Asawlk   Bug 50519, Passed value for new parameter CONTRACT when calling
--  050509           Pre_Accounting_API.Copy_Pre_Accounting() inside Insert().
--  050509  JoEd     Added public attribute qty_confirmeddiff. Changed Line_Is_Fully_Invoiced___.
--  050505  NaLrlk   Removed the Info message when supply code is SO in the method Unpack_Check_Update___
--  050505  LaBolk   Bug 50111, Removed method Is_Line_Close_Allowed__. Modified Finite_State_Machine___ to handle new state changes.
--  050503  JoEd     Bug 49796. Added created_by_server default value in call to Get_Line_Defaults___
--                   from Get_Default_Part_Attributes___.
--  050430  NiRulk   Bug 49348, Made Retrieve_Default_Vendor___ a private method. Modified Unpack_Check_Insert___ and
--                   Unpack_Check_Update___ to change the vendor_no_ validations in the server. Modified Validate_Vendor_No___.
--  050425  NaLrlk   Added Cursor for get all SO records for a CO and Call method Shop_Order_Int_API.Modify_Cust_Ord_Details in Unpeg__.
--  050421  NiRulk   Bug 49798, Added derived attribute header_date_changed-this indicates if the line dates are modified as a consequence of
--  050421           manually updating the CO header delivery date.
--  050421  MaEelk   Modified Validate_Proj_Connect___ to send supply_code_db_ as an
--  050421           IN OUT parameter.Condition for the supply code as PI and PRJ was checked
--  050421           after after Validate_Proj_Connect___ and Validate_Proj_Disconnect___.
--  050418  NuFilk   Added new parameters customer_po_line_no and customer_po_rel_no which originates from Customer Schedules.
--  050408  JoEd     Added call to create outstanding sales record in Modify_Staged_Billing.
--  050408  KeFelk   Changes to Unpack_check_inset and Unpack_check_update related to Deliver to Customer no.
--  050407  ChJalk   Bug 49788, Modified PROCEDURE Unpack_Check_Update___, to raise an error message, if a connected
--  050407           order has been created when modifying the configuration Id.
--  050404  JoEd     Bug 49796. Added info handling for Get_Cust_Part_No_Defaults__.
--                   Present info message NO_PRIMARY_SUPP as an error if created by server.
--  050401  RaSilk   Modified Unpeg_Line to support Non Inventory parts.
--  050329  RaSilk   Added methods Unpeg__ and Unpeg_Line.
--  050331  IsAnlk   Modified Change_Package_Structure__ to calculate price_conv_factor when the component is catch enabled.
--  050330  JaBalk   Modified Finite_State_Set___ to keep the code relevant to DO other than state cancel.
--  050328  RaKalk   Modified Insert___ to get the correct value for the self_billing_db field.
--  050324  IsWilk   Moved the FUNCTION Get_Earliest_Ship_And_Due_Date to the
--  050324           ReserveCustomerOrder LU and split into two seprerate funstions
--  050324           to get planned_dye_date and planned_ship_date.
--  050323  JoEd     Bug 49796. Added fetch of primary supplier for PD and PT in Get_Line_Defaults___ -
--                   like it's already done for IPD and IPT.
--                   Also present a message if sourcing option 'PRIMARYSUPP...' and no
--                   primary supplier is found in Get_Line_Defaults___ and Insert_Package___.
--  050323  SaJjlk   Added validations for Input UoM in methods Unpack_Check_Insert___ and Unpack_Check_Update___.
--  050323  JaJalk   Removed the codes related to DO cancel from Finite_State_Set___ since the line cannot be cancelled if it
--  050323           has been originated from a DO, and can only be cancelled from the DO.
--  050321  JoEd     Added methods Validate_Delivery_Conf___ and Check_Part_Used.
--  050318  DaZase   Added some date handling in Create_Sourced_Co_Lines for capability checked lines, also added
--                   the new attr parameter CAPABILITY_CHECK_SOURCE_FLAG and used it to block backward date calculations
--  050318  JeLise   Bug 50240, Changed IF statements added in 49563 and 49362 in Unpack_Check_Insert___
--                   and Unpack_Check_Update___ to check on internal_po_no instead of demand_code.
--  050316  JoEd     Added public column DELIVERY_CONFIRMED.
--  050314  LaBolk   Bug 48763, Modified Update___ to remove check for server_data_change when updating connected orders.
--  050311  JeLise   Bug 49694, Added new check in Init_Before_Check_Insert___ since check on agreement is not
--                   not necessary for package components.
--  050311  JoEd     Added method Validate_Delivery_Conf__. And placed same kind
--                   of validation in Check_Before_Insert___.
--  050310  LaBolk   Bug 49281, Added method Calc_Sales_Qty_To_Deliver. Modified cursor of Calculate_Qty_To_Load to remove division by conv_factor.
--  050309  NiDalk   Modified Unpack_Check_Update___  and Unpack_Check_Insert___
--                   to clear dop connection for non DOP Order lines.
--  050307  JoEd     Made planned ship date insertable when order line's "created by server".
--                   First of all this is for Distribution Order functionality.
--  050307  SaJjlk   Added columns MANUFACTURING_DEPARTMENT and DELIVERY_SEQUENCE.
--  050304  WaJalk   Modified Unpack_Check_Update___, as newrec_.shipment_connected = 'TRUE'.
--  050302  JeLise   Bug 49563, Added check on discount if CO created/updated from internal purchase order.
--  050228  JoEd     Added check for DO demand and CTP planned in Calculate_Order_Line_Dates___.
--                   Don't calculate the dates if those flags are set.
--  050228  DaZase   Added check on changed configuration_id for the automatic capability check process.
--  050228  MiKulk   Bug 49592, Modified the procedure Change_Package_Structure___ to take the negative discounts also into the calculations
--  050228           and modified the cursor get_order_lines in the method Modify_Additional_Discount__ to update the additional discounts for the component parts.
--  050225  DaZase   Added methods Calc_Dates_Forwards___, Get_auto_capability_check___ and Perform_Capability_Check___.
--  050224  NiRulk   Bug 48417, Modified function Change_Package_Structure___.
--  050221  JaBalk   Modified Finite_State_Set___ to call Distribution_Order_API.Cancel_Connected_Orders
--  050221           only if the DO is not in the cancelled status.
--  050221  VeMolk   Bug 49362, Added checks in Unpack_Check_Insert___ and Check_Delete___ in order to restrict manually
--  050221           adding a new co line and removing an exisitng co line for an internal customer order.
--  050218  IsAnlk   Changed SHIPMENT_CONNECTED values to check SHIPMENT_CONNECTED_DB.
--  050218  LaPrlk   Bug 48770, current_info_ was set to NULL and inserted the value in current_info_
--  050218           to Client_SYS in Modify and removed the call to Client_SYS.Clear_Info in Modify_Line___.
--  050217  DaZase   Added ctp_planned_db_ to Get_Interim_Order_No, added some calls to Interim_Ctp_Manager_API.Get_Top_Int_Head_By_Usage.
--  050216  IsAnlk   Modified SHIPMENT_CONNECTED as VARCHAR2(5) and changed the code accordingly.
--  050214  JICE     Bug 49626, Added public attribute cancel_reason.
--  050210  LaBolk   Bug 49521, Modified Check_Before_Insert___ and Check_Before_Update___ to add more conditions to customer tax error.
--  050209  GeKalk   Modified the method Fininte_State_Set___ to change the status of all connected Distribution Orders.
--  050202  JaBalk   Modified Unpack_Check_Insert___ to allow the server_data_change attribute to be inserted from DistributionOrder.
--  050201  JICE     Bug 49187, Added handling of minimum_qty on SalesPart.
--  050131  JoEd     Changed calls to CustOrdDateCalculation.
--  050131  DaZase   Added allocate_db_ to Update_Planning_Date. Added latest_release_date in method Clear_Ctp_Planned.
--  050128  UsRalk   Changed the information message SHIPMENT_CHANGED in method Check_Before_Update___.
--  050128  JaJalk   Modified the dop conditions of method call Modify_Dop and removed the order_requisition_db_ of the method Update___.
--  050125  JaBalk   Added an error msg NOTUPDATESHIPMENT in Check_Before_Update___ and modified Post_Insert_Actions___
--  050125           to include the reserved status to connect the order lines to shipment.
--  050120  JaBalk   Added shipment_creation_ parameter to Insert_Package___. Modified Unpack_Check_Insert___,
--  050120           Check_Before_Update___, Post_Insert_Actions___ to get the correct shipment creation.
--  050120  JaJalk   Modified the DOP condition in the method Update___.
--  050118  JaBalk   Modified Post_Insert_Actions___ to call Shipment_Handling_Utility_API.Add_Order_Line_To_Shipment.
--  050118  JaBalk   Modified Post_Insert_Actions___ to connect the order line added after releasing order.
--  050118  ChJalk   Bug 48913, Modified Procedure Modify to avoid Create_Connected_Order_Line when cancelling an order line.
--  050113  RaKalk   Added procedure Lock_By_Id
--  050112  DaZase   Made some changes on the error message OLCTPWRONGACQTYPE and added IPT/IPD on the check for this error.
--  050112  NaLrLk   Removed the views VIEW_DEMAND,VIEW_DEMAND_CUSTORD,VIEW_MS,VIEW_EXT,VIEW_SHORT and added it in CustomerOrderDemandUtil LU.
--                   Removed the function Get_Pdsm_Order_Demand and added to the CustomerOrderDemandUtil LU.
--  050111  DaZase   Changed some old calls to Interim_Order_Int_API so they now instead call Interim_Ctp_Manager_API for capability checked lines.
--  050110  JaBalk   Change the shipment creation of pkg part while changing supply code of component part.
--  050107  NaLrLk   Added the function get_pdsm_order_demand.
--  050107  JaBalk   Modified the logic to raise error when changing shipment_creation.
--  050106  JaBalk   Modified Post_Insert_Actions___ , Check_Before_Update___, Update___ to change the shipment_creation of PKG according to its components.
--  050106  JaBalk   Modified Init_Before_Check_Insert___ to remove NON from shipment creation assignment..
--  050105  UsRalk   Corrected the error message regarding Package Part Structure at Check_Before_Update___.
--  050105  JaBalk   Modified Check_Before_Update___ and Init_Before_Check_Insert___ to change
--  050105           the shipment creation value according to the supply code.
--  050104  UsRalk   Restricted update and insert of package components for shipment connected package parts.
--  050103  MaGuse   Bug 48232, Added setting of recalculation flag for connected commissions when region_code is updated. Modified method Update___.
--  041230  DiVelk   Re-arranged code in Check_Before_Insert___.
--  041223  JaBalk   Added Shipment_Creation db column.
--  041222  ChJalk   Bug 48529, Modified PROCEDURE Update___ to ignore the recalculation of Staged Billing for Package part components.
--  041222  VeMolk   Bug 48706, Restuctured the code with different IF conditions, one for recalculation of Staged billing and another one
--  041222           for updating of qty_invoiced in the method Update__. Added another condition for updating qty_invoiced.
--  041217           Get_Sum_Shipped_Base_Curr___, Get_Sum_Shipped_Order_Curr___, Get_Sum_Invoiced_Base_Curr___,
--  041217           Get_Sum_Invoiced_Order_Curr___, Get_Backlog_Value_Base_Curr___, Get_Backlog_Value_Ord_Curr___ and Get_Backord_Value_Base_Curr___.
--  041214  GeKalk   Removed public method Quantity_Deviation_Exist and replaced it in OrderSelfBillingManager LU.
--  041214  JaJalk   Removed the quantity peged condition for DOP updates in the method Update___
--  041210  DaZase   Replaced earliest_start_date with latest_release_date. Removed the default value setting of earliest_start_date,
--  041210           latest_release_date will now only get a value from the Capability Check engine. Added latest_release_date
--  041210           as a param to Update_Planning_Date.
--  041208  KiSalk   qty_to_move set to revised_qty_due in call to Distribution_Order_API.Modify_From_Connected_Order in Update___
--  041203  DaZase   Removed error message NODOPSUPPLY in Check_Supply_Code___ and replaced it with
--                   a new check on mrp_order_code and a new error message MRPCODEPNNOTALLOWED.
--  041201  GeKalk   Added a new public method Quantity_Deviation_Exist.
--  041201  UsRalk   Modified Check_Before_Update___ to support changing SUPPLY_CODE on Project connected Customer Order Lines.
--  041125  NiRulk   Bug 44599, Modified procedure Update_Planning_Date.
--  041124  AnLaSe   Removed method Modify_Base_Price.
--                   Removed check for intersite profitabiity in Unpack_Check_Update___.
--  041118  DiVelk   Added 'PS' in Post_Insert_Actions___ 'If' condition.
--  041117  SaNalk   Modified Handle_Activity_Seq___ to stop project connections if pre posings exists for a financial project code part.
--  041116  DiVelk   Modified IF condition in Check_Before_Update___.
--  041112  DiVelk   Modified Check_Before_Update___.
--  041110  IsAnlk   Removed Calculate_Price_Conv_Factor.
--  041109  ChBalk   Bug 47747, Added replacement part functionality. Modified Get_Line_Defaults___ and Insert_Package___ methods.
--  041105  KaDilk   Bug 45027, Added columns part_ownership,owning_customer_no and owning_vendor_no to VIEW_SHORT.
--  041103  NaWilk   LCS Bug 47669, Modified the procedures and Update___ and Post_Insert_Actions___ by changing the order of creating the connected order line and
--  041103           inserting the customer order line address.
--  041103  KeFelk   QC - Changed the customer_no to deliver_to_customer_No in err msg INVALIDDELADDR.
--  041102  GeKalk   Added new methods Calculate_Price_Conv_Factor and Modify_Price_Conv_Factor.
--  041101  DiVelk   Modified Update___ and Check_Before_Update___.
--  041028  Samnlk   Modify Check_Supply_Code___ ,add supply code 'PRJ' to the conditions.
--  041027  AnLaSe   Modified Unpack_Check_Update___ to allow of update of discount.
--  041026  ChJalk   Modified PROCEDURE Update___ to update the qty_invoiced to match what is really invoiced on the Staged Billing,
--  041026           when quantity/Assembly in a component is modified after any step has been invoiced partially or in full.
--  041026  DiVelk   Modified Check_Before_Insert___,Check_Before_Update___ and Check_Supply_Code___.
--  041025  JOHESE   Modified VIEW_DEMAND VIEW_DEMAND_CUSTORD VIEW_MS and VIEW_EXT
--  041022  DhAalk   Modified the procedures Unpack_Check_Update___ and Check_Supply_Code___.
--  041021  AnLaSe   Intersite Profitability: Added calculation of SALES_UNIT_PRICE in method Modify_Base_Price.
--                   Modified Unpack_Check_Update_ to allow update of price for orders with inter-site profitability.
--  041016  SaNalk   Modified Handle_Activity_Seq___ to stop project connections if pre posings exists for a financial project code part.
--  041015  NuFilk   Removed method Get_Total_Charge_Tax_Pct.
--  041014  LaBolk   Bug 46826, Modified Unpack_Check_Update___ and Update___.
--  041013  IsWilk   Modified the PROCEDURE Unpack_Check_Update___ to fetch the correct dop connection.
--  041006  UsRalk   Modified [Calculate_Cost_And_Progress] to report the component cost back to the Purchase Order Line.
--  041005  UsRalk   Added new method [Is_Purch_Comp_Part_Line___].
--  041005  DhAalk   Modified the PROCEDURE Unpack_Check_Update___.
--  041004  NuFilk   Modified method Check_Before_Update___ to fetch route and forward id correctly.
--  041001  LoPrlk   Miner modification was done in the method Unpack_Check_Update___.
--  040930  AnLaSe   Inter-site profitability: Added method Modify_Base_Price.
--  040929  DiVelk   Added public method [Get_Earliest_Ship_And_Due_Date].
--  040928  LaBolk   Bug 46826, Added derived attribute server_data_change. Modified Update___ to handle modifications of column qty_on_order and to clean up the code.
--  040927  MaMalk   Bug 47018, Modified the where conditions of views VIEW_DEMAND, VIEW_DEMAND_CUSTORD, VIEW_SIM, VIEW_EXT and VIEW_MS
--  040927           in order to include the 'Credit Blocked' customer orders with supply code 'Invent Order' when the demands are shown.
--  040922  LoPrlk   Miner modification were done to Check_Before_Update___ and Update___.
--  040922  SaNalk   Modified Handle_Activity_Seq___.
--  040921  LoPrlk   Added the field dop_new_qty_demand to the LU.
--  040920  LaBolk   LCS Bug 46648, Modified Check_Before_Insert___ and Check_Before_Update___ to fire an error when tax info is not defined for the customer.
--  040920  NiRulk   Bug 46674, Addedd parameter pkg_planned_ship_date_ to procedures Update_Package___ and Change_Package_Structure___to correctly update
--  040920           the package part planned ship date. Modified procedure Change_Package_Structure___ to correctly update the package component dates.
--  040914  MaEelk   Added public method Modify_Activity_Seq.
--  040909  NuFilk   Modified method Get_Line_Defaults___ added code to set fee code.
--  040909  Samnlk   Added project_id and activity_seq to view customer_order_line_address.
--  040909  SaNalk   Added a check for Financial Project code part value in Handle_Activity_Seq___.
--  040909  MaMalk   Bug 46595, Modified Check_Before_Insert___ and Check_Before_Update___ to raise error messages for invalid addresses.
--  040908  MaEelk   Removed the view CUSTOMER_ORDER_LINE_PROJECT.
--  040907  HoInlk   Bug 46422, Modified procedure Update_Package___, re-structured an IF condition to calculate dates not only when planned_delivery_date has changed,
--  040907           but also when planned_due_date changes.
--  040907  KeFelk   Added INTRASTAT_EXEMPT_DB to Prepare_Insert___.
--  040907  SaNalk   Modifed Get_Activity_Info___ for Customer Order milestones.
--  040831  Samnlk   Modify procedure Unpack_Check_Update___.
--  040831  NuFilk   Added method Get_Total_Line_Tax_Pct and Get_Total_Charge_Tax_Pct.
--  040830  DhAalk   Modified the PROCEDURE Get_Line_Defaults___.
--  040827  MaEelk   Added condition for supply code in Unpack_Check_Insert___.
--  040827  LoPrlk   Method Init_Before_Check_Insert___ was altered to pass DISTRICT_CODE,
--  040827           REGION_CODE and INTRASTAT_EXEMPT_DB for not single occurence addresses also.
--  040825  DiVelk   Added new view CUSTOMER_ORDER_LINE_PROJECT.
--  040823  PrPrlk   Bug 45888, Added a check in Check_Before_Insert___ and made changes to the  Check_Exist___ to check the duplication of line_no and rel_no for a given order
--  040823  LaBolk   Modified supply/demand views CUSTOMER_ORDER_LINE_DEMAND and CUSTOMER_ORDER_LINE_EXT to display type as Distribution Order for COs created by DOs.
--  040823  DiVelk   Modified [Validate_Proj_Connect___] to get the status of Activity.
--  040820  IsWilk   Modified the PROCEDUREs Unpack_Check_Insert___, Unpack_Check_Update___, Update___, Check_Before_Insert___,
--  040820           Check_Before_Update___, Init_Before_Check_Insert___ to correct the tax calculation according to the deliver_to_customer_no.
--  040820  IsWilk   Modified the PROCEDURE Get_Line_Defaults___.
--  040820  ChBalk   Bug 45543, Deduct qty_assigned when calculating demand_qty in Calculate_Order_Line_Dates___.
--  040818  DhWilk   Inserted General_SYS.Init_Method to Insert___, Lock_By_Id___, Finite_State_Machine___
--  040818           Inserted General_SYS.Init_Method to Get_Consignment_Stock_Db
--  040816  MiKulk   Bug 45929, Added a parameter for the method Change_Package_Structure___ and modified the Update_package___
--  040816           to get the changed Promised Delivery Date, also modified the calls to Change_Package_Structure___ by adding the new parameter.
--  040811  SaNalk   Modified Calculate_Cost_And_Progress,Handle_Activity_Seq___ and Get_Activity_Info___.
--  040811  GeKalk   Modified Modify_Delivery_Data to add revised_qty_due to the attribute string.
--  040810  LaBolk   Modified Modify_Delivery_Data to bring attribute SERVER_DATA_CHANGE to the front of the attr_.
--  040809  IsWilk   Modified the PROCEDUREs Calculate_Order_Line_Dates___, Get_Supply_Chain_Defaults___ and Update_Planning_Date
--  040809           to pass the deliver_to_customer_no.
--  040806  IsWilk   Added the parameter deliver_to_customer_no_ and modified the PROCEDURE Insert_Default_Address___,
--  040806           Update___, Post_Insert_Actions___, Get_Line_Defaults___, Check_Before_Insert___, Check_Before_Update___.
--  040806  IsWilk   Modified the view comments of delivery_to_customer_no in the base view and removed the added comments.
--  040804  IsWilk   Modified the PROCEDURE Copy_Customer_Order_Line to add the deliver_to_customer_no.
--  040803  LaBolk   Modified call to Distribution_Order_API.Modify_From_Connected_Order in Update___ to include route id.
--  040803  JaJalk   Modified the method Create_Sourced_Co_Lines to remove the UoM values if the line is manually sourced.
--  040802  JaBalk   Modified the Finite_State_Set___ to call the DO method Cancel_Connected_Orders to cancel the related PO and DO.
--  040728  NaWilk   Bug 46166, Modified method Unpack_Check_Insert___ to correctly update the ship_via_desc when the Automatic Sourcing is used.
--  040726  DiVelk   Modified [Get_Activity_Info___].
--  040723  LoPrlk   Miner changes were done to Init_Before_Check_Insert___.
--  040723  WaJalk   Changes related to column contact done.
--  040723  MaEelk   Modified Get_Activity_Info___.
--  040722  WaJalk   Modified Unpack_Check_Insert___.
--  040722  MaEelk   Modified Get_Activity_Info___.
--  040722  LoPrlk   Method Init_Before_Check_Insert___ was altered to work with single occurence addresses in internal direct deliveries.
--  040721  DhAalk   Modified the view CUSTOMER_ORDER_LINE_ADDRESS.
--  040720  SaNalk   Modified Get_Activity_Info___. Modified Finite_State_Set___ to update cost and progress for the project connected CO lines.
--  040719  GeKalk   Modified Modify_Delivery_Data to change the attr_.
--  040719  DhAalk   Modified the view CUSTOMER_ORDER_LINE_ADDRESS.
--  040716  NiRulk   Bug 45874, Modified cursor pkgpart_components in procedure Check_Before_Update___.
--  040716  NuFilk   Modified Call to Supplier_API.Get_Acquisition_Site to Get_Vendor_Contract__ in methods Check_Before_Insert___ and Check_Before_Update___ .
--  040716  DaRulk   Added method Is_Uom_Group_Connected.
--  040714  GeKalk   Modified Finite_State_Set___ to to change the states of the connected Distribution Order when Reserve the Order.
--  040714  IsWilk   Modified the PROCEDUREs Check_Before_Update___, Init_Before_Check_Insert___
--  040714           to replace customer_no with deliver_to_customer_no.
--  040713  DiVelk   Call 115935, Modified [Validate_Proj_Connect___].
--  040713  DaRulk   Added new attributes input_qty ,input_unit_meas ,input_conv_factor, input_variable_values
--  040712  MaEelk   Modified Proj_Disconnect____.
--  040712  MaEelk   Modified Validate_Proj_Connect___ and Unpack_Check_Update___ regarding consignment stocks.
--  040709  GeKalk   Modified Finite_State_Set___ to call the check_state of Distribution Order.
--  040709  KiSalk   Modified Modify_Delivery_Data not to add unchanged fields to attribute string.
--  040707  MiKulk   Bug 45803, Added code to the procedure Post_Insert_Actions___ to set the qty_invoiced to match what is really invoiced on the Staged Billing,
--  040707           when a component is added to the package structure after any step has been invoiced partially or in full.
--  040706  IsWilk   Modified the PROCEDURE Init_Before_Check_Insert___, Unpack_Check_Insert___
--  040706           Unpack_Check_Update___ and Get_Supply_Chain_Defaults___ to fetch the correct address.
--  040706  IsWilk   Modified the PROCEDURE Init_Before_Check_Insert___, Unpack_Check_Insert___ and Unpack_Check_Update___.
--  040706  GeKalk   Modified method Modify_Delivery_Data to change the Order Default check box.
--  040701  SaNalk   Modified method Calculate_Cost_And_Progress to check the existance of project connection before update.
--  040701  LaBolk   Modified Unpack_Check_Update___ and Update___ to handle modifications in DO.
--  040630  LaBolk   Removed parameter delivery_address from Modify_Delivery_Data (reversed correction of 040629-NaWalk). Modified Update___.
--  040630  DiVelk   Modified [Unpack_Check_Update___].
--  040630  NuFilk   Modified Check_Before_Insert___ and Check_Before_Update___ to prevent creation of order lines when the part
--  040630           does not exist in the site connected to the Internal order or if the part is Weighted Average Cost Handled in the internal site.
--  040629  NaWalk   Added parameter delivery_address to Modify_Delivery_Data.
--  040628  DiVelk   Modified message in constant COLWRONGCUST.
--  040628  ChBalk   Bug 42635, Added supply_code 'SO', when user selected 'Shop Order' in Source From Order Site.
--  040625  SaNalk   Modified the method Get_Activity_Info___.
--  040625  DiVelk   Modified [Validate_Proj_Connect___] and [Validate_Proj_Disconnect___].
--  040624  LaBolk   Modified paramters of Modify_Delivery_Data. Modified Update___.
--  040624  SaNalk   Modified the method Calculate_Cost_And_Progress.
--  040623  LaBolk   Modified the call to Distribution Order in Update___. Modified Modify_Delivery_Data.
--  040622  SaNalk   Modified the method Get_Activity_Info___.
--  040622  GeKalk   Modify the method Finite_State_Set__ to add the event_ variable from the call to Distribution Order.
--  040621  KiSalk   Corrected parameters for call Distribution_Order_API.Modify_From_Connected_Order.
--  040616  NaWalk   Changed Modify_Order_Line_Dates to Modify_Delivery_Data.
--  040616  MaMalk   Modified the method Insert_Default_Address___ by adding the county field.
--  040618  DiVelk   Added check for 'activity_seq > 0' with NOT NULL condition.
--  040617  KiSalk   Added error message when changing condition_codefor demand_code = 'DO'
--  040617  WaJalk   Added attribute Contact, modified Get, Insert___, Update_Line___, Unpack_Check_Insert___ and Unpack_Check_Update___.
--  040616  GeKalk   Modify the method Finite_State_Set__ to remove the event_ variable from the call to Distribution Order.
--  040615  NaWalk   Made a checks to Disallow adding of Customer Order Lines ,and to disallow creating SM Objects when CO created by a DO.
--  040615  LoPrlk   Added the attribute DeliverToCustomerNo to the LU and set its default value in Init_Before_Check_Insert___.
--  040611  Samnlk   Modify method Unpack_Check_update to restrict the consignment stock check when line has project connection.
--  040610  DiVelk   Modified Handle_Activity_Seq___.
--  040610  Samnlk   Change the parameters in methods Validate_Proj_Connect___, Validate_Proj_Disconnect___ and Handle_Activity_Seq___.
--  040609  Asawlk   Bug 44917, Modified procedures Check_Before_Update___ and Unpack_Check_Insert___, re-structured an IF condition to
--  040609           raise errors when a Condition Code is entered for a Package Part or a Non Inventory Sales Part.
--  040609  ChBalk   Bug 41364, Modified condition when calling Calculate_Order_Line_Dates___ in Check_Before_Update___.
--  040609           Changes in Calculate_Order_Line_Dates___ when calling Cust_Ord_Date_Calcultions_API.Get_Order_Dates.
--  040609  Samnlk   Call the method Handle_Activity_Seq___ from procedure Update___ and Insert___.
--  040608  Samnlk   Change the parameters in method Handle_Activity_Seq___.
--  040607  Samnlk   Changed the method Delete___, to disconnect the project connection when line is deleting.
--  040604  NiRulk   Bug 44993, Modified procedure Update___ to create new default address when unchecking the order default flag.
--  040603  Samnlk   Added new methods Validate_Proj_Disconnect___ and Handle_Activity_Seq___  for project connection.
--  040601  Samnlk   Added new method Validate_Proj_Connect___ for project connection.
--  040528  NaWilk   Bug 44959, Modified methods Get_Supply_Chain_Defaults___ and Unpack_Check_Insert___ to get ship via description correctly.
--  040525  SaRalk   Bug 44207, Modified procedure Update___ to generate history lines when qty changed in package component lines.
--  040524  SaNalk   Modified Get_Activity_Info___.
--  040520  SaNalk   Added methods Calculate_Cost_And_Progress and Get_Activity_Info___.
--  040519  KiSalk   Added Procedure Modify_Order_Line_Dates, attribute server_date_change and
--  040519           modified Unpack_Check_Update___, Update___.
--  040518  JaBalk   Changed the static call Distribution_Order_API to dynamic call.
--  040517  KaDilk   Bug 44464, Removed the dymanic calls to Delivery_Fee_Code_API in procedures Post_Insert_Actions___,Update___ and added error messages
--  040517           POLINEPNOTEXIST,POCOCNOTEXIST,PURORDNOTEXIT.Added global constants inst_PurOrderCustOrderComp_,inst_PurchaseOrderLinePart_.
--  040517  GeKalk   Modified Finite_State_Set__ method to change the connected PO Line state.
--  040513  NaWilk   Bug 44113, Modified method Get_Supply_Chain_Defaults___ to get ship via description correctly.
--  040512  GeKalk   Modified Finite_State_Set__ method to change the connected DO and PO state.
--  040512  JaJalk   Corrected the lead time lables.
--  040512  IsWilk   Rewrote the DBMS_SQL to Native dynamic SQL inside FOR LOOPs.
--  040429  UsRalk   Modified Get, Insert___, Update___, Unpack_Check_Insert___ and Unpack_Check_Update___.
--  040429  UsRalk   Added column PROJECT_ID to view CUSTOMER_ORDER_LINE and added Get_Project_Id.
--  040426  MaMalk   Bug 37374, Removed the Check_Base_Part_Config__ from Insert___,Update___ procedures and modified the procedures
--  040426           Modify,Post_Insert_Actions___ and Update___, Removed Update_Package_Charprice___ and updated the procedures
--  040426           Delete___,Post_Insert_Actions___,Update___.
--  040421  KiSalk   SCHT603 Supply Demand Views - Removed CUSTOMER_ORDER_LINE_SIM
--  040419  SaNalk   Added column Activity_Seq to view CUSTOMER_ORDER_LINE and to method Get. Modified Unpack_Check_Insert___, Unpack_Check_Update___,
--  040419           Insert___ and Update___.Added method Get_Activity_Seq.
--  040416  LoPrlk   SCHT603 Supply Demand Views - Reversed the change done in "040415  LoPrlk".
--  040415  KiSalk   SCHT603 Supply Demand Views - Added column qty_reserved to views CUSTOMER_ORDER_LINE_DEMAND,
--                   CUSTOMER_ORDER_LINE_DEMAND_OE, CUSTOMER_ORDER_LINE_MS and CUSTOMER_ORDER_LINE_EXT.
--  040415  LoPrlk   SCHT603 Supply Demand Views - Added the column wanted_due_date to the views CUSTOMER_ORDER_LINE_DEMAND, CUSTOMER_ORDER_LINE_DEMAND_OE, CUSTOMER_ORDER_LINE_MS and CUSTOMER_ORDER_LINE_EXT.
--  040414  NaWalk   SCHT603 Supply Demand Views - Added column qty_pegged to views CUSTOMER_ORDER_LINE_DEMAND,CUSTOMER_ORDER_LINE_DEMAND_OE,CUSTOMER_ORDER_LINE_MS and CUSTOMER_ORDER_LINE_EXT .
--  040409  VeMolk   Bug 43324, Modified the argument passed to the method Validate_Mro_Line___ from sales_part_no to inventory_part_no.
--  040402  CaRase   Bug 43140, Create procedure Check_Active_Part___.
--  040318  LaBolk   Added column comments for db columns part_ownership_db and release_planning_db. Made minor changes due to cat modifications.
--  040315  UdGnlk   Bug 43364, Modified method Update___ to reverse the previous correction used to handle Stage Billing flow.
--  040305  MiKalk   Bug 42952, Modified method Update_Planning_Date__ to use newrec_.planned_ship_date
--  040305           instead of new_planned_ship_date_ and removed new_planned_ship_date_ from the method.
--  040305  MiKalk   Bug 42853, Modified the text for Constant 'COMPANYOWNAUTOSRC' in Unpack_Check_Insert___ method.
--  040303  DaZa     Bug 42004, added extra checks so we dont make priority reservations when a local site reservations
--                   exist when a sourced line is released into a regular CO line.
--  040227  IsWilk   Removed the SUBSTRB from the views and modified the SUBSTRB to SUBSTR for Unicode Changes.
--  040226  LaBolk   Moved code to method Get_Cost in PKG and removed Get_Cost from PKG2.
--  040226           Removed PKG2 along with its Init method and define and undefine statements.
--  040226  LaBolk   Moved code to the respective public mathods of PKG and removed the following from PKG2: Get_Qty_Shipdiff, Get_Qty_Shipped, Get_Qty_To_Ship, Get_Qty_Short, Get_Ref_Id,
--  040226           Get_Revised_Qty_Due, Get_Sale_Unit_Price, Get_Warranty, Get_Wanted_Delivery_Date, Get_Supply_Code and Get_Sub_Dock_Code.
--  040226  LaBolk   Moved code to the respective public mathods of PKG and removed the following from PKG2: Get_Price_Freeze, Get_Price_Conv_Factor, Get_Price_Source, Get_Price_Effectivity_Date, Get_Price_Source_Id,
--  040226           Get_Qty_Assigned, Get_Qty_Invoiced, Get_Qty_On_Order, Get_Qty_Returned and Get_Qty_Picked.
--  040226  LaBolk   Moved code to the respective public mathods of PKG and removed the following from PKG2: Get_Note_Text, Get_Order_Discount, Get_Original_Part_No, Get_Job_Id, Get_Location_No,
--  040226           Get_Part_Price, Get_Planned_Due_Date, Get_Planned_Due_Date, Get_Pre_Accounting_Id and Get_Planned_Ship_Date.
--  040226  LaBolk   Moved code to the respective public mathods of PKG and removed the following from PKG2: Get_Desired_Qty, Get_Date_Entered, Get_Customer_Part_No, Get_Customer_Part_Buy_Qty, Get_Delivery_Leadtime,
--  040226           Get_Intrastat_Exempt, Get_Discount, Get_Interim_Order_No, Get_Dock_Code and Get_Earliest_Start_Date.
--  040226  LaBolk   Moved code to the respective public mathods of PKG and removed the following from PKG2: Get_Catalog_Desc, Get_Calc_Char_Price, Get_Char_Price, Get_Base_Sale_Unit_Price, Get_Buy_Qty_Due,
--  040226           Get_Conv_Factor, Get_Close_Tolerance, Get_Configured_Line_Price_Id, Get_Ctp_Planned, Get_Cust_Warranty_Id.
--  040225  LaBolk   Moved methods Get_Def_Supplier_Ship_Via___ and Get_Supply_Chain_Defaults___ from PKG2 to PKG. Moved some constants from PKG2 to PKG.
--  040225           Moved code to the respective public methods in PKG and removed the following methods from PKG2: Get_Purchase_Order_Info___ and Get_Shop_Order_Info___.
--  040224  LaBolk   Moved code to the respective public and private methods in PKG and removed the following methods fromPKG2: Get_Qty_Demand___, Get_Sale_Price_Total___, Get_Sum_Invoiced_Base_Curr___, Get_Sum_Invoiced_Order_Curr___,
--  040224           Get_Sum_Shipped_Base_Curr___ and Get_Sum_Shipped_Order_Curr___.
--  040224  LaBolk   Moved methods Get_Line_Defaults___ and Get_Default_Part_Attributes___ from PKG2 to PKG.
--  040224           Moved code to the respective private methods of PKG and deleted the following methods from PKG2:  Get_Backlog_Value_Base_Curr___, Get_Backlog_Value_Ord_Curr___, Get_Backord_Value_Base_Curr___  and Get_Cust_Part_No_Defaults___.
--  040224  LaBolk   Moved methods Retrieve_Default_Vendor___, Validate_Fee_Code___, Validate_Mro_Line___, Validate_Vendor_Category___ and Validate_Vendor_No___ from PKG2 to PKG
--  040224  LaBolk   Moved methods Exist_Sm_Object___, Update_Config_Pricing_Info___, Exist_Vendor_No___ and Set_Job_Pre_Posting___ from PKG2 to PKG.
--  040224           Added constants inst_PurchasePartSupplier_ and inst_EquipmentObject_ to PKG.
--  040224  LaBolk   Moved methods Check_Qty_From_Repair_Order___, Close_Financial_Project___, Check_Supply_Code___, Exist_Purchase_Part___ and Exist_Job_Id___ from PKG2 to PKG1.
--  040224           Moved constants inst_PurchasePart_, inst_AccountingProject_ and inst_AccountingProjUtil_ from PKG2 to PKG.
--  040223  LaBolk   Moved code to the respective private methods in PKG and removed the following methods from PKG2: Check_Base_Part_Config___, Check_Delivery_Terms___ and Check_Ship_Via_Code___.
--  040223           Removed methods Check_Exist___, Lock_By_Keys___, Get_Object_By_Id___ and Get_Id_Version_By_Keys___ from PKG2.
--  040219  LaBolk   Moved methods Add_Info___, Update___, Modify_Line___, Post_Insert_Actions___, Change_Package_Structure___, Update_Package___, Update_Package_Cost___,
--  040219           Update_PackageLine___, Update_Package_Charprice___, Check_Allow_Backorders___, Insert_Default_Address___, Calculate_Order_Line_Dates___ and Insert_Package___ from PKG2 to PKG.
--  040219           Moved the code to respective public and private methods in PKG and deleted the following methods in PKG2: Calc_Route_Departure_Date___, Modify_Qty_Returned___, Modify_Arrival___,
--  040219           Modify_Bonus_Value___, Modify_Bonus_Value___, Modify_Order_Discount___, Update_Planning_Date__, Modify_Acquisition_Type__ and Get_Base_Sale_Price_Total___.
--  040219           Removed Get_Object_By_Keys___ from PKG2.
--  040219           Moved methods Prepare_Insert___, Unpack_Check_Update___, Check_Before_Insert___, Check_Before_Insert___, Init_Before_Check_Insert___ and Init_Before_Check_Insert___ from PKG3 to PKG.
--  040219           Removed Get_Object_By_Keys___ and Init from PKG3. Finally removed the package PKG3 along with its DEFINE and UNDEFINE statements.
--  040213  MiKalk   Bug 42148, Added error messages in Unpack_Check_Update___ and Modify_Staged_Billing when staged billing and consignment stock are used together.
--  040213           Added new function Get_Consignment_Stock_Db.
--  040211  MiKalk   Bug 42010, Modified the method Modify_Staged_Billing to allow creation of invoice after removing the stage billing profile
--  040211           and added Error message when trying add new profile once the order line is Partially Delivered or Delivered.
--  040209  Castse   Bug 40663, Modified Init_Before_Check_Insert___ to default route_id and forward_agent_id
--                   from customer only if no route_id and forward_agent_id has been set for specific order line.
--  040209  GeKalk   Convert  CHR() to UNISTR() for UNICODE modifications.
--  040129  GeKalk   Rewrote the DBMS_SQL to Native dynamic SQL for UNICODE modifications.
--  040126  SeKalk   Bug 41397, Modified the procedure Modify_Order_Defaults__.
--  040122  AnLaSe   Bug 41282, Modified Init_Before_Check_Insert___ to default delivery term from customer
--                   only if no delivery term has been set for specific order line.
--  040116  SeKalk   Bug 41033, Modified the procedures Get_Supply_Chain_Defaults___, Init_Before_Check_Insert___.
--                   Changed the retreival of customer agreement and deleted the setting default_address_flag to N.
--  ------------------------------ 13.3.0-------------------------------------
--  ********************* VSHSB Merge End *************************
--  021023  Prinlk   Added method Modify_Shipment_Connection.
--  021017  Prinlk   Added some modification after code review.
--  021011  GeKalk   Added an Get_Self_Billing_Db() to get the value of that property.
--  021009  Prinlk   Added an additional condition to the view 'CUSTOMER_ORDER_LINE_CHARGE_LOV' not to show self_billing order lines.
--  020425  GeKa     Added self_billing to Unpack_Check_Update___ and Update_Line___ functions.
--  020318  GeKa     Add self_billing to view CUSTOMER_ORDER_LINE and Get_Line_Defaults___.
--  020328  MaGu     Changed attribute shipment_connected to public.
--  020124  Prinlk   Added a warning message when changing delivery information in a line which connected to a shipment.
--                   Set Shipment_Connected field to 1 when adding new line to Customer Order Line.
--  020118  Prinlk   Added connected_shipment attribute to the LU.
--  ********************* VSHSB Merge *****************************
--  040122  HaPulk   Removed parameter WNPS from PRAGMA references.
--  040120  GeKalk   Replaced INSTRB with INSTR for UNICODE modifications.
--  040114  LoPrlk   Rmove public cursors, Method Insert_Package___ was altered, cursor get_pkg_ingridients was added
--  040114           and calls for Sales_Part_Package_API.Get_Package_Ingridients were substituted by calls to get_pkg_ingridients.
--  --------------------------------------- 13.3.0 ------------------------------------
--  031111  JaJalk   Modified the Update___ method to add an extra check on the call Connect_Customer_Order_API.Modify_Dop.
--  031107  DaZa     Added extra check for addr_flag and default_addr_flag in Get_Supply_Chain_Defaults___ to fix some issues with overriding ship_via_code and delivery_leadtime.
--  031106  JoAn     Added an error Message in procedure Unpack_Check_Insert___ for create_sm_object_option when the supply code is MRO.
--  031106  JoEd     Changed so that the dates are recalculated from wanted delivery date
--                   when only supply code, address or supplier has been changed in Unpack_Check_Update___
--                   otherwise the "greatest of the planned and wanted date".
--  031106  SaNalk   Added an error Message in procedure Unpack_Check_Update___ for create_sm_object_option when the supply code is MRO.
--  031106  SaNalk   Added a check for create_sm_object_option when the supply code is MRO in procedure Get_Line_Defaults___.
--  031105  ChIwlk   Modified methods Get_Default_Part_Attributes___ and Get_Line_Defaults___ to consider condition codes in pricing.
--  031029  GaJalk   Modified procedure Update_Line___.
--  031028  JaJalk   Reversed the bug correction of 38052.
--  031024  JoAnSe   Added copying of promised_delivery_date in Copy_Customer_Order_Line.
--                   Also made some other changes regarding the handling of promised_delivery_date.
--                   Removed 'Note:' in all comments.
--  031022  JoEd     Added planned delivery date in attribute string in Create_Sourced_Co_Lines
--                   to avoid inherit it from order header.
--  031022  ZiMolk   LCS Bug 38376, Removed the supply type DOP from the check for the information message 'WRONGSUPPLY'.
--  031017  JoAnSe   Removed qty_on_order from the expression used to decide demand_qty in
--                   CUSTOMER_ORDER_LINE_SIM
--  031017  JaJalk   Modified the method Modify_Additional_Discount__ to handle additional discounts.
--  031016  JaJalk   Modified method Update___ to remove the tax code when pay tax is unchecked.
--  031016  NaWalk   LCS Bug 39358 ,Modified Check_Before_Insert___ to keep the value entered by user for consignment stock in customer order line
--  031015  JoAnSe   Changed Calculate_Order_Line_Dates___, demand_qty_ set for IPT and IPD
--  031015  PrJalk   Bug Fix 106224, Corrected wrong General_Sys.Init_Method calls for Implementation methods delared in Package.
--  031014  JoEd     Changed check on configured parts and automatic sourcing.
--  031014  SaNalk   Modified a condition for Pay Tax check box in PROCEDURE Update___.
--  031013  DAYJLK   Call Id 105252, Modified Insert___ to insert NULL for cust_warranty_id when order line is for
--  031013           externally owned stock or if it originates from an external service order or if its for an exchanged item.
--  031013  PrJalk   Bug Fix 106224, Added missing General_Sys.Init_Method calls.
--  031009  JoEd     Removed earliest delivery date message in Unpack_Check_Update___.
--                   Changed date recalculation logic. Removed EARLY_DATE message.
--  031008  BhRalk   Modified the method New to append time part to Wanted Delivery Date.
--  031008  SaNalk   Modified the FUNCTION Get_Total_Tax_Amount to round off the tax amount.
--  031008  BhRalk   Modified the method Update_Planning_Date__ to append  timepart to planned ship date.
--  031007  DaZa     Moved the site-to-site-connection-allowed check in Unpack_Check_Update___.
--  031003  DaZa     Added block_component_info_ for PKG2 and added extra check in Add_Info___ method to block component info messages.
--  031002  JoAnSe   Changed Get_Supply_Chain_Defaults___ due to changes in Cust_Order_Leadtime_Util.
--                   Changed all calls to Get_Agreement_For_Part so that catalog_no is passed in instead of part_no
--  031002  PrTilk   Added a new public method Get_Demand_Order_Info.
--  031002  UdGnlk   Modified method Check_Before_Update___ allow to change condition code for external service order Release state.
--  031001  DaZa     Added extra site-to-site-connection-allowed check in Unpack_Check_Insert___/Unpack_Check_Update___.
--  030930  SuAmlk   Corrected invalid dynamic sql statement in method Check_Qty_From_Repair_Order___.
--  030929  JoAnSe   Corrected initialization of ship via code in Create_Sourced_Co_Lines
--                   Made some changes in Get_Supply_Chain_Defaults___
--  030926  DaZa     Fixed problem in Unpack_Check_Insert___/Unpack_Check_Update___ that override supply_site_reserve_type value from the client.
--  030925  NuFilk   Added the method Check_Pegged_Component_Exist, and modified Get_Send_Change_Msg_For_Supp.
--  030924  DaZa     Added a fix Check_Before_Update___ so supply_site_due_date is returned to client when supply code is changed to IPD/IPT.
--                   Added extra checks in Unpack_Check_Update___. Fixed some invalid NVL,'') checks.
--  030923  MaGulk   Merged bug 37024, Added Get_Sm_Connection_Db function.
--  030922  UdGnlk   Modified method Check_Before_Update___ by adding a new error message when line status not in Released.
--  030922  JaJalk   Added the method Get_Purchase_Order_No.
--  030919  JoAnSe   Changed Init_Before_Check_Insert___. No exceptions should be needed when
--                   created_by_server is TRUE.
--  030919  DaZa     Added extra where-statements on the supply demand views so order head status is checked.
--  030919  JaJalk   Modified the method Update___ to re-calc tax.
--  030918  KeFelk   B103541, Removed originated_by from CURSOR get_purchase_type.
--  030918  JoEd     Changed fetch of ship via transit description.
--  030917  DaZa     Added a fix Check_Before_Update___ so supply_site_due_date is cleared if not IPD/IPT.
--  030917  NuFilk   Modified procedure Get_Supply_Chain_Defaults___.
--  030916  MaMalk   Bug 37022, Updated the procedures Modify_Order_Defaults__ and Unpack_Check_Insert___.
--  030915  DaZa     Added purchase_part_no to all Create_Instant_Reservation__ calls so we can handle non-inventory parts on demand site in supply site reservation.
--  030915  JoEd     Added supplier part no to date calculation methods.
--  030915  HaPulk   Bug 38052, Modified method Modify_Qty_To_Ship__ to update field QTY_TO_SHIP with total quantity received.
--  030915  UdGnlk   Modified method Check_Before_Update___ to check condition code when header status Planned and line status Released.
--  030915  SuAmlk   Modified method Check_Supply_Code___ to include MRO in the Check for the correct SUPPLY_CODE.
--  030910  JoAnSe   Restructured the code for retrieval of ship_via_code and delivery_leadtime
--                   Removed info message previously created when no leadtimes were found.
--                   Cleaned up the code in the Unpack_Check methods.
--                   Made the default_addr_flag and customer_no attributes public.
--  030909  DaZa     Added a Supply Site Reservation exist check in method Check_Delete___.
--  030908  ChBalk   Modified Check_Before_Update___ to remove ship_via_transit when supply_code is other than IPT, PT.
--  030905  NuFilk   Modified Unpack_Check_Update___ included a check when changing supply code.
--  030905  WaJalk   Modified occurences of acquisition type/mode to supply code in methods
--                   Validate_Mro_Line___, Unpack_Check_Update___, Check_Before_Update___.
--  030903  JoAnSe   Changed the cost retrieval for package components.
--                   Method Inventory_Part_Cost_API.Get_Cost is always used.
--  **************************** End CR Merge 02 ********************************
--  030903  NuFilk   CR Merge 02
--  030829  NuFilk   Modified Check_Before_Update___ changed message tag name.
--  030829  NuFilk   Modified Unpack_Check_Insert___ to fetch supplier ship via for IPD if data is missing in supply chain matrices.
--  030828  NuFilk   Modified Unpack_Check_Insert___ to update leadtime when created from sourcing.
--  030828  NuFilk   Modified method Copy_Customer_Order_Line and Create_Sourced_Co_Lines.
--  030828  NaWalk   Performed code review.
--  030827  ChBalk   Added validated ship_via_desc to the newrec when inserting record.
--  030827  NuFilk   Modified originating_line_item_no and originating_rel_no related logic.
--  030826  ChBalk   Added more validation on leadtime zero info message, in Insert___.
--  030826  ChBalk   Added validation for ship_via_code when changes done to the vendor_no, Supply_code and Ship_Address.
--  030826  ChBalk   Added Error_SYS.Check_Not_Null for SHIP_VIA_CODE
--  030822  NuFilk   Changed message in Unpack_Check_Update___.
--  030820  JoEd     Added check on supply code in Check_Before_Update___ to
--                   recaclulate all dates if changed from ND.
--  030820  DaZa     Modified check and fetch of default supply_site_reservation_type in Check_Before_Update___.
--  **************************** CR Merge 02 ************************************
--  030902  PrTilk   Modified VIEW CUSTOMER_ORDER_LINE_RMA_LOV. Removed exchange item check.
--  030829  DaZa     Added check in Unpack_Check_Insert___ so automatic sourcing demands COMPANY OWNED part. Added some Take-Off columns to Copy_Customer_Order_Line.
--  030827  PrTilk   Changed error constants in Check_Before_Update___.
--  030820  GaSolk   Performed CR Merge.
--  030815  NuFilk   Modified method Unpack_Check_Insert___ to fetch leadtimes correctly.
--  030814  DaZa     Modified check on reserve type INSTANT in method Unpack_Check_Update___ so we also check CO status now,
--                   also added an error message UPDTOINSTANTERR to this check.
--  030814  DaZa     Changed the check before update of release_planning flag in method Check_Before_Update___.
--                   Removed method Modify_Release_Planning.
--  030813  DaZa     Made some fixes so the client value of SUPPLY_SITE_RESERVE_TYPE is always added to attribute strings.
--  030813  CaRase   Modified in procedure Create_Sourced_Co_Lines, ship_via_code is fetch from sourced_lines_.ship_via_code regardless of sourced_lines_.supply_code.
--  030813  WaJalk   Modified views CUSTOMER_ORDER_LINE_DEMAND_OE and CUSTOMER_ORDER_LINE_SIM.
--  030812  NuFilk   Modified Update___ to enable the the warning message for sourced pegged lines to happen once.
--  030812  WaJalk   Modified view CUSTOMER_ORDER_LINE_DEMAND_OE.
--  030808  NuFilk   Modified Update___ to enable creation of SO,Purch Orders when line supply code is changed.
--  030807  NuFilk   Modified Create_Sourced_Co_Lines to correctly handle stage billing.
--  030806  ChBalk   Code review changes.
--  030806  Asawlk   Modified Check_Before_Insert___ and Check_Before_Update___ to set Release_Planning flag if supply code is IPD or IPT.
--  030728  ChBalk   Bug fixed, Moved ship_via_code_ validations against supply_code_ in Unpack_Check_Insert___ further down.
--  030728  NuFilk   Bug fixed, Modified in Unpack_Check_Update___ a condition checking sourced qty.
--  030725  ChBalk   Bug fixed. Moved Check_Leadtime_Exist from Unpack_Check_Insert, Unpack_Check_Update to Insert, Update.
--  030725  ChBalk   Bug fixed. Modified supply_code, added Order_Supply_Type_API.Encode() insted of Decode().
--  030724  NuFilk   Modified method Create_Sourced_Co_Lines.
--  030716  NaWalk   Removed Bug coments.
--  030716  NuFilk   Merged corrections that have been applied in quick correction.
--  030716  SeKalk   Changed the Supplier_API.Get_Acquisition_Site to PKG..Get_Vendor_Contract__ when dynamic calls aren't used
--  030703  CaRase   Move check if vendor_no is NULL in method Unpack_Check_Insert___ and Check_Before_Update___.
--  030702  NuFilk   Modified method Unpack_Check_Update___, Post_Insert_Actions___ and Update__ to create
--  030702           history transactions for lines created through sourcing.
--  030702  Asawlk   Modified views CUSTOMER_ORDER_LINE_EXT, CUSTOMER_ORDER_LINE_DEMAND, CUSTOMER_ORDER_LINE_DEMAND_OE, CUSTOMER_ORDER_LINE_MS AND CUSTOMER_ORDER_LINE_SIM.
--  030701  JoEd     Removed Calculate_Planned_Due_Date__, Calculate_Planned_Due_Date___ and Calculate_Planned_Ship_Date___.
--                   Changed Calculate_Order_Line_Dates___ to use general date calculation methods.
--                   Added attribute supply_site_due_date.
--  030630  JoEd     Replaced call to Reserve_Or_Make_Analysis__ with Create_Priority_Reservation__.
--                   Removed parts of bug correction 30258.
--  030626  DaZa     Added new method Get_Def_Supplier_Ship_Via___ and new param header_language_code_ to Check_Before_Update___.
--                   Added constants inst_SupplierAddress_, inst_SuppAddrPartLeadtime_,inst_SupplierAddressLeadtime_.
--  030626  NuFilk   Modified checks on sourced lines in method Unpack_Check_Update___.
--  030625  DaZa     Added new public attributes SUPPLIER_SHIP_VIA_TRANSIT and SUPPLIER_SHIP_VIA_TRANSIT_DESC.
--  030625  SeKalk   Added the column SUPPLY_SITE to CUSTOMER_ORDER_LINE_TAB
--  030623  DaZa     Added a check for COL status when changing the value on supply_site_reserve_type in method Check_Before_Update___.
--                   Removed checks for CO status = 'Planned' when fetching default value for supply_site_reserve_type.
--  030620  WaJalk   Modified method Get_Send_Change_Msg_For_Supp.
--  030620  ChBalk   Added Get_Vendor_no, Get_Send_Change_Msg_For_Supp methods.
--  030618  ChBalk   Added replicate_changes,change_request two dummy columns to the main view.
--  030617  DaZa     Added sourced reservation transfer handling in method Create_Sourced_CO_Lines.
--  030616  DaZa     Made some changes on the handling of supply_site_reserve_type since it now isnt NULLABLE anymore. Changed error message NOSUPPLY.
--  030616  NuFilk   Added method Get_Note_Id, Create_Sourced_Co_Lines.
--  030612  JoEd     Added column RELEASE_PLANNING - for the planning/supply demand views
--                   to handle supply site reservations.
--  030609  NuFilk   Added Copy_Customer_Order_Line method and modified Insert___.
--  030603  JoEd     Changed supply code/vendor update check - added Not Decided...
--                   Added creation of connected orders when changing supply code from ND.
--                   Made Vendor No mandatory when using Purchase supply.
--  030528  NuFilk   Modified check for order header state in Unpack_Check_Update___method.
--  030527  DaZa     Added extra fetch of default value for supply_site_reserve_type after automatic_sourcing in Unpack_Check_Insert___
--  030526           Unpack_Check_Update___.
--  030524  NuFilk   Modified check for Order state in Check_Before_Update___.
--  030523  PrInlk   Made modifications complient to changes on defaults ORIGINATING_REL_NO(0),ORIGINATING_LINE_ITEM_NO(-1)
--                   in Unpack_Check_Update___.
--  030522  PrInlk   Set the ORIGINATING_REL_NO(0),ORIGINATING_LINE_ITEM_NO(-1) to its defaults when adding records.
--                   These values then uses in report printing.
--  030520  ChBalk   Removed check for newline when supply code is 'Not Decided'.
--  030520  ThGulk   Modified Unpack_Check_Update___. Added supply_code Not Decided, sourcing completed checks.
--  030519  ChBalk   Added originating_rel_no, originating_line_item_no public attributes.
--  030509  JoEd     Changed supply_code logic. Removed use of so_flag and purchase_flag.
--  030508  ChBalk   Changed method call from Cust_Order_Leadtime_Util_API.Get_Leadtime_Values to Get_Default_Values.
--  030505  DaZa     All occurences of acquisition type/mode changed to supply code.
--  030502  DaZa     Added fetches of default supply_site_reserve_type_ in methods Check_Before_Insert___ and Check_Before_Update___.
--  030429  DaZa     Added check for supply site reservation and changed revised_qty_due to less than already reserved in Check_Before_Update___.
--  030428  JoEd     Added update check on vendor_no and supply_site_reserve_type. Don't allow update if supply site reservation still exists.
--  030425  WaJalk   Default address flag set to NO for lines related to external customers and external suppliers.
--  030424  WaJalk   Modified method Init_Before_Check_Insert___, Modified the call to Cust_Order_Leadtime_Util_API.Get_External_Default_Values
--                   in Unpack_Check_Insert___ and Unpack_Check_Update___.
--  030423  NuFilk   Added call to Cust_Order_Leadtime_Util_API.Get_Default_Values and Get_Leadtime_Values
--  030423           in methods Init_Before_Check_Insert___ and Unpack_Check_Insert___,Unpack_Check_Update___ respectively.
--  030423  WaJalk   Added call to Cust_Order_Leadtime_Util_API.Get_External_Leadtime_Values in methods
--                   Unpack_Check_Insert___ and Unpack_Check_Update___.
--  030423  DaZa     Added calls to Reserve_Customer_Order_API.Is_Supply_Chain_Reservation in methods
--                   Change_Package_Structure___, Post_Insert_Actions___ and Update___. Added check for
--                   supply_site_reserve_type in Unpack_Check_Update___.
--  030409  DaZa     Added new attribute supply_site_reserve_type. Added vendor_no to Get method.
--  ***************************************CR Merge*******************************************************************************************************************************
--  030814  SuAmlk   Modified method call Invent_Condition_Code_Util_API.Get_Est_Cost_Per_Condition to Inventory_Part_Cost_API.Get_Cost in
--                   Get_Line_Defaults___, Unpack_Check_Update___and Init_Before_Check_Insert___ .
--  030813  ChIwlk   Modified procedures Insert___ and Update___ to remove information message on condition code pricing.
--  030812  SuAmlk   Modified method call Inventory_Part_Unit_Cost_API.Get_Invent_Value_By_Condition to Invent_Condition_Code_Util_API.Get_Est_Cost_Per_Condition in
--                   Get_Line_Defaults___, Unpack_Check_Update___and Init_Before_Check_Insert___ .
--  030805  UdGnlk   Modified method Check_Before_Update___ for Call ID 99646 to allow updating condition code even the header status Released.
--  030804  GaJalk   Code review changes.
--  030804  GaSolk   Performed SP4 Merge.
--  030729  ChIwlk   Modified procedures Insert___ and Update___ to add an information message.
--  030725  SaAblk   Removed obsolete views CUSTOMER_ORDER_LINE_MS2 and CUSTOMER_ORDER_LINE_DEMAND1
--  030725  GaJalk   Modified Procedure Update___.
--  030725  JaJalk   Modified the method Get_Qty_Returned.
--  030724  JaJalk   Modified the function Get_Qty_Returned to a procedure.
--  030722  JaJalk   Added the function Get_Qty_Returned.
--  030718  GeKalk   Changed a method in Post_Insert_Actions___ with the new method Inventory_Part_In_Stock_API.Get_Inventory_Quantity().
--  030715  SuAmlk   Modified method call Inventory_Part_Unit_Cost_API.Get_Invent_Value_By_Condition to Inventory_Part_Unit_Cost_API.Get_Cost_Per_Condition in Get_Line_Defaults___.
--  030711  GeKalk   Modified method Get_Qty_Demand__ to add a condition to get only 'COMPANY OWNED' and 'CONSIGNMENT' records.
--  030711  GeKalk   Modified CUSTOMER_ORDER_LINE_MS and CUSTOMER_ORDER_LINE_MS2 views to get records where part_ownership = 'COMPANY OWNED' and part_ownership = 'CONSIGNMENT'.
--  030710  GeKalk   Added condition to get only 'COMPANY OWNED' and 'CONSIGNMENT' records from views
--  030710           CUSTOMER_ORDER_LINE_DEMAND, CUSTOMER_ORDER_LINE_DEMAND_OE, CUSTOMER_ORDER_LINE_SIM, CUSTOMER_ORDER_LINE_EXT
--  030709  ChFolk   Reversed the changes that have been done for Advance Payment.
--  030612  UsRalk   Added new method [Synchronize_Tax_Data] to update the order line with Tax data from [CustOrderLineTaxLines]
--  030610  GaJalk   Modified IID values of exchange_item.
--  030610  GaJalk   Modified the procedure Update___ to update the part ownership information on purchase order line part according to the changes done in the customer order line.
--                   Modified the procedure Unpack_Check_Update___.
--  030610  GeKalk   Modified exchange_item attribute of the customer_order_line_tab to not null.
--  030609  GeKalk   Added exchange_item attribute to the customer_order_line_tab and changed customer_order_line_rma_lov to exclude exchange item lines.
--  030529  GeKalk   Modified CUSTOMER_ORDER_LINE_MS and CUSTOMER_ORDER_LINE_MS2 views to get records where part_ownership = 'COMPANY OWNED'.
--  030528  PrTilk   Changed PROCEDURES Unpack_Check_Update__ and Unpack_Check_Insert__. Added validations for component parts.
--  030527  ChIwlk   Changed procedure Validate_Mro_Line__ to make it an implementation method Validate_Mro_Line___.
--  030527  AnJplk   Modified procedures Unpack_Check_Update__ and Unpack_Check_Insert__.
--  030527  PrTilk   Changed methods Unpack_Check_Update___, Unpack_Check_Insert___. Changed the check for package parts.
--  030527  GeKaLk   Rechanged Unpack_Check_Update___ to restrict changing of owner and ownership when the order is connected to a project.
--  030526  PrTilk   Changed method Unpack_Check_Update___. Added checks to stop the order line form being changed when
--  030526           the order line has been created from a purchase order line with component parts.
--  030526  GeKaLk   Changed Unpack_Check_Insert__ and Unpack_Check_Update___ to restrict changing of owner and ownership when the order is connected to a project.
--  030526  SaAblk   Removed methods Has_Options___, Has_Options, Clear_Options___ and Clear_Options.
--  030526           and removed all references to Obsolete LU CustomerOrderOption
--  030522  ChFolk   Modified Unpack_Check_Update___ to allow modifying demand_code, demand_order_ref1 and demand_order_ref1 at MRO line reservation.
--  030522  AnJplk   Modified view CUSTOMER_ORDER_LINE_RMA_LOV.
--  030522  PrTilk   Modified PROCEDURE Line_Is_Fully_Invoiced___.
--  030521  AnJplk   Modified procedures Unpack_Check_Update__ and Unpack_Check_Insert__.
--  030521  ChFolk   Removed PROCEDURE Connect_To_Wo and added it into ConnectCustomerOrder LU.
--  030520  PrTilk   Modified VIEW DOP_CUSTOMER_ORDER_LINE_LOV.
--  030520  ChFolk   Modified procedure Connect_To_Wo.
--  030519  PrTilk   Added a new PROCEDURE Get_Owner_For_Part_Ownership.
--  030519  ChFolk   Added PROCEDURE Connect_To_Wo.
--  030515  CaRase   Bug 37372, Reverse corrections made for bug 37003.
--  030513  PrTilk   Modified methods Check_Before_Update___, Check_Before_Insert___.
--  030513  ChJalk   Bug 37302, Modified Procedure Unpack_Check_Update__ and Unpack_Check_Insert__ to check whether the field 'SHIP_ADDR_NO' is not null.
--  030513  MiKulk   Bug 37083, Modified the view CUSTOMER_ORDER_lINE_ADDRESS.
--  030513  ChJalk   Bug 37092, Modified Procedure Line_Is_Fully_Delivered___ to handle Package part lines.
--  030512  ChIwlk   Added procedure Validate_Mro_Line__ to check the conditions for order lines with
--  030512           acqusition type MRO.
--  030512  MiKulk   Bug 37127, Modified a condition in procedure Finite_State_Machine___
--  030512           for the state transition from 'Released' with the event 'SetQtyShipped'.
--  030509  SudWlk   Modified method Check_Before_Update___ to check if the ownership is changed for manually pegged lines.
--  030508  PrTilk   Modified methods Check_Before_Update___, Check_Before_Insert___, Prepare_Insert___.
--  030508  MiKulk   Bug 37083, Added the View CUSTOMER_ORDER_lINE_ADDRESS.
--  030508  MiKulk   Bug 37141, Removed the change done earlier under this bug id.
--  030508  JaBalk   Bug 37012, Update the qty_invoiced of component lines when stage billing is recalculated.
--  030507  PrTilk   Added 2 new columns part_ownership, owning_customer_no.
--  030507  ThJalk   Bug 37003, Modified the procedure Unpack_Check_Insert___ to update BASE_SALE_UNIT_PRICE for unsaved CO line for a configured part.
--  030506  ChFolk   Call ID 96789. Modified the inconsistent error messages.
--  030505  MiKulk   Bug 37141, Modified the Procedure New, by adding more conditions to fetch all the updated field values to the new_attr_.
--  030502  JaJaLk   Modified the Validation of the FEE_CODE in Unpack_Check_Update___.
--  030502  ChJalk   Bug 37092, Modified Procedure Line_Is_Fully_Delivered___.
--  030428  PuIllk   Bug 36879, Modified info messages of PREL_DELNOTE1 in method Modify_Ordr_Defaults__
--                              and PREL_DELNOTE_CREATE1 in method  Unpack_Check_Update___.
--  030422  JaJaLk   Call 96172 Modified the call to Cust_Order_Line_Tax_Lines_API.Modify_Fee_Code__.
--  030421  SaNalk   Call 95441 Added 'additional_discount' to sale_unit_price calculation in CUSTOMER_ORDER_LINE_RMA_LOV.
--  030421  SaNalk   Call 95454 Added 'additional_discount' to the calculations in FUNCTION Get_Total_Discount.
--  030410  ChFolk   Modified procedure Update___ to modify add/remove tax lines connection to a charge lines according to the change of pay tax of the customer order line.
--  030409  GeKaLk   Call 96038, Added checks in Check_Before_Update___ when changing condition code and planned due date.
--  030408  SaRalk   Bug 36408, Modified procedure Update___.
--  030403  DayJLk   Call 95668, Added checks in Check_Before_Update___ and Unpack_Check_Insert___ of PKG3 to
--  030403           prevent Condtion codes from being entered to Package Parts.
--  030403  JaJaLk   Modified the calling condition to Add_Tax_Lines.
--  030401  GeKaLk   Removed checks when changing the revised_qty_due from Unpack_Check_Update___ and.
--  030401           added warnings to Check_Before_Update___ if revised_qty_due, planned_due_date and conditio_code changed.
--  030401  GeKaLk   Modified Unpack_Check_Update___ add checks when changing the revised_qty_due.
--  030401  ErSolk   Bug 36301, Added function Is_Line_Close_Allowed__
--  030401  DhAalk   Bug 36392, Modified the procedure Check_Before_Update___.
--  030401  ThPalk   Bug 36635, Removed changes done under bug 36343.
--  030331  Samnlk   Bug 34801, Added a new function Get_Next_Rel_No.
--  030328  JaJaLk   Modified the Validate_Fee_Code to handle the tax regime.
--  030328  SaRalk   Bug 35939, Modified function Get_Delivery_Terms_Desc in order to correct an existing problem caused by bug correction 30257.
--  030328  ThPalk   Bug 36231, Removed the change done earlier under this bug id.
--  030327  ChFolk   Modified procedure Update___ to add/remove tax lines connected to a charge lines according to the change of pay tax of the customer order line.
--  030327  JaJaLk   Modified the Unpack_Check_Update to handle the pay tax.
--  030326  DhAalk   Bug 36392, Modified the procedure Check_Before_Update___.
--  030325  PrTilk   Modified procedure Update___. Changed the calculation of the qty_short.
--  030324  ChFolk   Modified procedure Update___ to modify tax lines connected to charge lines according to the change of addr_flag and ship_addr_no of the order lines connected to charge lines.
--  030324  JaJaLk   Modified the procedure Get_Total_Tax_Amount to do the calculation only from the CUST_ORDER_LINE_TAX_LINES_TAB
--                   since the CUST_ORDER_LINE_TAX_LINES_TAB contains all the tax codes relevent to a orderline.
--  030321  JaJaLk   Modified the db values of Tax_Regime since it has been changed.
--  030321  JaJaLk   Added the method Modify_Fee_Code  to call the tax line modify to syncronize the tax codes.
--  030321  LoPrlk   Bug 36138, Additional parameters were added to default_attr_ in Get_Default_Part_Attributes___.
--  030321           Get_Line_Defaults___ was modified to work with these parameters.
--  030320  MiKulk   Bug 36245, Modified the procedure Unpack_Check_Update___, to trigger the event Delivery_Date_Or_Qty_Changed correctly.
--  030320  MiKulk   Bug 35434, Modified the earlier conditions added in procedure Finite_State_Machine___
--  030320           for the state transition from 'Released' with the event 'SetQtyShipped'.
--  030319  JaBalk   Bug 36343, Added DEMAND_NOT_ALLOW error message in Unpack_Check_Update___ when increasing the
--  030319           buy_qty_due,desired_qty if inventory part status is not active
--  030314  ThPalk   Bug 36231, Modified function Get_Delivery_Terms_Desc in order to correct an existing problem caused by bug correction 30257.
--  030312  JaJaLk   Added the method Validate_Fee_Code___ to validate the fee code with respect to the tax regime
--                   of the customer and the company.
--  030220  GaJalk   Bug 35434, Modified the procedure Finite_State_Machine___.
--  030217  DayJlk   Bug 35703, Added variables contract_, wanted_delivery_date_ and price_effectivity_date_ to check and update
--  030217           PRICE_EFFECTIVITY_DATE with the appropriate value in procedure NEW.
--  030213  PrJalk   Merged TakeOff changes
--  020906  JoAnSe   Replaced calls to Inventory_Part_API.Get_Inventory_Value_By_method with
--                   Inventory_Part_Unit_Cost_API.Get_Invent_Value_By_Condition
--                   Added call in Init_Before_Check_Insert___ and Unpack_Check_Update___
--                   to retrieve cost when condition code is specified/changed.
--  020830  Nabeus   Corrected to change condition code after Order is in state
--                   Planned and Released Call 88384.
--  020829  Chamlk   Call Id 88335 - Since the Maintenance_Object_API.Get_Objstate has been made obsolete, Maintenance_Object_API.Get_Operational_Status_Db
--                   was called in methods Check_Before_Insert___ and Check_Before_Update___.
--  020827  Nabeus   Call 88214 - after setting default condition code send it in attr, added
--                   code in Get_Line_Default___ method.
--  020823  Nabeus   Call 88044 - moved the logic from UCU to Check_Before_Update___ method and
--                   raised a error for updating Condition code of released orders.
--  020716  NabeUs   Added additional validation in UPI and UPU for condition_code.
--  020711  NabeUs   Changed Unpack_Check_Insert___ and Unpack_Check_Update___ to validate
--                   part is condition code enabled or not.
--  020628  MaEelk   Changed comments of CONDITION_CODE in all views that uses the Condition_CODE.
--  020613  Maeelk   Added new public attribute CONDITION_CODE to the LU.
--  -------------------------TSO Merge---------------------------------------------
--  021216  Asawlk   Merged bug fixes in 2002-3 SP3
--  021213  SaNalk   Added the view comment for ctp_planned_db.
--  021212  SaNalk   Reversed a part of the previous correction used to handle Stage Billing flow in procedure Update___.
--  021210  SaNalk   Modified the cursor in procedure Modify_Additional_Discount__.
--  021210  ChJalk   Bug 34472, Modified method Get_Sale_Price_Total___ in CUSTOMER_ORDER_LINE2_API.
--  021209  JaBalk   Bug 34420, Called the Get_Total_Invoiced_Percentage function inside the Update___ procedure to calculate the qty_invoiced.
--  021205  SaNalk   Added the public function Get_Additional_Discount.Modified function Get_Sale_Price_Total___.
--  021204  SaNalk   Added Additional Discount to view customer_order_line.Added Coding to Handle Additional_Discount
--                   in proc: Insert___, Update_Line___, Unpack_Check_Update___ and Unpack_Check_Insert___.
--                   Removed the function Get_Additional_Discount.Added the procedure Modify_Additional_Discount__.
--  021204  SaNalk   Modified the handling of Stage Billing flow in procedure Update___.
--  021203  SaNalk   Modified function Get_Sale_Price_Total___ for additional discount.
--  021129  SaNalk   Changed the function Get_Total_Tax_Amount, to include additional discount.
--  021121  ChJalk   Bug 28943, Added Get_Interim_order_No method.
--  021120  SaNalk   Changed the function Get_Base_Sale_Price_Total___, to include additional discount in calculations.
--  021120  SaRalk   Bug 34178, Modified the procedure Check_Before_Update___.
--  021119  GaJalk   Bug 33384, Modified the procedure Unpack_Check_Update___.
--  021118  JSAnse   Bug 33435, modified Init_Before_Check_Insert___ further so it handle order quotations.
--  021118  arkrpl   Bug 33485, modified Unpack_Check_Update with condition for supply_code 'PD'
--  021115  SaNalk   Removed the function Get_Total_Order_Discount.Modified the procedure Check_Line_Total_Discount_Pct.
--  021113  Susalk   Bug 33451, Modified Change_Package_Structure___ to update the price_U/M,sales_U/M and the price_conv_factor.
--  021113  SaRalk   Bug 32842, Modified procedure Update___.
--  021112  arkrpl   Bug 33485, modified Calculate_Order_Line_Dates__
--  021112  Samnlk   Bug 33231, Modified Unpack_Check_Update___ restrict the display of the WRONGSUPPLY message,when header status was planned. Also changed that in Check_Before_Update___.
--  021111  JSAnse   Bug 33435, Modified Init_Before_Check_Insert___ so that ship_via_code, delivery_terms and delivery_leadtime get the right value
--                   when using agreement. Modified Unpack_Check_Insert___ so an error message accur when no leadtime is specified.
--  021111  GaJalk   Bug 33384, Removed an information message in the procedure Calculate_Order_Line_Dates___.
--  021111  SaRalk   Bug 32842, Modified procedures Insert___, Insert_Package___, Update___, Change_Package_Structure___ and Check_Before_Update___.
--  021107  SaNalk   Added the procedure Check_Line_Total_Discount_Pct.
--  021106  MKrase   Bug 33893, Modified views CUSTOMER_ORDER_LINE_DEMAND, CUSTOMER_ORDER_LINE_DEMAND_OE
--                   CUSTOMER_ORDER_LINE_EXT, CUSTOMER_ORDER_LINE_SIM, CUSTOMER_ORDER_LINE_MS and
--                   CUSTOMER_ORDER_LINE_MS2
--  021106  DhAalk   Bug 33000, Removed the table join and included more states to be checked inside the where condition in Check_Order_Line_For_Planning.
--  021105  GaJalk   Bug 33384, Modified the procedures Calculate_Order_Line_Dates___ and Unpack_Check_Update___. Removed an assignment for earliest_delivery_date_ in Calculate_Order_Line_Dates___.
--  021031  SaNalk   Added the function Get_Total_Order_Discount.
--  021029  IsWilk   Bug 33839, Modified the cursor get_demand in the FUNCTION Get_Qty_Demand___.
--  021029  SaRalk   Bug 33002, Modified procedure Insert_Package___.
--  021028  SaRalk   Bug 32842, Modified procedures Check_Before_Update___ and Unpack_Check_Update___.
--  021025  ViPalk   Bug 33670, Modified procedure Check_Before_Update___.
--  021024  ChBalk   Added sub-procedure Check_Qty_From_Repair_Order in unpack_check_update(PKG3),
--  021022  Nabeus   Corrected Check_Before_Update___ to allow change of condition code if Interim
--                   order is yet to be created. If COL is released and IO is created then CC is not
--                   allowed to change, call 89536.
--  021021  arkrpl   Bug 33485, modified Calculate_Order_Line_Dates___
--  021018  MKrase   Bug 30258, Modified Update___, Post_Insert_Actions___ and Change_Package_Structure___.
--  021017  SaRalk   Bug 32842, Modified procedure Unpack_Check_Update___.
--  021016  JeLise   Bug 33505, Removed check on header_rowstate_ in Post_Insert_Actions___.
--  021014  RoAnse   Bug 33335, Removed call to Customer_Address_Leadtime_API.Exist in Calculate_Order_Line_Dates___,
--  021014           Unpack_Check_Insert___ and Unpack_Check_Update___. Added info message NOLEADTIME2 in
--  021014           Unpack_Check_Insert___ and Unpack_Check_Update___.
--  021010  SaRalk   Bug 32842, Rolled back the changes of bug 32842.
--  020925  DhAalk   Bug 33000, Modified the where condition by adding a query to join the table CUSTOMER_ORDER_TAB in Check_Order_Line_For_Planning.
--  020923  SaRalk   Bug 33002, Modified procedure Check_Before_Insert___.
--                   which relating to the external service order validation.
--  020919  JoAnSe   Merged the IceAge bugg corrections below onto the AD 2002-3 track.
--  020918  MKrase   Bug 31062, Added function Get_Vendor_Contract__. Added calls to Get_Vendor_Contract__
--                   in Unpack_Check_Update___, Unpack_Check_Insert___ and Calculate_Order_Line_Dates___.
--  020917  MKrase   Bug 31059, removed 'IPD' in check for newrec_.supply_code when adding leadtime and
--                   backed out of some changes made in correction for bug 29508 in Calculate_Order_Line_Dates___.
--                   Added call to Add_Info___ in procedure Post_Insert_Actions___.
--  020916  SaRalk   Bug 32842, Modified the PROCEDURE Unpack_Check_Update___.
--  020903  NaMolk   Bug 31053, Modified the procedure Update___ in order to update invoiced quantity with roundings.
--  020831  GaJalk   Bug 29409, Modified procedures Post_Insert_Actions___ and Update___.
--  020829  ErFise   Bug 29508, Changed the handling of order lines with supply_code
--                   IPD in methods Post_Insert_Actions___,
--                   Calculate_Order_Line_Dates___, Calculate_Planned_Due_Date___,
--                   Update___ and Unpack_Check_Update___.
--  020829  NaMolk   Bug 31053, Modified the procedure Update___ in order to update invoiced quantity correctly.
--  020828  KiSalk   Bug 29380, In Insert__, stopped setting of price_conv_factor to value from sales part when demand_code is 'CQ'
--  020826  ViPalk   Bug 31807, Modified Check_Before_Update___.
--  020821  MaGu     Bug 30098. Added fetching of default price and discount if buy_qty_due or price_list_no
--  020821           has been refreshed, i.e., updated with the same value as in the old record.
--  020821           Modified methods Check_Before_Update___, Unpack_Check_Update___ and Update___.
--  020816  ErFise   Bug 30257, made Ship_Via_Desc and Delivery_Terms_Desc public
--  020815  DhAalk   Bug 31830, Modified procedure Update___ to ignore the change done to qty_on_order when order status is "CreditBlocked".
--  020813  UsRalk   Bug 29108, Modified procedure Insert___ to transfer Documment from quotation.
--  020812  RoAnse   Bug 31979, Returned correction for bug 31807.
--  020808  RoAnse   Bug 31977, Removed correction for bug 31807 in order to be able to make CPS2.
--  020806  ViPalk   Bug 31807, Added a check to compare Revised_qty_due against, (Qty Assigned + Qty Shipped) of
--  020806           package part components in Procedure Check_Before_Update___.
--  020801  ThJaLk   Bug 30098, Remove Corrections.
--  020611  MIGUUS   Bug 29932, Added validation of whether plan_ship_date is within used valendar date.
--  020606  ThJaLk   Bug 30098, Added Procedure Get_Discount_Amount.
--  020518  DIKUUS   Bug 29274. Added additional selection of IN clause Value 'PartiallDelivered'
--                   Also added qty_shipped for qty_to_peg definition and part of AND condtion
--                   to take care of propervalue display for partially delivered conditon
--  020515  ROALUS   Bug fix 29228, Insert_Package__ modified.
--  020510  CaStse   Bug fix 28422, Modified Finite_State_Machine___.
--  020508  IsWilk   Bug 29044, Modified the PROCEDURE Calculate_Order_Line_Dates___.
--  ---------------------------------- IceAge Merge End ------------------------------------
--  -------------------------------- AD 2002-3 Baseline ------------------------------------
--  020401  ViPalk   Bug 27514, Price_Unit_Meas was added to Update_Line___ procedure.
--  020328  JOHESE   Optimized view CUSTOMER_ORDER_LINE_SHORTAGE
--  020326  IsWilk   Bug Fix 27316, Corrected the index hint of the view CUSTOMER_ORDER_LINE_DEMAND_OE.
--  020313  JoAn     Moved call to Recalculate_Tax_Lines.
--  020313  Thajlk   Bug fix 28004 (Call 76748), Modified Unpack_Check_Insert___, Unpack_Check_Update___ to handle Cosign: stocks.
--  020308  JoAn     Code clenup for code merged for ID 10115 Sales Tax
--                   and ID 10220 Vertex Integration
--  020308  Samnlk   Bug fix 27006,Create a new function Shop_Ord_Req_Exist.
--  020226  KiSalk   Bug fix 27997 (Call 76747), Modifed Procedure Update__ to calculate discount also on change of buy_qty_due (Sales Quantity).
--  020221  Hecese   Bug fix 27732. Modified Unpack_Check_Update___ regarding how the WRONGSUPPLY message is displayed.
--                   Also changed that message and the WRONGSUPPLY2 message (found in Check_Before_Update___).
--  011026  MaGu     Bug fix 24889. Removed all corrections for bug fix 24899.
--                   is always set to the same discount as on package header.
--  011024  MaGu     Bug fix 24889. Removed corrections from methods Insert_Package___ and Change_Package_Structure___.
--  011024  IsWilk   Bug Fix 25477, Modified the WHERE clause in the view CUSTOMER_ORDER_LINE_RMA_LOV.
--  011018  DaZa     Bug fix 25545, made changes in methods Finite_State_Machine___ and Finite_State_Events__
--                   so state Released can handle event SetQtyShipdiff. So we now can deliver a package part
--                   containing only non-inventory parts.
--  011017  MaGu     Bug fix 24889. Modified methods Insert_Package___, Change_Package_Structure___
--                   and Post_Insert_Actions___ so that discounts are not saved on component lines.
--  011011  MaGu     Bug fix 24887. Modified calculation of sale_unit_price for component parts
--                   in methods Insert_Package___ and Change_Package_Structure___.
--  011010  ANLASE   Bug Fix 24493, Added method New_Cust_Sched for creating new order lines from Customer Schedule.
--  011005  IsWilk   Bug Fix 24798, Modified the PROCEDURE Check_Before_Update___.
--  011004  OsAllk   Bug Fix 25022, Added FUNCTION Is_Pre_Posting_Mandatory.
--  010925  MaGu     Bug fix 24593. Modidfied method Insert___ so that qty_to_ship is set even if
--                   order head status is Delivered or Invoiced.
--  010921  Memeus   Bug fix 23564, validate consignment delivery address based on CO line on
--                   method Check_Before_Insert___ and Check_Before_Update___.
--  010917  MaGu     Bug fix 24342. Modified info handling in method Modify_Order_Defaults__. Added
--                   info messge PREL_DELNOTE and a check on the attributes that are used in delivery note.
--  010914  DaZa     Bug Fix 19928, Added new global constant inst_MaintenanceObject_ and new checks for
--                   sm_object status in methods Check_Before_Insert___ and Check_Before_Update___.
--  010904  Samnlk   Bug Fix 23260, Added a new IF condition to Calculate_Order_Line_Dates___.
--  010821  Samnlk   Bug Fix 23260, Change the Calculate_Order_Line_Dates___ and Check_Before_Update___
--  010809  RoAnse   Bug fix 21638, Added check if interim_head_id_ is not null before sending
--                   error message INTORDEXISTS in procedure Update___.
--  010809  CaSt     Bug fix 23225, Update of package lines added when qty is changed in Change_Package_Structure___
--  010621  RoAnse   Bug fix 21638, Corrections to dynamic PL/SQL in procedure Update___.
--  010618  SaNalk   Bug Fix 22065, Added the conditions to handle non inventory sales parts in PROCEDURE Unpack_Check_Update___.
--  010618  PaLj     Bug Fix 22035 Correction Changed handling of customer_part_no attribute in
--                   Insert___ and Get_Line_Defaults___
--  010618  RoAnse   Bug fix 21638, Modified the procedure Update___, making it possible to change
--                   quantity on an orderline connected to an Interim order.
--  010615  GaJalk   Bug fix 21640, Modified the procedure Delete___.
--  010529  JSAnse   Bug Fix 21463, Modified the end-statement of procedure Check_Order_Line_For_Planning.
--  010525  PUILLK   BUG Fix 21670, Modify Procedure Update__ to update the row discount when the ordrow price is changing.
--  010522  IsWilk   Bug Fix 21791, Modified the PROCEDURE Change_Package_Structure___.
--  010522  RoAnse   Bug fix 21324, Modified PROCEDURE Modify_Order_Defaults__, only unchecking the default flag
--                   if linerec_ in objstate 'Delivered', 'Invoiced' or 'Cancelled'. Added variabel info_,
--                   getting value from PKG..current_info_ because no infomessage was sent to client.
--                   Also removed infomessage DELINFO_NOT_CHG.
--  010522  PaLj     Bug fix 22035, Changed function Get_Line_Defaults___, added CUSTOMER_PART_NO to attr_.
--                   Changed declaration of customer_part_no_
--  010413  JaBa     Bug Fix 20598,Added new global lu constants in pkg,pkg2,pkg3 to check logical unit installed.
--  010411  CaSt     Bug fix 21217. Order line address was not updated when ship_addr_no was changed in the header.
--  010409  CaSt     Bug fix 21046, Modified info message EXPECTED_LEADTIME to include earliest delivery date.
--  010403  RoAnse   Bug fix 19545, Added FUNCTION Check_Order_Line_For_Planning.
--  010301  IsAn     Bug fix 18710, Added public attribute price_unit_meas.
--  010226  RoAnse   Bug fix 20247, Changed definition of new_attr_ from 2000 to 32000 chars in Procedure New.
--  010226  JeAsse   Bug fix 19937, Added line to set newrec_.catalog_desc to the value of
--                   cross_rec_.catalog_desc to correct sales part description on package parts.
--  010222  MaGu     Bug fix 19177. Added public attribute intrastat_exempt.
--                   Added intrastat_exempt in methods Init_Before_Check_Insert___, Check_Before_Update___,
--                   Insert_Package___, Change_Package_Structure and Modify_Order_Defaults__.
--  010125  JoEd     Bug fix 19074. Changed message DISCCHG in Update___ - added round
--                   of the discount values.
--  010111  JoEd     Created package PKG3 and moved the Unpack_... and Check_Before_...
--                   methods to it because PKG and PKG2 were too large.
--  010105  JakH     Component lines of a package are not automatically added for lines created from quotation.
--  010104  JakH     Fetching part price for configured package components using normal price fetching.
--  001223  DaZa     Added nvl checks for sup_sm_object/sup_sm_contract in Check_Before_Update___
--  001222  JakH     Added call to change_package_structure___ in Update___ when cost is updated for a component.
--  001218  JoAn     Bug Id 18709 Added more checks before error message TOMUCHTORETURN
--                   in Update___
--  001218  MaGu     Modified method Update___ so that discount is recalculated if price_effectivity_date has changed.
--  001218  CaSt     Made sure that created_by_server_ has a value != NULL in Init_Before_Check_Insert___.
--  001214  JoEd     Added LOV view VIEW_PACKVER_LOV2.
--  001213  DaZa     Added status check for sup_sm_object/sup_sm_contract in Check_Before_Update___.
--  001213  JoEd     Added LOV view VIEW_PACKVER_LOV.
--  001212  MaGu     Added price effectivity date to attribute string that is sent to Get_Line_Defaults___
--                   in method Get_Default_Part_Attributes___.
--  001212  JoAn     Bug Id 18571 supply code 'SEO allowed for parts with so_flag = 'Y'
--                   or purchase_flag = 'Y', 'PD', 'I' or 'IPD'.
--                   Changed in Check_Before_Insert___ and Check_Before_Update___.
--  001212  CaRa     Set temporary variable dop_connection_ to zero in procedure Insert_Package___.
--  001211  DaZa     Added extra assignment of promised_delivery_date in method Update_Planning_Date__ when status is Planned.
--  001208  DaZa     Added default value for EARLIEST_START_DATE in Insert_Package___.
--  001201  JoAn     Added part_no as parameter to reference for configuration_id.
--  001130  JoEd     Changed fetch of catalog desc in Get_Line_Defaults___.
--                   Added check on created_by_server in Init_Before_Insert___
--                   to avoid overriding the delivery information if default_addr_flag = 'N'.
--  001128  MaGu     Added price effectivity_date in fetch of price list and price in Get_Line_Defaults.
--  001128  MaGu     Removed price_effectivity_date in Init_Before_Check_Insert___.
--  001127  MaGu     Added price_effectivity_date to check for valid price list in Check_Before_Insert___
--                   and Check_Before_Update___.
--  001123  JakH     Modified insert___ to update configured line price reference if it was created
--                   by the client.
--  001123  JoAn     Added check not to allow Consignemnt stock for configured parts.
--  001123  FBen     BugFix. Added another where statement, rowstate != 'cancelled' in Update_Package_Cost___ in order to
--                   get right amount credit to customer in RMA, when returning package part with cancelled lines.
--  001120  MaGu     Added convertion to price_source in method New.
--  001117  JakH     Corrected error on inserting of configurations in packages.
--  001117  JakH     Removed paramaeters calc_char_price_ and char_price_ from recalc_package_structure__
--  001117  MaGu     Removed call to Customer_Order_Pricing_API.Get_Order_Line_Price_Info in method Insert_Package__.
--  001117  FBen     Bug Fix. Added not null check in unpack_check_insert for Promised_Delivery_Date.
--  001114  MaGu     Modified methods Insert_Package___ and Get_Line_Defaults___, added price_source_id
--                   to calls to Customer_Order_Pricing_API.Get_Order_Line_Price_Info.
--  001110  JakH     Added call to care for actions related to changes of configuration_id in update___
--  001109  MaGu     Modified method Update___ so that discount is not recalculated for package component parts
--                   when qty per assembly is changed.
--  001108  FBen     Changed pricing method/default value for price effectivity date in Prepare_Insert___.
--                   Removed NOT NULL checks for price_effectivity_date in Unpack_Check_Update___ and Unpack_Check_Insert___.
--  001106  MaGu     Added new column price_source_id.
--  001101  CaRa     In procedure Insert_Package___  fetch the supply code
--                   from the Inventory_Part_Planning instead of setting it into 'ND' (Not Decided).
--  001031  JoEd     Added NOCHECK flag on cust_warranty_id.
--  001031  FBen     Added Close_Financial_Project___ (Dynamic call to AccountingProjectUtil LU) and modified
--                   set_qty_invoiced so that a Job automatically will close right after the CustomerOrderLine
--                   status changes to 'Invoiced'.
--  001031  DaZa     Added check in Check_Before_Update___ for ctp_planned and valid
--                   supply_code. Added dynamic calls in Update___ to PromiseOrder. Added
--                   checks on ctp_planned before calling Reserve_Or_Make_Analysis__.
--  001030  DaZa     Made planned_ship_period public, added method Modify_Acquisition_Type__.
--  001030  JoEd     Changed warranty inheritance from quotation.
--  001029  JoEd     Added public attribute CUST_WARRANTY_ID.
--  001027  JAkH     Added Configuration Id to RMA lov
--  001027  DaZa     Added methods Update_Planning_Date__ and Lock_By_Keys___ in PKG2.
--  001027  FBen     Added Procedure Set_Job_Pre_Posting___ and PROCEDURE Set_Job_Id for the job-costing funtionality.
--  001027  FBen     Added function Get_Price_Effectivity_Date.
--  001026  FBen     Added Exist_Job_Id___ which is a dynamic Exist call to AccountingProject LU.
--  001026  FBen     Added new attribute 'JOB_ID' for the new functionality Job-Costing.
--  001025  FBen     Added functionality Pricing Method in Prepare_Insert___. The default value for
--                   price effectivity date on a new order line will be determined on Site level.
--  001025  DaZa     Added methods Set_Ctp_Planned, Clear_Ctp_Planned and Update_Planning_Date.
--  001025  JakH     Moved Feedback_From_Manufacturing to Reserve_Customer_Order_API. (Stub left for compatibility)
--  001020  JakH     Changed call to inventory_part_location to inventory_part_in_stock and added
--                   configuration_id in call to that and Customer_Order_Reservation
--  001019  JoAn     Double byt fix. Using substrb instead of substr in Add_Info___
--  001018  DaZa     Added check in Delete___ for ctp_planned.
--  001013  JoEd     Added fetch of customer_part_no in Insert___ if no
--                   customer_part_no has been entered.
--                   Also added calculation of customer_part_buy_qty in Check_Before_Update___.
--  001012  JoEd     Bug fix 17836. Set flag delivery_date_changed_ when updating
--                   delivery_leadtime and route_id in Unpack_Check_Update___.
--  001012  JoEd     Bug fix 16945. Moved call to Control_Ms_Mrp_Consumption__ in
--                   Delete___, so it's the last method called.
--  001011  JakH     Fixed missing condidtion for evaluating pkg parts in Check_Base_Part_Config___
--  001011  JakH     Corrected calculation in Get_Total_Discount
--  001006  JoEd     Bug fix 17538. Added error (TOMUCHTORETURN) if quantity returned
--                   is greater than quantity delivered in Update___.
--  001003  JakH     Added creation of in insert configured_line_price_id, adde return in attr
--  001006  DaZa     Added earliest_start_date and ctp_planned.
--  001005  JoEd     Changed method New, so that supply_code can be sent as client or db value.
--  001003  JakH     Added configured_line_price_id
--  001003  JakH     Changed calls for configuration pricing. Removed references to config_spec_usage.
--  000929  JakH     Modified checks for valid configurations. Added CUST_ORDER_LINE_CONFIG_USAGE view
--  000928  FBen     Added status 'cancelled' as Where statement in Line_Is_Fully_Invoiced___.
--  000928  JakH     Changed 'PRICE_EFFECTIVITY_DATE' setting.
--  000927  JakH     Added part_no in call to configuration check IS_VALID
--  000925  FBen     Added effectivity_date as parameter in Get_Line_Defaults___ and Insert_Package___.
--  000925  MaGu     Modified Insert_Default_Address___, added new address columns.
--  000920  JakH     Added configuration_id. Added it to supply demand views aswell.
--  000915  JakH     Changed Check_Supply_Code___ to allow configured services to be entered.
--  000913  JoAn     Moved code from Unpack_Check_Insert___ to new method Init_Before_Check_Insert___
--                   and moved code from to avoid problems with package size becoming to large.
--                   Also created new implementation methods in PKG2 for some methods.
--  000913  JoAn     Used installed_ConfigSpecUsage instead of calling Transaction_SYS.Logical_Unit_Is_Installed
--  000907  JakH     Added DEMAND_ORDER_REF4
--  000905  JakH     Has_Options and CLear_options cursor go directly on tables.
--  000905  JakH     Added parameter 'CO' to Reserve_Customer_Order_API.Control_Ms_Mrp_Consumption__
--  000906  JakH     Changed call to Inventory_Part_API.Get_Forecast_Consumption_Flag to _db-version
--  000906  JakH     Removed trails of CTO merge and references to state 'Quoted'.
--  000828  JoEd     Added public attributes dock_code, sub_dock_code, ref_id and
--                   location_no.
--  000807  FBEN     Added supply_code to the attribute string in procedure New
--                   and Get_Default_Part_Attributes___ in order to receive the
--                   correct acquisition type when creating CustomerOrderLine.
--  000719  LIN      Added cancel of configuration usage and interim order
--  000717  DEHA     Modified updating discounts on order line.
--  000717  BRO      Corrected calls to Modify_Usage_By_Key__.
--  000717  TFU      Merged from Chameleon
--  --------------   ---------------- 12.1 -------------------------------------
--  000620  JoAn     Bug Id 15894 Status of package line when only parts
--                   of a package have been delivered and invoiced.
--                   Corrected in Finite_State_machine___ handling for state 'Picked'.
--  000614  JoAn     CID 42871 Info was cleared when discoun record was created.
--                   Added call to Add_Info___ in Post_Insert_Actions___ before
--                   creating discount record and in Update___ before modification of discount record.
--  000609  JoEd     Added remove of unused serial number reservations in
--                   Feedback_From_Manufacturing___.
--  000608  DaZa     Fix on event call in Finite_State_Set___.
--  000607  JoEd     Bug fix 16315, Added custom reference to ship_via_code and
--                   delivery_terms. Added methods Check_Ship_Via_Code__ and
--                   Check_Delivery_Terms__.
--  000524  JoEd     Added check on earliest delivery date in Calculate_Order_Line_Dates___
--                   when aquisition Shop Order or Purchase Order.
--  000524  DaZa     Added event call in Finite_State_Set___, moved calls to
--                   Cust_Order_Event_Creation_API.Delivery_Date_Or_Qty_Changed and added
--                   a couple of parameters(supply_code and qty_on_order) to those calls.
--  000519  DaZa     Changed Exist_Sm_Object___ so it checks EquipmentObject instead of EquipmentFunctional.
--  000519  JoEd     Bug fix 16197. Added Get_Real_Ship_Date (made attribute public).
--  000519  MaGu     Added method Get_Total_Cost.
--  000519  JoAn     CID 40743 Added condition on order header to DOP_CUSTOMER_ORDER_LINE_LOV
--  000505  JoAn     Bug fix 15866, Added check on rowstate and update of qty_on_order in
--                   Feedback_From_Manufacturing___.
--  000426  PaLj     Changed check for installed logical units. A check is made when API is instantiatet.
--                   See beginning of api-file.
--  000419  PaLj     Corrected Init_Method Errors
--  000404  MaGu     Added method Modify_Wanted_Delivery_Date__.
--  000403  MaGu     Replaced all calls to Mpccom_System_Parameter_API for getting picking_leadtime with
--                   calls to Site_API.Get_Picking_Leadtime.
--  000327  JoAn     Replaced call to Inventory_Part_Location_API.Get_Total_Qty_Onhand
--                   with Get_Inventory_Qty_Onhand.
--  000321  JoAn     Reimplemented the Modify_Line___ method to fix problems with removed info
--                   on insert of new lines.
--  000320  JakH     Fixed lineending character problem.
--  000317  PaLj     Added handling of Null event in Finite_state_machine when state is 'Released'
--                   To solve trouble when check_state is called when using packages and staged_billing.
--  000309  JoEd     Changed update check for supply_code in Check_Before_Update___
--                   and Update___.
--  000307  DaZa     Added extra checks in Check_Before_Insert___ and Check_Before_Update___ on sup_sm_object/contract
--  000303  JoEd     Added VAT_DB assignment in Modify_Order_Defaults__ again ("rollback" from 000224).
--  000302  MaGu     Added check on order_discount in Unpack_Check_Insert___ and Unpack_Check_Update___.
--  000302  SaMi     Aquisition changed to Acquisition
--  000228  DaZa     Added extra gets on SUP_SM_CONTRACT in unpack methods to avoid exist problems.
--  000224  JoEd     Removed assign of VAT_DB ("Pay Tax" flag) from Modify_Order_Defaults__.
--  000224  MaGu     Added error message NOT_ACTIVE2 to Get_Line_Defaults___.
--  000221  DaZa     Added a check on SM_Connection and Create_SM_object_option in Check_Before_Update___.
--  000218  MaGu     Bug fix 31996. Changed message in Get_Line_Defaults___.
--  000215  JakH     Added Currency_Rate to public_rec
--  000215  PaLj     Bug fix 13548, Added check on newrec_.catalog_desc in Unpack_Check_Insert___.
--  000215  JoEd     Changed check on tax lines in Post_Insert_Actions___.
--  000215  PaLj     Bug fix 12915, Condition to check the shipped quantity is more than zero was
--                      added to Procedure'Finite_State_Machine___', state 'Picked'.
--  000214  JoEd     Changed fetch of "VAT usage" from Company. Added error message NOTAXINFO.
--  000209  JoAn     Added code to handle prices passed in the attribute string to Get_Default_Part_Attributes___
--  000209  PaLj     Added COST to IF-statement in beginning of Unpack_Check_Update___
--  000208  JoEd     Removed NULL assignment of fee_code when using sales tax.
--  000207  PaLj     Modifued call to Recalculate in Update___. Changed Modify_Discount__.
--  000207  MaGu     Bug fix 29111. Added check on supply_code to see if it has changed from 'ND' to 'IO'
--                   in Unpack_Check_Update___.
--  000202  JoEd     Added calls to create default tax lines when creating and updating
--                   an order line.
--  000201  DaZa     Decreased PKG size by moving the code for some private methods to PKG2.
--  000131  DaZa     Added columns sup_sm_contract, sup_sm_object and sm_connection.
--                   Added methods Get_Sup_Sm_Contract, Get_Sup_Sm_Object, Get_Sm_Connection,
--                   Modify_Sm_Connection and Exist_Sm_Object___.
--  000127  JoAn     Changes in Info handling. Info messages for components always cleared.
--  000127  MaGu     Modified Insert_Package___. Removed call to New__ and added calls to
--                   Unpack_Check_Insert___ and Insert___ instead.
--  000126  PaLj     Modified Post_Insert_Actions and Update___
--  000125  MaGu     Modified Insert_Package___. Added check for replaced component parts.
--  000124  PaLj     Added newrec_.staged_billing := 'NOT STAGED BILLING' in unpack_check_insert
--  000121  MaGu     Added public attribute original_part_no.
--  000119  JakH     Added fee_code to RMA LOV view.
--  000119  JoEd     Added public attribute VAT.
--  000119  MaGu     Changed procedures Get_Line_Defaults__ and Get_Line_Defaults___.
--                   Changed catalog_no_ to IN OUT parameter.
--  000117  JoEd     Bug fix 12975. Added CREATED_BY_SERVER to attr_ in Unpack_Check_Insert___
--                   to use in Insert___for mandatory pre accounting code parts.
--  000117  MaGu     Added check for replacement_part_no in Get_Line_Defaults___.
--  000113  JoEd     Bug fix 12805. Added nvl check on price list no in Check_Before_Update__
--                   before calling Cust_Order_Line_Discount_API.Check_Manual_Rows.
--  000113  MaGu     Added new parameter info_ to Get_Line_Defaults__.
--  000112  PaLj     Changed Finite State Machine to support Staged Billing
--  991215  PaLj     Changed methods Insert_Package___ and Change_Package_Structure___
--  991214  PaLj     Added procedure Modify_Staged_Billing.
--  991206  PaLj     Added Attribute Staged_Billing. Added method Get_Staged_Billing.
--  --------------   ---------------- 12.0 -------------------------------------
--  991111  JakH     Rearranged VIEW_RMA_LOV and made it joined
--  991110  JakH     Added Customer_Po_No and Poss_Qty_To_Return and rearranged the VIEW_RMA_LOV
--  991109  sami     CID 27453 catalog_type != 'PKG' added to VIEW_RMA_LOV's where Statement
--  991109  JoEd     Changed validation of purchase part no.
--  991109  sami     CID 27453 VIEW_RMA_LOV titles are changed,(ex: rel no->del no)
--                   charged_item = 'CHARGED ITEM' added to VIEW_RMA_LOV's where Statement
--  991105  JoAn     CID 27335 Status for invoiced lines not always correct.
--                   Changed Line_Is_Fully_Invoiced___, used trunc instead of round.
--  991104  JoAn     CID 27110 Added code in Delete___ to update MS/MRP forecast.
--  991101  JoEd     Changed check on deleting DOP when removing an order line.
--  991101  DaZa     Changed LOV VIEW_CHARGE_LOV, added check on rowstate.
--  991029  PaLj     CID 26126 Copied the Pre_Posting_Id from Package_head to components in Insert____
--  991027  JoAn     Bug Id 12304 Added new method Calculate_Order_ Line_Dates___
--                   called on Insert and Update. Removed other code for date
--                   calculations in Unpack_Check_Update___, Check_Before_Update and
--                   Unpack_Check_Insert___. Also added Calculate_Planned_Due_Date___
--                   and Calculate_Planned_Ship_Date___.
--  991027  JoAn     Moved code from Insert___ to new method Post_Insert_Actions__ in PKG2
--                   to avoid problems with package size.
--  991026  DaZa     Changed LOV VIEW_CHARGE_LOV added where statement and removed line_item_no from view.
--  991025  JoEd     Changed assignment of qty_to_ship when changing supply_code.
--  991022  JakH     Altered RMA LOV
--  991022  Sami     CID 24195:purchase_part_no added in insert_package and items in a packages get the value
--  991021  JoAn     CID 24123: Allowed delete of 'ND' order lines.
--                   Moved the delete checks from Delete___ to Check_Delete___,
--                   no deletes allowed for released orders.
--  991020  JoAn     CID 24413: Allowing update of QTY_TO_SHIP for invoiced lines.
--                   CID 24450: New lines with acquisition 'Not Decided' not allowed on relesed orders.
--                   supplier connected to given purchase part.
--  991018  JoAn     CID 23352 Initializing desired_qty for package components in
--                   Insert_Package___ and Change_Package_Structure___.
--                   Added Get_Desired_Qty.
--  991018  DaZa     Change in LOV VIEW_CHARGE_LOV so line_item_no is not visable any more.
--  991011  JakH     Bug fix 11053, To much reserved to customer order row from Manufacturing.
--                   Qty_assigned_ in procedure Feedback_From_Manufacturing___ modified.
--  991008  JOHW     Added call to Cust_Order_Line_Discount_API.Calculate_Discount__
--                   when changing sale_unit_price to update discounts.
--  991007  JoEd     Replaced Utility_SYS.Get_User with Fnd_Session_API.Get_Fnd_User.
--  991007  JoEd     Call Id 21210: Corrected double-byte problems.
--  991007  JoEd     Made wanted_delivery_date public.
--  991007  JOHW     Added functionality to Multiple Discounts.
--  991006  JOHW     Corrected call to Modify_Default_Discount_Rec.
--  991004  JOHW     Added Add_Info when update in Cust_Order_Line_Discount.
--  991001  JOHW     Added call to Modify_Default_Discount_Rec inside update___,
--  990930  JOHW     Corrected the call to New_Default_Discount_Rec.
--  990928  sami     Code added in check before update to update supply_code to ND(not decided) supply_code is='NO' (for non inventory parts)'
--  990927  DaZa     Added new LOV VIEW_CHARGE_LOV.
--  990927  JOHW     Added new public method Modify_Discount.
--  990924  JoEd     Changed name of Get_Sum_Unshipped_... to Get_Backlog_Value_....
--                   Added Get_Backord_Value_Base_Curr__.
--                   Added fetch of purchase part when changing supply_code.
--  990923  JoEd     Added Get_Sum_Unshipped_Order_Curr__.
--  990922  JoEd     Added new attribute purchase_part_no.
--  990922  JoEd     Added insert check of package components.
--  990920  JOHW     Added call to Customer_Order_Pricing_API.Create_Default_Record.
--  990917  JoEd     Added info message when calling Modify_Order_Defaults___
--                   and the order line has already been picked.
--  990914  JoEd     Added address values back to client after insert.
--  990909  JakH     Added LOV for Return Material.
--  990908  JoEd     Changed Modify_Order_Defaults__. Added extra attribute update
--                   check in Unpack_Check_Update___.
--  990906  JoAn     Added new attribute desired_qty.
--  990830  JoEd     Added Get_Delivery_Leadtime and moved Update___ to PKG2.
--  990827  sami     Code added to handle ND(not decided) for acquisition
--  9908xx  JoEd     Added order row address handling.
--                   Decreased PKG size by moving some method impl. to PKG2.
--  --------------   ---------------- 11.1 -------------------------------------
--  990617  JakH     Wrong parameters to translate_constant around SOURCEID_1
--  990607  JoEd     Call id 19202: Changed qty_assigned to qty_on_order in VIEW_DOP_LOV.
--                   Call id 19947: Don't allow change of dop_connection when order header
--                   has been released.
--  990602  JoEd     Call id 19465: Changed comment on planned_ship_period.
--  990528  JakH     CID 18828 Added restriction when to promote package header lines
--                   to status invoiced in function Line_Is_Fully_Invoiced___ .
--  990527  JoEd     Removed commas from error messages to work with Localize.
--  990525  JICE     Unneccessary join removed from view CUSTOMER_ORDER_LINE_MS2.
--  990519  JICE     Additional performance changes for views CUSTOMER_ORDER_LINE_MS2
--                   and CUSTOMER_ORDER_LINE_DEMAND1.
--  990519  JoAn     Corrected call to Init_Method in Modify_Cost.
--  990517  JICE     Performance changes for views CUSTOMER_ORDER_LINE_MS2 and
--                   CUSTOMER_ORDER_LINE_DEMAND1
--  990517  JoAn     Bug Id 10455 planned delivery date for package with no components
--                   Corrected in Change_Package_Structure___.
--  990514  JoAn     Corrected date calculations for noninventory parts.
--  990514  JoAn     Removed join with inventory_part_tab in CUSTOMER_ORDER_LINE_MS2 view.
--  990510  RaKU     Replaced Inventory_Part_Cost_API.Get_Total_Cost with
--                   Inventory_Part_API.Get_Inventory_Value_By_Method.
--  990505  JoAn     Changed Get_Sum_xxx methods to return 0 if not data is found.
--  990505  JakH     The view CUSTOMER_ORDER_LINE_SHORTAGE joined with CUSTOMER_ORDER_TAB
--                   to filter out credit blocked orders.
--  990504  JoAn     Added code to make it possible to add new order lines to
--                   orders in state 'Delivered' or 'Invoiced' using the New method.
--  990429  JakH     Reversing CID 11871 from 990323
--  990428  RaKu     Added procedure Add_Info and replaced call with it.
--  990428  RaKu     Bug ID 7530. Improved performance for package creation/modification.
--  990428  RaKu     Y.Corrections.
--  990427  RaKu     Removed globals changed_structure_price_ and fixed_structure_.
--  990426  RaKu     Y.Several corrections.
--  990421  JoAn     Removed parameter category_internal in Validate_Vendor_No___
--                   Changed parameter supply_code_ to supply_code_db_ in Calculate_Planned_Due_Date__
--  990419  RaKu     Fixes with Get-method.
--  990419  JoAn     Corrected supply code check in Unpack_Check_Update___
--  990416  JoAn     Corrected Db/Client values returned from Get_Line_Defaults___
--                   Removed customer_no from Prepare_Insert__.
--  990414  RaKu     New templates. Removed a lot of old comments.
--  990406  JakH     Y.CID 10582 Removed use of Gen_Def_Key_value. use '*' where possible.
--  990330  RaKu     Call ID 10552. QTY_SHORT was not calculated correct.
--  990326  JoAn     CID 12693 Changed the message of history record created when
--                   a line has been delivered.
--  990324  JoAn     CID 14280 New order lines not allowed if Pre Posting on the
--                   order header is mandatory but not yet defined.
--  990323  JakH     CID 11871, applied bug fix from 10.4
--          SuWi     Bug fix 9433, Comment the call to Shortage_Demand_Api and Added a new If condition to check
--                   whether the state is picked or qty_picked > 0.
--  990322  JoAn     Added Get_Planned_Ship_Date.
--  990317  JoAn     Default value for consignment_stock_db set in Get_Line_Defaults___
--                   Ship address retrieved from order instead of customer.
--  990317  JoAn     Internal leadtimes not considered when calculating dates for
--                   order lines with supply_code 'PD' or 'IPD'
--  990316  JoAn     CID 10580 Connected orders not created if new lines are added
--                   to a credit blocked order. Connected orders will then be created
--                   when the credit block is released.
--  990315  JoAn     CID 10580 Changed initialization of qty_on_order.
--                   Set to 0 when the line is created. Assigned a value
--                   when PO or SO is created.
--  990303  JoAn     Changed the return value for the Part_Exist method.
--  990303  JoAn     CID 11085 Corrected calculation of planned_ship_date
--  990302  RaKu     Corrected hint-definitions.
--  990223  PaLj     Changed Calculate_Qty_To_Load to give sales qty.
--  990219  JoAn     Changed Line_Is_Fully_Invoiced___ to handle noncharged lines.
--  990218  JoAn     Call Id 8034 Assigned promised_delivery_date to
--                   planned_delivery_date after call to Reserve_Or_Make_Analysis in Insert___
--  990216  RaKu     Call id 7594. Line item no was wrong when entering line_no or rel_no
--                   for an package header.
--  990216  JoAn     CID 4220 Added contract in calls to Get_Route_Delivery_Date
--  990215  JakH     CID 4225 (5496), Added an additional condition to check the CO
--                   Header status when fetching CO Lines for VIEW_DEMAND_CUSTORD.
--                   (7682) Added controls for supply_code <> 'SEO' in demand view.
--  990211  JoEd     Changed the TARGETDATECHG message to contain time.
--  990209  JoAn     Reduced the number of packages in order to make the code more
--                   Work Bench friendly. All LU specific implementation methods
--                   have been placed in PKG2. PKG3 and PKG4 removed.
--  990209  JoAn     Added procedure Check_State called when decreasing buy qty
--                   on a partially delivered order line.
--  990208  PaLj     Bug Id 7780: Change in Change_Package_Structure/If do_planned.
--  990205  JoAn     Using new method Inventory_Part_Status_Par_API.Get_Demand_Flag_Db
--                   in Get_Line_Defaults___
--  990205  CAST     Call id: 7295. Problems with db values in public New method. Charged_item and
--                   Consignment_stock were always stored with default values even when non default
--                   values were sent via the attribute string.
--  990203  JoEd     Added public attribute planned_ship_period.
--                   Added mandatory check on planned_ship_date.
--  990202  JoEd     Call id 7956: Changed calculation of planned_ship_date.
--  990202  RaKu     Removed COMPANY from view and added CUSTOM-method Check_Statutory_Fee__.
--  990202  CAST     Removed incorrect conv_factor in Get_Sum_Invoiced_Order_Curr__
--                   and Get_Sum_Invoiced_Base_Curr__.
--  990129  RaKu     Added CUSTOMER_NO column. NOTE: This column is stored twice
--                   (on the order header and order lines) just to improve the
--                   performance in the order-flow.
--  990128  JICE     Added public cursor configuration_options for MS.
--  990127  JoEd     Added DOP to supply_code check in Calculate_Planned_Due_Date__.
--                   Added handling of time for wanted and planned delivery date.
--  990126  JICE     Added two views for CUSTOMER_ORDER_LINE_MS2 and CUSTOMER_ORDER_LINE_DEMAND1
--                   for configured options.
--  990126  JoEd     Replaced route_departure_date with planned_ship_date.
--  990125  PaLj     Added method Make_Service_Deliverable
--  990125  JakH     Added methods for Get_Warranty and Get_Base_Sale_Price
--  990120  JakH     Removed Get_Pkg_Structure_Defaults___ since its use is
--                   equally good done by Get_Line_Defaults___.
--  990119  JakH     Change_SM_obect_option's and warranty are now transferred
--                   upon creation of package structure lines
--  990118  PaLj     changed sysdate to Site_API.Get_Site_Date(contract)
--  990113  JakH     Added fields Create_Sm_Object_Option and Warranty and
--                   public access method for Get_Create_Sm_Object_Option.
--  990108  JoEd     Removed Add_To_Picklist and Add_To_Picklist___.
--  990104  JoEd     Added view DOP_CUSTOMER_ORDER_LINE_LOV.
--                   Added public attribute DOP_CONNECTION.
--  ------------------------- Old comments removed --------------------------
--  960403  JoEd  Created
-----------------------------------------------------------------------------

layer Core;

-------------------- PUBLIC DECLARATIONS ------------------------------------


-------------------- PRIVATE DECLARATIONS -----------------------------------
-- Replication, start
TYPE Purchase_Order_No_Rec IS RECORD (
   po_order_no  VARCHAR2(12),
   order_no     VARCHAR2(12),
   line_no      VARCHAR2(4),
   rel_no       VARCHAR2(4),
   line_item_no NUMBER,
   supply_code  VARCHAR2(3));
TYPE purchase_order_no_tab IS TABLE OF Purchase_Order_No_Rec INDEX BY BINARY_INTEGER;
@ApproveGlobalVariable
purchase_order_no_tab_ purchase_order_no_tab;
-- Replication, end

-------------------- LU SPECIFIC IMPLEMENTATION METHODS ---------------------

PROCEDURE Check_Tax_Calc_Struct_Ref___ (
   newrec_ IN OUT NOCOPY customer_order_line_tab%ROWTYPE )
IS
   company_    VARCHAR2(20);
BEGIN
   company_ := Site_API.Get_Company(newrec_.contract);
   Tax_Calc_Structure_API.Validate_Tax_Structure_State(company_, newrec_.tax_calc_structure_id);
END Check_Tax_Calc_Struct_Ref___;

@IgnoreUnitTest MethodOverride
@Override
PROCEDURE Unpack___ (
   newrec_   IN OUT customer_order_line_tab%ROWTYPE,
   indrec_   IN OUT Indicator_Rec,
   attr_     IN OUT VARCHAR2 )
IS
BEGIN
   IF (newrec_.rowstate IS NULL) THEN
      Pre_Unpack_Insert___(attr_, newrec_);
   ELSE
      Pre_Unpack_Update___(attr_, newrec_);
   END IF;
   --Add pre-processing code here
   super(newrec_, indrec_, attr_);
   --Add post-processing code here
END Unpack___;

PROCEDURE Check_Catalog_No_Ref___ (
   newrec_ IN OUT customer_order_line_tab%ROWTYPE )
IS
   usage_   VARCHAR2(20);
BEGIN
   IF (newrec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
      usage_ := Sales_Type_API.DB_RENTAL_ONLY;
   ELSE
      usage_ := Sales_Type_API.DB_SALES_ONLY;
   END IF;
   Sales_Part_API.Exist(newrec_.contract, newrec_.catalog_no, usage_);
END Check_Catalog_No_Ref___;


PROCEDURE Check_Ship_Addr_No_Ref___ (
   newrec_ IN OUT customer_order_line_tab%ROWTYPE )
IS
BEGIN
   IF (newrec_.ship_addr_no IS NOT NULL) THEN
      IF (newrec_.demand_code = 'IPD' AND newrec_.addr_flag = 'N') THEN
         Cust_Ord_Customer_Address_API.Exist(newrec_.deliver_to_customer_no, newrec_.ship_addr_no);
      END IF;
   END IF;
END Check_Ship_Addr_No_Ref___;


PROCEDURE Check_Cust_Warranty_Id_Ref___ (
   newrec_ IN OUT customer_order_line_tab%ROWTYPE )
IS
BEGIN
   IF ((newrec_.rowstate IS NULL) AND (NVL(newrec_.demand_code, ' ') != 'CQ')) THEN
      Error_SYS.Item_Insert(lu_name_, 'CUST_WARRANTY_ID');
   END IF;
   IF (newrec_.cust_warranty_id IS NOT NULL) THEN
      Cust_Warranty_API.Exist(newrec_.cust_warranty_id);
   END IF;
END Check_Cust_Warranty_Id_Ref___;

PROCEDURE Check_Configuration_Id_Ref___ (
   newrec_ IN OUT customer_order_line_tab%ROWTYPE )
IS
BEGIN
   $IF (Component_Cfgchr_SYS.INSTALLED) $THEN
      IF (newrec_.configuration_id != '*')THEN
         Configuration_Spec_API.Exist(NVL(newrec_.part_no, newrec_.catalog_no), newrec_.configuration_id);
      END IF;
   $ELSE
      NULL;            
   $END    
END Check_Configuration_Id_Ref___;

PROCEDURE Check_Delete_Exp_License___ (
   rec_  IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
   licensed_order_type_ VARCHAR2(25);
BEGIN
   licensed_order_type_ := Customer_Order_Line_API.Get_Expctr_License_Order_Type(rec_.demand_code, rec_.demand_order_ref1, rec_.demand_order_ref2, rec_.demand_order_ref3);
   Customer_Order_Flow_API.Check_Delete_Exp_License(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no, licensed_order_type_);
END Check_Delete_Exp_License___;

-- Update_Line___
--   Method that simply updates the LU table.
--   Used to avoid external loop when Change_Package_Structure___ is called.
PROCEDURE Update_Line___ (
   objid_  IN VARCHAR2,
   newrec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
BEGIN
   -- gelr:disc_price_rounded, added original_discount, original_add_discount, original_order_discount
   UPDATE customer_order_line_tab
   SET order_no = newrec_.order_no,
       line_no = newrec_.line_no,
       rel_no = newrec_.rel_no,
       line_item_no = newrec_.line_item_no,
       contract = newrec_.contract,
       catalog_no = newrec_.catalog_no,
       note_id = newrec_.note_id,
       order_code = newrec_.order_code,
       part_no = newrec_.part_no,
       pre_accounting_id = newrec_.pre_accounting_id,
       sales_unit_meas = newrec_.sales_unit_meas,
       base_sale_unit_price = newrec_.base_sale_unit_price,
       base_unit_price_incl_tax = newrec_.base_unit_price_incl_tax,
       buy_qty_due = newrec_.buy_qty_due,
       catalog_desc = newrec_.catalog_desc,
       catalog_type = newrec_.catalog_type,
       conv_factor = newrec_.conv_factor,
       cost = newrec_.cost,
       currency_rate = newrec_.currency_rate,
       date_entered = newrec_.date_entered,
       discount = newrec_.discount,
       line_total_qty = newrec_.line_total_qty,
       line_total_weight = newrec_.line_total_weight,
       note_text = newrec_.note_text,
       order_discount = newrec_.order_discount,
       planned_delivery_date = newrec_.planned_delivery_date,
       planned_due_date = newrec_.planned_due_date,
       supply_site_due_date = newrec_.supply_site_due_date,
       price_conv_factor = newrec_.price_conv_factor,
       promised_delivery_date = newrec_.promised_delivery_date,
       qty_assigned = newrec_.qty_assigned,
       qty_invoiced = newrec_.qty_invoiced,
       qty_on_order = newrec_.qty_on_order,
       qty_picked = newrec_.qty_picked,
       qty_returned = newrec_.qty_returned,
       qty_shipdiff = newrec_.qty_shipdiff,
       qty_shipped = newrec_.qty_shipped,
       qty_to_ship = newrec_.qty_to_ship,
       qty_short = newrec_.qty_short,
       real_ship_date = newrec_.real_ship_date,
       revised_qty_due = newrec_.revised_qty_due,
       sale_unit_price = newrec_.sale_unit_price,
       unit_price_incl_tax = newrec_.unit_price_incl_tax,
       supply_code = newrec_.supply_code,
       wanted_delivery_date = newrec_.wanted_delivery_date,
       delivery_type = newrec_.delivery_type,
       vendor_no = newrec_.vendor_no,
       tax_code = newrec_.tax_code,
       tax_class_id = newrec_.tax_class_id,
       customer_part_no = newrec_.customer_part_no,
       customer_part_conv_factor = newrec_.customer_part_conv_factor,
       customer_part_unit_meas = newrec_.customer_part_unit_meas,
       customer_part_buy_qty = newrec_.customer_part_buy_qty,
       planned_ship_date = newrec_.planned_ship_date,
       planned_ship_period = newrec_.planned_ship_period,
       customer_no = newrec_.customer_no,
       consignment_stock = newrec_.consignment_stock,
       close_tolerance = newrec_.close_tolerance,
       price_list_no = newrec_.price_list_no,
       charged_item = newrec_.charged_item,
       demand_order_ref1 = newrec_.demand_order_ref1,
       demand_order_ref2 = newrec_.demand_order_ref2,
       demand_order_ref3 = newrec_.demand_order_ref3,
       demand_order_ref4 = newrec_.demand_order_ref4,
       demand_code = newrec_.demand_code,
       dop_connection = newrec_.dop_connection,
       create_sm_object_option = newrec_.create_sm_object_option,
       default_addr_flag = newrec_.default_addr_flag,
       addr_flag = newrec_.addr_flag,
       ship_addr_no = newrec_.ship_addr_no,
       route_id = newrec_.route_id,
       forward_agent_id = newrec_.forward_agent_id,
       ship_via_code = newrec_.ship_via_code,
       delivery_terms = newrec_.delivery_terms,
       delivery_leadtime = newrec_.delivery_leadtime,
       district_code = newrec_.district_code,
       region_code = newrec_.region_code,
       desired_qty = newrec_.desired_qty,
       purchase_part_no = newrec_.purchase_part_no,
       staged_billing = newrec_.staged_billing,
       tax_liability = newrec_.tax_liability,
       original_part_no = original_part_no,
       equipment_object_seq = newrec_.equipment_object_seq,
       sup_sm_contract = newrec_.sup_sm_contract,
       sup_sm_object = newrec_.sup_sm_object,
       sm_connection = newrec_.sm_connection,
       part_price = newrec_.part_price,
       char_price = newrec_.char_price,
       calc_char_price = newrec_.calc_char_price,
       price_source = newrec_.price_source,
       price_freeze = newrec_.price_freeze,
       dock_code = newrec_.dock_code,
       sub_dock_code = newrec_.sub_dock_code,
       ref_id = newrec_.ref_id,
       location_no = newrec_.location_no,
       configuration_id = newrec_.configuration_id,
       price_effectivity_date = newrec_.price_effectivity_date,
       configured_line_price_id = newrec_.configured_line_price_id,
       latest_release_date = newrec_.latest_release_date,
       ctp_planned =newrec_.ctp_planned,
       job_id = newrec_.job_id,
       cust_warranty_id = newrec_.cust_warranty_id,
       price_source_id = newrec_.price_source_id,
       intrastat_exempt = newrec_.intrastat_exempt,
       price_unit_meas = newrec_.price_unit_meas,
       condition_code = newrec_.condition_code,
       additional_discount = newrec_.additional_discount,
       part_ownership = newrec_.part_ownership,
       owning_customer_no = newrec_.owning_customer_no,
       exchange_item = newrec_.exchange_item,
       supply_site_reserve_type = newrec_.supply_site_reserve_type,
       originating_rel_no = newrec_.originating_rel_no,
       originating_line_item_no = newrec_.originating_line_item_no,
       release_planning = newrec_.release_planning,
       supplier_ship_via_transit = newrec_.supplier_ship_via_transit,
       supplier_ship_via_transit_desc = newrec_.supplier_ship_via_transit_desc,
       supply_site = newrec_.supply_site,
       shipment_connected = newrec_.shipment_connected,
       self_billing = newrec_.self_billing,
       activity_seq = newrec_.activity_seq,
       project_id = newrec_.project_id,
       deliver_to_customer_no = newrec_.deliver_to_customer_no,
       contact = newrec_.contact,
       input_qty = newrec_.input_qty,
       input_unit_meas = newrec_.input_unit_meas,
       input_conv_factor = newrec_.input_conv_factor,
       input_variable_values = newrec_.input_variable_values,
       shipment_creation = newrec_.shipment_creation,
       manufacturing_department = newrec_.manufacturing_department,
       delivery_sequence = newrec_.delivery_sequence,
       cancel_reason = newrec_.cancel_reason,
       delivery_confirmed = newrec_.delivery_confirmed,
       customer_po_line_no = newrec_.customer_po_line_no,
       customer_po_rel_no = newrec_.customer_po_rel_no,
       qty_confirmeddiff = newrec_.qty_confirmeddiff,
       blocked_for_invoicing = newrec_.blocked_for_invoicing,
       provisional_price = newrec_.provisional_price,
       receiving_advice_type = newrec_.receiving_advice_type,
       first_actual_ship_date = newrec_.first_actual_ship_date,
       tax_id_no = newrec_.tax_id_no,
       tax_id_validated_date = newrec_.tax_id_validated_date,
       price_source_net_price = newrec_.price_source_net_price,
       target_date = newrec_.target_date,
       allocation_id = newrec_.allocation_id,
       del_terms_location = newrec_.del_terms_location,
       classification_part_no = newrec_.classification_part_no,
       classification_unit_meas = newrec_.classification_unit_meas,
       classification_standard = newrec_.classification_standard,
       rebate_builder = newrec_.rebate_builder,
       line_total_weight_gross = newrec_.line_total_weight_gross,
       freight_map_id = newrec_.freight_map_id,
       zone_id = newrec_.zone_id,
       freight_price_list_no = newrec_.freight_price_list_no,
       adjusted_weight_net = newrec_.adjusted_weight_net,
       adjusted_weight_gross = newrec_.adjusted_weight_gross,
       adjusted_volume = newrec_.adjusted_volume,
       freight_free = newrec_.freight_free,
       part_level = newrec_.part_level,
       part_level_id = newrec_.part_level_id,
       customer_level = newrec_.customer_level,
       customer_level_id = newrec_.customer_level_id,
       load_id = newrec_.load_id,
       customs_value = newrec_.customs_value,
       abnormal_demand = newrec_.abnormal_demand,
       cust_calendar_id = newrec_.cust_calendar_id,
       ext_transport_calendar_id = newrec_.ext_transport_calendar_id,
       rel_mtrl_planning = newrec_.rel_mtrl_planning,
       qty_per_assembly = newrec_.qty_per_assembly,
       new_comp_after_delivery = newrec_.new_comp_after_delivery,
       picking_leadtime = newrec_.picking_leadtime,
       inverted_conv_factor = newrec_.inverted_conv_factor,
       rental = newrec_.rental,
       end_customer_id = newrec_.end_customer_id,
       shipment_type        = newrec_.shipment_type,
       open_shipment_qty = newrec_.open_shipment_qty,
       packing_instruction_id = newrec_.packing_instruction_id,
       originating_co_lang_code = newrec_.originating_co_lang_code,
       cust_part_invert_conv_fact = newrec_.cust_part_invert_conv_fact,
       country_code = upper(newrec_.country_code),
       tax_liability_type = newrec_.tax_liability_type,
       free_of_charge_tax_basis = newrec_.free_of_charge_tax_basis,
       original_order_discount = newrec_.original_order_discount,
       original_discount = newrec_.original_discount,
       original_add_discount = newrec_.original_add_discount,   
       rowversion = newrec_.rowversion
   WHERE rowid = objid_;

END Update_Line___;

@IgnoreUnitTest NoOutParams
-- Check_Allow_Backorders___
--   Check allowance of backorders
PROCEDURE Check_Allow_Backorders___ (
   order_no_              IN VARCHAR2,
   line_no_               IN VARCHAR2,
   rel_no_                IN VARCHAR2,
   line_item_no_          IN NUMBER,
   planned_delivery_date_ IN DATE )
IS
   found_  NUMBER;
   CURSOR get_rec IS
      SELECT 1
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    planned_delivery_date != planned_delivery_date_
      AND    (line_no != line_no_ OR rel_no != rel_no_ OR line_item_no != line_item_no_);
BEGIN
   IF (CUSTOMER_ORDER_API.Get_Backorder_Option_Db(order_no_) = 'NO PARTIAL DELIVERIES ALLOWED') THEN
      OPEN get_rec;
      FETCH get_rec INTO found_;
      IF get_rec%FOUND THEN
         Client_SYS.Add_Info(lu_name_, 'SAME_DATE: The planned delivery dates should be the same when no backorders are allowed.');
      END IF;
      CLOSE get_rec;
   END IF;
END Check_Allow_Backorders___;


-- Modify_Line___
--   General method for the public modify procedures
PROCEDURE Modify_Line___ (
   attr_         IN OUT VARCHAR2,
   order_no_     IN     VARCHAR2,
   line_no_      IN     VARCHAR2,
   rel_no_       IN     VARCHAR2,
   line_item_no_ IN     NUMBER )
IS
   objid_               VARCHAR2(2000);
   objversion_          VARCHAR2(2000);
   oldrec_              CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   newrec_              CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   ptr_                 NUMBER;
   name_                VARCHAR2(30);
   value_               VARCHAR2(4000);
   info_counter_        NUMBER := 1;
   temp_info_           VARCHAR2(2000);
   current_info_        VARCHAR2(32000);
   insert_package_mode_ VARCHAR2(5);
   indrec_              Indicator_Rec;
BEGIN
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   oldrec_              := Lock_By_Id___(objid_, objversion_);
   newrec_              := oldrec_;
   insert_package_mode_ := 'FALSE';
   Client_SYS.Add_To_Attr('INSERT_PACKAGE_MODE_', insert_package_mode_, attr_);
   Unpack___(newrec_, indrec_, attr_);
   Check_Update___(oldrec_, newrec_, indrec_, attr_);
   Update___(objid_, oldrec_, newrec_, attr_, objversion_);
   current_info_        := App_Context_SYS.Find_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_');

   IF (current_info_ IS NOT NULL AND ((newrec_.configuration_id != '*' AND newrec_.latest_release_date IS NOT NULL) OR
      (newrec_.supply_code = 'DOP' AND newrec_.rowstate = 'Cancelled')))THEN
      -- the call came probably from CONFIGURED_LINE_PRICE_API.Update_Parent_Config_Id when the user
      -- created or changed a configuration and in this case we want to send the info_ message back to CONFIGURED_LINE_PRICE_API
      --
      -- With existing condition another condition added to send the info message back to Client_SYS.
      -- IF a DOP is tied to more than one Customer Order Line, and one of those COL is cancelled, with Replicate changed of Yes,
      -- an informational message is supposed to be raised. To raise the information above condition added.
      Client_SYS.Clear_Info;
      ptr_ := NULL;
      WHILE (Client_SYS.Get_Next_From_Attr(current_info_, ptr_, name_, value_)) LOOP
         IF (name_ = 'INFO') THEN
            temp_info_    := 'INFO'||info_counter_||': '||value_;
            info_counter_ := info_counter_ + 1;
            Client_SYS.Add_Info(lu_name_, temp_info_);
         END IF;
      END LOOP;
      current_info_ := NULL;
      App_Context_SYS.Set_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_',current_info_);
   -- ELSE
   -- The clear info code below should probably be moved to Customer_Order_API.Calendar_Changed
   -- Clear info value, since no use of that string here - and if updating via Calendar_Changed method
   -- in Customer_Order_API, it might "hit the roof" right away.
      --Client_SYS.Clear_Info;
   ELSE
      App_Context_SYS.Set_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_',current_info_);
   END IF;
END Modify_Line___;

PROCEDURE Modify_Connected_Order_Line___ (
   newrec_                    IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   attr_                      IN OUT VARCHAR2,
   oldrec_                    IN     CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   replicate_changes_         IN     VARCHAR2,
   header_rowstate_           IN     VARCHAR2,
   po_charged_comp_change_    IN     VARCHAR2,
   update_pegged_orders_      IN     VARCHAR2,
   change_request_            IN     VARCHAR2,
   changed_attrib_not_in_pol_ IN     VARCHAR2,
   server_data_change_        IN     NUMBER )
IS
   ipd_replication_  BOOLEAN:=FALSE;
   old_qty_on_order_ NUMBER;
   copy_addr_to_line_ VARCHAR2(5) := 'FALSE' ;
BEGIN
   copy_addr_to_line_ := nvl(Client_SYS.Get_Item_Value('COPY_ADDR_TO_LINE', attr_),'FALSE') ;
   
   IF(header_rowstate_ != 'Planned') THEN
      IF ((newrec_.supply_code IN ('PT', 'PD', 'IPT', 'IPD', 'SO'))) THEN

         IF (newrec_.supply_code = 'IPD' AND ((NVL(newrec_.ext_transport_calendar_id, Database_SYS.string_null_) != NVL(oldrec_.ext_transport_calendar_id, Database_SYS.string_null_)) OR
             (NVL(newrec_.district_code, Database_SYS.string_null_) != NVL(oldrec_.district_code, Database_SYS.string_null_)) OR
             (NVL(newrec_.contact, Database_SYS.string_null_) != NVL(oldrec_.contact, Database_SYS.string_null_)) OR
             (NVL(newrec_.route_id, Database_SYS.string_null_) != NVL(oldrec_.route_id, Database_SYS.string_null_)) OR
             (NVL(newrec_.originating_co_lang_code, Database_SYS.string_null_) != NVL(oldrec_.originating_co_lang_code, Database_SYS.string_null_)) OR
             (newrec_.picking_leadtime != oldrec_.picking_leadtime) OR (newrec_.delivery_leadtime != oldrec_.delivery_leadtime) OR
             (NVL(newrec_.cust_calendar_id, Database_SYS.string_null_) != NVL(oldrec_.cust_calendar_id, Database_SYS.string_null_)) OR
             (NVL(newrec_.packing_instruction_id, Database_SYS.string_null_) != NVL(oldrec_.packing_instruction_id, Database_SYS.string_null_)) OR
             (newrec_.delivery_terms != oldrec_.delivery_terms) OR (NVL(newrec_.region_code, Database_SYS.string_null_) != NVL(oldrec_.region_code, Database_SYS.string_null_)) OR
             (NVL(newrec_.del_terms_location, Database_SYS.string_null_) != NVL(oldrec_.del_terms_location, Database_SYS.string_null_)) OR
             ((oldrec_.addr_flag != newrec_.addr_flag) AND copy_addr_to_line_ = 'FALSE') OR 
             (copy_addr_to_line_ = 'TRUE' AND oldrec_.addr_flag = 'Y' AND newrec_.addr_flag = 'N'))) THEN
               ipd_replication_ := TRUE;
         END IF;

         IF ((newrec_.supply_code IN ('PD', 'IPD') AND 
             (Validate_SYS.Is_Changed(newrec_.ship_addr_no, oldrec_.ship_addr_no)         OR
              Validate_SYS.Is_Changed(newrec_.ship_via_code, oldrec_.ship_via_code)       OR 
              Validate_SYS.Is_Changed(newrec_.forward_agent_id, oldrec_.forward_agent_id) OR
              Validate_SYS.Is_Changed(newrec_.dock_code, oldrec_.dock_code)               OR 
              Validate_SYS.Is_Changed(newrec_.sub_dock_code, oldrec_.sub_dock_code)       OR
              Validate_SYS.Is_Changed(newrec_.location_no, oldrec_.location_no)           OR
              Validate_SYS.Is_Changed(newrec_.packing_instruction_id, oldrec_.packing_instruction_id))) OR 
             (ipd_replication_) OR 
             Validate_SYS.Is_Changed(newrec_.revised_qty_due, oldrec_.revised_qty_due)   OR
             Validate_SYS.Is_Changed(newrec_.planned_due_date, oldrec_.planned_due_date) OR
             (update_pegged_orders_ ='TRUE') OR  
             (newrec_.rental = Fnd_Boolean_API.DB_TRUE AND Is_Rental_Dates_Changed___(attr_, newrec_))) THEN
            IF (NVL(server_data_change_, 0) != 1) OR (po_charged_comp_change_ = 'TRUE') THEN
               IF ((replicate_changes_ = 'TRUE') OR
                   (newrec_.supply_code IN ('PT', 'PD', 'IPT', 'IPD') AND (newrec_.revised_qty_due < oldrec_.qty_on_order)) OR
                   (newrec_.supply_code = 'SO' AND (newrec_.revised_qty_due - newrec_.qty_assigned - newrec_.qty_shipped < oldrec_.qty_on_order))) THEN
                  
                  IF (newrec_.line_item_no <= 0) THEN
                     old_qty_on_order_ := newrec_.qty_on_order;
                  END IF;
                  IF (newrec_.qty_on_order > 0) THEN
                     Client_SYS.Set_Item_Value('CONTRACT',                  newrec_.contract,                  attr_);
                     Client_SYS.Set_Item_Value('PART_NO',                   newrec_.part_no,                   attr_);
                     Client_SYS.Set_Item_Value('SUPPLY_CODE',               newrec_.supply_code,               attr_);
                     Client_SYS.Set_Item_Value('REVISED_QTY_DUE',           newrec_.revised_qty_due,           attr_);
                     Client_SYS.Set_Item_Value('PLANNED_DELIVERY_DATE',     newrec_.planned_delivery_date,     attr_);
                     Client_SYS.Set_Item_Value('PLANNED_DUE_DATE',          newrec_.planned_due_date,          attr_);
                     Client_SYS.Set_Item_Value('CHANGE_REQUEST',            change_request_,                   attr_);
                     Client_SYS.Set_Item_Value('REPLICATE_CHANGES',         replicate_changes_,                attr_);
                     Client_SYS.Set_Item_Value('QTY_ASSIGNED',              newrec_.qty_assigned,              attr_);
                     Client_SYS.Set_Item_Value('QTY_SHIPPED',               newrec_.qty_shipped,               attr_);
                     Client_SYS.Set_Item_Value('SHIP_VIA_CODE',             newrec_.ship_via_code,             attr_);
                     Client_SYS.Set_Item_Value('FORWARD_AGENT_ID',          newrec_.forward_agent_id,          attr_);
                     Client_SYS.Set_Item_Value('DELIVERY_TERMS',            newrec_.delivery_terms,            attr_);
                     Client_SYS.Set_Item_Value('DEL_TERMS_LOCATION',        newrec_.del_terms_location,        attr_);
                     Client_SYS.Set_Item_Value('CHANGED_ATTRIB_NOT_IN_POL',  changed_attrib_not_in_pol_,        attr_);
                     Client_SYS.Set_Item_Value('EXT_TRANSPORT_CALENDAR_ID', newrec_.ext_transport_calendar_id, attr_);
                     Client_SYS.Set_Item_Value('ORIGINATING_FROM',          'ORDER',                           attr_);
                     Client_SYS.Set_Item_Value('ADDR_FLAG_DB',              newrec_.addr_flag,                 attr_);
                     Client_SYS.Set_Item_Value('SHIP_ADDR_NO',              newrec_.ship_addr_no,              attr_);
                     Client_SYS.Set_Item_Value('CUSTOMER_NO',               newrec_.deliver_to_customer_no,    attr_);
                     Client_SYS.Set_Item_Value('CO_HEADER_STATUS',          header_rowstate_,                  attr_);
                     Client_SYS.Set_Item_Value('DEFAULT_ADDR_FLAG',         newrec_.default_addr_flag,         attr_);
                     Client_SYS.Set_Item_Value('PACKING_INSTRUCTION_ID',    newrec_.packing_instruction_id,    attr_);

                     Connect_Customer_Order_API.Modify_Connected_Order_Line(newrec_.qty_on_order,
                                                                            attr_,
                                                                            newrec_.order_no,
                                                                            newrec_.line_no,
                                                                            newrec_.rel_no,
                                                                            newrec_.line_item_no);
                  END IF;
                  IF (newrec_.line_item_no <= 0) AND (old_qty_on_order_ != newrec_.qty_on_order) THEN
                     Modify_Qty_On_Order(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.qty_on_order);
                  END IF;
               END IF;
            END IF;
         END IF;
      END IF;
   END IF;
END Modify_Connected_Order_Line___;


-- Insert_Package___
--   Inserts a package part's components as order line components
PROCEDURE Insert_Package___ (
   pkg_planned_delivery_date_    IN OUT DATE,
   shipment_creation_            IN     VARCHAR2,
   pkg_contract_                 IN     VARCHAR2,
   pkg_catalog_no_               IN     VARCHAR2,
   pkg_order_no_                 IN     VARCHAR2,
   pkg_line_no_                  IN     VARCHAR2,
   pkg_rel_no_                   IN     VARCHAR2,
   pkg_order_code_               IN     VARCHAR2,
   pkg_tax_code_                 IN     VARCHAR2,
   pkg_tax_class_                IN     VARCHAR2,
   pkg_currency_rate_            IN     NUMBER,
   pkg_revised_qty_due_          IN     NUMBER,
   pkg_buy_qty_due_              IN     NUMBER,
   pkg_sale_unit_price_          IN     NUMBER,
   pkg_unit_price_incl_tax_      IN     NUMBER,
   pkg_base_sale_unit_price_     IN     NUMBER,
   pkg_base_unit_price_incl_tax_ IN     NUMBER,
   pkg_wanted_delivery_date_     IN     DATE,
   pkg_target_date_              IN     DATE,
   insert_package_mode_          IN     VARCHAR2 )
IS
   base_sale_unit_price_          NUMBER := 0;
   base_unit_price_incl_tax_      NUMBER := 0;
   sale_unit_price_               NUMBER := 0;
   unit_price_incl_tax_           NUMBER := 0;
   discount_                      NUMBER := 0;
   qty_on_order_                  NUMBER := 0;
   qty_assigned_                  NUMBER := 0;
   buy_qty_due_                   NUMBER := 0;
   desired_qty_                   NUMBER;
   revised_qty_due_               NUMBER := 0;
   cost_                          NUMBER := 0;
   pkg_cost_                      NUMBER := 0;
   dop_connection_                VARCHAR2(200) := NULL;
   supply_code_db_                VARCHAR2(3) := NULL;
   supply_code_                   VARCHAR2(200) := NULL;
   catalog_desc_                  CUSTOMER_ORDER_LINE_TAB.catalog_desc%TYPE;
   sales_part_desc_               CUSTOMER_ORDER_LINE_TAB.catalog_desc%TYPE;
   qty_to_ship_                   NUMBER := 0;
   template_attr_                 VARCHAR2(32000);
   attr_                          VARCHAR2(32000);
   objid_                         VARCHAR2(2000);
   objversion_                    VARCHAR2(2000);
   component_no_                  VARCHAR2(25);
   component_part_no_             VARCHAR2(25);
   original_part_no_              VARCHAR2(25);
   part_price_                    NUMBER := 0;
   price_source_                  VARCHAR2(200);
   price_source_id_               VARCHAR2(25);
   temp_base_sale_unit_price_     NUMBER;
   temp_base_unit_price_incl_tax_ NUMBER;
   temp_discount_                 NUMBER;
   temp_currency_rate_            NUMBER;
   header_rec_                    CUSTOMER_ORDER_API.Public_Rec;
   sales_part_rec_                SALES_PART_API.Public_Rec;
   pkg_header_rec_                CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   newrec_                        CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   part_price_is_set_             BOOLEAN;
   condition_code_                CUSTOMER_ORDER_LINE_TAB.condition_code%TYPE;
   pkg_deliv_conf_                VARCHAR2(20);
   deliv_conf_                    VARCHAR2(20);
   provisional_price_db_          VARCHAR2(20);
   net_price_fetched_             VARCHAR2(20);
   rebate_builder_db_             VARCHAR2(20);
   part_level_db_                 VARCHAR2(30);
   part_level_id_                 VARCHAR2(200);
   customer_level_db_             VARCHAR2(30);
   customer_level_id_             VARCHAR2(200);
   line_discount_amount_          NUMBER;
   customer_part_no_              CUSTOMER_ORDER_LINE_TAB.customer_part_no%TYPE;
   indrec_                        Indicator_Rec;
   tax_liability_type_db_         VARCHAR2(20);
   multiple_tax_                  VARCHAR2(20);

   CURSOR get_pkg_ingridients(contract_ VARCHAR2, parent_part_ VARCHAR2)
   IS
      SELECT catalog_no, line_item_no, qty_per_assembly
      FROM   SALES_PART_PACKAGE_PUB
      WHERE  contract = contract_
      AND    parent_part= parent_part_
      ORDER BY line_item_no;
BEGIN
   -- Fetch the total package cost for each component.
   pkg_cost_   := 0;
   header_rec_ := CUSTOMER_ORDER_API.Get(pkg_order_no_);

   FOR psrec_ IN get_pkg_ingridients(pkg_contract_, pkg_catalog_no_) LOOP
      component_part_no_ := psrec_.catalog_no;
      original_part_no_  := NULL;

      Handle_Replacement_Part___(component_part_no_,
                                 original_part_no_,
                                 pkg_contract_,
                                 FALSE );

      sales_part_rec_ := Sales_Part_API.Get(pkg_contract_, component_part_no_);

      --Check if part is active
      Check_Active_Part___(pkg_contract_, sales_part_rec_.part_no);
      revised_qty_due_ := pkg_buy_qty_due_ * psrec_.qty_per_assembly * sales_part_rec_.conv_factor / sales_part_rec_.inverted_conv_factor;
      IF (sales_part_rec_.part_no IS NULL) THEN
         cost_ := sales_part_rec_.cost;
      ELSE
         -- Retrive the default condition code if used for this part
         IF (Part_Catalog_API.Get_Condition_Code_Usage_Db(sales_part_rec_.part_no) = 'ALLOW_COND_CODE') THEN
            condition_code_ := Condition_Code_API.Get_Default_Condition_Code;
         ELSE
            condition_code_ := NULL;
         END IF;
         IF (revised_qty_due_ IS NOT NULL) THEN
            -- Retrive cost for the part (and condition code if applicable)
            cost_ := Sales_Cost_Util_API.Get_Cost_Incl_Sales_Overhead(pkg_contract_,
                                                                      sales_part_rec_.part_no,
                                                                      '*',
                                                                      condition_code_,
                                                                      revised_qty_due_,
                                                                      'CHARGED ITEM',
                                                                      Order_Supply_Type_API.Encode(Sales_Part_API.Get_Default_Supply_Code(pkg_contract_, psrec_.catalog_no)),
                                                                      header_rec_.customer_no,
                                                                      'COMPANY OWNED');
         END IF;
      END IF;
      pkg_cost_ := pkg_cost_ + cost_ * psrec_.qty_per_assembly * sales_part_rec_.conv_factor / sales_part_rec_.inverted_conv_factor;
   END LOOP;

   -- fetch package header to use with the components
   pkg_header_rec_ := Get_Object_By_Keys___(pkg_order_no_, pkg_line_no_, pkg_rel_no_, -1);

   -- Create a template that may be used for every component.
   Client_SYS.Clear_Attr(template_attr_);
   Client_SYS.Add_To_Attr('ORDER_NO', pkg_order_no_, template_attr_);
   Client_SYS.Add_To_Attr('LINE_NO', pkg_line_no_, template_attr_);
   Client_SYS.Add_To_Attr('REL_NO', pkg_rel_no_, template_attr_);
   Client_SYS.Add_To_Attr('CONTRACT', pkg_contract_, template_attr_);
   Client_SYS.Add_To_Attr('CURRENCY_RATE', pkg_currency_rate_, template_attr_);
   Client_SYS.Add_To_Attr('ORDER_CODE', pkg_order_code_, template_attr_);
   Client_SYS.Add_To_Attr('QTY_INVOICED', 0, template_attr_);
   Client_SYS.Add_To_Attr('QTY_RETURNED', 0, template_attr_);
   Client_SYS.Add_To_Attr('QTY_SHIPDIFF', 0, template_attr_);
   Client_SYS.Add_To_Attr('QTY_SHIPPED', 0, template_attr_);
   Client_SYS.Add_To_Attr('ORDER_DISCOUNT', 0, template_attr_);
   Client_SYS.Add_To_Attr('CONSIGNMENT_STOCK', Consignment_Stock_API.Decode('NO CONSIGNMENT STOCK'), template_attr_);
   Client_SYS.Add_To_Attr('CONSIGNMENT_STOCK_DB', 'NO CONSIGNMENT STOCK', template_attr_);
   Client_SYS.Add_To_Attr('CHARGED_ITEM', Charged_Item_API.Decode('CHARGED ITEM'), template_attr_);
   Client_SYS.Add_To_Attr('CHARGED_ITEM_DB', 'CHARGED ITEM', template_attr_);
   Client_SYS.Add_To_Attr('CATALOG_TYPE_DB', 'KOMP', template_attr_);
   Client_SYS.Add_To_Attr('TAX_CODE', pkg_tax_code_, template_attr_);
   Client_SYS.Add_To_Attr('TAX_CLASS_ID', pkg_tax_class_, template_attr_);
   Client_SYS.Add_To_Attr('ADDR_FLAG_DB', pkg_header_rec_.addr_flag, template_attr_);
   Client_SYS.Add_To_Attr('SHIP_ADDR_NO', pkg_header_rec_.ship_addr_no, template_attr_);
   Client_SYS.Add_To_Attr('CONTACT', pkg_header_rec_.contact, template_attr_);
   Client_SYS.Add_To_Attr('DELIVERY_TERMS', pkg_header_rec_.delivery_terms, template_attr_);
   Client_SYS.Add_To_Attr('DEL_TERMS_LOCATION', pkg_header_rec_.del_terms_location, template_attr_);
   Client_SYS.Add_To_Attr('DISTRICT_CODE', pkg_header_rec_.district_code, template_attr_);
   Client_SYS.Add_To_Attr('REGION_CODE', pkg_header_rec_.region_code, template_attr_);
   Client_SYS.Add_To_Attr('TAX_LIABILITY', pkg_header_rec_.tax_liability, template_attr_);
   Client_SYS.Add_To_Attr('STAGED_BILLING_DB',pkg_header_rec_.staged_billing, template_attr_);
   Client_SYS.Add_To_Attr('PRICE_FREEZE_DB', 'FROZEN', template_attr_);
   Client_SYS.Add_To_Attr('CONFIGURATION_ID', '*', template_attr_);
   Client_SYS.Add_To_Attr('INTRASTAT_EXEMPT_DB', pkg_header_rec_.intrastat_exempt, template_attr_);
   Client_SYS.Add_To_Attr('SUPPLY_SITE_RESERVE_TYPE_DB', pkg_header_rec_.supply_site_reserve_type, template_attr_);
   Client_SYS.Add_To_Attr('SUPPLY_SITE_RESERVE_TYPE', Supply_Site_Reserve_Type_API.Decode(pkg_header_rec_.supply_site_reserve_type), attr_);
   Client_SYS.Add_To_Attr('QTY_CONFIRMEDDIFF', 0, attr_);
   Client_SYS.Add_To_Attr('EQUIPMENT_OBJECT_SEQ', pkg_header_rec_.equipment_object_seq, template_attr_);
   Client_SYS.Add_To_Attr('SUP_SM_CONTRACT', pkg_header_rec_.sup_sm_contract, template_attr_);
   Client_SYS.Add_To_Attr('SUP_SM_OBJECT', pkg_header_rec_.sup_sm_object, template_attr_);
   Client_SYS.Add_To_Attr('TAX_ID_NO', pkg_header_rec_.tax_id_no, template_attr_);
   Client_SYS.Add_To_Attr('TAX_ID_VALIDATED_DATE', pkg_header_rec_.tax_id_validated_date, template_attr_);
   Client_SYS.Add_To_Attr('DELIVER_TO_CUSTOMER_NO', pkg_header_rec_.deliver_to_customer_no, template_attr_);
   Client_SYS.Add_To_Attr('DEMAND_CODE_DB',pkg_header_rec_.demand_code, template_attr_);
   Client_SYS.Add_To_Attr('COUNTRY_CODE',pkg_header_rec_.country_code, template_attr_);
   Client_SYS.Add_To_Attr('TAX_LIABILITY_TYPE_DB',pkg_header_rec_.tax_liability_type, template_attr_);
   
   -- Create record for each component.
   FOR psrec_ IN get_pkg_ingridients(pkg_contract_, pkg_catalog_no_) LOOP
      component_no_     := psrec_.catalog_no;
      original_part_no_ := NULL;
      dop_connection_   := NULL;

      Handle_Replacement_Part___(component_no_,
                                 original_part_no_,
                                 pkg_contract_,
                                 FALSE );

      sales_part_rec_    := Sales_Part_API.Get(pkg_contract_, component_no_);
      sales_part_desc_   := Sales_Part_API.Get_Catalog_Desc(pkg_contract_, component_no_, header_rec_.language_code);

      attr_              := template_attr_;
      part_price_is_set_ := FALSE;
      Client_SYS.Add_To_Attr('LINE_ITEM_NO', psrec_.line_item_no, attr_);
      Client_SYS.Add_To_Attr('CATALOG_NO', component_no_, attr_);
      Client_SYS.Add_To_Attr('CONV_FACTOR', sales_part_rec_.conv_factor, attr_);
      Client_SYS.Add_To_Attr('PRICE_CONV_FACTOR', sales_part_rec_.price_conv_factor, attr_);
      Client_SYS.Add_To_Attr('CLOSE_TOLERANCE', sales_part_rec_.close_tolerance, attr_);
      Client_SYS.Add_To_Attr('ORIGINAL_PART_NO', original_part_no_, attr_);
      Client_SYS.Add_To_Attr('INVERTED_CONV_FACTOR', sales_part_rec_.inverted_conv_factor, attr_);

      -- Fetch correct description.
      customer_part_no_ := Sales_Part_Cross_Reference_API.Get_Customer_Part_No(header_rec_.customer_no, header_rec_.contract, component_no_);
      catalog_desc_     := Sales_Part_Cross_Reference_API.Get_Catalog_Desc(header_rec_.customer_no ,pkg_contract_, customer_part_no_ );
      IF (catalog_desc_ IS NULL) THEN
         catalog_desc_:= Sales_Part_Language_Desc_API.Get_Catalog_Desc(pkg_contract_, component_no_, header_rec_.language_code);
         IF (catalog_desc_ IS NULL) THEN
            catalog_desc_ := sales_part_desc_;
         END IF;
      END IF;
      Client_SYS.Add_To_Attr('CATALOG_DESC', catalog_desc_, attr_);

      -- Fetch total_standard from PART_COST.
      condition_code_ := NULL;

      -- Set correct SUPPLY_CODE
      supply_code_     := Sales_Part_API.Get_Default_Supply_Code(pkg_contract_, component_no_);
      supply_code_db_  := Order_Supply_Type_API.Encode(supply_code_);
      Client_SYS.Add_To_Attr('SUPPLY_CODE_DB', supply_code_db_, attr_);
      revised_qty_due_ := pkg_buy_qty_due_ * psrec_.qty_per_assembly * sales_part_rec_.conv_factor / sales_part_rec_.inverted_conv_factor;

      IF (sales_part_rec_.part_no IS NULL) THEN
         cost_ := sales_part_rec_.cost;
      ELSE
         -- Retrive the default condition code if used for this part
         IF (Part_Catalog_API.Get_Condition_Code_Usage_Db(sales_part_rec_.part_no) = 'ALLOW_COND_CODE') THEN
            condition_code_ := Condition_Code_API.Get_Default_Condition_Code;
         END IF;
         IF (revised_qty_due_ IS NOT NULL) THEN
            -- Retrive cost for the part (and condition code if applicable)
            cost_ := Sales_Cost_Util_API.Get_Cost_Incl_Sales_Overhead(pkg_contract_,
                                                                      sales_part_rec_.part_no,
                                                                      '*',
                                                                      condition_code_,
                                                                      revised_qty_due_,
                                                                      'CHARGED ITEM',
                                                                      supply_code_db_,
                                                                      header_rec_.customer_no,
                                                                      'COMPANY OWNED');
         END IF;
      END IF;
      Client_SYS.Add_To_Attr('COST', cost_, attr_);
      Client_SYS.Add_To_Attr('CONDITION_CODE', condition_code_, attr_);

      -- Display an error about the primary supplier missing - instead of just "Supply Code must have a value" later...
      IF (supply_code_db_ IS NULL) AND (sales_part_rec_.sourcing_option IN ('PRIMARYSUPPTRANSIT', 'PRIMARYSUPPDIRECT')) THEN
         Error_SYS.Record_General(lu_name_, 'NO_PRIMARY_SUPP: No primary supplier exists for purchase part :P1.', sales_part_rec_.purchase_part_no);
      END IF;

      IF (supply_code_db_ = 'DOP') THEN
         dop_connection_ := Inventory_Part_API.Get_Dop_Connection(pkg_contract_, sales_part_rec_.part_no);
      -- if part is configured, supply_code is Not Decided
      ELSIF (sales_part_rec_.catalog_type != 'NON') AND (Part_Catalog_API.Get_Configurable_Db(nvl(sales_part_rec_.part_no, component_no_)) = 'CONFIGURED') THEN
         customer_level_db_ := pkg_header_rec_.customer_level;
         customer_level_id_ := pkg_header_rec_.customer_level_id;
         -- fetch a valid part price to be used as a base for characteristic pricing offsets.
         Customer_Order_Pricing_API.Get_Order_Line_Price_Info(sale_unit_price_,      unit_price_incl_tax_,    temp_base_sale_unit_price_,    temp_base_unit_price_incl_tax_,
                                                              temp_currency_rate_,   temp_discount_,          price_source_,                 price_source_id_,
                                                              provisional_price_db_, net_price_fetched_,      rebate_builder_db_,            part_level_db_,
                                                              part_level_id_,        customer_level_db_,      customer_level_id_,            pkg_order_no_,
                                                              component_no_,         psrec_.qty_per_assembly, pkg_header_rec_.price_list_no, pkg_header_rec_.price_effectivity_date,
                                                              NULL,                  header_rec_.use_price_incl_tax);
         IF (header_rec_.use_price_incl_tax = 'TRUE') THEN
            part_price_ := unit_price_incl_tax_;
         ELSE
            part_price_ := sale_unit_price_;
         END IF;
         Client_SYS.Add_to_Attr('PROVISIONAL_PRICE_DB', 'FALSE', attr_);
         Client_SYS.Add_To_Attr('PART_PRICE', part_price_, attr_);
         Client_SYS.Add_To_Attr('PRICE_SOURCE', price_source_, attr_);
         Client_SYS.Add_To_Attr('PRICE_SOURCE_ID', price_source_id_, attr_);
         Client_SYS.Add_To_Attr('PRICE_SOURCE_NET_PRICE_DB', net_price_fetched_, attr_);
         Client_SYS.Add_To_Attr('REBATE_BUILDER_DB', rebate_builder_db_, attr_);
         Client_SYS.Add_To_Attr('PART_LEVEL_DB', part_level_db_, attr_);
         Client_SYS.Add_To_Attr('PART_LEVEL_ID', part_level_id_, attr_);
         Client_SYS.Add_To_Attr('CUSTOMER_LEVEL_DB', customer_level_db_, attr_);
         Client_SYS.Add_To_Attr('CUSTOMER_LEVEL_ID', customer_level_id_, attr_);
         part_price_is_set_ := TRUE;
      ELSIF (supply_code_db_ NOT IN ('IPD', 'PD')) THEN
         Client_SYS.Add_To_Attr('SHIP_VIA_CODE', pkg_header_rec_.ship_via_code, attr_);
         Client_SYS.Add_To_Attr('CUST_CALENDAR_ID', pkg_header_rec_.cust_calendar_id, attr_);
         Client_SYS.Add_To_Attr('EXT_TRANSPORT_CALENDAR_ID', pkg_header_rec_.ext_transport_calendar_id, attr_);
         Client_SYS.Add_To_Attr('DEFAULT_ADDR_FLAG_DB', pkg_header_rec_.default_addr_flag, attr_);
         Client_SYS.Add_To_Attr('DELIVERY_LEADTIME', pkg_header_rec_.delivery_leadtime, attr_);
         Client_SYS.Add_To_Attr('ROUTE_ID', pkg_header_rec_.route_id, attr_);
         Client_SYS.Add_To_Attr('FORWARD_AGENT_ID', pkg_header_rec_.forward_agent_id, attr_);
         Client_SYS.Add_To_Attr('PICKING_LEADTIME', pkg_header_rec_.picking_leadtime, attr_);
         Client_SYS.Add_To_Attr('SHIPMENT_TYPE',    pkg_header_rec_.shipment_type, attr_);
         Client_SYS.Add_To_Attr('PACKING_INSTRUCTION_ID', pkg_header_rec_.packing_instruction_id, attr_);
      END IF;

      -- Calculate quantities.
      buy_qty_due_ := pkg_buy_qty_due_ * psrec_.qty_per_assembly;
      desired_qty_ := pkg_header_rec_.desired_qty * psrec_.qty_per_assembly;

      -- Calculate SALE_UNIT_PRICE and BASE_SALE_UNIT_PRICE.
      IF ((pkg_cost_ * pkg_revised_qty_due_) = 0) THEN
         sale_unit_price_          := 0;
         unit_price_incl_tax_      := 0;
         base_sale_unit_price_     := 0;
         base_unit_price_incl_tax_ := 0;
      ELSE
         -- Get unrounded line discount
         line_discount_amount_ := Cust_Order_Line_Discount_API.Get_Total_Line_Discount(pkg_header_rec_.order_no, pkg_header_rec_.line_no, pkg_header_rec_.rel_no, -1,
                                                                                          1, -- quantity
                                                                                          (sales_part_rec_.conv_factor / sales_part_rec_.inverted_conv_factor * cost_ * pkg_header_rec_.price_conv_factor) /(pkg_cost_ * sales_part_rec_.price_conv_factor));
         IF (header_rec_.use_price_incl_tax = 'TRUE') THEN
            unit_price_incl_tax_ := (sales_part_rec_.conv_factor / sales_part_rec_.inverted_conv_factor * cost_ * pkg_unit_price_incl_tax_ * pkg_header_rec_.price_conv_factor) /
                                     (pkg_cost_ * sales_part_rec_.price_conv_factor);
            IF (pkg_header_rec_.discount IS NOT NULL AND pkg_header_rec_.discount > 0) THEN
               -- Modified calculation logic of unit_price_incl_tax_
               unit_price_incl_tax_ := unit_price_incl_tax_ - line_discount_amount_;
            END IF;
         ELSE
            sale_unit_price_ := (sales_part_rec_.conv_factor / sales_part_rec_.inverted_conv_factor * cost_ * pkg_sale_unit_price_ * pkg_header_rec_.price_conv_factor) /
                                 (pkg_cost_ * sales_part_rec_.price_conv_factor);
            IF (pkg_header_rec_.discount IS NOT NULL AND pkg_header_rec_.discount > 0) THEN
               -- Modified calculation logic of sale_unit_price_
               sale_unit_price_ := sale_unit_price_ - line_discount_amount_;
            END IF;
         END IF;
         IF (Order_Supply_Type_API.Encode(pkg_header_rec_.demand_code) = 'IPD') THEN
            tax_liability_type_db_ := External_Cust_Order_Line_API.Get_Tax_Liability(pkg_header_rec_.order_no, 
                                                                                     pkg_header_rec_.line_no, 
                                                                                     pkg_header_rec_.rel_no);
         ELSE
            tax_liability_type_db_ := pkg_header_rec_.tax_liability_type;
         END IF;
         
         Tax_Handling_Order_Util_API.Get_Prices(base_sale_unit_price_,
                                                base_unit_price_incl_tax_,
                                                sale_unit_price_,
                                                unit_price_incl_tax_,
                                                multiple_tax_,
												            pkg_header_rec_.tax_code,
                                                pkg_header_rec_.tax_calc_structure_id,
                                                pkg_header_rec_.tax_class_id,
                                                pkg_header_rec_.order_no, 
                                                pkg_header_rec_.line_no, 
                                                pkg_header_rec_.rel_no, 
                                                -1,
                                                '*',
                                                Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                                pkg_contract_,
                                                header_rec_.customer_no,
                                                pkg_header_rec_.ship_addr_no,
                                                pkg_header_rec_.planned_ship_date,
                                                header_rec_.supply_country,
                                                NVL(pkg_header_rec_.delivery_type, '*'),
                                                pkg_header_rec_.catalog_no,
                                                header_rec_.use_price_incl_tax,
                                                header_rec_.currency_code,
                                                pkg_header_rec_.currency_rate,
                                                'FALSE',                                                
                                                pkg_header_rec_.tax_liability,
                                                tax_liability_type_db_,
                                                delivery_country_db_ => NULL,
                                                ifs_curr_rounding_ => 16,
                                                tax_from_diff_source_ => 'FALSE',
                                                attr_ => NULL); 
      END IF;

      discount_ := 0;

      Client_SYS.Add_To_Attr('QTY_TO_SHIP', qty_to_ship_, attr_);
      Client_SYS.Add_To_Attr('BASE_SALE_UNIT_PRICE', base_sale_unit_price_, attr_);
      Client_SYS.Add_To_Attr('BASE_UNIT_PRICE_INCL_TAX', base_unit_price_incl_tax_, attr_);
      Client_SYS.Add_To_Attr('BUY_QTY_DUE', buy_qty_due_, attr_);
      Client_SYS.Add_To_Attr('DESIRED_QTY', desired_qty_, attr_);
      Client_SYS.Add_To_Attr('DISCOUNT', discount_, attr_);
      Client_SYS.Add_To_Attr('PART_NO', sales_part_rec_.part_no, attr_);
      Client_SYS.Add_To_Attr('PURCHASE_PART_NO', sales_part_rec_.purchase_part_no, attr_);
      Client_SYS.Add_To_Attr('PLANNED_DELIVERY_DATE', pkg_planned_delivery_date_, attr_);
      Client_SYS.Add_To_Attr('PROMISED_DELIVERY_DATE', pkg_planned_delivery_date_, attr_);
      Client_SYS.Add_To_Attr('QTY_ASSIGNED', qty_assigned_, attr_);
      Client_SYS.Add_To_Attr('QTY_ON_ORDER', qty_on_order_, attr_);
      Client_SYS.Add_To_Attr('REVISED_QTY_DUE', revised_qty_due_, attr_);
      Client_SYS.Add_To_Attr('SALES_UNIT_MEAS', sales_part_rec_.sales_unit_meas, attr_);
      Client_SYS.Add_To_Attr('SALE_UNIT_PRICE', sale_unit_price_, attr_);
      Client_SYS.Add_To_Attr('UNIT_PRICE_INCL_TAX', unit_price_incl_tax_, attr_);
      Client_SYS.Add_To_Attr('WANTED_DELIVERY_DATE', pkg_wanted_delivery_date_, attr_);
      Client_SYS.Add_To_Attr('TARGET_DATE', pkg_target_date_, attr_);
      Client_SYS.Add_To_Attr('CREATE_SM_OBJECT_OPTION_DB', sales_part_rec_.create_sm_object_option, attr_);
      Client_SYS.Add_To_Attr('CREATED_BY_SERVER','1',attr_);
      Client_SYS.Add_To_Attr('QTY_PER_ASSEMBLY', psrec_.qty_per_assembly, attr_);
      Client_SYS.Add_To_Attr('NEW_COMP_AFTER_DELIVERY', 'FALSE', attr_);

      IF NOT part_price_is_set_ THEN
         IF (header_rec_.use_price_incl_tax = 'TRUE') THEN
            Client_SYS.Add_To_Attr('PART_PRICE', unit_price_incl_tax_, attr_);
         ELSE
         Client_SYS.Add_To_Attr('PART_PRICE', sale_unit_price_, attr_);
         END IF;
         Client_SYS.Add_To_Attr('PRICE_SOURCE_DB', pkg_header_rec_.price_source, attr_);
         Client_SYS.Add_To_Attr('PRICE_SOURCE_ID', pkg_header_rec_.price_source_id, attr_);
         Client_SYS.Add_To_Attr('PART_LEVEL_DB', pkg_header_rec_.part_level, attr_);
         Client_SYS.Add_To_Attr('PART_LEVEL_ID', pkg_header_rec_.part_level_id, attr_);
         Client_SYS.Add_To_Attr('CUSTOMER_LEVEL_DB', pkg_header_rec_.customer_level, attr_);
         Client_SYS.Add_To_Attr('CUSTOMER_LEVEL_ID', pkg_header_rec_.customer_level_id, attr_);
      END IF;

      IF (dop_connection_ IS NOT NULL) THEN
         Client_SYS.Add_To_Attr('DOP_CONNECTION', dop_connection_, attr_);
      END IF;
      IF NOT (Client_SYS.Item_Exist('REBATE_BUILDER_DB', attr_)) THEN
         Client_SYS.Add_To_Attr('REBATE_BUILDER_DB', pkg_header_rec_.rebate_builder, attr_);
      END IF;

      Client_SYS.Add_To_Attr('INSERT_PACKAGE_MODE_', insert_package_mode_, attr_);

      newrec_ := NULL;
      Unpack___(newrec_, indrec_, attr_);
      Check_Insert___(newrec_, indrec_, attr_);
      Insert___(objid_, objversion_, newrec_, attr_);
      -- Clearing all info generated for components.
      Client_SYS.Clear_Info;
   END LOOP;

   -- Client_SYS info is empty at this point. To be able to show the info message below in the client
   -- an Add_Info___ call is made when returning from this method.

   -- display an info message if there are components with invalid sales group setting.
   IF (header_rec_.check_sales_grp_deliv_conf = 'TRUE') THEN

      -- fetch package part's sales group setting
      pkg_deliv_conf_ := Sales_Group_API.Get_Delivery_Confirmation_Db(Sales_Part_API.Get_Catalog_Group(pkg_contract_, pkg_catalog_no_));
      Trace_SYS.Field('PKG SALES GROUP - delivery_confirmation', pkg_deliv_conf_);

      FOR psrec_ IN get_pkg_ingridients(pkg_contract_, pkg_catalog_no_) LOOP
         -- fetch component's sales group setting
         deliv_conf_ := Sales_Group_API.Get_Delivery_Confirmation_Db(Sales_Part_API.Get_Catalog_Group(pkg_contract_, psrec_.catalog_no));
         Trace_SYS.Field('COMP SALES GROUP - delivery_confirmation', deliv_conf_);

         IF (deliv_conf_ NOT IN (pkg_deliv_conf_, 'OPTIONAL')) THEN
            Trace_SYS.Message('Sales groups don''t match...');
            Client_SYS.Add_Info(lu_name_, 'SALESGRPDELIVCONF3: The Delivery Confirmation settings on the package part and its components'' sales groups don''t match. Please change the Sales Group Setting on the customer order or check the sales groups.');
            EXIT; -- only add info once
         END IF;
      END LOOP;
   END IF;
EXCEPTION
   WHEN zero_divide THEN
      Error_SYS.Record_General(lu_name_, 'WRONGCOST: The package is not permitted to have a standard cost of 0.');
END Insert_Package___;


-- Update_Package___
--   Updates the package structure
PROCEDURE Update_Package___ (
   pkg_promised_delivery_date_ IN OUT DATE,
   pkg_planned_delivery_date_  IN OUT DATE,
   pkg_planned_ship_date_      IN OUT DATE,
   pkg_planned_due_date_       IN OUT DATE,
   pkg_rec_                    IN     CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   insert_package_mode_        IN     VARCHAR2,
   block_component_info_       IN     VARCHAR2,
   dop_replicate_msg_          IN     VARCHAR2 )
IS
   do_price_    BOOLEAN := FALSE;
   do_discount_ BOOLEAN := FALSE;
   do_planned_  BOOLEAN := FALSE;
   do_wanted_   BOOLEAN := FALSE;
   do_qty_      BOOLEAN := FALSE;
   do_promised_ BOOLEAN := FALSE;
   oldrec_      CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   do_target_   BOOLEAN := FALSE;
BEGIN
   oldrec_ := Get_Object_By_Keys___(pkg_rec_.order_no, pkg_rec_.line_no, pkg_rec_.rel_no, -1);

   IF ((oldrec_.buy_qty_due != pkg_rec_.buy_qty_due) OR
       (oldrec_.desired_qty != pkg_rec_.desired_qty)) THEN
      do_qty_     := TRUE;
      do_planned_ := TRUE;
   END IF;

   IF (oldrec_.discount != pkg_rec_.discount) THEN
      do_discount_ := TRUE;
      do_price_    := TRUE;
   END IF;

   IF ((oldrec_.base_sale_unit_price != pkg_rec_.base_sale_unit_price) OR
       (oldrec_.base_unit_price_incl_tax != pkg_rec_.base_unit_price_incl_tax) OR
       (oldrec_.sale_unit_price != pkg_rec_.sale_unit_price) OR
       (oldrec_.unit_price_incl_tax != pkg_rec_.unit_price_incl_tax)) THEN
      do_price_ := TRUE;
   END IF;

   IF ((oldrec_.planned_delivery_date != pkg_rec_.planned_delivery_date) OR
       (oldrec_.planned_due_date != pkg_planned_due_date_) OR
       (oldrec_.planned_ship_date != pkg_planned_ship_date_)) THEN
      do_planned_ := TRUE;
   END IF;

   IF (oldrec_.wanted_delivery_date != pkg_rec_.wanted_delivery_date) THEN
      do_wanted_ := TRUE;
   END IF;

   IF (oldrec_.target_date != pkg_rec_.target_date) THEN
      do_target_ := TRUE;
   END IF;

   IF (oldrec_.promised_delivery_date != pkg_rec_.promised_delivery_date) THEN
      do_promised_ := TRUE;
   END IF;

   Change_Package_Structure___(pkg_promised_delivery_date_, pkg_planned_delivery_date_, pkg_planned_ship_date_, pkg_planned_due_date_,
                               pkg_rec_, do_qty_, do_price_, do_discount_, do_planned_, do_wanted_, do_promised_, do_target_, insert_package_mode_, block_component_info_, dop_replicate_msg_);
END Update_Package___;


-- Update_Package_Cost___
--   Updates the package cost when inserting, updating or deleting the
--   package structure.
PROCEDURE Update_Package_Cost___ (
   pkg_cost_     IN OUT NUMBER,
   pkg_order_no_ IN     VARCHAR2,
   pkg_line_no_  IN     VARCHAR2,
   pkg_rel_no_   IN     VARCHAR2 )
IS
   revised_qty_due_ CUSTOMER_ORDER_LINE_TAB.revised_qty_due%TYPE;
   CURSOR get_package_cost IS
      SELECT NVL(sum(revised_qty_due / revised_qty_due_ * cost), 0)
      FROM  CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = pkg_order_no_
      AND   line_no = pkg_line_no_
      AND   rel_no = pkg_rel_no_
      AND   line_item_no > 0
      AND   rowstate != 'Cancelled';
BEGIN
   revised_qty_due_ := Get_Revised_Qty_Due(pkg_order_no_, pkg_line_no_, pkg_rel_no_, -1);
   OPEN  get_package_cost;
   FETCH get_package_cost INTO pkg_cost_;
   IF (get_package_cost%NOTFOUND) THEN
      pkg_cost_ := 0;
   END IF;
   CLOSE get_package_cost;
EXCEPTION
   WHEN zero_divide THEN
      Error_SYS.Record_General(lu_name_, 'WRONGCOST: The package is not permitted to have a standard cost of 0.');
END Update_Package_Cost___;


-- Change_Package_Structure___
--   Changes the package structure attributes when changing a package.
PROCEDURE Change_Package_Structure___ (
   pkg_promised_delivery_date_ IN OUT DATE,
   pkg_planned_delivery_date_  IN OUT DATE,
   pkg_planned_ship_date_      IN OUT DATE,
   pkg_planned_due_date_       IN OUT DATE,
   pkg_rec_                    IN     CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   do_qty_                     IN     BOOLEAN,
   do_price_                   IN     BOOLEAN,
   do_discount_                IN     BOOLEAN,
   do_planned_                 IN     BOOLEAN,
   do_wanted_                  IN     BOOLEAN,
   do_promised_                IN     BOOLEAN,
   do_target_                  IN     BOOLEAN,
   insert_package_mode_        IN     VARCHAR2,
   block_component_info_       IN     VARCHAR2,
   dop_replicate_msg_          IN     VARCHAR2 )
IS
   newrec_                    CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   old_pkg_rec_               Public_Rec;
   header_rec_                CUSTOMER_ORDER_API.Public_Rec;
   part_cat_rec_              Part_Catalog_API.Public_Rec;
   sales_part_rec_            Sales_Part_API.Public_Rec;
   max_planned_delivery_date_ DATE;
   min_planned_due_date_      DATE;
   old_pkg_delivery_date_     DATE;
   max_date_                  DATE := SYSDATE - 10000;
   min_date_                  DATE := SYSDATE + 10000;
   site_date_                 DATE;
   header_objstate_           CUSTOMER_ORDER_LINE_TAB.rowstate%TYPE;
   attr_                      VARCHAR2(2000);
   sales_unit_meas_           VARCHAR2(10);
   price_unit_meas_           VARCHAR2(10);
   price_conv_factor_         NUMBER;
   oldrec_                    CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   max_planned_ship_date_     DATE;
   external_deliv_ship_date_  DATE;
   backorder_option_          VARCHAR2(40);
   line_discount_amount_      NUMBER;
   promised_                  VARCHAR2(5) := Fnd_Boolean_Api.DB_FALSE;
   tax_liability_type_db_     VARCHAR2(20);
   multiple_tax_              VARCHAR2(20);
   alloc_assign_flag_db_      CUST_ORDER_TYPE_TAB.oe_alloc_assign_flag%TYPE;

   CURSOR get_package_structure IS
      SELECT rowid, activity_seq
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = pkg_rec_.order_no
      AND    line_no  = pkg_rec_.line_no
      AND    rel_no   = pkg_rec_.rel_no
      AND    line_item_no > 0
      AND    (rowstate != 'Cancelled' OR (rowstate = 'Cancelled' AND promised_ = Fnd_Boolean_Api.DB_TRUE))
      ORDER BY line_item_no;
BEGIN
   IF (do_promised_) THEN
      promised_ := Fnd_Boolean_Api.DB_TRUE;
   END IF;
   max_planned_delivery_date_ := max_date_;
   max_planned_ship_date_     := max_date_;
   external_deliv_ship_date_  := max_date_;
   min_planned_due_date_      := min_date_;
   old_pkg_delivery_date_     := pkg_planned_delivery_date_;

   site_date_       := TRUNC(Site_API.Get_Site_Date(pkg_rec_.contract));

   header_rec_      := CUSTOMER_ORDER_API.Get(pkg_rec_.order_no);
   header_objstate_ := header_rec_.rowstate;
   old_pkg_rec_     := Get(pkg_rec_.order_no, pkg_rec_.line_no, pkg_rec_.rel_no, -1);

   FOR comprec_ IN get_package_structure LOOP
      newrec_                       := Get_Object_By_Id___(comprec_.rowid);

      -- set header values on all components in case they have changed
      newrec_.addr_flag             := pkg_rec_.addr_flag;
      newrec_.ship_addr_no          := pkg_rec_.ship_addr_no;
      newrec_.contact               := pkg_rec_.contact;
      newrec_.district_code         := pkg_rec_.district_code;
      newrec_.region_code           := pkg_rec_.region_code;
      newrec_.staged_billing        := pkg_rec_.staged_billing;
      newrec_.tax_id_no             := pkg_rec_.tax_id_no;
      newrec_.tax_id_validated_date := pkg_rec_.tax_id_validated_date;
      newrec_.tax_code              := pkg_rec_.tax_code;
      newrec_.tax_class_id          := pkg_rec_.tax_class_id;
      newrec_.intrastat_exempt      := pkg_rec_.intrastat_exempt;
      newrec_.equipment_object_seq  := pkg_rec_.equipment_object_seq;
      newrec_.sup_sm_contract       := pkg_rec_.sup_sm_contract;
      newrec_.sup_sm_object         := pkg_rec_.sup_sm_object;

      IF (newrec_.supply_code NOT IN ('IPD', 'PD')) THEN
         newrec_.ship_via_code             := pkg_rec_.ship_via_code;
         newrec_.cust_calendar_id          := pkg_rec_.cust_calendar_id;
         newrec_.ext_transport_calendar_id := pkg_rec_.ext_transport_calendar_id;
         newrec_.delivery_leadtime         := pkg_rec_.delivery_leadtime;
         newrec_.route_id                  := pkg_rec_.route_id;
         newrec_.forward_agent_id          := pkg_rec_.forward_agent_id;
         newrec_.picking_leadtime          := pkg_rec_.picking_leadtime;
         newrec_.shipment_type             := pkg_rec_.shipment_type;
         newrec_.shipment_creation         := pkg_rec_.shipment_creation;
         newrec_.delivery_terms            := pkg_rec_.delivery_terms;
         newrec_.del_terms_location        := pkg_rec_.del_terms_location;
      END IF;
      
      -- Evaluating default info
      newrec_.default_addr_flag   := Check_Default_Addr_Flag___(newrec_, newrec_.order_no, newrec_.default_addr_flag);
      
      -- oldrec_ used in date calculation
      oldrec_           := newrec_;

      backorder_option_ := header_rec_.backorder_option;
      
      alloc_assign_flag_db_ := Cust_Order_Type_API.Get_Oe_Alloc_Assign_Flag_Db(header_rec_.order_id);
      
      IF do_qty_ THEN
         -- Recalculate quantities for package components
         newrec_.buy_qty_due      := (pkg_rec_.buy_qty_due * newrec_.buy_qty_due) / old_pkg_rec_.buy_qty_due;
         IF pkg_rec_.desired_qty = 0 THEN
            -- desired_qty of package header is 0
            newrec_.desired_qty := 0;
         ELSIF old_pkg_rec_.desired_qty = 0 THEN
            -- desired_qty of package header has been changed from 0 to another value. So, use ratio from buy_qty_due to calculate for component
            newrec_.desired_qty := pkg_rec_.desired_qty * (newrec_.buy_qty_due / pkg_rec_.buy_qty_due);
         ELSE
            newrec_.desired_qty := (pkg_rec_.desired_qty * newrec_.desired_qty) / old_pkg_rec_.desired_qty;
         END IF;
         newrec_.revised_qty_due  := (pkg_rec_.revised_qty_due * newrec_.revised_qty_due) / old_pkg_rec_.revised_qty_due;
         newrec_.qty_per_assembly := newrec_.buy_qty_due / pkg_rec_.buy_qty_due;

         IF (newrec_.rowstate IN ('Released', 'PartiallyDelivered')) AND (((newrec_.supply_code = 'NO') AND
            (backorder_option_ != 'INCOMPLETE PACKAGES NOT ALLOWED')) OR (newrec_.supply_code = 'SEO')) THEN
            IF (TRUNC(newrec_.planned_due_date) <= site_date_) OR
               (alloc_assign_flag_db_ = Cust_Ord_Reservation_Type_API.DB_PRIORITY_RESERVATION) THEN
                  newrec_.qty_to_ship := newrec_.revised_qty_due - newrec_.qty_shipped;
            END IF;
         END IF;
      END IF;

      IF do_wanted_ THEN
         newrec_.wanted_delivery_date := pkg_rec_.wanted_delivery_date;
      END IF;

      IF do_target_ THEN
         newrec_.target_date := pkg_rec_.target_date;
      END IF;

      IF do_planned_ THEN
         newrec_.promised_delivery_date := pkg_promised_delivery_date_;
         newrec_.planned_delivery_date  := pkg_planned_delivery_date_;

         IF (newrec_.revised_qty_due > newrec_.qty_shipped) OR (do_wanted_) THEN
            Calculate_Order_Line_Dates___(newrec_, oldrec_, comprec_.rowid);
         END IF;
         Add_Info___(insert_package_mode_);

         IF (newrec_.rowstate = 'Released') AND (((newrec_.supply_code = 'NO') AND
            (backorder_option_ != 'INCOMPLETE PACKAGES NOT ALLOWED')) OR (newrec_.supply_code = 'SEO')) THEN
            IF (TRUNC(newrec_.planned_due_date) <= site_date_) OR
                (alloc_assign_flag_db_ = Cust_Ord_Reservation_Type_API.DB_PRIORITY_RESERVATION) THEN
               newrec_.qty_to_ship := newrec_.revised_qty_due;
               Customer_Order_Line_Hist_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no,
                                                Language_SYS.Translate_Constant(lu_name_, 'CANBESHIPPED: The line can now be shipped'));
            END IF;
         END IF;
      END IF;

      IF (do_promised_) THEN
         newrec_.promised_delivery_date := pkg_rec_.promised_delivery_date;
      END IF;

      IF do_discount_ THEN
         newrec_.discount := 0;
      END IF;

      sales_part_rec_  := Sales_Part_API.Get(newrec_.contract, newrec_.catalog_no);
      sales_unit_meas_ := sales_part_rec_.sales_unit_meas;
      price_unit_meas_ := sales_part_rec_.price_unit_meas;
      price_conv_factor_ := sales_part_rec_.price_conv_factor;

      IF (pkg_rec_.catalog_type = 'PKG' AND pkg_rec_.price_freeze != 'FROZEN') THEN
         IF (newrec_.price_unit_meas != price_unit_meas_) THEN
            Client_SYS.Add_Info(lu_name_, 'PRICEUMCHG: Price unit of Measure has changed from :P1 to :P2 for component part :P3.',newrec_.price_unit_meas,price_unit_meas_,newrec_.catalog_no);
            newrec_.price_unit_meas := price_unit_meas_;
         END IF;
         IF (newrec_.sales_unit_meas != sales_unit_meas_) THEN
            Client_SYS.Add_Info(lu_name_, 'SALESUMCHG: Sales unit of Measure has changed from :P1 to :P2 for component part :P3.',newrec_.sales_unit_meas,sales_unit_meas_,newrec_.catalog_no);
            newrec_.sales_unit_meas := sales_unit_meas_;
         END IF;
         IF (newrec_.price_conv_factor != price_conv_factor_) THEN
            part_cat_rec_ := Part_Catalog_API.Get(newrec_.part_no);
            IF (part_cat_rec_.catch_unit_enabled = 'FALSE' ) THEN
               Client_SYS.Add_Info(lu_name_, 'PRICECONVCHG: Price Conversion factor has changed from :P1 to :P2 for component part :P3.',newrec_.price_conv_factor,price_conv_factor_,newrec_.catalog_no);
               newrec_.price_conv_factor := price_conv_factor_;
            END IF;
         END IF;
      END IF;

      IF (do_price_ AND (newrec_.price_source != 'MANUAL')) THEN
         IF (pkg_rec_.cost = 0) THEN
            newrec_.sale_unit_price          := 0;
            newrec_.unit_price_incl_tax      := 0;
            newrec_.base_sale_unit_price     := 0;
            newrec_.base_unit_price_incl_tax := 0;
         ELSE
            line_discount_amount_ := Cust_Order_Line_Discount_API.Get_Total_Line_Discount(pkg_rec_.order_no, pkg_rec_.line_no, pkg_rec_.rel_no, -1,
                                                                                          1, -- quantity
                                                                                          (newrec_.conv_factor / newrec_.inverted_conv_factor * newrec_.cost * pkg_rec_.price_conv_factor) /(pkg_rec_.cost * newrec_.price_conv_factor));
            IF (header_rec_.use_price_incl_tax = 'TRUE') THEN
               newrec_.unit_price_incl_tax := (newrec_.conv_factor / newrec_.inverted_conv_factor * newrec_.cost * pkg_rec_.unit_price_incl_tax * pkg_rec_.price_conv_factor) /
                                              (pkg_rec_.cost * newrec_.price_conv_factor);

               IF (pkg_rec_.discount IS NOT NULL AND pkg_rec_.discount != 0) THEN
                  IF (pkg_rec_.discount = 100) THEN
                     newrec_.unit_price_incl_tax := 0;
                  ELSE
                     -- Modified calculation of unit_price_incl_tax
                     newrec_.unit_price_incl_tax := newrec_.unit_price_incl_tax - line_discount_amount_;
                  END IF;
               END IF;
            ELSE
               newrec_.sale_unit_price := (newrec_.conv_factor / newrec_.inverted_conv_factor * newrec_.cost * pkg_rec_.sale_unit_price * pkg_rec_.price_conv_factor) /
                      (pkg_rec_.cost * newrec_.price_conv_factor);

               IF (pkg_rec_.discount IS NOT NULL AND pkg_rec_.discount != 0) THEN
                  IF (pkg_rec_.discount = 100) THEN
                     newrec_.sale_unit_price := 0;
                  ELSE
                     -- Modified calculation of sale_unit_price
                     newrec_.sale_unit_price := newrec_.sale_unit_price - line_discount_amount_;
                  END IF;
               END IF;
            END IF;
            
            IF (Order_Supply_Type_API.Encode(pkg_rec_.demand_code) = 'IPD') THEN
               tax_liability_type_db_ := External_Cust_Order_Line_API.Get_Tax_Liability(pkg_rec_.order_no, 
                                                                                        pkg_rec_.line_no, 
                                                                                        pkg_rec_.rel_no);
            ELSE
               tax_liability_type_db_ := pkg_rec_.tax_liability_type;
            END IF;
                                    
            Tax_Handling_Order_Util_API.Get_Prices(newrec_.base_sale_unit_price,
                                                   newrec_.base_unit_price_incl_tax,
                                                   newrec_.sale_unit_price,
                                                   newrec_.unit_price_incl_tax,
                                                   multiple_tax_,
												               old_pkg_rec_.tax_code,
                                                   old_pkg_rec_.tax_calc_structure_id,
                                                   old_pkg_rec_.tax_class_id,
                                                   pkg_rec_.order_no, 
                                                   pkg_rec_.line_no, 
                                                   pkg_rec_.rel_no, 
                                                   -1,
                                                   '*',
                                                   Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                                   old_pkg_rec_.contract,
                                                   header_rec_.customer_no,
                                                   old_pkg_rec_.ship_addr_no,
                                                   old_pkg_rec_.planned_ship_date,
                                                   header_rec_.supply_country,
                                                   NVL(old_pkg_rec_.delivery_type, '*'),
                                                   old_pkg_rec_.catalog_no,
                                                   header_rec_.use_price_incl_tax,
                                                   header_rec_.currency_code,
                                                   old_pkg_rec_.currency_rate,
                                                   'FALSE',                                                   
                                                   old_pkg_rec_.tax_liability,
                                                   tax_liability_type_db_,
                                                   delivery_country_db_ => NULL,
                                                   ifs_curr_rounding_ => 16,
                                                   tax_from_diff_source_ => 'FALSE',
                                                   attr_ => NULL);
      
         END IF;
      END IF;

      IF (do_qty_ OR do_wanted_) THEN
         -- only create priority / instant reservations when its not a CTP planned/reserved line
         IF (newrec_.ctp_planned = 'N') THEN
            IF (Reserve_Customer_Order_API.Is_Supply_Chain_Reservation(pkg_rec_.order_no, pkg_rec_.line_no, pkg_rec_.rel_no,
                                                                       pkg_rec_.line_item_no, NULL, 'INSTANT') = 1) THEN
               -- instant supply chain reservation
               Reserve_Customer_Order_API.Create_Instant_Reservation__(pkg_rec_.order_no,  pkg_rec_.line_no, pkg_rec_.rel_no, newrec_.line_item_no,
                                                                    NULL, NVL(newrec_.part_no, newrec_.purchase_part_no), newrec_.revised_qty_due,
                                                                    newrec_.qty_shipped, comprec_.rowid, newrec_.vendor_no);
            ELSE
               Reserve_Customer_Order_API.Create_Priority_Reservation__(newrec_.qty_assigned,
                  newrec_.contract, newrec_.part_no, pkg_rec_.order_no, pkg_rec_.line_no, pkg_rec_.rel_no, newrec_.line_item_no,
                  newrec_.revised_qty_due, newrec_.qty_shipped, newrec_.supply_code, comprec_.rowid);
            END IF;
         END IF;
      END IF;

      -- set date "bounds"
      max_planned_delivery_date_ := GREATEST(max_planned_delivery_date_, newrec_.planned_delivery_date);
      IF (newrec_.supply_code IN ('IPD', 'PD')) THEN
         external_deliv_ship_date_     := GREATEST(external_deliv_ship_date_, newrec_.planned_ship_date);
      ELSE
         max_planned_ship_date_ := GREATEST(max_planned_ship_date_, newrec_.planned_ship_date);
      END IF;
      min_planned_due_date_      := LEAST(min_planned_due_date_, newrec_.planned_due_date);

      -- Modify DOP structure for component part with Supply_Type = 'Dop'.
      IF (newrec_.supply_code = 'DOP') AND (dop_replicate_msg_ IS NOT NULL) THEN
         Connect_Customer_Order_API.Modify_Dop(newrec_.qty_on_order,
                                               newrec_.order_no,
                                               newrec_.line_no,
                                               newrec_.rel_no,
                                               newrec_.line_item_no,
                                               newrec_.revised_qty_due,
                                               newrec_.planned_due_date,
                                               dop_replicate_msg_,
                                               'TRUE');
      END IF;

      newrec_.rowversion := sysdate;
      IF do_planned_ THEN
         IF ((trunc(pkg_planned_ship_date_)) = (trunc(newrec_.planned_ship_date))) AND (pkg_planned_ship_date_ != newrec_.planned_ship_date) THEN
            newrec_.planned_ship_date := pkg_planned_ship_date_;
         END IF;
      END IF;

      Update_Line___(comprec_.rowid, newrec_);

      IF (do_qty_ AND comprec_.activity_seq IS NOT NULL) THEN
         Calculate_Cost_And_Progress(newrec_.order_no,
                                     newrec_.line_no,
                                     newrec_.rel_no,
                                     newrec_.line_item_no);
      END IF;
   END LOOP;

   FOR comprec_ IN get_package_structure LOOP
      newrec_ := Get_Object_By_Id___(comprec_.rowid);
      oldrec_ := newrec_;

      IF (header_objstate_ = 'Planned') THEN
         IF (do_promised_ AND NOT do_planned_) THEN
            newrec_.promised_delivery_date := pkg_rec_.promised_delivery_date;
            pkg_promised_delivery_date_    := pkg_rec_.promised_delivery_date;
         ELSE
            newrec_.promised_delivery_date := max_planned_delivery_date_;
            pkg_promised_delivery_date_    := max_planned_delivery_date_;
         END IF;
      END IF;

      newrec_.rowversion := sysdate;

      IF (newrec_.promised_delivery_date != oldrec_.promised_delivery_date) THEN
         Update_Line___(comprec_.rowid, newrec_);
      END IF;

      IF do_qty_ THEN
         Finite_State_Machine___(newrec_, NULL, attr_);
      END IF;
   END LOOP;
   -- do not use components of newrec_ after this loop!

   -- Remove all component infos that have been generated
   IF (block_component_info_ = 'TRUE') THEN
      Client_Sys.Clear_Info;
   END IF;

   -- Fix PLANNED_DELIVERY_DATE and PLANNED_DUE_DATE for Package.
   IF (pkg_planned_delivery_date_ < max_planned_delivery_date_) THEN
      pkg_planned_delivery_date_ := max_planned_delivery_date_;

      min_planned_due_date_      := min_date_;

      FOR comprec_ IN get_package_structure LOOP
         newrec_ := Get_Object_By_Id___(comprec_.rowid);
         IF (newrec_.planned_delivery_date < pkg_planned_delivery_date_) THEN
            oldrec_                        := newrec_;
            newrec_.promised_delivery_date := pkg_promised_delivery_date_;
            newrec_.planned_delivery_date  := pkg_planned_delivery_date_;
            IF (newrec_.revised_qty_due > newrec_.qty_shipped) THEN
               Calculate_Order_Line_Dates___(newrec_, oldrec_, comprec_.rowid);
            END IF;

            -- Modify DOP structure for component part with Supply_Type = 'Dop'.
            IF (newrec_.supply_code = 'DOP') AND (dop_replicate_msg_ IS NOT NULL) THEN
               Connect_Customer_Order_API.Modify_Dop(newrec_.qty_on_order,
                                                     newrec_.order_no,
                                                     newrec_.line_no,
                                                     newrec_.rel_no,
                                                     newrec_.line_item_no,
                                                     newrec_.revised_qty_due,
                                                     newrec_.planned_due_date,
                                                     dop_replicate_msg_,
                                                     'TRUE');
            END IF;

            Update_Line___(comprec_.rowid, newrec_);
         END IF;
      END LOOP;
   END IF;
         min_planned_due_date_ := LEAST(min_planned_due_date_, newrec_.planned_due_date);

   IF (pkg_planned_delivery_date_ != old_pkg_delivery_date_) THEN
      Client_SYS.Add_Info(lu_name_, 'TARGETDATECHG: The planned delivery date has been changed from :P1 to :P2.',
         to_char(old_pkg_delivery_date_, 'YYYY-MM-DD HH24.MI'),
         to_char(pkg_planned_delivery_date_, 'YYYY-MM-DD HH24.MI'));
   END IF;

   IF (max_planned_ship_date_ != max_date_) THEN
      pkg_planned_ship_date_ := max_planned_ship_date_;
      IF ((trunc(pkg_planned_ship_date_)) = (trunc(newrec_.planned_ship_date))) AND (pkg_planned_ship_date_ != newrec_.planned_ship_date) THEN
         pkg_planned_ship_date_ := newrec_.planned_ship_date;
      END IF;
   ELSIF (external_deliv_ship_date_ != max_date_) THEN
      pkg_planned_ship_date_ := external_deliv_ship_date_;
   END IF;

   IF (min_planned_due_date_ != min_date_) THEN
      pkg_planned_due_date_ := min_planned_due_date_;
   END IF;
EXCEPTION
   WHEN zero_divide THEN
      Error_Sys.Record_General(lu_name_, 'WRONGCOST: The package is not permitted to have a standard cost of 0.');
END Change_Package_Structure___;


-- Check_Active_Part___
--   Check whether the connected sales part is an active part in the Inventory.
PROCEDURE Check_Active_Part___ (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 )
IS
BEGIN
   IF (part_no_ IS NOT NULL) THEN
      IF (Inventory_Part_Status_Par_API.Get_Demand_Flag_Db(Inventory_Part_API.Get_Part_Status(contract_, part_no_)) = 'N') THEN
         Error_SYS.Record_General(lu_name_, 'DMD_NOT_ALLOW: The inventory part :P1 has a status that does not allow new demands.', part_no_);
      END IF;
   END IF;
END Check_Active_Part___;

-- Get_Line_Defaults___
--   Field validation on column catalog_no from client.
PROCEDURE Get_Line_Defaults___ (
   attr_                     IN OUT VARCHAR2,
   catalog_no_               IN OUT VARCHAR2,
   order_no_                 IN     VARCHAR2,
   part_replacement_allowed_ IN     NUMBER )
IS
   buy_qty_due_                     NUMBER;
   currency_rate_                   NUMBER;
   sale_unit_price_                 NUMBER;
   unit_price_incl_tax_             NUMBER;
   base_sale_unit_price_            NUMBER;
   base_unit_price_incl_tax_        NUMBER;
   discount_                        NUMBER;
   supply_code_                     CUSTOMER_ORDER_LINE_TAB.supply_code%TYPE;
   supply_code_client_              VARCHAR2(200);
   price_list_no_                   CUSTOMER_ORDER_LINE_TAB.price_list_no%TYPE;
   vendor_no_                       CUSTOMER_ORDER_LINE_TAB.vendor_no%TYPE;
   catalog_desc_                    CUSTOMER_ORDER_LINE_TAB.catalog_desc%TYPE;
   sales_part_desc_                 CUSTOMER_ORDER_LINE_TAB.catalog_desc%TYPE;
   cost_                            NUMBER;
   consignment_stock_               CUSTOMER_ORDER_LINE_TAB.consignment_stock%TYPE;
   dop_connection_                  VARCHAR2(200) := NULL;
   header_rec_                      CUSTOMER_ORDER_API.Public_Rec;
   sales_part_rec_                  Sales_Part_API.Public_Rec;
   inv_part_rec_                    Inventory_Part_API.Public_Rec;
   org_catalog_no_                  CUSTOMER_ORDER_LINE_TAB.catalog_no%TYPE;
   component_part_no_               CUSTOMER_ORDER_LINE_TAB.catalog_no%TYPE;
   catalog_type_                    CUSTOMER_ORDER_LINE_TAB.catalog_type%TYPE;
   price_source_                    VARCHAR2(200);
   effectivity_date_                DATE := NULL;
   price_source_id_                 VARCHAR2(25);
   customer_part_no_                CUSTOMER_ORDER_LINE_TAB.customer_part_no%TYPE;
   receiving_advice_type_           CUSTOMER_ORDER_LINE.receiving_advice_type%TYPE;
   cross_rec_                       Sales_Part_Cross_Reference_API.Public_Rec;
   customer_part_conv_factor_       NUMBER;
   customer_part_unit_meas_         VARCHAR2(50);
   supply_site_reserve_type_        VARCHAR2(20);
   supply_site_                     VARCHAR2(5);   
   condition_code_                  CUSTOMER_ORDER_LINE_TAB.condition_code%TYPE;
   demand_code_                     VARCHAR2(200);
   value_                           VARCHAR2(200) := NULL;
   sm_object_option_                VARCHAR2(20);
   self_billing_db_                 VARCHAR2(20);
   created_by_server_               BOOLEAN;
   provisional_price_db_            VARCHAR2(20) := 'FALSE';
   charged_item_                    VARCHAR2(20);
   revised_qty_due_                 NUMBER;
   configuration_id_                CUSTOMER_ORDER_LINE_TAB.configuration_id%TYPE;
   net_price_fetched_               VARCHAR2(20);
   rebate_builder_db_               VARCHAR2(20);
   input_unit_meas_group_id_        VARCHAR2(30);
   default_input_uom_               VARCHAR2(30);
   uom_rec_                         Input_Unit_Meas_API.Public_Rec;
   part_level_db_                   VARCHAR2(30);
   part_level_id_                   VARCHAR2(200);
   customer_level_db_               VARCHAR2(30);
   customer_level_id_               VARCHAR2(200);
   tax_code_                        CUSTOMER_ORDER_LINE_TAB.tax_code%TYPE;
   tax_class_                       CUSTOMER_ORDER_LINE_TAB.tax_class_id%TYPE;
   line_item_no_                    CUSTOMER_ORDER_LINE_TAB.line_item_no%TYPE;
   activity_seq_                    CUSTOMER_ORDER_LINE_TAB.activity_seq%TYPE;
   demand_order_ref_                CUSTOMER_ORDER_LINE_TAB.demand_order_ref1%TYPE;
   rental_db_                       CUSTOMER_ORDER_LINE_TAB.rental%TYPE;
   part_ownership_db_               CUSTOMER_ORDER_LINE_TAB.part_ownership%TYPE;
   sales_price_type_db_             VARCHAR2(20);
   usage_                           VARCHAR2(20);
   ship_addr_no_                    VARCHAR2(50);
   dummy_rec_                       CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   rental_chargeable_days_          NUMBER;
   cust_part_inver_conv_fact_       NUMBER;
   free_of_charge_db_               VARCHAR2(20);   
   suggested_exists_                NUMBER;
   addr_flag_                       VARCHAR2(5);
   deliver_to_customer_no_          CUSTOMER_ORDER_LINE_TAB.deliver_to_customer_no%TYPE;
   packing_instruction_id_          VARCHAR2(50);
   header_contract_conected_comp_   SITE_TAB.company%TYPE;
   sales_unit_meas_                 VARCHAR2(10);
   configured_db_                   VARCHAR2(20);
   purchase_part_no_                VARCHAR2(25);

   
   
   CURSOR get_pkg_components(contract_ VARCHAR2, parent_part_ VARCHAR2) IS
      SELECT catalog_no, line_item_no, qty_per_assembly
        FROM sales_part_package_pub
       WHERE contract = contract_
         AND parent_part = parent_part_
    ORDER BY line_item_no;
BEGIN
   header_rec_ := CUSTOMER_ORDER_API.Get(order_no_);
   header_contract_conected_comp_ := Site_API.Get_Company(header_rec_.contract);
   -- Fetch already entered defaults from the attribute-string.
   buy_qty_due_       := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('BUY_QTY_DUE', attr_));
   effectivity_date_  := Client_SYS.Attr_Value_To_Date(Client_SYS.Get_Item_Value('PRICE_EFFECTIVITY_DATE', attr_));
   vendor_no_         := Client_SYS.Get_Item_Value('VENDOR_NO', attr_);
   ship_addr_no_      := Client_SYS.Get_Item_Value('SHIP_ADDR_NO', attr_);
   created_by_server_ := (NVL(Client_SYS.Get_Item_Value('CREATED_BY_SERVER', attr_), '0') = '1');

   IF (Fnd_Session_API.Is_Odp_Session) THEN
      addr_flag_               := Client_SYS.Get_Item_Value('ADDR_FLAG', attr_);
      deliver_to_customer_no_  := Client_SYS.Get_Item_Value('DELIVER_TO_CUSTOMER_NO', attr_);
   END IF;

   demand_code_ := Client_SYS.Get_Item_Value('DEMAND_CODE_DB', attr_);
   IF demand_code_ IS NULL THEN
      demand_code_ := Client_SYS.Get_Item_Value('DEMAND_CODE', attr_);
      IF demand_code_ IS NOT NULL THEN
         demand_code_ := Order_Supply_Type_API.Encode(demand_code_);
      END IF;
   END IF;

   rental_db_ := NVL(Client_SYS.Get_Item_Value('RENTAL_DB', attr_), Fnd_Boolean_API.DB_FALSE);
   IF (rental_db_ = Fnd_Boolean_API.DB_FALSE) THEN
      usage_               := Sales_Type_API.DB_SALES_ONLY;
      sales_price_type_db_ := Sales_Price_Type_API.DB_SALES_PRICES;
   ELSE
      usage_               := Sales_Type_API.DB_RENTAL_ONLY;
      sales_price_type_db_ := Sales_Price_Type_API.DB_RENTAL_PRICES;
      rental_chargeable_days_ := Get_Latest_Rent_Charge_Days___(attr_, dummy_rec_);
   END IF;
   -- Check if it's a valid and active sales part.
   Sales_Part_API.Exist(header_rec_.contract, catalog_no_, usage_);
   catalog_type_  := Sales_Part_API.Get_Catalog_Type_Db(header_rec_.contract, catalog_no_);
   
   IF NVL(part_replacement_allowed_, 1) = 1 THEN
      Handle_Replacement_Part___(catalog_no_,
                                 org_catalog_no_,
                                 header_rec_.contract,
                                 TRUE );
                                 
      IF (catalog_type_ = 'PKG') THEN
        FOR pcrec_ IN get_pkg_components(header_rec_.contract, catalog_no_) LOOP
           component_part_no_ := pcrec_.catalog_no;
           Handle_Replacement_Part___(component_part_no_,
                                      org_catalog_no_,
                                      header_rec_.contract,
                                      TRUE );
           org_catalog_no_    := NULL;
           component_part_no_ := NULL;
        END LOOP;
     END IF;                                
   END IF;


   sales_part_rec_  := Sales_Part_API.Get(header_rec_.contract, catalog_no_);
   
   -- fetch catalog description from the cross reference
   customer_part_no_ := Sales_Part_Cross_Reference_API.Get_Customer_Part_No(header_rec_.customer_no, header_rec_.contract, catalog_no_);
   IF (customer_part_no_ IS NOT NULL) THEN
      cross_rec_                 := Sales_Part_Cross_Reference_API.Get(header_rec_.customer_no, header_rec_.contract, customer_part_no_);
      customer_part_conv_factor_ := greatest(NVL(cross_rec_.conv_factor, 1), 0);
      cust_part_inver_conv_fact_ := greatest(NVL(cross_rec_.inverted_conv_factor, 1), 0);
      customer_part_unit_meas_   := NVL(cross_rec_.customer_unit_meas, sales_part_rec_.sales_unit_meas);
   ELSE
      customer_part_conv_factor_ := NULL;
      customer_part_unit_meas_   := NULL;
      cust_part_inver_conv_fact_ := NULL;
   END IF;

   -- cross_rec_ may be NULL - But that does not generate any errors
   IF (cross_rec_.receiving_advice_type != 'USE_CUSTOMER_DEFAULT') THEN
      receiving_advice_type_ := Receiving_Advice_Type_API.Decode(cross_rec_.receiving_advice_type);
   ELSE
      receiving_advice_type_ := Cust_Ord_Customer_API.Get_Receiving_Advice_Type(header_rec_.customer_no);
   END IF;
   IF (rental_db_ = Fnd_Boolean_API.DB_FALSE) THEN
      self_billing_db_ := NVL(Sales_Part_Cross_Reference_API.Get_Self_Billing_Db(header_rec_.customer_no, header_rec_.contract, customer_part_no_), 'NOT SELF BILLING');
   ELSE
      self_billing_db_ := Self_Billing_Type_API.DB_NOT_SELF_BILLING;
   END IF;
   
   condition_code_ := NULL;
   IF (sales_part_rec_.part_no IS NOT NULL) THEN
      IF (Part_Catalog_API.Get_Condition_Code_Usage_Db(sales_part_rec_.part_no) = 'ALLOW_COND_CODE') THEN
         condition_code_ := Client_SYS.Get_Item_Value('CONDITION_CODE', attr_);         
      END IF;
   END IF;
   
   supply_code_client_ := Client_SYS.Get_Item_Value('SUPPLY_CODE', attr_);
   supply_code_        := Client_SYS.Get_Item_Value('SUPPLY_CODE_DB', attr_);
   
   sales_unit_meas_ := sales_part_rec_.sales_unit_meas;
   purchase_part_no_ := sales_part_rec_.purchase_part_no;
   configured_db_ := Part_Catalog_API.Get_Configurable_Db(nvl(sales_part_rec_.part_no, catalog_no_));
   
   Customer_Order_Line_API.Validate_Cust_Ord_Lin_Defaults( catalog_no_, catalog_desc_, supply_code_, vendor_no_,
                                       supply_site_, condition_code_, supply_code_client_, header_rec_.contract, header_rec_.language_code,
                                       header_rec_.customer_no, demand_code_, purchase_part_no_, configured_db_, sales_part_rec_.part_no, 
                                       sales_part_rec_.sourcing_option, created_by_server_, rental_db_);

   demand_order_ref_ := Client_SYS.Get_Item_Value('DEMAND_ORDER_REF1', attr_);

   IF NOT (Is_External_Service_Order___(demand_code_, demand_order_ref_) = 'TRUE') THEN
      -- Check if it's a activ inventory part.
      Check_Active_Part___(header_rec_.contract, sales_part_rec_.part_no);
   END IF;

   -- Logic for Consignment stock
   consignment_stock_ := NVL(Consignment_Stock_API.Encode(Customer_Consignment_Stock_API.Get_Consignment_Stock(header_rec_.contract, catalog_no_,
                             header_rec_.customer_no, header_rec_.ship_addr_no)), 'NO CONSIGNMENT STOCK');

   line_item_no_       := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('LINE_ITEM_NO', attr_));
   activity_seq_       := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('ACTIVITY_SEQ', attr_));
   IF (line_item_no_ > 0 AND activity_seq_ > 0 AND supply_code_ NOT IN ('PD','IPD', 'SO', 'PT', 'ND', 'IPT', 'DOP','SEO') ) THEN
      IF (catalog_type_ ='INV') THEN
         supply_code_ := 'PI';
      ELSIF (catalog_type_ ='NON') THEN
         supply_code_ := 'PRJ';
      END IF;
   END IF;
   
  value_ := Client_SYS.Get_Item_Value('CHARGED_ITEM_DB', attr_);
  IF (value_ IS NOT NULL) THEN
     charged_item_ := value_;
  END IF;
  value_ := Client_SYS.Get_Item_Value('CHARGED_ITEM', attr_);
  IF (value_ IS NOT NULL) THEN
     charged_item_ := Charged_Item_API.Encode(value_);
  END IF;

  revised_qty_due_ := buy_qty_due_ * sales_part_rec_.conv_factor / sales_part_rec_.inverted_conv_factor;
  -- Logic for Cost
   IF (sales_part_rec_.part_no IS NULL) THEN
      cost_ := sales_part_rec_.cost;
   ELSE
      configuration_id_ := NVL(Client_SYS.Get_Item_Value('CONFIGURATION_ID', attr_),'*');

      IF (revised_qty_due_ IS NOT NULL) THEN
         cost_ := Sales_Cost_Util_API.Get_Cost_Incl_Sales_Overhead(header_rec_.contract,
                                                                   sales_part_rec_.part_no,
                                                                   configuration_id_,
                                                                   condition_code_,
                                                                   revised_qty_due_,
                                                                   charged_item_,
                                                                   supply_code_,
                                                                   header_rec_.customer_no,
                                                                   'COMPANY OWNED');
      END IF;
   END IF;

   inv_part_rec_ := Inventory_Part_API.Get(header_rec_.contract, sales_part_rec_.part_no);
   -- Only fetch dop_connection when supply code = 'DOP'
   IF (supply_code_ = 'DOP') THEN
      dop_connection_ := Dop_Connection_API.Decode(inv_part_rec_.dop_connection); 
   END IF;

   IF (supply_code_ IN ('IPT', 'IPD')) THEN

      IF (Inventory_Part_API.Part_Exist(supply_site_, nvl(sales_part_rec_.part_no, purchase_part_no_)) = 1) THEN

         -- check if a security connection exists between the CO/PO Site (Demand site) and the Supply Site
         IF (Site_To_Site_Reserve_Setup_API.Connection_Allowed(supply_site_, header_rec_.contract) = 1) THEN
            supply_site_reserve_type_ := Site_To_Site_Reserve_Setup_API.Get_Supply_Site_Reserve_Db(supply_site_, header_rec_.contract);
         END IF;
      END IF;
      IF (supply_site_ IS NOT NULL AND rental_db_ = Fnd_Boolean_API.DB_TRUE) THEN
         IF (Site_API.Get_Company(supply_site_) = header_contract_conected_comp_) THEN
            part_ownership_db_ := Part_Ownership_API.DB_COMPANY_RENTAL_ASSET;
         ELSE
            part_ownership_db_ := Part_Ownership_API.DB_SUPPLIER_RENTED;
         END IF;
      END IF;
   END IF;
   IF (supply_code_ = 'PT' AND rental_db_ = Fnd_Boolean_API.DB_TRUE) THEN
      part_ownership_db_ := Part_Ownership_API.DB_SUPPLIER_RENTED;
   END IF;
   -- if supply_site_reserve_type_ still is NULL set it to Not Allowed
   IF (supply_site_reserve_type_ IS NULL) THEN
      supply_site_reserve_type_ := 'NOTALLOWED';
   END IF;

   IF demand_code_ = 'WO' THEN
      value_ := Client_SYS.Get_Item_Value('PRICE_LIST_NO', attr_);
   END IF;

   IF value_ IS NOT NULL THEN
      price_list_no_ := value_;
   ELSE
      -- Find default price list.
      Sales_Price_List_API.Get_Valid_Price_List(customer_level_db_,        customer_level_id_,  price_list_no_,
                                                header_rec_.contract,      catalog_no_,         header_rec_.customer_no,
                                                header_rec_.currency_code, effectivity_date_,   NULL ,
                                                sales_price_type_db_);
   END IF;

   -- For CO lines created from WO (with or without connected to service contract), CRO and Service contract will have price source set to Service Price
   -- The discount is set to zero, but if discounts are sent in from WO or SEC they will be applied later in the code.
   IF (supply_code_ = 'SEO') THEN
      discount_        := 0;
      price_source_    := Pricing_Source_API.Decode('SERVICEPRICE');
      price_source_id_ := NULL;
      
      IF (demand_code_ = 'FSM' AND  base_sale_unit_price_ IS NULL) THEN
         Customer_Order_Pricing_API.Get_Base_Price_In_Currency( base_sale_unit_price_,
                                                                currency_rate_,
                                                                NVL(header_rec_.customer_no_pay, header_rec_.customer_no),
                                                                header_rec_.contract,
                                                                header_rec_.currency_code,
                                                                sale_unit_price_,
                                                                NVL(header_rec_.currency_rate_type, Currency_Type_API.Get_Default_Type(header_contract_conected_comp_, 'CUSTOMER')));
      END IF;   
   ELSIF (buy_qty_due_ IS NOT NULL) THEN
      -- Find prices, currency and discount.
      Customer_Order_Pricing_API.Get_Order_Line_Price_Info(sale_unit_price_,      unit_price_incl_tax_,  base_sale_unit_price_, base_unit_price_incl_tax_,
                                                           currency_rate_,        discount_,             price_source_,         price_source_id_,
                                                           provisional_price_db_, net_price_fetched_,    rebate_builder_db_,    part_level_db_,
                                                           part_level_id_,        customer_level_db_,    customer_level_id_,    order_no_,
                                                           catalog_no_,           buy_qty_due_,          price_list_no_,        effectivity_date_,
                                                           condition_code_,       header_rec_.use_price_incl_tax,               rental_chargeable_days_);
   END IF;

   tax_code_  := Client_SYS.Get_Item_Value('TAX_CODE', attr_);
   tax_class_ := Client_SYS.Get_Item_Value('TAX_CLASS_ID', attr_);
   free_of_charge_db_ := Client_SYS.Get_Item_Value('FREE_OF_CHARGE_DB', attr_);
   -- Return all defaults using the attribute string.
   Client_SYS.Clear_Attr(attr_);

   IF (org_catalog_no_ IS NOT NULL) THEN
      -- The part has been replaced
      Client_SYS.Add_To_Attr('ORIGINAL_PART_NO', org_catalog_no_, attr_);
   END IF;

   sm_object_option_ := sales_part_rec_.create_sm_object_option;

   -- IF the supply code is MRO create_sm_object_option should be unchecked.
   IF (supply_code_ = 'MRO') THEN
      sm_object_option_ := 'DONOTCREATESMOBJECT';
   END IF;

   Client_SYS.Add_To_Attr('CATALOG_DESC', catalog_desc_, attr_);

   Client_SYS.Add_To_Attr('CUSTOMER_PART_NO', customer_part_no_, attr_);
   Client_SYS.Add_To_Attr('CUSTOMER_PART_CONV_FACTOR', customer_part_conv_factor_, attr_);
   Client_SYS.Add_To_Attr('CUSTOMER_PART_UNIT_MEAS', customer_part_unit_meas_, attr_);

   Client_SYS.Add_To_Attr('BUY_QTY_DUE', buy_qty_due_, attr_);
   Client_SYS.Add_To_Attr('REVISED_QTY_DUE', buy_qty_due_ * sales_part_rec_.conv_factor / sales_part_rec_.inverted_conv_factor, attr_);
   Client_SYS.Add_To_Attr('CURRENCY_RATE', currency_rate_, attr_);
   Client_SYS.Add_To_Attr('CONV_FACTOR', sales_part_rec_.conv_factor, attr_);
   Client_SYS.Add_To_Attr('DELIVERY_TYPE', sales_part_rec_.delivery_type, attr_);
   Client_SYS.Add_To_Attr('PRICE_CONV_FACTOR', sales_part_rec_.price_conv_factor, attr_);
   Client_SYS.Add_To_Attr('SALE_UNIT_PRICE', sale_unit_price_, attr_);
   Client_SYS.Add_To_Attr('UNIT_PRICE_INCL_TAX', unit_price_incl_tax_, attr_);
   Client_SYS.Add_To_Attr('BASE_SALE_UNIT_PRICE', base_sale_unit_price_, attr_);
   Client_SYS.Add_To_Attr('BASE_UNIT_PRICE_INCL_TAX', base_unit_price_incl_tax_, attr_);
   Client_SYS.Add_To_Attr('SALES_UNIT_MEAS', sales_part_rec_.sales_unit_meas, attr_);
   IF (NVL(free_of_charge_db_, 'FALSE') = 'FALSE') THEN 
      Client_SYS.Add_To_Attr('DISCOUNT', discount_, attr_);
   END IF;
   Client_SYS.Add_To_Attr('COST', NVL(cost_, 0), attr_);
   Client_SYS.Add_To_Attr('PART_NO', sales_part_rec_.part_no, attr_);
   IF supply_code_ IS NOT NULL THEN
      supply_code_client_ := Order_Supply_Type_API.Decode(supply_code_);
   END IF;
   Client_SYS.Add_To_Attr('SUPPLY_CODE', supply_code_client_, attr_);
   Client_SYS.Add_To_Attr('CATALOG_TYPE', Sales_Part_Type_API.Decode(sales_part_rec_.catalog_type), attr_);
   Client_SYS.Add_To_Attr('VENDOR_NO', vendor_no_, attr_);
   Client_SYS.Add_To_Attr('CONSIGNMENT_STOCK_DB', consignment_stock_, attr_);
   Client_SYS.Add_To_Attr('CLOSE_TOLERANCE', sales_part_rec_.close_tolerance, attr_);
   Client_SYS.Add_To_Attr('PRICE_LIST_NO', price_list_no_, attr_);
   Client_SYS.Add_To_Attr('CHARGED_ITEM_DB', 'CHARGED ITEM', attr_);
   IF (rental_db_ = Fnd_Boolean_API.DB_FALSE) THEN
      Client_SYS.Add_To_Attr('CREATE_SM_OBJECT_OPTION_DB', sm_object_option_, attr_);
   END IF;
   Client_SYS.Add_To_Attr('STAGED_BILLING_DB', 'NOT STAGED BILLING', attr_);
   IF (dop_connection_ IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('DOP_CONNECTION', dop_connection_, attr_);
   END IF;
   Client_SYS.Add_To_Attr('PURCHASE_PART_NO', purchase_part_no_, attr_);
   IF (header_rec_.use_price_incl_tax = Fnd_Boolean_API.DB_TRUE) THEN
      Client_SYS.Add_To_Attr('PART_PRICE', unit_price_incl_tax_, attr_);
   ELSE
      Client_SYS.Add_To_Attr('PART_PRICE', sale_unit_price_, attr_);
   END IF;
   Client_SYS.Add_To_Attr('PRICE_SOURCE', price_source_, attr_);
   Client_SYS.Add_To_Attr('PRICE_SOURCE_ID', price_source_id_, attr_);
   Client_SYS.Add_to_Attr('PROVISIONAL_PRICE_DB', provisional_price_db_, attr_);
   Client_SYS.Add_To_Attr('PRICE_SOURCE_NET_PRICE_DB', net_price_fetched_, attr_);
   Client_SYS.Add_To_Attr('CONDITION_CODE', condition_code_ , attr_);
   Client_SYS.Add_To_Attr('SUPPLY_SITE_RESERVE_TYPE_DB', supply_site_reserve_type_, attr_);
   Client_SYS.Add_To_Attr('SUPPLY_SITE_RESERVE_TYPE', Supply_Site_Reserve_Type_API.Decode(supply_site_reserve_type_), attr_);
   Client_SYS.Add_To_Attr('SELF_BILLING_DB', self_billing_db_, attr_);
   Client_SYS.Add_To_Attr('SELF_BILLING', Self_Billing_Type_API.Decode(self_billing_db_), attr_);
   Client_SYS.Add_To_Attr('RECEIVING_ADVICE_TYPE', receiving_advice_type_, attr_);
   Client_SYS.Add_To_Attr('REBATE_BUILDER_DB', rebate_builder_db_, attr_);
   Client_SYS.Add_To_Attr('PART_LEVEL_DB', part_level_db_, attr_);
   Client_SYS.Add_To_Attr('PART_LEVEL_ID', part_level_id_, attr_);
   Client_SYS.Add_To_Attr('CUSTOMER_LEVEL_DB', customer_level_db_, attr_);
   Client_SYS.Add_To_Attr('CUSTOMER_LEVEL_ID', customer_level_id_, attr_);

   Client_SYS.Add_To_Attr('TAX_CODE', tax_code_, attr_);
   Client_SYS.Add_To_Attr('TAX_CLASS_ID', tax_class_, attr_);
   Client_SYS.Add_To_Attr('INVERTED_CONV_FACTOR', sales_part_rec_.inverted_conv_factor, attr_);
   Client_SYS.Add_To_Attr('RENTAL_DB', rental_db_, attr_);
   Client_SYS.Add_To_Attr('CUST_PART_INVERT_CONV_FACT', cust_part_inver_conv_fact_, attr_);
   -- gelr: acquisition_origin, begin
   Client_SYS.Add_To_Attr('ACQUISITION_ORIGIN', sales_part_rec_.acquisition_origin, attr_);
   -- gelr: acquisition_origin, end
   -- gelr:good_service_statistical_code, begin
   Client_SYS.Add_To_Attr('STATISTICAL_CODE', sales_part_rec_.statistical_code, attr_);
   -- gelr:good_service_statistical_code, end
   -- gelr:brazilian_specific_attributes, begin
   Client_SYS.Add_To_Attr('ACQUISITION_REASON_ID', NVL(Business_Transaction_Id_API.Get_Acquisition_Reason_Id(header_contract_conected_comp_, header_rec_.business_transaction_id), 
                                                       sales_part_rec_.acquisition_reason_id), attr_);
   -- gelr:brazilian_specific_attributes, end
   IF (supply_site_ IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('SUPPLY_SITE', supply_site_, attr_);
   END IF;
   IF (part_ownership_db_ IS NOT NULL) THEN
      Client_SYS.Add_To_Attr('PART_OWNERSHIP', Part_Ownership_API.Decode(part_ownership_db_), attr_);
   END IF;

   IF buy_qty_due_ IS NULL THEN
      input_unit_meas_group_id_ := inv_part_rec_.input_unit_meas_group_id;
      IF input_unit_meas_group_id_ IS NOT NULL AND demand_code_ IS NULL THEN
         default_input_uom_ := Input_Unit_Meas_API.Get_Default_Input_Uom(input_unit_meas_group_id_);
         IF default_input_uom_ IS NOT NULL THEN
            uom_rec_ := Input_Unit_Meas_API.Get(input_unit_meas_group_id_, default_input_uom_);
            IF (uom_rec_.cust_usage_allowed = 1) THEN
               Client_SYS.Add_To_Attr('INPUT_UNIT_MEAS', default_input_uom_, attr_);
               Client_SYS.Add_To_Attr('INPUT_CONV_FACTOR', uom_rec_.conversion_factor, attr_);
            END IF;
         END IF;
      END IF;
   END IF;

    IF (Fnd_Session_API.Is_Odp_Session) THEN
         Client_SYS.Add_To_Attr('PRICE_UNIT_MEAS', sales_part_rec_.price_unit_meas, attr_);
         IF header_rec_.limit_sales_to_assortments = 'TRUE' THEN
            suggested_exists_ := Suggested_Sales_Part_API.Limit_Suggest_Part_Exists(header_rec_.contract, catalog_no_);
         ELSE
            suggested_exists_ := Suggested_Sales_Part_API.Suggested_Sales_Part_Exists(header_rec_.contract, catalog_no_);                                
         END IF;
         Client_SYS.Add_To_Attr('SUGGESTED_PART_EXISTS', suggested_exists_, attr_);
         Client_SYS.Add_To_Attr('SERIAL_TRACKING', Part_Catalog_API.Get_Rcpt_Issue_Serial_Track_Db(sales_part_rec_.part_no), attr_);
         Client_SYS.Add_To_Attr('INPUT_UNIT_MEAS_GROUP_ID', input_unit_meas_group_id_, attr_);  
         Client_SYS.Add_To_Attr('INPUT_UOM_GROUP', Input_Unit_meas_Group_API.Is_Usage_Allowed(input_unit_meas_group_id_, 'ORDER'), attr_);
         Client_SYS.Add_To_Attr('COST_LEVEL', Inventory_Part_API.Get_Invent_Part_Cost_Level_Db(header_rec_.contract, sales_part_rec_.part_no), attr_);
         Client_SYS.Add_To_Attr('GTIN', Sales_Part_API.Get_Gtin_No(header_rec_.contract, catalog_no_, default_input_uom_), attr_);
         Client_SYS.Add_To_Attr('CATALOG_TYPE_DB', sales_part_rec_.catalog_type, attr_);
         Client_SYS.Add_To_Attr('SUPPLY_CODE_DB', supply_code_, attr_);
         Client_SYS.Add_To_Attr('PRICE_SOURCE_DB', Pricing_Source_API.Encode(price_source_), attr_);
         IF addr_flag_ = 'Y'  THEN
            packing_instruction_id_ := Def_Pack_Instruct_Shipment_API.Get_Packing_Instruction_Id(header_rec_.contract, catalog_no_, deliver_to_customer_no_, NULL);
         ELSE 
            packing_instruction_id_ := Def_Pack_Instruct_Shipment_API.Get_Packing_Instruction_Id(header_rec_.contract, catalog_no_, deliver_to_customer_no_, ship_addr_no_);
         END IF;
         Client_SYS.Add_To_Attr('PACKING_INSTRUCTION_ID', packing_instruction_id_, attr_);
      ELSE
         NULL;  
      END IF;
END Get_Line_Defaults___;

-- Get_Default_Part_Attributes___
--   Retrieve the default attributes for the sales part or customer part
--   passed in the attribute string.
--   Merge the default attributes with the attr_ parameter.
PROCEDURE Get_Default_Part_Attributes___ (
   attr_                     IN OUT VARCHAR2,
   part_replacement_allowed_ IN     NUMBER )
IS
   order_no_                  CUSTOMER_ORDER_LINE_TAB.order_no%TYPE;
   contract_                  CUSTOMER_ORDER_LINE_TAB.contract%TYPE;
   buy_qty_due_               CUSTOMER_ORDER_LINE_TAB.buy_qty_due%TYPE;
   catalog_no_                CUSTOMER_ORDER_LINE_TAB.catalog_no%TYPE;
   catalog_desc_              CUSTOMER_ORDER_LINE_TAB.catalog_desc%TYPE;
   customer_no_               CUSTOMER_ORDER_LINE_TAB.customer_no%TYPE;
   customer_part_no_          CUSTOMER_ORDER_LINE_TAB.customer_part_no%TYPE;
   customer_part_buy_qty_     CUSTOMER_ORDER_LINE_TAB.customer_part_buy_qty%TYPE;
   customer_part_conv_factor_ CUSTOMER_ORDER_LINE_TAB.customer_part_conv_factor%TYPE;
   customer_part_unit_meas_   CUSTOMER_ORDER_LINE_TAB.customer_part_unit_meas%TYPE;
   customer_part_desc_        CUSTOMER_ORDER_LINE_TAB.catalog_desc%TYPE;
   base_sale_unit_price_      CUSTOMER_ORDER_LINE_TAB.base_sale_unit_price%TYPE;
   base_unit_price_incl_tax_  CUSTOMER_ORDER_LINE_TAB.base_unit_price_incl_tax%TYPE;
   sale_unit_price_           CUSTOMER_ORDER_LINE_TAB.sale_unit_price%TYPE;
   unit_price_incl_tax_       CUSTOMER_ORDER_LINE_TAB.unit_price_incl_tax%TYPE;
   cross_rec_                 SALES_PART_CROSS_REFERENCE_API.Public_Rec;
   default_attr_              VARCHAR2(2000);
   ptr_                       NUMBER;
   name_                      VARCHAR2(30);
   value_                     VARCHAR2(4000);
   header_rec_                CUSTOMER_ORDER_API.Public_Rec;
   currency_rate_             NUMBER;
   packing_instruction_id_    VARCHAR2(50);
   supply_code_               CUSTOMER_ORDER_LINE_TAB.supply_code%TYPE;
   cust_part_invert_conv_fact_ CUSTOMER_ORDER_LINE_TAB.cust_part_invert_conv_fact%TYPE;
BEGIN
   order_no_         := Client_SYS.Get_Item_Value('ORDER_NO', attr_);
   header_rec_       := CUSTOMER_ORDER_API.Get(order_no_);

   customer_part_no_ := Client_SYS.Get_Item_Value('CUSTOMER_PART_NO', attr_);
   catalog_no_       := Client_SYS.Get_Item_Value('CATALOG_NO', attr_);
   catalog_desc_     := Client_SYS.Get_Item_Value('CATALOG_DESC', attr_);
   value_            := Client_SYS.Get_Item_Value('BUY_QTY_DUE', attr_);

   IF (value_ IS NOT NULL) THEN
      buy_qty_due_ := Client_SYS.Attr_Value_To_Number(value_);
   END IF;

   value_ := Client_SYS.Get_Item_Value('CUSTOMER_PART_BUY_QTY', attr_);
   IF (value_ IS NOT NULL) THEN
      customer_part_buy_qty_ := Client_SYS.Attr_Value_To_Number(value_);
   END IF;

   value_ := Client_SYS.Get_Item_Value('SALE_UNIT_PRICE', attr_);
   IF (value_ IS NOT NULL) THEN
      sale_unit_price_ := Client_SYS.Attr_Value_To_Number(value_);
   END IF;

   value_ := Client_SYS.Get_Item_Value('UNIT_PRICE_INCL_TAX', attr_);
   IF (value_ IS NOT NULL) THEN
      unit_price_incl_tax_ := Client_SYS.Attr_Value_To_Number(value_);
   END IF;

   value_ := Client_SYS.Get_Item_Value('BASE_SALE_UNIT_PRICE', attr_);
   IF (value_ IS NOT NULL) THEN
      base_sale_unit_price_ := Client_SYS.Attr_Value_To_Number(value_);
   END IF;

   value_ := Client_SYS.Get_Item_Value('BASE_UNIT_PRICE_INCL_TAX', attr_);
   IF (value_ IS NOT NULL) THEN
      base_unit_price_incl_tax_ := Client_SYS.Attr_Value_To_Number(value_);
   END IF;

   customer_no_ := header_rec_.customer_no;
   contract_    := header_rec_.contract;

   -- IF a customer part number has been specified then check the sales part cross reference.
   IF (customer_part_no_ IS NOT NULL) THEN
      Sales_Part_Cross_Reference_API.Exist(customer_no_, contract_, customer_part_no_);
      cross_rec_               := Sales_Part_Cross_Reference_API.Get(customer_no_, contract_, customer_part_no_);
      catalog_no_              := cross_rec_.catalog_no;
      customer_part_unit_meas_ := cross_rec_.customer_unit_meas;
      IF (catalog_desc_ IS NULL) THEN
         customer_part_desc_ := cross_rec_.catalog_desc;
      END IF;
      IF (customer_part_buy_qty_ IS NOT NULL) THEN
         customer_part_conv_factor_ := cross_rec_.conv_factor;
         cust_part_invert_conv_fact_ := cross_rec_.inverted_conv_factor;
         IF (customer_part_conv_factor_ IS NOT NULL AND cust_part_invert_conv_fact_ IS NOT NULL) THEN
            buy_qty_due_ := (customer_part_buy_qty_ * customer_part_conv_factor_) / cust_part_invert_conv_fact_;
         ELSE
            buy_qty_due_ := customer_part_buy_qty_;
         END IF;
      END IF;
   END IF;

   Client_SYS.Clear_Attr(default_attr_);
   Client_SYS.Set_Item_Value('BUY_QTY_DUE', buy_qty_due_, default_attr_);

   value_ := Client_SYS.Get_Item_Value('DEMAND_CODE', attr_);
   IF (value_ IS NOT NULL) THEN
      Client_SYS.Set_Item_Value('DEMAND_CODE', value_, default_attr_);
   END IF;
   value_ := Client_SYS.Get_Item_Value('DEMAND_CODE_DB', attr_);
   IF (value_ IS NOT NULL) THEN
      Client_SYS.Set_Item_Value('DEMAND_CODE_DB', value_, default_attr_);
   END IF;
   value_ := Client_SYS.Get_Item_Value('PRICE_LIST_NO', attr_);
   IF (value_ IS NOT NULL) THEN
      Client_SYS.Set_Item_Value('PRICE_LIST_NO', value_, default_attr_);
   END IF;
   value_ := Client_SYS.Get_Item_Value('CHARGED_ITEM_DB', attr_);
   IF (value_ IS NOT NULL) THEN
      Client_SYS.Set_Item_Value('CHARGED_ITEM_DB', value_, default_attr_);
   END IF;
   value_ := Client_SYS.Get_Item_Value('CHARGED_ITEM', attr_);
   IF (value_ IS NOT NULL) THEN
      Client_SYS.Set_Item_Value('CHARGED_ITEM', value_, default_attr_);
   END IF;
   value_ := Client_SYS.Get_Item_Value('DEMAND_ORDER_REF1', attr_);
   IF (value_ IS NOT NULL) THEN
      Client_SYS.Set_Item_Value('DEMAND_ORDER_REF1', value_, default_attr_);
   END IF;
   value_ := Client_SYS.Get_Item_Value('FREE_OF_CHARGE_DB', attr_);
   IF (value_ IS NOT NULL) THEN
      Client_SYS.Set_Item_Value('FREE_OF_CHARGE_DB', value_, default_attr_);
   END IF;
   supply_code_ := Client_SYS.Get_Item_Value('SUPPLY_CODE_DB', attr_);

   -- Add supply_code and price effectivity date to attribute string to get correct default values
   Client_SYS.Set_Item_Value('SUPPLY_CODE_DB', supply_code_, default_attr_);
   Client_SYS.Set_Item_Value('PRICE_EFFECTIVITY_DATE', (Client_SYS.Get_Item_Value('PRICE_EFFECTIVITY_DATE', attr_)), default_attr_);
   Client_SYS.Set_Item_Value('CONDITION_CODE', (Client_SYS.Get_Item_Value('CONDITION_CODE', attr_)), default_attr_);
   Client_SYS.Set_Item_Value('CREATED_BY_SERVER', (Client_SYS.Get_Item_Value('CREATED_BY_SERVER', attr_)), default_attr_);

   -- Add rental_db value to check for valid and active sales part.
   Client_SYS.Set_Item_Value('RENTAL_DB', (Client_SYS.Get_Item_Value('RENTAL_DB', attr_)), default_attr_);
   
   Get_Line_Defaults___(default_attr_, catalog_no_, order_no_, part_replacement_allowed_);

   -- Check if a price was passed with the attribute string.
   -- IF that was the case this price should override the default price
   IF (header_rec_.use_price_incl_tax = 'TRUE') THEN
      IF (supply_code_ = 'SEO' AND (base_unit_price_incl_tax_ IS NULL AND unit_price_incl_tax_ IS NULL) ) THEN
         unit_price_incl_tax_      := sale_unit_price_;
         base_unit_price_incl_tax_ := base_sale_unit_price_;
      END IF;

      IF (unit_price_incl_tax_ IS NOT NULL) THEN
         -- Get the corresponding base sale unit price
         Customer_Order_Pricing_API.Get_Base_Price_In_Currency(base_unit_price_incl_tax_, currency_rate_,
                                                               NVL(header_rec_.customer_no_pay, header_rec_.customer_no),
                                                               contract_,header_rec_.currency_code, unit_price_incl_tax_,
                                                               header_rec_.currency_rate_type); 
         Client_SYS.Set_Item_Value('BASE_UNIT_PRICE_INCL_TAX', base_unit_price_incl_tax_, default_attr_);
         -- Since use_price_incl_tax is true, price calculation base will be gross amounts. but calculate_price() will call later.
         Client_SYS.Set_Item_Value('BASE_SALE_UNIT_PRICE', base_unit_price_incl_tax_, default_attr_);
         Client_SYS.Set_Item_Value('SALE_UNIT_PRICE', unit_price_incl_tax_, default_attr_);
         
         Client_SYS.Set_Item_Value('PROVISIONAL_PRICE_DB', 'FALSE', default_attr_);
         IF (supply_code_ = 'SEO') THEN
            Client_SYS.Set_Item_Value('PART_PRICE', unit_price_incl_tax_, default_attr_);
            Client_SYS.Set_Item_Value('CURRENCY_RATE', currency_rate_, default_attr_);
         END IF;
      ELSIF (base_unit_price_incl_tax_ IS NOT NULL) THEN
         -- Get the corresponding sale unit price
         Customer_Order_Pricing_API.Get_Sales_Price_In_Currency(unit_price_incl_tax_, currency_rate_, NVL(header_rec_.customer_no_pay, header_rec_.customer_no),
                                                                contract_, header_rec_.currency_code, base_unit_price_incl_tax_, header_rec_.currency_rate_type);
         Client_SYS.Set_Item_Value('UNIT_PRICE_INCL_TAX', unit_price_incl_tax_, default_attr_);
         -- Since use_price_incl_tax is true, price calculation base will be gross amounts. but calculate_price() will call later.
         Client_SYS.Set_Item_Value('SALE_UNIT_PRICE', unit_price_incl_tax_, default_attr_);
         Client_SYS.Set_Item_Value('BASE_SALE_UNIT_PRICE', base_unit_price_incl_tax_, default_attr_);
         
         Client_SYS.Set_Item_Value('PROVISIONAL_PRICE_DB', 'FALSE', default_attr_);
         IF (supply_code_ = 'SEO') THEN
            Client_SYS.Set_Item_Value('BASE_UNIT_PRICE_INCL_TAX', base_unit_price_incl_tax_, default_attr_);
            Client_SYS.Set_Item_Value('PART_PRICE', unit_price_incl_tax_, default_attr_);
            Client_SYS.Set_Item_Value('CURRENCY_RATE', currency_rate_, default_attr_);
         END IF;
      END IF;

      IF (customer_part_desc_ IS NOT NULL) THEN
         Client_SYS.Set_Item_Value('CATALOG_DESC', customer_part_desc_, default_attr_);
      END IF;
   ELSE
      IF (sale_unit_price_ IS NOT NULL) THEN
         -- Get the corresponding base sale unit price
         Customer_Order_Pricing_API.Get_Base_Price_In_Currency(base_sale_unit_price_, currency_rate_,
                                                               NVL(header_rec_.customer_no_pay, header_rec_.customer_no),
                                                               contract_, header_rec_.currency_code, sale_unit_price_,
                                                               header_rec_.currency_rate_type);
         Client_SYS.Set_Item_Value('BASE_SALE_UNIT_PRICE', base_sale_unit_price_, default_attr_);
         -- Since use_price_incl_tax is false, price calculation base will be net amounts. but calculate_price() will call later.
         Client_SYS.Set_Item_Value('BASE_UNIT_PRICE_INCL_TAX', base_sale_unit_price_, default_attr_);
         Client_SYS.Set_Item_Value('UNIT_PRICE_INCL_TAX', sale_unit_price_, default_attr_);
         
         Client_SYS.Set_Item_Value('PROVISIONAL_PRICE_DB', 'FALSE', default_attr_);
         IF (supply_code_ = 'SEO') THEN
            Client_SYS.Set_Item_Value('PART_PRICE', sale_unit_price_, default_attr_);
            Client_SYS.Set_Item_Value('CURRENCY_RATE', currency_rate_, default_attr_);
         END IF;
      ELSIF (base_sale_unit_price_ IS NOT NULL) THEN
         -- Get the corresponding sale unit price
         Customer_Order_Pricing_API.Get_Sales_Price_In_Currency(sale_unit_price_, currency_rate_, NVL(header_rec_.customer_no_pay, header_rec_.customer_no),
                                                                contract_, header_rec_.currency_code, base_sale_unit_price_, header_rec_.currency_rate_type);
         Client_SYS.Set_Item_Value('SALE_UNIT_PRICE', sale_unit_price_, default_attr_);
         -- Since use_price_incl_tax is false, price calculation base will be net amounts. but calculate_price() will call later.
         Client_SYS.Set_Item_Value('UNIT_PRICE_INCL_TAX', sale_unit_price_, default_attr_);
         Client_SYS.Set_Item_Value('BASE_UNIT_PRICE_INCL_TAX', base_sale_unit_price_, default_attr_);
         
         Client_SYS.Set_Item_Value('PROVISIONAL_PRICE_DB', 'FALSE', default_attr_);
         IF (supply_code_ = 'SEO') THEN
            Client_SYS.Set_Item_Value('PART_PRICE', sale_unit_price_, default_attr_);
            Client_SYS.Set_Item_Value('CURRENCY_RATE', currency_rate_, default_attr_);
         END IF;
      END IF;

      IF (customer_part_desc_ IS NOT NULL) THEN
         Client_SYS.Set_Item_Value('CATALOG_DESC', customer_part_desc_, default_attr_);
      END IF;
   END IF;
   IF (supply_code_ = 'SEO') THEN
      IF (sale_unit_price_ IS NOT NULL) THEN
         Client_SYS.Set_Item_Value('PART_PRICE', sale_unit_price_, default_attr_);
      END IF;
      Client_SYS.Set_Item_Value('CURRENCY_RATE', currency_rate_, default_attr_);
   END IF;

   packing_instruction_id_ := Def_Pack_Instruct_Shipment_API.Get_Packing_Instruction_Id(contract_,
                                                                                        catalog_no_,
                                                                                        customer_no_,
                                                                                        header_rec_.ship_addr_no);
   IF (packing_instruction_id_ IS NOT NULL) THEN
      Client_SYS.Set_Item_Value('PACKING_INSTRUCTION_ID', packing_instruction_id_, default_attr_);
   END IF;

   Client_SYS.Add_To_Attr('CONTRACT', contract_, default_attr_);
   Client_SYS.Add_To_Attr('CATALOG_NO', catalog_no_, default_attr_);
   Client_SYS.Add_To_Attr('CUSTOMER_PART_UNIT_MEAS', customer_part_unit_meas_, default_attr_);
   Client_SYS.Add_To_Attr('CUSTOMER_PART_CONV_FACTOR', customer_part_conv_factor_, default_attr_);
   Client_SYS.Add_To_Attr('CUST_PART_INVERT_CONV_FACT', cust_part_invert_conv_fact_, default_attr_);

   -- Merge the default attributes with the attribute string passed in
   ptr_ := NULL;
   WHILE (Client_SYS.Get_Next_From_Attr(default_attr_, ptr_, name_, value_)) LOOP
      Client_SYS.Set_Item_Value(name_, value_, attr_);
   END LOOP;
END Get_Default_Part_Attributes___;


-- Exist_Vendor_No___
--   Dynamic call to make exist-validation for vendor_no.
PROCEDURE Exist_Vendor_No___ (
   vendor_no_        IN VARCHAR2,
   contract_         IN VARCHAR2,
   purchase_part_no_ IN VARCHAR2,
   rental_db_        IN VARCHAR2)
IS
BEGIN
   $IF (Component_Purch_SYS.INSTALLED)$THEN
      IF (purchase_part_no_ IS NOT NULL) THEN
         IF (rental_db_ = Fnd_Boolean_API.DB_FALSE) THEN
            Purchase_Part_Supplier_API.Exist(contract_, purchase_part_no_, vendor_no_, Acquisition_Type_API.DB_PURCHASE_ONLY);
         ELSE
            Purchase_Part_Supplier_API.Exist(contract_, purchase_part_no_, vendor_no_, Acquisition_Type_API.DB_RENTAL_ONLY);
         END IF;
      ELSE
         Supplier_API.Exist(vendor_no_);
      END IF;
   $ELSE
      NULL;
   $END
END Exist_Vendor_No___;


-- Validate_Vendor_Category___
--   Dynamic call for vendor_no validation.
PROCEDURE Validate_Vendor_Category___ (
   vendor_no_   IN VARCHAR2,
   supply_code_ IN VARCHAR2 )
IS
   category_ VARCHAR2(200) := NULL;
BEGIN
   $IF (Component_Purch_SYS.INSTALLED)$THEN
      category_ := Supplier_Category_API.Encode(Supplier_API.Get_Category(vendor_no_));
   $END
   Validate_Vendor_No___(vendor_no_, supply_code_, category_);
END Validate_Vendor_Category___;


-- Validate_Vendor_No___
--   Checks if the vendor_no is allowed with specified supply_code combination.
PROCEDURE Validate_Vendor_No___ (
   vendor_no_   IN VARCHAR2,
   supply_code_ IN VARCHAR2,
   category_    IN VARCHAR2 )
IS
BEGIN
   $IF Component_Purch_SYS.INSTALLED $THEN
      IF vendor_no_ IS NOT NULL THEN
         IF NOT (Supplier_API.Is_Valid(vendor_no_)) THEN
            Error_SYS.Record_General(lu_name_, 'SUPNOTVALID: The supplier :P1 expiry date has passed.', vendor_no_);
         END IF;
      END IF;
   $END
   -- Vendor_no is mandatory if using Internal Purchase supply
   IF (supply_code_ IN ('IPT', 'IPD')) THEN
      Error_SYS.Check_Not_Null(lu_name_, 'VENDOR_NO', vendor_no_);
      -- IF internal supply - internal vendor must be specified
      IF (NVL(category_, ' ') != 'I') THEN
         Error_SYS.Record_General(lu_name_, 'SUPPLIERCATEGORY: Internal supplier must be specified when supply code is Internal Purchase Order Transit/Direct.');
      END IF;
   -- IF supply code is PD or PT an external vendor must be specified
   ELSIF (supply_code_ IN ('PT', 'PD')) AND (vendor_no_ IS NOT NULL) AND (NVL(category_, ' ') != 'E') THEN
      Error_SYS.Record_General(lu_name_, 'SUPPLIERCATEGORY2: Internal supplier may not be specified when supply code is Purchase Order Transit/Direct.');
   END IF;
END Validate_Vendor_No___;


PROCEDURE Validate_Price___ (
   newrec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
BEGIN
   -- Ignored base_sale_unit_price and base_unit_price_incl_tax is less than zero for FSM created orders. 
   IF (NVL(newrec_.demand_code, ' ') != Order_Supply_Type_API.DB_FIELD_SERVICE_MANAGEMENT ) THEN
      IF ((newrec_.base_sale_unit_price < 0) OR (newrec_.sale_unit_price < 0)) THEN
         Error_SYS.Record_General(lu_name_, 'PRICE_LESS_THAN_ZERO: Price must be greater than zero!');
      END IF;

      IF ((newrec_.base_unit_price_incl_tax < 0) OR (newrec_.unit_price_incl_tax < 0)) THEN
         Error_SYS.Record_General(lu_name_, 'PRICE_INCL_TAX_LESS_THAN_ZERO: Price Including Tax must be greater than zero!');
      END IF;
   END IF;

   IF (newrec_.discount > 100) THEN
      Error_SYS.Record_General(lu_name_, 'INVALID_DISC: The total discount given cannot exceed the order line price.');
   END IF;
END Validate_Price___;


-- Add_Info___
--   Handle the info string making sure the lenght never exceeds 2000 characters
PROCEDURE Add_Info___(
   insert_package_mode_  VARCHAR2)
IS
   info_          VARCHAR2(2000);
   current_info_  VARCHAR2(32000);
BEGIN
   info_ := Client_SYS.Get_All_Info;
   -- only set the info if we are not in the insert package loop, in those cases
   -- we skip the info messages for the components
   IF (insert_package_mode_ = 'FALSE') THEN
      current_info_ := App_Context_SYS.Find_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_');
      current_info_ := SUBSTR(current_info_ || info_, 1, 2000);
      IF current_info_ IS NOT NULL THEN
         IF (SUBSTR(current_info_, 1, 4) = 'INFO') THEN
            current_info_ := SUBSTR(current_info_, 6, LENGTH(current_info_));
            current_info_ := RTRIM(current_info_, CHR(30));
         END IF;
         Client_SYS.Add_Info(lu_name_, SUBSTR(current_info_,1,1024));
         info_ := Client_SYS.Get_All_Info;
      ELSE
         info_ := current_info_;
      END IF;
      App_Context_SYS.Set_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_',info_);
   END IF;
END Add_Info___;


-- Check_Before_Insert___
--   Additional checks to execute before a new record is created.
PROCEDURE Check_Before_Insert___ (
   attr_                IN OUT VARCHAR2,
   newrec_              IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   header_curr_code_    IN     VARCHAR2 )
IS
   sales_part_rec_            Sales_Part_API.Public_Rec;
   header_rec_                Customer_Order_API.Public_Rec;
   cust_ord_cust_rec_         Cust_Ord_Customer_API.Public_Rec;
   consignment_stock_db_      VARCHAR2(20);
   company_                   VARCHAR2(20);
   sup_object_status_         VARCHAR2(200);
   supplier_acquisition_site_ VARCHAR2(5);
   customer_contract_         CUSTOMER_ORDER_LINE_TAB.contract%TYPE;
   tax_customer_no_           CUSTOMER_ORDER_LINE_TAB.customer_no%TYPE;
   tax_ship_addr_no_          CUSTOMER_ORDER_LINE_TAB.ship_addr_no%TYPE;
   pkg_catalog_group_         VARCHAR2(10) := NULL;
   cust_category_             VARCHAR2(2);
   package_part_no_           VARCHAR2(25);
   customer_company_          VARCHAR2(20);
   insert_package_mode_       VARCHAR2(5);
   sales_price_type_db_       VARCHAR2(20);
   supplier_company_          VARCHAR2(20);
   price_effective_date_      DATE;
   copy_order_line_           BOOLEAN := (NVL(Client_SYS.Get_Item_Value('COPY_ORDER_LINE', attr_), 'FALSE') = 'TRUE');

   CURSOR get_package IS
      SELECT catalog_no
      FROM  CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = newrec_.order_no
      AND   line_no = newrec_.line_no
      AND   rel_no = newrec_.rel_no
      AND   line_item_no < 0;
BEGIN
   -- checks for the line_item_no and sets parameters acordingly
   IF (newrec_.line_item_no > 0) THEN
      Sales_Part_API.Check_If_Valid_Component(newrec_.contract, newrec_.catalog_no);
      Exist_Line_No(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      IF (Fnd_Boolean_API.Encode(Get_Shipment_Connected(newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1)) = 'TRUE') THEN
         Error_SYS.Record_General(lu_name_, 'NEW_NOT_ALLOWED: Entering new Component Part(s) to the Package Part Structure not allowed when the Package Part is connected to a Shipment.');
      END IF;
      pkg_catalog_group_ := Sales_Part_API.Get_Catalog_Group(newrec_.contract, Get_Catalog_No(newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1));
   ELSE
      Exist_Line_No(newrec_.order_no, newrec_.line_no, newrec_.rel_no, NULL);
   END IF;

   -- Check if the user is allowed access to the current site
   IF NOT(newrec_.demand_code IN ('IPT','IPD')) OR (Site_Discom_Info_API.Get_Exec_Ord_Change_Online_Db(newrec_.contract) = 'FALSE') THEN
      User_Allowed_Site_API.Exist(Fnd_Session_API.Get_Fnd_User, newrec_.contract);
   END IF;

   -- Check whether supply site exists
   IF newrec_.supply_site IS NOT NULL THEN
      Site_API.Exist(newrec_.supply_site);
   END IF;

   sales_part_rec_ := Sales_Part_API.Get(newrec_.contract, newrec_.catalog_no);

   IF ((newrec_.supply_code IN ('PD', 'IPD')) AND (newrec_.consignment_stock = 'CONSIGNMENT STOCK')) THEN
      Error_SYS.Record_General(lu_name_, 'SUPPLY_CODE: Not possible to have supply code Purchase Order Direct or Internal Purchase Order Direct for Consignment Stock parts');
   END IF;

   insert_package_mode_ := Client_SYS.Get_Item_Value('INSERT_PACKAGE_MODE_', attr_);
   -- extended check on order headers delivery confirmation flag
   Validate_Delivery_Conf___(newrec_, TRUE, sales_part_rec_.catalog_group, pkg_catalog_group_, insert_package_mode_);

   IF (newrec_.catalog_desc IS NULL) THEN
      newrec_.catalog_desc := Sales_Part_API.Get_Catalog_Desc(newrec_.contract, newrec_.catalog_no);
   END IF;
   IF (newrec_.rental = Fnd_Boolean_API.DB_FALSE) THEN
      sales_price_type_db_  := Sales_Price_Type_API.DB_SALES_PRICES;
      price_effective_date_ := newrec_.price_effectivity_date;
   ELSE
      sales_price_type_db_  := Sales_Price_Type_API.DB_RENTAL_PRICES;
      price_effective_date_ := Get_Planned_Rental_Start_Dt___(attr_, newrec_);
   END IF;
   
   IF NOT(copy_order_line_) THEN
      IF (newrec_.price_list_no IS NOT NULL) THEN
         -- Check if valid
         IF ((Sales_Price_List_API.Is_Valid(newrec_.price_list_no, newrec_.contract, newrec_.catalog_no, price_effective_date_, sales_price_type_db_) = FALSE) AND
             (Sales_Price_List_API.Is_Valid_Assort(newrec_.price_list_no, newrec_.contract, newrec_.catalog_no, newrec_.price_effectivity_date) = FALSE)) OR
            (Sales_Price_List_API.Get_Sales_Price_Group_Id(newrec_.price_list_no) != sales_part_rec_.sales_price_group_id) THEN
            Error_Sys.Record_General(lu_name_, 'INVALID_PRICELIST: The selected sales price list has no valid part-based line or a valid assortment-node-based line for the sales part.');
         END IF;
      END IF;
   END IF;
   
   -- Order discount may not be >= 100%
   IF (newrec_.order_discount >= 100) THEN
      Error_SYS.Record_General(lu_name_, 'WRONGDISC: Order discount must be lower than 100%.');
   END IF;

   IF (newrec_.supply_code = 'MRO') THEN
      Validate_Mro_Line___(newrec_.part_no,newrec_.buy_qty_due,newrec_.part_ownership);
   END IF;

   company_           := Site_API.Get_Company(newrec_.contract);
   cust_ord_cust_rec_ := Cust_Ord_Customer_API.Get(newrec_.customer_no);
   customer_contract_ := cust_ord_cust_rec_.acquisition_site;
   customer_company_  := Site_API.Get_Company(customer_contract_);
   IF (newrec_.supply_code = 'IPT' OR newrec_.supply_code = 'IPD') THEN
      supplier_acquisition_site_ := Get_Vendor_Contract__(newrec_.vendor_no, NULL, NULL, NULL, NULL);
      supplier_company_          := Site_API.Get_Company(supplier_acquisition_site_);
   END IF;

   -- create SM object option check
   IF (newrec_.create_sm_object_option = 'CREATESMOBJECT') THEN
      IF (newrec_.part_no IS NULL) THEN
         Error_SYS.Record_General(lu_name_, 'SM_NOT_VALID1: The Create SM Object Option can not be set for none inventory parts.');
      ELSE
         -- receipt and issue serial tracked parts are not allowed to be package component parts for sm objects
         IF (Part_Catalog_API.Get_Rcpt_Issue_Serial_Track_Db(newrec_.part_no) = Fnd_Boolean_API.DB_TRUE) THEN
            cust_category_ := cust_ord_cust_rec_.category; 
            IF (cust_category_ = 'I') AND (NVL(customer_company_, Database_SYS.string_null_) != company_) AND (newrec_.line_item_no > 0)  THEN
               OPEN get_package;
               FETCH get_package INTO package_part_no_;
               CLOSE get_package;
               Error_SYS.Record_General(lu_name_, 'CANNOTINSERTSERIAL: You are not allowed to add serial-tracked sales part :P1 with the option to create S/M object in package part :P2 in an intersite flow between different companies.', newrec_.part_no, package_part_no_);
            END IF;
         ELSE
            -- sm objects have to always be serial parts
            Error_SYS.Record_General(lu_name_, 'SM_NOT_ALLOWED1: The Create SM Object Option can not be set on an item without serial tracking.');
         END IF;
      END IF;
   END IF;

   -- check so sup_sm_object isnt NULL when sup_sm_contract has a value
   IF (newrec_.sup_sm_contract IS NOT NULL and newrec_.sup_sm_object IS NULL) THEN
      Raise_Sm_Object_Error___;
   END IF;
   
    -- check so sup_sm_contract isnt NULL when sup_sm_object has a value
   IF (newrec_.sup_sm_contract IS NULL and newrec_.sup_sm_object IS NOT NULL) THEN
      Raise_Sm_Object_Error___;
   END IF;

   -- sup_sm_object status control
   IF (newrec_.sup_sm_contract IS NOT NULL) AND (newrec_.sup_sm_object IS NOT NULL) THEN
      $IF (Component_Equip_SYS.INSTALLED)$THEN
         sup_object_status_ := Equipment_Object_API.Get_Operational_Status_Db(newrec_.sup_sm_contract, newrec_.sup_sm_object);
         IF (sup_object_status_ = 'SCRAPPED') THEN
            Raise_Scrapped_Object_Error___(newrec_.sup_sm_object);
         END IF;
      $ELSE
         NULL;
      $END
   END IF;

   -- supply site reservation is only allowed if its a IPD or IPT
   IF (newrec_.supply_site_reserve_type != 'NOTALLOWED' AND newrec_.supply_code NOT IN ('IPD', 'IPT')) THEN
      Error_SYS.Record_General(lu_name_, 'SCRWITHINVALIDSC: A :P1 Supply Site Reservation is only valid for supply codes ":P2" and ":P3".',
                               Supply_Site_Reserve_Type_API.Decode(newrec_.supply_site_reserve_type), Order_Supply_Type_API.Decode('IPD'), Order_Supply_Type_API.Decode('IPT'));
   END IF;

   -- Negative quantity allowed if supply_code = 'Service Order'.
   IF ((newrec_.buy_qty_due <= 0) AND (newrec_.supply_code != 'SEO')) THEN
      Error_SYS.Record_General(lu_name_, 'QTY_LESS_THAN_ZERO: Quantity must be greater than zero!');
   END IF;

   IF ((newrec_.revised_qty_due < (newrec_.qty_shipped + newrec_.qty_assigned)) AND (newrec_.supply_code != 'SEO')) THEN
      Error_SYS.Record_General(lu_name_, 'QTYNOTLESS: This quantity may not be less than the sum of the reserved quantity and the delivered quantity of customer order :P1-:P2-:P3.', newrec_.order_no, newrec_.line_no, newrec_.rel_no);
   END IF;

   IF newrec_.rental = Fnd_Boolean_API.DB_TRUE THEN
      newrec_.consignment_stock := Consignment_Stock_API.DB_NO_CONSIGNMENT_STOCK;
   ELSE
      consignment_stock_db_ := newrec_.consignment_stock;

      -- get consignment delivery based on order line
      IF (newrec_.supply_code IN ('SEO', 'CRO')) AND (newrec_.part_ownership = 'CUSTOMER OWNED') THEN
         newrec_.consignment_stock := 'NO CONSIGNMENT STOCK';
      ELSIF (newrec_.customer_no = newrec_.deliver_to_customer_no) THEN
         newrec_.consignment_stock := NVL(Consignment_Stock_API.Encode(Customer_Consignment_Stock_API.Get_Consignment_Stock(newrec_.contract, newrec_.catalog_no,
                                          newrec_.customer_no, newrec_.ship_addr_no)), newrec_.consignment_stock);
      ELSE
         newrec_.consignment_stock := 'NO CONSIGNMENT STOCK';
      END IF;

      IF ((consignment_stock_db_ = 'NO CONSIGNMENT STOCK') AND (consignment_stock_db_ != newrec_.consignment_stock)) THEN
         newrec_.consignment_stock := consignment_stock_db_;
         consignment_stock_db_     := NULL;
      END IF;
      
      IF (company_ = NVL(customer_company_, Database_SYS.string_null_) AND newrec_.part_ownership = Part_Ownership_API.DB_COMPANY_RENTAL_ASSET) THEN
         Error_SYS.Record_General(lu_name_,'IPTINTERNALDELERR: The part ownership Company Rental Asset is not allowed for internal deliveries.');
      END IF;
   END IF;

   IF (newrec_.consignment_stock = 'CONSIGNMENT STOCK') THEN
      IF (newrec_.catalog_type != 'INV') THEN
         Error_SYS.Record_General(lu_name_, 'ONLY_INV_ON_CONSIGN: Consignment stock can only be used together with inventory parts.');
      ELSIF (newrec_.configuration_id != '*') THEN
         Error_SYS.Record_General(lu_name_, 'NO_CONS_FOR_CONFIG: Consignment stock can not be used for configured parts');
      ELSIF (newrec_.exchange_item = 'EXCHANGED ITEM') THEN
         Error_SYS.Record_General(lu_name_, 'NO_CONS_FOR_EXCHANGE: Consignment Stock cannot be used when the Customer Order Line has been created from a Purchase Exchange Order.');
      ELSE
         consignment_stock_db_ := Consignment_Stock_API.Encode(Customer_Consignment_Stock_API.Get_Consignment_Stock(newrec_.contract, newrec_.catalog_no,
                                                                                                                    newrec_.customer_no, newrec_.ship_addr_no));

         IF (consignment_stock_db_ IS NULL) THEN
            -- Not specified consignment stock.
            Error_SYS.Record_General(lu_name_, 'NOT_SPECIF_CONSIGN: The consignment stock can not be used for specified Customer No - Sales Part - Ship Addr No combination.');
         ELSIF (consignment_stock_db_ = 'NO CONSIGNMENT STOCK') THEN
            -- Not active consignment stock.
            Error_SYS.Record_General(lu_name_, 'NOT_ACTIVE_CONSIGN: The consignment stock is not active for specified Customer No - Sales Part - Ship Addr No combination.');
         END IF;
      END IF;
   END IF;

   IF ((newrec_.close_tolerance < 0) OR NOT (newrec_.close_tolerance < 100)) THEN
      Error_SYS.Record_General(lu_name_, 'WRONG_CLOSE_TOL: The close tolerance must be less than 100!');
   END IF;

   IF ((newrec_.charged_item = 'ITEM NOT CHARGED') AND (newrec_.consignment_stock = 'CONSIGNMENT STOCK')) THEN
      Error_SYS.Record_General(lu_name_, 'CHARGED_CONSIGN: Consignment stock can not be used together with noncharge functionality.');
   END IF;

   header_rec_ := Customer_Order_API.Get(newrec_.order_no); 
   -- Make sure the specified ship address for the order line is valid using deliver_to_customer_no and ship_addr_no on the order line.
   -- Make sure the tax information has been defined for the address of the ordering customer.
   IF (newrec_.ship_addr_no IS NOT NULL) THEN
      IF (newrec_.deliver_to_customer_no = newrec_.customer_no) THEN
         tax_customer_no_  := newrec_.deliver_to_customer_no;
         tax_ship_addr_no_ := newrec_.ship_addr_no;
      ELSE
         tax_customer_no_  := newrec_.customer_no;
         tax_ship_addr_no_ := header_rec_.ship_addr_no;
      END IF;

      IF ((NVL(customer_company_, ' ') != company_) AND
          (newrec_.charged_item != 'ITEM NOT CHARGED') AND
          (newrec_.part_ownership NOT IN ('CUSTOMER OWNED', 'SUPPLIER LOANED')) AND
          (newrec_.exchange_item != 'EXCHANGED ITEM')) THEN
         IF (Customer_Delivery_Tax_Info_API.Check_Exist(tax_customer_no_, tax_ship_addr_no_, company_, header_rec_.supply_country) = 'FALSE') THEN   
            Error_SYS.Record_General(lu_name_, 'NOTAXFORADDR: Customer Tax Information has not been defined for the delivery address.');
         END IF;
      END IF;

      IF (newrec_.addr_flag = 'N') THEN
         IF (Cust_Ord_Customer_Address_API.Is_Ship_Location(newrec_.deliver_to_customer_no, newrec_.ship_addr_no) = 0) THEN
            Error_SYS.Record_General(lu_name_, 'NOTDELADDR: Invalid delivery address specified.');
         END IF;

         IF (Cust_Ord_Customer_Address_API.Is_Valid(newrec_.deliver_to_customer_no, newrec_.ship_addr_no) = 0) THEN
            Error_SYS.Record_General(lu_name_, 'INVALIDDELADDR: Delivery address :P1 is invalid. Check the validity period.', newrec_.ship_addr_no);
         END IF;
      END IF;
  END IF;

   IF (newrec_.configuration_id != '*') THEN
       Order_Config_Util_API.Configuration_Exist(NVL(newrec_.part_no, newrec_.catalog_no), newrec_.configuration_id);
   END IF;

   -- Part Ownership validations
   IF (newrec_.part_ownership IS NOT NULL) THEN
      IF (newrec_.rental = Fnd_Boolean_API.DB_FALSE AND newrec_.part_ownership = Part_Ownership_API.DB_SUPPLIER_RENTED) THEN
         Error_SYS.Record_General(lu_name_, 'INVALIDNONRENTPARTOWN: Ownership :P1 is not allowed for the non-rental lines.', Part_Ownership_API.Decode(newrec_.part_ownership));
      END IF;
      IF (newrec_.rental = Fnd_Boolean_API.DB_TRUE AND newrec_.part_ownership NOT IN (Part_Ownership_API.DB_SUPPLIER_RENTED,
                                                                                      Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)) THEN
         Error_SYS.Record_General(lu_name_, 'INVALIDRENTALPARTOWN: Ownership :P1 is not allowed for the rental lines.', Part_Ownership_API.Decode(newrec_.part_ownership));
      END IF;
      IF (newrec_.supply_code = 'IO') THEN
         IF (newrec_.part_ownership NOT IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                            Part_Ownership_API.DB_CUSTOMER_OWNED,
                                            Part_Ownership_API.DB_SUPPLIER_LOANED,
                                            Part_Ownership_API.DB_SUPPLIER_RENTED,
                                            Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)) THEN
            Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      ELSIF (newrec_.supply_code IN ('SO', 'MRO', 'SEO')) THEN
         IF (newrec_.part_ownership NOT IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                            Part_Ownership_API.DB_CUSTOMER_OWNED)) THEN
            Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      ELSIF (newrec_.supply_code = 'ND') THEN
         IF (newrec_.part_ownership NOT IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                            Part_Ownership_API.DB_SUPPLIER_RENTED,
                                            Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)) THEN
            Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      ELSIF (newrec_.supply_code = 'NO') THEN
         IF (newrec_.part_ownership NOT IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                            Part_Ownership_API.DB_SUPPLIER_RENTED,
                                            Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)) THEN
            Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      ELSIF (newrec_.supply_code = 'PT') THEN
         IF (newrec_.part_ownership NOT IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                            Part_Ownership_API.DB_SUPPLIER_RENTED,
                                            Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)) THEN
            Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      ELSIF (newrec_.supply_code = 'IPT') THEN
         IF (newrec_.part_ownership NOT IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                            Part_Ownership_API.DB_SUPPLIER_RENTED)) THEN
            IF (company_ = supplier_company_) THEN
               --Company Rental Asset is allowed for inter-site in the same company.
               IF (newrec_.part_ownership != Part_Ownership_API.DB_COMPANY_RENTAL_ASSET) THEN
                  Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
               END IF;
            ELSE
               Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
            END IF;
         END IF;
      ELSIF (newrec_.supply_code IN ('PD', 'IPD')) THEN
         IF (newrec_.rental = Fnd_Boolean_API.DB_FALSE) THEN
            IF (newrec_.part_ownership NOT IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                               Part_Ownership_API.DB_SUPPLIER_RENTED)) THEN
               Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
            END IF;
         ELSE
            Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      ELSIF (newrec_.supply_code IN ('DOP', 'PKG','PS')) THEN
         IF (newrec_.part_ownership != Part_Ownership_API.DB_COMPANY_OWNED)THEN
            Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      END IF;

      IF (newrec_.line_item_no > 0) THEN
         IF (newrec_.part_ownership != Part_Ownership_API.DB_COMPANY_OWNED) THEN
            Error_SYS.Record_General(lu_name_,'INVALIDCOMPART: Ownership :P1 is not allowed for component parts.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      END IF;

      IF (newrec_.consignment_stock = 'CONSIGNMENT STOCK') AND (newrec_.part_ownership != Part_Ownership_API.DB_COMPANY_OWNED) THEN
         Error_SYS.Record_General(lu_name_,'INVALIDCONOWNERSHIP: Only ownership company owned is allowed for consignment stock.');
      END IF;

      IF (newrec_.part_ownership = Part_Ownership_API.DB_CUSTOMER_OWNED) AND (newrec_.owning_customer_no IS NULL) THEN
         Error_SYS.Record_General(lu_name_,'OWNINGCUSNONULL: There should be a owning customer for customer owned stock.');
      END IF;

   END IF;

   IF (newrec_.supply_code = 'PKG') THEN
      IF (customer_company_= company_) AND (customer_contract_ IS NOT NULL) THEN
         Error_SYS.Record_General(lu_name_, 'NOPKGPART: Creation or delivery of internal customer order lines using a package part is not allowed for Inter-Site handling between two sites connected to the same company.');
      END IF;
   END IF;

   -- Non inventory Parts are not considered for Planning, therefore newrec_.rel_mtrl_planning should be 'FALSE'. But due to a technical limitation,
   -- we have to maintain the default check for newrec_.rel_mtrl_planning for Non Inventory Parts.
   IF (newrec_.supply_code = 'NO') AND (newrec_.rel_mtrl_planning = 'FALSE') THEN
      Error_SYS.Record_General(lu_name_, 'RELMTRLNOTUPDATE: The Release for Mtrl Planning check box cannot be updated for non inventory sales parts.');
   END IF;

   IF (newrec_.part_no IS NOT NULL) THEN
      IF (company_ = customer_company_) THEN
         IF (sales_part_rec_.part_no != Sales_Part_API.Get_Part_No(newrec_.contract, newrec_.original_part_no)) THEN
            Error_SYS.Record_General(lu_name_, 'REPARTEXISTS: You are not allowed to replace the sales part :P1 with the sales part :P2 since the intersite flow occurs within a single company.' ,newrec_.original_part_no, sales_part_rec_.part_no);
         ELSIF(cust_ord_cust_rec_.category = 'I' AND Part_Catalog_API.Get_Configurable_Db(nvl(newrec_.part_no, newrec_.catalog_no)) = 'CONFIGURED') THEN 
            Client_sys.Add_Info(lu_name_, 'CONFIGPARTSAVE: The configurable parts will remain in internal order transit upon delivery as internal purchase order information does not exist');
         END IF;
      END IF;

       IF (newrec_.supply_code = 'IPT' OR newrec_.supply_code = 'IPD') THEN
         IF (supplier_acquisition_site_ IS NOT NULL) THEN
            IF (supplier_company_ = company_) THEN
               IF (NOT Inventory_Part_API.Check_Exist(supplier_acquisition_site_, newrec_.part_no)) THEN
                  Error_SYS.Record_General(lu_name_, 'NOVENDPART: Creation of internal order lines are not allowed when inventory part :P1 does not exist in supplier site :P2.', newrec_.part_no, supplier_acquisition_site_);
               END IF;

               IF (newrec_.rental = Fnd_Boolean_API.DB_TRUE AND newrec_.supply_code = 'IPT' AND newrec_.part_ownership != Part_Ownership_API.DB_COMPANY_RENTAL_ASSET) THEN
                  Error_SYS.Record_General(lu_name_,'INVALIDRENTPARTCRA: Ownership Type :P1 is not allowed for this supply code if the supply site belongs to the same company.', Part_Ownership_API.Decode(newrec_.part_ownership));
               END IF;
            ELSE
               IF (newrec_.rental = Fnd_Boolean_API.DB_TRUE AND newrec_.supply_code = 'IPT' AND newrec_.part_ownership != Part_Ownership_API.DB_SUPPLIER_RENTED) THEN
                  Error_SYS.Record_General(lu_name_,'INVALIDRENTPARTSR: Ownership Type :P1 is not allowed for this supply code if the supply site belongs to a different company.', Part_Ownership_API.Decode(newrec_.part_ownership));
               END IF;
            END IF;
         END IF;
      END IF;

      IF (customer_company_= company_) AND (customer_contract_ IS NOT NULL) THEN
         IF (NOT Inventory_Part_API.Check_Exist(customer_contract_, newrec_.part_no)) THEN
            Error_SYS.Record_General(lu_name_, 'NOCUSTPART: Creation of Internal Order Lines are not allowed when Inventory Part :P1 does not exist in Customer Site :P2', newrec_.part_no, customer_contract_);
         END IF;
      END IF;
   END IF;
   IF (sales_part_rec_.activeind = 'N') THEN
      Error_SYS.Record_General(lu_name_, 'NOT_ACTIVE: The sales part :P1 is not active for sale', newrec_.catalog_no);
   END IF;

   IF NOT (Is_External_Service_Order___(newrec_.demand_code, newrec_.demand_order_ref1) = 'TRUE') THEN
      Check_Active_Part___(newrec_.contract, sales_part_rec_.part_no);
   END IF;
END Check_Before_Insert___;


-- Check_Before_Update___
--   Perform checks needed before updating a record.
PROCEDURE Check_Before_Update___ (
   attr_                  IN OUT VARCHAR2,
   newrec_                IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   oldrec_                IN     CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   header_curr_code_      IN     VARCHAR2,
   header_rowstate_       IN     VARCHAR2,
   delivery_date_changed_ IN     BOOLEAN )
IS
   sales_part_rec_               SALES_PART_API.Public_Rec;
   header_rec_                   CUSTOMER_ORDER_API.Public_Rec;
   consignment_stock_db_         VARCHAR2(20);
   company_                      VARCHAR2(20);
   supply_code_changed_          BOOLEAN;
   sup_object_status_            VARCHAR2(200);
   qty_refreshed_                NUMBER;
   price_source_refreshed_       NUMBER;
   objid_                        VARCHAR2(2000);
   suppcodeupd_                  BOOLEAN := FALSE;
   notdecided_                   BOOLEAN := FALSE;
   interim_header_id_            VARCHAR2(12);
   order_code_                   VARCHAR2(20);
   cust_ord_line_rec_            Public_Rec;
   qty_changed_                  BOOLEAN := FALSE;
   supplier_acquisition_site_    VARCHAR2(5);
   cust_acquisition_site_        VARCHAR2(5);
   customer_contract_            CUSTOMER_ORDER_LINE_TAB.contract%TYPE;
   cust_contract_connected_comp_ SITE_TAB.company%TYPE;
   capability_check_source_flag_ VARCHAR2(5);
   tax_customer_no_              CUSTOMER_ORDER_LINE_TAB.customer_no%TYPE;
   tax_ship_addr_no_             CUSTOMER_ORDER_LINE_TAB.ship_addr_no%TYPE;
   partca_condition_code_usage_  PART_CATALOG_TAB.condition_code_usage%TYPE;
   change_request_               VARCHAR2(5);
   server_data_change_           VARCHAR2(10);
   configuration_id_changed_     BOOLEAN := FALSE;
   expired_                      BOOLEAN := FALSE;
   insert_package_mode_          VARCHAR2(5);
   sales_price_type_db_          VARCHAR2(20);
   price_effective_date_         DATE;
   cond_update_error_            VARCHAR2(6);
   discount_freeze_db_           VARCHAR2(5);
   po_order_no_                  VARCHAR2(12);
   po_line_no_                   VARCHAR2(4);
   po_rel_no_                    VARCHAR2(4);
   purchase_type_                VARCHAR2(30);
   purchase_type_db_             VARCHAR2(1);
   cond_update_info_             VARCHAR2(6);
   allow_to_update_              VARCHAR2(5) := 'FALSE';
   connected_so_found_           VARCHAR2(5) := 'FALSE';
   connected_po_found_           NUMBER;
   unpeg_ipd_flag_               VARCHAR2(5);
   result_code_                  VARCHAR2(2000);
   available_qty_                NUMBER := 0;
   earliest_available_date_      DATE;
   
   CURSOR pkgpart_components IS
      SELECT line_item_no, qty_assigned, qty_shipped, buy_qty_due, qty_per_assembly, qty_on_order, conv_factor, inverted_conv_factor, supply_code
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = newrec_.order_no
      AND line_no = newrec_.line_no
      AND rel_no = newrec_.rel_no
      AND line_item_no > 0
      ORDER BY line_item_no;

   CURSOR get_id(order_no_ IN VARCHAR2, line_no_ IN VARCHAR2,
                 rel_no_ IN VARCHAR2, line_item_no_ IN NUMBER) IS
      SELECT rowid
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = order_no_
      AND line_no = line_no_
      AND rel_no = rel_no_
      AND line_item_no = line_item_no_;
BEGIN
   change_request_               := Client_SYS.Get_Item_Value('CHANGE_REQUEST', attr_);
   qty_refreshed_                := (NVL(Client_SYS.Get_Item_Value('QTY_REFRESHED', attr_), 0));
   price_source_refreshed_       := (NVL(Client_SYS.Get_Item_Value('PRICE_SOURCE_REFRESHED', attr_), 0));
   capability_check_source_flag_ := NVL(Client_SYS.Get_Item_Value('CAPABILITY_CHECK_SOURCE_FLAG', attr_), 'FALSE');
   supply_code_changed_          := (newrec_.supply_code != oldrec_.supply_code);
   unpeg_ipd_flag_               := NVL(Client_SYS.Get_Item_Value('UNPEG_IPD_FLAG', attr_), 'FALSE');
   -- Qty_changed is not set when the revised_qty_due is changed to equal the current shipped quantity.
   IF (newrec_.revised_qty_due > oldrec_.revised_qty_due) OR ((newrec_.revised_qty_due > oldrec_.qty_shipped) AND (newrec_.revised_qty_due < oldrec_.revised_qty_due)) THEN
     qty_changed_ := TRUE;
   END IF;
   server_data_change_           := NVL(Client_SYS.Get_Item_Value('SERVER_DATA_CHANGE', attr_), 0);
   insert_package_mode_          := NVL(Client_SYS.Get_Item_Value('INSERT_PACKAGE_MODE_', attr_), 'FALSE');
   IF (newrec_.rental = Fnd_Boolean_API.DB_FALSE) THEN
      sales_price_type_db_  := Sales_Price_Type_API.DB_SALES_PRICES;
      price_effective_date_ := newrec_.price_effectivity_date;
   ELSE
      sales_price_type_db_  := Sales_Price_Type_API.DB_RENTAL_PRICES;
      price_effective_date_ := Get_Planned_Rental_Start_Dt___(attr_, newrec_);
   END IF;

   IF ((Site_To_Site_Reserve_Setup_API.Exists(newrec_.supply_site, newrec_.contract)) AND
      (Site_To_Site_Reserve_Setup_API.Get_Rel_Mtrl_Planning_Db(newrec_.supply_site, newrec_.contract) = Rel_Mtrl_Planning_API.DB_NOT_VIS_PLANNED_RELEASED)) THEN
      allow_to_update_ := 'TRUE';
   END IF;      
      
   IF newrec_.activity_seq IS NOT NULL AND newrec_.job_id IS NOT NULL THEN
      Error_SYS.Record_General(lu_name_, 'JOBIDEXIST: A customer order line cannot be connected to both a project and a financial job.');
   END IF;

   IF (newrec_.rel_mtrl_planning != oldrec_.rel_mtrl_planning) THEN
      IF (newrec_.rowstate != 'Released') THEN
         Error_SYS.Record_General(lu_name_, 'RELMTRLCANNOTUPDATE: The Release for Mtrl Planning check box can be updated only when the order line is in the Released state.');
      ELSIF ((newrec_.qty_on_order > 0) AND (allow_to_update_ = 'FALSE')) THEN
         Error_SYS.Record_General(lu_name_, 'PEGLINECANNOTUPDATE: The Release for Mtrl planning check box cannot be cleared when pegged supplies are created.');
      END IF;

      IF (newrec_.supply_code = 'NO') THEN
         Error_SYS.Record_General(lu_name_, 'RELMTRLNOTUPDATE: The Release for Mtrl Planning check box cannot be updated for non inventory sales parts.');
      ELSIF (newrec_.supply_code = 'PKG') THEN
         Error_SYS.Record_General(lu_name_, 'RELMTRLPKGTUPDATE: The Release for Mtrl Planning check box cannot be updated for package parts. Please use the package part structure window to set it for component lines.');
      END IF;
   END IF;

   IF (oldrec_.self_billing != newrec_.self_billing) THEN
      IF (newrec_.qty_invoiced > 0) THEN
            Error_SYS.Record_General(lu_name_,'NOUPDATESELFBILL: It is not allowed to change self billing when the order line is invoiced.');
      ELSE
         IF (newrec_.customer_part_no IS NULL) THEN
            IF (newrec_.self_billing = 'SELF BILLING') THEN
               Error_SYS.Record_General(lu_name_, 'CUSTPARTNONEEDED: Customer''s part number is needed on the customer order line to enable self-billing.');
            END IF;
         ELSE
            IF (NVL(Sales_Part_Cross_Reference_API.Get_Self_Billing_Db(newrec_.customer_no, newrec_.contract, newrec_.customer_part_no), 'NOT SELF BILLING') = 'NOT SELF BILLING')
               AND (newrec_.self_billing = 'SELF BILLING') THEN
               Error_SYS.Record_General(lu_name_, 'EDITNOTALLOWEDSB: Cannot use self-billing on customer order line when there is no sales part cross reference record allowing self-billing for Sales part :P1 and Customer :P2 on site :P3 .',
                                        newrec_.catalog_no, newrec_.customer_no, newrec_.contract);
            END IF;
         END IF;
      END IF;
   END IF;

   IF (newrec_.qty_invoiced > 0) THEN
      IF (oldrec_.provisional_price != newrec_.provisional_price) THEN
         Error_SYS.Record_General(lu_name_,'NOTINVPROVPRICE: It is not allowed to change provisional price check when the order line is Invoiced.');
      END IF;
   END IF;

   IF (newrec_.line_item_no > 0) THEN
      IF (oldrec_.shipment_connected != newrec_.shipment_connected) THEN
         NULL;
      ELSIF (newrec_.shipment_connected = 'TRUE' AND newrec_.buy_qty_due != oldrec_.buy_qty_due) THEN
         Error_SYS.Record_General(lu_name_, 'EDIT_NOT_ALLOWED: Modifications to Component Part(s) not allowed when the Package Part is connected to a Shipment.');
      END IF;
   END IF;

   IF supply_code_changed_ THEN
      suppcodeupd_ := FALSE;
      IF (oldrec_.supply_code = 'SO') THEN
 		   connected_so_found_ := Customer_Order_Shop_Order_API.Connected_Orders_Found(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
 		ELSIF (oldrec_.supply_code IN ('PT', 'PD', 'IPT', 'IPD')) THEN
 		   connected_po_found_ := Customer_Order_Pur_Order_API.Connected_Orders_Found(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
 		END IF;
      IF (newrec_.supply_code = 'SRC') THEN
         Error_SYS.Record_General(lu_name_, 'AUTONOUPDATE: Supply code ":P1" can only be used on New order lines.', Order_Supply_Type_API.Decode('SRC'));
      END IF;
      IF (newrec_.rowstate = 'Reserved') THEN
         IF ((oldrec_.supply_code IN ('PI','PJD')) AND (newrec_.supply_code IN ('IO'))) OR ((oldrec_.supply_code IN ('IO')) AND (newrec_.supply_code IN ('PI','PJD'))) THEN
            Error_SYS.Record_General(lu_name_, 'NO_CHANGE_ALLOWED: Changing the supply code to ":P1" is not allowed for reserved line. Un-reserve the line before changing the supply code.', Order_Supply_Type_API.Decode(newrec_.supply_code));
         END IF;
      END IF;
      IF ((connected_so_found_ = 'TRUE' OR connected_po_found_ = 1 OR (connected_po_found_ = 0 AND unpeg_ipd_flag_ = 'TRUE')) AND (oldrec_.supply_code IN ('PT', 'PD', 'IPT', 'IPD', 'SO')) AND (newrec_.supply_code IN ('IO', 'NO'))) THEN
	      IF (server_data_change_ = 1) THEN
	         suppcodeupd_ := TRUE;
	      ELSE
	 	      Error_SYS.Record_General(lu_name_, 'NO_SUPPCODE_UPDATE2: Supply Code may not be updated if a pegged supply has been created. If applicable you may use the option to Unpeg instead.');
	      END IF;
	   END IF; 
      -- IF order has been released the supply code may be changed only if it was Not Decided...
      IF (header_rowstate_ = 'Planned') THEN
         suppcodeupd_ := TRUE;
         notdecided_  := (oldrec_.supply_code = 'ND');
      ELSIF ((oldrec_.supply_code = 'ND') AND (header_rowstate_ NOT IN ('Delivered', 'Invoiced', 'Cancelled'))) THEN
         suppcodeupd_ := TRUE;
         notdecided_  := TRUE;
      ELSIF (newrec_.rowstate = 'Released') THEN
         IF (Sales_Part_API.Get_Configurable_Db(newrec_.contract, newrec_.catalog_no) = 'CONFIGURED' AND newrec_.configuration_id = '*') THEN
            suppcodeupd_ := TRUE;
         ELSE
            -- When using Project Inventory functionality ( ACTIVITY_SEQ > 0 ) SUPPLY_CODE can be switched as follows (as long as the line state is Released)
            --   PI  <-> IO
            --   PRJ <-> NO
            IF (oldrec_.supply_code IN ('IO', 'NO', 'PI', 'PRJ', 'PJD' ) AND newrec_.supply_code IN ('IO', 'NO', 'PI', 'PRJ', 'PJD')) THEN
               suppcodeupd_ := TRUE;
            ELSIF ((oldrec_.supply_code IN ('SO', 'PT', 'PD', 'IPT', 'IPD')) AND (newrec_.supply_code IN ('PI', 'PRJ')) AND (newrec_.activity_seq IS NOT NULL)) THEN
               IF (server_data_change_ = 1) THEN
                  suppcodeupd_ := TRUE;
               END IF;
            ELSIF ((NVL(oldrec_.demand_code, Database_SYS.string_null_) != 'DO') AND (oldrec_.supply_code IN ('IO', 'PI')) AND (newrec_.supply_code IN ('SO', 'PT', 'PD', 'IPT', 'IPD', 'DOP'))) THEN
               suppcodeupd_ := TRUE;
            ELSIF ((oldrec_.supply_code IN ('PRJ', 'NO')) AND (newrec_.supply_code IN ('PT','PD', 'IPT', 'IPD'))) THEN
               suppcodeupd_ := TRUE;
            END IF;
         END IF;
      ELSIF ((newrec_.rowstate = 'Reserved') AND (oldrec_.supply_code IN ('IO', 'PI', 'PJD')) AND (newrec_.supply_code IN ('IO', 'PI', 'PJD'))) THEN
         suppcodeupd_ := TRUE;
      ELSIF (newrec_.activity_seq IS NULL AND oldrec_.activity_seq IS NOT NULL) THEN
         suppcodeupd_ := TRUE;
      END IF;

      IF suppcodeupd_ THEN
         -- Validate supply code so that it has the correct value depending on different data
         Check_Supply_Code___(newrec_);
      ELSE
         Error_SYS.Record_General(lu_name_, 'NO_SUPPCODE_UPDATE: Supply code may not be updated when the order has been Released.');
      END IF;
   END IF;

   Check_Purch_Supply_Code___(newrec_);-- prevent setting target date earlier than wanted delivery date

   --Note: Check whether supply site exists
   IF newrec_.supply_site IS NOT NULL THEN
      Site_API.Exist(newrec_.supply_site);
   END IF;

   IF ((newrec_.supply_code IN ('PD', 'IPD')) AND (newrec_.consignment_stock = 'CONSIGNMENT STOCK')) THEN
      Error_SYS.Record_General(lu_name_, 'SUPPLY_CODE: Not possible to have supply code Purchase Order Direct or Internal Purchase Order Direct for Consignment Stock parts');
   END IF;

   -- extended check on order header's delivery confirmation flag
   Validate_Delivery_Conf___(newrec_, FALSE, NULL, NULL);

   IF (newrec_.staged_billing = 'STAGED BILLING') THEN
      IF NOT ((newrec_.rowstate = 'Released' OR newrec_.rowstate = 'Invoiced') AND (newrec_.qty_shipped = 0) AND (newrec_.qty_invoiced > 0)) THEN
         IF (newrec_.qty_shipdiff > 0 ) THEN
            Error_SYS.Record_General(lu_name_, 'POSSHIPDIFF: Picking or delivering a qty greater than the Revised Qty of the Customer Order Line is not allowed when using Staged Billing. Please adjust the Sales Qty so that Revised Qty corresponds with the qty to be picked or delivered.');
         ELSIF (newrec_.qty_shipdiff < 0) THEN
            Error_SYS.Record_General(lu_name_, 'NEGSHIPDIFF: When using Staged Billing an order line may not be closed when picking or delivering a qty less than the Revised Qty of the Customer Order Line. Please adjust the Sales Qty so that Revised Qty corresponds with the qty to be picked or delivered before closing.');
         END IF;
      END IF;
   END IF;

   -- IF ship time is changed in customer order line.
   IF (to_char(newrec_.planned_ship_date,'HH24:MI') != to_char(oldrec_.planned_ship_date,'HH24:MI')) THEN
      IF (to_char(newrec_.planned_delivery_date, 'YYYY-MM-DD') != to_char(newrec_.planned_ship_date,'YYYY-MM-DD')) THEN
         IF (newrec_.delivery_leadtime = 0) THEN
            IF (to_char(newrec_.planned_ship_date,'HH24:MI') <= to_char( newrec_.planned_delivery_date , 'HH24:MI')) THEN
                newrec_.planned_delivery_date  := newrec_.planned_delivery_date - 1;
                newrec_.promised_delivery_date := newrec_.promised_delivery_date - 1;
            END IF;
         END IF;
       ELSE
          IF (to_char(newrec_.planned_delivery_date, 'YYYY-MM-DD') = to_char(newrec_.planned_ship_date,'YYYY-MM-DD')) THEN
            IF NOT ((to_char(newrec_.planned_delivery_date, 'HH24:MI') = '00:00') OR (to_char(newrec_.planned_ship_date, 'HH24:MI') = '00:00')) THEN
               IF (to_char(newrec_.planned_ship_date,'HH24:MI') > to_char( newrec_.planned_delivery_date , 'HH24:MI')) THEN
                  newrec_.planned_delivery_date  := newrec_.planned_delivery_date + 1;
                  newrec_.promised_delivery_date := newrec_.promised_delivery_date + 1;
               END IF;
            END IF;
         END IF;
       END IF;
   END IF;

   sales_part_rec_ := Sales_Part_API.Get(newrec_.contract, newrec_.catalog_no);
   configuration_id_changed_ := newrec_.configuration_id != oldrec_.configuration_id;

   -- Set release_planning flag according to supply_code, quantity and delivery date change. But only set it if the supply_code is IPT or IPD.
   -- Setting release_planning flag is done irrespective of checking the sourcing option. This code was place to facilitate availability check functionality.
   IF (((supply_code_changed_) OR (qty_changed_) OR (delivery_date_changed_) OR (configuration_id_changed_)) AND (newrec_.supply_code IN ('IPT', 'IPD'))) THEN   
      IF (NOT(Internal_Co_Line_Exists___(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no))) THEN
         newrec_.release_planning := 'RELEASED';
      END IF;
   END IF;

   -- override the value entered by the user for the ship date if the planned delivery date has changed
   -- Added qty_changed and supply_code_changed conditions
   IF configuration_id_changed_ OR delivery_date_changed_ OR supply_code_changed_ OR qty_changed_ OR
       (newrec_.part_ownership != oldrec_.part_ownership) OR (newrec_.rel_mtrl_planning != oldrec_.rel_mtrl_planning) THEN
      OPEN get_id(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      FETCH get_id INTO objid_;
      CLOSE get_id;
      IF ((Client_SYS.Get_Item_Value('MOVE_DELIVERY_DATE_FORWARD', attr_) = 'TRUE') AND
         (newrec_.planned_delivery_date != oldrec_.planned_delivery_date) AND
         (Work_Time_Calendar_API.Is_Working_Day(newrec_.cust_calendar_id, newrec_.planned_delivery_date) = 0)) THEN
         newrec_.planned_delivery_date := Work_Time_Calendar_API.Get_Next_Work_Day(newrec_.cust_calendar_id, newrec_.planned_delivery_date);
      END IF;
      IF(newrec_.rowstate != 'Cancelled') THEN
         -- do not calculate the order dates if this line have just been updated from a capability checked sourced order line
         -- because we have already done forward date calculation that we do not want recalculated now
         IF (capability_check_source_flag_ = 'FALSE') THEN
            Calculate_Order_Line_Dates___(newrec_, oldrec_, objid_);
         END IF;
      END IF;
      
      -- This flag was set to RELEASE for all sourcing options if the supply code, quantity or deliver_date was changed. 
      -- From this code block release_planning flag will be reset for all the sourcing options except inventory order.
      IF ((newrec_.supply_code IN ('IPT', 'IPD')) AND (newrec_.release_planning = 'RELEASED')) THEN
         IF (NOT((Sales_part_API.Get_Valid_Sourcing_Option(newrec_.supply_site, newrec_.catalog_no) = 'INVENTORYORDER'))) THEN
            newrec_.release_planning := 'NOTRELEASED' ;
         END IF;
         IF (header_rowstate_ IN ('Planned', 'Released')) THEN
            IF ((supply_code_changed_) OR (newrec_.vendor_no != oldrec_.vendor_no)) THEN
               -- During update, rel_mtrl_planning is only set either supply code or vendor_no is changed. 
               -- set the rel_mtrl_planning flag in newrec_.
               Assign_Rel_Mtrl_Planning___(newrec_, header_rowstate_);
            END IF;
         END IF; 
      END IF;
      
      IF (newrec_.planned_delivery_date != oldrec_.planned_delivery_date) AND newrec_.qty_assigned > 0 THEN
         expired_ := Reserve_Customer_Order_API.Check_Expired(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.contract, newrec_.catalog_no, newrec_.planned_delivery_date);
         IF (expired_) THEN
            Client_SYS.Add_Info(lu_name_, 'DATE_EXP: Please review the inventory part reservations as the change of planned delivery date resulted in the minimum required shelf life not being fulfilled for at least some of the inventory part reservations.');
         END IF;
      END IF;      
      -- Added extra condition to satisfy the previous execution
      IF (delivery_date_changed_ OR notdecided_) THEN
         IF ((newrec_.supply_code IN ('ND')) AND (oldrec_.qty_on_order != 0) AND (header_rowstate_ != 'Planned')) THEN
            Client_SYS.Add_Info(lu_name_, 'WRONGSUPPLY2: Since this is a supply from another order, the date on that order will not be updated automatically.');
         END IF;

         IF (newrec_.demand_code = 'PO') AND (NVL(Client_SYS.Get_Item_Value('PO_CHARGED_COMP_CHANGE', attr_), 'FALSE') = 'FALSE') THEN
            Client_SYS.Add_Info(lu_name_, 'CONNECTED_TO_PO: This order is connected to purchase order :P1/:P2/:P3 - which will not be updated automatically.', newrec_.demand_order_ref1, newrec_.demand_order_ref2, newrec_.demand_order_ref3);
         ELSIF (newrec_.demand_code = 'WO') THEN
            Client_SYS.Add_Info(lu_name_, 'CONNECTED_TO_WO: This order is connected to work order :P1/:P2/:P3 - which will not be updated automatically.', newrec_.demand_order_ref1, newrec_.demand_order_ref2, newrec_.demand_order_ref3);
         END IF;
      END IF;

      IF (newrec_.supply_code = 'PS' AND header_rowstate_ != 'Planned') THEN
         IF delivery_date_changed_ THEN
            Client_SYS.Add_Info(lu_name_, 'PS_EXISTLDATE: The customer order line delivery date has changed. Production schedule will not be updated automatically.');
         ELSIF qty_changed_ THEN
            Client_SYS.Add_Info(lu_name_, 'PS_EXISTLQTY: The customer order line quantity has changed. Production schedule will not be updated automatically.');
         END IF;
      END IF;

      IF (newrec_.demand_code = 'CRO') THEN
         IF (newrec_.part_ownership != oldrec_.part_ownership) THEN
            IF (newrec_.supply_code = 'CRO') THEN
               Error_Sys.Record_General(lu_name_, 'CRO_OWNERSHIP: Customer order line is created from a component repair order with ownership Customer-Owned. You cannot change the ownership.');
            END IF;
         END IF;

         IF (oldrec_.supply_code = 'CRO' AND supply_code_changed_) THEN
            Error_SYS.Record_General(lu_name_, 'COCREATEDFROMCRO: Customer order line is created from a component repair order. You cannot change the supply code.');
         ELSIF ((newrec_.supply_code NOT IN ('IO', 'SEO')) AND (newrec_.part_ownership = 'COMPANY OWNED')) THEN
            Error_SYS.Record_General(lu_name_, 'DEMCROSUPIOCOMPOWNED: The customer order line is created from a component repair order. For the Company-Owned ownership, only the :P1 and :P2 supply codes are applicable.', (Order_Supply_Type_API.Decode('IO')), (Order_Supply_Type_API.Decode('SEO')));
         END IF;
      END IF;
   -- Only changing the abnormal demand flag in orderline will update the MS level 1 
   ELSIF (oldrec_.abnormal_demand != newrec_.abnormal_demand) AND (Inventory_Part_API.Get_Forecast_Consump_Flag_Db(newrec_.contract, newrec_.part_no) = 'FORECAST') THEN 
      Reserve_Customer_Order_API.Control_Ms_Mrp_Consumption(result_code_, available_qty_, earliest_available_date_, newrec_.contract, newrec_.part_no, NVL(newrec_.activity_seq, 0),
                                                               newrec_.revised_qty_due, oldrec_.revised_qty_due, newrec_.planned_due_date, oldrec_.planned_due_date, 'CO', TRUE, newrec_.abnormal_demand,oldrec_.abnormal_demand);
   END IF;

   -- return the new supply_site_due_date to client
   IF (supply_code_changed_ AND newrec_.supply_code IN ('IPT', 'IPD')) THEN
      Client_SYS.Add_To_Attr('SUPPLY_SITE_DUE_DATE', newrec_.supply_site_due_date, attr_);
   ELSIF (supply_code_changed_ AND newrec_.supply_code NOT IN ('IPT', 'IPD')) THEN
      -- clear supply_site_due_date if its not a IPT/IPD
      newrec_.supply_site_due_date := NULL;
      Client_SYS.Add_To_Attr('SUPPLY_SITE_DUE_DATE', newrec_.supply_site_due_date, attr_);
   END IF;

   Client_SYS.Add_To_Attr('PLANNED_SHIP_PERIOD', newrec_.planned_ship_period, attr_);
   -- the column is mandatory in the database, but calculated from the delivery dates
   Error_SYS.Check_Not_Null(lu_name_, 'PLANNED_SHIP_DATE', newrec_.planned_ship_date);
   -- Check if right SUPPLY_CODE
   IF ((newrec_.price_list_no IS NOT NULL) AND (newrec_.price_list_no != NVL(oldrec_.price_list_no, ' '))) THEN
      -- Check if valid
      IF ((Sales_Price_List_API.Is_Valid(newrec_.price_list_no, newrec_.contract, newrec_.catalog_no, price_effective_date_, sales_price_type_db_) = FALSE) AND
          (Sales_Price_List_API.Is_Valid_Assort(newrec_.price_list_no, newrec_.contract, newrec_.catalog_no, newrec_.price_effectivity_date) = FALSE)) OR
          (Sales_Price_List_API.Get_Sales_Price_Group_Id(newrec_.price_list_no) != sales_part_rec_.sales_price_group_id) THEN
         Error_Sys.Record_General(lu_name_, 'INVALID_PRICELIST: The selected sales price list has no valid part-based line or a valid assortment-node-based line for the sales part.');
      END IF;
   END IF;

   IF (newrec_.supply_code = 'MRO') THEN
      Validate_Mro_Line___(newrec_.part_no, newrec_.buy_qty_due, newrec_.part_ownership);
   END IF;

   IF supply_code_changed_ THEN
      IF (oldrec_.supply_code IN ('IO','PS') AND oldrec_.qty_on_order > 0) THEN
           Error_SYS.Record_General(lu_name_,'PEG_SUPPLY_CODE: The customer order line is pegged to a supply. Remove the pegging first, then change the supply code.');
      END IF;
   END IF;

   -- create SM object option check
   IF (newrec_.create_sm_object_option != oldrec_.create_sm_object_option) THEN
      IF (newrec_.rowstate IN ('PartiallyDelivered', 'Delivered', 'Cancelled', 'Invoiced')) THEN
         Error_SYS.Record_General(lu_name_, 'SM_OPTION: The Create SM Object Option can not be changed when status is Partially Delivered or Delivered or Cancelled or Invoiced/Closed.');
      ELSIF (newrec_.part_no IS NULL) THEN
         Error_SYS.Record_General(lu_name_, 'SM_NOT_VALID1: The Create SM Object Option can not be set for none inventory parts.');
      ELSIF (newrec_.create_sm_object_option = 'CREATESMOBJECT') AND (Part_Catalog_API.Get_Rcpt_Issue_Serial_Track_Db(newrec_.part_no) = Fnd_Boolean_API.DB_FALSE) THEN
         Error_SYS.Record_General(lu_name_, 'SM_NOT_ALLOWED1: The Create SM Object Option can not be set on an item without serial tracking.');
      ELSIF (newrec_.sm_connection = 'CONNECTED') THEN
         Error_SYS.Record_General(lu_name_, 'SM_NOT_VALID3: The Create SM Object Option and SM Connection can not both be set at the same time.');
      END IF;
   END IF;

   IF (NVL(newrec_.Sup_Sm_Contract,' ') != NVL(oldrec_.Sup_Sm_Contract,' ') OR
       NVL(newrec_.Sup_Sm_Object,' ') != NVL(oldrec_.Sup_Sm_Object,' ')) AND
       (newrec_.rowstate IN ('PartiallyDelivered', 'Delivered', 'Cancelled', 'Invoiced')) THEN
      Error_SYS.Record_General(lu_name_, 'SUPOBJSTATE: The Superior Object can not be changed when status is Partially Delivered or Delivered or Cancelled or Invoiced/Closed.');
   END IF;

   -- check so sup_sm_object isnt NULL when sup_sm_contract has a value
   IF (newrec_.sup_sm_contract IS NOT NULL and newrec_.sup_sm_object IS NULL) THEN
      Raise_Sm_Object_Error___;
   END IF;

   -- check so sup_sm_contract isnt NULL when sup_sm_object has a value
   IF (newrec_.sup_sm_contract IS NULL and newrec_.sup_sm_object IS NOT NULL) THEN
      Error_SYS.Record_General(lu_name_, 'SMSITENULL: Superior SM Site cannot be empty when Superior SM Object have a value.');
   END IF;

   -- sup_sm_object status control
   IF (newrec_.sup_sm_contract IS NOT NULL) AND (newrec_.sup_sm_object IS NOT NULL) THEN
      $IF (Component_Equip_SYS.INSTALLED)$THEN
         sup_object_status_ := Equipment_Object_API.Get_Operational_Status_Db(newrec_.sup_sm_contract, newrec_.sup_sm_object);
         IF (sup_object_status_ = 'SCRAPPED') THEN
            Raise_Scrapped_Object_Error___(newrec_.sup_sm_object);
         END IF;
      $ELSE
         NULL;
      $END
   END IF;

   -- Consignment checks
   -- IF ship_addr_no change, get consignment delivery based on new order line ship_addr_noe
   IF NVL(newrec_.ship_addr_no,' ') != NVL(oldrec_.ship_addr_no,' ') THEN
      IF (newrec_.customer_no = newrec_.deliver_to_customer_no) THEN
         newrec_.consignment_stock := NVL(Consignment_Stock_API.Encode(Customer_Consignment_Stock_API.Get_Consignment_Stock(newrec_.contract, newrec_.catalog_no,
                                        newrec_.customer_no, newrec_.ship_addr_no)),newrec_.consignment_stock);
      ELSE
         newrec_.consignment_stock := 'NO CONSIGNMENT STOCK';
      END IF;
   END IF;

   IF (newrec_.consignment_stock = 'CONSIGNMENT STOCK') THEN
      IF (newrec_.configuration_id != '*') THEN
         Error_SYS.Record_General(lu_name_, 'NO_CONS_FOR_CONFIG: Consignment stock can not be used for configured parts');
      ELSIF (newrec_.exchange_item = 'EXCHANGED ITEM') THEN
         Error_SYS.Record_General(lu_name_, 'NO_CONS_FOR_EXCHANGE: Consignment Stock cannot be used when the Customer Order Line has been created from a Purchase Exchange Order.');
      END IF;
   END IF;

   IF (newrec_.consignment_stock != oldrec_.consignment_stock) THEN
      IF (newrec_.rowstate IN ('PartiallyDelivered', 'Delivered', 'Cancelled', 'Invoiced')) THEN
         Error_SYS.Record_General(lu_name_, 'CONSIGN_DELIV: The Consignment Stock can not be changed when status is Partially Delivered or Delivered or Cancelled or Invoiced/Closed.');
      END IF;

      IF (newrec_.consignment_stock = 'CONSIGNMENT STOCK') THEN
         IF (newrec_.catalog_type != 'INV') THEN
            Error_SYS.Record_General(lu_name_, 'ONLY_INV_ON_CONSIGN: Consignment stock can only be used together with inventory parts.');
         ELSE
            consignment_stock_db_ := Consignment_Stock_API.Encode(Customer_Consignment_Stock_API.Get_Consignment_Stock(newrec_.contract, newrec_.catalog_no,
                newrec_.customer_no, newrec_.ship_addr_no));

            IF (consignment_stock_db_ IS NULL) THEN
               -- Not specified consignment stock.
               Error_SYS.Record_General(lu_name_, 'NOT_SPECIF_CONSIGN: The consignment stock can not be used for specified Customer No - Sales Part - Ship Addr No combination.');
            ELSIF (consignment_stock_db_ = 'NO CONSIGNMENT STOCK') THEN
               -- Not active consignment stock.
               Error_SYS.Record_General(lu_name_, 'NOT_ACTIVE_CONSIGN: The consignment stock is not active for specified Customer No - Sales Part - Ship Addr No combination.');
            END IF;
         END IF;
      END IF;
   END IF;

   IF supply_code_changed_ THEN
      IF (newrec_.supply_code IN ('PD', 'IPD', 'PT', 'IPT', 'ND')) THEN
         IF (oldrec_.rowstate = 'Reserved') THEN
            Error_SYS.Record_General(lu_name_, 'CANTCHGSUPCODENW: Changing Supply code to Purch Order Dir,Purch Order Trans,Int Purch Dir,Int Purch Trans and Not Decided is not allowed for Reserved line. Unreserve it before changing supply code.');
         END IF;
      END IF;

      IF (newrec_.supply_code = 'PS')THEN
         IF(newrec_.rowstate = 'Reserved' AND newrec_.revised_qty_due = newrec_.qty_assigned) THEN
            Error_SYS.Record_General(lu_name_, 'CANTCHGSUPCODEPS: Changing Supply Code to Production Schedule is not allowed for fully reserved line. Unreserve it before changing Supply Code.');
         END IF;
      END IF;
   END IF;

   --supply site reservation is only allowed if its a IPD or IPT
   IF (newrec_.supply_site_reserve_type != 'NOTALLOWED' AND newrec_.supply_code NOT IN ('IPD','IPT')) THEN
      Error_SYS.Record_General(lu_name_, 'SCRWITHINVALIDSC: A :P1 Supply Site Reservation is only valid for supply codes ":P2" and ":P3".', Supply_Site_Reserve_Type_API.Decode(newrec_.supply_site_reserve_type), Order_Supply_Type_API.Decode('IPD'),Order_Supply_Type_API.Decode('IPT'));
   END IF;

   --you can only change the reservation type while the line is in status Released
   IF (newrec_.supply_site_reserve_type != oldrec_.supply_site_reserve_type AND newrec_.rowstate != 'Released') THEN
      Error_SYS.Record_General(lu_name_, 'SCRAFTERRELEASE: You are not allowed to change the supply site reservation type when the order line is not in status Released anymore');
   END IF;

   IF ((newrec_.buy_qty_due <= 0) AND (newrec_.supply_code != 'SEO')) THEN
      Error_SYS.Record_General(lu_name_, 'QTY_LESS_THAN_ZERO: Quantity must be greater than zero!');
   END IF;
      
   IF (newrec_.revised_qty_due != oldrec_.revised_qty_due) THEN
     -- Added a check to compare Revised_qty_due against, (Qty Assigned + Qty Shipped) of package part components.
     -- Changed the IF condition to take notice of Component Qty Per Assembly.
      IF (newrec_.supply_code = 'PKG') THEN
         FOR components_rec_ IN pkgpart_components LOOP
            IF (((newrec_.revised_qty_due  * components_rec_.conv_factor / components_rec_.inverted_conv_factor * (components_rec_.buy_qty_due/oldrec_.buy_qty_due)) < components_rec_.qty_assigned + components_rec_.qty_shipped) AND
               (components_rec_.qty_assigned + components_rec_.qty_shipped != 0)) THEN
               Raise_Sales_Qty_Less_Error___(newrec_.order_no, newrec_.line_no, newrec_.rel_no);
            END IF;
            IF (components_rec_.supply_code NOT IN ('PD','PT','IPD','IPT','SO','DOP') AND components_rec_.qty_on_order > 0) THEN
               IF(((newrec_.revised_qty_due * components_rec_.qty_per_assembly) - components_rec_.qty_assigned - components_rec_.qty_shipped - components_rec_.qty_on_order) < 0)THEN
                  Error_SYS.Record_General(lu_name_,'PEG_REV_QTY: There are manual peggings connected to this customer order line. Remove the pegging first, then modify the customer order line.');
               END IF;
            END IF;
         END LOOP;
      END IF;

      IF ((newrec_.revised_qty_due < newrec_.qty_assigned + newrec_.qty_shipped) AND
          (newrec_.qty_assigned + newrec_.qty_shipped != 0) AND
          (newrec_.supply_code NOT IN ('SEO','PKG'))) THEN
         Raise_Sales_Qty_Less_Error___(newrec_.order_no, newrec_.line_no, newrec_.rel_no);
      END IF;

      -- stop the process if there are manuly peggins exist and revised_qty_due decreased or else give the information message.
      IF (oldrec_.supply_code IN ('IO','PS') AND oldrec_.qty_on_order > 0) THEN
         IF (newrec_.revised_qty_due > oldrec_.revised_qty_due) THEN
            Client_SYS.Add_Info(lu_name_,'PEG_UNFULFILL: The pegged quantity does not fulfill all demand.');
         ELSIF ((newrec_.revised_qty_due - oldrec_.qty_assigned - oldrec_.qty_shipped - oldrec_.qty_on_order) < 0) THEN
            Error_SYS.Record_General(lu_name_,'PEG_REV_QTY: There are manual peggings connected to this customer order line. Remove the pegging first, then modify the customer order line.');
         END IF;
      END IF;
   END IF;

   IF ((newrec_.catalog_type = 'PKG') AND (newrec_.consignment_stock = 'CONSIGNMENT STOCK')) THEN
      Error_SYS.Record_General(lu_name_, 'NO_PKG_ON_CONSIGN: Consignment stock can not be used together with packages!');
   END IF;

   IF ((newrec_.close_tolerance < 0) OR NOT (newrec_.close_tolerance < 100)) THEN
      Error_SYS.Record_General(lu_name_, 'WRONG_CLOSE_TOL: The close tolerance must be less than 100!');
   END IF;

   IF ((newrec_.charged_item = 'ITEM NOT CHARGED') AND (newrec_.consignment_stock = 'CONSIGNMENT STOCK')) THEN
      Error_SYS.Record_General(lu_name_, 'CHARGED_CONSIGN: Consignment stock can not be used together with noncharge functionality.');
   END IF;

   company_           := Site_API.Get_Company(newrec_.contract);
   customer_contract_ := Cust_Ord_Customer_API.Get_Acquisition_Site(newrec_.customer_no);
   cust_contract_connected_comp_ := Site_API.Get_Company(customer_contract_);
   header_rec_ := Customer_Order_API.Get(newrec_.order_no);
   
   -- Make sure the specified ship address for the order line is valid.
   -- Make sure the tax information has been defined for the address of the ordering customer.
   IF (newrec_.ship_addr_no IS NOT NULL) THEN
      IF (newrec_.deliver_to_customer_no = newrec_.customer_no) THEN
         tax_customer_no_  := newrec_.deliver_to_customer_no;
         tax_ship_addr_no_ := newrec_.ship_addr_no;
      ELSE
         tax_customer_no_  := newrec_.customer_no;
         tax_ship_addr_no_ := header_rec_.ship_addr_no;
      END IF;

      IF ((NVL(cust_contract_connected_comp_, ' ') != company_) ) THEN
         IF ((newrec_.charged_item != 'ITEM NOT CHARGED') AND
          (newrec_.part_ownership NOT IN ('CUSTOMER OWNED', 'SUPPLIER LOANED')) AND
          (newrec_.exchange_item != 'EXCHANGED ITEM') AND 
           Customer_Delivery_Tax_Info_API.Check_Exist(tax_customer_no_, tax_ship_addr_no_, company_, header_rec_.supply_country) = 'FALSE') THEN
            Error_SYS.Record_General(lu_name_, 'NOTAXFORADDR: Customer Tax Information has not been defined for the delivery address.');
         END IF;
      ELSIF (newrec_.rental = Fnd_Boolean_API.DB_FALSE AND newrec_.part_ownership = Part_Ownership_API.DB_COMPANY_RENTAL_ASSET) THEN
         Error_SYS.Record_General(lu_name_,'IPTINTERNALDELERR: The part ownership Company Rental Asset is not allowed for internal deliveries.');
      END IF;

      IF ((newrec_.addr_flag = 'N') AND (NVL(newrec_.ship_addr_no, ' ') != NVL(oldrec_.ship_addr_no, ' ') OR (oldrec_.addr_flag = 'Y'))) THEN
         IF (Cust_Ord_Customer_Address_API.Is_Ship_Location(newrec_.deliver_to_customer_no, newrec_.ship_addr_no) = 0) THEN
            Error_SYS.Record_General(lu_name_, 'NOTDELADDR: Invalid delivery address specified.');
         END IF;

         IF (Cust_Ord_Customer_Address_API.Is_Valid(newrec_.deliver_to_customer_no, newrec_.ship_addr_no) = 0) THEN
            Error_SYS.Record_General(lu_name_, 'INVALIDDELADDR: Delivery address :P1 is invalid. Check the validity period.', newrec_.ship_addr_no);
         END IF;
      END IF;

      IF (NVL(newrec_.ship_addr_no, ' ') != NVL(oldrec_.ship_addr_no, ' ')) THEN
         -- check for consignment stock
         IF (newrec_.consignment_stock = 'CONSIGNMENT STOCK') THEN
            IF (NVL(Consignment_Stock_API.Encode(Customer_Consignment_Stock_API.Get_Consignment_Stock(newrec_.contract, newrec_.catalog_no,
                newrec_.customer_no, newrec_.ship_addr_no)), 'NO CONSIGNMENT STOCK') = 'NO CONSIGNMENT STOCK') THEN
               Error_SYS.Record_General(lu_name_, 'INVALID_CONS: The Consignment Stock flag has to be cleared for this order line before changing the delivery adress.');
            END IF;
         END IF;
      
         -- Added 'NON_DEFAULT_ADDR_CHANGE' check not to reset contact of lines on request to change line ship address with header Delivery address change
         IF (newrec_.default_addr_flag = 'N' AND NVL(Client_SYS.Get_Item_Value('NON_DEFAULT_ADDR_CHANGE', attr_), 'FALSE') = 'FALSE') THEN
            -- if not default values from order header, fetch new values from customer address
            -- Replaced with the deliver_to_customer_no
            IF ((newrec_.contact IS NULL) AND (NVL(change_request_, 'FALSE') = 'FALSE')) THEN
               newrec_.contact := Cust_Ord_Customer_Address_API.Get_Contact(newrec_.deliver_to_customer_no, newrec_.ship_addr_no);
               Client_SYS.Set_Item_Value('CONTACT', newrec_.contact, attr_);
            END IF;
         END IF;
      END IF;
   END IF;

   discount_freeze_db_ := Site_Discom_Info_API.Get_Discount_Freeze_Db(newrec_.contract);
   IF (newrec_.buy_qty_due != oldrec_.buy_qty_due) OR (NVL(newrec_.price_list_no, ' ') != NVL(oldrec_.price_list_no, ' ')) OR
       (NVL(to_char(newrec_.price_effectivity_date), '0') != NVL(to_char(oldrec_.price_effectivity_date), '0')
        OR (qty_refreshed_ = 1) OR (price_source_refreshed_ = 1)) THEN

      IF Cust_Order_Line_Discount_API.Check_Manual_Rows(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no) THEN
         IF NOT(newrec_.price_freeze = 'FROZEN' AND discount_freeze_db_ = 'TRUE') THEN
            Client_SYS.Add_Info(lu_name_, 'MANUAL: Manually entered discount exist. You may want to check the discount calculation.');
         END IF;
      END IF;
   END IF;

   IF (newrec_.configuration_id != '*') THEN
      Order_Config_Util_API.Configuration_Exist(NVL(newrec_.part_no, newrec_.catalog_no), newrec_.configuration_id);
   END IF;

   -- Added a condition to check for existing manual peggings.
   -- The information message is given if the planned_due_date is changed when there exist a manual pegging.
   IF ((newrec_.planned_due_date != oldrec_.planned_due_date) AND (oldrec_.supply_code IN ('IO','PS')) AND (oldrec_.qty_on_order > 0)) THEN
      Client_SYS.Add_Info(lu_name_, 'PEG_DUE_DATE: The customer order line planned due date has changed, review planned receipt date for pegged supply.');
   END IF;

   -- The information message is given if the condition_code is changed when there exist a manual pegging.
   IF ((newrec_.condition_code != oldrec_.condition_code) AND (oldrec_.supply_code IN ('IO','PS')) AND (oldrec_.qty_on_order > 0))THEN
      Error_SYS.Record_General(lu_name_, 'PEG_CON_CODE: The customer order line is pegged to a supply. Remove the pegging first, then change the condition code.');
   END IF;

   -- An error message is given if the configuration is changed when there exist a manual pegging.
   IF ((newrec_.configuration_id != oldrec_.configuration_id) AND (oldrec_.supply_code = 'IO') AND (oldrec_.qty_on_order > 0)) THEN
      Error_SYS.Record_General(lu_name_, 'PEG_CONFIG_ID: The customer order line is pegged to a supply. Remove the pegging first, then change the configuration.');
   END IF;

   IF ((newrec_.configuration_id != oldrec_.configuration_id) AND (newrec_.rowstate != 'Released')) THEN
      Error_SYS.Record_General(lu_name_, 'NOCONFIGCHANGE: Configuration cannot be updated when the customer order line is not in Released status.');
   END IF;

   -- send delivery info back to client if default_addr_flag has changed
   IF (newrec_.default_addr_flag != oldrec_.default_addr_flag) THEN
      Client_SYS.Set_Item_Value('DEFAULT_ADDR_FLAG_DB', newrec_.default_addr_flag, attr_);
      Client_SYS.Set_Item_Value('ADDR_FLAG_DB', newrec_.addr_flag, attr_);
      Client_SYS.Set_Item_Value('SHIP_ADDR_NO', newrec_.ship_addr_no, attr_);
      Client_SYS.Set_Item_Value('CONTACT', newrec_.contact, attr_);
      Client_SYS.Set_Item_Value('ROUTE_ID', newrec_.route_id, attr_);
      Client_SYS.Set_Item_Value('FORWARD_AGENT_ID', newrec_.forward_agent_id, attr_);
      Client_SYS.Set_Item_Value('SHIP_VIA_CODE', newrec_.ship_via_code, attr_);
      Client_SYS.Set_Item_Value('CUST_CALENDAR_ID', newrec_.cust_calendar_id, attr_);
      Client_SYS.Set_Item_Value('EXT_TRANSPORT_CALENDAR_ID', newrec_.ext_transport_calendar_id, attr_);
      Client_SYS.Set_Item_Value('DELIVERY_TERMS', newrec_.delivery_terms, attr_);
      Client_SYS.Set_Item_Value('DEL_TERMS_LOCATION', newrec_.del_terms_location, attr_);
      Client_SYS.Set_Item_Value('DELIVERY_LEADTIME', newrec_.delivery_leadtime, attr_);
      Client_SYS.Set_Item_Value('DISTRICT_CODE', newrec_.district_code, attr_);
      Client_SYS.Set_Item_Value('REGION_CODE', newrec_.region_code, attr_);
      Client_SYS.Set_Item_Value('TAX_LIABILITY', newrec_.tax_liability, attr_);
      Client_SYS.Set_Item_Value('INTRASTAT_EXEMPT_DB', newrec_.intrastat_exempt, attr_);
      Client_SYS.Set_Item_Value('SUPPLIER_SHIP_VIA_TRANSIT', newrec_.supplier_ship_via_transit, attr_);
      Client_SYS.Set_Item_Value('SUPPLIER_SHIP_VIA_TRANSIT_DESC', newrec_.supplier_ship_via_transit_desc, attr_);
      Client_SYS.Set_Item_Value('PICKING_LEADTIME', newrec_.picking_leadtime, attr_);
      Client_SYS.Set_Item_Value('SHIPMENT_TYPE', newrec_.shipment_type, attr_);
   END IF;

   IF ((newrec_.customer_part_no IS NOT NULL) AND (NVL(server_data_change_,'0') != '1')) THEN
      newrec_.customer_part_buy_qty := newrec_.buy_qty_due / NVL(newrec_.customer_part_conv_factor, 1) * NVL(newrec_.cust_part_invert_conv_fact, 1);
      Client_SYS.Set_Item_Value('CUSTOMER_PART_BUY_QTY', newrec_.customer_part_buy_qty, attr_);
   END IF;

   $IF (Component_Purch_SYS.INSTALLED)$THEN
      IF newrec_.demand_order_ref1 IS NOT NULL THEN
         order_code_ := Purchase_Order_API.Get_Order_Code(newrec_.demand_order_ref1);
      END IF;
   $END

   partca_condition_code_usage_ := Part_Catalog_API.Get_Condition_Code_Usage_Db(newrec_.part_no) ;
   IF ((newrec_.part_no IS NOT NULL) AND (NVL(server_data_change_,'0') != '1')) THEN
      IF (NVL(oldrec_.condition_code,'NOT_NULL') != NVL(newrec_.condition_code,'NOT_NULL')) THEN

         IF (header_rowstate_ NOT IN ('Planned')) THEN
            IF (newrec_.supply_code NOT IN ('PT', 'IPT', 'IO')) THEN
               cond_update_error_ := 'ERROR1';
            ELSIF (newrec_.rowstate != 'Released') THEN
               cond_update_error_ := 'ERROR2';
            ELSIF (newrec_.supply_code IN ('PT', 'IPT') AND newrec_.qty_on_order > 0) THEN
               Customer_Order_Pur_Order_API.Get_Purord_For_Custord(po_order_no_,
                                                                   po_line_no_,
                                                                   po_rel_no_,
                                                                   purchase_type_,
                                                                   newrec_.order_no,
                                                                   newrec_.line_no,
                                                                   newrec_.rel_no,
                                                                   newrec_.line_item_no);

               purchase_type_db_ := Purchase_Type_API.Encode(purchase_type_);
               IF (purchase_type_db_ = 'O') THEN 
                  cond_update_info_ := 'INFO1';
               ELSIF ( purchase_type_db_ = 'R') THEN
                  cond_update_info_ := 'INFO2';
               END IF;
            END IF;
         ELSIF (newrec_.rowstate != 'Released') THEN
            cond_update_error_ := 'ERROR2';
         END IF;

         IF cond_update_error_ = 'ERROR1' THEN
            Error_SYS.Record_General(lu_name_,'COND_UPD_NOTALLOW1: Condition code may not be changed after order is released.');
         ELSIF cond_update_error_ = 'ERROR2' THEN
            Error_SYS.Record_General(lu_name_,'COND_UPD_NOTALLOW2: Condition code may not be changed when order line is :P1.',newrec_.rowstate);
         ELSIF cond_update_info_ = 'INFO1' THEN
            Client_SYS.Add_Info(lu_name_,'COND_UPD_ALLOW1: The pegged purchase order line :P1 has a different condition code and will not be updated automatically.', po_order_no_);
         ELSIF cond_update_info_ = 'INFO2' THEN
            Client_SYS.Add_Info(lu_name_,'COND_UPD_ALLOW2: The pegged purchase requisition line :P1 has a different condition code and will not be updated automatically.', po_order_no_);
         END IF;

         IF (newrec_.condition_code IS NOT NULL) THEN
            IF (partca_condition_code_usage_= 'NOT_ALLOW_COND_CODE') THEN
               Error_SYS.Record_General(lu_name_,'COND_NOT_ALLOW: Condition code functionality is not enabled for this part. You cannot enter a condition code.');
            ELSE
               Condition_Code_API.Exist(newrec_.condition_code);
            END IF;

            IF (header_rowstate_ = 'Planned') THEN
               $IF (Component_Ordstr_SYS.INSTALLED)$THEN
                  IF (newrec_.ctp_planned = 'N') THEN
                      interim_header_id_ := Interim_Demand_Head_API.Get_Int_Head_By_Usage(
                                                   'CUSTOMERORDER', newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
                  ELSIF (newrec_.ctp_planned = 'Y') THEN
                      interim_header_id_ := Interim_Ctp_Manager_API.Get_Top_Int_Head_By_Usage(
                                                         'CUSTOMERORDER', newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
                  END IF;
               $END

               IF (interim_header_id_ IS NOT NULL) THEN
                   Error_SYS.Record_General(lu_name_,'CCUPDNOTALLWD: Condition code may not be changed, since Interim demand head :P1 exists.',
                                              interim_header_id_);
               END IF;
            END IF;
         ELSIF (partca_condition_code_usage_ = 'ALLOW_COND_CODE') THEN
            Error_SYS.Record_General(lu_name_,'COND_NOT_ALLOW0: Condition code functionality is enabled in the part catalog record for this part. You must enter a condition code.');
         END IF;
      END IF;
   ELSE
      IF (newrec_.condition_code IS NOT NULL) THEN
         IF (partca_condition_code_usage_ = 'NOT_ALLOW_COND_CODE') THEN
            Error_SYS.Record_General(lu_name_,'COND_NOT_ALLOW: Condition code functionality is not enabled for this part. You cannot enter a condition code.');
         ELSE
            Condition_Code_API.Exist(newrec_.condition_code);
         END IF;
      END IF;
   END IF;

   IF (newrec_.condition_code IS NOT NULL) THEN
      IF (newrec_.catalog_type = 'PKG') THEN
         Error_SYS.Record_General(lu_name_,'NO_COND_ON_PKG: Condition codes are not allowed for Package Parts.');
      ELSIF (newrec_.catalog_type = 'NON') THEN
         Error_SYS.Record_General(lu_name_,'NO_COND_ON_NON: Condition codes are not allowed for Non Inventory Sales Parts.');
      END IF;
   END IF;

   cust_ord_line_rec_ := Get(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);

   -- Part Ownership validations
   IF (newrec_.part_ownership IS NOT NULL) THEN
      IF (newrec_.rental = Fnd_Boolean_API.DB_FALSE AND newrec_.part_ownership = Part_Ownership_API.DB_SUPPLIER_RENTED) THEN
         Error_SYS.Record_General(lu_name_, 'INVALIDNONRENTPARTOWN: Ownership :P1 is not allowed for the non-rental lines.', Part_Ownership_API.Decode(newrec_.part_ownership));
      END IF;
      IF (newrec_.rental = Fnd_Boolean_API.DB_TRUE AND newrec_.part_ownership NOT IN (Part_Ownership_API.DB_SUPPLIER_RENTED,
                                                                                      Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)) THEN
         Error_SYS.Record_General(lu_name_, 'INVALIDRENTALPARTOWN: Ownership :P1 is not allowed for the rental lines.', Part_Ownership_API.Decode(newrec_.part_ownership));
      END IF;
      IF (newrec_.supply_code = 'IO') THEN
         IF (newrec_.part_ownership NOT IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                            Part_Ownership_API.DB_CUSTOMER_OWNED,
                                            Part_Ownership_API.DB_SUPPLIER_LOANED,
                                            Part_Ownership_API.DB_SUPPLIER_RENTED,
                                            Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)) THEN
            Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      ELSIF (newrec_.supply_code IN ('SO', 'MRO', 'SEO')) THEN
         IF (newrec_.part_ownership NOT IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                            Part_Ownership_API.DB_CUSTOMER_OWNED)) THEN
            Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      ELSIF (newrec_.supply_code = 'ND') THEN
         IF (newrec_.part_ownership NOT IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                            Part_Ownership_API.DB_SUPPLIER_RENTED,
                                            Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)) THEN
            Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      ELSIF (newrec_.supply_code = 'NO') THEN
         IF (newrec_.part_ownership NOT IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                            Part_Ownership_API.DB_SUPPLIER_RENTED,
                                            Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)) THEN
            Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      ELSIF (newrec_.supply_code IN ('PT', 'IPT')) THEN
         IF (newrec_.part_ownership NOT IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                            Part_Ownership_API.DB_COMPANY_RENTAL_ASSET,
                                            Part_Ownership_API.DB_SUPPLIER_RENTED)) THEN
            Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      ELSIF (newrec_.supply_code IN ('PD', 'IPD')) THEN
         IF (newrec_.rental = Fnd_Boolean_API.DB_FALSE) THEN
            IF (newrec_.part_ownership NOT IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                               Part_Ownership_API.DB_SUPPLIER_RENTED)) THEN
               Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
            END IF;
         ELSE
            Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      ELSIF (newrec_.supply_code IN ('DOP', 'PKG','PS')) THEN
         IF (newrec_.part_ownership != Part_Ownership_API.DB_COMPANY_OWNED) THEN
            Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      END IF;

      IF (newrec_.supply_code = 'SO' AND NOT supply_code_changed_) THEN
         IF (header_rowstate_ != 'Planned') AND (newrec_.part_ownership != oldrec_.part_ownership) THEN
            Error_SYS.Record_General(lu_name_, 'PARTOWN_CHANGED: Ownership cannot be changed after order is released.');
         END IF;
      END IF;

      IF (newrec_.line_item_no > 0) THEN
         IF (newrec_.part_ownership != Part_Ownership_API.DB_COMPANY_OWNED) THEN
            Error_SYS.Record_General(lu_name_,'INVALIDCOMPART: Ownership :P1 is not allowed for component parts.', Part_Ownership_API.Decode(newrec_.part_ownership));
         END IF;
      END IF;

      -- Check if the part_ownership is changed in a way that affects peggings
      IF ((newrec_.part_ownership != cust_ord_line_rec_.part_ownership) AND (cust_ord_line_rec_.supply_code ='IO') AND (cust_ord_line_rec_.qty_on_order>0) AND (cust_ord_line_rec_.part_no IS NOT NULL)) THEN
         Error_SYS.Record_General(lu_name_, 'MANPEGOWNCODE: You are not allowed to change owner conditions for pegged customer order lines, remove the pegging first.');
      END IF;

      IF (newrec_.consignment_stock = 'CONSIGNMENT STOCK') AND (newrec_.part_ownership != Part_Ownership_API.DB_COMPANY_OWNED) THEN
         Error_SYS.Record_General(lu_name_,'INVALIDCONOWNERSHIP: Only ownership company owned is allowed for consignment stock.');
      END IF;

      IF (newrec_.part_ownership = Part_Ownership_API.DB_CUSTOMER_OWNED) AND (newrec_.owning_customer_no IS NULL) THEN
         Error_SYS.Record_General(lu_name_,'OWNINGCUSNONULL: There should be a owning customer for customer owned stock.');
      END IF;

   END IF;

   -- Check if the owner is changed in a way that affects peggings
   IF ((newrec_.owning_customer_no != cust_ord_line_rec_.owning_customer_no) AND (cust_ord_line_rec_.supply_code ='IO') AND (cust_ord_line_rec_.qty_on_order>0) AND (cust_ord_line_rec_.part_no IS NOT NULL)) THEN
      Error_SYS.Record_General(lu_name_, 'MANPEGOWNCODE: You are not allowed to change owner conditions for pegged customer order lines, remove the pegging first.');
   END IF;

   IF (newrec_.part_no IS NOT NULL) THEN
      IF (company_ = cust_contract_connected_comp_) THEN
         IF (sales_part_rec_.part_no != Sales_Part_API.Get_Part_No(newrec_.contract, newrec_.original_part_no)) THEN
            Error_SYS.Record_General(lu_name_, 'REPARTEXISTS: You are not allowed to replace the sales part :P1 with the sales part :P2 since the intersite flow occurs within a single company.' ,newrec_.original_part_no, sales_part_rec_.part_no);
         END IF;
      END IF;

      IF (newrec_.supply_code = 'IPT' OR newrec_.supply_code = 'IPD') THEN
         supplier_acquisition_site_ := Get_Vendor_Contract__(newrec_.vendor_no, NULL, NULL, NULL, newrec_.rental);

         IF (supplier_acquisition_site_ IS NOT NULL) THEN
            IF (Site_API.Get_Company(supplier_acquisition_site_) = company_) THEN

               IF (NOT Inventory_Part_API.Check_Exist(supplier_acquisition_site_, newrec_.part_no)) THEN
                  Error_SYS.Record_General(lu_name_, 'NOVENDPART: Creation of internal order lines are not allowed when inventory part :P1 does not exist in supplier site :P2.', newrec_.part_no, supplier_acquisition_site_);
               END IF;

               IF (newrec_.rental = Fnd_Boolean_API.DB_TRUE AND newrec_.supply_code = 'IPT' AND newrec_.part_ownership != Part_Ownership_API.DB_COMPANY_RENTAL_ASSET) THEN
                  Error_SYS.Record_General(lu_name_,'INVALIDRENTPARTCRA: Ownership Type :P1 is not allowed for this supply code if the supply site belongs to the same company.', Part_Ownership_API.Decode(newrec_.part_ownership));
               END IF;
            ELSE
               IF (newrec_.rental = Fnd_Boolean_API.DB_TRUE AND newrec_.supply_code = 'IPT' AND newrec_.part_ownership != Part_Ownership_API.DB_SUPPLIER_RENTED) THEN
                  Error_SYS.Record_General(lu_name_,'INVALIDRENTPARTSR: Ownership Type :P1 is not allowed for this supply code if the supply site belongs to a different company.', Part_Ownership_API.Decode(newrec_.part_ownership));
               END IF;
            END IF;
         END IF;
      END IF;

      cust_acquisition_site_ := customer_contract_;

      IF (Site_API.Get_Company(cust_acquisition_site_)= company_) AND (cust_acquisition_site_ IS NOT NULL) THEN
         IF (NOT Inventory_Part_API.Check_Exist(cust_acquisition_site_,
                                                newrec_.part_no)) THEN
            Error_SYS.Record_General(lu_name_, 'NOCUSTPART: Creation of Internal Order Lines are not allowed when Inventory Part :P1 does not exist in Customer Site :P2', newrec_.part_no, cust_acquisition_site_);
         END IF;
      END IF;
   END IF;

   -- Change the shipment creation to NO_AUTOMATIC if single occurence is ticked or supply code is IPD/PD/ND
   
   -- IF not package ('Supply PKG') and if supply from purchase direct or SEO or package component part supply is not decided then set the shipment creation to the 'NO_AUTOMATIC'
   IF ( newrec_.supply_code IN ( 'PD', 'SEO') OR (newrec_.supply_code = 'ND' AND newrec_.line_item_no >0) ) THEN
      IF (newrec_.shipment_creation != 'NO_AUTOMATIC') THEN
         newrec_.shipment_creation := 'NO_AUTOMATIC';
         Raise_Shipment_Chaged_New();
         IF newrec_.supply_code NOT IN ('IPD', 'PD') THEN
            IF (newrec_.line_item_no > 0) OR ((newrec_.line_item_no = 0) AND (newrec_.supply_code = 'SEO')) THEN
               Client_SYS.Add_Info(lu_name_, 'SHIPMENT_CHANGED: According to the shipment creation method, the line should be connected automatically to a shipment. This will not happen due to the supply code of the line.');
            END IF;
         END IF;
      END IF;
   ELSIF  ( (newrec_.supply_code != oldrec_.supply_code) AND (oldrec_.supply_code IN ( 'PD', 'SEO')) AND (newrec_.supply_code NOT IN ( 'PD', 'SEO')) ) THEN
      newrec_.shipment_creation := header_rec_.shipment_creation;    
   END IF;

   -- Added ELSIF condition to inform user about the modification in shipment creation does not transfer to the supply site.   
   IF ((newrec_.shipment_creation != oldrec_.shipment_creation ) AND (newrec_.supply_code != 'IPD')) THEN
      IF ( newrec_.shipment_creation = 'ORDER_RELEASE' AND  header_rowstate_ != 'Planned') THEN
         Error_SYS.Record_General(lu_name_,'INVALSHIPCREATION: Shipment creation cannot be :P1 when the customer order is in :P2 state.', Shipment_Creation_API.Decode (newrec_.shipment_creation), CUSTOMER_ORDER_API.Finite_State_Decode__(header_rowstate_) );
      END IF;
   END IF;

   IF( newrec_.shipment_type != oldrec_.shipment_type ) OR ( newrec_.shipment_creation != oldrec_.shipment_creation ) THEN
      -- Information message should not raise for the component part where package update will trigger this message.
      IF ( newrec_.supply_code = 'IPD' AND newrec_.line_item_no <= 0 AND header_rowstate_ != 'Planned' ) THEN
         Client_SYS.Add_Info(lu_name_, 'IPDSHIPTYPCRECHANGE: Changes to the shipment type/shipment creation method will not be reflected in the supplier site. The required changes will have to be manually updated in the customer order of the supply site.');
      END IF;
   END IF;

   -- Validate non-inventory part shipment creation.
   -- For non-inventory part used with IPD, it should be able to have any shipment creation. Else it does not need to have shipment creation as picklist creation.
   IF ((newrec_.catalog_type = 'NON' AND newrec_.supply_code != 'IPD' )OR
       -- For package part if all non invnetory part and not all supply though Int Purch Direct then reset package shipment creation to 'NO_AUTOMATIC' if shipment creation used when Pick list creation
       (newrec_.catalog_type = 'PKG' AND All_Non_Inv_Parts(newrec_.order_no, newrec_.line_no, newrec_.rel_no) AND NOT All_Components_Supply_Ipd (newrec_.order_no, newrec_.line_no, newrec_.rel_no) AND (insert_package_mode_ = 'FALSE')))
       AND (newrec_.shipment_creation = 'PICK_LIST_CREATION') AND (oldrec_.shipment_creation != newrec_.shipment_creation) THEN
         Raise_Info_Message___;
   END IF;

   IF (newrec_.provisional_price = 'TRUE' AND newrec_.price_freeze = 'FROZEN') THEN
      Error_SYS.Record_General(lu_name_, 'SALES_PRICE_TYPE: It is not allowed to select provisional price and price freeze together.');
   END IF;
END Check_Before_Update___;


-- Pre_Unpack_Insert___
--   Initialize record with default values before Unpack_Check_Insert___ loop
PROCEDURE Pre_Unpack_Insert___ (
   attr_      IN OUT VARCHAR2,
   newrec_    IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
   site_date_                 DATE;
   address_rec_               Cust_Ord_Customer_Address_API.Public_Rec;
   packrec_                   CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   company_                   VARCHAR2(20);
   customer_agreement_        VARCHAR2(20);
   delivery_terms_            VARCHAR2(5);
   price_source_              VARCHAR2(200);
   price_source_db_           CUSTOMER_ORDER_LINE_TAB.Price_Source%TYPE;
   demand_code_               CUSTOMER_ORDER_LINE_TAB.demand_code%TYPE;
   supply_code_db_            CUSTOMER_ORDER_LINE_TAB.supply_code%TYPE;
   line_item_no_              CUSTOMER_ORDER_LINE_TAB.line_item_no%TYPE;
   revised_qty_due_           NUMBER;
   inv_part_cost_level_db_    VARCHAR2(50);
   agreement_rec_             Customer_Agreement_API.Public_Rec;
   sales_part_rec_            Sales_Part_API.Public_Rec;
   default_addr_flag_db_      CUSTOMER_ORDER_LINE_TAB.default_addr_flag%TYPE;
   shipment_type_sent_        VARCHAR2(5):= 'FALSE';
   shipment_creation_sent_    VARCHAR2(5):= 'FALSE';
   packed_ship_cre_in_init_   VARCHAR2(5):= 'FALSE';
   order_rec_                 CUSTOMER_ORDER_API.Public_Rec;
   duplicate_line_            BOOLEAN := FALSE;
   temprec_                   CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   deliver_country_db_        VARCHAR2(2);
   tax_liability_             VARCHAR2(20);
   substitutable_part_        VARCHAR2(25);
   sprec_                     Sales_Part_API.Public_Rec; 
   new_attr_                  VARCHAR2(32000);
   discount_                  CUSTOMER_ORDER_LINE_TAB.discount%TYPE;
   copy_discount_             VARCHAR2(5);
   create_partial_sum_        CUST_ORDER_LINE_DISCOUNT_TAB.Create_Partial_Sum%TYPE;   
   auto_substitution_allowed_ BOOLEAN;
BEGIN
   newrec_.order_no               := Client_SYS.Get_Item_Value('ORDER_NO', attr_);
   newrec_.contract               := Client_SYS.Get_Item_Value('CONTRACT', attr_);
   newrec_.part_no                := Client_SYS.Get_Item_Value('PART_NO', attr_);
   newrec_.purchase_part_no       := Client_SYS.Get_Item_Value('PURCHASE_PART_NO', attr_);
   newrec_.sup_sm_contract        := Client_SYS.Get_Item_Value('SUP_SM_CONTRACT', attr_);
   newrec_.originating_rel_no     := Client_SYS.Get_Item_Value('ORIGINATING_REL_NO', attr_);
   newrec_.condition_code         := Client_SYS.Get_Item_Value('CONDITION_CODE', attr_);
   newrec_.deliver_to_customer_no := Client_SYS.Get_Item_Value('DELIVER_TO_CUSTOMER_NO', attr_);
   demand_code_                   := NVL(Client_SYS.Get_Item_Value('DEMAND_CODE_DB', attr_),
                                     Order_Supply_Type_Api.Encode(Client_SYS.Get_Item_Value('DEMAND_CODE', attr_)));
   supply_code_db_                := NVL(Client_SYS.Get_Item_Value('SUPPLY_CODE_DB', attr_),
                                     Order_Supply_Type_API.Encode(Client_SYS.Get_Item_Value('SUPPLY_CODE', attr_)));
   newrec_.addr_flag              := NVL(Client_SYS.Get_Item_Value('ADDR_FLAG_DB', attr_),
                                     Gen_Yes_No_API.Encode(Client_SYS.Get_Item_Value('ADDR_FLAG', attr_)));
   newrec_.part_ownership         := NVL(Client_SYS.Get_Item_Value('PART_OWNERSHIP_DB', attr_),
                                     Part_Ownership_API.Encode(Client_SYS.Get_Item_Value('PART_OWNERSHIP', attr_)));
   newrec_.buy_qty_due            := Client_SYS.Get_Item_Value('BUY_QTY_DUE', attr_);
   newrec_.configuration_id       := Client_SYS.Get_Item_Value('CONFIGURATION_ID', attr_);
   newrec_.catalog_no             := Client_SYS.Get_Item_Value('CATALOG_NO', attr_);
   sales_part_rec_                := Sales_Part_API.Get(newrec_.contract,newrec_.catalog_no);
   IF ((Client_SYS.Get_Item_Value('SHIPMENT_CREATION', attr_) IS NOT NULL) OR (Client_SYS.Get_Item_Value('SHIPMENT_CREATION_DB', attr_) IS NOT NULL)) THEN
      shipment_creation_sent_ := 'TRUE';
   END IF;
   IF (Client_SYS.Get_Item_Value('SHIPMENT_TYPE', attr_) IS NOT NULL) THEN
      shipment_type_sent_ :=  'TRUE';
   END IF;

   default_addr_flag_db_ := NVL(Client_SYS.Get_Item_Value('DEFAULT_ADDR_FLAG_DB', attr_),
                                Gen_Yes_No_API.Encode(Client_SYS.Get_Item_Value('DEFAULT_ADDR_FLAG', attr_)));
   newrec_.rental        := NVL(Client_SYS.Get_Item_Value('RENTAL_DB', attr_), Fnd_Boolean_API.DB_FALSE);
   
   newrec_.ctp_planned            := Client_SYS.Get_Item_Value('CTP_PLANNED_DB', attr_);
   IF newrec_.part_no IS NULL THEN
      newrec_.part_no := sales_part_rec_.part_no;
   END IF;
   -- Calculate and reset cost if supply code is not Service Order
   IF NVL(supply_code_db_, ' ') != 'SEO' THEN
      revised_qty_due_ := newrec_.buy_qty_due * sales_part_rec_.conv_factor / sales_part_rec_.inverted_conv_factor;

      -- (For configured parts cost should be calculated using the interim order functionality)
      inv_part_cost_level_db_ := Inventory_Part_API.Get_Invent_Part_Cost_Level_Db(newrec_.contract,newrec_.part_no);
      IF (inv_part_cost_level_db_ != 'COST PER CONFIGURATION') AND (newrec_.ctp_planned != 'Y') THEN
         IF (inv_part_cost_level_db_ != 'COST PER CONDITION') OR (newrec_.condition_code IS NOT NULL) THEN
            IF (revised_qty_due_ IS NOT NULL) THEN
               newrec_.cost := Sales_Cost_Util_API.Get_Cost_Incl_Sales_Overhead(newrec_.contract,
                                                                               newrec_.part_no,
                                                                               NVL(newrec_.configuration_id,'*'),
                                                                               newrec_.condition_code,
                                                                               revised_qty_due_,
                                                                               'CHARGED ITEM',
                                                                               supply_code_db_,
                                                                               order_rec_.customer_no,
                                                                               newrec_.part_ownership);

               Client_SYS.Set_Item_Value('COST', newrec_.cost, attr_);
            END IF;
         END IF;
      END IF;
   END IF;
   

   order_rec_                      := CUSTOMER_ORDER_API.Get(newrec_.order_no);
   newrec_.customer_no             := order_rec_.customer_no;
   newrec_.cust_calendar_id        := order_rec_.cust_calendar_id;
   newrec_.deliver_to_customer_no  := NVL(newrec_.deliver_to_customer_no, order_rec_.customer_no);
   newrec_.qty_invoiced            := 0;
   newrec_.qty_returned            := 0;
   newrec_.qty_shipdiff            := 0;
   newrec_.qty_on_order            := 0;
   newrec_.qty_to_ship             := 0;
   newrec_.line_total_weight       := 0;
   newrec_.line_total_qty          := 0;
   newrec_.qty_picked              := 0;
   site_date_                      := Site_API.Get_Site_Date(newrec_.contract);
   newrec_.date_entered            := site_date_;
   newrec_.planned_due_date        := TRUNC(site_date_);
   newrec_.qty_short               := 0;
   newrec_.order_discount          := 0;
   newrec_.charged_item            := 'CHARGED ITEM';
   newrec_.staged_billing          := 'NOT STAGED BILLING';
   newrec_.sm_connection           := 'NOT CONNECTED';
   newrec_.order_code              := order_rec_.order_code;
   newrec_.ctp_planned             := 'N';
   newrec_.release_planning        := 'NOTRELEASED';
   newrec_.qty_confirmeddiff       := 0;
   newrec_.line_total_weight_gross := 0;
   newrec_.adjusted_weight_net     := 0;
   newrec_.adjusted_weight_gross   := 0;
   newrec_.adjusted_volume         := 0;
   newrec_.qty_shipped             := 0;
   newrec_.open_shipment_qty       := 0;
   newrec_.shipment_connected      := 'FALSE';
   newrec_.delivery_confirmed      := 'FALSE';
   newrec_.conv_factor             := NVL(Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('CONV_FACTOR', attr_)),NVL(sales_part_rec_.conv_factor,1));
   newrec_.inverted_conv_factor    := NVL(Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('INVERTED_CONV_FACTOR', attr_)),NVL(sales_part_rec_.inverted_conv_factor,1));
   auto_substitution_allowed_      := Substitute_Sales_Part_API.Allow_Auto_Substitution(newrec_.contract, newrec_.customer_no);

   Client_SYS.Add_To_Attr('ORDER_CODE', newrec_.order_code, attr_);
   Client_SYS.Add_To_Attr('FREIGHT_FREE_DB', 'FALSE', attr_);

   -- Initialize desired_qty using buy_qty_due
   newrec_.desired_qty := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('BUY_QTY_DUE', attr_));
   line_item_no_       := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('LINE_ITEM_NO', attr_));

   IF (line_item_no_ > 0) THEN
      Trace_SYS.Message('Package component - fetch values from package header...');
      -- fetch package header line to assign the same values to the component.
      newrec_.order_no := Client_SYS.Get_Item_Value('ORDER_NO', attr_);
      newrec_.line_no  := Client_SYS.Get_Item_Value('LINE_NO', attr_);
      newrec_.rel_no   := Client_SYS.Get_Item_Value('REL_NO', attr_);
      packrec_         := Get_Object_By_Keys___(newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1);

      IF (supply_code_db_ NOT IN ('IPD', 'PD')) OR (default_addr_flag_db_ IS NULL) THEN
         Client_SYS.Set_Item_Value('DEFAULT_ADDR_FLAG_DB', packrec_.default_addr_flag,   attr_);
      END IF;
      Client_SYS.Set_Item_Value('ADDR_FLAG_DB',         packrec_.addr_flag,           attr_);
      Client_SYS.Set_Item_Value('SHIP_ADDR_NO',         packrec_.ship_addr_no,        attr_);
      Client_SYS.Set_Item_Value('CONTACT',              packrec_.contact,             attr_);
      Client_SYS.Set_Item_Value('ROUTE_ID',             packrec_.route_id,            attr_);
      Client_SYS.Set_Item_Value('FORWARD_AGENT_ID',     packrec_.forward_agent_id,    attr_);
      Client_SYS.Set_Item_Value('DELIVERY_TERMS',       packrec_.delivery_terms,      attr_);
      Client_SYS.Set_Item_Value('DEL_TERMS_LOCATION',   packrec_.del_terms_location,  attr_);
      Client_SYS.Set_Item_Value('DISTRICT_CODE',        packrec_.district_code,       attr_);
      Client_SYS.Set_Item_Value('REGION_CODE',          packrec_.region_code,         attr_);
      Client_SYS.Set_Item_Value('TAX_LIABILITY',        packrec_.tax_liability,       attr_);
      Client_SYS.Set_Item_Value('INTRASTAT_EXEMPT_DB',  packrec_.intrastat_exempt,    attr_);
      Client_SYS.Set_Item_Value('RELEASE_PLANNING_DB',  packrec_.release_planning,    attr_);
      Client_SYS.Set_Item_Value('SHIPMENT_CREATION_DB', packrec_.shipment_creation,   attr_);
      Client_SYS.Set_Item_Value('TAX_ID_NO',            packrec_.tax_id_no,              attr_);
      Client_SYS.Set_Item_Value('TAX_ID_VALIDATED_DATE',packrec_.tax_id_validated_date,      attr_);
      Client_SYS.Set_Item_Value('REBATE_BUILDER_DB',    packrec_.rebate_builder,      attr_);
      IF (packrec_.activity_seq IS NOT NULL) THEN
         Client_SYS.Set_Item_Value('ACTIVITY_SEQ',      packrec_.activity_seq,        attr_);
      END IF;
      Client_SYS.Set_Item_Value('SHIPMENT_TYPE',        packrec_.shipment_type,       attr_);
      Client_SYS.Set_Item_Value('COUNTRY_CODE',         packrec_.country_code,        attr_);
      Client_SYS.Set_Item_Value('TAX_LIABILITY_TYPE_DB',packrec_.tax_liability_type,  attr_);
   ELSE
      Trace_SYS.Message('Package header or normal line - set values according to default addr flag.');

      -- Retrive the ship address if any
      newrec_.ship_addr_no := Client_SYS.Get_Item_Value('SHIP_ADDR_NO', attr_);
      
      -- IF no ship address was passed in, retrive the default to deliver to customer.
      IF (newrec_.ship_addr_no IS NULL) THEN
         newrec_.ship_addr_no := Cust_Ord_Customer_API.Get_Delivery_Address(newrec_.deliver_to_customer_no);
      END IF;
         
      IF (NVL(newrec_.ship_addr_no, ' ') != order_rec_.ship_addr_no) THEN
         -- The ship address for the line is different than the one on the order
         newrec_.default_addr_flag := 'N';
      ELSE
         IF (Client_SYS.Get_Item_Value('EVALUATE_DEFAULT_INFO', attr_) = 'TRUE') THEN
            duplicate_line_ := TRUE;
            attr_ := Client_SYS.Remove_Attr('EVALUATE_DEFAULT_INFO', attr_);
         END IF;
         IF (duplicate_line_ OR auto_substitution_allowed_) THEN
            temprec_.order_no           := Client_SYS.Get_Item_Value('ORDER_NO', attr_);
            temprec_.default_addr_flag  := Client_SYS.Get_Item_Value('DEFAULT_ADDR_FLAG_DB', attr_);
            temprec_.addr_flag          := Client_SYS.Get_Item_Value('ADDR_FLAG_DB', attr_);
            temprec_.ship_addr_no       := Client_SYS.Get_Item_Value('SHIP_ADDR_NO', attr_);
            
            temprec_.route_id           := Client_SYS.Get_Item_Value('ROUTE_ID', attr_);
            temprec_.forward_agent_id   := Client_SYS.Get_Item_Value('FORWARD_AGENT_ID', attr_);
            temprec_.ship_via_code      := Client_SYS.Get_Item_Value('SHIP_VIA_CODE', attr_);
            temprec_.delivery_terms     := Client_SYS.Get_Item_Value('DELIVERY_TERMS', attr_);
            temprec_.del_terms_location := Client_SYS.Get_Item_Value('DEL_TERMS_LOCATION', attr_);
            temprec_.delivery_leadtime  := Client_SYS.Get_Item_Value('DELIVERY_LEADTIME', attr_);
            temprec_.picking_leadtime   := Client_SYS.Get_Item_Value('PICKING_LEADTIME', attr_);
            temprec_.shipment_type      := Client_SYS.Get_Item_Value('SHIPMENT_TYPE', attr_);
            temprec_.ext_transport_calendar_id := Client_SYS.Get_Item_Value('EXT_TRANSPORT_CALENDAR_ID', attr_);
            temprec_.cust_calendar_id   := Client_SYS.Get_Item_Value('CUST_CALENDAR_ID', attr_);
            temprec_.district_code      := Client_SYS.Get_Item_Value('DISTRICT_CODE', attr_);
            temprec_.region_code        := Client_SYS.Get_Item_Value('REGION_CODE', attr_);
            temprec_.shipment_creation  := Shipment_Creation_API.Encode(Client_SYS.Get_Item_Value('SHIPMENT_CREATION', attr_));
            temprec_.contact            := Client_SYS.Get_Item_Value('CONTACT', attr_);
            temprec_.tax_liability      := Client_SYS.Get_Item_Value('TAX_LIABILITY', attr_);
            temprec_.freight_map_id     := Client_SYS.Get_Item_Value('FREIGHT_MAP_ID', attr_);
            temprec_.zone_id            := Client_SYS.Get_Item_Value('ZONE_ID', attr_);
            temprec_.freight_price_list_no := Client_SYS.Get_Item_Value('FREIGHT_PRICE_LIST_NO', attr_);
            temprec_.intrastat_exempt   := Client_SYS.Get_Item_Value('INTRASTAT_EXEMPT_DB', attr_);            
            temprec_.country_code       := Client_SYS.Get_Item_Value('COUNTRY_CODE', attr_);
            temprec_.tax_liability_type := Tax_Liability_API.Get_Tax_Liability_Type_Db(temprec_.tax_liability, temprec_.ship_addr_no);
        
            newrec_.default_addr_flag := Check_Default_Addr_Flag___(temprec_, temprec_.order_no, temprec_.default_addr_flag, duplicate_line_);
         ELSE
            -- Check the DB value for default address flag
            newrec_.default_addr_flag := Client_SYS.Get_Item_Value('DEFAULT_ADDR_FLAG_DB', attr_);
         END IF;   
      END IF;

      Trace_SYS.Field('DEFAULT_ADDR_FLAG', newrec_.default_addr_flag);

      --If IPD and no value is sent via ORDERS message copy tax_id_no from header.
      IF (NVL(demand_code_, Database_SYS.string_null_) != 'IPD' ) AND (Client_SYS.Get_Item_Value('TAX_ID_NO', attr_) IS NULL) THEN
         Client_SYS.Set_Item_Value('TAX_ID_NO', order_rec_.tax_id_no, attr_);
         Client_SYS.Set_Item_Value('TAX_ID_VALIDATED_DATE', order_rec_.tax_id_validated_date, attr_);
      END IF;

      IF (NVL(Client_SYS.Get_Item_Value('COPY_ORDER_LINE', attr_), 'FALSE') = 'FALSE') THEN
         -- if default flag is set, set order header values for the delivery address info
         IF (newrec_.default_addr_flag = 'Y') THEN
            Client_SYS.Set_Item_Value('ADDR_FLAG_DB',        order_rec_.addr_flag,           attr_);
            Client_SYS.Set_Item_Value('SHIP_ADDR_NO',        order_rec_.ship_addr_no,        attr_);
            Client_SYS.Set_Item_Value('CONTACT',             order_rec_.cust_ref,            attr_);
            Client_SYS.Set_Item_Value('ROUTE_ID',            order_rec_.route_id,            attr_);
            Client_SYS.Set_Item_Value('FORWARD_AGENT_ID',    order_rec_.forward_agent_id,    attr_);
            Client_SYS.Set_Item_Value('DISTRICT_CODE',       order_rec_.district_code,       attr_);
            Client_SYS.Set_Item_Value('REGION_CODE',         order_rec_.region_code,         attr_);
            Client_SYS.Set_Item_Value('TAX_LIABILITY',       order_rec_.tax_liability,       attr_);
            Client_SYS.Set_Item_Value('INTRASTAT_EXEMPT_DB', order_rec_.intrastat_exempt,    attr_);

            IF (NVL((Client_SYS.Get_Item_Value('DEMAND_CODE_DB', attr_)), 'IPT') != 'IPT') THEN
               Client_SYS.Set_Item_Value('DELIVERY_TERMS',      order_rec_.delivery_terms,      attr_);
               Client_SYS.Set_Item_Value('DEL_TERMS_LOCATION',  order_rec_.del_terms_location,  attr_);
            END IF;
            IF (shipment_creation_sent_ = 'FALSE') THEN
               Client_SYS.Set_Item_Value('SHIPMENT_CREATION_DB', order_rec_.shipment_creation, attr_);
            END IF;

            deliver_country_db_  := Customer_Order_Address_API.Get_Country_Code(newrec_.order_no);

            Client_SYS.Set_Item_Value('COUNTRY_CODE',          deliver_country_db_,        attr_);
            Client_SYS.Set_Item_Value('TAX_LIABILITY_TYPE_DB', Tax_Liability_API.Get_Tax_Liability_Type_Db(order_rec_.tax_liability, deliver_country_db_), attr_);
         -- otherwise fetch values from customer and customer address
         ELSE
            Trace_SYS.Field('Inherit values from ship address no', newrec_.ship_addr_no);

            address_rec_ := Cust_Ord_Customer_Address_API.Get(newrec_.deliver_to_customer_no, newrec_.ship_addr_no);

            -- IF it is an internal direct delivery, then don't alter attr_.
            IF ( NVL(demand_code_, Database_SYS.string_null_) != 'IPD' ) THEN
               -- When delivery terms for the line is different than the ones on the order
               IF (Client_SYS.Get_Item_Value('DELIVERY_TERMS', attr_) IS NULL) THEN
                  Client_SYS.Set_Item_Value('DELIVERY_TERMS', address_rec_.delivery_terms, attr_);
               END IF;
               IF (Client_SYS.Get_Item_Value('DEL_TERMS_LOCATION', attr_) IS NULL) THEN
                  Client_SYS.Set_Item_Value('DEL_TERMS_LOCATION', address_rec_.del_terms_location, attr_);
               END IF;
               Client_SYS.Set_Item_Value('INTRASTAT_EXEMPT_DB', address_rec_.intrastat_exempt, attr_);

               IF (Client_SYS.Get_Item_Value('DISTRICT_CODE', attr_) IS NULL) THEN
                  Client_SYS.Set_Item_Value('DISTRICT_CODE', address_rec_.district_code, attr_);
               END IF;
               IF (Client_SYS.Get_Item_Value('REGION_CODE', attr_) IS NULL) THEN
                  Client_SYS.Set_Item_Value('REGION_CODE', address_rec_.region_code, attr_);
               END IF;
            END IF;

            company_ := Site_API.Get_Company(newrec_.contract);

            IF (Client_SYS.Get_Item_Value('TAX_LIABILITY', attr_) IS NULL) THEN
               IF (order_rec_.customer_no = newrec_.deliver_to_customer_no) THEN
                  Client_SYS.Set_Item_Value('TAX_LIABILITY', Tax_Handling_Util_API.Get_Customer_Tax_Liability(newrec_.customer_no, newrec_.ship_addr_no, company_, order_rec_.supply_country), attr_);
               ELSE
                  Client_SYS.Set_Item_Value('TAX_LIABILITY', Tax_Handling_Util_API.Get_Customer_Tax_Liability(newrec_.customer_no, order_rec_.ship_addr_no, company_, order_rec_.supply_country), attr_);
               END IF;
            END IF;

            tax_liability_       := Client_SYS.Get_Item_Value('TAX_LIABILITY', attr_);
            deliver_country_db_  := Cust_Ord_Customer_Address_API.Get_Country_Code(newrec_.deliver_to_customer_no, newrec_.ship_addr_no);

            Client_SYS.Set_Item_Value('COUNTRY_CODE', deliver_country_db_, attr_);
            Client_SYS.Set_Item_Value('TAX_LIABILITY_TYPE_DB', Tax_Liability_API.Get_Tax_Liability_Type_Db(tax_liability_, deliver_country_db_), attr_);
         END IF;
      END IF;   
   END IF;

   price_source_    := Client_SYS.Get_Item_Value('PRICE_SOURCE', attr_);
   price_source_db_ := Pricing_Source_API.Encode(price_source_);
   IF (price_source_db_ IS NULL) THEN
      price_source_db_ := Client_SYS.Get_Item_Value('PRICE_SOURCE_DB', attr_);
   END IF;

   IF (price_source_db_ = 'AGREEMENT') THEN
      customer_agreement_ := Client_SYS.Get_Item_Value('PRICE_SOURCE_ID', attr_);
   ELSE
      customer_agreement_ := NULL;
   END IF;

   newrec_.demand_order_ref1 := Client_SYS.Get_Item_Value('DEMAND_ORDER_REF1', attr_);

   -- Check on line_item_no to make sure that this is not run for package components
   IF (line_item_no_ IS NULL) OR (line_item_no_ <= 0) THEN
      IF ((customer_agreement_ IS NOT NULL) AND (Order_Quotation_Line_API.Exist_Lines(newrec_.demand_order_ref1) = 'FALSE')) THEN
         agreement_rec_  := Customer_Agreement_API.Get(customer_agreement_);

         delivery_terms_ := agreement_rec_.delivery_terms;

         IF (NVL(demand_code_, Database_SYS.string_null_) NOT IN ('IPD', 'IPT', 'IPT_RO')) THEN
            IF (delivery_terms_ IS NOT NULL) THEN
               newrec_.delivery_terms      := delivery_terms_;
               newrec_.del_terms_location  := agreement_rec_.del_terms_location;
            ELSE
               newrec_.delivery_terms      := order_rec_.delivery_terms;
               newrec_.del_terms_location  := order_rec_.del_terms_location;
            END IF;
            Client_SYS.Set_Item_Value('DELIVERY_TERMS', newrec_.delivery_terms, attr_);
         END IF;
         Client_SYS.Set_Item_Value('DEFAULT_ADDR_FLAG_DB', newrec_.default_addr_flag, attr_);
      ELSE
         IF (NVL(demand_code_, Database_SYS.string_null_) NOT IN ('IPD', 'IPT', 'IPT_RO')) THEN
            IF (newrec_.default_addr_flag = 'Y') THEN
               newrec_.delivery_terms      := order_rec_.delivery_terms;
               newrec_.del_terms_location  := order_rec_.del_terms_location;
            ELSIF (newrec_.default_addr_flag = 'N') THEN
               newrec_.delivery_terms     := Client_SYS.Get_Item_Value('DELIVERY_TERMS', attr_);
               newrec_.del_terms_location := Client_SYS.Get_Item_Value('DEL_TERMS_LOCATION', attr_);
            END IF;
         END IF;
      END IF;
      IF (NVL(demand_code_, Database_SYS.string_null_) NOT IN ('IPD', 'IPT', 'IPT_RO')) THEN
         Client_SYS.Set_Item_Value('DELIVERY_TERMS', newrec_.delivery_terms, attr_);
         Client_SYS.Set_Item_Value('DEL_TERMS_LOCATION', newrec_.del_terms_location, attr_);
      END IF;
   END IF;

   IF (Client_SYS.Get_Item_Value('REBATE_BUILDER', attr_) IS NULL AND (Client_SYS.Get_Item_Value('REBATE_BUILDER_DB', attr_) IS NULL)) THEN
      Client_SYS.Set_Item_Value('REBATE_BUILDER_DB', 'TRUE', attr_);
   END IF;

   IF (Client_SYS.Get_Item_Value('SHIPMENT_CREATION', attr_) IS NOT NULL) OR (Client_SYS.Get_Item_Value('SHIPMENT_CREATION_DB', attr_) IS NOT NULL) THEN
      IF (shipment_creation_sent_ = 'FALSE') THEN
         packed_ship_cre_in_init_ := 'TRUE';
      END IF;
      shipment_creation_sent_ := 'TRUE';
   END IF;

   Client_SYS.Add_To_Attr('SHIPMENT_CREATION_SENT',  shipment_creation_sent_,  attr_);
   Client_SYS.Add_To_Attr('SHIPMENT_TYPE_SENT',      shipment_type_sent_,      attr_);
   Client_SYS.Add_To_Attr('PACKED_SHIP_CRE_IN_INIT', packed_ship_cre_in_init_, attr_);
   
   IF ((auto_substitution_allowed_) AND (supply_code_db_ = 'IO') AND (newrec_.part_ownership = 'COMPANY OWNED') AND (newrec_.rental = Fnd_Boolean_API.DB_FALSE)
            AND (Part_Catalog_API.Get_Configurable_Db(newrec_.part_no) = 'NOT CONFIGURED') 
            AND ((newrec_.demand_code NOT IN ('IPT', 'IPD')) OR (newrec_.demand_code IS NULL))) THEN
      
      substitutable_part_ := Substitute_Sales_Part_API.Find_Substitutable_Part(newrec_.contract, newrec_.catalog_no, newrec_.order_no, newrec_.line_no,
                                                                               newrec_.rel_no, newrec_.line_item_no, newrec_.customer_no, revised_qty_due_, 
                                                                               supply_code_db_, newrec_.picking_leadtime, newrec_.part_ownership );
      IF ((substitutable_part_ IS NOT NULL) AND (substitutable_part_ != newrec_.catalog_no)) THEN
         
         newrec_.original_part_no := newrec_.catalog_no;
         newrec_.catalog_no := substitutable_part_; 
         sprec_ := Sales_Part_API.Get(newrec_.contract, substitutable_part_);
         newrec_.catalog_desc := Sales_Part_API.Get_Catalog_Desc(newrec_.contract, newrec_.catalog_no, order_rec_.language_code);
         newrec_.part_no :=  sprec_.part_no;  
         
         Client_SYS.Add_To_Attr('CATALOG_NO',  newrec_.catalog_no,  attr_);
         Client_SYS.Add_To_Attr('ORIGINAL_PART_NO',  newrec_.original_part_no,  attr_);
         Client_SYS.Add_To_Attr('CATALOG_DESC',  newrec_.catalog_desc,  attr_);
         Client_SYS.Add_To_Attr('PART_NO',  newrec_.part_no,  attr_);
         Client_SYS.Add_To_Attr('REVISED_QTY_DUE',  revised_qty_due_,  attr_);         
         -- Removing the pricing information since those should be refetched for the substitute part.
         attr_ := Client_SYS.Remove_Attr('SALE_UNIT_PRICE', attr_);
         attr_ := Client_SYS.Remove_Attr('BASE_SALE_UNIT_PRICE', attr_);
         attr_ := Client_SYS.Remove_Attr('BASE_UNIT_PRICE_INCL_TAX', attr_);
         attr_ := Client_SYS.Remove_Attr('UNIT_PRICE_INCL_TAX', attr_);
         attr_ := Client_SYS.Remove_Attr('PART_PRICE', attr_);
         attr_ := Client_SYS.Remove_Attr('PRICE_SOURCE_ID', attr_);
         attr_ := Client_SYS.Remove_Attr('PRICE_LIST_NO', attr_);
         attr_ := Client_SYS.Remove_Attr('CURRENCY_RATE', attr_);
         attr_ := Client_SYS.Remove_Attr('COST', attr_);
         attr_ := Client_SYS.Remove_Attr('PURCHASE_PART_NO', attr_);
         attr_ := Client_SYS.Remove_Attr('PART_LEVEL', attr_);
         attr_ := Client_SYS.Remove_Attr('PART_LEVEL_DB', attr_);
         attr_ := Client_SYS.Remove_Attr('PART_LEVEL_ID', attr_);
         attr_ := Client_SYS.Remove_Attr('CUSTOMER_LEVEL', attr_);
         attr_ := Client_SYS.Remove_Attr('CUSTOMER_LEVEL_DB', attr_);
         attr_ := Client_SYS.Remove_Attr('CUSTOMER_LEVEL_ID', attr_);
         
         Build_Attr_For_New___(discount_, copy_discount_, create_partial_sum_, new_attr_, attr_);
         Client_SYS.Clear_Attr(attr_);
         attr_ := new_attr_;
         Client_SYS.Add_To_Attr('DISCOUNT', discount_, attr_);
         Client_SYS.Add_To_Attr('COPY_DISCOUNT', copy_discount_, attr_);
                                                    
      END IF;
      
   END IF;
   
END Pre_Unpack_Insert___;

PROCEDURE Pre_Unpack_Update___ (
   attr_      IN OUT VARCHAR2,
   newrec_    IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
   oldrec_                        CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   ptr_                           NUMBER;
   name_                          VARCHAR2(30);
   value_                         VARCHAR2(4000);
   cancel_info_added_             BOOLEAN := FALSE;
   info_added_                    BOOLEAN := FALSE;
   order_rec_                     CUSTOMER_ORDER_API.Public_Rec;
   addr_flag_changed_in_client_   BOOLEAN := TRUE;
   default_addr_flag_             CUSTOMER_ORDER_LINE_TAB.default_addr_flag%TYPE;
   insert_package_mode_           VARCHAR2(5);
   deliver_country_db_            VARCHAR2(2);
   tax_liability_                 VARCHAR2(20);
   company_                       VARCHAR2(20);
BEGIN
   oldrec_              := newrec_;
   insert_package_mode_ :=  NVL(Client_SYS.Get_Item_Value('INSERT_PACKAGE_MODE_', attr_), 'FALSE');

   ptr_ := NULL;
   WHILE (Client_SYS.Get_Next_From_Attr(attr_, ptr_, name_, value_)) LOOP
      -- Not all attributes may be updated when the line has reached the status 'Invoiced'
      IF (newrec_.rowstate = 'Invoiced') THEN
         IF name_ NOT IN ('QTY_RETURNED', 'NOTE_TEXT', 'ORDER_DISCOUNT', 'QTY_ASSIGNED', 'QTY_SHIPPED', 'QTY_PICKED', 'QTY_SHIPDIFF', 'QTY_TO_SHIP',
                          'REAL_SHIP_DATE', 'QTY_ON_ORDER', 'DEFAULT_ADDR_FLAG', 'DEFAULT_ADDR_FLAG_DB', 'DELIVERY_TERMS',
                          'DEL_TERMS_LOCATION', 'DELIVERY_LEADTIME', 'DISTRICT_CODE', 'REGION_CODE', 'UPDATE_PRICE_EFFECTIVE_DATE',
                          'SM_CONNECTION','SM_CONNECTION_DB', 'COST', 'INTRASTAT_EXEMPT', 'INTRASTAT_EXEMPT_DB', 'CUST_CALENDAR_ID', 'EXT_TRANSPORT_CALENDAR_ID',
                          'DELIVERY_CONFIRMED', 'DELIVERY_CONFIRMED_DB', 'QTY_CONFIRMEDDIFF', 'FIRST_ACTUAL_SHIP_DATE', 'PICKING_LEADTIME', 'SHIPMENT_TYPE', 'PACKING_INSTRUCTION_ID',
                          'SHIPMENT_CONNECTED', 'SHIPMENT_CONNECTED_DB', 'TAX_ID_NO', 'TAX_ID_VALIDATED_DATE', 'CUSTOMS_VALUE', 'ABNORMAL_DEMAND', 'ABNORMAL_DEMAND_DB', 'OPEN_SHIPMENT_QTY',
                          'INSERT_PACKAGE_MODE_', 'ADD_INFO', 'DEFAULT_CHARGES', 'QTY_INVOICED', 'SET_TAX_FROM_ORIGINAL', 'MULTIPLE_TAX_LINES', 'FETCH_TAX_FROM_DEFAULTS','TAX_CLASS_ID') THEN

            IF (name_ IN ('PRICE_CONV_FACTOR')) THEN
               IF (Part_Catalog_API.Get_Catch_Unit_Enabled(oldrec_.part_no) = Fnd_Boolean_API.Decode('FALSE')) THEN
                  Error_SYS.Record_General(lu_name_, 'BILLED_ORD_LINE: Invoiced/Closed order line :P1-:P2-:P3 may not be modified', newrec_.order_no, newrec_.line_no, newrec_.rel_no);
               END IF;
            ELSE
               Error_SYS.Record_General(lu_name_, 'BILLED_ORD_LINE: Invoiced/Closed order line :P1-:P2-:P3 may not be modified', newrec_.order_no, newrec_.line_no, newrec_.rel_no);
            END IF;
         END IF;
      -- Buy_qty_due may not be updated if the line is delivered
      ELSIF ((newrec_.rowstate = 'Delivered') AND (name_ = 'BUY_QTY_DUE')) THEN
           Error_SYS.Record_General(lu_name_, 'DELIVERED_ORDER_LINE: Sales quantity may not be updated on Delivered order lines.');
        -- Buy_qty_due may not be updated if the export license is connected

      -- Inform user about changing delivery note information if order line has been pick reported
      ELSIF (newrec_.rowstate IN ('Picked', 'PartiallyDelivered', 'Delivered')) THEN
         IF ((newrec_.rowstate = 'PartiallyDelivered') AND (newrec_.qty_invoiced > 0) AND (name_  = 'SHIP_VIA_CODE') AND (oldrec_.ship_via_code != value_)
              AND ( (newrec_.freight_map_id IS NOT NULL) OR (newrec_.zone_id IS NOT NULL) OR (newrec_.freight_price_list_no IS NOT NULL) )) THEN
            Error_SYS.Record_General(lu_name_, 'FREIGHT_ORDER: Invoiced order lines connected to Freight functionality cannot be changed.');
         END IF;
         IF NOT info_added_ AND (name_ IN ('CONTACT', 'ROUTE_ID', 'FORWARD_AGENT_ID', 'SHIP_VIA_CODE', 'SHIP_ADDR_NO', 'ADDR_FLAG', 'ADDR_FLAG_DB',
                                           'DEFAULT_ADDR_FLAG', 'DEFAULT_ADDR_FLAG_DB', 'DELIVERY_TERMS','DEL_TERMS_LOCATION')) THEN
            Raise_Delnote_Info_Message___;
            info_added_ := TRUE;
         END IF;
      ELSIF (newrec_.rowstate = 'Cancelled') THEN
         IF ((NOT cancel_info_added_) AND
             (name_ IN ('CUSTOMER_PART_BUY_QTY', 'BUY_QTY_DUE', 'DESIRED_QTY', 'CATALOG_DESC',
                        'WANTED_DELIVERY_DATE', 'PLANNED_DELIVERY_DATE', 'PROMISED_DELIVERY_DATE', 'PLANNED_SHIP_DATE',
                        'PRICE_LIST_NO', 'SALE_UNIT_PRICE', 'UNIT_PRICE_INCL_TAX', 'PRICE_FREEZE_DB', 'BASE_SALE_UNIT_PRICE', 'BASE_UNIT_PRICE_INCL_TAX',
                        'PRICE_EFFECTIVITY_DATE', 'CLOSE_TOLERANCE', 'WARRANTY', 'DELIVERY_TYPE', 'DEFAULT_ADDR_FLAG_DB',
                        'SHIP_ADDR_NO', 'DOCK_CODE', 'SUB_DOCK_CODE', 'REF_ID', 'LOCATION_NO', 'SUPPLY_CODE', 'VENDOR_NO',
                        'SUPPLY_SITE', 'DOP_CONNECTION', 'SUP_SM_OBJECT', 'SUP_SM_CONTRACT', 'EARLIEST_START_DATE', 'CANCEL_REASON',
                        'PROVISIONAL_PRICE_DB', 'SHIPMENT_CREATION', 'CUSTOMER_PO_LINE_NO', 'CUSTOMER_PO_REL_NO', 'RECEIVING_ADVICE_TYPE', 'TARGET_DATE'))) THEN
            Client_SYS.Add_Info(lu_name_, 'CANCELLED_LINE: You are updating a Cancelled Customer Order Line.');
            cancel_info_added_ := TRUE;
         END IF;
      END IF;
   END LOOP;

   order_rec_ := CUSTOMER_ORDER_API.Get(newrec_.order_no);
   -- fetch new default flag from attr
   default_addr_flag_ := Client_SYS.Get_Item_Value('DEFAULT_ADDR_FLAG_DB', attr_);
   IF (default_addr_flag_ IS NULL) THEN
      default_addr_flag_ := Gen_Yes_No_API.Encode(Client_SYS.Get_Item_Value('DEFAULT_ADDR_FLAG', attr_));
   END IF;

   -- if not found, use old flag value
   IF (default_addr_flag_ IS NULL) THEN
      default_addr_flag_ := oldrec_.default_addr_flag;
      IF (newrec_.ship_addr_no != order_rec_.ship_addr_no ) AND (default_addr_flag_  = 'Y') THEN
         addr_flag_changed_in_client_ := TRUE;
      ELSE
         addr_flag_changed_in_client_ := FALSE;
      END IF;
   END IF;

   IF (default_addr_flag_ = 'Y') THEN
      -- if reset to using order header values, overwrite the client's values.
      -- IF so, client values should be overwritten with order header values.
      IF addr_flag_changed_in_client_ THEN
         Client_SYS.Set_Item_Value('ADDR_FLAG_DB', order_rec_.addr_flag, attr_);
         Client_SYS.Set_Item_Value('SHIP_ADDR_NO', order_rec_.ship_addr_no, attr_);
         Client_SYS.Set_Item_Value('CONTACT', order_rec_.cust_ref, attr_);
         Client_SYS.Set_Item_Value('ROUTE_ID', order_rec_.route_id, attr_);
         Client_SYS.Set_Item_Value('FORWARD_AGENT_ID', order_rec_.forward_agent_id, attr_);
         Client_SYS.Set_Item_Value('SHIP_VIA_CODE', order_rec_.ship_via_code, attr_);
         Client_SYS.Set_Item_Value('CUST_CALENDAR_ID', order_rec_.cust_calendar_id, attr_);
         Client_SYS.Set_Item_Value('EXT_TRANSPORT_CALENDAR_ID', order_rec_.ext_transport_calendar_id, attr_);
         Client_SYS.Set_Item_Value('DELIVERY_TERMS', order_rec_.delivery_terms, attr_);
         Client_SYS.Set_Item_Value('DEL_TERMS_LOCATION', order_rec_.del_terms_location, attr_);
         Client_SYS.Set_Item_Value('DELIVERY_LEADTIME', order_rec_.delivery_leadtime, attr_);
         Client_SYS.Set_Item_Value('DISTRICT_CODE', order_rec_.district_code, attr_);
         Client_SYS.Set_Item_Value('REGION_CODE', order_rec_.region_code, attr_);
         Client_SYS.Set_Item_Value('TAX_LIABILITY', order_rec_.tax_liability, attr_);
         Client_SYS.Set_Item_Value('INTRASTAT_EXEMPT_DB', order_rec_.intrastat_exempt, attr_);
         Client_SYS.Set_Item_Value('SHIPMENT_CREATION_DB', order_rec_.shipment_creation, attr_);
         Client_SYS.Set_Item_Value('FREIGHT_MAP_ID', order_rec_.freight_map_id, attr_);
         Client_SYS.Set_Item_Value('ZONE_ID', order_rec_.zone_id, attr_);
         Client_SYS.Set_Item_Value('FREIGHT_PRICE_LIST_NO', order_rec_.freight_price_list_no, attr_);
         Client_SYS.Set_Item_Value('PICKING_LEADTIME', order_rec_.picking_leadtime, attr_);
         Client_SYS.Set_Item_Value('SHIPMENT_TYPE', order_rec_.shipment_type, attr_);
         Client_SYS.Set_Item_Value('TAX_ID_NO', order_rec_.tax_id_no, attr_);
         Client_SYS.Set_Item_Value('TAX_ID_VALIDATED_DATE', order_rec_.tax_id_validated_date, attr_);
         
         deliver_country_db_  := Customer_Order_Address_API.Get_Country_Code(newrec_.order_no);
         Client_SYS.Set_Item_Value('COUNTRY_CODE', deliver_country_db_, attr_);
         Client_SYS.Set_Item_Value('TAX_LIABILITY_TYPE_DB', Tax_Liability_API.Get_Tax_Liability_Type_Db(order_rec_.tax_liability, deliver_country_db_), attr_);
      END IF;
   ELSE
      IF (Client_SYS.Get_Item_Value('TAX_LIABILITY', attr_) IS NULL) THEN
         IF (newrec_.tax_liability IS NULL) THEN
            company_ := Site_API.Get_Company(newrec_.contract);
            IF (order_rec_.customer_no = newrec_.deliver_to_customer_no) THEN
               Client_SYS.Set_Item_Value('TAX_LIABILITY', Tax_Handling_Util_API.Get_Customer_Tax_Liability(newrec_.customer_no, newrec_.ship_addr_no, company_, order_rec_.supply_country), attr_);
            ELSE
               Client_SYS.Set_Item_Value('TAX_LIABILITY', Tax_Handling_Util_API.Get_Customer_Tax_Liability(newrec_.customer_no, order_rec_.ship_addr_no, company_, order_rec_.supply_country), attr_);
            END IF;
         ELSE
            Client_SYS.Set_Item_Value('TAX_LIABILITY', newrec_.tax_liability, attr_);            
         END IF;
      END IF;
      
      tax_liability_       := Client_SYS.Get_Item_Value('TAX_LIABILITY', attr_);
      deliver_country_db_  := Cust_Ord_Customer_Address_API.Get_Country_Code(newrec_.deliver_to_customer_no, newrec_.ship_addr_no);   
      Client_SYS.Set_Item_Value('TAX_LIABILITY_TYPE_DB', Tax_Liability_API.Get_Tax_Liability_Type_Db(tax_liability_, deliver_country_db_), attr_);
      
   END IF;   
END Pre_Unpack_Update___;


-- Post_Insert_Actions___
--   Actions to be executed after inserting a new record.
PROCEDURE Post_Insert_Actions___ (
   attr_   IN OUT VARCHAR2,
   newrec_ IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE)
IS
   rowid_                           VARCHAR2(2000);
   rowversion_                      VARCHAR2(2000);
   header_rowstate_                 CUSTOMER_ORDER_TAB.rowstate%TYPE;
   linerec_                         CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   order_rec_                       CUSTOMER_ORDER_API.Public_Rec;
   cust_rec_                        CUST_ORD_CUSTOMER_API.Public_Rec;
   company_tax_ctrl_rec_            COMPANY_TAX_CONTROL_API.Public_Rec;
   sales_part_rec_                  SALES_PART_API.Public_Rec;
   line_total_                      NUMBER;
   company_                         VARCHAR2(20);
   contract_                        CUSTOMER_ORDER_LINE_TAB.contract%TYPE;
   part_no_                         CUSTOMER_ORDER_LINE_TAB.part_no%TYPE;
   msg_text_                        VARCHAR2(200);
   local_site_reservation_exist_    NUMBER := 0;
   total_percentage_                NUMBER;
   create_connected_order_          BOOLEAN := TRUE;
   min_qty_                         NUMBER;
   add_status_                      BOOLEAN := FALSE;
   automatic_capability_check_      VARCHAR2(50);
   auto_cc_performed_               BOOLEAN := FALSE;
   calc_price_per_curr_             NUMBER;
   default_charges_                 VARCHAR2(5);
   planned_receipt_date_            DATE;
   shipment_id_                     NUMBER;
   shipment_creation_changed_       BOOLEAN := FALSE;
   dummy_                           Shipment_API.Shipment_Id_Tab;
   header_deliver_country_db_       VARCHAR2(2);
   deal_description_                VARCHAR2(200);
   insert_package_mode_             VARCHAR2(5);
   block_component_info_            VARCHAR2(5):= 'FALSE';
   rental_chargeable_days_          NUMBER;
   discount_type_                   VARCHAR2(25);
   proj_unique_sale_                VARCHAR2(5);
   order_project_id_                CUSTOMER_ORDER_TAB.project_id%TYPE;
   licensed_order_type_             VARCHAR2(25);
   copy_discount_                   VARCHAR2(5);
   ptr_                             VARCHAR2(2000);
   name_                            VARCHAR2(2000);
   value_                           VARCHAR2(4000);
   temp_info_                       VARCHAR2(2000);
   temp_insert_package_mode_        VARCHAR2(5);
   tax_from_defaults_               BOOLEAN;
   original_order_no_               VARCHAR2(12);
   original_line_no_                VARCHAR2(4);
   original_rel_no_                 VARCHAR2(4);
   original_line_item_no_           VARCHAR2(50);
   ctp_run_id_                      NUMBER;
   tax_class_id_                    VARCHAR2(20);
   quotation_no_                    VARCHAR2(12);
   quotation_line_no_               VARCHAR2(4);
   quotation_rel_no_                VARCHAR2(4);
   quotation_line_item_no_          NUMBER; 
   copy_order_line_                 BOOLEAN := NVL(Client_SYS.Get_Item_Value('COPY_ORDER_LINE', attr_), 'FALSE') = 'TRUE';
   tax_method_                      VARCHAR2(50);
   tax_from_external_system_        BOOLEAN := FALSE;
   update_required_                 BOOLEAN := FALSE;
   temp_sale_unit_price_            NUMBER;      
   temp_base_sale_unit_price_       NUMBER; 
   temp_currency_rate_              NUMBER;       
   discount_                        NUMBER;             
   temp_rebate_builder_db_          VARCHAR2(20);
   fetch_external_tax_              VARCHAR2(5) := 'TRUE';
BEGIN

   SELECT rowid
      INTO  rowid_
      FROM  CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = newrec_.order_no
      AND   line_no = newrec_.line_no
      AND   rel_no = newrec_.rel_no
      AND   line_item_no = newrec_.line_item_no;

   order_rec_ := CUSTOMER_ORDER_API.Get(newrec_.order_no);
   insert_package_mode_ := NVL(Client_SYS.Get_Item_Value('INSERT_PACKAGE_MODE_', attr_), 'FALSE');
   
   IF (newrec_.activity_seq IS NOT NULL) THEN 
      $IF (Component_Proj_SYS.INSTALLED) $THEN
         newrec_.project_id  := Activity_API.Get_Project_Id(newrec_.activity_seq);
         proj_unique_sale_   := Project_API.Get_Proj_Unique_Sale_Db(newrec_.project_id);

         IF (proj_unique_sale_ = 'TRUE') THEN
            order_project_id_ := order_rec_.project_id;
            IF (order_project_id_ IS NULL) THEN
               Customer_Order_API.Modify_Project_Id(newrec_.order_no, newrec_.project_id);
            END IF;
         END IF;
      $ELSE
         Error_SYS.Record_General(lu_name_, 'ACTIVITYNOTINST: Activity Sequence may not be set since Activity is not installed.');
      $END
      Handle_Activity_Seq___(newrec_, NULL);
   END IF;
      
   IF (((order_rec_.proposed_prepayment_amount >0) OR (Customer_Invoice_Pub_Util_API.Has_Adv_Inv(newrec_.order_no) = 'TRUE')) AND (newrec_.rental = Fnd_Boolean_API.DB_TRUE)) THEN
      Error_SYS.Record_General(lu_name_, 'CANNOTCREATRENTAL: You cannot create rental lines when prepayment invoices exist for the customer order.');
   END IF;

   -- Create a new history record.
   Customer_Order_Line_Hist_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);

   IF (newrec_.line_item_no <= 0) THEN
      calc_price_per_curr_ := newrec_.part_price + NVL(newrec_.calc_char_price, 0);
      -- Only create history record and event when the price has been manually changed
      IF (newrec_.sale_unit_price != calc_price_per_curr_) THEN
         Log_Price_Changes___(newrec_, order_rec_, calc_price_per_curr_ );
      END IF;
   END IF;

   $IF Component_Expctr_SYS.INSTALLED $THEN
      IF (Customer_Order_Flow_API.Get_License_Enabled(newrec_.order_no, 'INTERACT_CUST_ORD') = 'TRUE') THEN
         licensed_order_type_ := Get_Expctr_License_Order_Type(newrec_.demand_code, newrec_.demand_order_ref1, newrec_.demand_order_ref2, newrec_.demand_order_ref3);
         Exp_License_Connect_Util_API.Create_Exp_License_For_Src(licensed_order_type_, newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      END IF;
   $END

   -- Set the block component info flag so we stop the component info messages generated from Change_Package_Structure___ later on
   IF (newrec_.supply_code = 'PKG') THEN
      block_component_info_ := 'TRUE';
   END IF;
   
   IF (newrec_.line_item_no <= 0) THEN
      -- if address is set to single occurance and is not used as the default from the header,
      -- insert it so that the user can modify it at any time later on...
      IF ((newrec_.default_addr_flag = 'N') AND (newrec_.addr_flag = 'Y') AND  NOT(copy_order_line_)) THEN
         Insert_Default_Address___(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.customer_no, newrec_.ship_addr_no, newrec_.deliver_to_customer_no);
      END IF;
      Client_SYS.Set_Item_Value('DEFAULT_ADDR_FLAG_DB', newrec_.default_addr_flag, attr_);
      Client_SYS.Set_Item_Value('SHIP_ADDR_NO', newrec_.ship_addr_no, attr_);
      Client_SYS.Set_Item_Value('ADDR_FLAG_DB', newrec_.addr_flag, attr_);
   END IF;

   sales_part_rec_ := Sales_Part_API.Get(newrec_.contract, newrec_.catalog_no);
   IF (newrec_.line_item_no <= 0) THEN
      CUSTOMER_ORDER_API.Modify_Grp_Disc_Calc_Flag(newrec_.order_no, 'N');
      company_ := Site_API.Get_Company(order_rec_.contract);
      company_tax_ctrl_rec_ := Company_Tax_Control_API.Get(company_);
      tax_method_ := company_tax_ctrl_rec_.external_tax_cal_method;
      
      IF tax_method_ IN (External_Tax_Calc_Method_API.DB_AVALARA_SALES_TAX, External_Tax_Calc_Method_API.DB_AVALARA_TAX_BRAZIL)
         AND (company_tax_ctrl_rec_.fetch_tax_on_line_entry = Fnd_Boolean_API.DB_FALSE
              OR NVL(Client_SYS.Get_Item_Value('UPDATE_TAX', attr_), 'TRUE') = 'FALSE') THEN
         fetch_external_tax_ := 'FALSE';
      END IF;
      
      IF (tax_method_ != External_Tax_Calc_Method_API.DB_NOT_USED) THEN
         tax_from_defaults_ := TRUE;
         tax_from_external_system_ := TRUE;
      ELSE
         IF (NVL(Client_SYS.Get_Item_Value('FETCH_TAX_CODES', attr_), 'TRUE') = 'TRUE') THEN
            IF (newrec_.tax_calc_structure_id IS NULL) THEN
               IF (newrec_.tax_code IS NULL) THEN
                  tax_from_defaults_ := TRUE;
               ELSE
                  tax_from_defaults_ := FALSE;
               END IF;
            ELSE
               tax_from_defaults_ := FALSE;
            END IF;
         END IF;
      END IF;
      -- If the line is copied or duplicated, taxes should be copied from the original line.
      original_order_no_     := Client_SYS.Get_Item_Value('ORIGINAL_ORDER_NO', attr_);
      original_line_no_      := Client_SYS.Get_Item_Value('ORIGINAL_LINE_NO', attr_);
      original_rel_no_       := Client_SYS.Get_Item_Value('ORIGINAL_REL_NO', attr_);
      original_line_item_no_ := Client_SYS.Get_Item_Value('ORIGINAL_ITEM_NO', attr_);

      IF (Client_SYS.Get_Item_Value('SET_TAX_FROM_ORIGINAL', attr_) = 'TRUE') AND (NOT tax_from_external_system_) AND 
         (Customer_Order_API.Get_Customer_No(original_order_no_) = order_rec_.customer_no) THEN
         tax_class_id_ := Get_Tax_Class_Id(original_order_no_, 
                                           original_line_no_, 
                                           original_rel_no_, 
                                           original_line_item_no_);
         Tax_Handling_Order_Util_API.Transfer_Tax_lines(company_, 
                                                        Tax_Source_API.DB_CUSTOMER_ORDER_LINE, 
                                                        original_order_no_, 
                                                        original_line_no_, 
                                                        original_rel_no_, 
                                                        original_line_item_no_, 
                                                        '*',
                                                        Tax_Source_API.DB_CUSTOMER_ORDER_LINE, 
                                                        newrec_.order_no, 
                                                        newrec_.line_no, 
                                                        newrec_.rel_no, 
                                                        newrec_.line_item_no, 
                                                        '*',
                                                        'TRUE',
                                                        'FALSE');
      ELSIF ((NVL(Client_SYS.Get_Item_Value('FROM_ORDER_QUOTATION', attr_), 'FALSE') = 'TRUE') AND (NOT tax_from_external_system_)) THEN
         quotation_no_           := Client_SYS.Get_Item_Value('QUOTATION_NO', attr_);
         quotation_line_no_      := Client_SYS.Get_Item_Value('QUOTATION_LINE_NO', attr_);
         quotation_rel_no_       := Client_SYS.Get_Item_Value('QUOTATION_REL_NO', attr_);
         quotation_line_item_no_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('QUOTATION_ITEM_NO', attr_));
            Tax_Handling_Order_Util_API.Transfer_Tax_lines(company_, 
                                                           Tax_Source_API.DB_ORDER_QUOTATION_LINE, 
                                                           quotation_no_, 
                                                           quotation_line_no_, 
                                                           quotation_rel_no_, 
                                                           quotation_line_item_no_, 
                                                           '*',
                                                           Tax_Source_API.DB_CUSTOMER_ORDER_LINE, 
                                                           newrec_.order_no, 
                                                           newrec_.line_no, 
                                                           newrec_.rel_no, 
                                                           newrec_.line_item_no, 
                                                           '*');
      ELSIF (((copy_order_line_) AND (NVL(Client_SYS.Get_Item_Value('FETCH_TAX_FROM_DEFAULTS',attr_), 'TRUE') = 'FALSE')) 
            AND (NOT tax_from_external_system_)) THEN
         IF (NVL(Client_SYS.Get_Item_Value('RECALC_TAX_AMOUNTS', attr_), 'FALSE')='TRUE') THEN
            Tax_Handling_Order_Util_API.Transfer_Tax_lines(company_, 
                                                           Tax_Source_API.DB_CUSTOMER_ORDER_LINE, 
                                                           original_order_no_, 
                                                           original_line_no_, 
                                                           original_rel_no_, 
                                                           original_line_item_no_, 
                                                           '*',
                                                           Tax_Source_API.DB_CUSTOMER_ORDER_LINE, 
                                                           newrec_.order_no, 
                                                           newrec_.line_no, 
                                                           newrec_.rel_no, 
                                                           newrec_.line_item_no, 
                                                           '*',
                                                           'TRUE',
                                                           'TRUE');   
         ELSE
            Tax_Handling_Order_Util_API.Transfer_Tax_lines(company_, 
                                                           Tax_Source_API.DB_CUSTOMER_ORDER_LINE, 
                                                           original_order_no_, 
                                                           original_line_no_, 
                                                           original_rel_no_, 
                                                           original_line_item_no_, 
                                                           '*',
                                                           Tax_Source_API.DB_CUSTOMER_ORDER_LINE, 
                                                           newrec_.order_no, 
                                                           newrec_.line_no, 
                                                           newrec_.rel_no, 
                                                           newrec_.line_item_no, 
                                                           '*');  
         END IF;
      ELSE
         cust_rec_ := Cust_Ord_Customer_API.Get(order_rec_.customer_no);
         IF (tax_from_external_system_ AND newrec_.discount = 0 AND cust_rec_.discount_type IS NULL) THEN
            -- Execute the price logic and get the discount value, in order to know any discount involved for the line.
            Customer_Order_Pricing_API.Get_Order_Line_Price_Info(temp_sale_unit_price_,  temp_base_sale_unit_price_,  temp_currency_rate_,
                                                                 discount_,              temp_rebate_builder_db_,     newrec_.order_no,                                                                 
                                                                 newrec_.catalog_no,     newrec_.buy_qty_due,         newrec_.price_list_no,        
                                                                 newrec_.condition_code);
         END IF;

         -- When the tax is calculated from an external tax system and when there is a discount specified or applicable for the line, or on the customer,
         -- call to Add_Transaction_Tax_Info___ at this point will cause an unnecessary call to the external tax system where the tax is calculated for the un-discounted value.
         -- But this call is needed when there is no discount specified in the line or customer level, this also applies if there is a discount type specified on the customer that has the value 0%.
         IF (NOT tax_from_external_system_ OR (fetch_external_tax_ = 'TRUE' AND discount_ = 0 AND newrec_.discount = 0 AND cust_rec_.discount_type IS NULL) 
                                           OR (cust_rec_.discount_type IS NOT NULL AND cust_rec_.discount = 0)) THEN
            IF (newrec_.customer_no = newrec_.deliver_to_customer_no) THEN
               Add_Transaction_Tax_Info___ (newrec_,  
                                            company_,
                                            newrec_.customer_no,
                                            newrec_.ship_addr_no,                                      
                                            order_rec_.supply_country,
                                            order_rec_.use_price_incl_tax,
                                            order_rec_.currency_code,                                       
                                            tax_from_defaults_,                                      
                                            attr_  => NULL);
            ELSIF ((newrec_.demand_code IS NULL) OR (newrec_.demand_code != 'IPD') OR (newrec_.addr_flag = 'N')
                    OR (sales_part_rec_.tax_class_id IS NULL)) THEN
               Add_Transaction_Tax_Info___ (newrec_,  
                                            company_,                                      
                                            order_rec_.customer_no,
                                            order_rec_.ship_addr_no,                                      
                                            order_rec_.supply_country,                                        
                                            order_rec_.use_price_incl_tax,
                                            order_rec_.currency_code,                                       
                                            tax_from_defaults_,                                      
                                            attr_  => NULL);                                               
            END IF;
         END IF;
      END IF;
      newrec_ := Get_Object_By_Keys___(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      IF (tax_class_id_ IS NOT NULL) THEN
         newrec_.tax_class_id := tax_class_id_;
      END IF;
      Calculate_Prices(newrec_);      
      update_required_ := TRUE;
   END IF;
   
   -- This flag was set in Check_Insert___() to facilitate availability check functionality.
   -- From this code block it will be reset for all the sourcing options except inventory order.
   IF (newrec_.supply_code IN ('IPT', 'IPD')) THEN
      IF (NOT((Sales_part_API.Get_Valid_Sourcing_Option(newrec_.supply_site, newrec_.catalog_no) = 'INVENTORYORDER'))) THEN         
         newrec_.release_planning := 'NOTRELEASED' ;
         update_required_ := TRUE;
      END IF;
   END IF;
   
   IF (update_required_) THEN 
      -- This needs to be called only when line_item_no <= 0. But for a special situation when setting the release_planning flag for 
      -- component parts also this needs to be called.
      Update_Line___(rowid_, newrec_);
      update_required_ := FALSE;
   END IF;
   
   IF NOT(copy_order_line_) THEN
      IF (newrec_.supply_code = 'PKG') AND (NVL(newrec_.demand_code, ' ') != 'CQ') THEN
         -- quotations will add the component lines that exist on quotation line separately.

         Add_Info___(insert_package_mode_);
         insert_package_mode_ := 'TRUE';
         Insert_Package___(newrec_.planned_delivery_date, newrec_.shipment_creation, newrec_.contract, newrec_.catalog_no, newrec_.order_no, newrec_.line_no, newrec_.rel_no,
                           newrec_.order_code, newrec_.tax_code, newrec_.tax_class_id, newrec_.currency_rate,
                           newrec_.revised_qty_due, newrec_.buy_qty_due, newrec_.sale_unit_price, newrec_.unit_price_incl_tax,
                           newrec_.base_sale_unit_price, newrec_.base_unit_price_incl_tax, newrec_.wanted_delivery_date, newrec_.target_date, insert_package_mode_);

         insert_package_mode_  := 'FALSE';
         Connect_Customer_Order_API.Release_Internal_Pur_Orders(newrec_.order_no, newrec_.line_no, newrec_.rel_no);
         -- to include the SALESGRPDELIVCONF3 info message added last in Insert_Package___...
         Add_Info___(insert_package_mode_);
         newrec_.default_addr_flag := Gen_Yes_No_API.Encode(Customer_Order_Line_API.Get_Default_Addr_Flag(newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1));
         Update_Line___(rowid_, newrec_);
      END IF;
   END IF;

   IF (newrec_.line_item_no <= 0) THEN
      Check_Allow_Backorders___(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no,
                                newrec_.planned_delivery_date);
   END IF;

   -- only create priority / instant reservations when its not a CTP planned/reserved line
   IF (newrec_.ctp_planned = 'N') THEN

      IF (newrec_.supply_code = 'IPD') THEN
         contract_ := newrec_.supply_site;

         IF (Sales_Part_API.Check_Exist(newrec_.supply_site, newrec_.part_no) = 0) THEN
            part_no_ := Sales_Part_Cross_Reference_API.Get_Catalog_No(Cust_Ord_Customer_API.Get_Customer_No_From_Contract(newrec_.contract),
                                                                      contract_,
                                                                      newrec_.part_no);
         ELSE
            part_no_ := newrec_.part_no;
         END IF;
      ELSE
         contract_ := newrec_.contract;
         part_no_ := newrec_.part_no;
      END IF;

      local_site_reservation_exist_ := NVL(Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('LOCAL_SITE_RESERVATION_EXIST', attr_)), 0);

      IF (Reserve_Customer_Order_API.Is_Supply_Chain_Reservation(newrec_.order_no, newrec_.line_no, newrec_.rel_no,
                                                                 newrec_.line_item_no, NULL, 'INSTANT') = 1) THEN
         -- instant supply chain reservation
         Reserve_Customer_Order_API.Create_Instant_Reservation__(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no,
                                                                 NULL, NVL(part_no_,newrec_.purchase_part_no), newrec_.revised_qty_due,
                                                                 newrec_.qty_shipped, rowid_, newrec_.vendor_no);
      ELSIF (local_site_reservation_exist_= 0) THEN
         -- dont make any priority reservation if a local site reservation exist
         Reserve_Customer_Order_API.Create_Priority_Reservation__(newrec_.qty_assigned, contract_, part_no_,
                                                                  newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no,
                                                                  newrec_.revised_qty_due, newrec_.qty_shipped, newrec_.supply_code, rowid_);
      END IF;
   END IF;

   CUSTOMER_ORDER_API.New_Order_Line_Added(newrec_.order_no);
   header_rowstate_ := CUSTOMER_ORDER_API.Get_Objstate(newrec_.order_no);
   
   Generate_Next_Level_Demands___(header_rowstate_, newrec_);

   -- Modify cost and package structure only when package order line exist and
   -- the user inserts a new component or inserts the package order line.

   IF (insert_package_mode_ = 'FALSE') THEN
      IF (Check_Exist___(newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1)) THEN
         IF ((newrec_.line_item_no > 0) OR (newrec_.supply_code = 'PKG')) THEN
            -- Modify cost for the order line

            IF (newrec_.line_item_no = -1) THEN
               linerec_ := newrec_;
            ELSE
               linerec_ := Get_Object_By_Keys___(newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1);
            END IF;
            Update_Package_Cost___(linerec_.cost, linerec_.order_no, linerec_.line_no, linerec_.rel_no);
            IF (newrec_.free_of_charge = Fnd_Boolean_API.DB_TRUE) AND (newrec_.free_of_charge_tax_basis = 0) AND (linerec_.cost != 0) THEN 
               Tax_Handling_Order_Util_API.Calc_And_Save_Foc_Tax_Basis(linerec_.free_of_charge_tax_basis,
                                                                       Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                                                       newrec_.order_no,
                                                                       newrec_.line_no, 
                                                                       newrec_.rel_no, 
                                                                       newrec_.line_item_no,
                                                                       '*',
                                                                       linerec_.cost,
                                                                       newrec_.part_price,
                                                                       newrec_.revised_qty_due, 
                                                                       NVL(order_rec_.customer_no_pay, newrec_.customer_no),
                                                                       newrec_.contract,
                                                                       order_rec_.currency_code,
                                                                       order_rec_.currency_rate_type,
                                                                       'FALSE');
            END IF;
            IF ((linerec_.shipment_creation = 'PICK_LIST_CREATION') AND
                (All_Non_Inv_Parts(linerec_.order_no, linerec_.line_no, linerec_.rel_no) AND NOT All_Components_Supply_Ipd (linerec_.order_no, linerec_.line_no, linerec_.rel_no))) THEN
               -- This is execute only if the shipment creation method is PICK_LIST_CREATION
               Raise_Info_Message___;
            END IF;

            Add_Info___(insert_package_mode_);
            Change_Package_Structure___(linerec_.promised_delivery_date, linerec_.planned_delivery_date,
                                        linerec_.planned_ship_date, linerec_.planned_due_date, linerec_, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, insert_package_mode_, block_component_info_, NULL);
            linerec_.qty_assigned :=  Reserve_Customer_Order_API.Get_No_Of_Packages_Reserved(newrec_.order_no, newrec_.line_no, newrec_.rel_no);
            Get_Id_Version_By_Keys___(rowid_, rowversion_, newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1);
            linerec_.rowversion   := sysdate;

            Update_Line___(rowid_, linerec_);
            -- Add the new cost value to the attribute string and fetch new objversion
            -- if insert of package order line just has been made
            IF (newrec_.supply_code = 'PKG') THEN
               Client_SYS.Set_Item_Value('COST', linerec_.cost, attr_);
               Client_SYS.Set_Item_Value('FREE_OF_CHARGE_TAX_BASIS', linerec_.free_of_charge_tax_basis, attr_);
            END IF;
         END IF;
      END IF;
   END IF;

   -- Moved Create_Connected_Order_Line method call after the Change_Package_Structure___ method call.
   IF ((newrec_.supply_code IN ('SO', 'PT', 'PD', 'IPT', 'IPD', 'DOP','PS' )) AND
       (header_rowstate_ NOT IN ('Planned', 'Blocked'))) THEN

      -- When Purch is called in Connect_Customer_Order_API all info is lost
      Add_Info___(insert_package_mode_);

      -- Connected orders are normally created when the order is released,
      -- but if lines are added after releasing the work has to be done when the line is created.
      -- IF the order is credit blocked the connected orders will be created when the credit
      -- block is released.

      -- IF the part is configurable then configuration has to be defined to create a connected order
      IF (Sales_Part_API.Get_Configurable_Db(newrec_.contract, newrec_.catalog_no) = 'CONFIGURED'
          AND Order_Config_Util_API.Get_Config_Spec_Objstate(newrec_.part_no, newrec_.configuration_id) != 'Completed') THEN
         create_connected_order_ := FALSE;
      END IF;
      IF (create_connected_order_) THEN
         IF (insert_package_mode_ = 'TRUE') THEN
            Connect_Customer_Order_API.Create_Connected_Order_Line(newrec_.qty_on_order, newrec_.order_no, newrec_.line_no,
                                                                   newrec_.rel_no, newrec_.line_item_no, TRUE );
         ELSE
            Connect_Customer_Order_API.Create_Connected_Order_Line(newrec_.qty_on_order, newrec_.order_no, newrec_.line_no,
                                                                   newrec_.rel_no, newrec_.line_item_no, FALSE );
         END IF;
      END IF;
   END IF;

   -- if any of the component line's shipment creation is 'NO_AUTOMATIC' then change the value of pkg to the same
   IF (newrec_.line_item_no > 0 AND newrec_.shipment_creation = 'NO_AUTOMATIC') THEN
      Get_Id_Version_By_Keys___(rowid_, rowversion_, newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1);
      linerec_ := Get_Object_By_Keys___(newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1);
      IF (linerec_.shipment_creation != 'NO_AUTOMATIC') THEN
         linerec_.shipment_creation := 'NO_AUTOMATIC';
         linerec_.rowversion        := sysdate;
         temp_info_ := Client_SYS.Get_All_Info;
         temp_insert_package_mode_ := insert_package_mode_;
         insert_package_mode_ := 'FALSE';
         Raise_Shipment_Chaged_New();
         Add_Info___(insert_package_mode_);
         insert_package_mode_ := temp_insert_package_mode_;
         WHILE (Client_SYS.Get_Next_From_Attr(temp_info_, ptr_, name_, value_)) LOOP
            IF (name_ = 'INFO') THEN
               Client_SYS.Add_Info(lu_name_, value_);
            END IF;
         END LOOP;
         Update_Line___(rowid_, linerec_);
      END IF;
   END IF;

   -- Create the associated commission lines from the default commission receivers
   IF (newrec_.line_item_no <= 0) AND (newrec_.free_of_charge = Fnd_Boolean_API.DB_FALSE) THEN
      Order_Line_Commission_API.Create_Order_Commission_Lines(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.contract, newrec_.customer_no);
   END IF;

   IF (newrec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
      rental_chargeable_days_ := Get_Latest_Rent_Charge_Days___(attr_, newrec_);
   END IF;
    
   -- Save info created so far because it will be cleared if a new discount record is created.
   Add_Info___(insert_package_mode_);
   
   IF NOT (copy_order_line_)THEN 
      copy_discount_ := Client_SYS.Get_Item_Value('COPY_DISCOUNT', attr_);

      IF ((newrec_.discount > 0) AND (NVL(copy_discount_, 'TRUE') != 'FALSE'))  THEN
         discount_type_ := Site_Discom_Info_API.Get_Discount_Type(newrec_.contract);
         Cust_Order_Line_Discount_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, discount_type_, newrec_.discount, Discount_Source_API.DB_MANUAL, Create_Partial_Sum_API.DB_NOT_PARTIAL_SUM, 1, NULL, NULL,  NULL, NULL, NULL, NULL);
         Cust_Order_Line_Discount_API.Calc_Discount_Upd_Co_Line__(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
         -- At this point a call to Add_Transaction_Tax_Info___ is needed, since we avoided calculating tax when there is a discount specified in the line.
         -- This will calculate the tax for discounted amounts.
         IF (tax_from_external_system_ AND fetch_external_tax_ = 'TRUE') THEN
            Add_Transaction_Tax_Info___ (newrec_,  
                                         company_,
                                         newrec_.customer_no,
                                         newrec_.ship_addr_no,                                      
                                         order_rec_.supply_country,
                                         order_rec_.use_price_incl_tax,
                                         order_rec_.currency_code,                                       
                                         tax_from_defaults_,                                      
                                         attr_  => NULL);
         END IF; 
      ELSE
         -- Do not create discount lines for component part order lines, order lines created through Service Order and CRO.
         IF (newrec_.line_item_no <= 0)  AND NOT (newrec_.supply_code = 'SEO' AND newrec_.demand_code IN ('SEC', 'CRO', 'FSM')) THEN
            Customer_Order_Pricing_API.New_Default_Discount_Rec(newrec_.order_no,
                                                                newrec_.line_no,
                                                                newrec_.rel_no,
                                                                newrec_.line_item_no,
                                                                newrec_.contract,
                                                                newrec_.customer_no,
                                                                order_rec_.currency_code,
                                                                order_rec_.agreement_id,
                                                                newrec_.catalog_no,
                                                                newrec_.buy_qty_due,
                                                                newrec_.price_list_no,
                                                                newrec_.customer_level,
                                                                newrec_.customer_level_id,
                                                                rental_chargeable_days_,
                                                                fetch_external_tax_);
         END IF;
      END IF;
   END IF;

   newrec_.discount := Get_Discount(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
   Client_SYS.Add_To_Attr('DISCOUNT', newrec_.discount, attr_);
   -- gelr:disc_price_rounded, begin
   IF (Customer_Order_API.Get_Discounted_Price_Rounded(newrec_.order_no)) THEN
      newrec_.original_discount := Get_Original_Discount(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
   ELSE
      newrec_.original_discount := 0;
   END IF;
   -- gelr:disc_price_rounded, end
   
   IF NOT(copy_order_line_) THEN
      IF (order_rec_.staged_billing = Staged_Billing_Type_API.DB_STAGED_BILLING AND (newrec_.self_billing ='NOT SELF BILLING') AND (newrec_.rental = Fnd_Boolean_API.DB_FALSE)) THEN
         IF (order_rec_.use_price_incl_tax = 'TRUE') THEN
            line_total_ := Get_Sale_Price_Incl_Tax_Total(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
         ELSE
            line_total_ := Get_Sale_Price_Total(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
         END IF;
         Order_Line_Staged_Billing_API.Create_Stages_From_Template(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, line_total_);
         Client_SYS.Add_To_Attr('STAGED_BILLING_DB', 'STAGED BILLING', attr_);
      END IF;

      IF ((newrec_.line_item_no > 0) AND (newrec_.staged_billing = 'STAGED BILLING')) THEN
         total_percentage_:= Order_Line_Staged_Billing_API.Get_Total_Invoiced_Percentage(newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1);
         IF (total_percentage_ > 0) THEN
            newrec_.qty_invoiced := round((newrec_.buy_qty_due*total_percentage_/100),12);
            CUSTOMER_ORDER_API.Set_Line_Qty_Invoiced(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.qty_invoiced);
         END IF;
      END IF;
   END IF;

   IF (newrec_.originating_rel_no IS NOT NULL) THEN
      msg_text_ := SUBSTR(Language_SYS.Translate_Constant(lu_name_,'SRC_NEW: Line created from source lines with del no :P1, the new del no is :P2',NULL,newrec_.originating_rel_no , newrec_.rel_no ), 1, 200);
      Customer_Order_Line_Hist_API.New( newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, msg_text_);
   END IF;

   -- Refresh attribute string's values by appending them.
   IF (newrec_.supply_code = 'PKG') THEN
      newrec_ := Get_Object_By_Keys___(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      add_status_ := TRUE;
   END IF;

   IF (newrec_.qty_assigned > 0) THEN
      -- IF reservation has been made send updated values to the client
      Client_SYS.Set_Item_Value('QTY_ASSIGNED', newrec_.qty_assigned, attr_);
      IF NOT add_status_ THEN -- if status hasn't been fetched in clause above...
         newrec_.rowstate := Get_Objstate(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      END IF;
      add_status_ := TRUE;
   END IF;
   -- only run the automatic capability check when the ctp_planned flag is N, so lines created from Quotation or Distribution Order
   -- with the flag set to Y will not be valid for the automatic capability check (you have either run the manual
   -- capability check on the Quotation Line or the Distribution Order was created from a Order Line/Dop that have
   -- already done the capability check for the ctp_planned flag to be Y)
   IF (newrec_.ctp_planned = 'N') THEN
      automatic_capability_check_ := Get_Auto_Capability_Check___(newrec_.supply_code, newrec_.contract, newrec_.supply_site, newrec_.part_no);
      -- run the capability check if the inventory part is configured to use automatic capability check
      IF (automatic_capability_check_ IN ('RESERVE AND ALLOCATE','ALLOCATE ONLY','NEITHER RESERVE NOR ALLOCATE')) THEN
         Perform_Capability_Check___(newrec_, auto_cc_performed_, header_rowstate_, automatic_capability_check_);
         IF (auto_cc_performed_ = TRUE) THEN
            Update_Line___(rowid_, newrec_);
            $IF (Component_Ordstr_SYS.INSTALLED)$THEN 
               IF (App_Context_SYS.Find_Number_Value('CTP_RUN_ID') IS NOT NULL) THEN
                  ctp_run_id_ := App_Context_SYS.Get_Number_Value('CTP_RUN_ID');
                  IF (ctp_run_id_ > 0 ) THEN
                     Client_SYS.Add_To_Attr('CTP_RUN_ID', ctp_run_id_ , attr_);
                     Client_SYS.Add_To_Attr('IS_DELIVERABLE', Interim_Ctp_Critical_Path_API.Get_Is_Deliverable(ctp_run_id_) , attr_);
                  END IF;
               END IF;
               IF (App_Context_SYS.Find_Date_Value('OLD_REQUIRED_DATE') IS NOT NULL) THEN
                  Client_SYS.Add_To_Attr('OLD_REQUIRED_DATE', App_Context_SYS.Get_Date_Value('OLD_REQUIRED_DATE') , attr_);
               END IF;
         $ELSE
            NULL;
         $END
         END IF;
      END IF;
   END IF;

   -- Create a history record for Invoiced Blocked.
   IF (newrec_.blocked_for_invoicing = 'TRUE') THEN
      msg_text_ := Language_SYS.Translate_Constant(lu_name_, 'INVOICEBLOCEKD: Invoice Blocked');
      Customer_Order_Line_Hist_API.New( newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, msg_text_);
   END IF;

   -- The values added here are either the usual record or prior check on supply_code's result or calculated from the automatic capability check
   Client_SYS.Set_Item_Value('PLANNED_DELIVERY_DATE', newrec_.planned_delivery_date, attr_);
   Client_SYS.Set_Item_Value('PROMISED_DELIVERY_DATE', newrec_.promised_delivery_date, attr_);
   Client_SYS.Set_Item_Value('PLANNED_SHIP_DATE', newrec_.planned_ship_date, attr_);
   Client_SYS.Set_Item_Value('PLANNED_DUE_DATE', newrec_.planned_due_date, attr_);
   Client_SYS.Set_Item_Value('SUPPLY_SITE_DUE_DATE', newrec_.supply_site_due_date, attr_);
   Client_SYS.Set_Item_Value('OBJSTATE', newrec_.rowstate, attr_);
   Client_SYS.Set_Item_Value('SHIPMENT_CREATION_DB', newrec_.shipment_creation, attr_);
   Client_SYS.Set_Item_Value('SHIPMENT_CREATION', Shipment_Creation_API.Decode(newrec_.shipment_creation), attr_);

   IF add_status_ THEN
      Client_SYS.Set_Item_Value('__OBJSTATE', newrec_.rowstate, attr_);
      Client_SYS.Set_Item_Value('__OBJEVENTS', Finite_State_Events__(newrec_.rowstate), attr_);
      Client_SYS.Set_Item_Value('STATE', Finite_State_Decode__(newrec_.rowstate), attr_);
   END IF;

   -- Return the detected PROJECT_ID back to the client
   Client_SYS.Set_Item_Value('PROJECT_ID', newrec_.project_id, attr_);

   IF (newrec_.supply_code = 'PKG') THEN
      block_component_info_ := 'FALSE';
   END IF;

   -- Do not create/connect to shipment if delay requested through attribute 'DELAY_SHIPMENT_SINGLE_OCC' to wait till single occurrence line address is created
   IF (NVL(Client_SYS.Get_Item_Value('DELAY_SHIPMENT_SINGLE_OCC', attr_), 'FALSE') = 'FALSE') THEN
      Check_And_Add_To_Shipment___(newrec_,  header_rowstate_);
   END IF;

   default_charges_ := Client_SYS.Get_Item_Value('DEFAULT_CHARGES', attr_);
   IF ( default_charges_ IS NULL ) THEN
       default_charges_ := 'TRUE';
   END IF;
   IF (default_charges_ = 'TRUE') THEN
      IF newrec_.line_item_no IN (-1,0) THEN
         Customer_Order_Charge_API.Copy_From_Sales_Part_Charge(newrec_.order_no,
                                                               newrec_.line_no,
                                                               newrec_.rel_no,
                                                               newrec_.line_item_no);
      END IF;
   END IF;

   -- Add new CO charge lines.
   IF (newrec_.line_item_no <= 0) THEN
      IF ((default_charges_ = 'TRUE')OR(copy_order_line_ AND newrec_.free_of_charge = Fnd_Boolean_API.DB_FALSE)) THEN
         Customer_Order_Charge_Util_API.New_Cust_Order_Charge_Line(newrec_, FALSE);
      -- When a CO is created through a quotation default_charges_ will be FALSE
      -- we need to add only freight charges since the packsize charges will be transfered from the order quotation charges later
      ELSE
         Customer_Order_Charge_Util_API.New_Cust_Order_Charge_Line(newrec_, TRUE);
      END IF;
   END IF;

   Update_Freight_Free(newrec_);

   IF (newrec_.demand_code = 'DO') THEN
      $IF (Component_Disord_SYS.INSTALLED) $THEN
         Distribution_Order_API.Modify_From_Connected_Order(newrec_.demand_order_ref1,
                                                            newrec_.wanted_delivery_date,
                                                            newrec_.planned_due_date,
                                                            newrec_.planned_ship_date,
                                                            newrec_.planned_delivery_date,
                                                            planned_receipt_date_,
                                                            '',
                                                            '',
                                                            newrec_.forward_agent_id,
                                                            newrec_.delivery_terms,
                                                            newrec_.ship_via_code,
                                                            '',
                                                            newrec_.route_id,
                                                            'ORDER');
      $ELSE
         NULL;
      $END
   END IF;

   min_qty_ := sales_part_rec_.minimum_qty;
   IF (min_qty_ IS NOT NULL) THEN
      IF (min_qty_ > newrec_.buy_qty_due) THEN
         Client_SYS.Add_Info(lu_name_, 'LTMINIMUMQTY: The minimum quantity when ordering Sales Part No :P1 is :P2 :P3.', newrec_.catalog_no, min_qty_, newrec_.sales_unit_meas);
      END IF;
   END IF;

   IF Tax_Liability_Countries_API.Check_Valid_Info_Exist(company_, order_rec_.supply_country, Site_API.Get_Site_Date(order_rec_.contract)) = 'TRUE' THEN
      IF Tax_Liability_API.Get_Tax_Liability_Type_Db(order_rec_.tax_liability, newrec_.country_code) != 'EXM' AND newrec_.tax_liability_type = 'EXM' THEN
         Client_SYS.Add_Info(lu_name_, 'EXEMPTLIABILITY: Since the tax liability type is ''Exempt'' the Supply Country Tax ID No will be printed on the invoice.');
      ELSE
         header_deliver_country_db_ := Customer_Order_Address_API.Get_Country_Code(newrec_.order_no);
         -- if the line is not defaulted from header and is having a NON-single occurence address
         IF newrec_.default_addr_flag = 'N' AND newrec_.addr_flag = 'N' AND newrec_.country_code != header_deliver_country_db_ THEN
            Client_SYS.Add_Info(lu_name_, 'DIFFDELIVCOUNTRY: Since delivery address country is not the same as the header delivery address country the Supply Country Tax ID No will be printed on the invoice.');
         END IF;
      END IF;
   END IF;

   -- sales promotion check, if value on deal_description_ this order line have atleast one possible sales promotion deal
   IF (newrec_.free_of_charge = Fnd_Boolean_API.DB_FALSE) THEN
      deal_description_ := Get_Possible_Sales_Promo_Deal(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.rowstate, newrec_.price_source_net_price, newrec_.charged_item, newrec_.exchange_item, newrec_.self_billing, newrec_.part_ownership, newrec_.rental);
   END IF;
   IF (deal_description_ = 'MULTIPLE_DEALS') THEN
      Client_SYS.Add_Info(lu_name_, 'MULTIPLESALESPROMOEXIST: The sales part is connected to multiple sales promotion deal, can be analyzed via operations menu Calculate and View Sales Promotions.');
   ELSIF (deal_description_ IS NOT NULL) THEN
      Client_SYS.Add_Info(lu_name_, 'POSSIBLESALESPROMOEXIST: The sales part is connected to a sales promotion deal :P1.', deal_description_);
   END IF;
   Customer_Order_Charge_Util_API.Recalc_Percentage_Charge_Taxes(newrec_.order_no, newrec_.line_no, tax_from_external_system_);

END Post_Insert_Actions___;


-- Calculate_Order_Line_Dates___
--   Calculate the planned delivery date, planned ship date and
--   planned due date to be set for an order line.
PROCEDURE Calculate_Order_Line_Dates___ (
   newrec_ IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   oldrec_ IN     CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   objid_  IN     VARCHAR2 )
IS   
   contract_                   CUSTOMER_ORDER_LINE_TAB.contract%TYPE;
   calendar_id_                VARCHAR2(10);
   new_demand_qty_             NUMBER := NULL;
   old_demand_qty_             NUMBER := NULL;
   calculate_                  BOOLEAN := TRUE;   
   new_mrp_demand_qty_         NUMBER := NULL;
   old_mrp_demand_qty_         NUMBER := NULL;
   use_current_date_           VARCHAR2(5) := 'FALSE';
   fully_reserved_             NUMBER := 0;
   delivery_leadtime_          NUMBER;
   picking_leadtime_           NUMBER;
   internal_control_time_      NUMBER;
   vendor_delivery_leadtime_   NUMBER;
   internal_delivery_leadtime_ NUMBER;
   vendor_manuf_leadtime_      NUMBER;
   vendor_leadtime_            NUMBER;
   expected_leadtime_          NUMBER;
   order_conf_db_              VARCHAR2(1) := 'N';
   addr_flag_db_               VARCHAR2(1) := 'N';
   transport_leadtime_         NUMBER;
   arrival_route_id_           VARCHAR2(12);
   ship_via_code_changed_      VARCHAR2(5);
   ext_customer_order_no_      VARCHAR2(12);
   ext_line_no_                VARCHAR2(12);
   ext_rel_no_                 VARCHAR2(4);
   ext_line_item_no_           NUMBER;
   qty_reserved_               NUMBER;   
BEGIN
   IF (newrec_.target_date != oldrec_.target_date) THEN
      use_current_date_ := 'TRUE';
   END IF;
   -- Demand Qty is used for ATP analysis (IO supply only)
   new_demand_qty_ := NVL(newrec_.revised_qty_due - (newrec_.qty_shipped - newrec_.qty_shipdiff) - newrec_.qty_assigned, 0);
   old_demand_qty_ := NVL(oldrec_.revised_qty_due - (oldrec_.qty_shipped - oldrec_.qty_shipdiff) - oldrec_.qty_assigned, 0);

   new_mrp_demand_qty_ := NVL(newrec_.revised_qty_due - (newrec_.qty_shipped - newrec_.qty_shipdiff), 0);
   old_mrp_demand_qty_ := NVL(oldrec_.revised_qty_due - (oldrec_.qty_shipped - oldrec_.qty_shipdiff), 0);

   -- old_demand_date need to change when there is a supply_code change (only ATP analysis considered)
   IF oldrec_.supply_code NOT IN ('IO', 'SO', 'DOP', 'PT', 'PD', 'IPT', 'IPD') THEN
      IF newrec_.supply_code IN ('IO', 'SO', 'DOP', 'PT', 'PD', 'IPT', 'IPD') THEN
         old_demand_qty_ := 0;
      END IF;
   END IF;

   IF ((newrec_.rowstate IS NULL) OR (newrec_.rowstate != 'Cancelled')) THEN
      IF (oldrec_.rel_mtrl_planning = 'TRUE') AND (newrec_.rel_mtrl_planning = 'FALSE') THEN
         new_mrp_demand_qty_ := 0;
      ELSIF (oldrec_.rel_mtrl_planning = 'FALSE') AND (newrec_.rel_mtrl_planning = 'TRUE') THEN
         old_mrp_demand_qty_ := 0;
      ELSIF (oldrec_.rel_mtrl_planning = 'FALSE') AND (newrec_.rel_mtrl_planning = 'FALSE') THEN
         old_mrp_demand_qty_ := 0;
         new_mrp_demand_qty_ := 0;
      ELSIF (oldrec_.rel_mtrl_planning IS NULL) AND (newrec_.rel_mtrl_planning = 'TRUE') THEN
         -- A new record is inserted with rel_mtrl_planning TRUE.
         old_mrp_demand_qty_ := 0;
      ELSIF (oldrec_.rel_mtrl_planning IS NULL) AND (newrec_.rel_mtrl_planning = 'FALSE') THEN
         -- A new record is inserted with rel_mtrl_planning FALSE.
         new_mrp_demand_qty_ := 0;
      END IF;
   ELSE
      new_mrp_demand_qty_ := 0;
      old_mrp_demand_qty_ := 0;
   END IF;

   -- don't calculate the dates if demand DO and CTP planned (for new records) - the dates have already been calculated in DisOrd.
   IF (newrec_.demand_code = 'DO') AND (newrec_.ctp_planned = 'Y') AND (objid_ IS NULL) THEN
      calculate_ := (newrec_.planned_ship_date IS NULL);
   END IF;

   IF calculate_ THEN      
      fully_reserved_ := Reserve_Customer_Order_API.Line_Is_Fully_Reserved(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      
      IF (newrec_.demand_code IN ('IPT', 'DO')) AND (newrec_.ship_via_code != NVL(oldrec_.ship_via_code, Database_SYS.string_null_)) THEN
         delivery_leadtime_        := newrec_.delivery_leadtime;
         ship_via_code_changed_    := 'TRUE';
         
         Cust_Order_Leadtime_Util_API.Get_Default_Leadtimes(delivery_leadtime_, vendor_delivery_leadtime_, internal_delivery_leadtime_, 
                                                            picking_leadtime_, internal_control_time_, vendor_manuf_leadtime_, vendor_leadtime_, 
                                                            expected_leadtime_, transport_leadtime_, arrival_route_id_, newrec_.contract, newrec_.deliver_to_customer_no, newrec_.ship_addr_no, 
                                                            addr_flag_db_, newrec_.part_no, NVL(newrec_.part_no, newrec_.purchase_part_no), newrec_.supply_code,
                                                            newrec_.vendor_no, newrec_.ship_via_code, newrec_.supplier_ship_via_transit, ship_via_code_changed_);

         newrec_.delivery_leadtime := delivery_leadtime_;
      END IF;
      
      IF (newrec_.demand_code IN ('IPT', 'IPD') AND newrec_.demand_order_ref1 IS NOT NULL) THEN
         Customer_Order_Pur_Order_API.Get_Custord_For_Purord(ext_customer_order_no_, ext_line_no_, ext_rel_no_, ext_line_item_no_, newrec_.demand_order_ref1, newrec_.demand_order_ref2, newrec_.demand_order_ref3);
     
         IF (ext_customer_order_no_ IS NOT NULL) THEN 
               qty_reserved_ := Co_Supply_Site_Reservation_API.Get_Qty_Reserved(ext_customer_order_no_,ext_line_no_,ext_rel_no_,ext_line_item_no_);
               IF (qty_reserved_ > 0) THEN
                  new_demand_qty_ := new_demand_qty_ - qty_reserved_;
               END IF;
         END IF;
      END IF; 

      Cust_Ord_Date_Calculation_API.Calc_Order_Dates_Backwards(newrec_.planned_delivery_date,
         newrec_.planned_ship_date, newrec_.planned_due_date, newrec_.supply_site_due_date,
         newrec_.target_date, newrec_.date_entered, newrec_.order_no, newrec_.deliver_to_customer_no,
         newrec_.ship_addr_no, newrec_.vendor_no, newrec_.ship_via_code, newrec_.delivery_leadtime, newrec_.picking_leadtime, newrec_.ext_transport_calendar_id,
         newrec_.supplier_ship_via_transit, newrec_.supply_site_reserve_type, newrec_.route_id,
         newrec_.supply_code, newrec_.contract, newrec_.part_no,nvl(newrec_.part_no, newrec_.purchase_part_no),
         newrec_.configuration_id, newrec_.conv_factor, newrec_.inverted_conv_factor, newrec_.ctp_planned, new_demand_qty_, old_demand_qty_,
         objid_, oldrec_.supply_code, oldrec_.planned_due_date, FALSE, oldrec_.part_ownership, newrec_.part_ownership, newrec_.release_planning,
         newrec_.demand_order_ref1, newrec_.demand_code, new_mrp_demand_qty_, old_mrp_demand_qty_, newrec_.catalog_type, use_current_date_, fully_reserved_,
         newrec_.rowstate, newrec_.supply_site_part_no, newrec_.abnormal_demand , oldrec_.abnormal_demand);
   END IF;
   
   order_conf_db_ := Customer_Order_API.Get_Order_Conf_Db(newrec_.order_no);
   IF (order_conf_db_ = 'N' OR (newrec_.promised_delivery_date IS NULL)) THEN
      newrec_.promised_delivery_date := newrec_.planned_delivery_date;
   END IF;

   IF (newrec_.vendor_no IS NULL) THEN
      contract_ := newrec_.contract;
   ELSE
      contract_ := newrec_.supply_site;
   END IF;
   -- Added a condition only to fetch the planned_ship_period when the planned_ship_date is changed.
   IF (oldrec_.planned_ship_date != newrec_.planned_ship_date) THEN
      calendar_id_ := Site_API.Get_Dist_Calendar_Id(contract_);
      -- set shipment period
      newrec_.planned_ship_period := Work_Time_Calendar_API.Get_Period(calendar_id_, newrec_.planned_ship_date);
   END IF;
END Calculate_Order_Line_Dates___;


-- Insert_Default_Address___
--   Adds the same address to the bypassed order line as the order header's.
--   If not the same address no, the order line's address no is used when fetching
--   the correct address from the customer.
PROCEDURE Insert_Default_Address___ (
   order_no_               IN VARCHAR2,
   line_no_                IN VARCHAR2,
   rel_no_                 IN VARCHAR2,
   line_item_no_           IN NUMBER,
   customer_no_            IN VARCHAR2,
   ship_addr_no_           IN VARCHAR2,
   deliver_to_customer_no_ IN VARCHAR2 )
IS
   info_       VARCHAR2(2000);
   attr_       VARCHAR2(2000);
   objid_      VARCHAR2(2000);
   objversion_ VARCHAR2(2000);
   addr_rec_   CUSTOMER_ORDER_ADDRESS_API.Cust_Ord_Addr_Rec;
   name_       VARCHAR2(100);
BEGIN
   Client_SYS.Add_To_Attr('ORDER_NO', order_no_, attr_);
   Client_SYS.Add_To_Attr('LINE_NO', line_no_, attr_);
   Client_SYS.Add_To_Attr('REL_NO', rel_no_, attr_);
   Client_SYS.Add_To_Attr('LINE_ITEM_NO', line_item_no_, attr_);
   -- fetch order header's address
   addr_rec_ := Customer_Order_Address_API.Get_Cust_Ord_Addr(order_no_);

   IF (customer_no_ = deliver_to_customer_no_) AND (addr_rec_.ship_addr_no = ship_addr_no_) THEN
      Client_SYS.Add_To_Attr('ADDR_1', addr_rec_.addr_1, attr_);
      Client_SYS.Add_To_Attr('ADDRESS1', addr_rec_.address1, attr_);
      Client_SYS.Add_To_Attr('ADDRESS2', addr_rec_.address2, attr_);
      Client_SYS.Add_To_Attr('ADDRESS3', addr_rec_.address3, attr_);
      Client_SYS.Add_To_Attr('ADDRESS4', addr_rec_.address4, attr_);
      Client_SYS.Add_To_Attr('ADDRESS5', addr_rec_.address5, attr_);
      Client_SYS.Add_To_Attr('ADDRESS6', addr_rec_.address6, attr_);
      Client_SYS.Add_To_Attr('ZIP_CODE', addr_rec_.zip_code, attr_);
      Client_SYS.Add_To_Attr('CITY', addr_rec_.city, attr_);
      Client_SYS.Add_To_Attr('STATE', addr_rec_.state, attr_);
      Client_SYS.Add_To_Attr('COUNTRY_CODE', addr_rec_.country_code, attr_);
      Client_SYS.Add_To_Attr('COUNTY', addr_rec_.county, attr_);
      Client_SYS.Add_To_Attr('IN_CITY', addr_rec_.in_city, attr_);
   ELSE
      -- if that addr no isn't the same as the line's - fetch address from Deliver to customer instead.
      name_ := Customer_Info_Address_API.Get_Name(deliver_to_customer_no_, ship_addr_no_);
      Client_SYS.Add_To_Attr('ADDR_1', name_, attr_);
      Client_SYS.Add_To_Attr('ADDRESS1', Cust_Ord_Customer_Address_API.Get_Address1(deliver_to_customer_no_, ship_addr_no_), attr_);
      Client_SYS.Add_To_Attr('ADDRESS2', Cust_Ord_Customer_Address_API.Get_Address2(deliver_to_customer_no_, ship_addr_no_), attr_);
      Client_SYS.Add_To_Attr('ADDRESS3', Cust_Ord_Customer_Address_API.Get_Address3(deliver_to_customer_no_, ship_addr_no_), attr_);
      Client_SYS.Add_To_Attr('ADDRESS4', Cust_Ord_Customer_Address_API.Get_Address4(deliver_to_customer_no_, ship_addr_no_), attr_);
      Client_SYS.Add_To_Attr('ADDRESS5', Cust_Ord_Customer_Address_API.Get_Address5(deliver_to_customer_no_, ship_addr_no_), attr_);
      Client_SYS.Add_To_Attr('ADDRESS6', Cust_Ord_Customer_Address_API.Get_Address6(deliver_to_customer_no_, ship_addr_no_), attr_);      
      Client_SYS.Add_To_Attr('ZIP_CODE', Cust_Ord_Customer_Address_API.Get_Zip_Code(deliver_to_customer_no_, ship_addr_no_), attr_);
      Client_SYS.Add_To_Attr('CITY', Cust_Ord_Customer_Address_API.Get_City(deliver_to_customer_no_, ship_addr_no_), attr_);
      Client_SYS.Add_To_Attr('STATE', Cust_Ord_Customer_Address_API.Get_State(deliver_to_customer_no_, ship_addr_no_), attr_);
      Client_SYS.Add_To_Attr('COUNTRY_CODE', Cust_Ord_Customer_Address_API.Get_Country_Code(deliver_to_customer_no_, ship_addr_no_), attr_);
      Client_SYS.Add_To_Attr('COUNTY', Cust_Ord_Customer_Address_API.Get_County(deliver_to_customer_no_, ship_addr_no_), attr_);
      Client_SYS.Add_To_Attr('IN_CITY',Customer_Info_Address_API.Get_In_City(deliver_to_customer_no_, ship_addr_no_), attr_);
   END IF;
   Cust_Order_Line_Address_API.New__(info_, objid_, objversion_, attr_, 'DO');
END Insert_Default_Address___;


-- Exist_Purchase_Part___
--   Dynamic Exist call to PurchasePart LU.
--   If inventory_part flag is FALSE, and extended check is made ->
--   the purchase part number has to be a non-inventory part.
PROCEDURE Exist_Purchase_Part___ (
   contract_         IN VARCHAR2,
   purchase_part_no_ IN VARCHAR2,
   inventory_part_   IN BOOLEAN,
   rental_db_        IN VARCHAR2 )
IS
   found_ NUMBER := 0;
   usage_ VARCHAR2(20);
BEGIN
   $IF (Component_Purch_SYS.INSTALLED)$THEN
      IF (rental_db_ = Fnd_Boolean_API.DB_FALSE) THEN
         usage_ := Acquisition_Type_API.DB_PURCHASE_ONLY;
      ELSE
         usage_ := Acquisition_Type_API.DB_RENTAL_ONLY;
      END IF;
      Purchase_Part_API.Exist(contract_, purchase_part_no_, usage_);
      IF NOT inventory_part_ THEN
         found_ := Purchase_Part_API.Is_Inventory_Part(contract_, purchase_part_no_);
         IF (found_ = 1) THEN
            Error_SYS.Record_General(lu_name_, 'INVPURPART: The purchase part :P1 is an inventory part. Not allowed for non-inventory sales parts!', purchase_part_no_);
         END IF;
      END IF;
   $ELSE
      NULL;
   $END
END Exist_Purchase_Part___;


-- Check_Supply_Code___
--   Method to check if the entered supply code is allowed - using a
--   variety of combination checks. DOP parts, configured parts and so on.
PROCEDURE Check_Supply_Code___ (
   newrec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
   sales_part_rec_        SALES_PART_API.Public_Rec;
   supply_code_cl_        VARCHAR2(200) := Order_Supply_Type_API.Decode(newrec_.supply_code);
   type_code_             VARCHAR2(20);
   inv_part_planning_rec_ Inventory_Part_Planning_API.Public_Rec;
   prod_structure_exist_  BOOLEAN := FALSE;
BEGIN
   -- Check if right SUPPLY_CODE
   IF (newrec_.supply_code NOT IN ('IO', 'SO', 'PT', 'PD', 'NO', 'PKG', 'IPT', 'IPD', 'SEO', 'DOP', 'ND', 'SRC', 'MRO', 'PI', 'PS', 'PRJ', 'PJD', 'CRO')) THEN
      Error_SYS.Record_General(lu_name_, 'WRONG_SUPPLY_CODE: Supply code ":P1" is not allowed for this part.', supply_code_cl_);
   END IF;

   sales_part_rec_ := Sales_Part_API.Get(newrec_.contract, newrec_.catalog_no);

   -- Automatic sourcing is only allowed if sales part is set up to Use Sourcing Rule.
   IF (newrec_.supply_code = 'SRC') AND (sales_part_rec_.sourcing_option != 'USESOURCINGRULE') THEN
      Error_SYS.Record_General(lu_name_, 'AUTOSOURCING: Supply Code ":P1" is only allowed when sales part is set up to Use Sourcing Rule.', supply_code_cl_);
   END IF;

   -- DOP
   -- IF inventory part is a DOP part, supply code may only be set to DOP or IO
   inv_part_planning_rec_ := Inventory_Part_Planning_API.Get(newrec_.contract, newrec_.part_no);
   IF (NVL(inv_part_planning_rec_.order_requisition, '*') = 'D') THEN
	  IF (newrec_.supply_code NOT IN('IO', 'DOP', 'MRO', 'SEO', 'PI', 'PJD', 'CRO', 'IPT', 'IPD')) THEN
         Error_SYS.Record_General(lu_name_, 'DOPSUPPLY: Supply code ":P1" is not allowed for DOP parts.', supply_code_cl_);
      END IF;
   END IF;
   IF (newrec_.supply_code = 'DOP') AND (inv_part_planning_rec_.planning_method ='N') THEN
      Error_SYS.Record_General(lu_name_, 'MRPCODEPNNOTALLOWED: Associated Inventory Part cannot have MRP order code ":P1" when using supply code ":P2".',
                          inv_part_planning_rec_.planning_method, supply_code_cl_);
   ELSIF (newrec_.dop_connection IS NOT NULL) AND (newrec_.supply_code != 'DOP') THEN
      Error_SYS.Record_General(lu_name_, 'NO_CONNECTION: DOP connection is only allowed when supply code is set to ":P1"!', Order_Supply_Type_API.Decode('DOP'));
   END IF;

   Trace_SYS.Field('catalog_type', newrec_.catalog_type);

   -- CTO
   -- IO is not allowed for Configured inventory parts.
   IF (Part_Catalog_API.Get_Configurable_Db(nvl(newrec_.part_no, newrec_.catalog_no)) = 'CONFIGURED') THEN
      IF (newrec_.supply_code NOT IN ('IO', 'NO', 'SO','PI','PT', 'PD', 'IPT', 'IPD', 'SEO', 'DOP', 'ND', 'SRC', 'MRO', 'PJD')) THEN
         Error_SYS.Record_General(lu_name_, 'CONFIGPART: Supply code ":P1" is not allowed for configured parts.', supply_code_cl_);
      END IF;
   END IF;

   IF (newrec_.activity_seq IS NOT NULL) THEN
      IF (sales_part_rec_.catalog_type = 'INV') THEN
         IF (newrec_.supply_code NOT IN ('IO', 'PI', 'PD', 'IPD', 'PJD', 'PT', 'IPT', 'SO', 'ND', 'DOP', 'SEO', 'SRC')) THEN
            Error_Sys.Record_General(lu_name_, 'NOTALLOWEDIP: Project connected Customer Order Lines for Inventory Parts can only have supply code :P1, :P2, :P3.',Order_Supply_Type_API.Decode('IO'),Order_Supply_Type_API.Decode('PI'),(Order_Supply_Type_API.Decode('PD')||', '|| Order_Supply_Type_API.Decode('PT')||', '|| Order_Supply_Type_API.Decode('IPT')||', '||Order_Supply_Type_API.Decode('IPD')||', ' || Order_Supply_Type_API.Decode('ND') || ', ' || Order_Supply_Type_API.Decode('PJD')||', '||Order_Supply_Type_API.Decode('SO') ||' or '||Order_Supply_Type_API.Decode('DOP')));
         END IF;
      ELSIF (sales_part_rec_.catalog_type = 'NON') THEN
         IF (newrec_.supply_code NOT IN ('NO','PRJ','PD','IPD','PT', 'IPT', 'ND', 'SEO')) THEN
            Error_Sys.Record_General(lu_name_, 'NOTALLOWEDNP: Project connected Customer Order Lines for Non Inventory Sales Parts can only have supply code :P1, :P2, :P3.',Order_Supply_Type_API.Decode('NO'), Order_Supply_Type_API.Decode('PRJ'), Order_Supply_Type_API.Decode('ND') || ', ' || (Order_Supply_Type_API.Decode('PD') || ', ' || Order_Supply_Type_API.Decode('IPD') || ', ' || Order_Supply_Type_API.Decode('PT') || ' or ' || Order_Supply_Type_API.Decode('IPT')));
         END IF;
      END IF;
   ELSE
      IF (newrec_.supply_code IN ('PI', 'PJD')) THEN
         Error_Sys.Record_General(lu_name_, 'NOTALLOWED_PI_PJD: Supply code :P1 is only allowed for project connected customer order lines for Inventory Parts.', Order_Supply_Type_API.Decode(newrec_.supply_code));
      ELSIF (newrec_.supply_code IN ('PRJ')) THEN
         Error_Sys.Record_General(lu_name_, 'NOTALLOWEIPPRJ: Supply code :P1 is only allowed for project connected customer order lines for Non Inventory Sales Parts.',Order_Supply_Type_API.Decode('PRJ'));
      END IF;
   END IF;

   -- Check if right SUPPLY_CODE depending on CATALOG_TYPE
   IF (sales_part_rec_.catalog_type = 'INV') THEN
      IF (newrec_.supply_code IN ('NO', 'PKG')) THEN
         Error_SYS.Record_General(lu_name_, 'INVPART: Supply code ":P1" is not allowed for inventory sales parts.', supply_code_cl_);
      ELSIF (newrec_.supply_code = 'SO') THEN
         -- IF Manufactured (1) or Manufactured Recipe (2), Shop Order must be supplied
         type_code_ := nvl(Inventory_Part_API.Get_Type_Code_Db(newrec_.contract, newrec_.part_no), '0');
         IF (type_code_ NOT IN ('1', '2')) THEN
            $IF (Component_Mfgstd_SYS.INSTALLED) $THEN
               IF(Prod_Structure_Head_API.Product_Exist(newrec_.contract, newrec_.part_no, 'M') = 1) THEN
                  prod_structure_exist_ := TRUE;
               END IF;
            $END
            IF(prod_structure_exist_ = FALSE)THEN
               Error_SYS.Record_General(lu_name_, 'MANUFPART: Supply code ":P1" is only allowed for manufactured parts.', supply_code_cl_); 
            END IF;
         END IF;        
      END IF;
   ELSIF (sales_part_rec_.catalog_type = 'NON') THEN
      IF (newrec_.supply_code NOT IN ('PT', 'PD', 'NO', 'IPT', 'IPD', 'SEO', 'ND', 'SRC', 'PRJ')) THEN
         Error_SYS.Record_General(lu_name_, 'NONINVENT: Supply code ":P1" is not allowed. You may only use purchase order supply or no supply for non-inventory parts.', supply_code_cl_);
      END IF;
   ELSIF (sales_part_rec_.catalog_type = 'PKG') THEN
      IF (newrec_.supply_code != 'PKG') THEN
         Error_SYS.Record_General(lu_name_, 'PACKAGEPART: Supply code ":P1" is not allowed for package parts.', supply_code_cl_);
      END IF;
   END IF;

   -- Production Schedule Check
   $IF (Component_Mfgstd_SYS.INSTALLED) $THEN
      IF newrec_.supply_code = 'PS' THEN
         Production_Line_Part_API.Production_Schedules_Enabled(newrec_.contract, newrec_.part_no);
      END IF;
   $END

   -- validate purchase part no only if supply code is Purchase Order
   IF ((newrec_.purchase_part_no IS NOT NULL) AND (newrec_.supply_code IN ('PD', 'PT', 'IPD', 'IPT'))) THEN
      Exist_Purchase_Part___(newrec_.contract, newrec_.purchase_part_no, (newrec_.part_no IS NOT NULL), newrec_.rental);
   END IF;

   -- Validate Supply Code 'CRO'
   IF (NVL(newrec_.demand_code, ' ') IN (Order_Supply_Type_API.DB_COMPONENT_REPAIR_ORDER, Order_Supply_Type_API.DB_COMPONENT_REPAIR_EXCHANGE) AND newrec_.demand_order_ref1 IS NOT NULL) THEN
      IF (newrec_.supply_code NOT IN ('CRO', 'SEO', 'IO')) THEN
         Error_SYS.Record_General(lu_name_, 'SUPPLYCODEFILTERCRO: The customer order line is created from a component repair order. Only :P1, :P2 or :P3 supply codes are allowed.', Order_Supply_Type_API.Decode('CRO'), Order_Supply_Type_API.Decode('IO'), Order_Supply_Type_API.Decode('SEO'));
      END IF;
   ELSE
      IF (newrec_.supply_code = 'CRO') THEN
         Error_SYS.Record_General(lu_name_, 'ONLYFROMCRO: This supply code is only allowed for Customer Order lines created from a Component Repair Order.');
      END IF;
   END IF;
   
   IF (NVL(newrec_.demand_code, ' ') = 'FSM' AND newrec_.supply_code != 'SEO') THEN
      Error_SYS.Record_General(lu_name_, 'SUPPLYCODEFILTERFSM: The customer order line is created from Field Service Management. Only :P1 supply codes is allowed.', Order_Supply_Type_API.Decode('SEO'));      
   END IF;   
END Check_Supply_Code___;

-- Check_Purch_Supply_Code___
--    Method to check if the entered purch related supply code ('PD', 'PT', 'IPD', 'IPT') is allowed for a
--    specific part.
PROCEDURE Check_Purch_Supply_Code___ (
   newrec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
   sales_part_rec_    SALES_PART_API.Public_Rec;
   supply_code_cl_    VARCHAR2(200) := Order_Supply_Type_API.Decode(newrec_.supply_code);
BEGIN
   sales_part_rec_ := Sales_Part_API.Get(newrec_.contract, newrec_.catalog_no);
   IF (sales_part_rec_.catalog_type IN ('NON', 'INV')) THEN
      IF ((newrec_.purchase_part_no IS NULL) AND (newrec_.supply_code IN ('PD', 'IPD', 'PT', 'IPT'))) THEN
         Error_SYS.Record_General(lu_name_, 'NOSUPPLY: Purchase part must be entered when supply code is ":P1".', supply_code_cl_);
      END IF;
   END IF;
END Check_Purch_Supply_Code___;

-- Update_Config_Pricing_Info___
--   Implementation method for getting back the pricing info.
PROCEDURE Update_Config_Pricing_Info___ (
   newrec_ IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
BEGIN
   IF ((newrec_.configuration_id != '*') AND (newrec_.configured_line_price_id IS NOT NULL)) THEN
      Configured_Line_Price_API.Get_Pricing_Totals(newrec_.char_price, newrec_.calc_char_price,
         newrec_.configured_line_price_id, newrec_.configuration_id);
   END IF;
END Update_Config_Pricing_Info___;


-- Set_Job_Pre_Posting___
--   Method used by Project module
PROCEDURE Set_Job_Pre_Posting___ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   job_id_       IN VARCHAR2,
   activity_seq_ IN NUMBER )
IS
   company_     VARCHAR2(20);
   ordrec_      Public_Rec;
BEGIN
   ordrec_ := Get(order_no_, line_no_, rel_no_, line_item_no_);
   company_ := Site_API.Get_Company(ordrec_.contract);

   -- set pre accounting for customer order line
   Pre_Accounting_API.Set_Project_Code_Part(ordrec_.pre_accounting_id,
      company_, ordrec_.contract, 'M104', job_id_, activity_seq_);
END Set_Job_Pre_Posting___;


-- Validate_Mro_Line___
--   If the supply code of the order line is MRO checks whether the
--   conditions required for this supply code are satisfied.
PROCEDURE Validate_Mro_Line___ (
   part_no_        IN VARCHAR2,
   sales_quantity_ IN NUMBER,
   part_ownership_ IN VARCHAR2 )
IS
   inv_part_exists_      BOOLEAN;
BEGIN
   inv_part_exists_ := Part_Catalog_API.Check_Part_Exists(part_no_);
   IF (inv_part_exists_) THEN
      IF (Part_Catalog_API.Get_Rcpt_Issue_Serial_Track_Db(part_no_) = Fnd_Boolean_API.DB_FALSE) THEN
         Error_SYS.Record_General(lu_name_, 'MRONOTSERIAL: Only Serial handled parts can be used with Supply Code MRO');
      END IF;
   ELSE
      Error_SYS.Record_General(lu_name_, 'MRONOTSERIAL: Only Serial handled parts can be used with Supply Code MRO');
   END IF;

   IF (sales_quantity_ != 1)  THEN
      Error_SYS.Record_General(lu_name_, 'MROWRONGQUANTITY: Only Sales Quantity 1 can be used with Supply Code MRO');
   END IF;

   IF (part_ownership_ != 'CUSTOMER OWNED')  THEN
      Error_SYS.Record_General(lu_name_, 'MRONOTCUSTOMEROWNED: Only Customer Owned parts can be used with Supply Code MRO');
   END IF;
END Validate_Mro_Line___;


-- Check_Qty_From_Repair_Order___
--   Do the external service order validation, regarding the quantity (desired and sales).
PROCEDURE Check_Qty_From_Repair_Order___ (
   demand_code_       IN VARCHAR2,
   demand_order_ref1_ IN VARCHAR2,
   part_no_           IN VARCHAR2 )
IS
BEGIN
   IF (Is_External_Service_Order___(demand_code_, demand_order_ref1_) = Fnd_Boolean_API.DB_TRUE) THEN
      -- IF sales part is serialized part raise the error to avoid quantity been modified.
      -- Otherwise allow the quantity to modify in the CO.
      IF (Part_Catalog_API.Get_Rcpt_Issue_Serial_Track_Db(part_no_) = Fnd_Boolean_API.DB_TRUE) THEN
         Error_SYS.Record_General(lu_name_, 'ERRORORDERQUANTITY: Customer Order created from an External Service Order, Quantity not modifyable.');
      END IF;
   END IF;
END Check_Qty_From_Repair_Order___;


-- Get_Supply_Chain_Defaults___
--   Retrieve default values for supply chain parameters when creating or
--   updating an order line.
PROCEDURE Get_Supply_Chain_Defaults___ (
   newrec_  IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   indrec_  IN     Indicator_Rec,
   oldrec_  IN     CUSTOMER_ORDER_LINE_TAB%ROWTYPE DEFAULT NULL )
IS
   ship_via_code_                CUSTOMER_ORDER_LINE_TAB.ship_via_code%TYPE;
   delivery_leadtime_            CUSTOMER_ORDER_LINE_TAB.delivery_leadtime%TYPE;
   pkg_rec_                      Public_Rec;
   default_ship_via_code_        CUSTOMER_ORDER_LINE_TAB.ship_via_code%TYPE;
   default_delivery_terms_       CUSTOMER_ORDER_LINE_TAB.delivery_terms%TYPE;
   default_del_terms_location_   CUSTOMER_ORDER_LINE_TAB.del_terms_location%TYPE;
   default_delivery_leadtime_    CUSTOMER_ORDER_LINE_TAB.delivery_leadtime%TYPE;
   order_rec_                    CUSTOMER_ORDER_API.Public_Rec;
   distance_                     NUMBER;
   expected_additional_cost_     NUMBER;
   cost_curr_code_               VARCHAR2(3);
   internal_leadtime_            NUMBER;
   agreement_id_                 VARCHAR2(10);
   supplier_ship_via_transit_    CUSTOMER_ORDER_LINE_TAB.supplier_ship_via_transit%TYPE;
   ext_transport_calendar_id_    CUSTOMER_ORDER_LINE_TAB.ext_transport_calendar_id%TYPE;
   default_ext_transport_cal_id_ CUSTOMER_ORDER_LINE_TAB.ext_transport_calendar_id%TYPE;
   default_forward_agent_id_     CUSTOMER_ORDER_LINE_TAB.forward_agent_id%TYPE;
   default_route_id_             CUSTOMER_ORDER_LINE_TAB.route_id%TYPE;
   picking_leadtime_             NUMBER;
   default_picking_leadtime_     NUMBER;
   route_id_                     CUSTOMER_ORDER_LINE_TAB.route_id%TYPE;
   forward_agent_id_             CUSTOMER_ORDER_LINE_TAB.forward_agent_id%TYPE;
   shipment_type_                VARCHAR2(3);
   default_shipment_type_        VARCHAR2(3);
   vendor_no_                    VARCHAR2(20);
   delivery_terms_               CUSTOMER_ORDER_LINE_TAB.delivery_terms%TYPE;
   del_terms_location_           CUSTOMER_ORDER_LINE_TAB.del_terms_location%TYPE;
   ship_addr_no_changed_         VARCHAR2(5) := 'FALSE';
BEGIN
   -- Any values passed in when the line was created should override the default values
   -- This could be the case when the order line is created via the New() method.
   -- Defaults could for example come from a quotation line
   IF (indrec_.ship_via_code) THEN
      ship_via_code_ := newrec_.ship_via_code;
   END IF;
   IF (indrec_.delivery_leadtime) THEN
      delivery_leadtime_ := newrec_.delivery_leadtime;
   END IF;
   IF (indrec_.ext_transport_calendar_id) THEN
      ext_transport_calendar_id_ := newrec_.ext_transport_calendar_id;
   END IF;
   IF (indrec_.supplier_ship_via_transit) THEN
      supplier_ship_via_transit_ := newrec_.supplier_ship_via_transit;
   END IF;
   IF (indrec_.picking_leadtime) THEN
      picking_leadtime_ := newrec_.picking_leadtime;
   END IF;
   IF (indrec_.route_id) THEN
      route_id_ := newrec_.route_id;
   END IF;
   IF (indrec_.forward_agent_id) THEN
      forward_agent_id_ :=  newrec_.forward_agent_id;
   END IF;
   IF (indrec_.shipment_type) THEN
      shipment_type_ := newrec_.shipment_type;
   END IF;
   IF (indrec_.vendor_no) THEN
      vendor_no_ := newrec_.vendor_no;
   END IF;
   IF (indrec_.delivery_terms) THEN
      delivery_terms_ := newrec_.delivery_terms;
   END IF;
   IF (indrec_.del_terms_location) THEN
      del_terms_location_ := newrec_.del_terms_location;
   END IF;

   IF (ship_via_code_ IS NOT NULL) THEN
      IF ((delivery_leadtime_ IS NULL) OR (supplier_ship_via_transit_ IS NULL) OR (picking_leadtime_ IS NULL) OR
          (shipment_type_ IS NULL) OR (route_id_ IS NULL) OR (delivery_terms_ IS NULL) OR (del_terms_location_ IS NULL)) THEN
         newrec_.ship_via_code := ship_via_code_;
         -- Retrive default delivery leadtime, picking leadtime and supplier_ship_via_transit for the
         -- specified ship via code
         Cust_Order_Leadtime_Util_API.Get_Ship_Via_Values(newrec_.route_id,
                                                          newrec_.forward_agent_id,
                                                          newrec_.delivery_leadtime,
                                                          newrec_.ext_transport_calendar_id,
                                                          distance_,
                                                          expected_additional_cost_,
                                                          cost_curr_code_,
                                                          internal_leadtime_,
                                                          newrec_.supplier_ship_via_transit,
                                                          newrec_.freight_map_id,
                                                          newrec_.zone_id,
                                                          newrec_.picking_leadtime,
                                                          newrec_.shipment_type,
                                                          newrec_.delivery_terms,
                                                          newrec_.del_terms_location,
                                                          newrec_.contract,
                                                          newrec_.deliver_to_customer_no,
                                                          newrec_.ship_addr_no,
                                                          newrec_.addr_flag,
                                                          newrec_.part_no,
                                                          newrec_.supply_code,
                                                          newrec_.vendor_no,
                                                          newrec_.ship_via_code,
                                                          NULL,
                                                          'TRUE');
         -- There can be exist records which has no delivery terms or delivery term location in supply chain matrix.
         IF newrec_.delivery_terms IS NULL THEN
            order_rec_ := CUSTOMER_ORDER_API.Get(newrec_.order_no);
            newrec_.delivery_terms := order_rec_.delivery_terms;
            newrec_.del_terms_location := order_rec_.del_terms_location;
         END IF;

         IF (delivery_leadtime_ IS NOT NULL) THEN
            -- IF a delivery leadtime was sent in the attribute string this should
            -- override the default value
            newrec_.delivery_leadtime := delivery_leadtime_;
         END IF;
         IF (supplier_ship_via_transit_ IS NOT NULL) THEN
            -- IF a value for supplier ship via transit was sent in this should override the default
            newrec_.supplier_ship_via_transit := supplier_ship_via_transit_;
         END IF;
         IF (ext_transport_calendar_id_ IS NOT NULL) THEN
            -- IF a external transport calendar was sent in the attribute string this should override the default
            newrec_.ext_transport_calendar_id := ext_transport_calendar_id_;
         END IF;
         IF (picking_leadtime_ IS NOT NULL) THEN
            -- IF a picking leadtime was sent in the attribute string this should override the default value
            newrec_.picking_leadtime := picking_leadtime_;
         END IF;
         IF (route_id_ IS NOT NULL) THEN
             -- IF route_id_ was sent in the attribute string this should override the default value
            newrec_.route_id := route_id_;
            newrec_.forward_agent_id := NVL(Delivery_Route_API.Get_Forward_Agent_Id(route_id_), forward_agent_id_);
      END IF;
         IF (forward_agent_id_ IS NOT NULL) THEN
            newrec_.forward_agent_id := forward_agent_id_;
         END IF;
         IF (shipment_type_ IS NOT NULL) THEN
            -- IF a shipment type was sent in the attribute string this should override the default value
            newrec_.shipment_type := shipment_type_;
         END IF;
         IF (delivery_terms_ IS NOT NULL) THEN
            -- IF a delivery term was sent in the attribute string this should override the default value
            newrec_.delivery_terms := delivery_terms_;
         END IF;
         IF (del_terms_location_ IS NOT NULL) THEN
            -- IF a del term location was sent in the attribute string this should override the default value
            newrec_.del_terms_location := del_terms_location_;
         END IF;
      END IF;
   ELSE
      -- Retrieve customer agrement for the part if any
      order_rec_ := CUSTOMER_ORDER_API.Get(newrec_.order_no);

      IF (newrec_.price_source = 'AGREEMENT') THEN
         agreement_id_ := newrec_.price_source_id;
      ELSE
         agreement_id_ := NULL;
      END IF;

      IF (newrec_.line_item_no > 0)  THEN
         -- The current line is a package component line, retrieve defaults from package header
         pkg_rec_                      := Get(newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1);
         default_ship_via_code_        := pkg_rec_.ship_via_code;
         default_delivery_terms_       := pkg_rec_.delivery_terms;
         default_del_terms_location_   := pkg_rec_.del_terms_location;
         default_delivery_leadtime_    := pkg_rec_.delivery_leadtime;
         default_ext_transport_cal_id_ := pkg_rec_.ext_transport_calendar_id;
         default_route_id_             := pkg_rec_.route_id;
         default_forward_agent_id_     := pkg_rec_.forward_agent_id;
         default_picking_leadtime_     := pkg_rec_.picking_leadtime;
         default_shipment_type_        := pkg_rec_.shipment_type;
      ELSE
         IF (newrec_.addr_flag = 'Y' AND newrec_.default_addr_flag = 'N') THEN
            default_ship_via_code_        := NVL(newrec_.ship_via_code, order_rec_.ship_via_code);
            default_delivery_terms_       := NVL(newrec_.delivery_terms, order_rec_.delivery_terms);
            default_del_terms_location_   := NVL(newrec_.del_terms_location, order_rec_.del_terms_location);
            default_delivery_leadtime_    := NVL(newrec_.delivery_leadtime,order_rec_.delivery_leadtime);
            default_ext_transport_cal_id_ := NVL(newrec_.ext_transport_calendar_id, order_rec_.ext_transport_calendar_id);
            default_route_id_             := NVL(newrec_.route_id, order_rec_.route_id);
            default_forward_agent_id_     := NVL(newrec_.forward_agent_id, order_rec_.forward_agent_id);
            default_picking_leadtime_     := NVL(newrec_.picking_leadtime, order_rec_.picking_leadtime);
            default_shipment_type_        := NVL(newrec_.shipment_type, order_rec_.shipment_type);
         ELSE
            -- Retrieve defaults from order header
            default_ship_via_code_        := order_rec_.ship_via_code;
            default_delivery_terms_       := order_rec_.delivery_terms;
            default_del_terms_location_   := order_rec_.del_terms_location;
            default_delivery_leadtime_    := order_rec_.delivery_leadtime;
            default_ext_transport_cal_id_ := order_rec_.ext_transport_calendar_id;
            default_route_id_             := order_rec_.route_id;
            default_forward_agent_id_     := order_rec_.forward_agent_id;
            default_picking_leadtime_     := order_rec_.picking_leadtime;
            default_shipment_type_        := order_rec_.shipment_type;
         END IF;
      END IF;

      IF (NVL(oldrec_.ship_addr_no, newrec_.ship_addr_no) != newrec_.ship_addr_no) THEN
         -- Set TRUE only for delivery address update scenario.
         ship_addr_no_changed_         := 'TRUE';
         default_delivery_leadtime_    := NVL(newrec_.delivery_leadtime, default_delivery_leadtime_);
         default_picking_leadtime_     := NVL(newrec_.picking_leadtime, default_picking_leadtime_);
      END IF;

      newrec_.ship_via_code             := NULL;
      newrec_.delivery_terms            := NULL;
      newrec_.del_terms_location        := NULL;
      newrec_.supplier_ship_via_transit := NULL;
      newrec_.delivery_leadtime         := NULL;
      newrec_.ext_transport_calendar_id := NULL;
      newrec_.route_id                  := NULL;
      newrec_.forward_agent_id          := NULL;
      newrec_.picking_leadtime          := NULL;
      newrec_.shipment_type             := NULL;

      -- Get supply chain defaults
      -- Replaced with the deliver_to_customer_no
      Cust_Order_Leadtime_Util_API.Get_Supply_Chain_Defaults(newrec_.route_id,
                                                             newrec_.forward_agent_id,
                                                             newrec_.ship_via_code,
                                                             newrec_.delivery_terms,
                                                             newrec_.del_terms_location,
                                                             newrec_.supplier_ship_via_transit,
                                                             newrec_.delivery_leadtime,
                                                             newrec_.ext_transport_calendar_id,
                                                             newrec_.default_addr_flag,
                                                             newrec_.freight_map_id,
                                                             newrec_.zone_id,
                                                             newrec_.picking_leadtime,
                                                             newrec_.shipment_type,
                                                             newrec_.contract,
                                                             newrec_.deliver_to_customer_no,
                                                             newrec_.ship_addr_no,
                                                             newrec_.addr_flag,
                                                             newrec_.part_no,
                                                             newrec_.supply_code,
                                                             newrec_.vendor_no,
                                                             agreement_id_,
                                                             default_ship_via_code_,
                                                             default_delivery_terms_,
                                                             default_del_terms_location_,
                                                             default_delivery_leadtime_,
                                                             default_ext_transport_cal_id_, default_route_id_, default_forward_agent_id_,
                                                             default_picking_leadtime_, default_shipment_type_, order_rec_.vendor_no, order_rec_.ship_addr_no,
                                                             'FALSE', ship_addr_no_changed_);

      IF  (supplier_ship_via_transit_ IS NOT NULL) THEN
         -- IF a value for supplier ship via transit was sent in this should override the default
         newrec_.supplier_ship_via_transit := supplier_ship_via_transit_;
      END IF;
      IF (del_terms_location_ IS NOT NULL) THEN
         -- If a del term location was sent in the attribute string this should override the default value.
         newrec_.del_terms_location := del_terms_location_;
      END IF;
   END IF;

   IF (newrec_.supplier_ship_via_transit IS NOT NULL) THEN
      newrec_.supplier_ship_via_transit_desc := Mpccom_Ship_Via_API.Get_Description(newrec_.supplier_ship_via_transit, order_rec_.language_code);
   ELSE
      newrec_.supplier_ship_via_transit_desc := NULL;
   END IF;
END Get_Supply_Chain_Defaults___;


-- Get_Def_Supplier_Ship_Via___
--   Method fetches the default supplier_ship_via_transit and
PROCEDURE Get_Def_Supplier_Ship_Via___ (
   supplier_ship_via_transit_     OUT VARCHAR2,
   supplier_ship_via_transit_dsc_ OUT VARCHAR2,
   vendor_no_                     IN  VARCHAR2,
   contract_                      IN  VARCHAR2,
   supply_site_                   IN  VARCHAR2,
   part_no_                       IN  VARCHAR2,
   supply_code_db_                IN  VARCHAR2,
   language_code_                 IN  VARCHAR2 )
IS
   supply_chain_part_group_         VARCHAR2(20);
   default_supplier_addr_no_        SUPPLIER_INFO_ADDRESS_PUBLIC.address_id%TYPE;
   default_supplier_ship_via_       VARCHAR2(3);
BEGIN
   -- fetching default supplier document address and default supplier ship via code
   $IF (Component_Purch_SYS.INSTALLED)$THEN
      Supplier_Address_API.Get_Addr_Ship_Via(default_supplier_addr_no_, default_supplier_ship_via_, vendor_no_);
   $END

   supply_chain_part_group_ := Inventory_Part_API.Get_Supply_Chain_Part_Group(contract_, part_no_);

   IF (supply_code_db_ = 'PT') THEN
      $IF (Component_Purch_SYS.INSTALLED)$THEN
         supplier_ship_via_transit_ := Supp_Addr_Part_Leadtime_API.Get_Default_Ship_Via_Code(vendor_no_, default_supplier_addr_no_,
                                                                                             supply_chain_part_group_, contract_);
      $ELSE
         NULL;
      $END
   ELSE -- IPT
      supplier_ship_via_transit_ := Site_To_Site_Part_Leadtime_API.Get_Default_Ship_Via_Code(contract_,
                                            supply_site_, supply_chain_part_group_);
   END IF;
   IF (supplier_ship_via_transit_ IS NULL) THEN
      IF (supply_code_db_ = 'PT') THEN
         $IF (Component_Purch_SYS.INSTALLED)$THEN
            supplier_ship_via_transit_ := Supplier_Address_Leadtime_API.Get_Default_Ship_Via_Code(vendor_no_, default_supplier_addr_no_, contract_);
         $ELSE
            NULL;
         $END
      ELSE -- IPT
         supplier_ship_via_transit_ := Site_To_Site_Leadtime_API.Get_Default_Ship_Via_Code(contract_,
                                               supply_site_);
      END IF;
   END IF;

   -- if still NULL fetch new ship via from supplier address
   IF (supplier_ship_via_transit_ IS NULL) THEN
      supplier_ship_via_transit_ := default_supplier_ship_via_;
   END IF;

   -- fetch the description
   supplier_ship_via_transit_dsc_ := Mpccom_Ship_Via_API.Get_Description(supplier_ship_via_transit_, language_code_);
END Get_Def_Supplier_Ship_Via___;


-- Get_Activity_Info___
--   Calculates and Returns costs and progress of the customer order line.
PROCEDURE Get_Activity_Info___ (
   planned_cost_elements_     OUT Mpccom_Accounting_API.Project_Cost_Element_Tab,
   committed_cost_elements_   OUT Mpccom_Accounting_API.Project_Cost_Element_Tab,
   used_cost_elements_        OUT Mpccom_Accounting_API.Project_Cost_Element_Tab,
   object_progress_           OUT NUMBER,
   rec_                       IN  CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
   order_status_                 VARCHAR2(20);   
   reserved_committed_elements_  Mpccom_Accounting_API.Project_Cost_Element_Tab;
   qty_due_                      NUMBER:=0;
   sales_oh_cost_elements_       Mpccom_Accounting_API.Project_Cost_Element_Tab;
   sales_qty_                    NUMBER;
   inventory_part_               BOOLEAN;
   active_forecast_part_         VARCHAR2(5):= 'FALSE';
   $IF (Component_Proj_SYS.INSTALLED)$THEN
      activity_rec_        Activity_API.Public_Rec;
   $END
BEGIN
   -- For rental lines cost reporting is prevented as a temporary measure.
   IF (Is_External_Service_Order___(rec_.demand_code, rec_.demand_order_ref1) = 'TRUE' OR rec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
      RETURN;
   END IF;

   IF (rec_.demand_code = Order_Supply_Type_API.DB_REPLACEMENT_CUSTOMER_ORDER) THEN
      RETURN;
   END IF;

   object_progress_ := Get_Progress_Info___ (rec_.order_no,
                                             rec_.line_no,
                                             rec_.rel_no,
                                             rec_.line_item_no,
                                             rec_.rowstate);

   $IF (Component_Proj_SYS.INSTALLED)$THEN
      activity_rec_ := Activity_API.Get(rec_.activity_seq);      
      inventory_part_   := Inventory_Part_API.Check_Exist(rec_.contract, rec_.part_no);
      order_status_     := CUSTOMER_ORDER_API.Get_Objstate(rec_.order_no);

      $IF (Component_Massch_SYS.INSTALLED) $THEN
         active_forecast_part_ := Level_1_Part_API.Check_Part_Active_In_Activity(rec_.contract,
                                                                                      rec_.part_no,
                                                                                      activity_rec_.project_Id,
                                                                                      rec_.activity_seq);
      $END
      IF ((order_status_ != 'Cancelled') AND
          (rec_.rowstate != 'Cancelled') AND
          (active_forecast_part_ = 'FALSE') AND
          (rec_.part_ownership NOT IN ('CUSTOMER OWNED', 'SUPPLIER LOANED'))) THEN
         planned_cost_elements_ := Get_Activity_Planned_Cost___(rec_, inventory_part_);
      END IF;

      -- PI: Project Inventory, PJD: Project Deliverables, PRJ: Project, SO: Shop Order, ND: Not Decided, PT: Purch Order Trans, IPT:Int Purch Trans
      IF ((rec_.supply_code NOT IN ('PI', 'PJD', 'PRJ', 'SO', 'ND', 'PT', 'IPT', 'DOP')) AND (activity_rec_.rowstate <> 'Planned'))THEN
         -- Get project cost elements for committed cost

         IF ((order_status_ IN ('Released', 'Reserved', 'Picked', 'PartiallyDelivered'))
               AND (rec_.rowstate NOT IN ('Delivered', 'Cancelled', 'Invoiced')) AND (rec_.supply_code NOT IN ('PD', 'IPD'))) THEN
            IF (inventory_part_)THEN
            -- For Inventory Parts
               IF rec_.part_ownership NOT IN ('CUSTOMER OWNED', 'SUPPLIER LOANED') THEN
                  qty_due_ := (rec_.revised_qty_due - rec_.qty_assigned - (rec_.qty_shipped - rec_.qty_returned));

                  IF (qty_due_ > 0) THEN
                     -- Get Committed cost for unreserved, yet to be delivered parts
                     committed_cost_elements_ := Invent_Proj_Cost_Manager_API.Get_Project_Cost_Elements(
                                                                                    contract_            => rec_.contract,
                                                                                    part_no_             => rec_.part_no,
                                                                                    source_ref_type_db_  => 'CUST ORDER',
                                                                                    source_ref1_         => rec_.order_no,
                                                                                    source_ref2_         => rec_.line_no,
                                                                                    source_ref3_         => rec_.rel_no,
                                                                                    source_ref4_         => rec_.line_item_no,
                                                                                    quantity_            => qty_due_,
                                                                                    condition_code_      => rec_.condition_code,
                                                                                    part_related_        => TRUE );
                  END IF;

                  -- Get Committed cost for reserved quantity
                  IF (rec_.qty_assigned > 0) THEN
                     reserved_committed_elements_ := Invent_Proj_Cost_Manager_API.Get_Elements_For_Reservations(
                                                                                    source_ref1_         => rec_.order_no,
                                                                                    source_ref2_         => rec_.line_no,
                                                                                    source_ref3_         => rec_.rel_no,
                                                                                    source_ref4_         => rec_.line_item_no,
                                                                                    source_ref_type_db_  => 'CUST ORDER');
                     committed_cost_elements_ := Mpccom_Accounting_API.Get_Merged_Cost_Element_Tab(committed_cost_elements_,
                                                                                                   reserved_committed_elements_);
                  END IF;
               END IF;
            ELSE -- For Non Inventory Parts
               qty_due_                 := rec_.buy_qty_due - rec_.qty_shipped;
               committed_cost_elements_ := Get_Elements_Non_Inv___(rec_, qty_due_);
            END IF;
         END IF;

         -- Get project cost elements for Used cost
         IF ((rec_.rowstate IN ('PartiallyDelivered', 'Delivered', 'Invoiced')) AND
             ((rec_.supply_code IN ('IO', 'NO')) OR
             (rec_.supply_code IN ('PD', 'IPD') AND inventory_part_) OR
             ((NOT inventory_part_) AND (rec_.supply_code = 'IPD') AND
              (Site_API.Get_Company(rec_.contract) = Site_API.Get_Company(rec_.supply_site))))) THEN
            used_cost_elements_ := Inventory_Transaction_Hist_API.Get_Activity_Costs_By_Status(
                                       source_ref1_   => rec_.order_no,
                                       source_ref2_   => rec_.line_no,
                                       source_ref3_   => rec_.rel_no,
                                       source_ref4_   => rec_.line_item_no,
                                       status_        => 'NOT TRANSFERRED',
                                       source_ref_type_db_ => 'CUST ORDER');
         END IF;
      END IF;
      -- Get project cost elements for Commited Cost, Sales OH
      -- Get Committed project cost elements for Sales OH
      IF ((order_status_ IN ('Released', 'Reserved', 'Picked', 'PartiallyDelivered'))
            AND (rec_.rowstate NOT IN ('Delivered', 'Cancelled','Invoiced'))
            AND (inventory_part_)
            AND (rec_.part_ownership NOT IN ('CUSTOMER OWNED', 'SUPPLIER LOANED'))) THEN

         sales_qty_ := (rec_.revised_qty_due - (rec_.qty_shipped - rec_.qty_returned));

         IF (sales_qty_ > 0) THEN
            IF (rec_.charged_item = 'CHARGED ITEM') THEN
               sales_oh_cost_elements_ := Invent_Proj_Cost_Manager_API.Get_Elements_For_Sales_Oh(
                                                contract_        => rec_.contract,
                                                part_no_         => rec_.part_no,
                                                oe_order_no_     => rec_.order_no,
                                                oe_line_no_      => rec_.line_no,
                                                oe_rel_no_       => rec_.rel_no,
                                                oe_line_item_no_ => rec_.line_item_no,
                                                sales_qty_       => sales_qty_);
            END IF;
            -- PT: Purch Order Trans
            IF (rec_.supply_code IN ('PT', 'IPT', 'ND', 'PD', 'PI', 'PJD', 'IPD', 'DOP')) THEN
               committed_cost_elements_ := sales_oh_cost_elements_;
            ELSE
               committed_cost_elements_ := Mpccom_Accounting_API.Get_Merged_Cost_Element_Tab(committed_cost_elements_,
                                                                                             sales_oh_cost_elements_);
            END IF;
         END IF;
      END IF;

      -- Get project cost elements for Used Cost, Sales OH
      IF (rec_.rowstate IN ('PartiallyDelivered', 'Delivered', 'Invoiced') AND
          rec_.supply_code IN ('SO', 'PT', 'IPT', 'PI', 'PJD', 'DOP') AND (inventory_part_)) THEN
         used_cost_elements_ := Inventory_Transaction_Hist_API.Get_Activity_Costs_By_Status(
                                    source_ref1_   => rec_.order_no,
                                    source_ref2_   => rec_.line_no,
                                    source_ref3_   => rec_.rel_no,
                                    source_ref4_   => rec_.line_item_no,
                                    status_        => 'NOT TRANSFERRED',
                                    source_ref_type_db_ => 'CUST ORDER',
                                    event_code_    => 'SALES-OH');
      END IF;
   $END
END Get_Activity_Info___;


-- Validate_Proj_Connect___
--   Validate the project connection
PROCEDURE Validate_Proj_Connect___ (
   project_id_               OUT    VARCHAR2,
   demand_code_db_           IN OUT VARCHAR2,
   supply_code_db_           IN OUT VARCHAR2,
   order_no_                 IN     VARCHAR2,
   contract_                 IN     VARCHAR2,
   rowstate_                 IN     VARCHAR2,
   consignment_stock_db_     IN     VARCHAR2,
   qty_on_order_             IN     NUMBER,
   new_activity_seq_         IN     NUMBER,
   old_activity_seq_         IN     NUMBER,
   planned_ship_date_        IN     DATE,
   catalog_no_               IN     VARCHAR2,
   new_pkg_component_line_   IN     BOOLEAN,
   catalog_type_             IN     VARCHAR2 )
IS
   activity_site_exist_    NUMBER;
   early_start_            DATE;
   early_finish_           DATE;
   activity_state_         VARCHAR2(30);
   order_project_id_       VARCHAR2(10);
   error_msg_              VARCHAR2(2000);
   material_allocation_    VARCHAR2(25);
   proj_unique_sale_       VARCHAR2(5);
   header_rec_             CUSTOMER_ORDER_API.Public_Rec;
   $IF (Component_Proj_SYS.INSTALLED)$THEN
      project_rec_         Project_API.Public_Rec;
      activity_rec_        Activity_API.Public_Rec;
   $END   
BEGIN
   IF (old_activity_seq_ IS NOT NULL AND old_activity_seq_ > 0) THEN
      Error_Sys.Record_General(lu_name_, 'COLCONNEXIST: Project connection already exists');
   END IF;

   header_rec_ := Customer_Order_API.Get(order_no_);
   $IF (Component_Proj_SYS.INSTALLED)$THEN
      activity_rec_        := Activity_API.Get(new_activity_seq_);      
      project_id_          := activity_rec_.project_id;
      project_rec_         := Project_API.Get(project_id_);
      activity_site_exist_ := Project_Site_API.Project_Site_Exist(project_id_, contract_);
      material_allocation_ := project_rec_.material_allocation;
      early_start_         := activity_rec_.early_start;
      early_finish_        := activity_rec_.early_finish;
      activity_state_      := activity_rec_.rowstate;
   
      IF (activity_state_ != 'Released') THEN
         IF (header_rec_.rowstate = 'Released') THEN   
            Error_Sys.Record_General(lu_name_, 'ACTIVITYNOTRELEASED: Activity :P1 should be in the released state in order to be able to connect to a released customer order.', new_activity_seq_);
         END IF;
      END IF;

      IF (activity_state_ NOT IN ('Released', 'Planned') AND NOT(demand_code_db_ = Order_Supply_Type_API.DB_REPLACEMENT_CUSTOMER_ORDER AND activity_state_ NOT IN ('Closed', 'Cancelled')) ) THEN
         Error_SYS.Record_General(lu_name_, 'MATRACTNOTRELEASED: Cannot connect the object. The activity must be Planned or Released.');
      END IF;

      IF activity_site_exist_ = 0 THEN
         Error_SYS.Record_General(lu_name_,'COLSITENOTEXIS: Site :P1 does not exist as project site ', contract_);
      END IF;

      IF (Trunc(planned_ship_date_) NOT BETWEEN Trunc(early_start_) AND Trunc(early_finish_) AND (catalog_type_ != 'KOMP')) THEN
         Client_SYS.Add_Info('CustomerOrderLine','COLSHIPDATE: The planned ship date is not within life span of the connected project activity :P1.  '||
                             'Please review the dates',new_activity_seq_);
      END IF;

      proj_unique_sale_ := project_rec_.proj_unique_sale;

      IF (proj_unique_sale_ = 'TRUE') THEN
         IF (Diff_Proj_Exist___ ( order_no_, project_id_ )) THEN
            Error_SYS.Record_General(lu_name_,'DIFFPROJEXIST: Project :P1 is set for Project Unique Billing and cannot be connected to a customer order with lines connected to any other projects.', project_id_);
         END IF;
      END IF;
   $END

   IF (rowstate_ = 'Reserved') THEN
      IF (material_allocation_ = 'WITHIN_ACTIVITY') THEN
         Error_Sys.Record_General(lu_name_, 'COLRESMATALLOCCON: Project connection can only be made for a reserved customer order line/s when material allocation is within project.');
      END IF;
   ELSIF (rowstate_ != 'Released') THEN
      Error_Sys.Record_General(lu_name_, 'COLWRONGSTATUS: Customer order line must have status Released to make a project connection.');
   END IF;

   IF (supply_code_db_ NOT IN ('IO', 'NO', 'PD', 'IPD', 'PI', 'PJD', 'PKG', 'SO', 'PT', 'IPT', 'ND', 'DOP', 'SEO', 'PRJ')) THEN
      error_msg_ := '[' ||Order_Supply_Type_API.Decode('IO') || '], [' ||Order_Supply_Type_API.Decode('NO')|| '], [' ||Order_Supply_Type_API.Decode('PD')|| '], [' ||Order_Supply_Type_API.Decode('IPD')||'], [' ||Order_Supply_Type_API.Decode('PI')||'], [' ||Order_Supply_Type_API.Decode('PJD')||'], [' ||Order_Supply_Type_API.Decode('PKG')||'] , [' ||Order_Supply_Type_API.Decode('ND')|| '], [' ||Order_Supply_Type_API.Decode('PT')||'] or [' || Order_Supply_Type_API.Decode('IPT') || '] or [' || Order_Supply_Type_API.Decode('DOP') || '] or [' || Order_Supply_Type_API.Decode('SEO') || '] or [' || Order_Supply_Type_API.Decode('PRJ') || ']';
      Error_SYS.Record_General(lu_name_, 'COLDEMANDCODE: Project activity connections are allowed only for supply code :P1.', error_msg_);
   END IF;

   IF (supply_code_db_ IN ('IO','PS') AND (qty_on_order_ > 0 )) THEN
      Error_SYS.Record_General(lu_name_, 'COLUMBRELLAEXH1: Manually pegged order lines cannot have project connections');
   END IF;

   IF (consignment_stock_db_ = 'CONSIGNMENT STOCK') THEN
      Error_SYS.Record_General(lu_name_, 'COLCONSTOCK: Customer order lines for consignment stock delivery are not allowed to have project connections');
   END IF;

   order_project_id_ := header_rec_.project_id;

   IF ((order_project_id_ IS NOT NULL) AND (order_project_id_ != project_id_))  THEN
      Error_SYS.Record_General(lu_name_, 'COLPROJEXITS: It is not allowed to connect the order line to project [:P1], since the Customer Order Header is already connected to project [:P2].',project_id_,order_project_id_);
   END IF;

   IF ((supply_code_db_ NOT IN ('PD','IPD', 'SO', 'PT', 'ND', 'IPT', 'DOP','SEO')) AND (NOT new_pkg_component_line_)) THEN
      IF ((catalog_type_ ='INV') OR (catalog_type_ = 'KOMP' AND supply_code_db_ = 'IO')) THEN
         supply_code_db_ := 'PI';
      ELSIF ((catalog_type_ ='NON') OR (catalog_type_ = 'KOMP' AND supply_code_db_ = 'NO')) THEN
         supply_code_db_ := 'PRJ';
      END IF;
   END IF;
   IF (demand_code_db_ IS NULL) THEN
      demand_code_db_ := 'PI';
   END IF;
END Validate_Proj_Connect___;


-- Validate_Proj_Disconnect___
--   Validate the project disconnection.
PROCEDURE Validate_Proj_Disconnect___ (
   newrec_ IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
   catalog_type_          VARCHAR2(16);
   material_allocation_   VARCHAR2(25);
   co_state_              VARCHAR2(20);
   header_rec_            Customer_Order_API.Public_Rec;
BEGIN
   header_rec_ := Customer_Order_API.Get(newrec_.order_no); 
   co_state_ := header_rec_.rowstate;
   IF ((co_state_ = 'Released') AND  ((newrec_.supply_code = 'DOP' AND newrec_.qty_on_order != 0))) THEN
      Error_SYS.Record_General(lu_name_,'SUPPLYOBJCREATED: Disconnecting the project from the customer order line is not allowed when supply objects have been created.');
   END IF;

   IF (header_rec_.project_Id IS NOT NULL) AND (co_state_ != 'Planned') AND  (newrec_.rowstate != 'Cancelled') THEN
      Error_SYS.Record_General(lu_name_,'DISCONPROJNOTALWD: Disconnecting lines from project is not allowed after releasing a customer order with a project specified in the customer order references tab.');
   END IF;

   $IF (Component_Proj_SYS.INSTALLED) $THEN
      material_allocation_ := Project_API.Get_Material_Allocation_Db(newrec_.project_id);
   $END

   IF ((newrec_.rowstate = 'Reserved') AND (material_allocation_ = 'WITHIN_PROJECT')) THEN
      NULL;
   ELSIF (newrec_.rowstate NOT IN ('Released', 'Cancelled')) THEN
      Error_Sys.Record_General(lu_name_, 'COLWORNGSTATUS: Customer Order line should have status Released to disconnect from project');
   END IF;

   $IF (Component_Deford_SYS.INSTALLED) $THEN
      IF (Def_Contract_Order_Item_API.CO_Line_On_Defense_Contract(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no)) THEN
         Error_SYS.Record_General(lu_name_,'DISCONPROJDEFORD: The line is connected to a defense contract order item. Disconnecting the line from the project is not allowed.');
      END IF;      
   $END
   
   IF newrec_.supply_code IN ('PI', 'PRJ', 'PJD') THEN
      catalog_type_:= Sales_Part_API.Get_Catalog_Type_Db(newrec_.contract, newrec_.catalog_no);

      IF (catalog_type_ ='INV') THEN
         newrec_.supply_code := 'IO';
      ELSIF (catalog_type_ ='NON') THEN
         newrec_.supply_code := 'NO';
      END IF;
   END IF;

   newrec_.project_id := NULL;
   IF (newrec_.demand_code NOT IN ('PO', 'IPT', 'IPD', 'IPT_RO', 'DO', 'CQ')) THEN
      newrec_.demand_code := NULL;
   END IF;
END Validate_Proj_Disconnect___;


-- Handle_Activity_Seq___
--   Handle the pre-posting when project connection and disconnection made.
PROCEDURE Handle_Activity_Seq___ (
   rec_              IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   old_activity_seq_ IN NUMBER )
IS
   system_ctrl_connection_       VARCHAR2(5) := 'TRUE';
   object_progress_              NUMBER;
   company_                      VARCHAR2(100);
   proj_code_value_              VARCHAR2(30);
   distr_proj_code_value_        VARCHAR2(30);
   committed_cost_elements_      Mpccom_Accounting_API.Project_Cost_Element_Tab;
   used_cost_elements_           Mpccom_Accounting_API.Project_Cost_Element_Tab;
   empty_tab_                    Mpccom_Accounting_API.Project_Cost_Element_Tab;
   planned_cost_elements_        Mpccom_Accounting_API.Project_Cost_Element_Tab;
   po_project_id_                VARCHAR2(20);
   transaction_currency_code_    VARCHAR2(3);
   base_to_trans_currency_rate_  NUMBER;
   inventory_part_               BOOLEAN;
   base_currency_code_           VARCHAR2(3);
   base_currency_type_           VARCHAR2(10);
   
   attributes_                   Public_Declarations_API.PROJ_Project_Conn_Attr_Type;
BEGIN
   

   company_ := Site_API.Get_Company(rec_.contract);
   Pre_Accounting_API.Get_Project_Code_Value(proj_code_value_,distr_proj_code_value_,company_,rec_.pre_accounting_id);
   IF proj_code_value_ IS NOT NULL AND proj_code_value_ != rec_.project_id THEN
      Error_SYS.Record_General(lu_name_, 'PROJECTCODEPARTEXIST: It is not allowed to connect an object with existing preposting on the Project code part ');
   END IF;

   $IF (Component_Purch_SYS.INSTALLED) $THEN
      -- IF incoming customer order
      IF (rec_.demand_code IN ('IPT', 'IPD', 'IPT_RO')) THEN
         po_project_id_ := Purchase_Order_Line_API.Get_Project_Id (rec_.demand_order_ref1,
                                                                   rec_.demand_order_ref2,
                                                                   rec_.demand_order_ref3);
         IF (NVL(po_project_id_, Database_Sys.String_Null_) = rec_.project_id) THEN
            Error_SYS.Record_General(lu_name_, 'SAMEDEMANDSITEPROJECT: Connecting the incoming Customer Order line to the same project as the demand, will result in the planned cost being added twice to the project. This operation is not allowed.');
         END IF;
      END IF;
   $END

   -- Make a new project connection.
   $IF (Component_Proj_SYS.INSTALLED) $THEN
      IF (rec_.supply_code IN ('IPT', 'IPD', 'SO', 'IO')) THEN -- We need to consider demand code 'IPT', 'IPD', 'SO' and 'IO'.
         attributes_.include_in_ev := 'TRUE';
      ELSE
         attributes_.include_in_ev := 'FALSE';
      END IF;
   
      -- Get the pre posting details.
      IF NOT((rec_.line_item_no > 0) OR (rec_.demand_code = 'WO' OR rec_.demand_code = 'PO')) THEN
         system_ctrl_connection_ := 'FALSE';
      END IF;

      IF ( rec_.demand_code <> 'WO' ) THEN
         Get_Activity_Info___(planned_cost_elements_,
                              committed_cost_elements_,
                              used_cost_elements_,
                              object_progress_,
                              rec_);
      END IF;
      -- PT: Purch Order Trans, PD: Purch Order Dir, IPT: Int Purch Trans, IPD: Int Purch Dir
      IF (rec_.supply_code IN ('PT', 'PD', 'IPT', 'IPD')) THEN
         inventory_part_   := Inventory_Part_API.Check_Exist(contract_ => rec_.contract,
                                                             part_no_  => rec_.part_no );
         IF (inventory_part_ = FALSE) THEN
            DECLARE
               project_id_ project_tab.Project_id%TYPE;
            BEGIN
               $IF (Component_Purch_SYS.INSTALLED) $THEN   
                  transaction_currency_code_ := Purchase_Part_Supplier_API.Get_Currency_Code (contract_     => rec_.contract,
                                                                                              part_no_      => rec_.purchase_part_no,
                                                                                              vendor_no_    => rec_.vendor_no);
               $END
               project_id_                := Activity_API.Get_Project_Id (activity_seq_ => rec_.activity_seq );
               base_currency_type_        := Project_API.Get_Currency_Type (project_id_, company_);
            END;

            IF (transaction_currency_code_ IS NOT NULL) THEN
               base_currency_code_ := Company_Finance_API.Get_Currency_Code(company_);
               Currency_Rate_API.Get_Project_Currency_Rate (base_to_trans_currency_rate_,
                                                            company_,
                                                            transaction_currency_code_,
                                                            base_currency_code_,
                                                            base_currency_type_,
                                                            Site_API.Get_Site_Date(rec_.contract) );
            END IF;
         END IF;
      END IF;

      Invent_Proj_Cost_Manager_API.Fill_Project_Cost_Element_Tmp( planned_cost_elements_,
                                                                  empty_tab_,
                                                                  committed_cost_elements_,
                                                                  used_cost_elements_ );
      DECLARE
         activity_info_tab_          Public_Declarations_API.PROJ_Project_Conn_Cost_Tab;
         activity_revenue_info_tab_  Public_Declarations_API.PROJ_Project_Conn_Revenue_Tab;
         count_                      PLS_INTEGER;
         transaction_currency_code_  VARCHAR2(3);
         transaction_currency_rate_  NUMBER;

         CURSOR get_project_cost_elements IS
            SELECT project_cost_element,
                   SUM(planned_amount)   planned_amount,
                   SUM(planned_hours)    planned_hours,
                   SUM(committed_amount) committed_amount,
                   SUM(used_amount)      used_amount
            FROM project_cost_element_tmp
            GROUP BY project_cost_element;
      BEGIN
         count_                     := activity_info_tab_.COUNT;
         transaction_currency_code_ := transaction_currency_code_;
         transaction_currency_rate_ := base_to_trans_currency_rate_;

         IF (rec_.demand_code NOT IN (Order_Supply_Type_API.DB_REPLACEMENT_CUSTOMER_ORDER,
                                      Order_Supply_Type_API.DB_INT_PURCH_REPLACEMENT_ORDER)) THEN
            FOR proj_cost_element_rec_ IN get_project_cost_elements LOOP
               activity_info_tab_(count_).control_category          := proj_cost_element_rec_.project_cost_element;
               activity_info_tab_(count_).planned                   := proj_cost_element_rec_.planned_amount;
               activity_info_tab_(count_).planned_hours             := proj_cost_element_rec_.planned_hours;
               activity_info_tab_(count_).committed                 := proj_cost_element_rec_.committed_amount;
               activity_info_tab_(count_).used                      := proj_cost_element_rec_.used_amount;
               activity_info_tab_(count_).transaction_currency_code := transaction_currency_code_;
               activity_info_tab_(count_).planned_transaction       := activity_info_tab_(count_).planned * transaction_currency_rate_;
               activity_info_tab_(count_).committed_transaction     := activity_info_tab_(count_).committed * transaction_currency_rate_;
               activity_info_tab_(count_).used_transaction          := activity_info_tab_(count_).used * transaction_currency_rate_;
               count_                                               := count_ + 1;
            END LOOP;
         END IF;

         Create_Project_Connection___ (
            order_no_                        => rec_.order_no,
            line_no_                         => rec_.line_no,
            rel_no_                          => rec_.rel_no,
            line_item_no_                    => rec_.line_item_no,
            proj_lu_name_                    => 'COLINE',
            system_ctrl_connection_          => system_ctrl_connection_,
            activity_info_tab_               => activity_info_tab_,
            activity_revenue_info_tab_       => activity_revenue_info_tab_,
            attributes_                      => attributes_);
      END;

   $END
END Handle_Activity_Seq___;


-- Is_Purch_Comp_Part_Line___
--   This method checks whether the given line is created to ship purchase
--   component parts to supplier. [This is only implemented as a workaround]
FUNCTION Is_Purch_Comp_Part_Line___ (
   rec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE ) RETURN BOOLEAN
IS
   ref_order_no_  VARCHAR2(32000);
BEGIN
   $IF (Component_Purch_SYS.INSTALLED)$THEN
      -- Removed demand code check for 'PI' since there won't be such data with the rec_.demand_order_ref1 IS NOT NULL condition.
      IF ((rec_.demand_code = 'PO') AND (rec_.demand_order_ref1 IS NOT NULL)) THEN
         ref_order_no_ := Pur_Order_Cust_Order_Comp_API.Get_Cust_Order_No(rec_.demand_order_ref1, rec_.demand_order_ref2, rec_.demand_order_ref3);

         IF ( ref_order_no_ = rec_.order_no ) THEN
            -- When ref_order_no_ is null above condition is alway FALSE.
            RETURN TRUE;
         END IF;
      END IF;
   $END
   -- IF the above criteria is not met, we say no!!!
   RETURN FALSE;
END Is_Purch_Comp_Part_Line___;


-- Calc_Dates_Forwards___
--   Calculate order dates forwards from a planned due date,
--   used mainly by the capability check processes.
PROCEDURE Calc_Dates_Forwards___ (
   planned_delivery_date_     IN OUT DATE,
   planned_ship_date_         IN OUT DATE,
   planned_due_date_          IN OUT DATE,
   supply_site_due_date_      IN OUT DATE,
   promised_delivery_date_    IN OUT DATE,
   planned_ship_period_       IN OUT VARCHAR2,
   target_date_               IN     DATE,
   contract_                  IN     VARCHAR2,
   supply_code_db_            IN     VARCHAR2,
   deliver_to_customer_no_    IN     VARCHAR2,
   vendor_no_                 IN     VARCHAR2,
   part_no_                   IN     VARCHAR2,
   purchase_part_no_          IN     VARCHAR2,
   ship_addr_no_              IN     VARCHAR2,
   ship_via_code_             IN     VARCHAR2,
   route_id_                  IN     VARCHAR2,
   delivery_leadtime_         IN     NUMBER,
   picking_leadtime_          IN     NUMBER,
   ext_transport_calendar_id_ IN     VARCHAR2,
   supplier_ship_via_transit_ IN     VARCHAR2,
   header_rowstate_           IN     VARCHAR2 )
IS
   old_ship_date_             DATE;
   timestamp_                 VARCHAR2(30);
BEGIN
   old_ship_date_ := planned_ship_date_;

   -- calculate ship date and delivery date forwards from due date.
   -- Also calculate manuf_start_date_ for 'SO', 'DOP' OR supply_site_due_date for other supply codes
   Cust_Ord_Date_Calculation_API.Calc_Order_Dates_Forwards(planned_delivery_date_, planned_ship_date_, planned_due_date_,
      supply_site_due_date_, target_date_, contract_, supply_code_db_, deliver_to_customer_no_,
      vendor_no_, part_no_, NVL(part_no_, purchase_part_no_), ship_addr_no_, ship_via_code_,
      route_id_, delivery_leadtime_, picking_leadtime_, ext_transport_calendar_id_, supplier_ship_via_transit_);


   IF (route_id_ IS NULL) THEN
      -- The time part of the planned ship date should not be changed
      planned_ship_date_ := TO_DATE(TO_CHAR(planned_ship_date_, 'YYYY-MM-DD') || ' ' ||
                            TO_CHAR(old_ship_date_, 'HH24:MI:SS'), 'YYYY-MM-DD HH24:MI:SS');
   END IF;

   planned_ship_period_ := Work_Time_Calendar_API.Get_Period(Site_API.Get_Dist_Calendar_Id(contract_), planned_ship_date_);

   -- calculate planned ship date's  time
   timestamp_ :=to_char(planned_ship_date_, Report_SYS.datetime_format_);

   -- replace with the old ship date's  time
   timestamp_ := replace(timestamp_, '00:00:00', to_char(old_ship_date_, 'HH24:MI:SS'));

   -- The time part of the planned delivery date should not be changed
   planned_ship_date_ := to_date(timestamp_, Report_SYS.datetime_format_);

   IF (header_rowstate_ = 'Planned') THEN
      promised_delivery_date_ := planned_delivery_date_;
   END IF;
END Calc_Dates_Forwards___;


-- Get_Auto_Capability_Check___
--   Method that return the automatic capability check value from
--   the inventory part, it also does some checks and even overrides
--   the value for IPT/IPD supply codes (so if you realy want the
--   correct value from the inventory part use the get-method on
--   the inventory part instead)
FUNCTION Get_Auto_Capability_Check___ (
   supply_code_db_ IN VARCHAR2,
   contract_       IN VARCHAR2,
   supply_site_    IN VARCHAR2,
   part_no_        IN VARCHAR2 ) RETURN VARCHAR2
IS
   automatic_capability_check_      VARCHAR2(50);
BEGIN
   -- fetch the automatic_capability_check flag from the inventory part
   IF (supply_code_db_ IN ('DOP','SO')) THEN
      automatic_capability_check_ := NVL(Capability_Check_Allocate_API.Encode(Inventory_Part_API.Get_Automatic_Capability_Check(contract_, part_no_)),'NO AUTOMATIC CAPABILITY CHECK');
   ELSIF (supply_code_db_ IN ('IPT','IPD')) THEN
      -- fetch automatic_capability_check value for the inventory part on the supply_site
      automatic_capability_check_ := NVL(Capability_Check_Allocate_API.Encode(Inventory_Part_API.Get_Automatic_Capability_Check(supply_site_, part_no_)), 'NO AUTOMATIC CAPABILITY CHECK');
      IF (automatic_capability_check_ IN ('RESERVE AND ALLOCATE','ALLOCATE ONLY')) THEN
         -- the neither case is the only valid reserve/allocate case for IPT/IPD
         automatic_capability_check_ := 'NEITHER RESERVE NOR ALLOCATE';
      END IF;
   ELSE
      automatic_capability_check_ := 'NO AUTOMATIC CAPABILITY CHECK';
   END IF;

   Trace_SYS.Field('automatic_capability_check_', automatic_capability_check_);

   RETURN automatic_capability_check_;
END Get_Auto_Capability_Check___;


-- Perform_Capability_Check___
--   Method for running the Capabily Check for the automatic capability check process.
PROCEDURE Perform_Capability_Check___ (
   newrec_                     IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   auto_cc_performed_          OUT    BOOLEAN,
   header_rowstate_            IN     VARCHAR2,
   automatic_capability_check_ IN     VARCHAR2 )
IS
   ok_to_run_capability_check_ NUMBER;
   int_demand_usage_type_      VARCHAR2(20) := 'CUSTOMERORDER';
   completion_date_            DATE;
   latest_release_date_        DATE;
   error_msg_                  VARCHAR2(500) := NULL;
   supply_site_supply_code_db_ VARCHAR2(3);
   supply_site_dist_calendar_  SITE_TAB.dist_calendar_id%TYPE;
   type_code_db_               VARCHAR2(2);
   customer_name_              VARCHAR2(200);
   sourcing_option_db_         VARCHAR2(20);
   interim_id_                 VARCHAR2(12);
   temp_planned_due_date_      DATE;
   delivery_leadtime_          NUMBER;                                  -- only a dummy variable in this method
   vendor_delivery_leadtime_   NUMBER;
   internal_delivery_leadtime_ NUMBER;
   picking_leadtime_           NUMBER;                                  -- only a dummy variable in this method
   internal_control_time_      NUMBER;
   vendor_manuf_leadtime_      NUMBER;
   vendor_leadtime_            NUMBER;
   expected_leadtime_          NUMBER;
   old_delivery_date_          DATE;
   message_                    VARCHAR2(200);
   headrec_                    Customer_Order_API.public_rec;
   orig_order_no_              VARCHAR2(12);
   orig_line_no_               VARCHAR2(4);
   orig_rel_no_                VARCHAR2(4);
   orig_line_item_no_          NUMBER;
   cc_reset_flag_              VARCHAR2(1);  -- reset flag which tells if the cc-flag/latest_release_date needs reseting when receiving an error and there may exist old cc-data from an earlier try
   info_msg_                   VARCHAR2(2000);
   conv_revised_qty_due_       NUMBER;
   order_info_                 VARCHAR2(23);
   transport_leadtime_         NUMBER;
   arrival_route_id_           VARCHAR2(12);
   ctp_run_id_                 NUMBER;   
BEGIN
   auto_cc_performed_ := FALSE;

   -- do not run the capability check when a part ownership other than COMPANY OWNED
   -- and line state should be released and head state should be planned
   IF (newrec_.part_ownership = 'COMPANY OWNED' AND
       NVL(newrec_.rowstate,'Released') = 'Released' AND header_rowstate_ = 'Planned') THEN
      IF (newrec_.supply_code IN ('IPT','IPD')) THEN
         sourcing_option_db_ := Sourcing_Option_API.Encode(Sales_Part_API.Get_Sourcing_Option(newrec_.supply_site, newrec_.part_no));
         IF (sourcing_option_db_ = 'DOPORDER') THEN
            supply_site_supply_code_db_ := 'DOP';
         ELSIF (sourcing_option_db_ = 'SHOPORDER') THEN
            supply_site_supply_code_db_ := 'SO';
            -- a sourcing option SHOPORDER part on supply site need to be a manufactured part
            type_code_db_ := Inventory_Part_API.Get_Type_Code_Db(newrec_.supply_site, newrec_.part_no);
            IF (type_code_db_ IN ('1','2')) THEN
               ok_to_run_capability_check_ := 1;
            ELSE
               ok_to_run_capability_check_ := 0;
            END IF;
         END IF;
      END IF;

      headrec_  := Customer_Order_API.Get(newrec_.order_no);
      -- if this is the internal customer order in an IPT/IPD flow get the original order line keys
      $IF (Component_Purch_SYS.INSTALLED)$THEN
         IF (headrec_.internal_po_no IS NOT NULL) THEN
            DECLARE
               poline_ Purchase_Order_Line_API.Public_Rec;
            BEGIN
               poline_ := Purchase_Order_Line_API.Get(headrec_.internal_po_no, newrec_.line_no, newrec_.rel_no);
               IF (poline_.demand_code IN ('ICD', 'ICT')) THEN
                  orig_order_no_     := poline_.demand_order_no;
                  orig_line_no_      := poline_.demand_release;
                  orig_rel_no_       := poline_.demand_sequence_no;
                  orig_line_item_no_ := poline_.demand_operation_no;
               END IF;
            END;
         END IF;
      $END
      -- Note: Dont start auto capability check if the any reservations exists
      IF (newrec_.qty_assigned > 0 OR Co_Supply_Site_Reservation_API.Get_Qty_Reserved(NVL(orig_order_no_,newrec_.order_no),
                                          NVL(orig_line_no_,newrec_.line_no), NVL(orig_rel_no_,newrec_.rel_no),
                                          NVL(orig_line_item_no_,newrec_.line_item_no)) > 0) THEN
         ok_to_run_capability_check_ := 0;
         Client_SYS.Add_Info(lu_name_, 'AUTO_CC_RESERV: Since reservations have been made, the Capability Check cannot start.');
         Trace_SYS.Message('CC>> automatic capability check will not be performed due to existing reservations');
      END IF;
      -- the capability check should not be run if a cto-part have no configuration
      IF (Part_Catalog_API.Get_Configurable_Db(newrec_.part_no) = 'CONFIGURED' AND newrec_.configuration_id = '*') THEN
         ok_to_run_capability_check_ := 0;
      ELSE
         -- do not set this flag to true if its already got a value earlier on (like in the IPT/IPD SHOPORDER case above)
         IF (ok_to_run_capability_check_ IS NULL) THEN
            ok_to_run_capability_check_ := 1;
         END IF;
      END IF;
   END IF;

   Trace_SYS.Field('CC>> ok_to_run_automatic_capability_check_', ok_to_run_capability_check_);

   -- Run the capability check engine
   $IF (Component_Ordstr_SYS.INSTALLED) $THEN
      IF (ok_to_run_capability_check_ = 1) THEN
         supply_site_dist_calendar_ := Site_API.Get_Dist_Calendar_Id(newrec_.supply_site);
         -- the engine needs the previous work day for planned due date
         IF (newrec_.supply_site_due_date IS NULL) THEN
            Trace_SYS.Field('CC>> original planned_due_date  ', newrec_.planned_due_date);
            temp_planned_due_date_ := newrec_.planned_due_date;
            Trace_SYS.Field('CC>> planned_due_date sent to the CC engine ', temp_planned_due_date_);
         ELSE
            Trace_SYS.Field('CC>> original supply_site_due_date_  ', newrec_.supply_site_due_date);
            temp_planned_due_date_ := newrec_.supply_site_due_date;
            Trace_SYS.Field('CC>> supply_site_due_date_ sent to the CC engine ', temp_planned_due_date_);
         END IF;
         App_Context_SYS.Set_Value('OLD_REQUIRED_DATE', temp_planned_due_date_);
         old_delivery_date_ := newrec_.planned_delivery_date;
         interim_id_ := Get_Interim_Order_No(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.ctp_planned);
         customer_name_ := Cust_Ord_Customer_API.Get_Name(newrec_.customer_no);

         IF (newrec_.supply_site IS NOT NULL) THEN
            -- convert the qty from demand site inv uom to supply site inv oum
            conv_revised_qty_due_ := Inventory_Part_API.Get_Site_Converted_Qty(newrec_.contract, newrec_.part_no, newrec_.revised_qty_due, newrec_.supply_site, 'ADD');
         ELSE
            conv_revised_qty_due_ := newrec_.revised_qty_due;
         END IF;

         Interim_Ctp_Manager_API.Calculate_Ctp(cc_reset_flag_,
                                               completion_date_,
                                               latest_release_date_,
                                               error_msg_,
                                               info_msg_,                                               
                                               interim_id_,
                                               NVL(newrec_.supply_site,newrec_.contract),
                                               newrec_.part_no,
                                               newrec_.configuration_id,
                                               temp_planned_due_date_,
                                               conv_revised_qty_due_,
                                               int_demand_usage_type_,
                                               newrec_.order_no,
                                               newrec_.line_no,
                                               newrec_.rel_no,
                                               newrec_.line_item_no,
                                               newrec_.customer_no,
                                               customer_name_,
                                               automatic_capability_check_,
                                               NVL(supply_site_supply_code_db_, newrec_.supply_code),
                                               is_auto_cc_ => TRUE,
                                               planned_delivery_date_ => newrec_.planned_delivery_date);

         Trace_SYS.Field('CC>> completion_date_ (planned_due_date/supply_site_due_date received from CC engine)', completion_date_);


         IF (error_msg_ IS NULL) THEN
            -- we use the next work day from the completion_date/planned_due_date that engine have returned to us
            IF (newrec_.supply_site_due_date IS NULL) THEN -- this was a capability check performed on demand site
               -- getting next work day for DOP/SO planned_due_date will be done in method Calc_Order_Dates_Forwards later on
               temp_planned_due_date_ := completion_date_;
            ELSE -- this was a capability check performed on supply site
               newrec_.supply_site_due_date := Work_Time_Calendar_API.Get_Next_Work_Day(supply_site_dist_calendar_, completion_date_);
               Trace_SYS.Field('CC>> supply_site_due_date including next work day ', newrec_.supply_site_due_date);

               IF (completion_date_ != temp_planned_due_date_) THEN
                  -- fetching some default leadtimes values that we can use in the planned_due_date calculation
                  Cust_Order_Leadtime_Util_API.Get_Default_Leadtimes(delivery_leadtime_, vendor_delivery_leadtime_, internal_delivery_leadtime_,
                                                                     picking_leadtime_, internal_control_time_, vendor_manuf_leadtime_,
                                                                     vendor_leadtime_, expected_leadtime_, transport_leadtime_, arrival_route_id_,
                                                                     newrec_.contract, newrec_.deliver_to_customer_no, newrec_.ship_addr_no, newrec_.addr_flag,
                                                                     newrec_.part_no, newrec_.purchase_part_no, newrec_.supply_code, newrec_.vendor_no,
                                                                     newrec_.ship_via_code, newrec_.supplier_ship_via_transit);

                  -- count forwards from supply_site_due_date to planned_due_date
                  Cust_Ord_Date_Calculation_API.Calc_Due_Date_Forwards(temp_planned_due_date_, newrec_.supply_site_due_date,
                                                                    newrec_.contract, internal_control_time_, vendor_delivery_leadtime_,
                                                                    internal_delivery_leadtime_, vendor_manuf_leadtime_, vendor_leadtime_,
                                                                    expected_leadtime_, newrec_.supply_code, newrec_.vendor_no, newrec_.supply_site, newrec_.purchase_part_no,
                                                                    newrec_.supplier_ship_via_transit, transport_leadtime_, arrival_route_id_);
               END IF;
               Trace_SYS.Field('CC>> planned_due_date (calculated from supply_site_due_date) ', temp_planned_due_date_);
            END IF;

            newrec_.planned_due_date := temp_planned_due_date_;

            -- calculate planned_delivery_date, planned_ship_date, supply_site_due_date forwards from planned_due_date received from the cc engine
            Calc_Dates_Forwards___(newrec_.planned_delivery_date, newrec_.planned_ship_date, newrec_.planned_due_date,
               newrec_.supply_site_due_date, newrec_.promised_delivery_date, newrec_.planned_ship_period,
               newrec_.target_date, newrec_.contract, newrec_.supply_code, newrec_.deliver_to_customer_no,
               newrec_.vendor_no, newrec_.part_no, newrec_.purchase_part_no, newrec_.ship_addr_no, newrec_.ship_via_code,
            newrec_.route_id, newrec_.delivery_leadtime, newrec_.picking_leadtime, newrec_.ext_transport_calendar_id, newrec_.supplier_ship_via_transit, header_rowstate_);

            -- the capability check engine have returned a date and its one of the allocate/reserve cc alternatives, set the cc planned flag
            IF (latest_release_date_ IS NOT NULL AND automatic_capability_check_ IN ('RESERVE AND ALLOCATE','ALLOCATE ONLY')) THEN
               newrec_.latest_release_date := latest_release_date_;
               newrec_.ctp_planned := 'Y';
            -- for the neither case set the latest_release_date and set flag to false
            ELSIF (latest_release_date_ IS NOT NULL AND automatic_capability_check_ = 'NEITHER RESERVE NOR ALLOCATE') THEN
               newrec_.latest_release_date := latest_release_date_;
               newrec_.ctp_planned := 'N';
            END IF;
            auto_cc_performed_ := TRUE;
            order_info_        := newrec_.order_no||'-'||newrec_.line_no||'-'||newrec_.rel_no||'-'||newrec_.line_item_no;
            IF (App_Context_SYS.Find_Number_Value('CTP_RUN_ID') IS NOT NULL) THEN
               ctp_run_id_ := App_Context_SYS.Get_Number_Value('CTP_RUN_ID');
            END IF;
            IF (old_delivery_date_ != newrec_.planned_delivery_date) THEN
               message_ := SUBSTR(Language_SYS.Translate_Constant(lu_name_, 'DATESCHANGEDBYACC: Aut Capability Check. Planned Del Date changed from :P1 to :P2.',NULL,
                                                to_char(old_delivery_date_, 'YYYY-MM-DD'),
                                                to_char(newrec_.planned_delivery_date, 'YYYY-MM-DD')), 1, 200);
               Interim_Ctp_Critical_Path_API.Update_Is_Deliverable(ctp_run_id_, Fnd_Boolean_API.DB_FALSE);
            ELSE
               Interim_Ctp_Critical_Path_API.Update_Is_Deliverable(ctp_run_id_, Fnd_Boolean_API.DB_TRUE);
            END IF;
            IF (info_msg_ IS NOT NULL) THEN
               Client_SYS.Add_Info(lu_name_, 'CC_INFO: :P1', info_msg_);
            END IF;
         ELSE
            Trace_SYS.Message('Automatic capability check was performed but got the following error >>'|| error_msg_);
            Client_SYS.Add_Info(lu_name_, 'AUTO_CC_ERROR: Automatic Capability Check Error - :P1', error_msg_);
            IF (cc_reset_flag_ = 'Y') THEN  -- clear the cc flag/latest_release_date
               newrec_.latest_release_date   := NULL;
               newrec_.ctp_planned           := 'N';
               newrec_.planned_delivery_date := newrec_.target_date;
               auto_cc_performed_            := TRUE;  -- set this so the line will be modified and dates recalculated
            END IF;
         END IF;
      ELSE
         Trace_SYS.Message('No automatic capability check was performed');
      END IF;
   $ELSE
      Trace_SYS.Message('No automatic capability check was performed');
   $END

   IF (message_ IS NOT NULL) THEN
      Customer_Order_Line_Hist_API.New( newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, message_);
   END IF;
END Perform_Capability_Check___;


-- Validate_Delivery_Conf___
--   Performs insert/update checks against the "delivery confirmation",
--   "delay COGS" and "check sales group" flags on order header.
--   There are different error messages if validation is triggered by the
--   order header or if an order line is saved.
PROCEDURE Validate_Delivery_Conf___ (
   newrec_                        IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   insert_mode_                   IN BOOLEAN,
   catalog_group_                 IN VARCHAR2,
   pkg_catalog_group_             IN VARCHAR2,
   confirm_deliveries_db_         IN VARCHAR2 DEFAULT NULL,
   check_sales_grp_deliv_conf_db_ IN VARCHAR2 DEFAULT NULL,
   triggered_by_header_           IN BOOLEAN DEFAULT FALSE,
   insert_package_mode_           IN VARCHAR2 DEFAULT 'FALSE')
IS
   headrec_        CUSTOMER_ORDER_API.Public_Rec;
   error_          BOOLEAN;
   deliv_conf_     VARCHAR2(20);
   pkg_deliv_conf_ VARCHAR2(20);
BEGIN

   -- if validation is triggered by Order Header... (nothing is saved yet)
   IF triggered_by_header_ THEN
      headrec_.confirm_deliveries         := confirm_deliveries_db_;
      headrec_.check_sales_grp_deliv_conf := check_sales_grp_deliv_conf_db_;
      -- fetch delay COGS from company, just like the header does
      headrec_.delay_cogs_to_deliv_conf   := Company_Order_Info_API.Get_Delay_Cogs_To_Deliv_Con_Db(Site_API.Get_Company(newrec_.contract));
   ELSE
      headrec_ := CUSTOMER_ORDER_API.Get(newrec_.order_no);
   END IF;

   -- CONFIRM DELIVERIES
   IF (headrec_.confirm_deliveries = 'TRUE') THEN
      -- customer consignment stock
      IF (newrec_.consignment_stock = 'CONSIGNMENT STOCK') THEN
         Error_SYS.Record_General(lu_name_, 'CONSIGNMENT_DC: Not possible to have Delivery Confirmation together with Consignment Stock parts.');

      -- non-charged items / repair orders
      ELSIF (newrec_.charged_item = 'ITEM NOT CHARGED') THEN
         Error_SYS.Record_General(lu_name_, 'CHARGEDITEM_DC: Only allowed to have charged items together with Delivery Confirmation.');

      -- exchange order line
      ELSIF (newrec_.exchange_item = 'EXCHANGED ITEM') THEN
         Error_SYS.Record_General(lu_name_, 'EXCHANGEITEM_DC: Exchanged Order Lines can not use Delivery Confirmation.');

      -- ownership: customer owned or supplier loaned
      ELSIF (newrec_.part_ownership IN ('SUPPLIER LOANED', 'CUSTOMER OWNED')) THEN
         IF triggered_by_header_ THEN
            Error_SYS.Record_General(lu_name_, 'OWNERSHIP_DC: Not possible to have order lines with other than Company Owned parts together with Delivery Confirmation.');
         ELSE
            Error_SYS.Record_General(lu_name_, 'OWNERSHIP_DC2: Only Company Owned parts can be used together with Delivery Confirmation.');
         END IF;
      END IF;
   END IF;

   -- CONFIRM DELIVERIES WITH "DELAY COGS" (delay COGS can't be set unless delivery confirmation is true)
   IF (headrec_.delay_cogs_to_deliv_conf = 'TRUE') THEN

      -- direct delivery
      IF (newrec_.supply_code IN ('PD', 'IPD')) THEN
         IF triggered_by_header_ THEN
            Error_SYS.Record_General(lu_name_, 'DIRECTDEL_DC: There are order lines using Direct Delivery. Not allowed when Cost of Goods Sold is delayed to Delivery Confirmation.');
         ELSE
            Error_SYS.Record_General(lu_name_, 'DIRECTDEL_DC2: Not possible to use Direct Delivery when Cost of Goods Sold is delayed to Delivery Confirmation.');
         END IF;

      -- order line is project connected (activity sequence)
      ELSIF (newrec_.activity_seq IS NOT NULL) THEN
         IF triggered_by_header_ THEN
            Error_SYS.Record_General(lu_name_, 'ACTIVITYSEQ_DC: There are Project connected order lines. This is not allowed when Cost of Goods Sold is delayed to Delivery Confirmation.');
         ELSE
            Error_SYS.Record_General(lu_name_, 'ACTIVITYSEQ_DC2: Project connected order lines are not allowed when Cost of Goods Sold is delayed to Delivery Confirmation.');
         END IF;
      -- inventory part cost level
      ELSIF (newrec_.part_no IS NOT NULL) THEN
         IF (Inventory_Part_API.Get_Invent_Part_Cost_Level_Db(newrec_.contract, newrec_.part_no) != 'COST PER PART') THEN
            IF triggered_by_header_ THEN
               Error_SYS.Record_General(lu_name_, 'COSTLEVEL_DC: There are order lines having parts with Inventory Part Cost Level other than :P1. This is not allowed when Cost of Goods Sold is delayed to Delivery Confirmation.', Inventory_Part_Cost_Level_API.Decode('COST PER PART'));
            ELSE
               Error_SYS.Record_General(lu_name_, 'COSTLEVEL_DC2: :P1 is the only Inventory Part Cost Level allowed when Cost of Goods Sold is delayed to Delivery Confirmation.', Inventory_Part_Cost_Level_API.Decode('COST PER PART'));
            END IF;
         END IF;
      END IF;
   END IF;

   -- CHECK SALES GROUP SETTING
   IF (insert_package_mode_ = 'FALSE')AND (headrec_.check_sales_grp_deliv_conf = 'TRUE') THEN

      -- sales part is not updateable - but flag must be checked if triggered from order header
      IF insert_mode_ OR triggered_by_header_ THEN

         deliv_conf_ := Sales_Group_API.Get_Delivery_Confirmation_Db(catalog_group_);
         Trace_SYS.Field('SALES GROUP - delivery_confirmation', deliv_conf_);

         IF (pkg_catalog_group_ IS NOT NULL) THEN -- i.e. a component is being inserted manually
            pkg_deliv_conf_ := Sales_Group_API.Get_Delivery_Confirmation_Db(pkg_catalog_group_);
            Trace_SYS.Field('PKG SALES GROUP - delivery_confirmation', pkg_deliv_conf_);
            -- for components Delivery Confirmation must be the same as their package parts - or Optional
            error_ := (deliv_conf_ NOT IN (pkg_deliv_conf_, 'OPTIONAL'));
         ELSIF (headrec_.confirm_deliveries = 'TRUE') THEN
            -- if Confirm Deliveries is set Delivery Confirmation must be Required or Optional
            error_ := (deliv_conf_ = 'NOTALLOWED');
         ELSE
            -- otherwise Delivery Confirmation must be Not Allowed or Optional
            error_ := (deliv_conf_ = 'REQUIRED');
         END IF;

         IF error_ THEN
            IF triggered_by_header_ THEN
               Error_SYS.Record_General(lu_name_, 'SALESGRPDELIVCONF: There are order lines using sales group :P1 which doesn''t match the settings on Customer Order.', catalog_group_);
            ELSIF (pkg_catalog_group_ IS NOT NULL) THEN -- component part
               Error_SYS.Record_General(lu_name_, 'SALESGRPDELIVCONF4: The delivery confirmation setting on sales group :P1 doesn''t match the setting for the package part''s sales group :P2.', catalog_group_, pkg_catalog_group_);
            ELSE                                        -- package or regular part
               Error_SYS.Record_General(lu_name_, 'SALESGRPDELIVCONF2: The delivery confirmation setting on sales group :P1 doesn''t match the settings for Delivery Confirmation on Customer Order.', catalog_group_);
            END IF;
         END IF;
      END IF;
   END IF;
END Validate_Delivery_Conf___;


-- Validate_Block_For_Invoic___
--   Performs insert/update checks against the "Blocked for Invoicing",
PROCEDURE Validate_Block_For_Invoic___ (
   newrec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
BEGIN

   IF (newrec_.staged_billing = 'STAGED BILLING') THEN
      Error_SYS.Record_General(lu_name_, 'BLOCKINVOICESTOP2: It is not allowed to Block for Invoicing when the Order line is connected to a Staged Billing Profile');
   END IF;

   IF (newrec_.self_billing = 'SELF BILLING') THEN
      IF (Self_Billing_Item_API.Order_Line_Exist(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no) = 'TRUE') THEN
         Error_SYS.Record_General(lu_name_, 'BLOCKINVOICESTOP3: It is not allowed to Block for Invoicing when the Order line is connected to a Self Billing Invoice');
      END IF;
   END IF;
END Validate_Block_For_Invoic___;


PROCEDURE Log_Price_Changes___ (
   newrec_              IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   headrec_             IN CUSTOMER_ORDER_API.Public_Rec,
   calc_price_per_curr_ IN NUMBER )
IS
   price_diff_          NUMBER;
   curr_rate_           NUMBER;
   calc_price_per_base_ NUMBER;
BEGIN

   IF (calc_price_per_curr_ != 0) THEN
      IF (headrec_.use_price_incl_tax = 'TRUE') THEN
         price_diff_ := ((newrec_.unit_price_incl_tax - calc_price_per_curr_)/calc_price_per_curr_ )*100;
      ELSE
      price_diff_ := ((newrec_.sale_unit_price - calc_price_per_curr_)/calc_price_per_curr_ )*100;
      END IF;

      -- Retrieve the calculated price in base currency
      Customer_Order_Pricing_API.Get_Base_Price_In_Currency (calc_price_per_base_,
                                                             curr_rate_,
                                                             NVL(headrec_.customer_no_pay, headrec_.customer_no),
                                                             headrec_.contract,
                                                             headrec_.currency_code,
                                                             calc_price_per_curr_,
                                                             headrec_.currency_rate_type);
   ELSE
      price_diff_ := NULL;
      calc_price_per_base_ := 0;
   END IF;

   Cust_Order_Event_Creation_API.Cust_Ord_Line_Price_Changed(newrec_.order_no,
                                                             newrec_.line_no,
                                                             newrec_.rel_no,
                                                             newrec_.line_item_no,
                                                             calc_price_per_curr_,
                                                             calc_price_per_base_,
                                                             price_diff_);
   Cust_Ord_Price_Hist_API.New(newrec_.order_no,
                               newrec_.line_no,
                               newrec_.rel_no,
                               newrec_.line_item_no,
                               calc_price_per_curr_,
                               calc_price_per_base_,
                               price_diff_);
END Log_Price_Changes___;


-- Validate_Prepayment___
--   Validating CO gross amount/curr including charges by checking whether
--   it has exceeded the prepayment amount.
PROCEDURE Validate_Prepayment___ (
   rec_     IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   action_  IN VARCHAR2)
IS
   gross_amount_     NUMBER;
   prepay_amount_    NUMBER;
   line_amount_      NUMBER;
   header_rec_       CUSTOMER_ORDER_API.Public_Rec;
BEGIN
   header_rec_ := Customer_Order_API.Get(rec_.order_no);
   $IF (Component_Payled_SYS.INSTALLED) $THEN
      prepay_amount_ := On_Account_Ledger_Item_API.Get_Payment_Amt_For_Order_Ref(Site_API.Get_Company(rec_.contract),
                                                                                 NVL(header_rec_.customer_no_pay, header_rec_.customer_no),
                                                                                 rec_.order_no);
   $END
   IF NVL(prepay_amount_, 0) > 0 THEN
      gross_amount_  := Customer_Order_API.Get_Gross_Amt_Incl_Charges(rec_.order_no);
      IF action_ = 'MODIFY' THEN
         IF (prepay_amount_ > gross_amount_) THEN
            Raise_Prepay_Amount_Error___;
         END IF;
      ELSIF action_ = 'DELETE' THEN
         -- Modified value assignment to line_amount_.
         IF (header_rec_.use_price_incl_tax = 'TRUE') THEN
            line_amount_   := Get_Sale_Price_Incl_Tax_Total(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
         ELSE
            line_amount_   := Get_Sale_Price_Total(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
            line_amount_   := line_amount_ + Get_Total_Tax_Amount_Curr(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
         END IF;

         IF (prepay_amount_ > (gross_amount_ - line_amount_)) THEN
            Raise_Prepay_Amount_Error___;
         END IF;
      END IF;
  END IF;
END Validate_Prepayment___;


PROCEDURE Handle_Replacement_Part___ (
   catalog_no_     IN OUT VARCHAR2,
   org_catalog_no_ IN OUT VARCHAR2,
   contract_       IN     VARCHAR2,
   by_info_        IN     BOOLEAN )
IS
   sales_part_rec_   Sales_Part_API.Public_Rec;
   base_part_no_     CUSTOMER_ORDER_LINE_TAB.catalog_no%TYPE;
   replace_part_     VARCHAR2(25);
   replace_date_     DATE;
   overload_count_   NUMBER := 0;
   replaced_         BOOLEAN := FALSE;
BEGIN

   sales_part_rec_  := Sales_Part_API.Get(contract_, catalog_no_);
   replace_part_    := sales_part_rec_.replacement_part_no;
   replace_date_    := sales_part_rec_.date_of_replacement;

   -- Check if the specified sales part has been superseded by a replacement part.
   LOOP
      IF (replace_part_ IS NOT NULL) AND (replace_date_ <= (Site_API.Get_Site_Date(contract_))) THEN
         IF (overload_count_ = 10) THEN
            Error_SYS.Record_General(lu_name_, 'REPOVERLOADED: No of Part Replacements are exceeded for the sales part :P1, Please check your sales part replacement data.', base_part_no_);
         ELSE
            IF (overload_count_ = 0) THEN
               base_part_no_ := catalog_no_;
            END IF;
            IF (by_info_) THEN
               Client_SYS.Add_Info(lu_name_, 'REPLACED: The sales part :P1 on the order line has been superseded by replacement part :P2.', catalog_no_, replace_part_);
            END IF;
            org_catalog_no_ := catalog_no_;
            catalog_no_     := replace_part_;
            replaced_       := TRUE;

            sales_part_rec_  := Sales_Part_API.Get(contract_, catalog_no_);
            -- Fetch new replcement part
            replace_part_ := sales_part_rec_.replacement_part_no;
            replace_date_ := sales_part_rec_.date_of_replacement;
         END IF;
      ELSE
          EXIT;
      END IF;
      overload_count_ := overload_count_ + 1;
   END LOOP;

   IF (sales_part_rec_.activeind = 'N' AND by_info_) THEN
      IF replaced_ THEN
         -- Replacement part is not active.
         Client_SYS.Clear_Info;
         Error_SYS.Record_General(lu_name_, 'NOT_ACTIVE2: The sales part :P1 has been superceded by a replacement part (:P2) that is not active for sale.', org_catalog_no_, catalog_no_ );
      ELSE
         Error_SYS.Record_General(lu_name_, 'NOT_ACTIVE: The sales part :P1 is not active for sale', catalog_no_);
      END IF;
   END IF;
END Handle_Replacement_Part___;


-- Get_Progress_Info___
--   This method will return the progress information.
FUNCTION Get_Progress_Info___ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   rowstate_     IN VARCHAR2 ) RETURN NUMBER
IS
   progress_       NUMBER;
BEGIN
   IF (Customer_Order_Milestone_API.Milestone_Exist(order_no_, line_no_, rel_no_, line_item_no_)= 'TRUE') THEN
      progress_ := Customer_Order_Milestone_API.Get_Max_Progress(order_no_, line_no_, rel_no_, line_item_no_);
   ELSIF (rowstate_ IN ('Delivered', 'Invoiced')) THEN
      progress_:= 1;
   ELSIF (rowstate_ = 'PartiallyDelivered') THEN
      progress_:= 0.75;
   ELSIF (rowstate_ = 'Picked') THEN
      progress_:= 0.50;
   ELSIF (rowstate_ =  'Reserved') THEN
      progress_:= 0.30;
   ELSIF (rowstate_ IN ('Cancelled', 'Released')) THEN
      progress_:= 0;
   END IF;
   RETURN progress_;
END Get_Progress_Info___;


-- Is_Number___
--   Method checkes whether the passes string is a numeric value.
--   Returns TRUE if it is a numeric value, FALSE otherwise.
FUNCTION Is_Number___ (
   string_   IN VARCHAR2 ) RETURN BOOLEAN
IS
   c_    NUMBER;
BEGIN
   FOR i_ IN 1..LENGTH( string_ ) LOOP
      c_ := ASCII( SUBSTR( string_, i_, 1 ) );
      IF ( c_ < ASCII( '0' ) OR c_ > ASCII( '9' ) ) THEN
         RETURN FALSE;
      END IF;
   END LOOP;
   RETURN TRUE;
END Is_Number___;


PROCEDURE Generate_Next_Level_Demands___ (
   header_rowstate_  IN VARCHAR2,
   newrec_           IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
   planning_method_   VARCHAR2(1);
BEGIN
   IF (header_rowstate_ != 'Planned') THEN
        -- Check if MRP order code is 'N', if so generate next level demands
        -- The reason this is done even if the order is credit blocked is that there is no way
        -- of knowing whether demands have already been generated or not for a released order.
        -- IF the demands were generated when the credit blocked order is released then there is
        -- a risk that they would be generated more than once for the same order.

        IF (newrec_.supply_code = 'IO') THEN
           planning_method_ := Inventory_Part_Planning_API.Get_Planning_Method(newrec_.contract, newrec_.part_no);
           IF ((planning_method_ = 'N') AND (newrec_.part_ownership = Part_Ownership_API.DB_COMPANY_OWNED)) THEN
              -- 109943, Removed passing of planned quantiry on hand. Also passed newrec_.condition_code.
              Order_Supply_Demand_API.Generate_Next_Level_Demands (qty_ordered_      => newrec_.revised_qty_due,
                                                                   date_required_    => newrec_.planned_due_date,
                                                                   contract_         => newrec_.contract,
                                                                   part_no_          => newrec_.part_no,
                                                                   configuration_id_ =>  '*',
                                                                   condition_code_   => newrec_.condition_code);
           END IF;
        END IF;
     END IF;
END Generate_Next_Level_Demands___;


-- Get_Elements_From_Purch___
--   Return the planned_cost_elements_ plsql table with project cost elements and
--   cost calculated to be used for purchase related CO supply options.
--   Return the planned_cost_elements_ plsql table with project cost elements and
--   cost calculated to be used for purchase related CO supply options.
FUNCTION Get_Elements_From_Purch___ (
   contract_     IN VARCHAR2,
   part_no_      IN VARCHAR2,
   vendor_no_    IN VARCHAR2,
   quantity_     IN NUMBER,
   project_id_   IN VARCHAR2,
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN Mpccom_Accounting_API.Project_Cost_Element_Tab
IS
   planned_cost_elements_   Mpccom_Accounting_API.Project_Cost_Element_Tab;
BEGIN

   $IF (Component_Purch_SYS.INSTALLED)$THEN
      DECLARE
         planned_cost_elements_      Mpccom_Accounting_API.Project_Cost_Element_Tab;
         empty_tab_                  Mpccom_Accounting_API.Project_Cost_Element_Tab;
      BEGIN
         planned_cost_elements_ := Purchase_Part_Supplier_API.Get_Project_Cost_Elements(
                                                              contract_                     => contract_,
                                                              part_no_                      => part_no_,
                                                              vendor_no_                    => vendor_no_,
                                                              required_qty_                 => quantity_,
                                                              project_id_                   => project_id_,
                                                              stat_grp_                     => NULL,
                                                              assortment_                   => NULL,
                                                              expected_supplier_price_unit_ => NULL,
                                                              currency_code_                => NULL,
                                                              source_ref_type_db_           => 'CUST ORDER',
                                                              source_ref1_                  => order_no_,
                                                              source_ref2_                  => line_no_,
                                                              source_ref3_                  => rel_no_,
                                                              source_ref4_                  => line_item_no_ );

         Invent_Proj_Cost_Manager_API.Fill_Project_Cost_Element_Tmp(planned_cost_elements_,
                                                                    empty_tab_,
                                                                    empty_tab_,
                                                                    empty_tab_);

      END;

      planned_cost_elements_ := Invent_Proj_Cost_Manager_API.Get_From_Temporary_Table();
   $END

   RETURN planned_cost_elements_;

END Get_Elements_From_Purch___;


-- Get_Elements_From_Purch___
--   Return the planned_cost_elements_ plsql table with project cost elements and
--   cost calculated to be used for purchase related CO supply options.
--   Return the planned_cost_elements_ plsql table with project cost elements and
--   cost calculated to be used for purchase related CO supply options.
FUNCTION Get_Elements_From_Purch___ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   contract_     IN VARCHAR2,
   part_no_      IN VARCHAR2,
   vendor_no_    IN VARCHAR2,
   quantity_     IN NUMBER,
   project_id_   IN VARCHAR2,
   charged_item_ IN VARCHAR2 ) RETURN Mpccom_Accounting_API.Project_Cost_Element_Tab
IS
   planned_cost_elements_      Mpccom_Accounting_API.Project_Cost_Element_Tab;
   sales_oh_cost_elements_     Mpccom_Accounting_API.Project_Cost_Element_Tab;
   project_cost_element_tab_   Mpccom_Accounting_API.Project_Cost_Element_Tab;
BEGIN
   project_cost_element_tab_ := Get_Elements_From_Purch___(contract_,
                                                           part_no_,
                                                           vendor_no_,
                                                           quantity_,
                                                           project_id_,
                                                           order_no_,
                                                           line_no_,
                                                           rel_no_,
                                                           line_item_no_);

   IF (charged_item_ = 'CHARGED ITEM') THEN
      sales_oh_cost_elements_   := Invent_Proj_Cost_Manager_API.Get_Elements_For_Sales_Oh(contract_,
                                                                                          part_no_,
                                                                                          order_no_,
                                                                                          line_no_,
                                                                                          rel_no_,
                                                                                          line_item_no_,
                                                                                          quantity_ );
   END IF;
   planned_cost_elements_    := Mpccom_Accounting_API.Get_Merged_Cost_Element_Tab(project_cost_element_tab_,
                                                                                  sales_oh_cost_elements_);
   RETURN planned_cost_elements_;

END Get_Elements_From_Purch___;


-- Get_Activity_Planned_Cost___
--   Return the planned_cost_elements_ plsql table with project cost elements and
--   cost calculated using specific logic for part type and supply option.
FUNCTION Get_Activity_Planned_Cost___ (
   rec_              IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   inventory_part_   IN BOOLEAN ) RETURN Mpccom_Accounting_API.Project_Cost_Element_Tab
IS
   planned_cost_elements_      Mpccom_Accounting_API.Project_Cost_Element_Tab;
BEGIN
   CASE rec_.supply_code
      WHEN 'IO' THEN
         -- Invent Order
         planned_cost_elements_ := Get_Elements_From_Invent___(rec_.order_no,
                                                               rec_.line_no,
                                                               rec_.rel_no,
                                                               rec_.line_item_no,
                                                               rec_.contract,
                                                               rec_.part_no,
                                                               rec_.condition_code,
                                                               rec_.buy_qty_due,
                                                               rec_.charged_item );
      WHEN 'PD' THEN
         -- Purch Order Direct
         IF inventory_part_ THEN
            planned_cost_elements_ := Get_Elements_From_Purch___(rec_.order_no,
                                                                 rec_.line_no,
                                                                 rec_.rel_no,
                                                                 rec_.line_item_no,
                                                                 rec_.contract,
                                                                 rec_.part_no,
                                                                 rec_.vendor_no,
                                                                 rec_.buy_qty_due,
                                                                 rec_.project_id,
                                                                 rec_.charged_item );
         ELSE
            planned_cost_elements_ := Get_Elements_From_Purch___(rec_.contract,
                                                                 rec_.purchase_part_no,
                                                                 rec_.vendor_no,
                                                                 rec_.buy_qty_due,
                                                                 rec_.project_id,
                                                                 rec_.order_no,
                                                                 rec_.line_no,
                                                                 rec_.rel_no,
                                                                 rec_.line_item_no);
         END IF;
      WHEN 'NO' THEN
         -- Non-Inventory
         planned_cost_elements_ := Get_Elements_Non_Inv___(rec_, rec_.buy_qty_due);
      WHEN 'IPD' THEN
         -- Int Purch Dir
         IF inventory_part_ THEN
            IF (Site_API.Get_Company(rec_.contract) = Site_API.Get_Company(rec_.supply_site)) THEN
               planned_cost_elements_ := Get_Elements_From_Invent___(rec_.order_no,
                                                                     rec_.line_no,
                                                                     rec_.rel_no,
                                                                     rec_.line_item_no,
                                                                     rec_.contract,
                                                                     rec_.part_no,
                                                                     rec_.condition_code,
                                                                     rec_.buy_qty_due,
                                                                     rec_.charged_item );
            ELSE
               planned_cost_elements_ := Get_Elements_From_Purch___(rec_.order_no,
                                                                    rec_.line_no,
                                                                    rec_.rel_no,
                                                                    rec_.line_item_no,
                                                                    rec_.contract,
                                                                    rec_.part_no,
                                                                    rec_.vendor_no,
                                                                    rec_.buy_qty_due,
                                                                    rec_.project_id,
                                                                    rec_.charged_item );
            END IF;
         ELSE
            planned_cost_elements_ := Get_Elements_From_Purch___(rec_.contract,
                                                                 rec_.purchase_part_no,
                                                                 rec_.vendor_no,
                                                                 rec_.buy_qty_due,
                                                                 rec_.project_id,
                                                                 rec_.order_no,
                                                                 rec_.line_no,
                                                                 rec_.rel_no,
                                                                 rec_.line_item_no);
         END IF;
      WHEN 'PI' THEN
         -- Project Inventory
         planned_cost_elements_ := Get_Elements_Project_Inv___(rec_, rec_.buy_qty_due);

      WHEN 'PJD' THEN
         -- Project Deliverables
         IF (rec_.charged_item = 'CHARGED ITEM') THEN
            planned_cost_elements_ := Invent_Proj_Cost_Manager_API.Get_Elements_For_Sales_Oh(rec_.contract,
                                                                                             rec_.part_no,
                                                                                             rec_.order_no,
                                                                                             rec_.line_no,
                                                                                             rec_.rel_no,
                                                                                             rec_.line_item_no,
                                                                                             rec_.buy_qty_due );
         END IF;
      WHEN 'PT' THEN
         -- Purch Order Trans
         IF inventory_part_ THEN
            planned_cost_elements_ := Get_Elements_From_Purch___(rec_.order_no,
                                                                 rec_.line_no,
                                                                 rec_.rel_no,
                                                                 rec_.line_item_no,
                                                                 rec_.contract,
                                                                 rec_.part_no,
                                                                 rec_.vendor_no,
                                                                 rec_.buy_qty_due,
                                                                 rec_.project_id,
                                                                 rec_.charged_item );
         ELSE
            planned_cost_elements_ := Get_Elements_From_Purch___(rec_.contract,
                                                                 rec_.purchase_part_no,
                                                                 rec_.vendor_no,
                                                                 rec_.buy_qty_due,
                                                                 rec_.project_id,
                                                                 rec_.order_no,
                                                                 rec_.line_no,
                                                                 rec_.rel_no,
                                                                 rec_.line_item_no);
         END IF;
      WHEN 'IPT' THEN
         -- Int Purch Trans
         IF inventory_part_ THEN
            IF (Site_API.Get_Company(rec_.contract) = Site_API.Get_Company(rec_.supply_site)) THEN
               planned_cost_elements_ := Get_Elements_From_Invent___(rec_.order_no,
                                                                     rec_.line_no,
                                                                     rec_.rel_no,
                                                                     rec_.line_item_no,
                                                                     rec_.contract,
                                                                     rec_.part_no,
                                                                     rec_.condition_code,
                                                                     rec_.buy_qty_due,
                                                                     rec_.charged_item );
            ELSE
               planned_cost_elements_ := Get_Elements_From_Purch___(rec_.order_no,
                                                                    rec_.line_no,
                                                                    rec_.rel_no,
                                                                    rec_.line_item_no,
                                                                    rec_.contract,
                                                                    rec_.part_no,
                                                                    rec_.vendor_no,
                                                                    rec_.buy_qty_due,
                                                                    rec_.project_id,
                                                                    rec_.charged_item );
            END IF;
         ELSE
            planned_cost_elements_ := Get_Elements_From_Purch___(rec_.contract,
                                                                 rec_.purchase_part_no,
                                                                 rec_.vendor_no,
                                                                 rec_.buy_qty_due,
                                                                 rec_.project_id,
                                                                 rec_.order_no,
                                                                 rec_.line_no,
                                                                 rec_.rel_no,
                                                                 rec_.line_item_no);
         END IF;
      WHEN 'ND' THEN
         IF inventory_part_ THEN
            planned_cost_elements_ := Get_Elements_From_Invent___(rec_.order_no,
                                                                  rec_.line_no,
                                                                  rec_.rel_no,
                                                                  rec_.line_item_no,
                                                                  rec_.contract,
                                                                  rec_.part_no,
                                                                  rec_.condition_code,
                                                                  rec_.buy_qty_due,
                                                                  rec_.charged_item );
         ELSE
            planned_cost_elements_ := Get_Elements_Non_Inv___(rec_, rec_.buy_qty_due);
         END IF;
      WHEN 'SO' THEN
         planned_cost_elements_ := Get_Elements_From_Manuf_Ord___(rec_, 'COLSO', rec_.buy_qty_due);
      WHEN 'DOP' THEN
         planned_cost_elements_ := Get_Elements_From_Manuf_Ord___(rec_, 'DOP', rec_.buy_qty_due);
      ELSE
         NULL;
   END CASE;

   RETURN planned_cost_elements_;

END Get_Activity_Planned_Cost___;


-- Get_Elements_From_Invent___
--   Return the planned_cost_elements_ plsql table with project cost elements and
--   cost calculated to be used for non purchase related CO supply options. Uses
--   Inventory cost fetching hierarchy for calculation.
FUNCTION Get_Elements_From_Invent___ (
   order_no_         IN VARCHAR2,
   line_no_          IN VARCHAR2,
   rel_no_           IN VARCHAR2,
   line_item_no_     IN NUMBER,
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   condition_code_   IN VARCHAR2,
   quantity_         IN VARCHAR2,
   charged_item_     IN VARCHAR2 ) RETURN Mpccom_Accounting_API.Project_Cost_Element_Tab
IS
   planned_cost_elements_      Mpccom_Accounting_API.Project_Cost_Element_Tab;
   sales_oh_cost_elements_     Mpccom_Accounting_API.Project_Cost_Element_Tab;
   project_cost_element_tab_   Mpccom_Accounting_API.Project_Cost_Element_Tab;
BEGIN
   project_cost_element_tab_ := Invent_Proj_Cost_Manager_API.Get_Project_Cost_Elements(contract_,
                                                                                       part_no_,
                                                                                       'CUST ORDER',
                                                                                       order_no_,
                                                                                       line_no_,
                                                                                       rel_no_,
                                                                                       line_item_no_,
                                                                                       quantity_,
                                                                                       condition_code_,
                                                                                       TRUE );
   IF (charged_item_ = 'CHARGED ITEM') THEN
      sales_oh_cost_elements_  :=  Invent_Proj_Cost_Manager_API.Get_Elements_For_Sales_Oh(contract_,
                                                                                          part_no_,
                                                                                          order_no_,
                                                                                          line_no_,
                                                                                          rel_no_,
                                                                                          line_item_no_,
                                                                                          quantity_ );
   END IF;
   planned_cost_elements_ := Mpccom_Accounting_API.Get_Merged_Cost_Element_Tab(project_cost_element_tab_,
                                                                               sales_oh_cost_elements_);
   RETURN planned_cost_elements_;

END Get_Elements_From_Invent___;


-- Get_Elements_Non_Inv___
--   Return the project_cost_elements_ plsql table with project cost elements and
--   cost calculated using sales part cost to be used for non-inventory parts.
FUNCTION Get_Elements_Non_Inv___ (
   rec_             IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   quantity_        IN NUMBER ) RETURN Mpccom_Accounting_API.Project_Cost_Element_Tab
IS
   project_cost_elements_      Mpccom_Accounting_API.Project_Cost_Element_Tab;
   sales_part_cost_            NUMBER:=0;
BEGIN
   sales_part_cost_ := Sales_Part_API.Get_Cost(rec_.contract, rec_.catalog_no);

   IF ((quantity_ > 0) AND (NVL(sales_part_cost_, 0) != 0)) THEN

      project_cost_elements_(1).project_cost_element := Mpccom_Accounting_API.Get_Project_Cost_Element (
                                                                                 part_no_            => rec_.catalog_no,
                                                                                 contract_           => rec_.contract,
                                                                                 source_ref_type_db_ => 'CUST ORDER',
                                                                                 source_ref1_        => rec_.order_no,
                                                                                 source_ref2_        => rec_.line_no,
                                                                                 source_ref3_        => rec_.rel_no,
                                                                                 source_ref4_        => rec_.line_item_no,
                                                                                 part_related_       => FALSE);

      project_cost_elements_(1).amount := sales_part_cost_ * quantity_;

   END IF;

   RETURN project_cost_elements_;

END Get_Elements_Non_Inv___;


-- Get_Elements_Project_Inv___
--   Return the project_cost_elements_ plsql table with project cost elements and
--   cost calculated using sales part cost to be used for Project Inventory supply option.
FUNCTION Get_Elements_Project_Inv___ (
   rec_             IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   quantity_        IN NUMBER ) RETURN Mpccom_Accounting_API.Project_Cost_Element_Tab
IS
   project_cost_elements_          Mpccom_Accounting_API.Project_Cost_Element_Tab;
   merged_project_cost_elements_   Mpccom_Accounting_API.Project_Cost_Element_Tab;
   sales_oh_cost_elements_         Mpccom_Accounting_API.Project_Cost_Element_Tab;
   stmt_                           VARCHAR2(2000);
   type_code_db_                   VARCHAR2(2);
   primary_vendor_no_              CUSTOMER_ORDER_LINE_TAB.vendor_no%TYPE;
BEGIN

   type_code_db_ := Inventory_Part_API.Get_Type_Code_Db(rec_.contract, rec_.part_no);

   IF (type_code_db_ IN ('3','4','6')) THEN

      stmt_ :=
      'BEGIN
         :primary_vendor_no_ := Purchase_Part_Supplier_API.Get_Primary_Supplier_No(:contract, :catalog_no);
      END;' ;
      @ApproveDynamicStatement(2009-08-25,RoJalk)
      EXECUTE IMMEDIATE stmt_ USING OUT primary_vendor_no_,
                                    IN  rec_.contract,
                                    IN  rec_.part_no;

      project_cost_elements_ := Get_Elements_From_Purch___(rec_.contract,
                                                           rec_.part_no,
                                                           primary_vendor_no_,
                                                           quantity_,
                                                           rec_.project_id,
                                                           rec_.order_no,
                                                           rec_.line_no,
                                                           rec_.rel_no,
                                                           rec_.line_item_no);
   ELSE
      $IF (Component_Cost_SYS.INSTALLED)$THEN
         DECLARE
            project_cost_elements_tab_      Mpccom_Accounting_API.Project_Cost_Element_Tab;
            empty_tab_                      Mpccom_Accounting_API.Project_Cost_Element_Tab;
         BEGIN
            project_cost_elements_tab_   := Part_Cost_Bucket_One_API.Get_Project_Cost_Elements(
                                                       contract_           => rec_.contract,
                                                       part_no_            => rec_.part_no,
                                                       source_ref_type_db_ => 'CUST ORDER',
                                                       source_ref1_        => rec_.order_no,
                                                       source_ref2_        => rec_.line_no,
                                                       source_ref3_        => rec_.rel_no,
                                                       source_ref4_        => rec_.line_item_no,
                                                       required_qty_       => quantity_,
                                                       supply_option_      => 'PMRP',
                                                       activity_seq_       => rec_.activity_seq);

            Invent_Proj_Cost_Manager_API.Fill_Project_Cost_Element_Tmp(project_cost_elements_tab_,
                                                                       empty_tab_,
                                                                       empty_tab_,
                                                                       empty_tab_);
         END;

         project_cost_elements_ := Invent_Proj_Cost_Manager_API.Get_From_Temporary_Table();
      $ELSE
         NULL;
      $END
   END IF;

   IF (rec_.charged_item = 'CHARGED ITEM') THEN
      sales_oh_cost_elements_       :=  Invent_Proj_Cost_Manager_API.Get_Elements_For_Sales_Oh(rec_.contract,
                                                                                               rec_.part_no,
                                                                                               rec_.order_no,
                                                                                               rec_.line_no,
                                                                                               rec_.rel_no,
                                                                                               rec_.line_item_no,
                                                                                               quantity_ );
   END IF;


   merged_project_cost_elements_ := Mpccom_Accounting_API.Get_Merged_Cost_Element_Tab(project_cost_elements_,
                                                                                      sales_oh_cost_elements_);

   RETURN merged_project_cost_elements_;

END Get_Elements_Project_Inv___;


-- Diff_Proj_Exist___
--   Return TRUE if order already have order lines connected to other projects else return FALSE.
FUNCTION Diff_Proj_Exist___ (
   order_no_     IN VARCHAR2,
   project_id_   IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_        NUMBER;
   CURSOR get_diff_proj IS
      SELECT 1
      FROM  CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = order_no_
      AND   project_id != project_id_
      AND   project_id IS NOT NULL;
BEGIN
   OPEN get_diff_proj;
   FETCH get_diff_proj INTO dummy_;
   IF (get_diff_proj%FOUND) THEN
      CLOSE get_diff_proj;
      RETURN TRUE;
   END IF;
   CLOSE get_diff_proj;

   RETURN FALSE;

END Diff_Proj_Exist___;


-- Project_Connection_Exist___
--   Checks for a project connection.Connection could be a Customer Order Revenue connection
--   or a Customer Order Line depending on the proj_lu_name_ parameter.
FUNCTION Project_Connection_Exist___ (
   order_no_       IN VARCHAR2,
   line_no_        IN VARCHAR2,
   rel_no_         IN VARCHAR2,
   line_item_no_   IN NUMBER,
   activity_seq_   IN NUMBER,
   proj_lu_name_   IN VARCHAR2 ) RETURN VARCHAR2
IS
   exist_connection_   VARCHAR2(5) := 'FALSE';
BEGIN
   $IF (Component_Proj_SYS.INSTALLED)$THEN
      exist_connection_ := Project_Connection_Util_API.Exist_Project_Connection(activity_seq_,
                                                                                order_no_,
                                                                                line_no_,
                                                                                rel_no_,
                                                                                line_item_no_,
                                                                                NULL,
                                                                                NULL,
                                                                                proj_lu_name_);
   $END

   RETURN exist_connection_;

END Project_Connection_Exist___;


-- Remove_Project_Connection___
--   Removes the project connection for a given order line reference. Removes both Customer
--   Order Revenue connection and Customer Order Line connection.
PROCEDURE Remove_Project_Connection___ (
   order_no_          IN VARCHAR2,
   line_no_           IN VARCHAR2,
   rel_no_            IN VARCHAR2,
   line_item_no_      IN NUMBER,
   old_activity_seq_  IN NUMBER )
IS
   rec_   CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   exist_component_lines_        NUMBER := 0;
  
   CURSOR exist_component_lines IS
     SELECT  1
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  rowstate     != 'Cancelled'
      AND    line_item_no != line_item_no_
      AND    line_item_no > 0
      AND    rel_no       = rel_no_
      AND    line_no      = line_no_
      AND    order_no     = order_no_;
BEGIN

   IF line_item_no_ > 0 THEN
      OPEN exist_component_lines;
      FETCH exist_component_lines INTO exist_component_lines_;
      CLOSE exist_component_lines;
   END IF;
   IF exist_component_lines_ = 0 THEN
      rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
     
      Pre_Accounting_API.Remove_Proj_Pre_Posting(rec_.pre_accounting_id,
                                                 rec_.contract,
                                                 'M104',
                                                 TRUE);

   END IF;
   Connect_Customer_Order_API.Remove_Project_Connection(order_no_,
                                                        line_no_,
                                                        rel_no_,
                                                        line_item_no_,
                                                        old_activity_seq_ );

END Remove_Project_Connection___;


-- Calculate_Revenue___
--   Creates the project - Customer Order Revenue connection and report the revenue.
PROCEDURE Calculate_Revenue___ (
   order_no_              IN  VARCHAR2,
   line_no_               IN  VARCHAR2,
   rel_no_                IN  VARCHAR2,
   line_item_no_          IN  NUMBER)
IS
   activity_info_tab_         Public_Declarations_API.PROJ_Project_Conn_Cost_Tab;
   activity_revenue_info_tab_ Public_Declarations_API.PROJ_Project_Conn_Revenue_Tab;
   attributes_                Public_Declarations_API.PROJ_Project_Conn_Attr_Type;
BEGIN
   $IF Component_Proj_SYS.INSTALLED $THEN
      Refresh_Project_Connection (activity_info_tab_         => activity_info_tab_,
                                  activity_revenue_info_tab_ => activity_revenue_info_tab_,
                                  attributes_                => attributes_,
                                  activity_seq_              => NULL,
                                  keyref1_                   => order_no_,
                                  keyref2_                   => line_no_,
                                  keyref3_                   => rel_no_,
                                  keyref4_                   => line_item_no_,
                                  keyref5_                   => '*',
                                  keyref6_                   => '*',
                                  refresh_old_data_          => 'FALSE',
                                  proj_lu_name_              => 'COLINEREV');
   $ELSE
       NULL;
   $END
END Calculate_Revenue___;


-- Update_Proj_Ms_Forecast___
--   Updates Project Master Scheduling when qty is delivered or returned.
PROCEDURE Update_Proj_Ms_Forecast___ (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   qty_shipped_      IN NUMBER,
   planned_due_date_ IN DATE,
   activity_seq_     IN NUMBER )
IS
BEGIN
   $IF (Component_Massch_SYS.INSTALLED)$THEN
      IF (NVL(activity_seq_, 0) > 0) THEN
         -- Update PMPS forecast consumption
         Level_1_Forecast_Util_API.Shipment_Update(contract_, part_no_, activity_seq_, qty_shipped_, planned_due_date_, FALSE );
      END IF;
   $ELSE
      NULL;
   $END
END Update_Proj_Ms_Forecast___;


-- Is_External_Service_Order___
--   This method checks external service order.
FUNCTION Is_External_Service_Order___ (
   demand_code_       IN VARCHAR2,
   demand_order_ref1_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   external_service_order_   VARCHAR2(5) := 'FALSE';
   order_code_               VARCHAR2(20);
BEGIN
   $IF Component_Purch_SYS.INSTALLED $THEN
      IF ((NVL(demand_code_, Database_SYS.string_null_) = 'PO') AND (demand_order_ref1_ IS NOT NULL)) THEN
         order_code_ := Purchase_Order_API.Get_Order_Code(demand_order_ref1_);
         IF (order_code_ = 6) THEN
            external_service_order_ := 'TRUE';
         END IF;
      END IF;
   $END

   RETURN external_service_order_;
END Is_External_Service_Order___;


PROCEDURE Check_Demand_Code___ (
   demand_code_         IN VARCHAR2,
   confirm_deliveries_  IN VARCHAR2,
   consignment_stock_   IN VARCHAR2 )
IS
BEGIN

   IF (NVL(demand_code_, '*') = Order_Supply_Type_API.DB_COMPONENT_REPAIR_EXCHANGE) THEN
      IF (confirm_deliveries_ = 'TRUE') THEN
         Error_SYS.Record_General(lu_name_, 'NO_PARTEXCH: Delivery confirmation cannot be handled for Part Exchange CRO lines.');
      ELSIF (consignment_stock_ = 'CONSIGNMENT STOCK') THEN
         Error_SYS.Record_General(lu_name_, 'NO_CON_STOCK: Customer Consignment Stock cannot be handled for Part Exchange CRO lines.');
      END IF;
   END IF;

END Check_Demand_Code___;


-- Prepare_Rental___
--   This method prepares default values to rental attrbutes.
PROCEDURE Prepare_Rental___ (
   attr_ IN OUT VARCHAR2)
IS
BEGIN

   Client_SYS.Add_To_Attr('PART_OWNERSHIP', Part_Ownership_API.Decode(Part_Ownership_API.DB_COMPANY_RENTAL_ASSET), attr_);

   $IF Component_Rental_SYS.INSTALLED $THEN
      Rental_Object_API.Prepare(attr_,
                                Rental_Type_API.DB_CUSTOMER_ORDER);
   $END
END Prepare_Rental___;

-- New_Rental___
--   This method inserts a new rental record.
PROCEDURE New_Rental___ (
   attr_   IN VARCHAR2,
   newrec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE)
IS
BEGIN
   $IF Component_Rental_SYS.INSTALLED $THEN
      Rental_Object_API.New(newrec_.order_no,
                            newrec_.line_no,
                            newrec_.rel_no,
                            newrec_.line_item_no,
                            Rental_Type_API.DB_CUSTOMER_ORDER,
                            newrec_.contract,
                            attr_);
   $ELSE
      Error_SYS.Component_Not_Exist('RENTAL');
   $END
END New_Rental___;


-- Modify_Rental___
--   This method modifies a rental record.
PROCEDURE Modify_Rental___ (
   attr_   IN VARCHAR2,
   newrec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE)
IS
BEGIN
    $IF Component_Rental_SYS.INSTALLED $THEN
       Rental_Object_API.Modify(newrec_.order_no,
                                newrec_.line_no,
                                newrec_.rel_no,
                                newrec_.line_item_no,
                                Rental_Type_API.DB_CUSTOMER_ORDER,
                                attr_);
    $ELSE
       Error_SYS.Component_Not_Exist('RENTAL');
    $END
END Modify_Rental___;


-- Remove_Rental___
--   This method removes a rental record.
PROCEDURE Remove_Rental___ (
   remrec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE)
IS
BEGIN
   $IF Component_Rental_SYS.INSTALLED $THEN
      Rental_Object_API.Remove(remrec_.order_no,
                               remrec_.line_no,
                               remrec_.rel_no,
                               remrec_.line_item_no,
                               Rental_Type_API.DB_CUSTOMER_ORDER);
   $ELSE
      Error_SYS.Component_Not_Exist('RENTAL');
   $END
END Remove_Rental___;


PROCEDURE Add_Rental_Info_To_Attr___ (
   attr_         IN OUT NOCOPY VARCHAR2,
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER )
IS
   order_rec_              Customer_Order_API.Public_Rec;
   
BEGIN
   $IF (Component_Rental_SYS.INSTALLED) $THEN
      order_rec_ := Customer_Order_API.Get(order_no_);
      Rental_Object_Manager_API.Add_Rental_Info_To_Attr(attr_,
                                                        Rental_Object_API.Get_Rental_No(order_no_,
                                                                                        line_no_,
                                                                                        rel_no_,
                                                                                        line_item_no_,
                                                                                        Rental_Type_API.DB_CUSTOMER_ORDER));
   $ELSE
      Error_SYS.Component_Not_Exist('RENTAL');
   $END   
END Add_Rental_Info_To_Attr___;


-- Get_Latest_Rent_Charge_Days___
--   This method calculates and return rental chargable days
--   from the modified rental attribute value
FUNCTION Get_Latest_Rent_Charge_Days___ (
   attr_    IN VARCHAR2,
   newrec_  IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE) RETURN NUMBER
IS
   rental_chargeable_days_ NUMBER;
BEGIN
   $IF Component_Rental_SYS.INSTALLED $THEN
      rental_chargeable_days_ := Rental_Object_API.Get_Rental_Chargeable_Days(newrec_.order_no,
                                                                              newrec_.line_no,
                                                                              newrec_.rel_no,
                                                                              newrec_.line_item_no,
                                                                              Rental_Type_API.DB_CUSTOMER_ORDER,
                                                                              attr_);
   $END
   RETURN NVL(rental_chargeable_days_, 1);
END Get_Latest_Rent_Charge_Days___;

-- Get_Rental_Chargeable_Days___
--   This method calculates and return rental chargeable days
--   for given rental references. This method should be used after checking the given order lines is a rental line.
--   Otherwise Get_Rental_Chargeable_Days public method must be used.
FUNCTION Get_Rental_Chargeable_Days___ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   rental_chargeable_days_ NUMBER;
BEGIN
   $IF Component_Rental_SYS.INSTALLED $THEN
      rental_chargeable_days_ := Rental_Object_API.Get_Rental_Chargeable_Days(order_no_,
                                                                              line_no_,
                                                                              rel_no_,
                                                                              line_item_no_,
                                                                              Rental_Type_API.DB_CUSTOMER_ORDER);
   $END
   RETURN rental_chargeable_days_;
END Get_Rental_Chargeable_Days___;


PROCEDURE Validate_Pack_Instr_Id___ (
   attr_   IN OUT VARCHAR2,
   newrec_ IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   oldrec_ IN     CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
BEGIN
   IF (newrec_.shipment_type IS NULL AND NVL(newrec_.packing_instruction_id, Database_Sys.string_null_) = NVL(oldrec_.packing_instruction_id, Database_Sys.string_null_)
       AND newrec_.packing_instruction_id IS NOT NULL AND newrec_.shipment_connected = 'FALSE') THEN
      newrec_.packing_instruction_id := NULL;
      Client_SYS.Add_To_Attr('PACKING_INSTRUCTION_ID', newrec_.packing_instruction_id, attr_);
   END IF;

   IF (newrec_.shipment_type IS NULL AND newrec_.packing_instruction_id IS NOT NULL AND newrec_.shipment_connected = 'FALSE') THEN
      Error_SYS.Record_General(lu_name_, 'PACKINSTRIDNOTALLOWED: Packing Instruction cannot have a value when shipment type is NULL.');
   END IF;

   IF (newrec_.shipment_connected = 'FALSE' AND newrec_.shipment_type IS NOT NULL) THEN
      IF ((NVL(newrec_.ship_addr_no, Database_Sys.string_null_) != NVL(oldrec_.ship_addr_no, Database_Sys.string_null_)) AND
          NVL(newrec_.packing_instruction_id, Database_Sys.string_null_) = NVL(oldrec_.packing_instruction_id, Database_Sys.string_null_)) THEN
         newrec_.packing_instruction_id := Def_Pack_Instruct_Shipment_API.Get_Packing_Instruction_Id(newrec_.contract, newrec_.catalog_no, newrec_.customer_no, newrec_.ship_addr_no);
         IF (newrec_.packing_instruction_id IS NULL AND oldrec_.packing_instruction_id IS NOT NULL) THEN
            newrec_.packing_instruction_id := oldrec_.packing_instruction_id;
         END IF;
         Client_SYS.Add_To_Attr('PACKING_INSTRUCTION_ID', newrec_.packing_instruction_id, attr_);
      ELSE
         IF ((NVL(newrec_.addr_flag, Database_Sys.string_null_) != NVL(oldrec_.addr_flag, Database_Sys.string_null_)) AND
             (NVL(newrec_.packing_instruction_id, Database_Sys.string_null_) = NVL(oldrec_.packing_instruction_id, Database_Sys.string_null_))) THEN
            IF (newrec_.addr_flag = 'Y' AND oldrec_.addr_flag = 'N') THEN
               newrec_.packing_instruction_id := Def_Pack_Instruct_Shipment_API.Get_Packing_Instruction_Id(newrec_.contract, newrec_.catalog_no, newrec_.customer_no, NULL);
               Client_SYS.Add_To_Attr('PACKING_INSTRUCTION_ID', newrec_.packing_instruction_id, attr_);
            ELSE
               IF (newrec_.addr_flag = 'N' AND oldrec_.addr_flag = 'Y') THEN
                  newrec_.packing_instruction_id := Def_Pack_Instruct_Shipment_API.Get_Packing_Instruction_Id(newrec_.contract, newrec_.catalog_no, newrec_.customer_no, newrec_.ship_addr_no);
                  Client_SYS.Add_To_Attr('PACKING_INSTRUCTION_ID', newrec_.packing_instruction_id, attr_);
               END IF;
            END IF;
         END IF;
      END IF;
   END IF;

   IF (newrec_.shipment_connected = 'FALSE' AND newrec_.shipment_type IS NOT NULL AND oldrec_.shipment_type IS NULL AND
       NVL(newrec_.packing_instruction_id, Database_Sys.string_null_) = NVL(oldrec_.packing_instruction_id, Database_Sys.string_null_)) THEN
      IF (newrec_.addr_flag = 'Y') THEN
         newrec_.packing_instruction_id := Def_Pack_Instruct_Shipment_API.Get_Packing_Instruction_Id(newrec_.contract, newrec_.catalog_no, newrec_.customer_no, NULL);
         Client_SYS.Add_To_Attr('PACKING_INSTRUCTION_ID', newrec_.packing_instruction_id, attr_);
      ELSE
         newrec_.packing_instruction_id := Def_Pack_Instruct_Shipment_API.Get_Packing_Instruction_Id(newrec_.contract, newrec_.catalog_no, newrec_.customer_no, newrec_.ship_addr_no);
         Client_SYS.Add_To_Attr('PACKING_INSTRUCTION_ID', newrec_.packing_instruction_id, attr_);
      END IF;
   END IF;

   IF (NVL(newrec_.packing_instruction_id, Database_Sys.string_null_) != NVL(oldrec_.packing_instruction_id, Database_Sys.string_null_) AND
      (newrec_.packing_instruction_id IS NOT NULL)) THEN
      Part_Handling_Unit_API.Check_Combination(newrec_.catalog_no,
                                               newrec_.sales_unit_meas,
                                               newrec_.packing_instruction_id);
   END IF;
END Validate_Pack_Instr_Id___;


PROCEDURE Close_Financial_Project___ (
   company_ IN VARCHAR2,
   job_id_  IN VARCHAR2 )
IS
BEGIN
   $IF Component_Genled_SYS.INSTALLED $THEN
      Accounting_Project_Util_API.Co_Finally_Invoiced(company_, job_id_);
   $ELSE
      Error_SYS.Component_Not_Exist('GENLED');
   $END
END Close_Financial_Project___;


PROCEDURE Do_Set_Qty_Assigned___ (
   rec_  IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
   qty_assigned_  NUMBER;
BEGIN
   qty_assigned_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('QTY_ASSIGNED', attr_));
   Modify_Qty_Assigned__(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no, qty_assigned_);
   rec_ := Get_Object_By_Keys___(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
END Do_Set_Qty_Assigned___;


PROCEDURE Do_Set_Qty_Shipped___ (
   rec_  IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
   qty_shipped_  NUMBER;
BEGIN
   qty_shipped_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('QTY_SHIPPED', attr_));
   Modify_Qty_Shipped__(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no, qty_shipped_);
   rec_ := Get_Object_By_Keys___(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
END Do_Set_Qty_Shipped___;


PROCEDURE Do_Set_Qty_Invoiced___ (
   rec_  IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
   qty_invoiced_  NUMBER;
BEGIN
   qty_invoiced_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('QTY_INVOICED', attr_));
   Modify_Qty_Invoiced__(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no, qty_invoiced_);
   rec_ := Get_Object_By_Keys___(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
END Do_Set_Qty_Invoiced___;


PROCEDURE Do_Set_Qty_Shipdiff___ (
   rec_  IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
   qty_shipdiff_  NUMBER;
BEGIN
   qty_shipdiff_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('QTY_SHIPDIFF', attr_));
   Modify_Qty_Shipdiff__(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no, qty_shipdiff_);
   rec_ := Get_Object_By_Keys___(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
END Do_Set_Qty_Shipdiff___;


PROCEDURE Do_Set_Qty_Picked___ (
   rec_  IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
   qty_picked_  NUMBER;
BEGIN
   qty_picked_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('QTY_PICKED', attr_));
   Modify_Qty_Picked__(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no, qty_picked_);
   rec_ := Get_Object_By_Keys___(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
END Do_Set_Qty_Picked___;


PROCEDURE Do_Undo_Delivery___ (
   rec_  IN OUT NOCOPY customer_order_line_tab%ROWTYPE,
   attr_ IN OUT NOCOPY VARCHAR2 )
IS
   deliv_no_  NUMBER;
BEGIN
   deliv_no_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('DELIV_NO', attr_));
   Undo_Cust_Ord_Delivery_API.Undo_Cust_Ord_Line_Delivery__(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no, deliv_no_);
   rec_      := Get_Object_By_Keys___(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
END Do_Undo_Delivery___;


-- Check_Delivery_Confirmed___
--   If not using Delivery Confirmation, the order line has to be set to confirmed when Delivered.
--   This action is triggered when going from Picked or PartiallyDelivered to Delivered.
PROCEDURE Check_Delivery_Confirmed___ (
   rec_  IN     CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
   lineattr_  VARCHAR2(2000);
BEGIN
   IF (rec_.delivery_confirmed = 'FALSE') THEN
      IF (CUSTOMER_ORDER_API.Get_Confirm_Deliveries_Db(rec_.order_no) = 'FALSE') THEN
         Client_SYS.Clear_Attr(lineattr_);
         Client_SYS.Add_To_Attr('DELIVERY_CONFIRMED_DB', 'TRUE', lineattr_);
         Modify(lineattr_, rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
      END IF;
   END IF;
END Check_Delivery_Confirmed___;


PROCEDURE Do_Set_Qty_Confirmeddiff___ (
   rec_  IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
   qty_confirmeddiff_  NUMBER;
BEGIN
   qty_confirmeddiff_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('QTY_CONFIRMEDDIFF', attr_));
   Modify_Qty_Confirmeddiff__(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no, qty_confirmeddiff_);
   rec_ := Get_Object_By_Keys___(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
END Do_Set_Qty_Confirmeddiff___;


PROCEDURE Do_Set_Pkg_Header_State___ (
   rec_  IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
   rec_pkg_      CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
BEGIN
   -- IF package component, send message to package header.
   --Finite_State_Set is called here since it is quite difficult to model this within Finite_State_Machine.
   IF ((rec_.qty_shipped != 0) AND (rec_.line_item_no > 0)) THEN
       rec_pkg_ := Get_Object_By_Keys___(rec_.order_no, rec_.line_no, rec_.rel_no, -1);
       Finite_State_Set___(rec_pkg_, 'PartiallyDelivered');
   END IF;
END Do_Set_Pkg_Header_State___;


PROCEDURE Do_Uninvoice_Pkg_Component___ (
   rec_  IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
   pkg_invoiced_qty_ NUMBER;
   cancelled_pkg_comp_qty_    NUMBER;
   no_of_cancelled_pkgs_      NUMBER;
   
   CURSOR get_pkg_comp IS
      SELECT order_no, line_no, rel_no, line_item_no, qty_per_assembly, revised_qty_due,
             conv_factor, inverted_conv_factor, rowstate, qty_invoiced
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = rec_.order_no
      AND line_no = rec_.line_no
      AND rel_no = rec_.rel_no
      AND line_item_no > 0
      AND rowstate != 'Cancelled'
      AND qty_invoiced > 0;
BEGIN
   IF (rec_.line_item_no = -1) THEN
      pkg_invoiced_qty_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('QTY_INVOICED', attr_));
      no_of_cancelled_pkgs_ := rec_.qty_invoiced - pkg_invoiced_qty_;
      
      FOR comp_rec_ IN get_pkg_comp LOOP
         cancelled_pkg_comp_qty_ :=  no_of_cancelled_pkgs_ * (comp_rec_.revised_qty_due / rec_.revised_qty_due) / comp_rec_.conv_factor * comp_rec_.inverted_conv_factor;
         Set_Uninvoiced(comp_rec_.order_no, comp_rec_.line_no, comp_rec_.rel_no, comp_rec_.line_item_no, (comp_rec_.qty_invoiced - cancelled_pkg_comp_qty_));
      END LOOP;   
   END IF;   
END Do_Uninvoice_Pkg_Component___;


PROCEDURE Do_Uninvoice_Pkg_Head_State___ (
   rec_  IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   attr_ IN OUT VARCHAR2 )
IS
   pkg_line_rec_ CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
BEGIN 
   IF (rec_.line_item_no > 0) THEN
      pkg_line_rec_ := Get_Object_By_Keys___(rec_.order_no, rec_.line_no, rec_.rel_no, -1);
      IF (pkg_line_rec_.rowstate = 'Invoiced' AND pkg_line_rec_.qty_invoiced = 0) THEN
         Finite_State_Set___(pkg_line_rec_, 'Delivered');
      END IF;   
   END IF;   
END  Do_Uninvoice_Pkg_Head_State___;   


PROCEDURE Do_Nothing___ (
   rec_  IN OUT NOCOPY customer_order_line_tab%ROWTYPE,
   attr_ IN OUT NOCOPY VARCHAR2 )
IS
BEGIN
   NULL;
END Do_Nothing___;


FUNCTION Is_Any_Delivery_Exist___ (
   rec_  IN     customer_order_line_tab%ROWTYPE ) RETURN BOOLEAN
IS
   CURSOR check_delivered_comp_exist IS
      SELECT 1
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = rec_.order_no
      AND line_no = rec_.line_no
      AND rel_no = rec_.rel_no
      AND line_item_no > 0
      AND rowstate IN ('PartiallyDelivered', 'Delivered');
   
   found_ NUMBER;
BEGIN
   IF (rec_.qty_shipped != 0) THEN
      RETURN TRUE;
   ELSE
      IF (rec_.line_item_no = -1) THEN
         OPEN check_delivered_comp_exist;
         FETCH check_delivered_comp_exist INTO found_;
         CLOSE check_delivered_comp_exist;
         
         IF (found_ = 1) THEN
            RETURN TRUE;
         ELSE
            RETURN FALSE;
         END IF;  
      ELSE
        RETURN FALSE;
      END IF;
   END IF;
END Is_Any_Delivery_Exist___;    


FUNCTION Line_Is_Fully_Invoiced___ (
   rec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE ) RETURN BOOLEAN
IS
   header_rec_       CUSTOMER_ORDER_API.Public_Rec;
   ordering_company_ VARCHAR2(20);

   CURSOR get_non_invoiced_packages IS
      SELECT 1
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = rec_.order_no
      AND line_no = rec_.line_no
      AND rel_no = rec_.rel_no
      AND line_item_no > 0
      AND rental = Fnd_Boolean_API.DB_FALSE
      AND rowstate NOT IN ('Invoiced', 'Cancelled');

   found_  NUMBER := 0;
BEGIN
   -- For work order returns, when the Customer Order line is created, state machine should not proceed forward.
   IF ((rec_.rowstate = 'Released') AND (rec_.revised_qty_due < 0) AND (rec_.supply_code = 'SEO')) THEN
      RETURN FALSE;
   END IF; 
   
  IF (rec_.rental = Fnd_Boolean_API.DB_FALSE) THEN
     -- Used to distinguish Staged Billings.
     IF ((rec_.qty_invoiced > 0) AND (rec_.qty_shipped = 0)) THEN
        IF NOT Line_Is_Fully_Delivered___(rec_) THEN
           RETURN FALSE;
        END IF;
     END IF;
     IF (rec_.line_item_no = -1) THEN   -- this is a Package header
         OPEN get_non_invoiced_packages;
         FETCH get_non_invoiced_packages INTO found_;

         IF get_non_invoiced_packages%FOUND THEN
            CLOSE get_non_invoiced_packages;
            RETURN FALSE;
         END  IF;
         CLOSE get_non_invoiced_packages;
      END IF;

      header_rec_ := CUSTOMER_ORDER_API.Get(rec_.order_no);

      -- IF the line should not be charged it should be closed when fully delivered
      IF (rec_.charged_item = 'ITEM NOT CHARGED') THEN
         RETURN(Line_Is_Fully_Delivered___(rec_));
      END IF;

      -- IF the line is Customer Owned or Supplier loaned it should be closed when fully delivered
      IF (rec_.part_ownership IN ('CUSTOMER OWNED', 'SUPPLIER LOANED')) THEN       
         RETURN(Line_Is_Fully_Delivered___(rec_));
      END IF;
      
      IF (rec_.part_ownership IN ('COMPANY OWNED') AND (rec_.demand_code = Order_Supply_Type_API.DB_COMPONENT_REPAIR_EXCHANGE)
         AND (rec_.supply_code = Order_Supply_Type_API.DB_COMPONENT_REPAIR_ORDER)) THEN
         RETURN(Line_Is_Fully_Delivered___(rec_));   
      END IF;

      -- IF the line is for an exchange item it should be closed when fully delivered.
      IF (rec_.exchange_item = 'EXCHANGED ITEM') THEN
         RETURN(Line_Is_Fully_Delivered___(rec_));
      END IF;

      -- IF the header is connected to a sales contract it should be closed when fully delivered.
      IF (header_rec_.sales_contract_no IS NOT NULL) THEN
         RETURN(Line_Is_Fully_Delivered___(rec_));
      END IF;

      ordering_company_ :=  Site_API.Get_Company(header_rec_.contract);

      IF ((Site_API.Get_Company(Cust_Ord_Customer_API.Get_Contract_From_Customer_No(header_rec_.customer_no)) = ordering_company_)
         OR (Site_API.Get_Company(Cust_Ord_Customer_API.Get_Contract_From_Customer_No(header_rec_.customer_no_pay))= ordering_company_)) THEN
         RETURN (Line_Is_Fully_Delivered___(rec_));
      END IF;

      -- Not an internal order
      IF (rec_.buy_qty_due >= 0) THEN
         RETURN (ROUND((rec_.qty_invoiced - rec_.qty_confirmeddiff), 10) >= TRUNC(rec_.buy_qty_due + (rec_.qty_shipdiff / rec_.conv_factor * rec_.inverted_conv_factor), 10));
      ELSE
         -- Buy qty due may be negative for service order lines
         RETURN (ROUND((rec_.qty_invoiced - rec_.qty_confirmeddiff), 10) <= TRUNC(rec_.buy_qty_due + (rec_.qty_shipdiff / rec_.conv_factor * rec_.inverted_conv_factor), 10));
      END IF;
   ELSE
       RETURN Rental_Is_Completed___(rec_);
   END IF;
END Line_Is_Fully_Invoiced___;

-- Rental_Is_Completed___
-- Rental line is considered fully invoiced when
-- 1. all rental transactions for the line are invoiced and no transactions are due to be created for the existing rental events.
-- 2. all delivered items are returned.
-- 3. If the order line has replacement orders, they are fully returned.
FUNCTION Rental_Is_Completed___ (
   rec_  IN  customer_order_line_tab%ROWTYPE ) RETURN BOOLEAN
IS
   rental_no_                NUMBER;
   ro_fully_returned_        BOOLEAN:= TRUE;
   inter_site_intra_company_ BOOLEAN := FALSE;

   $IF Component_Rental_SYS.INSTALLED $THEN
      CURSOR get_replacement_orders(parent_rental_no_ NUMBER) IS
         SELECT order_no, line_no, rel_no, line_item_no
         FROM  CUSTOMER_ORDER_LINE_TAB, RENTAL_OBJECT_PUB
         WHERE demand_code IN ('RCO', 'IPT_RO')
         AND   order_no          = order_ref1
         AND   line_no           = order_ref2
         AND   rel_no            = order_ref3
         AND   line_item_no      = order_ref4
         AND   rental            = 'TRUE'
         AND   rental_type_db    = 'CUST ORDER'
         AND   primary_rental_no = parent_rental_no_;
   $END
BEGIN
   IF (rec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
      IF (rec_.qty_shipped = 0) THEN
         RETURN FALSE;
      END IF;
      IF (NVL(rec_.demand_code, Database_SYS.string_null_) NOT IN (Order_Supply_Type_API.DB_REPLACEMENT_CUSTOMER_ORDER,
                                                                   Order_Supply_Type_API.DB_INT_PURCH_REPLACEMENT_ORDER)) THEN
         rental_no_ := Get_Rental_No(rec_.order_no,
                                     rec_.line_no,
                                     rec_.rel_no,
                                     rec_.line_item_no);
         $IF Component_Rental_SYS.INSTALLED $THEN
            -- Checks whether connected replacement orders fully returned.
            FOR replacement_ord_rec_ IN get_replacement_orders(rental_no_) LOOP
               IF (Return_Material_Line_API.Cal_Qty_To_Return_Sales_Uom(replacement_ord_rec_.order_no, replacement_ord_rec_.line_no, replacement_ord_rec_.rel_no, replacement_ord_rec_.line_item_no) != 0) THEN
                  ro_fully_returned_ := FALSE;
                  EXIT;
               END IF;
            END LOOP;

            IF (rec_.demand_code = 'IPT') AND
                (Site_API.Get_Company(Cust_Ord_Customer_API.Get_Acquisition_Site(rec_.customer_no)) = Site_API.Get_Company(rec_.contract)) THEN
               inter_site_intra_company_ :=  TRUE;
            END IF;

            IF (inter_site_intra_company_) THEN
               -- Inter-site, intra-company lines are not invoiced, we don't use the extra validation here.
               RETURN (Return_Material_Line_API.Cal_Qty_To_Return_Sales_Uom(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no) = 0) AND
                  ro_fully_returned_;
            ELSE
               RETURN (Rental_Transaction_Manager_API.Fully_Invoiced(rental_no_, ignore_invoice_date_ => TRUE) AND
                   (Return_Material_Line_API.Cal_Qty_To_Return_Sales_Uom(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no) = 0) AND
                   ro_fully_returned_);
            END IF;
         $ELSE
            RETURN FALSE;
         $END
      ELSE
         RETURN (Line_Is_Fully_Delivered___(rec_));
      END IF;
   END IF;
   RETURN FALSE;
END Rental_Is_Completed___;


FUNCTION Line_Is_Reserved___ (
   rec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE ) RETURN BOOLEAN
IS
   CURSOR get_package IS
      SELECT 1
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = rec_.order_no
      AND line_no = rec_.line_no
      AND rel_no = rec_.rel_no
      AND line_item_no > 0
      AND (qty_assigned > 0 OR qty_shipped > 0);
   found_  NUMBER := 0;
BEGIN
   IF (rec_.line_item_no = -1) THEN
      -- Package header
      OPEN get_package;
      FETCH get_package INTO found_;
      CLOSE get_package;
      RETURN (found_ = 1);
   ELSE
      RETURN (rec_.qty_assigned > 0);
   END IF;
END Line_Is_Reserved___;


FUNCTION Line_Is_Picked___ (
   rec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE ) RETURN BOOLEAN
IS
   CURSOR get_package IS
      SELECT 1
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = rec_.order_no
      AND line_no = rec_.line_no
      AND rel_no = rec_.rel_no
      AND line_item_no > 0
      AND (qty_picked > 0 OR qty_shipped > 0);
   found_  NUMBER := 0;
BEGIN
   IF (rec_.line_item_no = -1) THEN
      -- Package header
      OPEN get_package;
      FETCH get_package INTO found_;
      CLOSE get_package;
      RETURN (found_ = 1);
   ELSE
      RETURN (rec_.qty_picked > 0);
   END IF;
END Line_Is_Picked___;


FUNCTION Line_Is_Fully_Delivered___ (
   rec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE ) RETURN BOOLEAN
IS
   CURSOR get_undelivered_components IS
      SELECT 1
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = rec_.order_no
      AND line_no = rec_.line_no
      AND rel_no = rec_.rel_no
      AND line_item_no > 0
      AND rowstate NOT IN ('Invoiced', 'Cancelled', 'Delivered');
   found_ NUMBER;
BEGIN
   IF (rec_.line_item_no = -1) THEN
      -- Package header, check if all components have been delivered
      OPEN get_undelivered_components;
      FETCH get_undelivered_components INTO found_;
      IF (get_undelivered_components%NOTFOUND) THEN
         found_ := 0;
      END IF;
      CLOSE get_undelivered_components;

      IF (found_ = 1) THEN
         -- Not fully delivered component lines exist
         RETURN FALSE;
      ELSE
         RETURN ((rec_.qty_shipped - rec_.qty_shipdiff) >= rec_.revised_qty_due);
      END IF;
   ELSE
      -- Normal line or package component line
      RETURN ((rec_.qty_shipped - rec_.qty_shipdiff) >= rec_.revised_qty_due);
   END IF;
END Line_Is_Fully_Delivered___;

--------------------------------------------------------------------------------------------
-- Get_Elements_From_Manuf_Ord___
--    Return the project_cost_elements_ plsql table with project cost elements and
--    cost calculated using sales part cost to be used for Shop Order and DOP supply options.
--------------------------------------------------------------------------------------------
FUNCTION Get_Elements_From_Manuf_Ord___ (
   rec_              IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   supply_option_    IN VARCHAR2,
   quantity_         IN NUMBER ) RETURN Mpccom_Accounting_API.Project_Cost_Element_Tab
IS
   inv_part_rec_                    Inventory_Part_API.Public_Rec;
   project_cost_elements_tab_       Mpccom_Accounting_API.Project_Cost_Element_Tab;
   empty_tab_                       Mpccom_Accounting_API.Project_Cost_Element_Tab;
   interim_header_id_               VARCHAR2(12);
   project_cost_elements_           Mpccom_Accounting_API.Project_Cost_Element_Tab;
   merged_project_cost_elements_    Mpccom_Accounting_API.Project_Cost_Element_Tab;
   sales_oh_cost_elements_          Mpccom_Accounting_API.Project_Cost_Element_Tab;
   so_order_no_                     customer_order_shop_order_tab.so_order_no%TYPE;
   so_release_no_                   customer_order_shop_order_tab.so_release_no%TYPE;
   so_sequence_no_                  customer_order_shop_order_tab.so_sequence_no%TYPE;
BEGIN
   IF supply_option_ = 'COLSO' THEN
      -- If Shop order is project connected, we can fetch the cost from Shop_Order_Project_Cost_API.Get_Plan_Project_Cost_Elements().
      IF (rec_.demand_order_ref1 IS NULL) THEN

         -- fetch the order ref details if null
         Customer_Order_Shop_Order_API.Get_Shop_Order(so_order_no_,
                                                      so_release_no_,
                                                      so_sequence_no_,
                                                      rec_.order_no,
                                                      rec_.line_no,
                                                      rec_.rel_no,
                                                      rec_.line_item_no);
      ELSE
         so_order_no_    := rec_.demand_order_ref1;
         so_release_no_  := rec_.demand_order_ref2;
         so_sequence_no_ := rec_.demand_order_ref3;   
      END IF;  

      $IF Component_Shpord_SYS.INSTALLED $THEN          
         IF so_order_no_ IS NOT NULL THEN

            project_cost_elements_tab_ :=  Shop_Order_Project_Cost_API.Get_Plan_Project_Cost_Elements(so_order_no_, so_release_no_, so_sequence_no_);
         END IF;
      $ELSE
         NULL;
      $END
   ELSE   
      inv_part_rec_ := Inventory_Part_API.Get(rec_.contract, rec_.part_no);
      IF NOT ((inv_part_rec_.inventory_valuation_method = 'ST') AND
         (inv_part_rec_.inventory_part_cost_level = 'COST PER PART')) THEN      
         $IF Component_Ordstr_SYS.INSTALLED $THEN
            interim_header_id_ := Get_Interim_Order_No(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no, rec_.ctp_planned);   
            IF supply_option_ = 'DOP' AND interim_header_id_ IS NOT NULL THEN
               project_cost_elements_tab_ := Interim_Order_Cost_API.Get_Project_Cost_Elements(interim_header_id_, rec_.buy_qty_due);
            END IF;
         $ELSE
            NULL;
         $END

      END IF;   
   END IF; 

   IF (project_cost_elements_tab_.COUNT > 0) THEN
      Invent_Proj_Cost_Manager_API.Fill_Project_Cost_Element_Tmp(project_cost_elements_tab_,
                                                                 empty_tab_,
                                                                 empty_tab_,
                                                                 empty_tab_);
      project_cost_elements_ := Invent_Proj_Cost_Manager_API.Get_From_Temporary_Table();
   END IF;

   -- if no project cost element found in above calls then try to get cost from PartCostBucketOne
   -- this is potentially slower to execute...
   IF project_cost_elements_.COUNT = 0 THEN
      $IF Component_Cost_SYS.INSTALLED $THEN         
         BEGIN
            project_cost_elements_tab_ := Part_Cost_Bucket_One_API.Get_Project_Cost_Elements(
                                             contract_           => rec_.contract,
                                             part_no_            => rec_.part_no,
                                             source_ref_type_db_ => 'CUST ORDER',
                                             source_ref1_        => rec_.order_no,
                                             source_ref2_        => rec_.line_no,
                                             source_ref3_        => rec_.rel_no,
                                             source_ref4_        => rec_.line_item_no,
                                             required_qty_       => rec_.buy_qty_due,
                                             supply_option_      => supply_option_, -- 'COLSO' or 'DOP'
                                             activity_seq_       => rec_.activity_seq);
            Invent_Proj_Cost_Manager_API.Fill_Project_Cost_Element_Tmp(project_cost_elements_tab_,
                                                                       empty_tab_,
                                                                       empty_tab_,
                                                                       empty_tab_);
         END;
         project_cost_elements_ := Invent_Proj_Cost_Manager_API.Get_From_Temporary_Table();
      $ELSE
         NULL;
      $END
   END IF; 
         
   IF (rec_.charged_item = 'CHARGED ITEM') THEN
      sales_oh_cost_elements_  :=  Invent_Proj_Cost_Manager_API.Get_Elements_For_Sales_Oh(rec_.contract,
                                                                                          rec_.part_no,
                                                                                          rec_.order_no,
                                                                                          rec_.line_no,
                                                                                          rec_.rel_no,
                                                                                          rec_.line_item_no,
                                                                                          rec_.buy_qty_due );
   END IF;

   merged_project_cost_elements_ := Mpccom_Accounting_API.Get_Merged_Cost_Element_Tab(project_cost_elements_,
                                                                                      sales_oh_cost_elements_);
   RETURN merged_project_cost_elements_;

END Get_Elements_From_Manuf_Ord___;

@Override
PROCEDURE Finite_State_Set___ (
   rec_   IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   state_ IN     VARCHAR2 )
IS
   old_state_  VARCHAR2(20);
   check_do_   BOOLEAN := TRUE;
BEGIN
   old_state_ := rec_.rowstate;
   super(rec_, state_);

   -- Modify the state of the Connected PO and DO.
   IF (rec_.demand_code = 'DO') THEN
      IF (state_ = 'Released' AND old_state_ IS NULL) THEN
         check_do_  := FALSE;
      ELSIF (state_ = 'Reserved') AND (old_state_ = 'Released')
         AND (Get_Qty_Assigned(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no) = 0) THEN
         -- Order line is not yet reserved.
         check_do_ := FALSE;
      END IF;

      $IF (Component_Disord_SYS.INSTALLED)$THEN
         IF check_do_ THEN
            Distribution_Order_API.Check_State(rec_.demand_order_ref1, NULL);
         END IF;
      $END
   END IF;

   IF rec_.activity_seq IS NOT NULL THEN
      Calculate_Cost_And_Progress(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
   END IF;

   IF (rec_.demand_code = Order_Supply_Type_API.DB_COMPONENT_REPAIR_EXCHANGE AND (rec_.supply_code = Order_Supply_Type_API.DB_COMPONENT_REPAIR_ORDER))
            AND (state_ IN ('PartiallyDelivered', 'Delivered')) THEN
      $IF Component_Cromfg_SYS.INSTALLED $THEN
         Cro_Exchange_Line_API.Set_Inexchange(rec_.demand_order_ref1, rec_.demand_order_ref2);
      $ELSE
         NULL;
      $END
   END IF;

   -- send event
   IF (state_ != 'PartiallyDelivered')THEN
      Cust_Order_Event_Creation_API.Order_Line_Status_Change(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no, state_);
      IF (state_ = 'Invoiced') THEN
         IF (rec_.job_id IS NOT NULL) THEN
            Close_Financial_Project___(Site_API.Get_Company(rec_.contract), rec_.job_id);
         END IF;
         IF (rec_.qty_short = 0) THEN
            IF (Customer_Order_Shortage_API.Check_Exist(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no)) THEN
               Customer_Order_Shortage_API.Remove(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
            END IF;
         END IF;
      END IF;
      IF (state_ = 'Delivered') THEN
         Update_Pegged_Orders__(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
      END IF;
   ELSE
      -- When setting the state to PartiallyDelivered do an extra check to see if the status will be immediately set to Delivered as well.
      -- Trigger the event only when the  line will remain  in the PartiallyDelivered state.
      IF (NOT Line_Is_Fully_Delivered___(rec_)) THEN
         Cust_Order_Event_Creation_API.Order_Line_Status_Change(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no, state_);
      END IF;
   END IF;
   rec_ := Get_Object_By_Keys___(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
END Finite_State_Set___;

@Override
PROCEDURE Prepare_Insert___ (
   attr_ IN OUT VARCHAR2 )
IS
   order_rec_              CUSTOMER_ORDER_API.Public_Rec;
   site_date_              DATE;
   receiving_advice_type_  VARCHAR2(4000);
   site_discom_info_rec_   Site_Discom_Info_API.Public_Rec;
   rental_db_              CUSTOMER_ORDER_LINE_TAB.rental%TYPE;
   deliver_to_customer_no_ CUSTOMER_ORDER_LINE_TAB.deliver_to_customer_no%TYPE;
BEGIN
   -- Fetch attributes already set in client by function DataRecordGetDefaults
   order_rec_              := CUSTOMER_ORDER_API.Get(Client_SYS.Get_Item_Value('ORDER_NO', attr_));
   site_date_              := Site_API.Get_Site_Date(order_rec_.contract);
   site_discom_info_rec_   := Site_Discom_Info_API.Get(order_rec_.contract);
   receiving_advice_type_  := Cust_Ord_Customer_API.Get_Receiving_Advice_Type(order_rec_.customer_no);
   rental_db_              := NVL(Client_SYS.Get_Item_Value('RENTAL_DB', attr_), Fnd_Boolean_API.DB_FALSE);
   deliver_to_customer_no_ := NVL(Client_SYS.Get_Item_Value('DELIVER_TO_CUSTOMER_NO', attr_),order_rec_.customer_no);

   super(attr_);
   Client_SYS.Add_To_Attr('ORDER_NO', order_rec_.order_no, attr_);
   Client_SYS.Add_To_Attr('RENTAL_DB', rental_db_, attr_);
   Client_SYS.Add_To_Attr('CONTRACT', order_rec_.contract, attr_);
   Client_SYS.Add_To_Attr('CUSTOMER_NO', order_rec_.customer_no, attr_);
   Client_SYS.Add_To_Attr('COMPANY', Site_API.Get_Company(order_rec_.contract), attr_);
   Client_SYS.Add_To_Attr('WANTED_DELIVERY_DATE', order_rec_.wanted_delivery_date, attr_);
   Client_SYS.Add_To_Attr('TARGET_DATE', order_rec_.wanted_delivery_date, attr_);
   Client_SYS.Add_To_Attr('PLANNED_DELIVERY_DATE', order_rec_.wanted_delivery_date, attr_);
   Client_SYS.Add_To_Attr('COST', 0, attr_);
   Client_SYS.Add_To_Attr('CONV_FACTOR', 1, attr_);
   Client_SYS.Add_To_Attr('PRICE_CONV_FACTOR', 0, attr_);
   Client_SYS.Add_To_Attr('DISCOUNT', 0, attr_);
   Client_SYS.Add_To_Attr('ORDER_DISCOUNT', 0, attr_);
   Client_SYS.Add_To_Attr('QTY_ASSIGNED', 0, attr_);
   Client_SYS.Add_To_Attr('QTY_SHIPPED', 0, attr_);
   Client_SYS.Add_To_Attr('REVISED_QTY_DUE', 0, attr_);
   Client_SYS.Add_To_Attr('QTY_SHORT', 0, attr_);
   Client_SYS.Add_To_Attr('CONSIGNMENT_STOCK_DB', 'NO CONSIGNMENT STOCK', attr_);
   Client_SYS.Add_To_Attr('CHARGED_ITEM_DB', 'CHARGED ITEM', attr_);
   Client_SYS.Add_To_Attr('CREATE_SM_OBJECT_OPTION_DB', 'DONOTCREATESMOBJECT', attr_);
   Client_SYS.Add_To_Attr('DEFAULT_ADDR_FLAG_DB', 'Y', attr_);
   Client_SYS.Add_To_Attr('ADDR_FLAG_DB', order_rec_.addr_flag, attr_);
   Client_SYS.Add_To_Attr('SHIP_ADDR_NO', order_rec_.ship_addr_no, attr_);
   Client_SYS.Add_To_Attr('END_CUSTOMER_ID', Customer_Info_Address_API.Get_End_Customer_Id(deliver_to_customer_no_, order_rec_.ship_addr_no), attr_);
   Client_SYS.Add_To_Attr('STAGED_BILLING_DB', 'NOT STAGED BILLING', attr_);
   Client_SYS.Add_To_Attr('TAX_LIABILITY', order_rec_.tax_liability, attr_);
   Client_SYS.Add_To_Attr('SM_CONNECTION_DB', 'NOT CONNECTED', attr_);
   Client_SYS.Add_To_Attr('PRICE_FREEZE_DB', 'FREE', attr_);
   Client_SYS.Add_To_Attr('CONFIGURATION_ID', '*', attr_);
   Client_SYS.Add_To_Attr('CTP_PLANNED_DB', 'N', attr_);
   IF (rental_db_ = Fnd_Boolean_API.DB_FALSE) THEN
      Client_SYS.Add_To_Attr('PART_OWNERSHIP', Part_Ownership_API.Decode(Part_Ownership_API.DB_COMPANY_OWNED), attr_);
   END IF;
   Client_SYS.Add_To_Attr('EXCHANGE_ITEM_DB', 'ITEM NOT EXCHANGED', attr_);
   Client_SYS.Add_To_Attr('INTRASTAT_EXEMPT_DB', 'INCLUDE', attr_);
   Client_SYS.Add_To_Attr('CLASSIFICATION_STANDARD', order_rec_.classification_standard, attr_);
   Client_SYS.Add_To_Attr('ABNORMAL_DEMAND_DB', 'FALSE', attr_);
   Client_SYS.Add_To_Attr('CUST_CALENDAR_ID', order_rec_.cust_calendar_id, attr_);
   Client_SYS.Add_To_Attr('EXT_TRANSPORT_CALENDAR_ID', order_rec_.ext_transport_calendar_id, attr_);
   IF ((order_rec_.rowstate = 'Blocked') AND (order_rec_.blocked_type = 'MANUAL_BLOCKED') AND
       (Block_Reasons_API.Get_Exclude_Mtrl_Planning_Db(order_rec_.blocked_reason) = 'TRUE')) THEN
      Client_SYS.Add_To_Attr('REL_MTRL_PLANNING', 'FALSE', attr_);
   ELSE
      Client_SYS.Add_To_Attr('REL_MTRL_PLANNING', 'TRUE', attr_);
   END IF;
   Client_SYS.Add_To_Attr('INVERTED_CONV_FACTOR', 1, attr_);
   -- Pricing Method. The default value for price effectivity date on a new order line will be determined on Site level.
   IF (site_discom_info_rec_.cust_order_pricing_method = 'ORDER_DATE') THEN
      Client_SYS.Add_To_Attr('PRICE_EFFECTIVITY_DATE', site_date_, attr_);
   ELSIF (site_discom_info_rec_.cust_order_pricing_method = 'DELIVERY_DATE') THEN
      Client_SYS.Add_To_Attr('PRICE_EFFECTIVITY_DATE', order_rec_.wanted_delivery_date, attr_);
   END IF;
   Client_SYS.Set_Item_Value('SUPPLY_SITE_RESERVE_TYPE_DB', 'NOTALLOWED', attr_);
   Client_SYS.Set_Item_Value('SUPPLY_SITE_RESERVE_TYPE', Supply_Site_Reserve_Type_API.Decode('NOTALLOWED'), attr_);
   Client_SYS.Set_Item_Value('RELEASE_PLANNING_DB', 'NOTRELEASED', attr_);
   Client_SYS.Set_Item_Value('SHIPMENT_CONNECTED_DB', 'FALSE', attr_);
   Client_SYS.Set_Item_Value('DELIVERY_CONFIRMED_DB', 'FALSE', attr_);
   Client_SYS.Set_Item_Value('BLOCKED_FOR_INVOICING_DB', 'FALSE', attr_);
   Client_SYS.Set_Item_Value('PROVISIONAL_PRICE_DB', 'FALSE', attr_);
   Client_SYS.Set_Item_Value('RECEIVING_ADVICE_TYPE', receiving_advice_type_, attr_);
   Client_SYS.Set_Item_Value('PRICE_SOURCE_NET_PRICE_DB', 'FALSE', attr_);
   Client_SYS.Set_Item_Value('REBATE_BUILDER_DB', 'TRUE', attr_);
   Client_SYS.Set_Item_Value('FREIGHT_FREE_DB', 'FALSE', attr_);
   Client_SYS.Set_Item_Value('FREE_OF_CHARGE_DB', Fnd_Boolean_API.DB_FALSE, attr_);

   IF (Fnd_Session_API.Is_Odp_Session) THEN   
      Client_SYS.Add_To_Attr('TAX_LIABILITY_TYPE_DB', Customer_Order_API.Get_Tax_Liability_Type_Db(order_rec_.order_no), attr_);
   END IF;
   
   Client_SYS.Add_To_Attr('CUSTOMER_TAX_USAGE_TYPE', order_rec_.customer_tax_usage_type, attr_);
   
   -- gelr:disc_price_rounded, begin
   IF (order_rec_.disc_price_round = Fnd_Boolean_API.DB_TRUE AND order_rec_.use_price_incl_tax = Fnd_Boolean_API.DB_FALSE) THEN
      Client_SYS.Add_To_Attr('ORIGINAL_DISCOUNT', 0, attr_);
      Client_SYS.Add_To_Attr('ORIGINAL_ORDER_DISCOUNT', 0, attr_);
   END IF;
   -- gelr:disc_price_rounded, end
   
   -- gelr:brazilian_specific_attributes, begin
   IF (order_rec_.business_transaction_id IS NOT NULL) THEN
      Client_SYS.Set_Item_Value('ACQUISITION_REASON_ID', Business_Transaction_Id_API.Get_Acquisition_Reason_Id(Site_API.Get_Company(order_rec_.contract), order_rec_.business_transaction_id), attr_);
   END IF;
   -- gelr:brazilian_specific_attributes, end
   
   IF (rental_db_ = Fnd_Boolean_API.DB_TRUE) THEN
      Prepare_Rental___(attr_);
   END IF;
END Prepare_Insert___;


@Override
PROCEDURE Insert___ (
   objid_      OUT    VARCHAR2,
   objversion_ OUT    VARCHAR2,
   newrec_     IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   attr_       IN OUT VARCHAR2 )
IS
   company_                  VARCHAR2(20);
   pre_accounting_id_        NUMBER;
   temp_pre_accounting_id_   NUMBER;
   source_id_                VARCHAR2(200);
   order_rec_                CUSTOMER_ORDER_API.Public_Rec;
   sales_part_rec_           SALES_PART_API.Public_Rec;
   site_rec_                 Site_API.Public_Rec;
   temp_                     Public_Rec;
   created_by_server_        NUMBER;
   -- dynamic server call variables
   cross_rec_                Sales_Part_Cross_Reference_API.Public_Rec;
   clp_attr_                 VARCHAR2(2000);
   old_note_id_              NUMBER;
   is_input_uom_grp_allowed_ VARCHAR2(20);
   input_uom_group_          Inventory_Part_Tab.Input_Unit_Meas_Group_Id%TYPE;
   site_date_                DATE;
   country_desc_             VARCHAR2(740);
   insert_package_mode_      VARCHAR2(5);
   new_default_addr_flag_    VARCHAR2(1);
   copy_order_line_          BOOLEAN := NVL(Client_SYS.Get_Item_Value('COPY_ORDER_LINE', attr_), 'FALSE') = 'TRUE';   
BEGIN
   order_rec_           := CUSTOMER_ORDER_API.Get(newrec_.order_no);
   -- New lines are not allowed if mandatory postings on order head have not been defined
   site_rec_            := Site_API.Get(newrec_.contract);
   company_             := site_rec_.company;
   pre_accounting_id_   := order_rec_.pre_accounting_id;
   source_id_           := Language_SYS.Translate_Constant(lu_name_, 'SOURCEID_1: Customer Order :P1', NULL, newrec_.order_no);
   created_by_server_   := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('CREATED_BY_SERVER', attr_));
   insert_package_mode_ := NVL(Client_SYS.Get_Item_Value('INSERT_PACKAGE_MODE_', attr_), 'FALSE');
   
   IF (newrec_.customer_tax_usage_type IS NULL) THEN
      newrec_.customer_tax_usage_type  := order_rec_.customer_tax_usage_type;
   END IF;

   IF (created_by_server_ = 0) THEN
      Pre_Accounting_API.Check_Mandatory_Code_Parts(pre_accounting_id_, 'M103', company_, source_id_);
   END IF;

   IF (newrec_.planned_ship_date IS NOT NULL) THEN
      Client_SYS.Set_Item_Value('PLANNED_SHIP_DATE', newrec_.planned_ship_date, attr_);
   END IF;

   -- fetch customer part number if not entered - or invalid
   IF ((newrec_.customer_part_no IS NULL) OR
       (newrec_.catalog_no != NVL(Sales_Part_Cross_Reference_API.Get_Catalog_No(newrec_.customer_no, newrec_.contract,
                                                                                newrec_.customer_part_no), ' '))) THEN
      Trace_SYS.Message('Fetching cross referenced part');
      newrec_.customer_part_no := Sales_Part_Cross_Reference_API.Get_Customer_Part_No(newrec_.customer_no, newrec_.contract, newrec_.catalog_no);
      Trace_SYS.Field('CUSTOMER_PART_NO', newrec_.customer_part_no);
   END IF;
      -- if part number was found, fetch unit and conv factor...
   
   IF (newrec_.customer_part_no IS NOT NULL) THEN
      Trace_SYS.Message('Fetching the rest of the customer part attributes.');
      cross_rec_ := Sales_Part_Cross_Reference_API.Get(newrec_.customer_no, newrec_.contract, newrec_.customer_part_no);
      IF (newrec_.customer_part_conv_factor IS NULL) THEN
         newrec_.customer_part_conv_factor := greatest(NVL(cross_rec_.conv_factor, 1), 0);
      END IF;
      IF (newrec_.cust_part_invert_conv_fact IS NULL) THEN
         newrec_.cust_part_invert_conv_fact := greatest(NVL(cross_rec_.inverted_conv_factor, 1), 0);
      END IF;
      IF (newrec_.customer_part_unit_meas IS NULL) THEN
         newrec_.customer_part_unit_meas := NVL(cross_rec_.customer_unit_meas, newrec_.sales_unit_meas);
      END IF;
      IF (newrec_.customer_part_buy_qty IS NULL) THEN
         newrec_.customer_part_buy_qty := (newrec_.buy_qty_due / newrec_.customer_part_conv_factor) * newrec_.cust_part_invert_conv_fact;
      END IF;
      IF (newrec_.catalog_desc IS NULL) THEN
         newrec_.catalog_desc := cross_rec_.catalog_desc;
      END IF;

      Client_SYS.Set_Item_Value('CUSTOMER_PART_NO', newrec_.customer_part_no, attr_);
      Client_SYS.Set_Item_Value('CUSTOMER_PART_CONV_FACTOR', newrec_.customer_part_conv_factor, attr_);
      Client_SYS.Set_Item_Value('CUSTOMER_PART_UNIT_MEAS', newrec_.customer_part_unit_meas, attr_);
      Client_SYS.Set_Item_Value('CUSTOMER_PART_BUY_QTY', newrec_.customer_part_buy_qty, attr_);
      Client_SYS.Set_Item_Value('CUST_PART_INVERT_CONV_FACT', newrec_.cust_part_invert_conv_fact, attr_);
   ELSE
      newrec_.customer_part_conv_factor  := NULL;
      newrec_.customer_part_unit_meas    := NULL;
      newrec_.customer_part_buy_qty      := NULL;
      newrec_.cust_part_invert_conv_fact := NULL;
   END IF;

   -- IF inserting a package component, set catalog_type as such and set the self billing value as NOT SELF BILLING.
   IF (newrec_.line_item_no > 0) THEN
      newrec_.catalog_type := 'KOMP';
      Client_SYS.Set_Item_Value('CATALOG_TYPE', Sales_Part_Type_API.Decode(newrec_.catalog_type), attr_);
      newrec_.self_billing := 'NOT SELF BILLING';
      Client_SYS.Set_Item_Value('SELF_BILLING_DB',  newrec_.self_billing, attr_);
   ELSE
      --Add the self billing to the attribute string
      Client_SYS.Set_Item_Value('SELF_BILLING_DB',  newrec_.self_billing, attr_);
      Client_SYS.Set_Item_Value('SELF_BILLING',  Self_Billing_Type_API.Decode(newrec_.self_billing), attr_);
   END IF;

   sales_part_rec_           := Sales_Part_API.Get(newrec_.contract, newrec_.catalog_no);
   input_uom_group_          := Inventory_Part_API.Get_Input_Unit_Meas_Group_Id( newrec_.contract, newrec_.part_no);
   is_input_uom_grp_allowed_ := Input_Unit_Meas_Group_API.Is_Usage_Allowed(input_uom_group_, 'ORDER' );

   -- IID DI011 removed net weight from Invent Part and adds it to the Partcatalog.
   -- As a result now Sales Part's freight info can get fetched from on itself or from part catalog.
   -- Sales_Weight_Volume_Util_API.Get_Total_Weight_Volume does the necessary conversions and returns the values.
   Sales_Weight_Volume_Util_API.Get_Total_Weight_Volume(total_net_weight_      => newrec_.line_total_weight,
                                                        total_gross_weight_    => newrec_.line_total_weight_gross,
                                                        total_volume_          => newrec_.line_total_qty,
                                                        adjusted_net_weight_   => newrec_.adjusted_weight_net,
                                                        adjusted_gross_weight_ => newrec_.adjusted_weight_gross,
                                                        adjusted_volume_       => newrec_.adjusted_volume,
                                                        contract_              => newrec_.contract,
                                                        catalog_no_            => newrec_.catalog_no,
                                                        part_no_               => newrec_.part_no,
                                                        buy_qty_due_           => newrec_.buy_qty_due,
                                                        configuration_id_      => newrec_.configuration_id,
                                                        input_unit_meas_       => newrec_.input_unit_meas,
                                                        input_qty_              => newrec_.input_qty,
                                                        packing_instruction_id_ => newrec_.packing_instruction_id);

   site_date_ := Site_API.Get_Site_Date(newrec_.contract);
   -- Check if new line with non inventory part should be ready for delivery
   IF (((newrec_.supply_code = 'NO') AND ((newrec_.catalog_type != 'KOMP') OR (order_rec_.backorder_option != 'INCOMPLETE PACKAGES NOT ALLOWED')))
          AND ((trunc(newrec_.planned_due_date) <= trunc(site_date_)) OR Cust_Order_Type_API.Get_Oe_Alloc_Assign_Flag(order_rec_.order_id) = Cust_Ord_Reservation_Type_API.Decode('Y'))
          OR (newrec_.supply_code IN ('SEO', 'PRJ'))) THEN
      newrec_.qty_to_ship := newrec_.revised_qty_due;
   ELSE
      newrec_.qty_to_ship := 0;
   END IF;

   old_note_id_    := newrec_.note_id;
   newrec_.note_id := Document_Text_API.Get_Next_Note_Id;

   IF (old_note_id_ IS NOT NULL) THEN
      Document_Text_API.Copy_All_Note_Texts(old_note_id_, newrec_.note_id);
   END IF;

   temp_pre_accounting_id_ := newrec_.pre_accounting_id ;

   IF (newrec_.line_item_no > 0) THEN
      -- if a component, use the same pre_accounting_id.
      temp_ := Get(newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1);
      newrec_.pre_accounting_id := temp_.pre_accounting_id;
      IF (newrec_.qty_per_assembly IS NULL) THEN
         newrec_.qty_per_assembly := newrec_.buy_qty_due/temp_.buy_qty_due;
      END IF;

      IF ((newrec_.new_comp_after_delivery IS NULL)) THEN
         newrec_.new_comp_after_delivery := 'FALSE';
      END IF;
   ELSE
      -- Not a package component
      newrec_.pre_accounting_id := Pre_Accounting_API.Get_Next_Pre_Accounting_Id;
   END IF;

   IF (newrec_.line_item_no <= 0) THEN
      IF (temp_pre_accounting_id_ IS NOT NULL) AND
         (newrec_.originating_rel_no IS NOT NULL) AND (newrec_.originating_line_item_no IS NOT NULL) THEN
         -- new source lines copy old order line pre accounting info to the new line
         Pre_Accounting_API.Copy_Pre_Accounting(temp_pre_accounting_id_, newrec_.pre_accounting_id, newrec_.contract);
      ELSE
         -- do copy for normal lines and package heads
         Pre_Accounting_API.Copy_Pre_Accounting(order_rec_.pre_accounting_id, newrec_.pre_accounting_id, newrec_.contract, NULL, 'CUSTOMER ORDER');
      END IF;
   END IF;

   Client_SYS.Set_Item_Value('NOTE_ID', newrec_.note_id, attr_);
   Client_SYS.Set_Item_Value('PRE_ACCOUNTING_ID', newrec_.pre_accounting_id, attr_);

   IF (NVL(newrec_.demand_code, ' ') != 'CQ') THEN
      newrec_.price_conv_factor := sales_part_rec_.price_conv_factor;
   END IF;

   -- The column is mandatory in the database, but calculated from the delivery dates
   Error_SYS.Check_Not_Null(lu_name_, 'PLANNED_SHIP_DATE', newrec_.planned_ship_date);
   -- Set shipment period
   newrec_.planned_ship_period := Work_Time_Calendar_API.Get_Period(site_rec_.dist_calendar_id, newrec_.planned_ship_date);
   Client_SYS.Add_To_Attr('PLANNED_SHIP_PERIOD', newrec_.planned_ship_period, attr_);

   -- if we have a configurable part, we will sooner or later create a configuration,
   -- then we need a price-id. Create it now so it is available when we call the configuration dialog.
   IF (Part_Catalog_API.Get_Configurable_Db(nvl(newrec_.part_no, newrec_.catalog_no)) = 'CONFIGURED') THEN
      IF (newrec_.configured_line_price_id IS NULL) THEN
         newrec_.configured_line_price_id := Configured_Line_Price_API.New_Order_Line_Price(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      ELSE
      -- if we get a configured line price id from the client, it was created before saving.
      -- Update the reference back to this line now that all keys are determined.
         Client_Sys.Clear_Attr(clp_attr_);
         Client_SYS.Add_To_Attr('LINE_NO', newrec_.line_no, clp_attr_);
         Client_SYS.Add_To_Attr('REL_NO', newrec_.rel_no, clp_attr_);
         Client_SYS.Add_To_Attr('LINE_ITEM_NO', newrec_.line_item_no, clp_attr_);
         Configured_Line_Price_API.Modify(newrec_.configured_line_price_id, clp_attr_);
      END IF;
   ELSE
      newrec_.configuration_id         := '*';
      newrec_.configured_line_price_id := NULL;
   END IF;

   Client_SYS.Add_To_Attr('CONFIGURED_LINE_PRICE_ID', newrec_.configured_line_price_id, attr_);

   -- fetch warranty ID from sales part if not inherited from Quotation
   IF ((NVL(newrec_.demand_code, ' ') != 'CQ') AND NOT(copy_order_line_)) THEN
      newrec_.cust_warranty_id := sales_part_rec_.cust_warranty_id;
   END IF;

   IF (newrec_.charged_item = 'ITEM NOT CHARGED' OR newrec_.exchange_item = 'EXCHANGED ITEM')
      OR (newrec_.part_ownership IN ('SUPPLIER LOANED', 'CUSTOMER OWNED')) THEN
      newrec_.cust_warranty_id := NULL;
   END IF;

   IF (newrec_.cust_warranty_id IS NOT NULL) THEN
      Cust_Warranty_API.Inherit(newrec_.cust_warranty_id);
      Client_SYS.Add_To_Attr('CUST_WARRANTY_ID', newrec_.cust_warranty_id, attr_);
   END IF;

   IF (newrec_.activity_seq IS NULL) THEN
      newrec_.project_id := NULL;
   END IF;

   -- gelr:disc_price_rounded, begin
   IF (Customer_Order_API.Get_Discounted_Price_Rounded(newrec_.order_no)) THEN
      -- user/system operates on additional_discount but it is saved in technical column: original_add_discount
      -- Initialize original_ column which is now empty
      newrec_.original_add_discount := newrec_.additional_discount;
      newrec_.additional_discount := Customer_Order_Pricing_API.Calculate_Additional_Discount(newrec_.contract,
                                                                   order_rec_.currency_code,
                                                                   newrec_.additional_discount,
                                                                   newrec_.buy_qty_due,
                                                                   newrec_.price_conv_factor,
                                                                   newrec_.sale_unit_price,
                                                                   newrec_.discount);
      -- The same as previous
      newrec_.original_order_discount := newrec_.order_discount;
      newrec_.order_discount := Customer_Order_Pricing_API.Calculate_Additional_Discount(newrec_.contract,
                                                                   order_rec_.currency_code,
                                                                   newrec_.order_discount,
                                                                   newrec_.buy_qty_due,
                                                                   newrec_.price_conv_factor,
                                                                   newrec_.sale_unit_price,
                                                                   newrec_.discount);
   ELSE
      newrec_.original_discount       := 0;
      newrec_.original_order_discount := 0;
      newrec_.original_add_discount   := 0;
   END IF;
   -- gelr:disc_price_rounded, end   
   -- gelr:brazilian_specific_attributes, begin
   IF order_rec_.business_transaction_id IS NOT NULL THEN
      newrec_.ref_id := order_rec_.business_transaction_id;
   END IF;
   -- gelr:brazilian_specific_attributes, end
   
   super(objid_, objversion_, newrec_, attr_);

   $IF (Component_Jinsui_SYS.INSTALLED) $THEN
      IF order_rec_.jinsui_invoice ='TRUE' THEN
         Validate_Jinsui_Constraints__(newrec_, 0, FALSE);
      END IF;
   $END

   IF NOT (Client_SYS.Item_Exist('INSERT_PACKAGE_MODE_',attr_))THEN
      Client_SYS.Add_To_Attr('INSERT_PACKAGE_MODE_', insert_package_mode_, attr_);
   END IF;

   -- Note : Rental object should be created before Post Insert Action.
   -- To calculate the sales price total, it needs rental duration days.
   IF (newrec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
      New_Rental___(attr_, newrec_);
   END IF;

   -- Perform post insert action like creating package component lines and making reservations
   Post_Insert_Actions___(attr_, newrec_);


   IF (newrec_.activity_seq IS NOT NULL) THEN
      IF (newrec_.charged_item = 'CHARGED ITEM') THEN
         Calculate_Revenue(newrec_.order_no,
                           newrec_.line_no,
                           newrec_.rel_no,
                           newrec_.line_item_no);
      END IF;
      $IF Component_Ordstr_SYS.INSTALLED $THEN
         DECLARE
            interim_head_id_  VARCHAR2(12);
         BEGIN
            interim_head_id_ := Interim_Demand_Head_API.Get_Cust_Ord_Line_Int_Head(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
            IF interim_head_id_ IS NOT NULL THEN
               -- Reflect activity information changes to the Interim Demand Header
               Interim_Demand_Head_API.Modify_Project_Activity_Seq(interim_head_id_, newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.project_id, newrec_.activity_seq);
            END IF;
         END;
      $END
   END IF;

   IF (newrec_.cust_calendar_id IS NOT NULL) THEN
      IF (newrec_.cust_calendar_id != NVL(order_rec_.cust_calendar_id, Database_Sys.string_null_)) THEN
         Work_Time_Calendar_API.Add_Info_On_Pending(newrec_.cust_calendar_id);
      END IF;

      IF (NOT (newrec_.planned_delivery_date = newrec_.wanted_delivery_date
               AND newrec_.wanted_delivery_date = order_rec_.wanted_delivery_date)) THEN
         Cust_Ord_Date_Calculation_API.Check_Date_On_Cust_Calendar_(newrec_.customer_no, newrec_.cust_calendar_id,
                                                     newrec_.planned_delivery_date, 'PLANNED');
      END IF;
   END IF;

   IF (newrec_.ext_transport_calendar_id IS NOT NULL) THEN
      Work_Time_Calendar_API.Add_Info_On_Pending(newrec_.ext_transport_calendar_id);
   END IF;

   IF (newrec_.supply_code = 'IPD') THEN
      IF Tax_Handling_Order_Util_API.Check_Ipd_Tax_Registration(company_, newrec_.contract, newrec_.supply_code, order_rec_.supply_country, newrec_.country_code) THEN
         country_desc_ := Iso_Country_API.Get_Description(newrec_.country_code, NULL);
         Client_SYS.Add_Info(lu_name_, 'SUPCOUNTRYDIFF: Company :P1 has a tax registration in delivery country :P2. The company tax ID number for the supply country of the order might not be appropriate.', company_, country_desc_);
      END IF;
   END IF;
   -- Set out parameter value
   Get_Id_Version_By_Keys___(objid_, objversion_, newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
EXCEPTION
   WHEN dup_val_on_index THEN
      Error_SYS.Record_Exist(lu_name_);
END Insert___;


@Override
PROCEDURE Update___ (
   objid_            IN     VARCHAR2,
   oldrec_           IN     CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   newrec_           IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   attr_             IN OUT VARCHAR2,
   objversion_       IN OUT VARCHAR2,
   by_keys_          IN     BOOLEAN DEFAULT FALSE )
IS
    CURSOR get_component_lines IS
      SELECT col.line_item_no, col.buy_qty_due, col.revised_qty_due, col.qty_on_order, col.supply_code, col.addr_flag, col.part_no, col.qty_assigned, col.qty_shipped, cop.po_order_no,
             col.ship_via_code, col.forward_agent_id, col.delivery_terms, col.del_terms_location, col.ext_transport_calendar_id,
             col.ship_addr_no, col.default_addr_flag
      FROM   customer_order_line_tab col, customer_order_pur_order_tab cop
      WHERE  col.order_no = newrec_.order_no
      AND    col.line_no = newrec_.line_no
      AND    col.rel_no = newrec_.rel_no
      AND    col.line_item_no > 0
      AND    col.rowstate NOT IN ('Invoiced', 'Cancelled')
      AND    cop.oe_order_no(+) = col.order_no
      AND    cop.oe_line_no(+) = col.line_no
      AND    cop.oe_rel_no(+) = col.rel_no
      AND    cop.oe_line_item_no(+)  = col.line_item_no
      ORDER BY cop.po_order_no, col.line_item_no;

   comp_rec_                      get_component_lines%ROWTYPE;
   next_comp_rec_                 get_component_lines%ROWTYPE;
   temp_change_request_           VARCHAR2(5);

   comp_qty_invoiced_             NUMBER;
   text_                          VARCHAR2(200);
   linerec_                       CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   rowid_                         VARCHAR2(2000);
   rowversion_                    VARCHAR2(2000);
   sales_part_rec_                Sales_Part_API.Public_Rec;
   order_rec_                     CUSTOMER_ORDER_API.Public_Rec;
   site_rec_                      Site_API.Public_Rec;
   old_sale_price_total_          NUMBER;
   new_sale_price_total_          NUMBER;
   company_                       VARCHAR2(20);
   pkg_changed_                   BOOLEAN := FALSE;
   discount_                      NUMBER;
   qty_refreshed_                 NUMBER;
   price_source_refreshed_        NUMBER;
   contract_                      CUSTOMER_ORDER_LINE_TAB.contract%TYPE;
   part_no_                       CUSTOMER_ORDER_LINE_TAB.part_no%TYPE;
   header_rowstate_               CUSTOMER_ORDER_TAB.rowstate%TYPE;
   tot_percentage_                NUMBER;
   msg_text_                      VARCHAR2(200);
   originating_rel_no_            VARCHAR2(4);
   originating_line_item_no_      NUMBER;
   source_msg_text_               VARCHAR2(300);
   len_msg_text_                  NUMBER:= 0;
   local_site_reservation_exist_  NUMBER := 0;
   planned_receipt_date_          DATE;
   data_changed_                  BOOLEAN;
   create_connected_order_        BOOLEAN := TRUE;
   replicate_changes_             VARCHAR2(5);
   change_request_                VARCHAR2(5);
   server_data_change_            NUMBER;
   comp_attr_                     VARCHAR2(2000);
   prov_msg_text_                 VARCHAR2(200);
   calc_price_per_curr_           NUMBER;
   tax_from_defaults_             BOOLEAN := FALSE;
   price_changed_                 BOOLEAN := FALSE;
   shipment_id_                   NUMBER;
   tax_method_                    VARCHAR2(50);
   exist_chg_on_order_line_       NUMBER;
   is_input_uom_grp_allowed_      VARCHAR2(20);
   input_uom_group_               Inventory_Part_Tab.Input_Unit_Meas_Group_Id%TYPE;
   update_pegged_orders_          VARCHAR2(5);
   dummy_                         Shipment_API.Shipment_Id_Tab;
   price_source_                  VARCHAR2(200);
   header_deliver_country_db_     VARCHAR2(2);
   proj_unique_sale_              VARCHAR2(5);
   order_project_id_              CUSTOMER_ORDER_TAB.project_id%TYPE;
   do_qty_                        BOOLEAN := FALSE;
   site_date_                     DATE;
   country_desc_                  VARCHAR2(740);
   new_rental_chargeable_days_    NUMBER;
   old_rental_chargeable_days_    NUMBER;
   old_sale_price_incl_tax_total_ NUMBER;
   new_sale_price_incl_tax_total_ NUMBER;
   insert_package_mode_           VARCHAR2(5);
   block_component_info_          VARCHAR2(5):= 'FALSE';
   current_info_                  VARCHAR2(32000);
   pkg_qty_reserved_              NUMBER;
   dop_replicate_msg_             VARCHAR2(2000) := NULL;
   no_of_dop_conns_               NUMBER;
   order_info_                    VARCHAR2(23);
   from_shortage_                 BOOLEAN := FALSE;
   make_reservation_              BOOLEAN := FALSE;
   connected_shipment_id_         NUMBER;
   po_charged_comp_change_        VARCHAR2(5);
   changed_attrib_not_in_pol_     VARCHAR2(5);
   discount_freeze_db_            VARCHAR2(5);    
   replication_not_needed_        VARCHAR2(10) := 'NOTSENT';
   currency_type_                 Currency_Type_Tab.currency_type%TYPE;      
   new_default_addr_flag_         VARCHAR2(1);
   evaluate_default_info_         BOOLEAN := FALSE;
   rounding_                      NUMBER;
   new_comprec_                   CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   unit_price_                    NUMBER;
   dummy_total_disc_pct_          NUMBER;
   dummy_total_disc_amt_          NUMBER;
   tax_code_changed_              VARCHAR2(5) := 'FALSE';
   multiple_tax_lines_            VARCHAR2(20);
   tax_item_removed_              VARCHAR2(5) := 'FALSE';
   price_refetch_                 VARCHAR2(5);
   fetch_external_tax_             VARCHAR2(5) := 'TRUE';
   -- gelr:disc_price_rounded, begin
   discounted_price_rounded_      BOOLEAN := Customer_Order_API.Get_Discounted_Price_Rounded(newrec_.order_no);
   -- gelr:disc_price_rounded, end
BEGIN  
   order_rec_                := CUSTOMER_ORDER_API.Get(newrec_.order_no);
   insert_package_mode_      := NVL(Client_SYS.Get_Item_Value('INSERT_PACKAGE_MODE_', attr_), 'FALSE');
   po_charged_comp_change_   := NVL(Client_SYS.Get_Item_Value('PO_CHARGED_COMP_CHANGE', attr_), 'FALSE');

   IF (Client_SYS.Get_Item_Value('MAKE_RESERVATION', attr_) = 'TRUE') THEN
      make_reservation_ := TRUE;
   END IF;
   
   IF Fnd_Session_API.Is_Odp_Session AND Client_SYS.Get_Item_Value('SOURCE', attr_) = 'SHORTAGES' THEN 
      from_shortage_ := TRUE;
   ELSIF (Client_SYS.Item_Exist('NULL', attr_)) THEN
      from_shortage_ := TRUE;
   END IF;

   IF (Client_SYS.Item_Exist('CONNECTED_SHIPMENT_ID', attr_)) THEN
      connected_shipment_id_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('CONNECTED_SHIPMENT_ID', attr_));
   END IF;

   site_rec_                 := Site_API.Get(newrec_.contract);
   company_                  := site_rec_.company;
   sales_part_rec_           := Sales_Part_API.Get(newrec_.contract, newrec_.catalog_no);
   input_uom_group_          := Inventory_Part_API.Get_Input_Unit_Meas_Group_Id( newrec_.contract, newrec_.part_no);
   is_input_uom_grp_allowed_ := Input_Unit_Meas_Group_API.Is_Usage_Allowed(input_uom_group_, 'ORDER' );

   -- IID DI011 removed net weight from Invent Part and adds it to the Partcatalog.
   -- As a result now Sales Part's freight info can get fetched from on itself or from part catalog.
   -- Sales_Weight_Volume_Util_API.Get_Total_Weight_Volume does the necessary conresions and returns the values.
   Sales_Weight_Volume_Util_API.Get_Total_Weight_Volume(total_net_weight_      => newrec_.line_total_weight,
                                                        total_gross_weight_    => newrec_.line_total_weight_gross,
                                                        total_volume_          => newrec_.line_total_qty,
                                                        adjusted_net_weight_   => newrec_.adjusted_weight_net,
                                                        adjusted_gross_weight_ => newrec_.adjusted_weight_gross,
                                                        adjusted_volume_       => newrec_.adjusted_volume,
                                                        contract_              => newrec_.contract,
                                                        catalog_no_            => newrec_.catalog_no,
                                                        part_no_               => newrec_.part_no,
                                                        buy_qty_due_           => newrec_.buy_qty_due,
                                                        configuration_id_      => newrec_.configuration_id,
                                                        input_unit_meas_       => newrec_.input_unit_meas,
                                                        input_qty_              => newrec_.input_qty,
                                                        packing_instruction_id_ => newrec_.packing_instruction_id);

   header_rowstate_ := order_rec_.rowstate;

   qty_refreshed_          := (NVL(Client_SYS.Get_Item_Value('QTY_REFRESHED', attr_), 0));
   price_source_refreshed_ := (NVL(Client_SYS.Get_Item_Value('PRICE_SOURCE_REFRESHED', attr_), 0));

   replicate_changes_    := Client_SYS.Get_Item_Value('REPLICATE_CHANGES', attr_);
   change_request_       := Client_SYS.Get_Item_Value('CHANGE_REQUEST', attr_);
   server_data_change_   := NVL(Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('SERVER_DATA_CHANGE', attr_)), 0);
   update_pegged_orders_ := Client_SYS.Get_Item_Value('UPDATE_PEGGED_ORDERS', attr_);
   changed_attrib_not_in_pol_   := Client_SYS.Get_Item_Value('CHANGED_ATTRIB_NOT_IN_POL', attr_);
   tax_code_changed_ := NVL(Client_SYS.Get_Item_Value('TAX_CODE_CHANGED', attr_), 'FALSE');
   price_refetch_        := Client_SYS.Get_Item_Value('PRICE_REFETCH', attr_);   
   multiple_tax_lines_  := Client_SYS.Get_Item_Value('MULTIPLE_TAX_LINES', attr_);
   tax_method_ := Company_Tax_Control_API.Get_External_Tax_Cal_Method_Db(company_);
   
   -- When AVALARA tax is used when possible bundle calls are used to fetch tax. At those 
   -- times UPDATE_TAX is set to FALSE in attr
   IF tax_method_ IN (External_Tax_Calc_Method_API.DB_AVALARA_SALES_TAX, External_Tax_Calc_Method_API.DB_AVALARA_TAX_BRAZIL) THEN
      fetch_external_tax_ := NVL(Client_SYS.Get_Item_Value('UPDATE_TAX', attr_), 'TRUE');
   END IF;

   IF (newrec_.line_item_no <= 0) THEN
      IF ((newrec_.tax_code IS NULL) AND (newrec_.tax_calc_structure_id IS NULL) AND (tax_method_ = External_Tax_Calc_Method_API.DB_NOT_USED)
         AND (multiple_tax_lines_ IS NOT NULL) AND (multiple_tax_lines_ = 'FALSE')
         AND (NVL(newrec_.project_id, Database_SYS.string_null_) = NVL(oldrec_.project_id, Database_SYS.string_null_)) AND order_rec_.rowstate != 'Invoiced') THEN

         tax_item_removed_ := 'TRUE';

         Source_Tax_Item_Order_API.Remove_Tax_Items(company_, 
                                                   Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                                   newrec_.order_no, 
                                                   newrec_.line_no, 
                                                   newrec_.rel_no, 
                                                   TO_CHAR(newrec_.line_item_no),
                                                   '*');
         Tax_Handling_Util_API.Validate_Tax_Code_Mandatory(company_, 'CUSTOMER_TAX');      
      END IF;
   END IF;

   -- For rental lines, the rental duration is retreived from the rental atrributes
   -- because rental object is updated after customer order line.
   IF (newrec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
      old_rental_chargeable_days_  := Get_Rental_Chargeable_Days___(newrec_.order_no,
                                                                    newrec_.line_no,
                                                                    newrec_.rel_no,
                                                                    newrec_.line_item_no);
      new_rental_chargeable_days_ := Get_Latest_Rent_Charge_Days___(attr_, newrec_);
   END IF;

   IF (from_shortage_ AND (newrec_.rowstate IN ('Delivered', 'Invoiced', 'Cancelled'))) THEN
      Error_SYS.Record_General(lu_name_, 'NOORDERCHGS: No changes may be made to an order when Delivered or Invoiced/Closed or Cancelled.');
   END IF;

   IF sales_part_rec_.minimum_qty IS NOT NULL AND newrec_.buy_qty_due != oldrec_.buy_qty_due THEN
      IF sales_part_rec_.minimum_qty > newrec_.buy_qty_due THEN
         Client_SYS.Add_Info(lu_name_, 'LTMINIMUMQTY: The minimum quantity when ordering Sales Part No :P1 is :P2 :P3.', newrec_.catalog_no, sales_part_rec_.minimum_qty, newrec_.sales_unit_meas);
      END IF;
   END IF;

   -- Project Umbrella Connection
   IF (newrec_.activity_seq IS NOT NULL) THEN
      IF ((oldrec_.activity_seq IS NULL) OR (oldrec_.activity_seq != newrec_.activity_seq)) THEN
         $IF (Component_Proj_SYS.INSTALLED) $THEN
            newrec_.project_id  := Activity_API.Get_Project_Id(newrec_.activity_seq);
            proj_unique_sale_   := Project_API.Get_Proj_Unique_Sale_Db(newrec_.project_id);
            IF (proj_unique_sale_ = 'TRUE') THEN
               order_project_id_ := order_rec_.project_id;
               IF (order_project_id_ IS NULL) THEN
                  Customer_Order_API.Modify_Project_Id(newrec_.order_no, newrec_.project_id);
               END IF;
               currency_type_ := Project_API.Get_Currency_Type(newrec_.project_id, company_);
            END IF;
         $ELSE
            Error_SYS.Record_General(lu_name_, 'ACTIVITYNOTINST: Activity Sequence may not be set since Activity is not installed.');
         $END
      END IF;
   ELSE
      newrec_.project_id := NULL;
      IF (oldrec_.activity_seq IS NOT NULL) THEN
         IF (order_rec_.currency_rate_type IS NULL) THEN
            currency_type_ := Currency_Type_API.Get_Default_Type(company_, 'CUSTOMER');
         ELSE
            currency_type_ := order_rec_.currency_rate_type;
         END IF;      
      END IF;
   END IF;
   IF ((currency_type_ IS NOT NULL) AND (newrec_.rowstate != 'Cancelled')) THEN 
      IF (order_rec_.use_price_incl_tax = 'TRUE') THEN
         Customer_Order_Pricing_API.Get_Base_Price_In_Currency( newrec_.base_unit_price_incl_tax, newrec_.currency_rate,
                                                                NVL(order_rec_.customer_no_pay, order_rec_.customer_no),
                                                                newrec_.contract,order_rec_.currency_code, newrec_.unit_price_incl_tax,
                                                                currency_type_);
      ELSE
         Customer_Order_Pricing_API.Get_Base_Price_In_Currency( newrec_.base_sale_unit_price, newrec_.currency_rate,
                                                                NVL(order_rec_.customer_no_pay, order_rec_.customer_no),
                                                                newrec_.contract,order_rec_.currency_code, newrec_.sale_unit_price,
                                                                currency_type_);
      END IF;      
      Calculate_Prices(newrec_);       
   END IF;

   -- Update should only be done if the configuration has changed, it not the flow might get stuck in an infinite loop.
   IF (newrec_.configuration_id != '*' AND newrec_.configuration_id != oldrec_.configuration_id) THEN
      Order_Config_Util_API.Update_Configuration__('CUSTOMERORDER', newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no,
                                                   oldrec_.configuration_id, newrec_.configuration_id, newrec_.ctp_planned, newrec_.supply_code );
   END IF;

   -- Maintain qty_short for inventory demand shortage.
   IF (oldrec_.qty_short > 0) AND ((oldrec_.revised_qty_due != newrec_.revised_qty_due) OR
      (oldrec_.qty_shipdiff != newrec_.qty_shipdiff) OR (oldrec_.qty_assigned != newrec_.qty_assigned)) THEN
      IF (newrec_.rowstate IN ('Delivered', 'Invoiced', 'Cancelled')) OR (newrec_.qty_shipdiff > 0) THEN
         newrec_.qty_short := 0;
      ELSIF (newrec_.qty_assigned + newrec_.qty_short + newrec_.qty_shipped) != newrec_.revised_qty_due THEN
         IF (newrec_.supply_code IN ('IO','PS')) AND (newrec_.qty_on_order > 0) THEN
            newrec_.qty_short := GREATEST(newrec_.revised_qty_due - newrec_.qty_assigned - newrec_.qty_shipped - newrec_.qty_on_order, 0);
         ELSE
            newrec_.qty_short := GREATEST(newrec_.revised_qty_due - newrec_.qty_assigned - newrec_.qty_shipped, 0);
         END IF;
      END IF;
   END IF;

   IF (newrec_.qty_shipped != oldrec_.qty_shipped) AND newrec_.demand_code = 'PI' THEN
      -- IF some qty delivered, update forecast in Project MS
      Update_Proj_Ms_Forecast___(newrec_.contract,
                                 newrec_.part_no,
                                 (newrec_.qty_shipped - oldrec_.qty_shipped),
                                 newrec_.planned_due_date,
                                 newrec_.activity_seq);
   END IF;

   IF (newrec_.qty_returned != oldrec_.qty_returned) THEN
      IF ((newrec_.qty_shipped < 0) AND (newrec_.qty_returned != 0)) OR
         ((newrec_.qty_shipped > 0) AND (newrec_.qty_returned > newrec_.qty_shipped)) THEN
         -- Error if quantity returned is greater than quantity delivered.
         -- Qty shipped could be negative if line was created from service management.
         Error_SYS.Record_General(lu_name_, 'TOMUCHTORETURN: The quantity to return exceeds the maximum quantity to return.');
      END IF;

      IF newrec_.demand_code = 'PI' THEN
         -- IF some qty returned, update forecast in Project MS
         Update_Proj_Ms_Forecast___(newrec_.contract,
                                    newrec_.part_no,
                                    (oldrec_.qty_returned - newrec_.qty_returned),
                                    newrec_.planned_due_date,
                                    newrec_.activity_seq);
      END IF;
   END IF;

   site_date_ := Site_API.Get_Site_Date(newrec_.contract);

   IF (newrec_.rowstate = 'Cancelled') THEN
      IF (newrec_.supply_code = 'PKG') AND (newrec_.promised_delivery_date != oldrec_.promised_delivery_date) THEN
         Update_Package___(newrec_.promised_delivery_date, newrec_.planned_delivery_date, newrec_.planned_ship_date, newrec_.planned_due_date, newrec_, insert_package_mode_, block_component_info_, dop_replicate_msg_);
      END IF;
   ELSE
      IF (oldrec_.rowstate IN ('Released', 'PartiallyDelivered') 
         AND (((newrec_.supply_code ='NO') AND ((newrec_.catalog_type != 'KOMP') OR (order_rec_.backorder_option != 'INCOMPLETE PACKAGES NOT ALLOWED'))) OR
         (newrec_.supply_code IN ('SEO', 'PRJ'))) AND ((oldrec_.revised_qty_due != newrec_.revised_qty_due) OR (oldrec_.planned_due_date != newrec_.planned_due_date))) THEN
         IF ((trunc(newrec_.planned_due_date) <= trunc(site_date_)) OR
            (Cust_Order_Type_API.Get_Oe_Alloc_Assign_Flag(order_rec_.order_id) = Cust_Ord_Reservation_Type_API.Decode('Y'))) THEN
            newrec_.qty_to_ship := newrec_.buy_qty_due - newrec_.qty_shipped;
            Client_SYS.Add_To_Attr('QTY_TO_SHIP', newrec_.qty_to_ship, attr_);
            IF (newrec_.shipment_connected = 'TRUE') THEN              
              Shipment_Line_API.Reserve_Non_Inventory(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, 'CUSTOMER_ORDER', newrec_.qty_to_ship);
            END IF;
            IF (oldrec_.qty_to_ship = 0) THEN
               Customer_Order_Line_Hist_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no,
               Language_SYS.Translate_Constant(lu_name_, 'CANBESHIPPED: The line can now be shipped'));
            END IF;
         ELSIF (oldrec_.qty_to_ship > 0) THEN
            IF (newrec_.revised_qty_due < oldrec_.revised_qty_due) THEN
               -- The ordered quantity has been decreased.
               newrec_.qty_to_ship := newrec_.revised_qty_due - newrec_.qty_shipped;
               Client_SYS.Add_Info(lu_name_, 'QTY_TO_SHIP_UPDATE: Quantity Non Inventory to Deliver has been updated.');
            ELSIF (newrec_.revised_qty_due > oldrec_.revised_qty_due) THEN
               -- The ordered quantity has been increased.
               Client_SYS.Add_Info(lu_name_, 'UPDATE_QTY_RESERVED: Reserve the increased Sales Quantity to update Quantity Non Inventory to Deliver.');
            END IF;
            IF ((TRUNC(newrec_.planned_due_date) > TRUNC(site_date_))
               AND (newrec_.revised_qty_due = oldrec_.revised_qty_due)) THEN
               newrec_.qty_to_ship := 0;
               Client_SYS.Add_To_Attr('QTY_TO_SHIP', newrec_.qty_to_ship, attr_);
               IF (newrec_.shipment_connected = 'TRUE') THEN                 
                 Shipment_Line_API.Unreserve_Non_Inventory(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, 'CUSTOMER_ORDER', newrec_.qty_to_ship, TRUE);
               END IF;
            END IF;
         END IF;
      END IF;

      IF make_reservation_ THEN
         -- only create priority / instant reservations when its not a CTP planned/reserved line
         IF (newrec_.ctp_planned = 'N') THEN
            IF (newrec_.supply_code = 'IPD') THEN
               contract_ := newrec_.supply_site;
               IF (Sales_Part_API.Check_Exist(contract_, newrec_.part_no) = 0) THEN
                  part_no_ := Sales_Part_Cross_Reference_API.Get_Catalog_No(Cust_Ord_Customer_API.Get_Customer_No_From_Contract(newrec_.contract),
                                                                            contract_, newrec_.part_no);
               ELSE
                  part_no_ := newrec_.part_no;
               END IF;
            ELSE
               contract_ := newrec_.contract;
               part_no_  := newrec_.part_no;
            END IF;

            local_site_reservation_exist_ := NVL(Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('LOCAL_SITE_RESERVATION_EXIST', attr_)), 0);

            IF (Reserve_Customer_Order_API.Is_Supply_Chain_Reservation(newrec_.order_no,
                                         newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, NULL, newrec_.contract,
                                         newrec_.supply_code, newrec_.vendor_no, NVL(part_no_,newrec_.purchase_part_no),
                                         newrec_.supply_site_reserve_type, 'INSTANT') = 1) THEN
               -- instant supply chain reservation
               Reserve_Customer_Order_API.Create_Instant_Reservation__(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no,
                                                                       NULL, NVL(part_no_,newrec_.purchase_part_no), newrec_.revised_qty_due,
                                                                       newrec_.qty_shipped, objid_, newrec_.vendor_no);
            ELSIF (local_site_reservation_exist_= 0) THEN
               -- dont make any priority reservation if a local site reservation exist
               Reserve_Customer_Order_API.Create_Priority_Reservation__(newrec_.qty_assigned, contract_,
                     part_no_, newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.revised_qty_due,
                     newrec_.qty_shipped, newrec_.supply_code, objid_);
            END IF;

            IF (newrec_.supply_code = 'IO') THEN
               Client_SYS.Set_Item_Value('QTY_ASSIGNED', newrec_.qty_assigned, attr_);
            END IF;
         END IF;
      END IF;

      -- Note: Create a history record if provisional price check is changed.
      IF (oldrec_.provisional_price != newrec_.provisional_price) THEN
         IF (newrec_.provisional_price = 'TRUE') THEN
            prov_msg_text_ := Language_SYS.Translate_Constant(lu_name_, 'PROV_PRICE_CHK1: Provisional price has been checked.');
         ELSE
            prov_msg_text_ := Language_SYS.Translate_Constant(lu_name_, 'PROV_PRICE_CHK2: Provisional price has been un-checked.');
         END IF;

         msg_text_ := SUBSTR(prov_msg_text_, 1, 200);
         Customer_Order_Line_Hist_API.New( newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, msg_text_);
      END IF;

      IF (newrec_.line_item_no <= 0) THEN
         IF (newrec_.supply_code = 'PKG') THEN
            dop_replicate_msg_ := Client_SYS.Get_Item_Value('DOP_NEW_QTY_DEMAND', attr_);
            IF (NVL(server_data_change_,0) != 1) AND (NVL(replicate_changes_, 'FALSE') = 'TRUE') AND (header_rowstate_ != 'Planned') AND (dop_replicate_msg_ IS NOT NULL) THEN
               IF ((oldrec_.buy_qty_due != newrec_.buy_qty_due) OR (oldrec_.wanted_delivery_date != newrec_.wanted_delivery_date) OR (Message_SYS.Find_Attribute(dop_replicate_msg_, 'FROM_CO_HEAD_CLIENT', 'FALSE') = 'TRUE')) THEN
                  $IF (Component_Dop_SYS.INSTALLED) $THEN
                     no_of_dop_conns_ := Dop_Demand_Cust_Ord_API.Get_No_Of_All_Dop_Headers(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, 'TRUE');
                  $END
                  IF (NVL(no_of_dop_conns_,0) > 1) THEN
                     order_info_ := newrec_.order_no || '-' || newrec_.line_no || '-' || newrec_.rel_no;
                     Client_SYS.Add_Info(lu_name_,'MOREDOPCONNS: There is more than one DOP header connected to the CO line :P1. The change in the CO line will not be replicated in any of them.', order_info_);
                     dop_replicate_msg_ := NULL;
                  END IF;
               ELSE
                  dop_replicate_msg_ := NULL;
               END IF;
            ELSE
               dop_replicate_msg_ := NULL;
            END IF;

            -- Save any info messages before we start to handle the components
            Add_Info___(insert_package_mode_);
            -- Set the block component info flag so we stop the component info messages generated from Change_Package_Structure___ later on
            block_component_info_ := 'TRUE';

            Update_Package___(newrec_.promised_delivery_date, newrec_.planned_delivery_date, newrec_.planned_ship_date, newrec_.planned_due_date, newrec_, insert_package_mode_, block_component_info_, dop_replicate_msg_);

            block_component_info_ := 'FALSE';

         END IF;
         IF (oldrec_.promised_delivery_date != newrec_.promised_delivery_date) THEN
            Check_Allow_Backorders___(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.planned_delivery_date);
         END IF;
      END IF;

      IF ((oldrec_.line_item_no >= 0) AND (newrec_.supply_code = 'DOP') AND (NVL(server_data_change_,0) != 1)) THEN
         dop_replicate_msg_ := Client_SYS.Get_Item_Value('DOP_NEW_QTY_DEMAND', attr_);
         IF ((NVL(replicate_changes_, 'FALSE') = 'TRUE') AND (((oldrec_.line_item_no > 0) AND (dop_replicate_msg_ IS NULL)) 
            OR ((Fnd_Session_API.Is_Odp_Session) AND (oldrec_.buy_qty_due != newrec_.buy_qty_due) AND (oldrec_.wanted_delivery_date = newrec_.wanted_delivery_date)))) THEN
            $IF (Component_Dop_SYS.INSTALLED) $THEN
               no_of_dop_conns_ := Dop_Demand_Cust_Ord_API.Get_No_Of_All_Dop_Headers(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, 'TRUE');
            $END
            IF (NVL(no_of_dop_conns_, 0) > 1) THEN
               order_info_ := newrec_.order_no || '-' || newrec_.line_no || '-' || newrec_.rel_no || '-' || newrec_.line_item_no;
               Client_SYS.Add_Info(lu_name_, 'MOREDOPCONNS: There is more than one DOP header connected to the CO line :P1. The change in the CO line will not be replicated in any of them.', order_info_);
               IF (NOT Fnd_Session_API.Is_Odp_Session) THEN
                  dop_replicate_msg_ := NULL;
               END IF;
            ELSE
               dop_replicate_msg_ := Message_SYS.Construct(dop_replicate_msg_);
               Message_SYS.Add_Attribute(dop_replicate_msg_,'REPLICATE_DOP_IN_SERVER','TRUE');
            END IF;
            Client_SYS.Set_Item_Value('DOP_NEW_QTY_DEMAND', dop_replicate_msg_, attr_);
         END IF;
         IF ((oldrec_.line_item_no = 0) AND (newrec_.supply_code = 'DOP') AND (NVL(server_data_change_,0) != 1)) THEN
            -- Modify DOP structure for part with Supply_Type = 'Dop'
            IF (header_rowstate_ != 'Planned') THEN
               Connect_Customer_Order_API.Modify_Dop(newrec_.qty_on_order,
                                                     newrec_.order_no,
                                                     newrec_.line_no,
                                                     newrec_.rel_no,
                                                     newrec_.line_item_no,
                                                     newrec_.revised_qty_due,
                                                     newrec_.planned_due_date,
                                                     dop_replicate_msg_,
                                                     NVL(replicate_changes_, 'FALSE'));
            END IF;
         END IF;
      END IF;
   END IF;

   -- This needs for stage billing invoicing porcess when Group discount is there for sales part.
   IF (newrec_.staged_billing = 'STAGED BILLING') THEN
      old_sale_price_total_ := Get_Sale_Price_Total(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      old_sale_price_incl_tax_total_ := Get_Sale_Price_Incl_Tax_Total(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
   END IF;
   -- Recalculate sale_unit_price and base_sale_unit_price
   IF (newrec_.line_item_no <= 0) THEN
      IF ((newrec_.price_freeze = 'FREE') AND ((NVL(newrec_.char_price, 0) != NVL(oldrec_.char_price, 0)) OR (newrec_.price_freeze != oldrec_.price_freeze))) THEN
         IF (order_rec_.use_price_incl_tax = 'TRUE') THEN
            IF (newrec_.free_of_charge = Fnd_Boolean_API.DB_FALSE OR newrec_.unit_price_incl_tax != 0) THEN
               newrec_.unit_price_incl_tax := newrec_.part_price + NVL(newrec_.char_price, 0);
            END IF;            
            IF (newrec_.unit_price_incl_tax != oldrec_.unit_price_incl_tax) THEN
               Customer_Order_Pricing_API.Get_Base_Price_In_Currency( newrec_.base_unit_price_incl_tax, newrec_.currency_rate,
                                                                      NVL(order_rec_.customer_no_pay, order_rec_.customer_no),
                                                                      newrec_.contract,order_rec_.currency_code, newrec_.unit_price_incl_tax,
                                                                      nvl(currency_type_, order_rec_.currency_rate_type));
            END IF;
            Client_SYS.Set_Item_Value('UNIT_PRICE_INCL_TAX',      newrec_.unit_price_incl_tax,      attr_);
            Client_SYS.Set_Item_Value('BASE_UNIT_PRICE_INCL_TAX', newrec_.base_unit_price_incl_tax, attr_);
         ELSE
            IF (newrec_.free_of_charge = Fnd_Boolean_API.DB_FALSE OR newrec_.sale_unit_price != 0) THEN
               newrec_.sale_unit_price := newrec_.part_price + NVL(newrec_.char_price, 0);
            END IF;            
            IF (newrec_.sale_unit_price != oldrec_.sale_unit_price) THEN
               Customer_Order_Pricing_API.Get_Base_Price_In_Currency( newrec_.base_sale_unit_price, newrec_.currency_rate,
                                                                      NVL(order_rec_.customer_no_pay, order_rec_.customer_no),
                                                                      newrec_.contract,order_rec_.currency_code, newrec_.sale_unit_price,
                                                                      nvl(currency_type_, order_rec_.currency_rate_type));
            END IF;
            Client_SYS.Set_Item_Value('SALE_UNIT_PRICE', newrec_.sale_unit_price, attr_);
            Client_SYS.Set_Item_Value('BASE_SALE_UNIT_PRICE', newrec_.base_sale_unit_price, attr_);
         END IF;         
         Calculate_Prices(newrec_);            
      END IF;
   END IF;

   originating_rel_no_       := Get_Originating_Rel_No(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
   originating_line_item_no_ := Get_Originating_Line_Item_No(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);

   source_msg_text_ := NULL;
   current_info_    :=  App_Context_SYS.Find_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_');

   IF (oldrec_.demand_code IS NULL OR oldrec_.demand_code != 'RCO') THEN
      IF ((originating_rel_no_ IS NOT NULL ) AND (originating_line_item_no_ = 0)) THEN
         source_msg_text_ := Language_SYS.Translate_Constant(lu_name_, 'ORILNEITMNO_NULL: The order line :P1-:P2 is sourced and originates from another order line. Check the other sourced order line(s) with the same previous delivery number.', NULL,
                                                                 (newrec_.order_no ||'-'||newrec_.line_no ||'-'|| newrec_.rel_no), to_char(newrec_.line_item_no));
         source_msg_text_ := LTRIM(SUBSTR(source_msg_text_, INSTR(source_msg_text_, ':') + 1));
         len_msg_text_    := instr(current_info_, source_msg_text_);

         IF (len_msg_text_ IS NULL) OR (len_msg_text_= 0) THEN
            Client_SYS.Add_Info(lu_name_, 'ORILNEITMNO_NULL: The order line :P1-:P2 is sourced and originates from another order line. Check the other sourced order line(s) with the same previous delivery number.',
                                (newrec_.order_no ||'-'||newrec_.line_no ||'-'|| newrec_.rel_no), to_char(newrec_.line_item_no));
         END IF;
      ELSIF (originating_line_item_no_ > 0) THEN
         source_msg_text_ := Language_SYS.Translate_Msg_(lu_name_, 'ORILNEITMNO_NOT_NULL: This order line is sourced and originates from another order lines package component. Check the other order lines package components with the same "Sales Part No".');
         source_msg_text_ := LTRIM(SUBSTR(source_msg_text_, INSTR(source_msg_text_, ':') + 1));
         len_msg_text_    := INSTR(current_info_, source_msg_text_);

         IF (len_msg_text_ IS NULL) OR (len_msg_text_= 0) THEN
            Client_SYS.Add_Info(lu_name_, 'ORILNEITMNO_NOT_NULL: This order line is sourced and originates from another order lines package component. Check the other order lines package components with the same "Sales Part No".');
         END IF;
      END IF;
   END IF;

   -- Recalculate prices / prices incl tax if tax code or quantity is changed
   IF (newrec_.buy_qty_due != oldrec_.buy_qty_due) THEN      
      Calculate_Prices(newrec_);      
   END IF;

   --  fetch the latest rowstate before calling Update___ to avoid setting it to a old value. There are some reservation methods called above which will do a state change.
   newrec_.rowstate := Get_Objstate(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);   
      
   super(objid_, oldrec_, newrec_, attr_, objversion_, by_keys_);
   
   IF (newrec_.line_item_no <= 0) THEN
      IF (Client_SYS.Get_Item_Value('EVALUATE_DEFAULT_INFO', attr_) = 'TRUE') THEN
         evaluate_default_info_ := TRUE;
      END IF;
      IF evaluate_default_info_ THEN
         new_default_addr_flag_ := Check_Default_Addr_Flag___(newrec_, newrec_.order_no, newrec_.default_addr_flag);
         newrec_.default_addr_flag := new_default_addr_flag_;
      END IF; 
      
      IF (newrec_.default_addr_flag = 'N') THEN
         -- remove any prior single occurence address
         IF ((newrec_.addr_flag = 'N') AND (oldrec_.addr_flag = 'Y')) THEN
            Cust_Order_Line_Address_API.Remove_Address__(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
         END IF;
         -- create new default address if single occurence
         IF ((newrec_.addr_flag = 'Y') AND (oldrec_.addr_flag = 'N')) OR ((oldrec_.default_addr_flag = 'Y') AND (newrec_.addr_flag = 'Y')) THEN
            Insert_Default_Address___(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.customer_no, newrec_.ship_addr_no, newrec_.deliver_to_customer_no);
            IF nvl(Client_SYS.Get_Item_Value('COPY_ADDR_TO_LINE', attr_),'FALSE') = 'FALSE' THEN 
               replication_not_needed_ := 'SENT';
            END IF ;
         END IF;
      ELSIF (oldrec_.default_addr_flag = 'N') THEN
         -- if user unchecked the address flag, remove the single occurence address
         IF ((newrec_.addr_flag = 'N') OR (oldrec_.addr_flag = 'Y')) THEN
            -- Remove the address if a single occurance existed from last save
            Cust_Order_Line_Address_API.Remove_Address__(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
         END IF;
      -- if default address flag wasn't updated, remove address just in case (if it exists)
      ELSIF (newrec_.default_addr_flag = 'Y') THEN
         Cust_Order_Line_Address_API.Remove_Address__(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      END IF;
      IF evaluate_default_info_ THEN
         Modify_Default_Addr_Flag__(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.default_addr_flag);  
      END IF;
      Customer_Order_Flow_API.Modify_License_Address(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.demand_code, newrec_.demand_order_ref1, newrec_.demand_order_ref2, newrec_.demand_order_ref3); -- Export control

      Client_SYS.Set_Item_Value('DEFAULT_ADDR_FLAG_DB', newrec_.default_addr_flag, attr_);
      Client_SYS.Set_Item_Value('SHIP_ADDR_NO', newrec_.ship_addr_no, attr_);
      Client_SYS.Set_Item_Value('ADDR_FLAG_DB', newrec_.addr_flag, attr_);
   END IF;
   
   Modify_Connected_Order_Line___ (newrec_, attr_, oldrec_, replicate_changes_, header_rowstate_, po_charged_comp_change_,
                                   update_pegged_orders_, change_request_, changed_attrib_not_in_pol_, server_data_change_);
      
   IF (newrec_.rowstate != 'Cancelled') THEN
      IF (newrec_.line_item_no <= 0) THEN
         IF (newrec_.supply_code = 'PKG') THEN
            -- Do Replication for package components based on client value sent.
            IF ((NVL(server_data_change_, 0) != 1) OR
                (NVL(oldrec_.activity_seq, -9999) != NVL(newrec_.activity_seq, -9999)) OR (po_charged_comp_change_ = 'TRUE')) THEN
               OPEN get_component_lines;
               FETCH get_component_lines INTO comp_rec_;

               LOOP
                  EXIT WHEN get_component_lines%NOTFOUND;
                  -- next_comp_rec_ is not set to null when NOTFOUND. So, set it to NULL to make next_component_rec_.po_order_no = component_rec_.po_order_no FALSE in the last iteration
                  next_comp_rec_ := NULL;

                  FETCH get_component_lines INTO next_comp_rec_;
                  temp_change_request_ := change_request_;
                  IF (replicate_changes_ = 'TRUE' AND comp_rec_.po_order_no IS NOT NULL AND  next_comp_rec_.po_order_no = comp_rec_.po_order_no) THEN
                     temp_change_request_ :='FALSE';
                  END IF;
                  
                  -- Initialize the component line record.
                  new_comprec_ := newrec_;
                  
                  -- Assign values from component line. 
                  new_comprec_.line_item_no              := comp_rec_.line_item_no;                  
                  new_comprec_.supply_code               := comp_rec_.supply_code;
                  new_comprec_.revised_qty_due           := comp_rec_.revised_qty_due;
                  new_comprec_.qty_on_order              := comp_rec_.qty_on_order;
                  new_comprec_.qty_assigned              := comp_rec_.qty_assigned;
                  new_comprec_.qty_shipped               := comp_rec_.qty_shipped;                  
                  new_comprec_.part_no                   := comp_rec_.part_no;
                  new_comprec_.ship_via_code             := comp_rec_.ship_via_code;
                  new_comprec_.forward_agent_id          := comp_rec_.forward_agent_id;
                  new_comprec_.delivery_terms            := comp_rec_.delivery_terms;
                  new_comprec_.del_terms_location        := comp_rec_.del_terms_location;
                  new_comprec_.ext_transport_calendar_id := comp_rec_.ext_transport_calendar_id;
                  new_comprec_.addr_flag                 := comp_rec_.addr_flag;
                  new_comprec_.ship_addr_no              := comp_rec_.ship_addr_no;
                  new_comprec_.default_addr_flag         := comp_rec_.default_addr_flag;
                  
                  Modify_Connected_Order_Line___ (new_comprec_, attr_, oldrec_, replicate_changes_, header_rowstate_, po_charged_comp_change_,
                                   update_pegged_orders_, temp_change_request_, changed_attrib_not_in_pol_, server_data_change_);

                  -- Connect the Package Component Lines to project.
                  IF (NVL(oldrec_.activity_seq, -9999) != NVL(newrec_.activity_seq, -9999)) THEN
                     Client_SYS.Clear_Attr(comp_attr_);
                     Client_SYS.Add_To_Attr('ACTIVITY_SEQ', newrec_.activity_seq, comp_attr_);
                     Modify_Line___(comp_attr_, newrec_.order_no, newrec_.line_no, newrec_.rel_no, comp_rec_.line_item_no);
                  END IF;
                  comp_rec_ := next_comp_rec_;
               END LOOP;
               CLOSE get_component_lines;
            END IF;
         END IF;
      END IF;
   END IF;
   
   IF (replication_not_needed_ != 'SENT') AND (NVL(replicate_changes_, 'FALSE') = 'TRUE') THEN
      Cust_Order_Line_Address_API.Modify_Connected_Addr_Line__(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, 
                                    replicate_changes_, change_request_, header_rowstate_, newrec_.supply_code); 
   END IF;
   
   IF (newrec_.buy_qty_due != 0) THEN
      IF (oldrec_.discount != newrec_.discount) AND ((server_data_change_ != 1) OR (change_request_ = 'TRUE')) THEN
         -- gelr:disc_price_rounded, begin
         IF (discounted_price_rounded_) THEN
            newrec_.discount := newrec_.original_discount;   
         END IF;
         -- gelr:disc_price_rounded, end
         Cust_Order_Line_Discount_API.Add_Remove_Update_Line(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.discount, newrec_.contract);
         -- gelr:disc_price_rounded, begin
         -- if DISCPRICEROUNDED is not set, discount will be calculated in a core way, and original_discount will be equal discount
         IF (discounted_price_rounded_) THEN
            Cust_Order_Line_Discount_API.Calc_Discount_Upd_Co_Line__(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
            newrec_.discount := Get_Discount(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
            newrec_.original_discount := Get_Original_Discount(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
         END IF;
         -- gelr:disc_price_rounded, end         
      END IF;
   END IF;

   IF (newrec_.buy_qty_due > oldrec_.buy_qty_due) THEN
      IF (header_rowstate_ IN ('Reserved','Picked','PartiallyDelivered') and newrec_.supply_code IN ('SO','PT','IPT','DOP') AND newrec_.qty_on_order = 0) THEN
         Client_Sys.Add_Info(lu_name_,'INCREASEDDEMAND: Increasing the sales quantity will not create any new pegged supply. Reservation can still be done from standard inventory');
      END IF;
      Generate_Next_Level_Demands___(header_rowstate_, newrec_);
   END IF;
   
   -- gelr:disc_price_rounded, begin
   -- Recalculate additional_discount and order_discount to achive net value the same as rounded price
   -- All of this variables affects net value, therefore all of this can affect recalculated additional_discount and order_discount
   -- if DISCPRICEROUNDED is not set, calculated discounts and original discounts will be the same
   IF (discounted_price_rounded_) THEN
      IF ((newrec_.buy_qty_due != oldrec_.buy_qty_due) OR
          (newrec_.base_sale_unit_price != oldrec_.base_sale_unit_price) OR
          (newrec_.order_discount != oldrec_.order_discount) OR
          (newrec_.additional_discount != oldrec_.additional_discount) OR
          (newrec_.discount != oldrec_.discount)) THEN

         -- 1. additional_discount
         -- user/system operates on additional_discount but it is saved in technical column: original_add_discount
         -- Initialize original_ column which is now empty
         IF (newrec_.additional_discount != oldrec_.additional_discount) THEN
            newrec_.original_add_discount := newrec_.additional_discount;
         ELSE
            -- the reason of recalculation was NOT changing of additional_discount but the other variable
            newrec_.original_add_discount := oldrec_.original_add_discount;
         END IF;
         newrec_.additional_discount := Customer_Order_Pricing_API.Calculate_Additional_Discount(newrec_.contract,
                                                                      order_rec_.currency_code,
                                                                      newrec_.original_add_discount,
                                                                      newrec_.buy_qty_due,
                                                                      newrec_.price_conv_factor,
                                                                      newrec_.sale_unit_price,
                                                                      newrec_.discount);

         -- 2. order_discount
         -- Read the comment upper
         IF (newrec_.order_discount != oldrec_.order_discount) THEN
            newrec_.original_order_discount := newrec_.order_discount;
         ELSE
            newrec_.order_discount := oldrec_.order_discount;
         END IF;
         newrec_.order_discount := customer_Order_Pricing_API.Calculate_Additional_Discount(newrec_.contract,
                                                                 order_rec_.currency_code,
                                                                 newrec_.original_order_discount,
                                                                 newrec_.buy_qty_due,
                                                                 newrec_.price_conv_factor,
                                                                 newrec_.sale_unit_price,
                                                                 newrec_.discount);
         Update_Line___(objid_, newrec_);
      END IF;
   END IF;
   -- discount and original_discount are handle in diffrent way in Modify_Discount__()
   -- they both comes from cust_order_line_discount_tab.
   -- Sometimes discount is not changed (because it comes from rounded price) but original should be.
   -- gelr:disc_price_rounded, end

   $IF (Component_Jinsui_SYS.INSTALLED)$THEN
      IF order_rec_.jinsui_invoice ='TRUE' THEN
         Validate_Jinsui_Constraints__(newrec_, 0, FALSE);
      END IF;
   $END  

   IF Tax_Liability_Countries_API.Check_Valid_Info_Exist(company_, order_rec_.supply_country, site_date_) = 'TRUE' THEN
      IF Tax_Liability_API.Get_Tax_Liability_Type_Db(order_rec_.tax_liability, newrec_.country_code) != 'EXM' AND 
         oldrec_.tax_liability_type != 'EXM' AND newrec_.tax_liability_type = 'EXM'  THEN
         Client_SYS.Add_Info(lu_name_, 'EXEMPTLIABILITY: Since the tax liability type is ''Exempt'' the Supply Country Tax ID No will be printed on the invoice.');
      ELSIF (oldrec_.ship_addr_no != newrec_.ship_addr_no) THEN
         header_deliver_country_db_ := Customer_Order_Address_API.Get_Country_Code(newrec_.order_no);
         -- if the line is not defaulted from header and is having a NON-single occurence address
         IF newrec_.default_addr_flag = 'N' AND newrec_.addr_flag = 'N' AND newrec_.country_code != header_deliver_country_db_ THEN
            Client_SYS.Add_Info(lu_name_, 'DIFFDELIVCOUNTRY: Since delivery address country is not the same as the header delivery address country the Supply Country Tax ID No will be printed on the invoice.');
         END IF;
      END IF;
   END IF;

   IF oldrec_.supply_code = 'ND' AND newrec_.supply_code != 'ND' THEN
      IF (newrec_.originating_rel_no IS NOT NULL) THEN
         msg_text_ := SUBSTR(Language_SYS.Translate_Constant(lu_name_,'SRC_ORG: Line created from source lines with del no :P1',NULL,newrec_.originating_rel_no), 1, 200);
         Customer_Order_Line_Hist_API.New( newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, msg_text_);
      END IF;
   END IF;

   IF (newrec_.line_item_no > 0) THEN
      linerec_ := Get_Object_By_Keys___(newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1);

      IF ((newrec_.buy_qty_due != oldrec_.buy_qty_due) OR (newrec_.cost != oldrec_.cost) OR (oldrec_.supply_code != newrec_.supply_code) OR
          (NVL(tax_code_changed_, 'FALSE') = 'TRUE')) THEN
         -- Buy quantity due changed for a component -> Recalculate package structure.
         -- or the cost changed (due to cost roll up of interim order or change of condition code)
         -- Modify the cost for the package  header order line
         IF ((newrec_.buy_qty_due != oldrec_.buy_qty_due) OR (newrec_.cost != oldrec_.cost))  THEN
            Update_Package_Cost___(linerec_.cost, newrec_.order_no, newrec_.line_no, newrec_.rel_no);
         END IF;
         IF (newrec_.buy_qty_due != oldrec_.buy_qty_due) THEN
            do_qty_ := TRUE;
         END IF;
         Change_Package_Structure___(linerec_.promised_delivery_date, linerec_.planned_delivery_date,
                                     linerec_.planned_ship_date, linerec_.planned_due_date, linerec_, do_qty_, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, insert_package_mode_, block_component_info_, NULL);
         IF (newrec_.cost != oldrec_.cost) THEN
            Trace_Sys.Field(' new cost of component', newrec_.cost);
            Trace_Sys.Field(' new cost of package  ', linerec_.cost);
         END IF;
         pkg_changed_ := TRUE;
      END IF;
      IF (NVL(newrec_.calc_char_price, 0) != NVL(oldrec_.calc_char_price, 0)) OR (NVL(newrec_.char_price, 0) != NVL(oldrec_.char_price, 0)) THEN
         linerec_.calc_char_price := 0;
         linerec_.char_price      := 0;
         pkg_changed_             := TRUE;
      END IF;
      IF (newrec_.shipment_creation = 'NO_AUTOMATIC') AND (linerec_.shipment_creation != 'NO_AUTOMATIC') THEN
         linerec_.shipment_creation := 'NO_AUTOMATIC';
         pkg_changed_               := TRUE;
      END IF;
      IF (newrec_.qty_per_assembly != oldrec_.qty_per_assembly OR newrec_.qty_to_ship != oldrec_.qty_to_ship) THEN
         pkg_qty_reserved_ :=  Reserve_Customer_Order_API.Get_No_Of_Packages_Reserved(newrec_.order_no, newrec_.line_no, newrec_.rel_no);
         IF (linerec_.qty_assigned != pkg_qty_reserved_) THEN
            linerec_.qty_assigned := pkg_qty_reserved_;
            pkg_changed_          := TRUE;
         END IF;
      END IF;
      IF pkg_changed_ THEN
         Get_Id_Version_By_Keys___(rowid_, rowversion_, newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1);
         linerec_.rowversion := sysdate;
         Update_Line___(rowid_, linerec_);
      END IF;
   END IF;
   
   IF (newrec_.rowstate != 'Cancelled') THEN
      -- if supply code has changed from Not Decided to any order supply - create the connected order.
      IF (header_rowstate_ NOT IN ('Planned', 'Blocked')) THEN
         IF ((oldrec_.supply_code IN ('ND', 'IO', 'PI') OR (oldrec_.rel_mtrl_planning = 'FALSE' AND newrec_.rel_mtrl_planning = 'TRUE')) AND
            newrec_.supply_code IN ('SO', 'PT', 'PD', 'IPT', 'IPD', 'DOP')) OR
            (oldrec_.supply_code IN ('NO', 'PRJ') AND newrec_.supply_code IN ('PT','PD', 'IPT', 'IPD')) THEN
            -- If update triggers from customer order release process connected orders should not be generated since,
            -- customer order release process itself generates the connected orders.
            IF NVL(Client_SYS.Get_Item_Value('CREATE_CONNECTED_ORDER', attr_), Fnd_Boolean_API.DB_TRUE) = Fnd_Boolean_API.DB_TRUE THEN
               -- When Purch is called in Connect_Customer_Order_API all info is lost
               Add_Info___(insert_package_mode_);

               -- Connected orders are normally created when the order is released,
               -- but if lines are updated after release - the work has to be done when the line is saved.
               -- IF the order is credit blocked the connected orders will be created when the credit
               -- block is released.

               -- IF the part is configurable then configuration has to be defined to create a connected order
               IF (Sales_Part_API.Get_Configurable_Db(newrec_.contract, newrec_.catalog_no) = 'CONFIGURED'
                   AND Order_Config_Util_API.Get_Config_Spec_Objstate(newrec_.part_no, newrec_.configuration_id) != 'Completed') THEN
                  create_connected_order_ := FALSE;
               END IF;
               IF (create_connected_order_) THEN
                  Connect_Customer_Order_API.Create_Connected_Order_Line(newrec_.qty_on_order, newrec_.order_no, newrec_.line_no,
                                                                         newrec_.rel_no, newrec_.line_item_no, FALSE);
               END IF;
            END IF;
         END IF;
      END IF;
   END IF;

   -- Store the info created so far locally because the methods called below could clear the global info.
   Add_Info___(insert_package_mode_);

   IF (newrec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
      Modify_Rental___( attr_, newrec_);
   END IF;

   IF (newrec_.line_item_no <= 0) THEN
      IF newrec_.shipment_connected = 'FALSE' AND oldrec_.shipment_connected = 'FALSE' THEN         
         Update_Freight_Free(newrec_);         
      END IF;

      IF (newrec_.buy_qty_due != oldrec_.buy_qty_due) OR (newrec_.rental = Fnd_Boolean_API.DB_TRUE AND new_rental_chargeable_days_ != old_rental_chargeable_days_) OR
         (NVL(newrec_.price_list_no, ' ') != NVL(oldrec_.price_list_no, ' ') OR
          NVL(to_char(newrec_.price_effectivity_date), '0') != NVL(TO_CHAR(oldrec_.price_effectivity_date), '0') OR
          (qty_refreshed_ = 1) OR (price_source_refreshed_ = 1) OR (oldrec_.price_source != newrec_.price_source)) THEN
          IF ((newrec_.price_freeze = 'FREE') AND ((server_data_change_ = 1) OR (NVL(price_refetch_, 'FALSE') = 'TRUE'))) THEN
             Customer_Order_Pricing_API.Get_Order_Line_Price_Info(sale_unit_price_ => newrec_.sale_unit_price,
                                                                  unit_price_incl_tax_ => newrec_.unit_price_incl_tax,
                                                                  base_sale_unit_price_ => newrec_.base_sale_unit_price,
                                                                  base_unit_price_incl_tax_ => newrec_.base_unit_price_incl_tax,
                                                                  currency_rate_ => newrec_.currency_rate,
                                                                  discount_ => newrec_.discount,
                                                                  price_source_ => price_source_,
                                                                  price_source_id_ => newrec_.price_source_id,
                                                                  provisional_price_db_ => newrec_.provisional_price,
                                                                  net_price_fetched_ => newrec_.price_source_net_price,
                                                                  rebate_builder_db_ => newrec_.rebate_builder,
                                                                  part_level_db_ => newrec_.part_level,
                                                                  part_level_id_ => newrec_.part_level_id,
                                                                  customer_level_db_ => newrec_.customer_level,
                                                                  customer_level_id_ => newrec_.customer_level_id,
                                                                  order_no_ => newrec_.order_no,
                                                                  catalog_no_ => newrec_.catalog_no,
                                                                  buy_qty_due_ => newrec_.buy_qty_due,
                                                                  price_list_no_ => newrec_.price_list_no,
                                                                  effectivity_date_ => newrec_.price_effectivity_date,
                                                                  condition_code_ => newrec_.condition_code,
                                                                  use_price_incl_tax_ => order_rec_.use_price_incl_tax,
                                                                  rental_chargable_days_ => new_rental_chargeable_days_);

             newrec_.price_source := Pricing_Source_API.Encode(price_source_);
             IF (order_rec_.use_price_incl_tax = 'TRUE') THEN
                newrec_.part_price   := newrec_.unit_price_incl_tax;
             ELSE
                newrec_.part_price   := newrec_.sale_unit_price;
             END IF;
             
             IF (newrec_.free_of_charge = Fnd_Boolean_API.DB_TRUE) THEN
                newrec_.rebate_builder := Fnd_Boolean_API.DB_FALSE;
             END IF;
             
             Calculate_Prices(newrec_);                     

             Client_SYS.Set_Item_Value('SALE_UNIT_PRICE',          newrec_.sale_unit_price,          attr_);
             Client_SYS.Set_Item_Value('UNIT_PRICE_INCL_TAX',      newrec_.unit_price_incl_tax,      attr_);
             Client_SYS.Set_Item_Value('BASE_SALE_UNIT_PRICE',     newrec_.base_sale_unit_price,     attr_);
             Client_SYS.Set_Item_Value('BASE_UNIT_PRICE_INCL_TAX', newrec_.base_unit_price_incl_tax, attr_);
             Client_SYS.Set_Item_Value('CURRENCY_RATE',            newrec_.currency_rate,            attr_);
             Client_SYS.Set_Item_Value('DISCOUNT',                 newrec_.discount,                 attr_);
             Client_SYS.Set_Item_Value('PRICE_SOURCE',             price_source_,                    attr_);
             Client_SYS.Set_Item_Value('PRICE_SOURCE_ID',          newrec_.price_source_id,          attr_);
             Client_SYS.Set_Item_Value('PROVISIONAL_PRICE_DB',     newrec_.provisional_price,        attr_);
             Client_SYS.Set_Item_Value('PART_PRICE',               newrec_.part_price,               attr_);
             Client_SYS.Set_Item_Value('PRICE_SOURCE_NET_PRICE',   newrec_.price_source_net_price,   attr_);
             Client_SYS.Set_Item_Value('REBATE_BUILDER_DB',        newrec_.rebate_builder,           attr_);
             Client_SYS.Set_Item_Value('PART_LEVEL_DB',            newrec_.part_level,               attr_);
             Client_SYS.Set_Item_Value('PART_LEVEL_ID',            newrec_.part_level_id,            attr_);
             Client_SYS.Set_Item_Value('CUSTOMER_LEVEL_DB',        newrec_.customer_level,           attr_);
             Client_SYS.Set_Item_Value('CUSTOMER_LEVEL_ID',        newrec_.customer_level_id,        attr_);
             Update_Line___(objid_, newrec_);
          END IF;

          IF (newrec_.configuration_id != '*') THEN
             Configured_Line_Price_API.Modify_Config_Line_Price (newrec_.char_price,
                                                                 newrec_.calc_char_price,
                                                                 newrec_.configuration_id,
                                                                 newrec_.configured_line_price_id,
                                                                 newrec_.catalog_no);
            IF (newrec_.price_freeze = 'FREE') AND (server_data_change_ = 1) THEN
               IF (order_rec_.use_price_incl_tax = 'TRUE') THEN
                  newrec_.unit_price_incl_tax := newrec_.part_price + NVL(newrec_.char_price, 0);
                  IF (newrec_.unit_price_incl_tax != oldrec_.unit_price_incl_tax) THEN
                     Customer_Order_Pricing_API.Get_Base_Price_In_Currency( newrec_.base_unit_price_incl_tax,
                                                                            newrec_.currency_rate,
                                                                            NVL(order_rec_.customer_no_pay, order_rec_.customer_no),
                                                                            newrec_.contract,
                                                                            order_rec_.currency_code,
                                                                            newrec_.unit_price_incl_tax,
                                                                            nvl(currency_type_, order_rec_.currency_rate_type));
                     Client_SYS.Set_Item_Value('UNIT_PRICE_INCL_TAX',      newrec_.unit_price_incl_tax,      attr_);
                     Client_SYS.Set_Item_Value('BASE_UNIT_PRICE_INCL_TAX', newrec_.base_unit_price_incl_tax, attr_);
                  END IF;
               ELSE
                  newrec_.sale_unit_price := newrec_.part_price + NVL(newrec_.char_price, 0);
                  IF (newrec_.sale_unit_price != oldrec_.sale_unit_price) THEN
                     Customer_Order_Pricing_API.Get_Base_Price_In_Currency( newrec_.base_sale_unit_price,
                                                                            newrec_.currency_rate,
                                                                            NVL(order_rec_.customer_no_pay, order_rec_.customer_no),
                                                                            newrec_.contract,
                                                                            order_rec_.currency_code,
                                                                            newrec_.sale_unit_price,
                                                                            nvl(currency_type_, order_rec_.currency_rate_type));
                     Client_SYS.Set_Item_Value('SALE_UNIT_PRICE', newrec_.sale_unit_price, attr_);
                     Client_SYS.Set_Item_Value('BASE_SALE_UNIT_PRICE', newrec_.base_sale_unit_price, attr_);
                  END IF;
               END IF;               
               Calculate_Prices(newrec_);                  
            END IF;

            Client_SYS.Set_Item_Value('CHAR_PRICE', newrec_.char_price, attr_);
            Client_SYS.Set_Item_Value('CALC_CHAR_PRICE', newrec_.calc_char_price, attr_);

            newrec_.rowversion := sysdate;
            
            Update_Line___(objid_, newrec_);            
         END IF;


      END IF;

      discount_freeze_db_ := Site_Discom_Info_API.Get_Discount_Freeze_Db(newrec_.contract);
      rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, order_rec_.currency_code);


      IF (((newrec_.addr_flag != oldrec_.addr_flag) AND (tax_method_ != External_Tax_Calc_Method_API.DB_NOT_USED)) 
         OR (NVL(newrec_.ship_addr_no, ' ') != NVL(oldrec_.ship_addr_no, ' ')) OR
         (newrec_.tax_liability!= oldrec_.tax_liability) OR (NVL(Client_SYS.Get_Item_Value('SUPPLY_COUNTRY_CHANGED', attr_),'FALSE')) = 'TRUE') THEN
         IF fetch_external_tax_ = 'TRUE' THEN 
            Customer_Order_Charge_API.Add_Transaction_Tax_Info(newrec_.order_no,                                                     
                                                               newrec_.line_no,
                                                               newrec_.rel_no,
                                                               newrec_.line_item_no);
         END IF;
      END IF;

      IF ((oldrec_.sale_unit_price = 0 AND newrec_.sale_unit_price != 0) OR
          (oldrec_.sale_unit_price != 0 AND newrec_.sale_unit_price = 0) OR
          (oldrec_.unit_price_incl_tax = 0 AND newrec_.unit_price_incl_tax != 0) OR
          (oldrec_.unit_price_incl_tax != 0 AND newrec_.unit_price_incl_tax = 0)) THEN
         price_changed_ := TRUE;
      END IF;

      newrec_.free_of_charge_tax_basis := NVL(Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('FREE_OF_CHARGE_TAX_BASIS', attr_)), newrec_.free_of_charge_tax_basis);
      
      IF ((price_changed_) OR (newrec_.tax_liability_type != oldrec_.tax_liability_type) OR
          (newrec_.tax_liability != oldrec_.tax_liability) OR
          (NVL(newrec_.tax_code, Database_SYS.string_null_) != NVL(oldrec_.tax_code, Database_SYS.string_null_)) OR
          (NVL(newrec_.tax_calc_structure_id, Database_SYS.string_null_) != NVL(oldrec_.tax_calc_structure_id, Database_SYS.string_null_)) OR
          ((newrec_.addr_flag != oldrec_.addr_flag) AND (tax_method_ != External_Tax_Calc_Method_API.DB_NOT_USED)) OR
          (NVL(newrec_.ship_addr_no, Database_SYS.string_null_) != NVL(oldrec_.ship_addr_no, Database_SYS.string_null_)) OR
          (NVL(newrec_.free_of_charge_tax_basis, 0) != NVL(oldrec_.free_of_charge_tax_basis, 0)) OR
          ((NVL(Client_SYS.Get_Item_Value('SUPPLY_COUNTRY_CHANGED', attr_),'FALSE')) = 'TRUE') OR 
          (newrec_.country_code != oldrec_.country_code) OR
          ((newrec_.addr_flag != oldrec_.addr_flag OR newrec_.planned_ship_date != oldrec_.planned_ship_date) AND (tax_method_ = External_Tax_Calc_Method_API.DB_NOT_USED) AND (newrec_.tax_class_id IS NOT NULL))) THEN
           
         IF (order_rec_.use_price_incl_tax = Fnd_Boolean_API.DB_FALSE) THEN
            unit_price_            := newrec_.sale_unit_price;
         ELSE
            unit_price_            := newrec_.unit_price_incl_tax;
         END IF;
         
         -- Update discount calculation basis before recalculate tax.
         Cust_Order_Line_Discount_API.Calculate_Discount__(dummy_total_disc_pct_, dummy_total_disc_amt_, 
                                                          newrec_.order_no, newrec_.line_no, 
                                                          newrec_.rel_no, newrec_.line_item_no,
                                                          unit_price_, newrec_.buy_qty_due,
                                                          newrec_.price_conv_factor, 'TRUE',
                                                          NVL(new_rental_chargeable_days_, 1));

         -- Added condition to stop adding taxes during CO line creation from quotation, as taxes will be transferred later from quotation line         
         IF (tax_item_removed_ != 'TRUE' AND fetch_external_tax_ = 'TRUE'
             AND (NOT(NVL(newrec_.demand_code, ' ') = 'CQ' AND NVL(Order_Quotation_Line_API.Get_Objstate(newrec_.demand_order_ref1, newrec_.demand_order_ref2, newrec_.demand_order_ref3, newrec_.demand_order_ref4),' ')= 'Released'))) THEN
            IF (newrec_.customer_no = newrec_.deliver_to_customer_no) THEN
               IF ((((NVL(Client_SYS.Get_Item_Value('SUPPLY_COUNTRY_CHANGED', attr_),'FALSE')) = 'TRUE') OR
                    (newrec_.country_code != oldrec_.country_code) OR (newrec_.tax_liability != oldrec_.tax_liability) OR 
                    (((newrec_.addr_flag != oldrec_.addr_flag) OR (NVL(newrec_.free_of_charge_tax_basis, 0) != NVL(oldrec_.free_of_charge_tax_basis, 0)))
                     AND (tax_method_ != External_Tax_Calc_Method_API.DB_NOT_USED)) OR
                    (NVL(newrec_.ship_addr_no, Database_SYS.string_null_) != NVL(oldrec_.ship_addr_no, Database_SYS.string_null_))
                   OR price_changed_) AND nvl(Client_SYS.Get_Item_Value('FETCH_TAX_FROM_DEFAULTS', attr_), 'TRUE') = 'TRUE' OR 
                   ((newrec_.addr_flag != oldrec_.addr_flag OR newrec_.planned_ship_date != oldrec_.planned_ship_date) AND (tax_method_ = External_Tax_Calc_Method_API.DB_NOT_USED) AND (newrec_.tax_class_id IS NOT NULL))) THEN
                  tax_from_defaults_ := TRUE;
               END IF;
               
               IF newrec_.addr_flag = 'N' THEN
                  newrec_.country_code := Cust_Ord_Customer_Address_API.Get_Country_Code(newrec_.customer_no, newrec_.ship_addr_no);                   
               END IF; 
               
               Add_Transaction_Tax_Info___ (newrec_,  
                                            company_,                                         
                                            newrec_.customer_no,
                                            newrec_.ship_addr_no,                                         
                                            order_rec_.supply_country,                                           
                                            order_rec_.use_price_incl_tax,
                                            order_rec_.currency_code,                                          
                                            tax_from_defaults_,                                         
                                            attr_   => NULL);                                                 
            ELSE
               IF ((price_changed_) OR (newrec_.tax_liability_type != oldrec_.tax_liability_type) OR 
                   (NVL(newrec_.tax_code,Database_SYS.string_null_) != NVL(oldrec_.tax_code,Database_SYS.string_null_)) OR
                   (NVL(newrec_.tax_calc_structure_id, Database_SYS.string_null_) != NVL(oldrec_.tax_calc_structure_id, Database_SYS.string_null_))) THEN

                  tax_from_defaults_ := (newrec_.ship_addr_no != order_rec_.ship_addr_no);
                  IF (((price_changed_) OR (newrec_.tax_liability_type != oldrec_.tax_liability_type) OR (NVL(newrec_.free_of_charge_tax_basis, 0) != NVL(oldrec_.free_of_charge_tax_basis, 0))) 
                     AND (tax_method_ != External_Tax_Calc_Method_API.DB_NOT_USED)) THEN
                     tax_from_defaults_ := TRUE;
                  END IF;
                  IF (NVL(newrec_.tax_code,Database_SYS.string_null_) != NVL(oldrec_.tax_code,Database_SYS.string_null_) OR 
                      NVL(newrec_.tax_calc_structure_id, Database_SYS.string_null_) != NVL(oldrec_.tax_calc_structure_id, Database_SYS.string_null_)) THEN
                     tax_from_defaults_ := FALSE;
                  END IF;

                  Add_Transaction_Tax_Info___ (newrec_,                                              
                                               company_,                                            
                                               order_rec_.customer_no,
                                               order_rec_.ship_addr_no,                                            
                                               order_rec_.supply_country,                                              
                                               order_rec_.use_price_incl_tax,
                                               order_rec_.currency_code,                                            
                                               tax_from_defaults_,                                            
                                               attr_   => NULL); 
               END IF;
            END IF;
         END IF;

         IF price_changed_ THEN
            Customer_Order_Charge_Util_API.Recalc_Percentage_Charge_Taxes(newrec_.order_no, newrec_.line_no, tax_from_defaults_);
         END IF;
      -- gelr:br_external_tax_integration, added acquisition_origin, acquisition_reason_id, statistical_code
      -- If any of the attributes affecting the total line amount have been changed then
      -- tax lines connected to the order line will have to be recalculated
      -- since the tax amount may have to be updated
      ELSIF ((newrec_.buy_qty_due != oldrec_.buy_qty_due) OR
             (newrec_.base_sale_unit_price != oldrec_.base_sale_unit_price AND order_rec_.use_price_incl_tax = 'FALSE' ) OR
             (newrec_.base_unit_price_incl_tax != oldrec_.base_unit_price_incl_tax AND  order_rec_.use_price_incl_tax = 'TRUE') OR
             (newrec_.order_discount != oldrec_.order_discount) OR (newrec_.additional_discount != oldrec_.additional_discount) OR
             (NVL(oldrec_.customer_tax_usage_type,' ') != NVL(newrec_.customer_tax_usage_type,' ')) OR
             (newrec_.discount != oldrec_.discount) OR (newrec_.rental = Fnd_Boolean_API.DB_TRUE AND new_rental_chargeable_days_ != old_rental_chargeable_days_) OR
             (NVL(newrec_.acquisition_origin, -9999) != NVL(oldrec_.acquisition_origin, -9999)) OR
             (NVL(newrec_.acquisition_reason_id, Database_SYS.string_null_) != NVL(oldrec_.acquisition_reason_id, Database_SYS.string_null_)) OR
             (NVL(newrec_.statistical_code, Database_SYS.string_null_) != NVL(oldrec_.statistical_code, Database_SYS.string_null_))) THEN
         
         IF (order_rec_.use_price_incl_tax = Fnd_Boolean_API.DB_FALSE) THEN
            unit_price_            := newrec_.sale_unit_price;
         ELSE
            unit_price_            := newrec_.unit_price_incl_tax;
         END IF;
         
         -- Update discount calculation basis before recalculate tax.
         Cust_Order_Line_Discount_API.Calculate_Discount__(dummy_total_disc_pct_, dummy_total_disc_amt_, 
                                                          newrec_.order_no, newrec_.line_no, 
                                                          newrec_.rel_no, newrec_.line_item_no,
                                                          unit_price_, newrec_.buy_qty_due,
                                                          newrec_.price_conv_factor, 'TRUE', 
                                                          NVL(new_rental_chargeable_days_, 1));
                                                          
         IF (tax_method_ != External_Tax_Calc_Method_API.DB_NOT_USED) THEN
            tax_from_defaults_ := TRUE;
            IF fetch_external_tax_ = 'TRUE' THEN 
               Add_Transaction_Tax_Info___ (newrec_,  
                                            company_,                                         
                                            newrec_.customer_no,
                                            newrec_.ship_addr_no,                                         
                                            order_rec_.supply_country,                                           
                                            order_rec_.use_price_incl_tax,
                                            order_rec_.currency_code,                                          
                                            tax_from_defaults_,                                         
                                            attr_   => NULL); 
            END IF;
         ELSE
            tax_from_defaults_ := FALSE;
            Recalculate_Tax_Lines___(newrec_,										    
                                  company_,                                  
                                  order_rec_.customer_no,
                                  order_rec_.ship_addr_no,
                                  order_rec_.supply_country,
                                  order_rec_.use_price_incl_tax,
                                  order_rec_.currency_code,
                                  tax_from_defaults_,
                                  NULL);
         END IF;         
         Customer_Order_Charge_Util_API.Recalc_Percentage_Charge_Taxes(newrec_.order_no, newrec_.line_no, tax_from_defaults_);
      END IF; 
      IF (NVL(tax_code_changed_, 'FALSE') = 'TRUE') THEN 
         Calculate_Prices(newrec_);
         newrec_.rowversion := sysdate;            
         Update_Line___(objid_, newrec_);
      END IF;
      
      -- NOTE: When price including tax is specified, gross amounts are used to calculate calculation basis of the discount. And these values are used when reclaculating tax lines.
      IF ((newrec_.buy_qty_due != oldrec_.buy_qty_due) OR (newrec_.sale_unit_price != oldrec_.sale_unit_price) OR (ROUND(newrec_.unit_price_incl_tax, rounding_) != ROUND(oldrec_.unit_price_incl_tax, rounding_))
         OR (price_source_refreshed_ = 1) OR (oldrec_.price_source != newrec_.price_source)) THEN
            discount_ :=  Cust_Order_Line_Discount_API.Calculate_Discount__(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
            Client_SYS.Add_To_Attr('DISCOUNT', discount_, attr_);
            Modify_Discount__(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, discount_);
      END IF;
      
      exist_chg_on_order_line_ := Customer_Order_Charge_API.Exist_Charge_On_Order_Line(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      IF (exist_chg_on_order_line_ = 1) AND newrec_.rowstate NOT IN ('Delivered', 'Invoiced', 'Closed') THEN
         Customer_Order_Charge_Util_API.Modify_Cust_Order_Charge_Line(newrec_, oldrec_, NVL(tax_code_changed_, 'FALSE'));
      ELSIF ((newrec_.input_unit_meas IS NOT NULL AND oldrec_.input_unit_meas IS NULL) OR
            (newrec_.freight_map_id IS NOT NULL AND (NVL(oldrec_.freight_map_id, ' ') != newrec_.freight_map_id)) OR
            (newrec_.zone_id IS NOT NULL AND (NVL(oldrec_.zone_id, ' ') != newrec_.zone_id)) OR
            (newrec_.buy_qty_due != oldrec_.buy_qty_due) OR
            (newrec_.planned_delivery_date != oldrec_.planned_delivery_date) OR
            (newrec_.delivery_terms != oldrec_.delivery_terms)) AND newrec_.rowstate NOT IN ('Delivered','PartiallyDelivered','Invoiced', 'Closed') THEN
         Customer_Order_Charge_Util_API.New_Cust_Order_Charge_Line(newrec_, FALSE);
      END IF;
   END IF;
          
   -- Moved discount calculation logic after Tax calculation logic. When price including tax is specified, final tax amount is used for discount calculations.
   IF (newrec_.buy_qty_due != oldrec_.buy_qty_due) OR (NVL(newrec_.price_list_no, ' ') != NVL(oldrec_.price_list_no, ' ') OR
       NVL(to_char(newrec_.price_effectivity_date), '0') != NVL(to_char(oldrec_.price_effectivity_date), '0')
       OR (qty_refreshed_ = 1) OR (price_source_refreshed_ = 1) OR (oldrec_.price_source != newrec_.price_source)) THEN
      IF NOT((newrec_.price_freeze = 'FROZEN' AND discount_freeze_db_ = 'TRUE') OR (NVL(change_request_, Database_SYS.string_null_) = 'TRUE')) THEN
         Customer_Order_Pricing_API.Modify_Default_Discount_Rec(newrec_.order_no,
                                                                newrec_.line_no,
                                                                newrec_.rel_no,
                                                                newrec_.line_item_no,
                                                                newrec_.contract,
                                                                newrec_.customer_no,
                                                                order_rec_.currency_code,
                                                                order_rec_.agreement_id,
                                                                newrec_.catalog_no,
                                                                newrec_.buy_qty_due,
                                                                newrec_.price_list_no,
                                                                newrec_.customer_level,
                                                                newrec_.customer_level_id);
      END IF;
   END IF;

   IF (newrec_.buy_qty_due != oldrec_.buy_qty_due) OR (newrec_.sales_unit_meas != oldrec_.sales_unit_meas) OR
      (newrec_.sale_unit_price != oldrec_.sale_unit_price) OR (newrec_.unit_price_incl_tax != oldrec_.unit_price_incl_tax) OR
      (newrec_.base_sale_unit_price != oldrec_.base_sale_unit_price) OR (newrec_.base_unit_price_incl_tax != oldrec_.base_unit_price_incl_tax) OR
      (newrec_.order_discount != oldrec_.order_discount) OR (newrec_.price_conv_factor != oldrec_.price_conv_factor) OR
      (newrec_.discount != oldrec_.discount) OR
      (newrec_.rental = Fnd_Boolean_API.DB_TRUE AND old_rental_chargeable_days_ != new_rental_chargeable_days_) THEN
      -- Recalculation of group discount must be made.
      CUSTOMER_ORDER_API.Modify_Grp_Disc_Calc_Flag(newrec_.order_no, 'N');
   END IF;

   -- Check for prepayment amount has exceed the total gross amount including charges.
   IF ((newrec_.buy_qty_due != oldrec_.buy_qty_due) OR
       (newrec_.base_sale_unit_price != oldrec_.base_sale_unit_price) OR
       (newrec_.base_unit_price_incl_tax != oldrec_.base_unit_price_incl_tax) OR
       (newrec_.order_discount != oldrec_.order_discount) OR
       (newrec_.discount != oldrec_.discount) OR
       (newrec_.tax_code != oldrec_.tax_code)) THEN

      Validate_Prepayment___(newrec_, 'MODIFY');
   END IF;

   -- IF revised_qty_due was decreased change of order line state might be needed if the state i 'PartiallyDelivered'
   IF ((newrec_.revised_qty_due < oldrec_.revised_qty_due) AND (newrec_.rowstate = 'PartiallyDelivered')) THEN
      Check_State(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      IF newrec_.line_item_no > 0 THEN
         --In this case we have to check and deliver the package part(header) if
         --all the component lines are delivered.
         Deliver_Customer_Order_API.Deliver_Package_If_Complete(newrec_.order_no, newrec_.line_no, newrec_.rel_no);
      END IF;
   END IF;

   IF (from_shortage_ AND Customer_Order_Shortage_API.Check_Exist(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no)) THEN
      Customer_Order_Shortage_API.Remove(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
   END IF;

   IF (newrec_.rowstate != 'Cancelled') THEN
      IF (oldrec_.line_item_no > 0) THEN
         IF (newrec_.buy_qty_due != oldrec_.buy_qty_due) THEN
            text_ := substr(Language_SYS.Translate_Constant(lu_name_, 'QTYCHANGED: The quantity has been changed from :P1 to :P2',
                                NULL, TO_CHAR(oldrec_.buy_qty_due), TO_CHAR(newrec_.buy_qty_due)), 1, 200);
            Customer_Order_Line_Hist_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, text_);
         END IF;

         IF ((newrec_.sale_unit_price != oldrec_.sale_unit_price) AND (order_rec_.use_price_incl_tax != 'TRUE')) THEN
            text_ := SUBSTR(Language_SYS.Translate_Constant(lu_name_, 'PRICECHG: The price has been changed from :P1 to :P2',
                                                                       NULL, TO_CHAR(oldrec_.sale_unit_price), TO_CHAR(newrec_.sale_unit_price)), 1, 200);
            Customer_Order_Line_Hist_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, text_);
         ELSIF ((newrec_.unit_price_incl_tax != oldrec_.unit_price_incl_tax) AND (order_rec_.use_price_incl_tax = 'TRUE')) THEN
            text_ := SUBSTR(Language_SYS.Translate_Constant(lu_name_, 'PRICECHG: The price has been changed from :P1 to :P2',
                                                                       NULL, TO_CHAR(oldrec_.unit_price_incl_tax), TO_CHAR(newrec_.unit_price_incl_tax)), 1, 200);
            Customer_Order_Line_Hist_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, text_);
         END IF;
      END IF;
      -- Check if a history record should be generated for changed attributes
      -- Only create history lines if user modifies an order line and not a component
      IF (oldrec_.line_item_no <= 0) THEN
         -- Is buy_qty_due changed?
         IF (newrec_.buy_qty_due != oldrec_.buy_qty_due) THEN
            -- Is it changed in the shortage-form?
            IF from_shortage_ THEN
               text_ := Language_SYS.Translate_Constant(lu_name_, 'UPDATEFROMSHORTAGE: The order line has been updated via the handle shortage form.');
            ELSE
               text_ := substr(Language_SYS.Translate_Constant(lu_name_, 'QTYCHANGED: The quantity has been changed from :P1 to :P2',
                                 NULL, to_char(oldrec_.buy_qty_due), to_char(newrec_.buy_qty_due)), 1, 200);
            END IF;
            Customer_Order_Line_Hist_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, text_);
         END IF;
         -- Planned_delivery_date?
         IF (newrec_.planned_delivery_date != oldrec_.planned_delivery_date) THEN
            -- Is it changed in the shortage-form?
            IF from_shortage_ THEN
               text_ := Language_SYS.Translate_Constant(lu_name_, 'UPDATEFROMSHORTAGE: The order line has been updated via the handle shortage form.');
            ELSE
               text_ := substr(Language_SYS.Translate_Constant(lu_name_, 'TARGETDATECHG2: The planned delivery date has been changed from :P1 to :P2',
                  NULL, to_char(oldrec_.planned_delivery_date, 'YYYY-MM-DD HH24.MI.SS'), to_char(newrec_.planned_delivery_date, 'YYYY-MM-DD HH24.MI.SS')), 1, 200);
            END IF;
            Customer_Order_Line_Hist_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, text_);
         END IF;
         -- Sale_unit_price?
         IF ((newrec_.sale_unit_price != oldrec_.sale_unit_price) AND (order_rec_.use_price_incl_tax != 'TRUE')) THEN
            text_ := substr(Language_SYS.Translate_Constant(lu_name_, 'PRICECHG: The price has been changed from :P1 to :P2',
                                                                       NULL, to_char(oldrec_.sale_unit_price), to_char(newrec_.sale_unit_price)), 1, 200);
            Customer_Order_Line_Hist_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, text_);

            calc_price_per_curr_ := newrec_.part_price + NVL(newrec_.calc_char_price, 0);
            Log_Price_Changes___(newrec_, order_rec_, calc_price_per_curr_);
         ELSIF ((newrec_.unit_price_incl_tax != oldrec_.unit_price_incl_tax) AND (order_rec_.use_price_incl_tax = 'TRUE')) THEN
            text_ := substr(Language_SYS.Translate_Constant(lu_name_, 'PRICECHG: The price has been changed from :P1 to :P2',
                                                                       NULL, to_char(oldrec_.unit_price_incl_tax), to_char(newrec_.unit_price_incl_tax)), 1, 200);
            Customer_Order_Line_Hist_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, text_);

            calc_price_per_curr_ := newrec_.part_price + NVL(newrec_.calc_char_price, 0);
            Log_Price_Changes___(newrec_, order_rec_, calc_price_per_curr_);
         END IF;
         
         -- Discount?
         IF (newrec_.discount != oldrec_.discount) THEN
            -- gelr:disc_price_rounded, begin
            IF (discounted_price_rounded_) THEN
               text_ := substr(Language_SYS.Translate_Constant(lu_name_, 'DISCCHG: The discount has been changed from :P1 to :P2',
                  NULL, to_char(round(oldrec_.original_discount, 2)), to_char(round(newrec_.original_discount, 2))), 1, 200);
            ELSE
               text_ := substr(Language_SYS.Translate_Constant(lu_name_, 'DISCCHG: The discount has been changed from :P1 to :P2',
                  NULL, to_char(round(oldrec_.discount, 2)), to_char(round(newrec_.discount, 2))), 1, 200);
            END IF;
            -- gelr:disc_price_rounded, end               
            Customer_Order_Line_Hist_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, text_);
         END IF;
         IF (newrec_.ship_addr_no != oldrec_.ship_addr_no) THEN
            text_ := substr(Language_Sys.Translate_Constant(lu_name_, 'SHIPADDRNOCHGLINE: The delivery address has been changed from :P1 to :P2', NULL, oldrec_.ship_addr_no, newrec_.ship_addr_no), 1, 200);
            Customer_Order_Line_Hist_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, text_);
         END IF;
         -- Has Configuration Id changed?
         IF ((newrec_.configuration_id != oldrec_.configuration_id) AND (oldrec_.configuration_id != '*'))THEN
            text_ := substr(Language_SYS.Translate_Constant(lu_name_, 'CONFIGCCHG: The configuration id has changed from :P1 to :P2',
               NULL, oldrec_.configuration_id, newrec_.configuration_id), 1, 200);
            Customer_Order_Line_Hist_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, text_);
         END IF;
      END IF;
   END IF;

   -- Create a history record for Invoiced Blocked.
   IF (newrec_.blocked_for_invoicing != oldrec_.blocked_for_invoicing) THEN
      IF (newrec_.blocked_for_invoicing = 'TRUE') THEN
         text_ := Language_SYS.Translate_Constant(lu_name_, 'INVOICEBLOCEKD: Invoice Blocked');
      ELSE
         text_ := Language_SYS.Translate_Constant(lu_name_, 'INVBLOCKUNCHECK: Invoice Blocked Unchecked');
      END IF;
      Customer_Order_Line_Hist_API.New( newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, text_);
   END IF;

   IF (newrec_.staged_billing = 'STAGED BILLING') THEN
      new_sale_price_total_ := Get_Sale_Price_Total(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, new_rental_chargeable_days_);
      new_sale_price_incl_tax_total_ := Get_Sale_Price_Incl_Tax_Total(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      -- Added the check for ignoring the Recalculation of Staged Billing for package part components.
      IF (((new_sale_price_total_ - old_sale_price_total_) != 0) OR ((new_sale_price_incl_tax_total_ - old_sale_price_incl_tax_total_) != 0) OR (NVL(tax_code_changed_, 'FALSE') = 'TRUE')) AND (newrec_.line_item_no <= 0) THEN
         Order_Line_Staged_Billing_API.Recalculate(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no,
                                       new_sale_price_total_, old_sale_price_total_, new_sale_price_incl_tax_total_, old_sale_price_incl_tax_total_,
                                       newrec_.buy_qty_due, oldrec_.buy_qty_due, order_rec_.use_price_incl_tax);
      END IF;

      -- Get the total percentage of invoiced stage billing lines to calculate the qty_invoiced of the order lines , if the qty_invoiced
      -- is equal to sales qty and the status is Partially/fully delivered then the status of the line will be changed to Invoiced/Closed
      IF (((new_sale_price_total_ - old_sale_price_total_) != 0) OR (oldrec_.buy_qty_due != newrec_.buy_qty_due)) THEN
         IF (newrec_.line_item_no > 0) THEN
            tot_percentage_:= Order_Line_Staged_Billing_API.Get_Total_Invoiced_Percentage(newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1);
         ELSE
            tot_percentage_:= Order_Line_Staged_Billing_API.Get_Total_Invoiced_Percentage(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
         END IF;
         IF (tot_percentage_ >= 0) THEN
            FOR comp_rec_ IN get_component_lines LOOP
               comp_qty_invoiced_ := round((comp_rec_.buy_qty_due*tot_percentage_/100),12);
               CUSTOMER_ORDER_API.Set_Line_Qty_Invoiced(newrec_.order_no, newrec_.line_no, newrec_.rel_no, comp_rec_.line_item_no, comp_qty_invoiced_);
            END LOOP;
            newrec_.qty_invoiced := round((newrec_.buy_qty_due*tot_percentage_/100),12);
            Client_SYS.Add_To_Attr('QTY_INVOICED', newrec_.qty_invoiced, attr_);
            IF (newrec_.qty_invoiced != oldrec_.qty_invoiced) THEN
               CUSTOMER_ORDER_API.Set_Line_Qty_Invoiced(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.qty_invoiced);
            END IF;
         END IF;
      END IF;
   END IF;

   -- Created commission lines will be cancelled if the line is a free of charge line.
   IF (Order_Line_Commission_API.Has_Commission_Lines(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no)) AND 
      (newrec_.free_of_charge = Fnd_Boolean_API.DB_TRUE) THEN
      Order_Line_Commission_API.Cancel_Order_Commission_Lines(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      Client_SYS.Add_Info(lu_name_, 'COMMCAN: Commission lines have been cancelled for free of charge lines.');      
   END IF;
   -- Set the associated commission lines as 'Changed'
   IF (newrec_.rowstate != 'Cancelled') AND (newrec_.free_of_charge = Fnd_Boolean_API.DB_FALSE) THEN
      IF (newrec_.base_sale_unit_price <> oldrec_.base_sale_unit_price OR
         newrec_.base_unit_price_incl_tax <> oldrec_.base_unit_price_incl_tax OR
         newrec_.buy_qty_due <> oldrec_.buy_qty_due OR
         newrec_.discount <> oldrec_.discount OR
         newrec_.order_discount <> oldrec_.order_discount OR
         newrec_.price_list_no <> oldrec_.price_list_no OR
         newrec_.contract <> oldrec_.contract OR
         newrec_.catalog_no <> oldrec_.catalog_no OR
         newrec_.region_code <> oldrec_.region_code) THEN
         Order_Line_Commission_API.Set_Order_Com_Lines_Changed(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      END IF;
   END IF;

   IF (newrec_.supply_code = 'IO') AND (newrec_.demand_code = 'PO') THEN
      IF (newrec_.part_ownership != oldrec_.part_ownership) OR (newrec_.owning_customer_no != oldrec_.owning_customer_no) THEN
         $IF (Component_Purch_SYS.INSTALLED)$THEN
            Purchase_Order_Line_Part_API.Modify_Po_Part_Ownership_Info(newrec_.demand_order_ref1, newrec_.demand_order_ref2,
                                                                       newrec_.demand_order_ref3, newrec_.part_ownership, newrec_.owning_customer_no);
         $ELSE
            Error_SYS.Record_General(lu_name_,'POLINEPNOTEXIST: Can not modify the part ownership information when purchase order line part is not installed.');
         $END
      END IF;
   END IF;

   IF (newrec_.demand_code = 'DO') THEN
      $IF (Component_Disord_SYS.INSTALLED) $THEN
         IF (newrec_.wanted_delivery_date != oldrec_.wanted_delivery_date OR newrec_.planned_delivery_date != oldrec_.planned_delivery_date
            OR (newrec_.planned_ship_date != oldrec_.planned_ship_date) OR newrec_.planned_due_date != oldrec_.planned_due_date)
            OR (newrec_.buy_qty_due != oldrec_.buy_qty_due) OR (NVL(newrec_.forward_agent_id,CHR(2)) != NVL(oldrec_.forward_agent_id,CHR(2)))
            OR (newrec_.delivery_terms != oldrec_.delivery_terms) OR (newrec_.ship_via_code != oldrec_.ship_via_code)
            OR (newrec_.ship_addr_no != oldrec_.ship_addr_no)
            OR (newrec_.route_id != oldrec_.route_id) THEN
            data_changed_ := TRUE;
         END IF;
         IF (data_changed_ AND ((NVL(Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('SERVER_DATA_CHANGE', attr_)), 0) != 1)
            OR (NVL(Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('MODIFIED_FROM_HEADER', attr_)), 0) = 1))) THEN
            Distribution_Order_API.Modify_From_Connected_Order(newrec_.demand_order_ref1,
                                                               newrec_.wanted_delivery_date,
                                                               newrec_.planned_due_date,
                                                               newrec_.planned_ship_date,
                                                               newrec_.planned_delivery_date,
                                                               planned_receipt_date_,
                                                               newrec_.revised_qty_due,
                                                               '',
                                                               newrec_.forward_agent_id,
                                                               newrec_.delivery_terms,
                                                               newrec_.ship_via_code,
                                                               '',
                                                               newrec_.route_id,
                                                               'ORDER');
         END IF;
      $ELSE
         NULL;
      $END
   END IF;

   IF (header_rowstate_ != 'Planned' AND ((oldrec_.planned_delivery_date != newrec_.planned_delivery_date) OR
                                          (oldrec_.buy_qty_due != newrec_.buy_qty_due))) THEN

      Cust_Order_Event_Creation_API.Delivery_Date_Or_Qty_Changed(oldrec_.order_no, oldrec_.line_no, oldrec_.rel_no, oldrec_.line_item_no,
                                                                 oldrec_.planned_delivery_date, oldrec_.revised_qty_due,
                                                                 newrec_.planned_delivery_date, newrec_.revised_qty_due,
                                                                 newrec_.supply_code, newrec_.qty_on_order, newrec_.part_no);
   END IF;

   Client_SYS.Set_Item_Value('PLANNED_DELIVERY_DATE', newrec_.planned_delivery_date, attr_);
   Client_SYS.Set_Item_Value('PROMISED_DELIVERY_DATE', newrec_.promised_delivery_date, attr_);
   Client_SYS.Set_Item_Value('PLANNED_SHIP_DATE', newrec_.planned_ship_date, attr_);
   Client_SYS.Set_Item_Value('PLANNED_DUE_DATE', newrec_.planned_due_date, attr_);
   Client_SYS.Set_Item_Value('PROJECT_ID', newrec_.project_id, attr_);

   Client_SYS.Set_Item_Value('TAX_CODE', Customer_Order_Line_API.Get_Tax_Code(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no), attr_);
   Client_SYS.Set_Item_Value('TAX_CLASS_ID', Customer_Order_Line_API.Get_Tax_Class_Id(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no), attr_);

   objversion_ := to_char(newrec_.rowversion,'YYYYMMDDHH24MISS');

   IF (NVL(oldrec_.activity_seq, -9999) != NVL(newrec_.activity_seq, -9999)) THEN
      IF (newrec_.activity_seq IS NOT NULL AND newrec_.activity_seq > 0) THEN
         -- Create Customer Order Line and Customer Order Revenue connections
         Handle_Activity_Seq___ (newrec_,
                                 oldrec_.activity_seq );
         IF (newrec_.charged_item = 'CHARGED ITEM') THEN
            Calculate_Revenue(newrec_.order_no,
                              newrec_.line_no,
                              newrec_.rel_no,
                              newrec_.line_item_no);
         END IF;
      ELSIF (newrec_.activity_seq IS NULL) THEN
         -- Remove Customer Order Line and Customer Order Revenue connections
         Remove_Project_Connection___(newrec_.order_no,
                                      newrec_.line_no,
                                      newrec_.rel_no,
                                      newrec_.line_item_no,
                                      oldrec_.activity_seq );
      END IF;
      $IF Component_Ordstr_SYS.INSTALLED $THEN
         DECLARE
            interim_head_id_  VARCHAR2(12);
         BEGIN
            interim_head_id_ := Interim_Demand_Head_API.Get_Cust_Ord_Line_Int_Head(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
            IF interim_head_id_ IS NOT NULL THEN
               -- Reflect activity information changes to the Interim Demand Header
               Interim_Demand_Head_API.Modify_Project_Activity_Seq(interim_head_id_, newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.project_id, newrec_.activity_seq);
            END IF;
         END;
      $END
   ELSIF (newrec_.activity_seq IS NOT NULL) THEN
      -- Refersh Customer Order Line and Customer Order Revenue connections
      IF (oldrec_.buy_qty_due != newrec_.buy_qty_due) OR (oldrec_.qty_shipped != newrec_.qty_shipped)
         OR (oldrec_.supply_code != newrec_.supply_code) OR (oldrec_.qty_assigned != newrec_.qty_assigned)
         OR (oldrec_.qty_returned != newrec_.qty_returned)
         OR (oldrec_.part_ownership != newrec_.part_ownership) THEN
         Calculate_Cost_And_Progress(newrec_.order_no,
                                     newrec_.line_no,
                                     newrec_.rel_no,
                                     newrec_.line_item_no);
      END IF;

      IF (newrec_.charged_item = 'CHARGED ITEM') THEN
         IF (oldrec_.buy_qty_due != newrec_.buy_qty_due) OR (oldrec_.additional_discount != newrec_.additional_discount)
            OR (oldrec_.discount != newrec_.discount) OR (oldrec_.sale_unit_price != newrec_.sale_unit_price)
            OR (oldrec_.unit_price_incl_tax != newrec_.unit_price_incl_tax) OR (oldrec_.tax_code != newrec_.tax_code)
            OR (newrec_.rental = Fnd_Boolean_API.DB_TRUE AND old_rental_chargeable_days_ != new_rental_chargeable_days_) THEN
            Calculate_Revenue(newrec_.order_no,
                              newrec_.line_no,
                              newrec_.rel_no,
                              newrec_.line_item_no);
         END IF;
      END IF;
   END IF;

   IF (newrec_.line_item_no = -1) THEN
      IF (newrec_.supply_code = 'PKG') THEN
         IF (oldrec_.shipment_creation != newrec_.shipment_creation AND newrec_.shipment_creation != 'NO_AUTOMATIC') THEN
            FOR comp_rec_ IN get_component_lines LOOP
               comp_attr_ := NULL;
               IF (comp_rec_.supply_code IN ('PD', 'ND', 'SEO')) THEN
                  Error_SYS.Record_General(lu_name_, 'NOTCHANGESHIPMENT: A line with a package part where its components have supply code Purchase Order Direct or Not Decided or Service Order, '||
                                                      'cannot use a shipment creation method where the line should be connected automatically to a shipment.');
               END IF;
            END LOOP;
         END IF;
      END IF;
   END IF;

   IF (newrec_.shipment_connected = 'TRUE') THEN
      IF ((header_rowstate_ != 'Planned') AND (oldrec_.supply_code != newrec_.supply_code) AND (newrec_.supply_code IN ('PD', 'IPD')) AND (newrec_.line_item_no <= 0 )) THEN
         Shipment_Line_API.Remove_Shipment_Lines(newrec_.order_no, newrec_.line_no, newrec_.rel_no,
                                                 newrec_.line_item_no, Logistics_Source_Ref_Type_API.DB_CUSTOMER_ORDER);
      END IF;
   ELSIF ((oldrec_.supply_code != newrec_.supply_code) AND (newrec_.rowstate != 'Cancelled')) THEN
      Check_And_Add_To_Shipment___(newrec_,  header_rowstate_);
   END IF;

   -- Invalidate Pre-Shipping Delivery note
   IF (newrec_.qty_to_ship != oldrec_.qty_to_ship AND oldrec_.qty_to_ship !=0) THEN
      IF order_rec_.use_pre_ship_del_note = 'TRUE' AND header_rowstate_ IN ('Picked', 'PartiallyDelivered') THEN
         Deliver_Customer_Order_API.Invalidate_Pre_Ship_Delnote(newrec_.order_no);
      END IF;
   END IF;

   IF (((newrec_.ship_addr_no          != oldrec_.ship_addr_no)    OR
       (newrec_.ship_via_code          != oldrec_.ship_via_code)   OR
       (newrec_.shipment_type          != oldrec_.shipment_type)   OR
       (newrec_.route_id               != oldrec_.route_id)OR
       (newrec_.forward_agent_id       != oldrec_.forward_agent_id)OR
       (newrec_.del_terms_location     != oldrec_.del_terms_location)OR
       (newrec_.delivery_terms         != oldrec_.delivery_terms)) AND
      ((newrec_.default_addr_flag      != oldrec_.default_addr_flag) OR
      (newrec_.default_addr_flag = 'N')) OR
      (NVL(newrec_.packing_instruction_id, Database_Sys.string_null_) != NVL(oldrec_.packing_instruction_id, Database_Sys.string_null_)) OR
      (NVL(newrec_.customs_value, -9999) != NVL(oldrec_.customs_value, -9999))) THEN
      IF (newrec_.shipment_connected = 'TRUE') THEN
         Client_SYS.Add_Info(lu_name_, 'SHIPCONADDR: Line no, rel no, order :P1  is connected to shipment(s). Note that delivery information must be changed manually for these shipment(s).', (newrec_.line_no ||' '||newrec_.rel_no ||' '|| newrec_.order_no));
      END IF;
   END IF;   
     
   IF (connected_shipment_id_ IS NOT NULL) THEN
      Shipment_Line_API.Update_From_Source_Line(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no,
                                                Logistics_Source_Ref_Type_API.DB_CUSTOMER_ORDER,
                                                newrec_.buy_qty_due, newrec_.qty_shipped, oldrec_.open_shipment_qty,
                                                newrec_.inverted_conv_factor, newrec_.conv_factor, connected_shipment_id_, newrec_.sales_unit_meas, newrec_.revised_qty_due);
   END IF;

   IF (NVL(newrec_.abnormal_demand,'FALSE') != NVL(oldrec_.abnormal_demand,'FALSE')) THEN
      IF (newrec_.abnormal_demand = 'TRUE') THEN
         Inventory_Transaction_Hist_API.Enable_Abnormal_Demand(newrec_.order_no,
                                                               newrec_.line_no,
                                                               newrec_.rel_no,
                                                               newrec_.line_item_no,
                                                               'CUST ORDER');
         Return_Material_Line_API.Enable_Abnormal_Demand(newrec_.order_no,
                                                         newrec_.line_no,
                                                         newrec_.rel_no,
                                                         newrec_.line_item_no);
      ELSE
         Inventory_Transaction_Hist_API.Disable_Abnormal_Demand(newrec_.order_no,
                                                                newrec_.line_no,
                                                                newrec_.rel_no,
                                                                newrec_.line_item_no,
                                                                'CUST ORDER');
         Return_Material_Line_API.Disable_Abnormal_Demand(newrec_.order_no,
                                                          newrec_.line_no,
                                                          newrec_.rel_no,
                                                          newrec_.line_item_no);
      END IF;
   END IF;

   IF (NVL(newrec_.cust_calendar_id, Database_Sys.string_null_) != NVL(oldrec_.cust_calendar_id, Database_Sys.string_null_)
       OR newrec_.planned_delivery_date != oldrec_.planned_delivery_date) THEN

      IF (NVL(newrec_.cust_calendar_id, Database_Sys.string_null_) != NVL(oldrec_.cust_calendar_id, Database_Sys.string_null_)) THEN
         Work_Time_Calendar_API.Add_Info_On_Pending(newrec_.cust_calendar_id);
      END IF;

      Cust_Ord_Date_Calculation_API.Check_Date_On_Cust_Calendar_(newrec_.customer_no, newrec_.cust_calendar_id,
                                                     newrec_.planned_delivery_date, 'PLANNED');
   END IF;

   IF (NVL(newrec_.ext_transport_calendar_id, Database_Sys.string_null_) != NVL(oldrec_.ext_transport_calendar_id, Database_Sys.string_null_)) THEN
      Work_Time_Calendar_API.Add_Info_On_Pending(newrec_.ext_transport_calendar_id);
   END IF;
   IF (newrec_.supply_code = 'IPD') THEN
      IF (oldrec_.supply_code != newrec_.supply_code) OR (newrec_.supply_site != oldrec_.supply_site)
         OR (((oldrec_.ship_addr_no != newrec_.ship_addr_no) OR (oldrec_.addr_flag != newrec_.addr_flag))AND (newrec_.addr_flag = 'N') AND (newrec_.default_addr_flag = 'N')) THEN
         IF Tax_Handling_Order_Util_API.Check_Ipd_Tax_Registration(company_, newrec_.contract, newrec_.supply_code,order_rec_.supply_country, newrec_.country_code) THEN
            country_desc_ := Iso_Country_API.Get_Description(newrec_.country_code, NULL);
            Client_SYS.Add_Info(lu_name_, 'SUPCOUNTRYDIFF: Company :P1 has a tax registration in delivery country :P2. The company tax ID number for the supply country of the order might not be appropriate.', company_, country_desc_);
         END IF;
      END IF;
   END IF;     
   Add_Info___(insert_package_mode_);
EXCEPTION
   WHEN dup_val_on_index THEN
      Error_SYS.Record_Exist(lu_name_);
END Update___;


@Override
PROCEDURE Check_Delete___ (
   remrec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
   linerec_             CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   header_rec_          Customer_Order_API.Public_Rec;
   licensed_order_type_ VARCHAR2(25);

   CURSOR get_package IS
      SELECT rowid
      FROM  CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = remrec_.order_no
      AND   line_no = remrec_.line_no
      AND   rel_no = remrec_.rel_no
      AND   line_item_no > 0;
BEGIN
   licensed_order_type_ := Get_Expctr_License_Order_Type(remrec_.demand_code, remrec_.demand_order_ref1, remrec_.demand_order_ref2, remrec_.demand_order_ref3);
   Customer_Order_Flow_API.Check_Delete_Exp_License(remrec_.order_no, remrec_.line_no, remrec_.rel_no, remrec_.line_item_no, licensed_order_type_); -- Export control
   header_rec_ := Customer_Order_API.Get(remrec_.order_no);
   
   -- Deleting order lines only allowed if the order is in state 'Planned'
   IF (header_rec_.rowstate != 'Planned' ) THEN
      Error_SYS.Record_General(lu_name_, 'USE_CANCEL_ORDER: Order lines on released orders may not be removed, only cancelled!');
   ELSIF (remrec_.rowstate != 'Released') THEN
      Error_SYS.Record_General(lu_name_, 'NO_REMOVE: An order line in :P1 state may not be removed.', Finite_State_Decode__(remrec_.rowstate));
   END IF;

   -- Deleting not allowed if Supply site reservations exists on supply site
   IF (Co_Supply_Site_Reservation_API.Reservation_Exist(remrec_.order_no, remrec_.line_no, remrec_.rel_no, remrec_.line_item_no) = 1) THEN
      Error_SYS.Record_General(lu_name_, 'SSR_EXIST: The order line may not be removed while Supply Site Reservations exists, remove reservations first!');
   END IF;

   -- Deleting not allowed when customer order originates from an internal purchase order
   IF (header_rec_.internal_po_no IS NOT NULL) THEN
      Error_SYS.Record_General(lu_name_, 'CHANGENOTALLOWED: It is not allowed to add or remove order lines when the customer order originates from an internal purchase order.');
   END IF;

   -- IF the line is a package part then check all component lines
   IF (remrec_.line_item_no = -1) THEN
      FOR pkgrec_ IN get_package LOOP
         linerec_ := Get_Object_By_Id___(pkgrec_.rowid);
         Check_Delete___(linerec_);
      END LOOP;
   END IF;

   -- IF the line is connected to a sales promotion calculation that has resulted in a sales promotion charge it can't be removed.
   IF Sales_Promotion_Util_API.Check_Promo_Exist_For_Ord_Line(remrec_.order_no, remrec_.line_no, remrec_.rel_no, remrec_.line_item_no) THEN
      Error_SYS.Record_General(lu_name_, 'NOREMOVEPROMOCONN: The order line cannot be deleted unless sales promotions have been cleared first.');
   END IF;

   Validate_Prepayment___(remrec_, 'DELETE');

   IF (remrec_.demand_code = 'PO') THEN
      Client_SYS.Add_Warning(lu_name_, 'CONNECTED_TO_PO: This order is connected to purchase order :P1/:P2/:P3 - which will not be updated automatically.', remrec_.demand_order_ref1, remrec_.demand_order_ref2, remrec_.demand_order_ref3);
   ELSIF (remrec_.demand_code = 'WO') THEN
      Client_SYS.Add_Warning(lu_name_, 'CONNECTED_TO_WO: This order is connected to work order :P1/:P2/:P3 - which will not be updated automatically.', remrec_.demand_order_ref1, remrec_.demand_order_ref2, remrec_.demand_order_ref3);
   ELSIF (remrec_.demand_code = 'FSM') THEN
      Client_SYS.Add_Warning(lu_name_, 'CONNECTED_TO_FSM: This order is connected to Field Service Management invoice.');
   END IF;

   super(remrec_);
END Check_Delete___;


@Override
PROCEDURE Delete___ (
   objid_  IN VARCHAR2,
   remrec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
   linerec_                 CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   cc_dummy_                VARCHAR2(2000);
   company_                 VARCHAR2(20);
   result_code_             VARCHAR2(2000);
   available_qty_           NUMBER := 0;
   earliest_available_date_ DATE;
   licensed_order_type_     VARCHAR2(25);
   ctp_run_id_              NUMBER;
   interim_ord_id_          VARCHAR2(12);

   CURSOR get_package IS
      SELECT rowid
      FROM  CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = remrec_.order_no
      AND   line_no = remrec_.line_no
      AND   rel_no = remrec_.rel_no
      AND   line_item_no > 0;
BEGIN
   super(objid_, remrec_);

   Customer_Order_Line_Hist_API.Remove(remrec_.order_no, remrec_.line_no, remrec_.rel_no, remrec_.line_item_no);
   IF (remrec_.line_item_no <= 0) THEN
      Pre_Accounting_API.Remove_Accounting_Id(remrec_.pre_accounting_id);
   END IF;

   licensed_order_type_ := Get_Expctr_License_Order_Type(remrec_.demand_code, remrec_.demand_order_ref1, remrec_.demand_order_ref2, remrec_.demand_order_ref3);
   Customer_Order_Flow_API.Remove_Connected_Exp_Licenses(remrec_.order_no, remrec_.line_no, remrec_.rel_no, remrec_.line_item_no, licensed_order_type_); -- Export control

   IF (remrec_.supply_code = 'PKG') THEN
      FOR pkgrec_ IN get_package LOOP
         linerec_ := Get_Object_By_Id___(pkgrec_.rowid);
         Delete___(pkgrec_.rowid, linerec_);
      END LOOP;
   -- Cancel DOP for DOP parts
   ELSIF (remrec_.supply_code = 'DOP') THEN
      Connect_Customer_Order_API.Cancel_Dop(remrec_.order_no, remrec_.line_no, remrec_.rel_no, remrec_.line_item_no);
   END IF;
   
   $IF (Component_Ordstr_SYS.INSTALLED) $THEN
      -- remove capibility check reservations/allocations
      interim_ord_id_:= Customer_Order_Line_API.Get_Interim_Order_No(remrec_.order_no, remrec_.line_no, remrec_.rel_no, remrec_.line_item_no, remrec_.ctp_planned);
      IF (remrec_.ctp_planned = 'Y' OR (remrec_.ctp_planned = 'N' AND interim_ord_id_ IS NOT NULL)) THEN
         Interim_Ctp_Manager_API.Cancel_Ctp(cc_dummy_, remrec_.order_no, remrec_.line_no, remrec_.rel_no, remrec_.line_item_no,
                                            'CUSTOMERORDER', remrec_.supply_code);
      END IF;
      
      -- Remove interim order association
      Interim_Demand_Head_API.Remove_Interim_Head_By_Usage('CUSTOMERORDER', remrec_.order_no, remrec_.line_no, remrec_.rel_no, remrec_.line_item_no);
      
      -- Remove ctp record
      ctp_run_id_ := Interim_Ctp_Critical_Path_API.Get_Ctp_Run_Id('CUSTOMERORDER', remrec_.order_no, remrec_.line_no, remrec_.rel_no, remrec_.line_item_no);
      IF (ctp_run_id_ IS NOT NULL AND ctp_run_id_ > 0) THEN
         Interim_Ctp_Critical_Path_API.Clear_Ctp_Data(ctp_run_id_);
      END IF;
   $END 

   IF remrec_.activity_seq IS NOT NULL THEN
      -- Remove Customer Order Line and Customer Order Revenue connections
      Connect_Customer_Order_API.Remove_Project_Connection(remrec_.order_no,
                                                           remrec_.line_no,
                                                           remrec_.rel_no,
                                                           remrec_.line_item_no,
                                                           remrec_.activity_seq );
   END IF;

   IF (remrec_.line_item_no <= 0) THEN
      CUSTOMER_ORDER_API.Modify_Grp_Disc_Calc_Flag(remrec_.order_no, 'N');
      IF (remrec_.default_addr_flag = 'N') THEN
         Cust_Order_Line_Address_API.Remove_Address__(remrec_.order_no, remrec_.line_no, remrec_.rel_no, remrec_.line_item_no);
      END IF;
   END IF;

   IF (remrec_.supply_code IN ('IO','PS','SO','DOP','PD','PT','IPD','IPT')) THEN
   -- Update forecast in MS or MRP if needed.
      IF (Inventory_Part_API.Get_Forecast_Consump_Flag_Db(remrec_.contract, remrec_.part_no) = 'FORECAST') THEN
         -- Unconsume the cancelled quantity
         Reserve_Customer_Order_API.Control_Ms_Mrp_Consumption(result_code_, available_qty_, earliest_available_date_, remrec_.contract, remrec_.part_no, NVL(remrec_.activity_seq, 0),
                                                               0, remrec_.revised_qty_due, remrec_.planned_due_date, remrec_.planned_due_date, 'CO', TRUE, remrec_.abnormal_demand, NULL );
      END IF;
   END IF;

   IF (remrec_.job_id IS NOT NULL) THEN
      company_ := Site_API.Get_Company(remrec_.contract);
      $IF (Component_Genled_SYS.INSTALLED)$THEN
         Accounting_Project_Util_API.Remove_Financial_Job(company_, remrec_.job_id);
      $END
   END IF;

   IF (remrec_.demand_code = 'CRO' OR remrec_.demand_code = 'CRE') THEN
      IF (remrec_.supply_code IN ('IO', 'CRO')) THEN
         -- Clear CO Line information if CO line was created by a Component Repair Order Line.
         $IF (Component_Cromfg_SYS.INSTALLED)$THEN
            Cro_Line_Material_Route_API.Clear_Co_Information(  cro_no_              => remrec_.demand_order_ref1, 
                                                               cro_line_no_         => remrec_.demand_order_ref2,
                                                               dispatch_order_ref1_ => remrec_.order_no,
                                                               dispatch_order_ref2_ => remrec_.line_no,
                                                               dispatch_order_ref3_ => remrec_.rel_no, 
                                                               dispatch_order_ref4_ => remrec_.line_item_no);
         $ELSE
            NULL;
         $END
         -- Clear CO Exchange Line information if CO line was created by a Component Repair Order Exchange Line.
         $IF Component_Cromfg_SYS.INSTALLED $THEN
            Cro_Exchange_Line_API.Clear_Co_Information(remrec_.demand_order_ref1, remrec_.demand_order_ref2);
         $ELSE
            NULL;
         $END

      ELSIF (remrec_.supply_code = 'SEO')THEN
         -- Clear CO Line information if CO line was generated by transferring sales lines in Component Repair Order.
         $IF (Component_Srvinv_SYS.INSTALLED) $THEN
            Srv_Sales_Lines_API.Undo_Transfer(remrec_.demand_order_ref4);
         $ELSE
            NULL;
         $END
      END IF;
   END IF;
   IF (remrec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
      Remove_Rental___(remrec_);
   END IF;
END Delete___;


@Override
PROCEDURE Check_Common___ (
   oldrec_ IN     customer_order_line_tab%ROWTYPE,
   newrec_ IN OUT customer_order_line_tab%ROWTYPE,
   indrec_ IN OUT Indicator_Rec,
   attr_   IN OUT VARCHAR2 )
IS
BEGIN
     
   IF indrec_.buy_qty_due = TRUE THEN
      IF ((newrec_.revised_qty_due <> FLOOR(newrec_.revised_qty_due)) AND (Part_Catalog_API.Get_Rcpt_Issue_Serial_Track_Db(newrec_.part_no) = Fnd_Boolean_API.DB_TRUE)) THEN
         Error_SYS.Appl_General(lu_name_, 'BUYQTYDUEINT: Sales quantity must be a multiple of the inverted conversion factor when the part is serialized.');
      END IF;
   END IF;
   
   IF (newrec_.free_of_charge IS NULL) THEN
      newrec_.free_of_charge := Fnd_Boolean_API.DB_FALSE;
   END IF;
   IF (newrec_.free_of_charge = Fnd_Boolean_API.DB_TRUE) THEN
      newrec_.rebate_builder := Fnd_Boolean_API.DB_FALSE;
      IF (indrec_.sale_unit_price AND newrec_.sale_unit_price <> 0) OR 
         (indrec_.base_sale_unit_price AND newrec_.base_sale_unit_price <> 0) OR 
         (indrec_.discount AND newrec_.discount <> 0) THEN
         Error_SYS.Record_General(lu_name_, 'CANTCHGPRICE: Price information cannot be modified for free of charge lines.');
      END IF;       
   END IF;
   
   IF (indrec_.tax_liability) THEN
      IF NOT (newrec_.tax_liability = 'TAX' OR newrec_.tax_liability = 'EXEMPT') THEN
         Tax_Handling_Order_Util_API.Validate_Tax_Liability(newrec_.tax_liability, newrec_.country_code);
      END IF;
   END IF;
 
   super(oldrec_, newrec_, indrec_, attr_);  
   
END Check_Common___;


@Override
PROCEDURE Check_Insert___ (
   newrec_ IN OUT customer_order_line_tab%ROWTYPE,
   indrec_ IN OUT Indicator_Rec,
   attr_   IN OUT VARCHAR2 )
IS
   name_                         VARCHAR2(30);
   value_                        VARCHAR2(4000);
   order_rec_                    CUSTOMER_ORDER_API.Public_Rec;
   partca_rec_                   PART_CATALOG_API.Public_Rec;
   company_                      VARCHAR2(20);
   header_rowstate_              CUSTOMER_ORDER_TAB.rowstate%TYPE;
   created_by_server_            BOOLEAN;
   is_config_edited_             BOOLEAN := FALSE;
   site_date_                    DATE;
   customer_agreement_           VARCHAR2(10);
   server_data_change_           NUMBER;
   capability_check_source_flag_ VARCHAR2(5) := 'FALSE';
   assortment_id_                ASSORTMENT_STRUCTURE_TAB.assortment_id%TYPE;
   original_demand_code_         CUSTOMER_ORDER_LINE_TAB.demand_code%TYPE;
   original_supply_code_         CUSTOMER_ORDER_LINE_TAB.supply_code%TYPE;
   new_pkg_component_line_       BOOLEAN := FALSE;
   zone_info_exist_              VARCHAR2(5) := 'FALSE';
   addr_rec_                     Customer_Order_Address_API.Cust_Ord_Addr_Rec;
   shipment_creation_sent_       BOOLEAN := FALSE;
   packed_ship_cre_in_init_      BOOLEAN := FALSE;
   shipment_type_sent_           BOOLEAN := FALSE;
   shipment_type_                CUSTOMER_ORDER_LINE_TAB.shipment_type%TYPE;
   inv_part_cost_level_db_       VARCHAR2(50);
   current_info_                 VARCHAR2(32000);
   external_service_order_       VARCHAR2(5) := Fnd_Boolean_API.DB_FALSE;
   tax_liability_type_db_        VARCHAR2(20);
   calc_revise_qty_due_          NUMBER;
   std_planned_item_po_comp_     VARCHAR2(5) := 'TRUE';
BEGIN
   order_rec_ := Customer_Order_API.Get(newrec_.order_no);
   -- Note :
   -- newrec_.planned_delivery_date - Delivery date has time included - copied from order header and might have been modified by user
   -- newrec_.wanted_delivery_date -  Delivery date has time included - copied from order header and might have been modified by user
   IF (newrec_.line_no IS NOT NULL) THEN
      IF NOT(Is_Number___(newrec_.line_no)) THEN
         Error_SYS.Record_General(lu_name_, 'NOTANUMBER: Line No and/or Delivery No must have numeric values.');
      END IF;
      newrec_.line_no := FLOOR(newrec_.line_no);
   END IF;

   IF (newrec_.rel_no IS NOT NULL) THEN
      IF NOT(Is_Number___(newrec_.rel_no)) THEN
         Error_SYS.Record_General(lu_name_, 'NOTANUMBER: Line No and/or Delivery No must have numeric values.');
      END IF;
      newrec_.rel_no := FLOOR(newrec_.rel_no);
   END IF;

   Validate_Price___(newrec_);

   IF (newrec_.rel_no IS NULL) THEN
      CUSTOMER_ORDER_API.Get_Next_Line_No(newrec_.rel_no, newrec_.line_item_no, newrec_.line_no, newrec_.order_no,
                                          newrec_.contract, newrec_.catalog_no, Order_Supply_Type_API.Decode(newrec_.supply_code),
                                          newrec_.demand_code, newrec_.rental);
   ELSIF (newrec_.line_item_no <= 0) THEN
      IF (newrec_.supply_code = 'PKG') THEN
         newrec_.line_item_no := -1;
      ELSE
         newrec_.line_item_no := 0;
      END IF;
   END IF;

   created_by_server_ := (NVL(Client_SYS.Get_Item_Value('CREATED_BY_SERVER', attr_), '0') = '1');
   IF (indrec_.planned_ship_date) THEN
      IF (NOT created_by_server_) THEN
         Error_SYS.Item_Insert(lu_name_, 'PLANNED_SHIP_DATE');
      END IF;
   END IF;

   calc_revise_qty_due_ := newrec_.buy_qty_due * newrec_.conv_factor / newrec_.inverted_conv_factor;
   -- calculated value for calc_revise_qty_due_ could exceed 38 decimal points sometimes. Therefor it is
   -- rounded for 38 because maximum guaranteed precision for Oracle numbers is 38.
   IF ((length(calc_revise_qty_due_)-INSTR(calc_revise_qty_due_,'.')) > 38) THEN
      calc_revise_qty_due_ := ROUND(calc_revise_qty_due_, 38);
   END IF;
   newrec_.revised_qty_due := calc_revise_qty_due_;
   
   IF (newrec_.vendor_no IS NOT NULL) THEN
      Exist_Vendor_No___(newrec_.vendor_no, newrec_.contract, newrec_.purchase_part_no, newrec_.rental);
   END IF;

   IF(Client_SYS.Get_Item_Value('SHIPMENT_CREATION_SENT', attr_) = 'TRUE') THEN
      shipment_creation_sent_ := TRUE;
   END IF;
   IF(Client_SYS.Get_Item_Value('SHIPMENT_TYPE_SENT', attr_) = 'TRUE') THEN
      shipment_type_sent_ := TRUE;
   END IF;
   IF(Client_SYS.Get_Item_Value('PACKED_SHIP_CRE_IN_INIT', attr_) = 'TRUE') THEN
      packed_ship_cre_in_init_ := TRUE;
   END IF;

   company_         := Site_API.Get_Company(newrec_.contract);
   header_rowstate_ := order_rec_.rowstate;
   site_date_       := Site_API.Get_Site_Date(newrec_.contract);
   -- fetch demand code to use with CUST_WARRANTY_ID check...

   IF (newrec_.rel_mtrl_planning IS NULL) THEN
      newrec_.rel_mtrl_planning := 'TRUE';
   END IF;
   
   IF (newrec_.supply_code = 'PKG') AND (newrec_.rel_mtrl_planning = 'FALSE') THEN
      Error_SYS.Record_General(lu_name_, 'RELMTRLPKGTUPDATE: The Release for Mtrl Planning check box cannot be updated for package parts. Please use the package part structure window to set it for component lines.');
   END IF;

   IF (newrec_.blocked_for_invoicing IS NULL) THEN
      newrec_.blocked_for_invoicing := 'FALSE';
   END IF;

   IF (newrec_.price_source_net_price IS NULL) THEN
      newrec_.price_source_net_price := 'FALSE';
   END IF;

   IF (newrec_.abnormal_demand IS NULL) THEN
      newrec_.abnormal_demand := 'FALSE';
   END IF;

   IF (newrec_.supply_code IN ('PT', 'PD', 'IPT', 'IPD')) THEN
      IF created_by_server_ AND (newrec_.vendor_no IS NULL) THEN
         -- check if non-inventory sales part uses a purchase part
         newrec_.vendor_no := Retrieve_Default_Vendor__(newrec_.contract, newrec_.purchase_part_no, newrec_.supply_code, newrec_.rental);
         Validate_Vendor_No__(newrec_.vendor_no, newrec_.supply_code);
      ELSE
         -- Validate the category for the specified vendor
         Validate_Vendor_Category___(newrec_.vendor_no, newrec_.supply_code);
      END IF;
   ELSE
      newrec_.vendor_no   := NULL;
      newrec_.supply_site := NULL;
      newrec_.supply_site_reserve_type := 'NOTALLOWED';
   END IF;

   Check_Purch_Supply_Code___ (newrec_);

  -- prevent setting target date earlier than wanted delivery date
   IF (newrec_.target_date IS NULL OR (newrec_.target_date < newrec_.wanted_delivery_date )) THEN
      newrec_.target_date := newrec_.wanted_delivery_date;
   END IF;

   IF (newrec_.supply_code != 'DOP') THEN
      newrec_.dop_connection := NULL;
   ELSE
      IF (newrec_.dop_connection IS NULL) THEN
         newrec_.dop_connection := Dop_Connection_API.Encode(Inventory_Part_API.Get_Dop_Connection(newrec_.contract, newrec_.part_no));
      END IF;
   END IF;
   
   -- Validate supply code so that it has the correct value depending on different data
   Check_Supply_Code___(newrec_);

   shipment_type_ := newrec_.shipment_type;
   IF (newrec_.supply_code = 'SRC') THEN
      std_planned_item_po_comp_ := NVL(Client_SYS.Get_Item_Value('SRC_STD_PLANNED_ITEM', attr_), 'TRUE');
      IF (std_planned_item_po_comp_ = 'FALSE') THEN
         std_planned_item_po_comp_ := 'FALSE';
      END IF;
      
      -- Replaced with the deliver_to_customer_no
      -- Automatic sourcing, all supply chain parameters are returned by the sourcing method
      Source_Order_Lines_API.Source_Automatically__(newrec_.route_id, newrec_.forward_agent_id,
                                                    newrec_.supply_code, newrec_.vendor_no,
                                                    newrec_.ship_via_code,
                                                    newrec_.delivery_terms,
                                                    newrec_.del_terms_location,
                                                    newrec_.supplier_ship_via_transit,
                                                    newrec_.delivery_leadtime,
                                                    newrec_.ext_transport_calendar_id,
                                                    newrec_.default_addr_flag,
                                                    newrec_.picking_leadtime, newrec_.shipment_type,
                                                    newrec_.order_no, newrec_.line_no,
                                                    newrec_.rel_no, newrec_.line_item_no,
                                                    newrec_.contract, newrec_.catalog_no,
                                                    newrec_.part_no, newrec_.purchase_part_no,
                                                    newrec_.revised_qty_due, newrec_.deliver_to_customer_no,
                                                    newrec_.ship_addr_no, newrec_.addr_flag,
                                                    newrec_.wanted_delivery_date,
                                                    newrec_.demand_code);

      IF (newrec_.supplier_ship_via_transit IS NOT NULL) THEN
         newrec_.supplier_ship_via_transit_desc := Mpccom_Ship_Via_API.Get_Description(newrec_.supplier_ship_via_transit, order_rec_.language_code);
      ELSE
         newrec_.supplier_ship_via_transit_desc := NULL;
      END IF;
   ELSE
      -- Retrive default values for supply chain parameters
      IF (NVL(Client_SYS.Get_Item_Value('FETCH_SUPPLY_CHAIN_DEFAULTS', attr_), 'TRUE') = 'TRUE') THEN
         Get_Supply_Chain_Defaults___(newrec_, indrec_);
      END IF;
   END IF;

   IF (shipment_type_sent_) THEN
      newrec_.shipment_type := shipment_type_;
   END IF;
   IF (newrec_.shipment_type IS NULL) THEN
      newrec_.shipment_type := order_rec_.shipment_type;
   ELSE
      IF (newrec_.default_addr_flag = 'Y' AND (newrec_.shipment_type != order_rec_.shipment_type)) THEN
         newrec_.default_addr_flag := 'N';
      END IF;
   END IF;
   IF (NOT shipment_creation_sent_) OR ((packed_ship_cre_in_init_) AND (order_rec_.shipment_type != newrec_.shipment_type))THEN
      newrec_.shipment_creation := Shipment_Creation_API.Encode(Shipment_Type_API.Get_Shipment_Creation_Co(newrec_.shipment_type));
   END IF;

   IF (newrec_.part_ownership IS NULL) THEN
      IF (newrec_.rental = Fnd_Boolean_API.DB_FALSE) THEN
         newrec_.part_ownership := Part_Ownership_API.DB_COMPANY_OWNED;
      ELSE
         newrec_.part_ownership := Part_Ownership_API.DB_COMPANY_RENTAL_ASSET;
      END IF;
   ELSIF newrec_.part_ownership IN (Part_Ownership_API.DB_CUSTOMER_OWNED, Part_Ownership_API.DB_SUPPLIER_LOANED) THEN
      newrec_.part_price               := 0;
      newrec_.sale_unit_price          := 0;
      newrec_.unit_price_incl_tax      := 0;
      newrec_.base_sale_unit_price     := 0;
      newrec_.base_unit_price_incl_tax := 0;
      newrec_.cost                     := 0;
      newrec_.price_source             := 'UNSPECIFIED';
      newrec_.price_source_id          := NULL;
      IF newrec_.char_price IS NOT NULL THEN
         newrec_.char_price := 0;
      END IF;
      IF newrec_.calc_char_price IS NOT NULL THEN
         newrec_.calc_char_price := 0;
      END IF;
   ELSIF (newrec_.part_ownership = Part_Ownership_API.DB_COMPANY_RENTAL_ASSET) THEN
 	 	newrec_.cost  := 0;
   END IF;
    
   -- set release_planning flag according to supply_code
   IF (newrec_.supply_code IN ('IPT', 'IPD')) THEN
      newrec_.release_planning := 'RELEASED' ;
      -- fetching the supply site part no when inserting.
      newrec_.supply_site_part_no := Sales_Part_API.Get_Supply_Site_Part_No__(newrec_.supply_site, newrec_.contract, newrec_.catalog_no, newrec_.vendor_no );
      Assign_Rel_Mtrl_Planning___(newrec_, header_rowstate_);
   END IF;

   -- do not calculate the order dates if this line have just been created from a capability checked sourced order line
   -- becuase we have already done forward date calculation that we do not want recalculated now
   capability_check_source_flag_ := NVL(Client_SYS.Get_Item_Value('CAPABILITY_CHK_SOURCE_FLAG', attr_), 'FALSE');
   IF (capability_check_source_flag_ = 'FALSE') THEN
      -- Calculate all the dates on the new order line
      Calculate_Order_Line_Dates___(newrec_, NULL, NULL);
   END IF;

   IF (newrec_.exchange_item IS NULL) THEN
      newrec_.exchange_item := 'ITEM NOT EXCHANGED';
   END IF;

   IF (newrec_.provisional_price IS NULL) THEN
      newrec_.provisional_price := 'FALSE';
   END IF;

   IF (newrec_.receiving_advice_type IS NULL) THEN
      newrec_.receiving_advice_type := Sales_Part_Cross_Reference_API.Get_Receiving_Advice_Type_Db(order_rec_.customer_no, order_rec_.contract, newrec_.customer_part_no);
      IF (newrec_.receiving_advice_type IS NULL) OR (newrec_.receiving_advice_type = 'USE_CUSTOMER_DEFAULT') THEN
         newrec_.receiving_advice_type := Cust_Ord_Customer_API.Get_Receiving_Advice_Type_Db(order_rec_.customer_no);
      END IF;
      newrec_.receiving_advice_type := NVL(newrec_.receiving_advice_type, 'DO_NOT_USE');
   ELSIF (newrec_.receiving_advice_type = 'USE_CUSTOMER_DEFAULT') THEN
      Error_SYS.Record_General(lu_name_, 'INVALIDRECADVTYPE: Receiving advice type ":P1" can not be used in customer order line.', Receiving_Advice_Type_API.Decode(newrec_.receiving_advice_type));
   END IF;

   IF ((newrec_.rental = Fnd_Boolean_API.DB_FALSE) AND newrec_.line_item_no <= 0 AND (order_rec_.limit_sales_to_assortments = 'TRUE') AND ((newrec_.demand_code IS NULL) OR (newrec_.demand_code IN ('CQ', 'BO')))) THEN
      Sales_Part_API.Check_Limit_Sales_To_Assort(newrec_.contract, newrec_.catalog_no, newrec_.customer_no);
   END IF;
   
   super(newrec_, indrec_, attr_);

   IF ((newrec_.part_ownership = 'SUPPLIER LOANED') AND
       (NVL(Get_Owner_For_Part_Ownership(newrec_.order_no,
                                        newrec_.line_no,
                                        newrec_.rel_no,
                                        newrec_.line_item_no,
                                        newrec_.part_ownership), Database_SYS.string_null_) = Database_SYS.string_null_)) THEN
       Error_SYS.Record_General(lu_name_, 'NULLOWNERFORSUPLOANED: The customer must be connected to a supplier in order to return :P1 stock', Part_Ownership_API.Decode(newrec_.part_ownership));
   END IF;

   IF (newrec_.blocked_for_invoicing = 'TRUE') THEN
      Validate_Block_For_Invoic___(newrec_);
   END IF;

   IF ((order_rec_.internal_po_no IS NOT NULL) AND (order_rec_.internal_po_no = NVL(newrec_.demand_order_ref1, ' ')) AND (newrec_.discount < 0)) THEN
      Error_SYS.Record_General(lu_name_, 'IPO_NEG_DISC: Negative discount cannot be handled when the customer order originates from an internal purchase order. Check valid price list(s) and/or Customer Agreement(s).');
   END IF;

   IF (newrec_.price_unit_meas IS NULL) THEN
      newrec_.price_unit_meas := Sales_Part_API.Get_Price_Unit_Meas(newrec_.contract, newrec_.catalog_no);
   END IF;

   Iso_Unit_API.Exist(newrec_.price_unit_meas);

   IF (newrec_.cust_calendar_id IS NOT NULL) THEN
      IF (newrec_.cust_calendar_id != NVL(order_rec_.cust_calendar_id, Database_Sys.string_null_)) THEN
         IF newrec_.demand_code != 'IPD' THEN
            Cust_Ord_Customer_API.Validate_Customer_Calendar(newrec_.customer_no, newrec_.cust_calendar_id, TRUE);
         ELSE
            Cust_Ord_Customer_API.Validate_Customer_Calendar(newrec_.customer_no, newrec_.cust_calendar_id, FALSE);
         END IF;
      END IF;
   END IF;

   IF (newrec_.customer_part_no IS NOT NULL) THEN
      IF (Sales_Part_Cross_Reference_API.Get_Self_Billing_Db(newrec_.customer_no, newrec_.contract, newrec_.customer_part_no) = 'NOT SELF BILLING' AND (newrec_.self_billing = 'SELF BILLING'))THEN
         Error_SYS.Record_General(lu_name_, 'EDITNOTALLOWEDSB: Cannot use self-billing on customer order line when there is no sales part cross reference record allowing self-billing for Sales part :P1 and Customer :P2 on site :P3 .',
                                  newrec_.catalog_no, newrec_.customer_no, newrec_.contract);
      END IF;
   ELSE
      IF (newrec_.self_billing = 'SELF BILLING') THEN
         Error_SYS.Record_General(lu_name_, 'EDITNOTALLOWEDSB: Cannot use self-billing on customer order line when there is no sales part cross reference record allowing self-billing for Sales part :P1 and Customer :P2 on site :P3 .',
                                  newrec_.catalog_no, newrec_.customer_no, newrec_.contract);
      END IF;
   END IF;

   -- Check for prepayment exists before self billing is entered for a Customer Order.
   IF (order_rec_.proposed_prepayment_amount > 0 AND newrec_.self_billing = 'SELF BILLING') THEN
      Error_SYS.Record_General(lu_name_, 'PREPAY_EXISTSELF: The Required Prepayment amount exists. Cannot enable this customer order for self billing.');
   END IF;

   IF (newrec_.input_unit_meas IS NOT NULL) AND (newrec_.input_qty IS NULL) THEN
      Error_SYS.Record_General(lu_name_, 'INPUTQTYNEEDED: Input quantity must be entered when Input UoM has a value');
   END IF;

   server_data_change_ := Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('SERVER_DATA_CHANGE', attr_));
   IF (Order_Supply_Type_API.Encode(Get_Demand_Code(newrec_.order_no,1,1,0)) = 'DO' AND server_data_change_ IS NULL) THEN
      Error_SYS.Record_General(lu_name_, 'NOORDERLINEWHENDO: Customer Order Lines cannot be created when Customer Order is created from Distribution Order');
   END IF;

   -- When the customer order originates from an internal purchase order, co lines can not be added manually
   IF ((order_rec_.internal_po_no IS NOT NULL) AND (order_rec_.internal_po_no != NVL(newrec_.demand_order_ref1, ' ')) AND (newrec_.line_item_no <= 0) AND (NVL(newrec_.demand_code, ' ') != 'DO')) THEN
      Error_SYS.Record_General(lu_name_, 'CHANGENOTALLOWED: It is not allowed to add or remove order lines when the customer order originates from an internal purchase order.');
   END IF;

   -- do not allow automatic sourcing if the part is not COMPANY OWNED
   IF (newrec_.supply_code = 'SRC' AND newrec_.part_ownership != 'COMPANY OWNED') THEN
      Error_SYS.Record_General(lu_name_, 'COMPANYOWNAUTOSRC: Only Company Owned parts can be used with Supply Code :P1',Order_Supply_Type_API.Decode('SRC'));
   END IF;

   IF ((newrec_.freight_map_id IS NULL AND newrec_.zone_id IS NULL) OR (newrec_.default_addr_flag = 'Y' AND newrec_.addr_flag = 'Y' AND order_rec_.freight_map_id IS NOT NULL)) THEN
      addr_rec_ := Customer_Order_Address_API.Get_Cust_Ord_Addr(newrec_.order_no);
      Freight_Zone_Util_API.Fetch_Zone_For_Addr_Details(newrec_.freight_map_id,
                                                        newrec_.zone_id,
                                                        zone_info_exist_,
                                                        newrec_.contract,
                                                        newrec_.ship_via_code,
                                                        addr_rec_.zip_code,
                                                        addr_rec_.city,
                                                        addr_rec_.county,
                                                        addr_rec_.state,
                                                        addr_rec_.country_code);
   END IF;
   IF (newrec_.freight_map_id IS NOT NULL) THEN
      IF ((newrec_.supply_code IN ('PD', 'IPD') AND newrec_.vendor_no IS NOT NULL)) THEN
         newrec_.freight_price_list_no := Freight_Price_List_Direct_API.Get_Active_Freight_List_No(newrec_.contract, newrec_.ship_via_code, newrec_.freight_map_id, newrec_.forward_agent_id,  order_rec_.use_price_incl_tax, newrec_.vendor_no);
      ELSE
         newrec_.freight_price_list_no := Freight_Price_List_API.Get_Active_Freight_List_No(newrec_.contract, newrec_.ship_via_code, newrec_.freight_map_id, newrec_.forward_agent_id, order_rec_.use_price_incl_tax);
      END IF;
   ELSE
      newrec_.freight_price_list_no := NULL;
   END IF;

   IF (newrec_.supply_code IN ('IPT', 'IPD')) THEN
      -- Initialize the supply site attribute for internal suppliers
      newrec_.supply_site := Get_Vendor_Contract__(newrec_.vendor_no, NULL, NULL, NULL, newrec_.rental);

      IF (newrec_.supply_site_reserve_type = 'NOTALLOWED') THEN
           -- get default supply_site_reserve_type_
           -- check if the inventory part exists on the supply_site (is the supply_site in the same database)
         IF (Inventory_Part_API.Part_Exist(newrec_.supply_site, NVL(newrec_.part_no,newrec_.purchase_part_no)) = 1) THEN
            -- check if a security connection exists between the CO/PO Site (Demand site) and the Supply Site
            IF (Site_To_Site_Reserve_Setup_API.Connection_Allowed(newrec_.supply_site, newrec_.contract) = 1) THEN
               newrec_.supply_site_reserve_type := Site_To_Site_Reserve_Setup_API.Get_Supply_Site_Reserve_Db(newrec_.supply_site, newrec_.contract);
            END IF;
         END IF;
      ELSIF (Site_To_Site_Reserve_Setup_API.Connection_Allowed(newrec_.supply_site, newrec_.contract) = 0) OR
            (Site_To_Site_Reserve_Setup_API.Get_Supply_Site_Reserve_Db(newrec_.supply_site, newrec_.contract) = Supply_Site_Reserve_Type_API.DB_NOT_ALLOWED)THEN
         Error_Sys.Record_General(lu_name_, 'CONN_NOT_ALLOWED: No Site to Site Reservation allowed between demand site :P1 and supply site :P2',newrec_.contract,newrec_.supply_site);
      END IF;
   ELSE
      -- Clear supply site if not internal supply
      newrec_.supply_site := NULL;
   END IF;

   IF (newrec_.rental = Fnd_Boolean_API.DB_FALSE) AND NOT ((newrec_.part_ownership = Part_Ownership_API.DB_COMPANY_OWNED ) OR (newrec_.part_ownership = Part_Ownership_API.DB_CUSTOMER_OWNED AND newrec_.owning_customer_no = order_rec_.customer_no)) THEN
      IF (order_rec_.project_id IS NOT NULL) THEN
         -- PROJ_NEW error should not be raised for CO line is created from external service order 
         $IF Component_Purch_SYS.INSTALLED $THEN
            IF ((NVL(newrec_.demand_code, Database_SYS.string_null_) = 'PO') AND (newrec_.demand_order_ref1 IS NOT NULL)) THEN
               IF (Purchase_Order_API.Get_Order_Code(newrec_.demand_order_ref1) = 6) THEN
                  external_service_order_ := Fnd_Boolean_API.DB_TRUE;
               END IF;
            END IF;
         $END
         IF (external_service_order_ = Fnd_Boolean_API.DB_FALSE) THEN    
            Error_SYS.Record_General(lu_name_, 'PROJ_NEW: Can not add a new customer order line that has a different ownership other than company owned or customer owned by the customer :P1.',order_rec_.customer_no);
         END IF;
      END IF;
   END IF;

   Customer_Agreement_API.Get_Agreement_For_Part(customer_agreement_,
                                                 order_rec_.customer_no,
                                                 order_rec_.contract,
                                                 order_rec_.currency_code,
                                                 newrec_.catalog_no,
                                                 site_date_);
  
   -- Forced re-evaluating default_addr_flag for DO as it can have shipment_type values different from order header due to exception for site to site                                               
   -- Forced re-evaluating default_addr_flag for IPT too as it can have shipment_type values different from order header due to exception for site to site                                        
   IF (customer_agreement_ IS NOT NULL OR (newrec_.demand_code IN ('IPT', 'DO'))) THEN     
      IF newrec_.default_addr_flag = 'Y' THEN
         IF ((NVL(order_rec_.route_id, ' ') != NVL(newrec_.route_id, ' ')) OR
             (NVL(order_rec_.forward_agent_id, ' ') != NVL(newrec_.forward_agent_id, ' ')) OR
             (NVL(order_rec_.cust_ref, ' ') != NVL(newrec_.contact, ' ')) OR
             (NVL(order_rec_.ship_via_code, ' ') != NVL(newrec_.ship_via_code, ' ')) OR
             (NVL(order_rec_.cust_calendar_id, Database_Sys.string_null_) != NVL(newrec_.cust_calendar_id, Database_Sys.string_null_)) OR
             (NVL(order_rec_.ext_transport_calendar_id, Database_Sys.string_null_) != NVL(newrec_.ext_transport_calendar_id, Database_Sys.string_null_)) OR
             (order_rec_.delivery_terms != newrec_.delivery_terms) OR
             (NVL(order_rec_.del_terms_location, ' ') != NVL(newrec_.del_terms_location, ' ')) OR
             (order_rec_.delivery_leadtime != newrec_.delivery_leadtime) OR
             (order_rec_.picking_leadtime != newrec_.picking_leadtime) OR
             (order_rec_.shipment_type != newrec_.shipment_type) OR
             (order_rec_.shipment_creation != newrec_.shipment_creation) OR
             (NVL(order_rec_.district_code, ' ') != NVL(newrec_.district_code, ' ')) OR
             (NVL(order_rec_.region_code, ' ') != NVL(newrec_.region_code, ' ')) OR
             (Customer_Order_API.Get_Tax_Liability_Type_Db(newrec_.order_no) != newrec_.tax_liability_type) OR
             (order_rec_.intrastat_exempt != newrec_.intrastat_exempt) OR
             (NVL(order_rec_.ship_addr_no, ' ') != NVL(newrec_.ship_addr_no, ' '))) THEN
            newrec_.default_addr_flag := 'N';
         END IF;
      END IF;
   END IF;

   IF (newrec_.activity_seq IS NOT NULL) THEN
      original_demand_code_ := newrec_.demand_code;
      original_supply_code_ := newrec_.supply_code;
      IF newrec_.line_item_no > 0 THEN
         new_pkg_component_line_ := TRUE;
      END IF;

      Validate_Proj_Connect___(newrec_.project_id,
                               newrec_.demand_code,
                               newrec_.supply_code,
                               newrec_.order_no,
                               newrec_.contract,
                               newrec_.rowstate,
                               newrec_.consignment_stock,
                               newrec_.qty_on_order,
                               newrec_.activity_seq,
                               NULL,
                               newrec_.planned_ship_date,
                               newrec_.catalog_no,
                               new_pkg_component_line_,
                               newrec_.catalog_type );
      IF (original_demand_code_ = 'PO' AND std_planned_item_po_comp_ = 'TRUE') THEN
         newrec_.supply_code := original_supply_code_;
      END IF;
   END IF;

   IF (newrec_.provisional_price = 'TRUE' AND newrec_.price_freeze = 'FROZEN') THEN
      Error_SYS.Record_General(lu_name_, 'SALES_PRICE_TYPE: It is not allowed to select provisional price and price freeze together.');
   END IF;

   IF (newrec_.qty_assigned < 0) THEN
      Error_SYS.Record_General(lu_name_,'COASSQTYNOTNEG: The quantity reserved may not be negative.');
   END IF;

   IF (newrec_.classification_standard IS NOT NULL) THEN
      assortment_id_ := Assortment_Structure_API.Get_Assort_For_Classification(newrec_.classification_standard);
      IF (Customer_Assortment_Struct_API.Get_Classification_Standard(newrec_.customer_no, assortment_id_) IS NULL) THEN
         Error_SYS.Record_General(lu_name_, 'INVALID_CLASSIF: The classification standard :P1 is not connected to the customer :P2.',newrec_.classification_standard, order_rec_.customer_no);
      END IF;
      IF (newrec_.classification_part_no IS NULL) THEN
         Assortment_Node_API.Get_Classification_Defaults(newrec_.classification_unit_meas,
                                                         newrec_.catalog_no,
                                                         newrec_.classification_part_no,
                                                         newrec_.classification_standard,
                                                         'TRUE');  
      END IF;
   END IF;

   Check_Demand_Code___(newrec_.demand_code, order_rec_.confirm_deliveries, newrec_.consignment_stock);

   IF (newrec_.rental = Fnd_Boolean_API.DB_FALSE AND NVL(newrec_.demand_code, Database_SYS.string_null_) = Order_Supply_Type_API.DB_REPLACEMENT_CUSTOMER_ORDER) THEN
      Error_SYS.Record_General(lu_name_, 'NONRENTALREPLACEMENT: The demand code :P1 cannot be used for a non-rental customer order line.');
   END IF;

   IF (newrec_.picking_leadtime != trunc(newrec_.picking_leadtime)) OR (newrec_.picking_leadtime < 0) THEN
      Error_SYS.Item_General(lu_name_, 'PICKING_LEADTIME', 'PICKVALUEINTEGER: [:NAME] must be an integer. Negative values not allowed.');
   END IF;

   tax_liability_type_db_ := newrec_.tax_liability_type; 
   
   IF (newrec_.demand_code = 'IPD' AND Get_Ship_Addr_No( newrec_.order_No, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no) != newrec_.ship_addr_no) THEN
      Client_SYS.Add_Info(lu_name_, 'NOTAXUPDATE: The tax information will not be updated automatically. Consider reviewing the information.');
   END IF;
   
   partca_rec_ := Part_Catalog_API.Get(newrec_.part_no);
   IF (header_rowstate_ = 'Planned' AND newrec_.part_no IS NOT NULL) THEN
      inv_part_cost_level_db_ := Inventory_Part_API.Get_Invent_Part_Cost_Level_Db(newrec_.contract, newrec_.part_no);
      -- Checked inv_part_cost_level_db_ as well before setting the cost to zero.
      IF (newrec_.configuration_id = '*') AND (inv_part_cost_level_db_ = 'COST PER CONFIGURATION') AND (partca_rec_.configurable = 'CONFIGURED') THEN
         newrec_.cost := 0;
      END IF;
   END IF;
   IF (newrec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
      newrec_.cost := 0;
   END IF;
   -- New order lines not allowed when the order is in state 'Delivered' or 'Invoiced'
   -- unless the lines are created by the public New method.
   -- Forward the created_by_server_ value to the Insert___ method...
   IF (NOT created_by_server_) THEN
      -- Make sure new order lines are allowed
      IF (CUSTOMER_ORDER_API.New_Order_Lines_Allowed(newrec_.order_no) = 0) THEN
         Error_SYS.Record_General(lu_name_, 'NONEWLINES: Order lines cannot be added if the order is Invoiced/Closed or Cancelled.');
      END IF;

      IF (newrec_.line_item_no > 0) THEN
         -- Check if new component order lines are allowed.
         IF (New_Comp_Lines_Allowed(newrec_.order_no, newrec_.line_no, newrec_.rel_no) = 0) THEN
            Error_SYS.Record_General(lu_name_, 'NONEWCOMP: Package components cannot be added if the order line is Delivered, Invoiced/Closed or Cancelled.');
         END IF;
      END IF;
   END IF;

   -- update pricing info
   IF (is_config_edited_ = TRUE) THEN
      Update_Config_Pricing_Info___(newrec_);
      Client_SYS.Add_To_Attr('CHAR_PRICE', newrec_.char_price, attr_);
      Client_SYS.Add_To_Attr('CALC_CHAR_PRICE', newrec_.calc_char_price, attr_);
   END IF;

   Check_Before_Insert___(attr_, newrec_, order_rec_.currency_code);

   Client_SYS.Add_To_Attr('LINE_NO', newrec_.line_no, attr_);
   Client_SYS.Add_To_Attr('REL_NO', newrec_.rel_no, attr_);
   Client_SYS.Add_To_Attr('LINE_ITEM_NO', newrec_.line_item_no, attr_);
   Client_SYS.Add_To_Attr('DESIRED_QTY', newrec_.desired_qty, attr_);
   Client_SYS.Add_To_Attr('ADDITIONAL_DISCOUNT', newrec_.additional_discount, attr_);
   Client_SYS.Add_To_Attr('SUPPLY_CODE_DB', newrec_.supply_code, attr_);
   Client_SYS.Add_To_Attr('SUPPLY_CODE', Order_Supply_Type_API.Decode(newrec_.supply_code), attr_);
   Client_SYS.Add_To_Attr('VENDOR_NO', newrec_.vendor_no, attr_);
   Client_SYS.Add_To_Attr('SHIP_VIA_CODE', newrec_.ship_via_code, attr_);
   Client_SYS.Add_To_Attr('CUST_CALENDAR_ID', newrec_.cust_calendar_id, attr_);
   Client_SYS.Add_To_Attr('EXT_TRANSPORT_CALENDAR_ID', newrec_.ext_transport_calendar_id, attr_);
   Client_SYS.Add_To_Attr('DELIVERY_LEADTIME', newrec_.delivery_leadtime, attr_);
   Client_SYS.Add_To_Attr('DEFAULT_ADDR_FLAG_DB', newrec_.default_addr_flag, attr_);
   Client_SYS.Add_To_Attr('DEFAULT_ADDR_FLAG', Gen_Yes_No_API.Decode(newrec_.default_addr_flag), attr_);
   Client_SYS.Add_To_Attr('SUPPLY_SITE', newrec_.supply_site, attr_);
   Client_SYS.Add_To_Attr('SUPPLY_SITE_RESERVE_TYPE_DB', newrec_.supply_site_reserve_type, attr_);
   Client_SYS.Add_To_Attr('SUPPLY_SITE_RESERVE_TYPE', Supply_Site_Reserve_Type_API.Decode(newrec_.supply_site_reserve_type), attr_);
   Client_SYS.Add_To_Attr('SUPPLIER_SHIP_VIA_TRANSIT', newrec_.supplier_ship_via_transit, attr_);
   Client_SYS.Add_To_Attr('SUPPLIER_SHIP_VIA_TRANSIT_DESC', newrec_.supplier_ship_via_transit_desc, attr_);
   Client_SYS.Add_To_Attr('DELIVERY_CONFIRMED_DB', newrec_.delivery_confirmed, attr_);
   Client_SYS.Add_To_Attr('PICKING_LEADTIME', newrec_.picking_leadtime, attr_);
   Client_SYS.Add_To_Attr('SHIPMENT_TYPE', newrec_.shipment_type, attr_);
   Client_SYS.Add_To_Attr('ROUTE_ID', newrec_.route_id, attr_);
   Client_SYS.Add_To_Attr('FORWARD_AGENT_ID', newrec_.forward_agent_id, attr_);
   Client_SYS.Add_To_Attr('PLANNED_DUE_DATE', newrec_.planned_due_date, attr_);
   
   newrec_.planned_due_date    := newrec_.planned_due_date;
   newrec_.additional_discount := order_rec_.additional_discount;

   IF (newrec_.part_no IS NOT NULL) THEN
      IF (newrec_.condition_code IS NOT NULL) THEN
         IF (partca_rec_.condition_code_usage = 'NOT_ALLOW_COND_CODE') THEN
            Error_SYS.Record_General(lu_name_,'COND_NOT_ALLOW: Condition code functionality is not enabled for this part. You cannot enter a condition code.');
         ELSE
            Condition_Code_API.Exist(newrec_.condition_code);
         END IF;
      ELSE
         IF (partca_rec_.condition_code_usage = 'ALLOW_COND_CODE') THEN
            newrec_.condition_code := Condition_Code_API.Get_Default_Condition_Code;
            -- send this to the client
         Client_SYS.Add_To_Attr('CONDITION_CODE', newrec_.condition_code, attr_);
         END IF;
      END IF;
   END IF;

   IF (newrec_.condition_code IS NOT NULL) THEN
      IF (newrec_.catalog_type = 'PKG') THEN
         Error_SYS.Record_General(lu_name_,'NO_COND_ON_PKG: Condition codes are not allowed for Package Parts.');
      ELSIF (newrec_.catalog_type = 'NON') THEN
         Error_SYS.Record_General(lu_name_,'NO_COND_ON_NON: Condition codes are not allowed for Non Inventory Sales Parts.');
      END IF;
   END IF;

   -- IF supply code is MRO no SM object should be created on delivery of the order line
   IF (newrec_.supply_code = 'MRO') AND (newrec_.create_sm_object_option = 'CREATESMOBJECT') THEN
      Error_SYS.Record_General(lu_name_, 'NOMROSM: Create SM Object is not allowed when supply code is MRO');
   END IF;

   IF (newrec_.supply_code IN ('IPD', 'PD', 'SEO')) OR (newrec_.supply_code = 'ND' AND (newrec_.line_item_no > 0)) THEN
      -- Added IF condition to use shipment creation method when supply code is IPD.
      IF ( newrec_.supply_code != 'IPD') THEN
         newrec_.shipment_creation := 'NO_AUTOMATIC';
      END IF;
      -- change default address flag to 'N' if header and line shipment creation methods are different.
      IF (order_rec_.shipment_creation != newrec_.shipment_creation ) THEN
         newrec_.default_addr_flag := 'N';
      END IF;
   END IF;

   -- Validate for not to raise information message for component parts due to changes in component part shipment creation will update the package shipment creation where package it self
   -- raise the message.
   IF (newrec_.catalog_type = 'NON' AND newrec_.supply_code != 'IPD' AND newrec_.line_item_no <= 0 ) AND (newrec_.shipment_creation = 'PICK_LIST_CREATION') THEN
      Raise_Info_Message___;
   END IF;

   IF (newrec_.ext_transport_calendar_id IS NOT NULL) THEN
      Work_Time_Calendar_API.Check_Not_Generated(newrec_.ext_transport_calendar_id);
   END IF;

   IF (newrec_.shipment_type IS NULL AND newrec_.packing_instruction_id IS NOT NULL) THEN
      Error_SYS.Record_General(lu_name_, 'PACKINSTRIDNOTALLOWED: Packing Instruction cannot have a value when shipment type is NULL.');
   END IF;

   IF (newrec_.line_item_no < 1) THEN
      IF (newrec_.demand_code = 'IPT' AND newrec_.packing_instruction_id IS NULL) THEN
         IF (newrec_.shipment_type IS NOT NULL) THEN
            IF (newrec_.addr_flag = 'Y') THEN
               newrec_.packing_instruction_id := Def_Pack_Instruct_Shipment_API.Get_Packing_Instruction_Id(newrec_.contract, newrec_.catalog_no, newrec_.deliver_to_customer_no, newrec_.ship_addr_no);
            ELSE
               newrec_.packing_instruction_id := Def_Pack_Instruct_Shipment_API.Get_Packing_Instruction_Id(newrec_.contract, newrec_.catalog_no, newrec_.deliver_to_customer_no, NULL);
            END IF;
         ELSE
            newrec_.packing_instruction_id := NULL;
         END IF;
         Client_SYS.Set_Item_Value('PACKING_INSTRUCTION_ID', newrec_.packing_instruction_id, attr_);
      END IF;
   ELSE
      newrec_.packing_instruction_id := NULL;
      Client_SYS.Set_Item_Value('PACKING_INSTRUCTION_ID', newrec_.packing_instruction_id, attr_);
   END IF;

   IF (newrec_.packing_instruction_id IS NOT NULL) THEN
      Part_Handling_Unit_API.Check_Combination(newrec_.catalog_no,
                                               newrec_.sales_unit_meas,
                                               newrec_.packing_instruction_id);
   END IF;

   IF (NVL(Client_SYS.Get_Item_Value('ADD_INFO', attr_), 'FALSE') = 'TRUE') THEN
      current_info_ := Client_SYS.Get_All_Info;
      App_Context_SYS.Set_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_', current_info_);
      Trace_SYS.Field('current_info 1', current_info_);
   END IF;
EXCEPTION
   WHEN value_error THEN
      Error_SYS.Item_Format(lu_name_, name_, value_);
END Check_Insert___;


@Override
PROCEDURE Check_Update___ (
   oldrec_ IN     customer_order_line_tab%ROWTYPE,
   newrec_ IN OUT customer_order_line_tab%ROWTYPE,
   indrec_ IN OUT Indicator_Rec,
   attr_   IN OUT VARCHAR2 )
IS
   name_                            VARCHAR2(30);
   value_                           VARCHAR2(4000);
   delivery_date_changed_           BOOLEAN := FALSE;
   calendar_id_                     VARCHAR2(12);
   order_rec_                       CUSTOMER_ORDER_API.Public_Rec;
   site_rec_                        SITE_API.Public_Rec;
   sales_part_rec_                  SALES_PART_API.Public_Rec;
   site_discom_info_rec_            Site_Discom_Info_API.Public_Rec;
   header_rowstate_                 CUSTOMER_ORDER_TAB.rowstate%TYPE;
   default_addr_flag_               CUSTOMER_ORDER_LINE_TAB.default_addr_flag%TYPE;
   qty_refreshed_                   BOOLEAN := FALSE;
   buy_qty_changed_                 BOOLEAN := FALSE;
   total_sourced_qty_               NUMBER;
   supply_site_qty_                 NUMBER;
   supply_chain_reserve_            NUMBER;
   sourcing_flag_                   VARCHAR2(5) := 'FALSE';
   company_                         VARCHAR2(20);
   planned_date_changed_            BOOLEAN := FALSE;
   server_data_change_              NUMBER :=0;
   inv_flag_                        VARCHAR2(10);
   dop_new_qty_demand_              VARCHAR2(2000);
   dummy_                           VARCHAR2(2000);
   automatic_capability_check_      VARCHAR2(50);
   capability_check_source_flag_    VARCHAR2(5) := 'FALSE';
   dummy_boolean_                   BOOLEAN;
   old_auto_cc_flag_                VARCHAR2(50);
   interim_head_id_                 VARCHAR2(12);
   count_                           NUMBER;
   tax_code_                        VARCHAR2(20);
   refresh_tax_code_                BOOLEAN := FALSE;
   revised_qty_due_                 NUMBER;
   inv_part_cost_level_db_          VARCHAR2(50);
   temp_num_                        NUMBER;
   zone_info_exist_                 VARCHAR2(5) := 'FALSE';
   sing_occ_addr_                   Cust_Order_Line_Address_API.Co_Line_Addr_Rec;

   update_price_effective_date_     VARCHAR2(5);
   customer_level_db_               VARCHAR2(30);
   customer_level_id_               VARCHAR2(200);
   price_source_                    VARCHAR2(200);
   tax_codes_found_                 BOOLEAN := FALSE;
   supply_country_                  VARCHAR2(2);
   header_tax_id_no_                VARCHAR2(50);
   calculate_cost_for_config_       BOOLEAN := FALSE;
   sales_price_type_db_             VARCHAR2(20);
   rental_chargable_days_           NUMBER;
   current_info_                    VARCHAR2(32000);
   make_reservation_                VARCHAR2(5):='FALSE';
   from_shortage_                   VARCHAR2(5):='FALSE';
   no_of_preliminary_shipments_     NUMBER;
   new_ship_connectable_qty_        NUMBER;
   old_ship_connectable_qty_        NUMBER;
   connected_shipment_id_           NUMBER;
   change_request_                  VARCHAR2(5);
   update_on_ordchg_approve_        BOOLEAN:=FALSE;
   customer_no_                     customer_order_tab.customer_no%TYPE;   
   addr_no_                         customer_order_tab.bill_addr_no%TYPE;    
   calc_revise_qty_due_             NUMBER;
   ctp_run_id_                      NUMBER;
   temp_newrec_                     CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   b2b_quotation_order_             ORDER_QUOTATION_TAB.B2B_ORDER%TYPE;
   
   CURSOR get_manual_pick_lines IS
      SELECT COUNT(res.preliminary_pick_list_no)
      FROM   customer_order_reservation_tab res, manual_consol_pick_list_tab mpl
      WHERE  res.preliminary_pick_list_no IS NOT NULL
      AND    mpl.rowstate = 'Preliminary'
      AND    mpl.preliminary_pick_list_no = res.preliminary_pick_list_no
      AND    pick_list_no = '*'
      AND    res.order_no = newrec_.order_no
      AND    line_no      = newrec_.line_no
      AND    rel_no       = newrec_.rel_no
      AND    line_item_no = newrec_.line_item_no;

   insert_package_mode_             VARCHAR2(5);
   pkg_buy_qty_due_                 NUMBER;
   po_charged_comp_change_          VARCHAR2(5);
   discount_line_count_             NUMBER;
   sale_unit_price_                 NUMBER;
   unit_price_incl_tax_             NUMBER;
   base_sale_unit_price_            NUMBER;
   base_unit_price_incl_tax_        NUMBER;
   discount_                        NUMBER;
   unpeg_ipd_flag_                  VARCHAR2(5);
   interim_ord_id_                  VARCHAR2(12);
BEGIN
   -- planned_ship_date
   -- Planned ship period will be updated when the calendar is recreated (via planned_delivery_date)
   -- or if planned_ship_date has been changed by the user

   insert_package_mode_          := NVL(Client_SYS.Get_Item_Value('INSERT_PACKAGE_MODE_', attr_), 'FALSE');
   order_rec_                    := CUSTOMER_ORDER_API.Get(newrec_.order_no);
   header_rowstate_              := order_rec_.rowstate;
   capability_check_source_flag_ := NVL(Client_SYS.Get_Item_Value('CAPABILITY_CHECK_SOURCE_FLAG', attr_), 'FALSE');
   site_rec_                     := Site_API.Get(newrec_.contract);
   calendar_id_                  := site_rec_.dist_calendar_id;
   company_                      := site_rec_.company;
   server_data_change_           := NVL(Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('SERVER_DATA_CHANGE', attr_)), 0);
   po_charged_comp_change_       := Client_SYS.Get_Item_Value('PO_CHARGED_COMP_CHANGE', attr_);
   change_request_               := NVL(Client_SYS.Get_Item_Value('CHANGE_REQUEST', attr_), 'FALSE');
   unpeg_ipd_flag_               := NVL(Client_SYS.Get_Item_Value('UNPEG_IPD_FLAG', attr_), 'FALSE');
   IF ((change_request_ = 'TRUE') AND (NVL(newrec_.demand_code, Database_Sys.string_null_) = 'IPD')) THEN
      update_on_ordchg_approve_ := TRUE;
   END IF;

   Validate_Price___(newrec_);
   IF (indrec_.buy_qty_due) THEN
      Check_Qty_From_Repair_Order___(newrec_.demand_code, newrec_.demand_order_ref1, newrec_.part_no);
      -- Check if qty is refreshed, i.e., if qty has been updated with same value as in old record.
      -- Used for being able to trigger fetching of correct default prices and discounts.
      IF (oldrec_.buy_qty_due = newrec_.buy_qty_due) THEN
         -- buy_qty_due has been refreshed.
         qty_refreshed_ := TRUE;
      END IF;
      IF (newrec_.demand_code = 'WO') THEN
         Client_SYS.Add_Info(lu_name_, 'CONNECTED_TO_WO: This order is connected to work order :P1/:P2/:P3 - which will not be updated automatically.', newrec_.demand_order_ref1, newrec_.demand_order_ref2, newrec_.demand_order_ref3);
      END IF;
      make_reservation_ := 'TRUE';
      buy_qty_changed_  := TRUE;

   END IF;
 
   IF (indrec_.desired_qty) THEN
      Check_Qty_From_Repair_Order___(newrec_.demand_code, newrec_.demand_order_ref1, newrec_.part_no);
   END IF;

   -- check if date portion has changed - in that case it's not allowed to change the value
   IF ((trunc(oldrec_.planned_ship_date) != trunc(newrec_.planned_ship_date)) AND (server_data_change_ != 1) AND (capability_check_source_flag_ = 'FALSE')) THEN
      Error_SYS.Item_General(lu_name_, 'PLANNED_SHIP_DATE', 'UPD_TIME_ONLY: You may only change the time for [:NAME]!');
   ELSE
      -- set shipment period
      newrec_.planned_ship_period := Work_Time_Calendar_API.Get_Period(calendar_id_, newrec_.planned_ship_date);
   END IF;
   
   -- check if date portion has changed - in that case it's not allowed to change the value
   IF ((trunc(oldrec_.planned_due_date) != trunc(newrec_.planned_due_date)) AND (server_data_change_ != 1) AND (capability_check_source_flag_ = 'FALSE')) THEN
      Error_SYS.Item_General(lu_name_, 'PLANNED_DUE_DATE', 'UPD_TIME_ONLY: You may only change the time for [:NAME]!');
   END IF;

   b2b_quotation_order_ := Order_Quotation_API.Get_B2b_Order_Db(oldrec_.demand_order_ref1);
   
   IF (indrec_.demand_order_ref1) THEN
      IF (oldrec_.supply_code != 'MRO') THEN
         IF NOT(oldrec_.demand_code = 'CQ' AND b2b_quotation_order_ = 'TRUE') THEN
            Error_SYS.Item_Update(lu_name_, 'DEMAND_ORDER_REF1');
         END IF;
      END IF;
   END IF;

   IF (indrec_.demand_order_ref2) THEN
      IF (oldrec_.supply_code != 'MRO') THEN
         IF NOT(oldrec_.demand_code = 'CQ' AND b2b_quotation_order_ = 'TRUE') THEN
            Error_SYS.Item_Update(lu_name_, 'DEMAND_ORDER_REF2');
         END IF;
      END IF;
   END IF;
   
   IF NOT(oldrec_.demand_code = 'CQ' AND b2b_quotation_order_ = 'TRUE') THEN
      IF (indrec_.demand_order_ref3) THEN
         Error_SYS.Item_Update(lu_name_, 'DEMAND_ORDER_REF3');
      END IF;
      IF (indrec_.demand_order_ref4) THEN
         Error_SYS.Item_Update(lu_name_, 'DEMAND_ORDER_REF4');
      END IF;
   END IF;

   IF ((indrec_.demand_code) AND (oldrec_.supply_code != 'MRO')) THEN
      IF NOT(oldrec_.demand_code = 'CQ' AND b2b_quotation_order_ = 'TRUE') THEN
         Error_SYS.Item_Update(lu_name_, 'DEMAND_CODE');
      END IF;
   END IF;

   IF(indrec_.vendor_no) THEN
      -- If order has been released then supplier may be changed only if supply code is (was) Not Decided...
      IF ((header_rowstate_ = 'Planned') OR
          ((oldrec_.supply_code = 'ND' OR newrec_.supply_code = 'IO' OR newrec_.supply_code = 'NO') AND (header_rowstate_ NOT IN ('Delivered', 'Invoiced', 'Cancelled')))) THEN
         IF (newrec_.vendor_no IS NOT NULL) THEN
            Exist_Vendor_No___(newrec_.vendor_no, newrec_.contract, newrec_.purchase_part_no, newrec_.rental);
         END IF;
      ELSE
         IF ((newrec_.vendor_no IS NOT NULL) OR ((newrec_.vendor_no IS NULL) AND (oldrec_.vendor_no IS NOT NULL))) THEN
            IF (oldrec_.supply_code = newrec_.supply_code) THEN
               Error_SYS.Record_General(lu_name_, 'CANNOTUPDSUPP: Supplier can be changed only when order has not been Released.');
            END IF;
         END IF;
      END IF;
   END IF;

   IF (newrec_.activity_seq IS NOT NULL) THEN
      $IF (Component_Proj_SYS.INSTALLED) $THEN
         NULL;
      $ELSE
         Error_SYS.Record_General(lu_name_, 'ACTIVITYNOTINST: Activity Sequence may not be set since Activity is not installed.');
      $END
   END IF;
   
   $IF (Component_Deford_SYS.INSTALLED) $THEN
      IF (Def_Contract_Order_Item_API.CO_Line_On_Defense_Contract(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no)) THEN
         Def_Contract_Order_Item_API.Validate_Co_Line_Changes(oldrec_,newrec_,server_data_change_);
      END IF;
   $END
   
   super(oldrec_, newrec_, indrec_, attr_);
   
   IF (indrec_.configuration_id) THEN
      Client_SYS.Add_To_Attr('SENT_CONFIGURATION', 'TRUE', attr_);
   END IF;
   
   IF (indrec_.ship_addr_no) THEN
      newrec_.end_customer_id := Customer_Info_Address_API.Get_End_Customer_Id(newrec_.deliver_to_customer_no, newrec_.ship_addr_no);
   END IF;

   IF po_charged_comp_change_ = 'TRUE' THEN
      Client_SYS.Add_To_Attr('PO_CHARGED_COMP_CHANGE', po_charged_comp_change_, attr_);
   END IF;

   IF ((NVL(newrec_.route_id, ' ') != NVL(oldrec_.route_id, ' '))  OR (NVL(newrec_.ship_via_code, ' ') != NVL(oldrec_.ship_via_code, ' ')) OR
      (newrec_.delivery_leadtime != oldrec_.delivery_leadtime) OR (NVL(oldrec_.ext_transport_calendar_id, Database_SYS.string_null_) != NVL(oldrec_.ext_transport_calendar_id, Database_SYS.string_null_))
       OR (newrec_.picking_leadtime != oldrec_.picking_leadtime) OR (indrec_.target_date OR indrec_.supplier_ship_via_transit)) THEN
      delivery_date_changed_ := TRUE;
   END IF;

   -- Check if price source is refreshed, i.e., if price source has been updated with same value as in old record.
   -- Used for being able to trigger fetching of correct default prices and discounts.
   IF ((indrec_.price_source) AND (oldrec_.price_source = newrec_.price_source)) THEN
      -- buy_qty_due has been refreshed.
      Client_SYS.Add_To_Attr('PRICE_SOURCE_REFRESHED', 1, attr_);
   END IF;

   IF indrec_.planned_delivery_date THEN
      make_reservation_      := 'TRUE';
      delivery_date_changed_ := TRUE;
      planned_date_changed_  := TRUE;
   END IF;

   IF indrec_.wanted_delivery_date THEN
      delivery_date_changed_ := TRUE;
      make_reservation_      := 'TRUE';
   END IF;

   IF indrec_.tax_code THEN
      refresh_tax_code_        := TRUE;      
   END IF;

   IF (indrec_.tax_liability  AND oldrec_.tax_liability != newrec_.tax_liability) OR
      (indrec_.ship_addr_no AND oldrec_.ship_addr_no != newrec_.ship_addr_no)  OR
      (newrec_.addr_flag = 'N' AND oldrec_.addr_flag = 'Y') OR
      (newrec_.addr_flag = 'Y' AND oldrec_.addr_flag = 'N' and oldrec_.default_addr_flag = 'N') OR --this added to handle copy address from header to non-default lines
      (newrec_.default_addr_flag = 'Y' AND oldrec_.default_addr_flag = 'N') THEN
      refresh_tax_code_ := TRUE;
   END IF;

   IF (indrec_.delivery_type ) THEN
      refresh_tax_code_      := TRUE;
   END IF;

   IF ((oldrec_.buy_qty_due != newrec_.buy_qty_due) AND (oldrec_.revised_qty_due = newrec_.revised_qty_due)) THEN
      calc_revise_qty_due_ := newrec_.buy_qty_due * newrec_.conv_factor / newrec_.inverted_conv_factor;
      -- calculated value for calc_revise_qty_due_ could exceed 38 decimal points sometimes. Therefor it is
      -- rounded for 38 because maximum guaranteed precision for Oracle numbers is 38.
      IF ((length(calc_revise_qty_due_)-INSTR(calc_revise_qty_due_,'.')) > 38) THEN
         calc_revise_qty_due_ := ROUND(calc_revise_qty_due_, 38);
      END IF;
      newrec_.revised_qty_due := calc_revise_qty_due_;
   END IF;
   
   -- Recalculate buy_qty_due and revised_qty_due because it may have rounding issues with large decimal values for qty_per_assembly
   IF (newrec_.line_item_no > 0 AND newrec_.qty_per_assembly != oldrec_.qty_per_assembly) THEN
      pkg_buy_qty_due_        := Get_Buy_Qty_Due(newrec_.order_no, newrec_.line_no, newrec_.rel_no, -1);
      newrec_.buy_qty_due     := pkg_buy_qty_due_* newrec_.qty_per_assembly;
      newrec_.revised_qty_due := newrec_.buy_qty_due * newrec_.conv_factor / newrec_.inverted_conv_factor;
   END IF;

   IF ((newrec_.part_ownership = 'SUPPLIER LOANED') AND
       (NVL(Get_Owner_For_Part_Ownership(newrec_.order_no,
                                        newrec_.line_no,
                                        newrec_.rel_no,
                                        newrec_.line_item_no,
                                        newrec_.part_ownership), Database_SYS.string_null_) = Database_SYS.string_null_)) THEN
       Error_SYS.Record_General(lu_name_, 'NULLOWNERFORSUPLOANED: The customer must be connected to a supplier in order to return :P1 stock', Part_Ownership_API.Decode(newrec_.part_ownership));
   END IF;

   IF newrec_.demand_code = 'PO' THEN
      IF (oldrec_.buy_qty_due != newrec_.buy_qty_due) AND (server_data_change_ = 0) THEN
         IF Is_Purch_Comp_Part_Line___(newrec_) THEN
            Error_Sys.Record_General(lu_name_, 'POCOMPLINCONN: Quantity cannot be changed since this order line is connected to a purchase order :P1/:P2/:P3 which having component lines.', newrec_.demand_order_ref1, newrec_.demand_order_ref2, newrec_.demand_order_ref3);
         ELSE
            Client_SYS.Add_Info(lu_name_, 'CONNECTED_TO_PO: This order is connected to purchase order :P1/:P2/:P3 - which will not be updated automatically.', newrec_.demand_order_ref1, newrec_.demand_order_ref2, newrec_.demand_order_ref3);
         END IF;
      END IF;
   END IF;

   IF ((oldrec_.revised_qty_due > newrec_.revised_qty_due) AND (oldrec_.qty_shipdiff != 0)) THEN
      newrec_.qty_shipdiff := newrec_.qty_shipped + newrec_.qty_picked - newrec_.revised_qty_due;
   END IF;

   -- Avoid resetting the manually updated Target Date with Wanted Delivery Date and
   -- avoid setting target date earlier than wanted delivery date and
   IF ((oldrec_.wanted_delivery_date != newrec_.wanted_delivery_date) AND (oldrec_.target_date = newrec_.target_date)) THEN
      newrec_.target_date := newrec_.wanted_delivery_date;
   END IF;

   IF (newrec_.blocked_for_invoicing IS NULL) THEN
      newrec_.blocked_for_invoicing := 'FALSE';
   END IF;

   IF (newrec_.price_source_net_price IS NULL) THEN
      newrec_.price_source_net_price := 'FALSE';
   END IF;

   IF (newrec_.blocked_for_invoicing = 'TRUE') THEN
      Validate_Block_For_Invoic___(newrec_);
   END IF;

   IF (newrec_.staged_billing = 'STAGED BILLING' AND newrec_.consignment_stock = 'CONSIGNMENT STOCK') THEN
      Error_SYS.Record_General(lu_name_, 'STAGE_BILL_CON_STOCK: Staged Billing cannot be used together with Customer Consignment Stock.');
   END IF;

   sales_part_rec_ := Sales_Part_API.Get(newrec_.contract, newrec_.catalog_no);
   
   IF (newrec_.price_unit_meas IS NULL) THEN
      newrec_.price_unit_meas := sales_part_rec_.price_unit_meas;
   END IF;

   IF (newrec_.input_unit_meas IS NOT NULL) AND (newrec_.input_qty IS NULL) THEN
      Error_SYS.Record_General(lu_name_, 'INPUTQTYNEEDED: Input quantity must be entered when Input UoM has a value');
   END IF;

   Check_Demand_Code___(newrec_.demand_code, order_rec_.confirm_deliveries, newrec_.consignment_stock);

   IF (newrec_.rental = Fnd_Boolean_Api.DB_FALSE AND NVL(newrec_.demand_code, Database_SYS.string_null_) = Order_Supply_Type_API.DB_REPLACEMENT_CUSTOMER_ORDER) THEN
      Error_SYS.Record_General(lu_name_, 'NONRENTALREPLACEMENT: The demand code :P1 cannot be used for a non-rental customer order line.');
   END IF;

   IF (newrec_.supply_code != oldrec_.supply_code) OR
       (newrec_.ship_addr_no != oldrec_.ship_addr_no) OR
       (NVL(newrec_.vendor_no, ' ') != NVL(oldrec_.vendor_no, ' ')) THEN
      IF (newrec_.supply_code IN ('PT', 'PD', 'IPT', 'IPD')) THEN
         -- Validate the category for the specified vendor
         Validate_Vendor_Category___(newrec_.vendor_no, newrec_.supply_code);
      ELSE
         newrec_.vendor_no                := NULL;
         newrec_.supply_site              := NULL;
         newrec_.supply_site_reserve_type := 'NOTALLOWED';
      END IF;

      -- type into Invent Order.
      IF ( NOT (newrec_.supply_code = 'IO' AND oldrec_.supply_code IN ('IPT','PT', 'SO', 'DOP')) AND NOT (oldrec_.supply_code = 'IO' AND newrec_.supply_code IN ('PT', 'SO', 'DOP'))) THEN
         -- Retrieve new supply chain defaults
         temp_newrec_ := newrec_;
         Get_Supply_Chain_Defaults___(newrec_, indrec_, oldrec_ );
         IF (oldrec_.supply_code = 'IO' AND temp_newrec_.supply_code = 'IPT') THEN
            temp_newrec_.supplier_ship_via_transit      := newrec_.supplier_ship_via_transit;
            temp_newrec_.supplier_ship_via_transit_desc := newrec_.supplier_ship_via_transit_desc;
            newrec_                                     := temp_newrec_; 
         END IF; 
      END IF;
      -- recalculate all dates since necessary parameter have been changed.
      delivery_date_changed_ := TRUE;

      IF (newrec_.supply_code IN ('IPT', 'IPD')) THEN
         IF (newrec_.supply_code != oldrec_.supply_code) THEN
            -- fetching the supply site part no.
            newrec_.supply_site_part_no := Sales_Part_API.Get_Supply_Site_Part_No__(newrec_.supply_site, newrec_.contract, newrec_.catalog_no, newrec_.vendor_no );
         END IF;
         -- Do not fetch the supply_site_reserve_type_ if the customer order is not in Planned state
         IF (header_rowstate_ = 'Planned') THEN
            -- Initialize the supply site attribute for internal suppliers
            newrec_.supply_site := Get_Vendor_Contract__(newrec_.vendor_no, NULL, NULL, NULL, newrec_.rental);

            IF (newrec_.supply_site_reserve_type = 'NOTALLOWED') THEN
               -- get default supply_site_reserve_type_
               -- check if the inventory part exists on the supply_site (is the supply_site in the same database)
               IF (Inventory_Part_API.Part_Exist(newrec_.supply_site, NVL(newrec_.part_no,newrec_.purchase_part_no)) = 1) THEN
                  -- check if a security connection exists between the CO/PO Site (Demand site) and the Supply Site
                  IF (Site_To_Site_Reserve_Setup_API.Connection_Allowed(newrec_.supply_site, newrec_.contract) = 1) THEN
                     newrec_.supply_site_reserve_type := Site_To_Site_Reserve_Setup_API.Get_Supply_Site_Reserve_Db(newrec_.supply_site, newrec_.contract);
                  END IF;
               END IF;
            END IF;
         END IF;
      ELSE
         newrec_.supply_site_part_no := NULL;
         newrec_.supply_site              := NULL;
         newrec_.supply_site_reserve_type := 'NOTALLOWED';
      END IF;
   END IF;
   IF ((newrec_.shipment_type != oldrec_.shipment_type) AND (newrec_.shipment_creation IS NOT NULL) AND (NOT indrec_.shipment_creation)) THEN
      newrec_.shipment_creation := Shipment_Creation_API.Encode(Shipment_Type_API.Get_Shipment_Creation_Co(newrec_.shipment_type));
   END IF;
   IF ((newrec_.freight_map_id IS NULL AND newrec_.zone_id IS NULL)
       OR ((newrec_.addr_flag = 'N') AND (oldrec_.addr_flag = 'Y'))) THEN
      IF (newrec_.addr_flag = 'N') THEN
         Freight_Zone_Util_API.Fetch_Zone_For_Cust_Addr(newrec_.freight_map_id,
                                                        newrec_.zone_id,
                                                        newrec_.customer_no,
                                                        newrec_.ship_addr_no,
                                                        newrec_.contract,
                                                        newrec_.ship_via_code);
      ELSE
         sing_occ_addr_ := Cust_Order_Line_Address_API.Get_Co_Line_Addr(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
         Freight_Zone_Util_API.Fetch_Zone_For_Addr_Details(newrec_.freight_map_id,
                                                           newrec_.zone_id,
                                                           zone_info_exist_,
                                                           newrec_.contract,
                                                           newrec_.ship_via_code,
                                                           sing_occ_addr_.zip_code,
                                                           sing_occ_addr_.city,
                                                           sing_occ_addr_.county,
                                                           sing_occ_addr_.state,
                                                           sing_occ_addr_.country_code);
      END IF;
   END IF;
   IF (newrec_.freight_map_id IS NOT NULL) THEN
      IF ((newrec_.supply_code IN ('PD', 'IPD') AND newrec_.vendor_no IS NOT NULL)) THEN
         newrec_.freight_price_list_no := Freight_Price_List_Direct_API.Get_Active_Freight_List_No(newrec_.contract, newrec_.ship_via_code, newrec_.freight_map_id, newrec_.forward_agent_id, order_rec_.use_price_incl_tax, newrec_.vendor_no);
      ELSE
         newrec_.freight_price_list_no := Freight_Price_List_API.Get_Active_Freight_List_No(newrec_.contract, newrec_.ship_via_code, newrec_.freight_map_id, newrec_.forward_agent_id, order_rec_.use_price_incl_tax);
      END IF;
   ELSE
      newrec_.freight_price_list_no := NULL;
   END IF;

   IF (newrec_.supply_code IN ('IPT', 'IPD')) AND (newrec_.supply_site_reserve_type != 'NOTALLOWED') AND
       ((Site_To_Site_Reserve_Setup_API.Connection_Allowed(newrec_.supply_site, newrec_.contract) = 0) OR
       (Site_To_Site_Reserve_Setup_API.Get_Supply_Site_Reserve_Db(newrec_.supply_site, newrec_.contract) = Supply_Site_Reserve_Type_API.DB_NOT_ALLOWED)) THEN
      IF (newrec_.supply_site_reserve_type != oldrec_.supply_site_reserve_type) THEN
         Error_Sys.Record_General(lu_name_, 'CONN_NOT_ALLOWED: No Site to Site Reservation allowed between demand site :P1 and supply site :P2',newrec_.contract,newrec_.supply_site);
      ELSE
         Error_Sys.Record_General(lu_name_, 'SET_NOT_ALLOWED: Set the supply site reservation type to Not Allowed before releasing the customer order.'); 
      END IF;      
   END IF;

   IF ((order_rec_.internal_po_no IS NOT NULL) AND (order_rec_.internal_po_no = NVL(newrec_.demand_order_ref1, ' ')) AND (newrec_.discount < 0)) THEN
      Error_SYS.Record_General(lu_name_, 'IPO_NEG_DISC: Negative discount cannot be handled when the customer order originates from an internal purchase order. Check valid price list(s) and/or Customer Agreement(s).');
   END IF;

   -- date parameters have been changed. Recalculate from wanted delivery date if not planned delivery date hasn't been changed.
   IF (delivery_date_changed_ AND NOT planned_date_changed_) THEN         
      newrec_.planned_delivery_date := newrec_.target_date;      
   END IF;

   --if changing supplier and/or reservation type, check first that no reservations exist
   --(changing from MANUAL/INSTANT/SOURCED to NOTALLOWED is not permitted...).
   IF ((NVL(newrec_.vendor_no, ' ') != NVL(oldrec_.vendor_no, ' ')) OR
       (newrec_.supply_site_reserve_type = 'NOTALLOWED' AND oldrec_.supply_site_reserve_type != 'NOTALLOWED')) THEN
      IF (Co_Supply_Site_Reservation_API.Get_Qty_Reserved(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no) > 0) THEN
         Error_SYS.Record_General(lu_name_ , 'REMSUPPRES: You cannot change supplier or reservation type since supply site reservation exists.');
      END IF;
   END IF;

   IF (NVL(newrec_.supply_code, ' ') != NVL(oldrec_.supply_code, ' ') AND
       oldrec_.supply_code != 'ND' AND header_rowstate_ = 'Planned' ) THEN
      IF (Co_Supply_Site_Reservation_API.Get_Qty_Reserved(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no) > 0) THEN
         Error_SYS.Record_General(lu_name_ , 'SUPRESCHGEXS: You cannot change supply code since supply site reservation exists.');
      END IF;
   END IF;

   -- IF condition code or qty was changed, and this is not a configured part then retrive new cost
   -- (For configured parts cost should be calculated using the interim order functionality)
   IF (oldrec_.buy_qty_due != newrec_.buy_qty_due AND oldrec_.revised_qty_due = newrec_.revised_qty_due) THEN
      revised_qty_due_        := newrec_.buy_qty_due * newrec_.conv_factor / newrec_.inverted_conv_factor;
   END IF;
   inv_part_cost_level_db_ := Inventory_Part_API.Get_Invent_Part_Cost_Level_Db(newrec_.contract,newrec_.part_no);

   -- Calculate cost details if supply code is invent order and the part cost level in "Cost Per Configuration" when order is in planned state.
   IF ((oldrec_.supply_code != newrec_.supply_code OR oldrec_.configuration_id != newrec_.configuration_id ) AND
       ((newrec_.supply_code = 'IO') AND (inv_part_cost_level_db_ = 'COST PER CONFIGURATION')) )THEN
      Order_Config_Util_API.Configuration_Exist(NVL(newrec_.part_no, newrec_.catalog_no), newrec_.configuration_id);
      calculate_cost_for_config_ := TRUE;
   END IF;

   -- Modified if condition to calculate cost of configured part after set configuration and source form Invent Order.
   IF (revised_qty_due_ > newrec_.qty_shipped) AND (newrec_.rowstate != 'PartiallyDelivered') AND
      (((newrec_.condition_code != NVL(oldrec_.condition_code, 'NOT_NULL')) AND (inv_part_cost_level_db_ = 'COST PER CONDITION')) OR
       ((inv_part_cost_level_db_ != 'COST PER CONFIGURATION') AND (newrec_.buy_qty_due != oldrec_.buy_qty_due))) OR ( calculate_cost_for_config_ ) THEN

      -- Modified if condition to calculate cost of configured part after set configuration and source form Invent Order.
      IF (revised_qty_due_ IS NOT NULL AND (newrec_.part_ownership NOT IN ('CUSTOMER OWNED', 'SUPPLIER LOANED'))) OR ( calculate_cost_for_config_ ) THEN
         newrec_.cost := Sales_Cost_Util_API.Get_Cost_Incl_Sales_Overhead(newrec_.contract,
                                                                          newrec_.part_no,
                                                                          NVL(newrec_.configuration_id,'*'),
                                                                          newrec_.condition_code,
                                                                          revised_qty_due_,
                                                                          newrec_.charged_item,
                                                                          newrec_.supply_code,
                                                                          newrec_.customer_no,
                                                                          newrec_.part_ownership);
         Client_SYS.Set_Item_Value('COST', newrec_.cost, attr_);
      END IF;
   END IF;

   IF ((newrec_.condition_code != oldrec_.condition_code) AND (newrec_.demand_code = 'DO')) THEN
      Error_Sys.Record_General(lu_name_, 'DO_CONDITION_CODE: Condition code cannot be changed when the demand code is DO.');
   END IF;

   IF (indrec_.part_ownership) THEN
      IF (order_rec_.project_id IS NOT NULL) AND (newrec_.part_ownership = 'SUPPLIER LOANED') THEN
         Error_Sys.Record_General(lu_name_, 'PROJ_OWNERSHIP: Ownership can not be :P1 when the customer order is connected to a project.',Part_Ownership_API.Decode(newrec_.part_ownership));
      END IF;
      IF (newrec_.supply_code = 'IO') AND (newrec_.demand_code = 'PO') AND (NVL(newrec_.part_ownership, Database_SYS.string_null_) != NVL(oldrec_.part_ownership, Database_SYS.string_null_)) AND (newrec_.rowstate != 'Released') THEN
         Error_Sys.Record_General(lu_name_, 'COMP_OWNERSHIP: Ownership can be changed only when the customer order line is in the released status.');
      END IF;
   END IF;
   total_sourced_qty_ := Sourced_Cust_Order_Line_API.Get_Total_Sourced_Qty(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);

   IF (newrec_.supply_code != 'DOP') THEN
      newrec_.dop_connection := NULL;
   END IF;

   IF (newrec_.supply_code = 'ND') THEN
      IF delivery_date_changed_ THEN
         -- Delivery date is changed for sourced lines
          IF (total_sourced_qty_ IS NOT NULL) AND (total_sourced_qty_!= 0) THEN
             Client_SYS.Add_Info(lu_name_, 'DATE_CHANGED: This order line is sourced, please, check source lines.');
          END IF;
      END IF;
      IF buy_qty_changed_ THEN
         -- Qty on line is more than the total sourced Qty
          IF (total_sourced_qty_ > newrec_.revised_qty_due) THEN
             Error_SYS.Record_General(lu_name_ , 'SOUQTY_LARGE: This order line is sourced, quantity must be equal to, or larger than, total sourced quantity.');
          END IF;
      END IF;

   ELSIF (newrec_.supply_code = 'DOP') THEN
      IF ((header_rowstate_ != 'Planned') AND (oldrec_.supply_code = newrec_.supply_code) AND (oldrec_.dop_connection != newrec_.dop_connection)) THEN
         Error_SYS.Record_General(lu_name_ , 'AUTDOPNOTALLOWED: It is not possible to change the DOP Connection field for an existing order line when the order is released.');
      END IF;
      IF (newrec_.dop_connection IS NULL) THEN
         newrec_.dop_connection := Dop_Connection_API.Encode(Inventory_Part_API.Get_Dop_Connection(newrec_.contract, newrec_.part_no));
      END IF;
   END IF;

   IF (total_sourced_qty_ IS NOT NULL) AND (total_sourced_qty_ != 0) THEN
      sourcing_flag_ := NVL(Client_SYS.Get_Item_Value('SOURCING_FLAG', attr_), 'FALSE');
      IF (newrec_.originating_rel_no IS NULL) AND (newrec_.originating_line_item_no IS NULL)
        AND (sourcing_flag_ != 'TRUE')THEN
         -- Supply code cannot be changed for co lines which has source lines.
         IF (oldrec_.supply_code != newrec_.supply_code ) THEN
            Error_SYS.Record_General(lu_name_ , 'SOUSUP_LINE: This order line is sourced, please remove source lines to change supply code.');
         END IF;
      END IF;
   END IF;

   IF (indrec_.owning_customer_no) THEN
      IF (newrec_.owning_customer_no IS NOT NULL) AND (newrec_.owning_customer_no != order_rec_.customer_no ) THEN
         IF (order_rec_.project_id IS NOT NULL) THEN
            Error_Sys.Record_General(lu_name_, 'PROJ_OWNER: Owner can not be different from :P1 when the customer order is connected to a project.',order_rec_.customer_no);
         END IF;
      END IF;

      IF (newrec_.supply_code = 'IO') AND (newrec_.demand_code = 'PO') AND (NVL(newrec_.owning_customer_no, Database_SYS.string_null_) != NVL(oldrec_.owning_customer_no, Database_SYS.string_null_)) AND (newrec_.rowstate != 'Released') THEN
         Error_Sys.Record_General(lu_name_, 'COMP_OWNER: Owner can be changed only when the customer order line is in the released status.');
      END IF;
   END IF;

   -- IF promised delivery date was set to null the reinitialize the value
   IF (newrec_.promised_delivery_date IS NULL) THEN
      newrec_.promised_delivery_date := newrec_.planned_delivery_date;
   END IF;

   IF (oldrec_.activity_seq IS NOT NULL) AND (newrec_.consignment_stock = 'CONSIGNMENT STOCK') THEN
      Error_Sys.Record_General(lu_name_, 'CSNOTALLOWED: When Customer Order line is project connected, it is not allowed to be a consignment stock delivery');
   END IF;
   inv_flag_ := sales_part_rec_.catalog_type;
   IF (oldrec_.activity_seq IS NOT NULL) AND (newrec_.supply_code != oldrec_.supply_code) THEN
      IF (inv_flag_ = 'INV') THEN
         IF (oldrec_.supply_code = 'PJD') AND (newrec_.demand_code != 'PI') THEN
            Error_SYS.Record_General(lu_name_, 'PROJECT_DELIVERABLES: This Customer Order line originates from Project Deliverables. Therefore it is not allowed to change the supply code on this.');
         END IF;
      END IF;
   END IF;

   IF (newrec_.configuration_id != '*' AND newrec_.revised_qty_due != oldrec_.revised_qty_due) THEN
      Client_SYS.Add_Info(lu_name_, 'CONFIGQTY: Quantity change may affect configuration. Edit configuration to verify characteristics.');
   END IF;

   IF (newrec_.configuration_id != '*' AND Nvl(newrec_.supply_site, '*') != Nvl(oldrec_.supply_site, '*')) THEN
      Client_SYS.Add_Info(lu_name_, 'CONFIGSUPPSITE: Supply site change may affect configuration. Edit configuration to verify characteristics.');
   END IF;

   IF (newrec_.country_code IS NULL)THEN
      IF newrec_.addr_flag = 'Y' THEN
         newrec_.country_code := Cust_Order_Line_Address_API.Get_Country_Code(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      ELSE
         newrec_.country_code := Cust_Ord_Customer_Address_API.Get_Country_Code(newrec_.customer_no, newrec_.ship_addr_no);
      END IF;
   END IF;
   
   IF (newrec_.configuration_id != '*' AND (newrec_.ship_addr_no != oldrec_.ship_addr_no OR
       newrec_.addr_flag != oldrec_.addr_flag)) THEN
      IF Nvl(oldrec_.country_code, '*') != Nvl(newrec_.country_code, '*') THEN
         Client_SYS.Add_Info(lu_name_, 'CONFIGDELCTRY: Delivery country change may affect configuration. Edit configuration to verify characteristics.');
      END IF;
   END IF;

   IF (NVL(oldrec_.activity_seq, -9999) != NVL(newrec_.activity_seq, -9999)) THEN
      IF (newrec_.activity_seq IS NULL)  THEN
         Validate_Proj_Disconnect___(newrec_);
      ELSE
         Validate_Proj_Connect___(newrec_.project_id,
                                  newrec_.demand_code,
                                  newrec_.supply_code,
                                  newrec_.order_no,
                                  newrec_.contract,
                                  newrec_.rowstate,
                                  newrec_.consignment_stock,
                                  newrec_.qty_on_order,
                                  newrec_.activity_seq,
                                  oldrec_.activity_seq,
                                  newrec_.planned_ship_date,
                                  newrec_.catalog_no,
                                  FALSE,
                                  newrec_.catalog_type);
      END IF;
   END IF;

   IF (newrec_.provisional_price IS NULL) THEN
      newrec_.provisional_price := 'FALSE';
   END IF;

   IF (newrec_.receiving_advice_type = 'USE_CUSTOMER_DEFAULT') THEN
      Error_SYS.Record_General(lu_name_, 'INVALIDRECADVTYPE: Receiving advice type ":P1" can not be used in customer order line.', Receiving_Advice_Type_API.Decode(newrec_.receiving_advice_type));
   END IF;

   IF (newrec_.qty_assigned < 0) THEN
      Error_SYS.Record_General(lu_name_,'COASSQTYNOTNEG: The quantity reserved may not be negative.');
   END IF;

   Iso_Unit_API.Exist(newrec_.price_unit_meas);

   IF (newrec_.rental = Fnd_Boolean_API.DB_FALSE) THEN
      sales_price_type_db_ := Sales_Price_Type_API.DB_SALES_PRICES;
   ELSE
      sales_price_type_db_ := Sales_Price_Type_API.DB_RENTAL_PRICES;
   END IF;

   site_discom_info_rec_   := Site_Discom_Info_API.Get(newrec_.contract);
   IF (oldrec_.wanted_delivery_date != newrec_.wanted_delivery_date AND newrec_.supply_code != 'SEO') THEN
      update_price_effective_date_ := Client_SYS.Get_Item_Value('UPDATE_PRICE_EFFECTIVE_DATE', attr_);
      IF (site_discom_info_rec_.price_effective_date = 'TRUE') AND update_price_effective_date_ = 'TRUE' AND (newrec_.free_of_charge = Fnd_Boolean_API.DB_FALSE) THEN
         newrec_.price_effectivity_date := newrec_.wanted_delivery_date;

         Sales_Price_List_API.Get_Valid_Price_List(customer_level_db_,        customer_level_id_,              newrec_.price_list_no,
                                                   order_rec_.contract,       newrec_.catalog_no,              order_rec_.customer_no,
                                                   order_rec_.currency_code,  newrec_.price_effectivity_date,  NULL ,
                                                   sales_price_type_db_);

         IF customer_level_db_ IS NOT NULL THEN
            newrec_.customer_level := customer_level_db_;
         END IF;
         IF customer_level_id_ IS NOT NULL THEN
            newrec_.customer_level_id := customer_level_id_;
         END IF;

         -- For rental lines, the rental  chargable days retreived from the rental atrributes
         -- because rental object is updated after customer order line.
         rental_chargable_days_ := NULL;
         IF (newrec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
            rental_chargable_days_ := Get_Latest_Rent_Charge_Days___(attr_, newrec_);
         END IF;

         IF ((newrec_.buy_qty_due IS NOT NULL) AND (newrec_.rental = Fnd_Boolean_API.DB_FALSE OR
                                                    (newrec_.rental = Fnd_Boolean_API.DB_TRUE AND rental_chargable_days_ IS NOT NULL))) THEN
            Customer_Order_Pricing_API.Get_Order_Line_Price_Info(sale_unit_price_,          unit_price_incl_tax_,           base_sale_unit_price_,        base_unit_price_incl_tax_,
                                                                 newrec_.currency_rate,     discount_,                      price_source_,                newrec_.price_source_id,
                                                                 newrec_.provisional_price, newrec_.price_source_net_price, newrec_.rebate_builder,       newrec_.part_level,
                                                                 newrec_.part_level_id,     newrec_.customer_level,         newrec_.customer_level_id,    newrec_.order_no,
                                                                 newrec_.catalog_no,        newrec_.buy_qty_due,            newrec_.price_list_no,        newrec_.price_effectivity_date,
                                                                 newrec_.condition_code,    order_rec_.use_price_incl_tax,  rental_chargable_days_);

            newrec_.price_source := Pricing_Source_API.Encode(price_source_);
            IF (newrec_.price_freeze = 'FREE') THEN
               newrec_.sale_unit_price := sale_unit_price_;
               newrec_.unit_price_incl_tax := unit_price_incl_tax_;
               newrec_.base_sale_unit_price := base_sale_unit_price_;
               newrec_.base_unit_price_incl_tax := base_unit_price_incl_tax_;
            END IF;
            IF NOT(newrec_.price_freeze = 'FROZEN' AND site_discom_info_rec_.discount_freeze = 'TRUE') THEN
               newrec_.discount := discount_;
            END IF;
            IF (order_rec_.use_price_incl_tax = 'TRUE') THEN
               newrec_.part_price   := newrec_.sale_unit_price;
            ELSE
               newrec_.part_price   := newrec_.unit_price_incl_tax;
         END IF;
            Calculate_Prices(newrec_);                 
         END IF;

         IF (Cust_Order_Line_Discount_API.Check_Manual_Rows(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no)) THEN
            newrec_.discount := Customer_Order_Line_API.Get_Discount(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
         END IF;
         IF (newrec_.configuration_id != '*') THEN
            Config_Char_Price_API.Get_Calculated_Char_Prices (newrec_.char_price, newrec_.calc_char_price, newrec_.configured_line_price_id,
                                                              newrec_.part_no, newrec_.price_list_no, newrec_.configuration_id, newrec_.price_effectivity_date);
         END IF;
      END IF;
   END IF;

   IF (newrec_.picking_leadtime != trunc(newrec_.picking_leadtime)) OR (newrec_.picking_leadtime < 0) THEN
      Error_SYS.Item_General(lu_name_, 'PICKING_LEADTIME', 'PICKVALUEINTEGER: [:NAME] must be an integer. Negative values not allowed.');
   END IF;

   IF (qty_refreshed_) THEN
      Client_SYS.Add_To_Attr('QTY_REFRESHED', 1, attr_);
   END IF;

   IF (capability_check_source_flag_ = 'TRUE') THEN
      -- add the flag to the attr string again so we can use it a check inside Check_Before_Update___
      Client_SYS.Add_To_Attr('CAPABILITY_CHECK_SOURCE_FLAG', capability_check_source_flag_, attr_);
   END IF;

   IF (unpeg_ipd_flag_ = 'TRUE') THEN
      -- add the flag to the attr string again so we can use it a check inside Check_Before_Update___
      Client_SYS.Set_Item_Value('UNPEG_IPD_FLAG', unpeg_ipd_flag_, attr_);
   END IF;
   
   IF (newrec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
      IF (newrec_.tax_code != oldrec_.tax_code) THEN
      $IF (Component_Rental_SYS.INSTALLED) $THEN
         IF (Rental_Transaction_API.Rental_Transactions_Exist(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, Rental_Type_API.DB_CUSTOMER_ORDER)) THEN
            Error_SYS.Record_General(lu_name_, 'RENTTRANSEXIST: Tax code cannot be changed when rental transactions exist.');
         END IF;
      $ELSE
         Error_SYS.Component_Not_Exist('RENTAL');
      $END
      END IF;
      IF (newrec_.sale_unit_price != oldrec_.sale_unit_price) THEN
         IF (Rental_Period_Exists(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no)) THEN
            Error_SYS.Record_General(lu_name_, 'RENTEVENTSEXIST: It is not possible to edit the price as rental events exist.');
         END IF;
      END IF;
   ELSE
      IF (newrec_.part_ownership = Part_Ownership_API.DB_COMPANY_RENTAL_ASSET) AND (newrec_.supply_code NOT IN ('IO', 'PI')) THEN
         Error_SYS.Record_General(lu_name_,'INVALIDSUPPLYPARTOWN: Ownership :P1 is not allowed for this supply code.', Part_Ownership_API.Decode(newrec_.part_ownership));
      END IF;
   END IF;

   IF (newrec_.default_addr_flag IS NULL) THEN
      default_addr_flag_ := oldrec_.default_addr_flag;
   ELSE
      default_addr_flag_ := newrec_.default_addr_flag;
   END IF;
   
   IF ((default_addr_flag_ = 'N') AND (newrec_.addr_flag = 'N') AND (NVL(oldrec_.ship_addr_no, ' ') != NVL(newrec_.ship_addr_no, ' '))) THEN
      IF (NVL(newrec_.demand_code, Database_Sys.string_null_) != 'IPD') THEN
         IF (order_rec_.customer_no_pay IS NOT NULL) THEN
            customer_no_ := order_rec_.customer_no_pay;
            addr_no_     := order_rec_.customer_no_pay_addr_no;
         ELSE
            customer_no_ := order_rec_.customer_no;
            addr_no_     := order_rec_.bill_addr_no;         
         END IF;            
         newrec_.tax_id_no  := Customer_Document_Tax_Info_API.Get_Vat_No_Db(customer_no_,
                                                                         addr_no_,
                                                                         company_,
                                                                         order_rec_.supply_country,
                                                                         newrec_.country_code);
         IF (newrec_.tax_id_no IS NOT NULL) THEN
            newrec_.tax_id_validated_date := Tax_Handling_Order_Util_API.Get_Tax_Id_Validated_Date(order_rec_.customer_no_pay,
                                                                                                   order_rec_.customer_no_pay_addr_no,
                                                                                                   order_rec_.customer_no,
                                                                                                   order_rec_.bill_addr_no,
                                                                                                   company_,
                                                                                                   order_rec_.supply_country,
                                                                                                   newrec_.country_code);
         END IF;
      END IF;
   END IF;
   
   IF (NVL(newrec_.demand_code, Database_Sys.string_null_) != 'IPD') AND (newrec_.end_customer_id IS NOT NULL) THEN
      -- This was written for Intrastat purpose.
      IF Customer_Info_API.Get_Country_Db(NVL(order_rec_.customer_no_pay, order_rec_.customer_no)) != Customer_Info_API.Get_Country_Db(newrec_.end_customer_id) THEN
         newrec_.tax_id_no  := Customer_Document_Tax_Info_API.Get_Vat_No_Db(newrec_.end_customer_id,
                                                                            Customer_Info_Address_API.Get_Default_Address(newrec_.end_customer_id, 'Document'),
                                                                            company_,
                                                                            order_rec_.supply_country,
                                                                            newrec_.country_code);
      END IF;
   END IF;
   
   IF oldrec_.supply_code != newrec_.supply_code AND newrec_.supply_code NOT IN ('DOP','SO','IPT','IPD') AND
       oldrec_.supply_code IN ('DOP','SO','IPT','IPD') AND oldrec_.latest_release_date IS NOT NULL AND
       (header_rowstate_ = 'Planned') THEN
      old_auto_cc_flag_ := Get_Auto_Capability_Check___(oldrec_.supply_code, oldrec_.contract, oldrec_.supply_site, oldrec_.part_no);
      -- changing from a valid capability check supply code to a non valid capability check supply code means that
      -- we need to remove our ctp_planned flag and cancel the ctp when the part was using automatic capability check
      IF (old_auto_cc_flag_ IN ('RESERVE AND ALLOCATE','ALLOCATE ONLY')) THEN
         $IF (Component_Ordstr_SYS.INSTALLED)$THEN
            IF (newrec_.ctp_planned = 'Y') THEN
               Interim_Ctp_Manager_API.Cancel_Ctp(dummy_, newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no,
                                                 'CUSTOMERORDER', oldrec_.supply_code);
               -- Remove ctp record
               ctp_run_id_ := Interim_Ctp_Critical_Path_API.Get_Ctp_Run_Id('CUSTOMERORDER', newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
               IF (ctp_run_id_ IS NOT NULL AND ctp_run_id_ > 0) THEN
                  Interim_Ctp_Critical_Path_API.Clear_Ctp_Data(ctp_run_id_);
               END IF;
      
               newrec_.ctp_planned           := 'N';
               newrec_.latest_release_date   := NULL;
               -- recalculate all dates
               delivery_date_changed_        := TRUE;
               newrec_.planned_delivery_date := newrec_.wanted_delivery_date;
            END IF;
         $ELSE
            NULL;
         $END
      END IF;
   END IF;
   -- if supply code changes from a valid CTP/CC code to a non valid and latest_release_date have value
   -- then set latest_release_date to null. This covers all 'NEITHER RESERVE NOR ALLOCATE' cases (both manual and automatic cc)
   IF oldrec_.supply_code IN ('SO','DOP','IPT','IPD','IO') AND newrec_.supply_code NOT IN ('SO','DOP','IPT','IPD','IO') AND
       newrec_.latest_release_date IS NOT NULL AND newrec_.ctp_planned = 'N' AND
       (header_rowstate_ = 'Planned') THEN
      newrec_.latest_release_date   := NULL;
      -- recalculate all dates
      delivery_date_changed_        := TRUE;
      newrec_.planned_delivery_date := newrec_.target_date;
   END IF;
   
   interim_ord_id_ := Get_Interim_Order_No(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, newrec_.ctp_planned);

   IF (newrec_.ctp_planned = 'Y' OR newrec_.latest_release_date IS NOT NULL OR (oldrec_.ctp_planned = 'N' AND interim_ord_id_ IS NOT NULL))THEN
   -- handling of special updates that concerns manual Capability Check
      IF (Get_Auto_Capability_Check___(newrec_.supply_code, newrec_.contract, newrec_.supply_site, newrec_.part_no) = 'NO AUTOMATIC CAPABILITY CHECK') THEN
         IF ((delivery_date_changed_) OR
             (oldrec_.planned_due_date != newrec_.planned_due_date) OR
             (oldrec_.planned_ship_date != newrec_.planned_ship_date) OR
             (oldrec_.revised_qty_due != newrec_.revised_qty_due) OR
             (oldrec_.rel_mtrl_planning = 'TRUE' AND newrec_.rel_mtrl_planning = 'FALSE')) AND
             (header_rowstate_ = 'Planned') THEN
            -- inform user that he needs to re-run the Capability Check to get correct delivery date when he changes dates or quantity
            Client_SYS.Add_Info(lu_name_, 'COLCCPLANNED: This Customer Order Line was planned with a Capability Check. Dates will be reset and possible interim orders deleted. You can choose to run the Capability Check again.');
            -- cancel interim orders
            $IF (Component_Ordstr_SYS.INSTALLED) $THEN
               IF (newrec_.ctp_planned = 'Y' OR (oldrec_.ctp_planned = 'N' AND interim_ord_id_ IS NOT NULL)) THEN
                  Add_Info___(insert_package_mode_);   -- cancel ctp seems to do a clear info somewhere
                  Interim_Ctp_Manager_API.Cancel_Ctp(dummy_, newrec_.order_no, newrec_.line_no, newrec_.rel_no,
                                                     newrec_.line_item_no, 'CUSTOMERORDER', oldrec_.supply_code);
                  -- Remove ctp record
                  ctp_run_id_ := Interim_Ctp_Critical_Path_API.Get_Ctp_Run_Id('CUSTOMERORDER', newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
                  IF (ctp_run_id_ IS NOT NULL AND ctp_run_id_ > 0) THEN
                     Interim_Ctp_Critical_Path_API.Clear_Ctp_Data(ctp_run_id_);
                  END IF;
               END IF;
            $END
            -- recalculate all dates
            delivery_date_changed_        := TRUE;
            newrec_.planned_delivery_date := newrec_.wanted_delivery_date;
            -- removed cc/ctp flags and latest release date
            newrec_.ctp_planned           := 'N';
            newrec_.latest_release_date   := NULL;
         END IF;
      END IF;
      IF (oldrec_.part_ownership != newrec_.part_ownership) THEN
         Error_SYS.Record_General(lu_name_, 'OWNCHANGEDFORCC: Ownership may not be changed for a Capability Checked line.');
      END IF;
   ELSIF (newrec_.ctp_planned = 'N') THEN
      IF (oldrec_.revised_qty_due != newrec_.revised_qty_due) THEN
         $IF (Component_Ordstr_SYS.INSTALLED)$THEN
            -- if we for some reason in the future would like to do this even for ctp_planned lines we need to use
            -- method Interim_Ctp_Manager_API.Get_Top_Int_Head_By_Usage instead of Interim_Demand_Head_API.Get_Cust_Ord_Line_Int_Head
            interim_head_id_ := Interim_Demand_Head_API.Get_Cust_Ord_Line_Int_Head(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
            IF interim_head_id_ IS NOT NULL THEN
               Interim_Demand_Head_API.Set_Demand_Qty(interim_head_id_, newrec_.revised_qty_due);
            END IF;
         $ELSE
            NULL;
         $END
      ELSE
         IF (oldrec_.target_date != newrec_.target_date) THEN
            $IF (Component_Ordstr_SYS.INSTALLED)$THEN
               interim_head_id_ := Interim_Demand_Head_API.Get_Cust_Ord_Line_Int_Head(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
               IF interim_head_id_ IS NOT NULL THEN
                  Error_SYS.Record_General(lu_name_, 'INTORDEXISTS: Date may not be changed when an Interim Order exists. Delete the Interim Order to proceed.');
               END IF;
            $ELSE
               NULL;
            $END
         END IF;
      END IF;
   END IF;

   IF ((oldrec_.configuration_id != newrec_.configuration_id) AND (Get_Send_Change_Msg_For_Supp(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no)) = 'TRUE') THEN
      Client_SYS.Set_Item_Value('CHANGE_REQUEST', 'TRUE', attr_);
   END IF;

   Check_Before_Update___(attr_, newrec_, oldrec_, order_rec_.currency_code, header_rowstate_, delivery_date_changed_);

   -- if the line tax_id_no is manually changed; i.e we haven't changed the header tax_id_no and consequentlly
   -- getting the line tax_id_no being updated...then the validated date should be NULL.
   IF (NOT update_on_ordchg_approve_) THEN
      header_tax_id_no_ := order_rec_.tax_id_no;
      IF (NVL(oldrec_.tax_id_no,' ') != NVL(newrec_.tax_id_no,' ')) AND (NVL(newrec_.tax_id_no,' ') != NVL(header_tax_id_no_,' ')) THEN
         newrec_.tax_id_validated_date := NULL;
      END IF;
   END IF;
   
   IF refresh_tax_code_ OR (oldrec_.planned_ship_date != newrec_.planned_ship_date AND newrec_.tax_class_id IS NOT NULL) THEN
      newrec_.tax_liability_type := Tax_Liability_API.Get_Tax_Liability_Type_Db(newrec_.tax_liability, newrec_.country_code);
            
      IF (update_on_ordchg_approve_ = FALSE AND newrec_.demand_code = 'IPD' AND Get_Ship_Addr_No( newrec_.order_No, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no) != newrec_.ship_addr_no) THEN
         Client_SYS.Add_Info(lu_name_, 'NOTAXUPDATE: The tax information will not be updated automatically. Consider reviewing the information.');
      END IF;
      
   END IF;

   IF (NVL(newrec_.ext_transport_calendar_id, Database_Sys.string_null_) != NVL(oldrec_.ext_transport_calendar_id, Database_Sys.string_null_)) THEN
      Work_Time_Calendar_API.Check_Not_Generated(newrec_.ext_transport_calendar_id);
   END IF;

   -- handling of changes that could affect the automatic capability check
   IF (newrec_.ctp_planned = 'Y' OR newrec_.latest_release_date IS NOT NULL) THEN
      automatic_capability_check_ := Get_Auto_Capability_Check___(newrec_.supply_code, newrec_.contract, newrec_.supply_site, newrec_.part_no);
      -- this is a possible automatic capability check
      IF (automatic_capability_check_ IN ('RESERVE AND ALLOCATE','ALLOCATE ONLY','NEITHER RESERVE NOR ALLOCATE')) THEN
         -- if the supply code have been changed and its one of the supply codes valid for capability check, then run the automatic capability check again
         IF (oldrec_.supply_code != newrec_.supply_code AND newrec_.supply_code IN ('DOP','SO','IPT','IPD')) THEN
            Perform_Capability_Check___(newrec_, dummy_boolean_, header_rowstate_, automatic_capability_check_);
         -- if the due date, qty or configuration id have been changed, then run the automatic capability check again
         ELSIF (oldrec_.revised_qty_due != newrec_.revised_qty_due OR
                oldrec_.planned_due_date != newrec_.planned_due_date OR
                oldrec_.configuration_id != newrec_.configuration_id) THEN
            Perform_Capability_Check___(newrec_, dummy_boolean_, header_rowstate_, automatic_capability_check_);
         END IF;
         $IF (Component_Ordstr_SYS.INSTALLED)$THEN 
            IF (App_Context_SYS.Find_Number_Value('CTP_RUN_ID') IS NOT NULL) THEN
               ctp_run_id_ := App_Context_SYS.Get_Number_Value('CTP_RUN_ID');
               IF (ctp_run_id_ > 0 ) THEN
                  Client_SYS.Add_To_Attr('CTP_RUN_ID', ctp_run_id_ , attr_);
                  Client_SYS.Add_To_Attr('IS_DELIVERABLE', Interim_Ctp_Critical_Path_API.Get_Is_Deliverable(ctp_run_id_) , attr_);
               END IF;
               IF (App_Context_SYS.Find_Date_Value('OLD_REQUIRED_DATE') IS NOT NULL) THEN
                  Client_SYS.Add_To_Attr('OLD_REQUIRED_DATE', App_Context_SYS.Get_Date_Value('OLD_REQUIRED_DATE') , attr_);
               END IF;
            END IF;
         $ELSE
            NULL;
         $END
      END IF;
   ELSIF (oldrec_.supply_code != newrec_.supply_code AND newrec_.supply_code IN ('DOP','SO','IPT','IPD') AND
          oldrec_.supply_code NOT IN ('DOP','SO','IPT','IPD')) THEN
      automatic_capability_check_ := Get_Auto_Capability_Check___(newrec_.supply_code, newrec_.contract, newrec_.supply_site, newrec_.part_no);
      IF (automatic_capability_check_ IN ('RESERVE AND ALLOCATE','ALLOCATE ONLY','NEITHER RESERVE NOR ALLOCATE')) THEN
         -- changing from a non valid capability check supply code to a valid one, will start the engine
         Perform_Capability_Check___(newrec_, dummy_boolean_, header_rowstate_, automatic_capability_check_);
      END IF;
   ELSIF (oldrec_.configuration_id != newrec_.configuration_id) AND (newrec_.supply_code IN ('DOP','SO','IPT','IPD')) THEN
      automatic_capability_check_ := Get_Auto_Capability_Check___(newrec_.supply_code, newrec_.contract, newrec_.supply_site, newrec_.part_no);
      IF (automatic_capability_check_ IN ('RESERVE AND ALLOCATE','ALLOCATE ONLY','NEITHER RESERVE NOR ALLOCATE')) THEN
         -- creating the configuration, will start the engine
         Perform_Capability_Check___(newrec_, dummy_boolean_, header_rowstate_, automatic_capability_check_);
      END IF;
   END IF;

   -- check if supply site reservation quantity differs from revised_qty_due...
   IF (newrec_.revised_qty_due != oldrec_.revised_qty_due) THEN
      -- if its a supply chain reservation compare Revised_qty_due and Qty Assigned + Qty Shipped
      -- where the Qty Assigned is fetched from the Co_Supply_Site_Reservation
      supply_chain_reserve_ := Reserve_Customer_Order_API.Is_Supply_Chain_Reservation(newrec_.order_no,
                                 newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, NULL, newrec_.contract,
                                 newrec_.supply_code, newrec_.vendor_no, newrec_.part_no,
                                 newrec_.supply_site_reserve_type, NULL);

      -- if supply chain reservations can be done...
      IF (supply_chain_reserve_ = 1) THEN
         supply_site_qty_ := Co_Supply_Site_Reservation_API.Get_Qty_Reserved(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);

         -- convert the supply site inv uom quantity to demand site inv uom
         supply_site_qty_ := Inventory_Part_API.Get_Site_Converted_Qty(newrec_.supply_site, newrec_.part_no, newrec_.contract, supply_site_qty_, 'ADD');

         -- if quantity is less than reserved quantity on supply site, display error...
         IF (newrec_.revised_qty_due < supply_site_qty_ + newrec_.qty_shipped) AND (supply_site_qty_ + newrec_.qty_shipped != 0) THEN
            Error_SYS.Record_General(lu_name_, 'NOLESSQTYSCR: The quantity may not be less than Qty Reserved on Supply Site. Reduce the reserved quantity via the window for Manual Reservation on Supply Site first.');
         -- if quantity has increased make instant / automatic update of the remaning quantity.
         ELSIF (newrec_.revised_qty_due > oldrec_.revised_qty_due) AND (supply_site_qty_ + newrec_.qty_shipped > 0) THEN
            -- if the reserve type is Instant (not updated to), reservations will be made later in this update...
            IF (newrec_.supply_site_reserve_type = 'INSTANT') AND (oldrec_.supply_site_reserve_type = 'INSTANT') THEN
               make_reservation_ := 'TRUE';
            END IF;
         END IF;
      END IF;
   END IF;

   IF (indrec_.part_ownership) THEN
   -- Set all prices and cost zero if for customer owned and supplier loaned stocks.
      IF ((newrec_.part_ownership IN ('CUSTOMER OWNED', 'SUPPLIER LOANED')))  THEN
         newrec_.part_price               := 0;
         newrec_.sale_unit_price          := 0;
         newrec_.unit_price_incl_tax      := 0;
         newrec_.base_sale_unit_price     := 0;
         newrec_.base_unit_price_incl_tax := 0;
         newrec_.cost                     := 0;
         newrec_.price_source             := 'UNSPECIFIED';
         newrec_.price_source_id          := NULL;
         IF (newrec_.char_price IS NOT NULL) THEN
            newrec_.char_price := 0;
         END IF;
         IF (newrec_.calc_char_price IS NOT NULL) THEN
            newrec_.calc_char_price := 0;
         END IF;
      ELSIF (newrec_.part_ownership = Part_Ownership_API.DB_COMPANY_RENTAL_ASSET) THEN
         newrec_.cost  := 0;
      END IF;
   END IF;

   -- check change of supply code for non-inventory parts
   IF ((((newrec_.supply_code = 'NO') AND ((newrec_.catalog_type != 'KOMP') OR (order_rec_.backorder_option != 'INCOMPLETE PACKAGES NOT ALLOWED')))
       OR (newrec_.supply_code = 'SEO')) AND ((newrec_.planned_due_date <= trunc(Site_API.Get_Site_Date(newrec_.contract))) OR
       Cust_Order_Type_API.Get_Oe_Alloc_Assign_Flag(order_rec_.order_id) = Cust_Ord_Reservation_Type_API.Decode('Y'))) THEN
      IF (oldrec_.supply_code IN ('PT', 'PD', 'IPT', 'IPD', 'ND')) THEN
         newrec_.qty_to_ship := newrec_.revised_qty_due;
      END IF;
   ELSIF (newrec_.supply_code IN ('PT', 'PD', 'IPT', 'IPD', 'ND')) THEN
      IF (oldrec_.supply_code IN ('NO', 'SEO', 'PRJ')) THEN
         newrec_.qty_to_ship := 0;
      END IF;
   END IF;

   IF ((newrec_.supply_code = 'IO') AND (oldrec_.supply_code != 'IO'))THEN
      make_reservation_ := 'TRUE';
   END IF;

   -- if the supply_site_reserve_type have been changed to INSTANT make sure that we make new reservations
   IF ((newrec_.supply_site_reserve_type = 'INSTANT') AND (oldrec_.supply_site_reserve_type != 'INSTANT')
       AND header_rowstate_ = 'Planned') THEN
      make_reservation_ := 'TRUE';
   ELSIF (((NOT Validate_SYS.Is_Equal(oldrec_.supply_code, newrec_.supply_code)) OR (NOT Validate_SYS.Is_Equal(oldrec_.supply_site_reserve_type, newrec_.supply_site_reserve_type))) 
         AND (header_rowstate_ != 'Planned')) THEN
      newrec_.supply_site_reserve_type := 'NOTALLOWED';
   END IF;

   -- Order discount may not be >= 100%
   IF (newrec_.order_discount >= 100) THEN
      Error_SYS.Record_General(lu_name_, 'WRONGDISC: Order discount must be lower than 100%.');
   END IF;

   IF (server_data_change_ != 1) AND
      (newrec_.discount != 0) AND
      (newrec_.discount != oldrec_.discount) THEN
      discount_line_count_ := Cust_Order_Line_Discount_API.Get_Discount_Line_Count( newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      IF (discount_line_count_ > 1) THEN
         Error_SYS.Record_General(lu_name_, 'NODISCOUNTCHNG: Cannot update discount since there are multiple discount lines connected to the customer order line.');
      END IF;
   END IF;

   -- IF supply code is MRO no SM object should be created on delivery of the order line
   IF (newrec_.supply_code = 'MRO') AND (newrec_.create_sm_object_option = 'CREATESMOBJECT') THEN
      Error_SYS.Record_General(lu_name_, 'NOMROSM: Create SM Object is not allowed when supply code is MRO');
   END IF;

   IF (newrec_.demand_code = 'DO') AND (newrec_.create_sm_object_option = 'CREATESMOBJECT') AND
       (newrec_.create_sm_object_option != oldrec_.create_sm_object_option) THEN
      Error_SYS.Record_General(lu_name_, 'NODOSM1: Create SM Object is not allowed when demand code is DO');
   END IF;
   IF (oldrec_.configuration_id != newrec_.configuration_id) THEN
      $IF (Component_Dop_SYS.INSTALLED)$THEN
         Dop_Demand_Cust_Ord_API.Check_Connected_Dop_Status(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
      $ELSE
         NULL;
      $END
   END IF;

   -- If the line is connected to a sales promotion calculation that has resulted in a sales promotion charge, tax code can't be changed.
   IF (Sales_Promotion_Util_API.Check_Promo_Exist_For_Ord_Line(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no)) THEN
      IF ((NVL(newrec_.tax_code, ' ') != NVL(oldrec_.tax_code, ' ')) OR (NVL(newrec_.tax_class_id, ' ') != NVL(oldrec_.tax_class_id, ' ')) OR (NVL(newrec_.tax_calc_structure_id, ' ') != NVL(oldrec_.tax_calc_structure_id, ' '))) THEN
         Error_SYS.Record_General(lu_name_, 'NOALTERTAXCODEPROMO: The tax code or tax class or tax calculation structure cannot be altered unless sales promotion calculations have been cleared.');
      END IF;
      IF (oldrec_.buy_qty_due != newrec_.buy_qty_due OR oldrec_.sale_unit_price != newrec_.sale_unit_price OR oldrec_.base_sale_unit_price != newrec_.base_sale_unit_price) THEN
         Client_SYS.Add_Info(lu_name_, 'SALEPROMOEXISTORD: There are connected sales promotion charge lines existing for the order line :P1 that may have to be recalculated or reviewed.', newrec_.order_no ||'-'||newrec_.line_no ||'-'|| newrec_.rel_no);
      END IF;
   END IF;

   IF (newrec_.part_ownership != 'COMPANY OWNED') THEN
      IF (Customer_Order_Charge_API.Exist_Charge_On_Order_Line(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no) = 1) THEN
         Error_SYS.Record_General(lu_name_, 'WRONGOWNERSHIP: You are not allowed to change the ownership of customer order line :P1-:P2-:P3 to Customer Owned or Supplier Loaned since one or more sales charge(s) are connected.', newrec_.order_no, newrec_.line_no, newrec_.rel_no);
      END IF;
      IF Sales_Promotion_Util_API.Check_Promo_Exist_For_Ord_Line(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no) THEN
         Error_SYS.Record_General(lu_name_, 'WRONGOWNERSHIPFORSP: You are not allowed to change the ownership of customer order line :P1-:P2-:P3 to Customer Owned or Supplier Loaned unless sales promotion calculations are cleared.', newrec_.order_no, newrec_.line_no, newrec_.rel_no);
      END IF;
   END IF;

   IF order_rec_.proposed_prepayment_amount > 0 AND newrec_.tax_calc_structure_id IS NOT NULL THEN
      Error_SYS.Record_General(lu_name_, 'PREPAYINVSTRUCT: Tax calculation structure may not be added when a prepayment based invoice is connected to a customer order.');
   END IF;
   
   -- Attributes that might have changed passed back to the client 
   Client_SYS.Add_To_Attr('VENDOR_NO', newrec_.vendor_no, attr_);
   Client_SYS.Add_To_Attr('SUPPLY_SITE', newrec_.supply_site, attr_);
   Client_SYS.Add_To_Attr('SUPPLY_SITE_RESERVE_TYPE_DB', newrec_.supply_site_reserve_type, attr_);
   Client_SYS.Add_To_Attr('SUPPLY_SITE_RESERVE_TYPE', Supply_Site_Reserve_Type_API.Decode(newrec_.supply_site_reserve_type), attr_);
   Client_SYS.Add_To_Attr('SUPPLIER_SHIP_VIA_TRANSIT', newrec_.supplier_ship_via_transit, attr_);
   Client_SYS.Add_To_Attr('SUPPLIER_SHIP_VIA_TRANSIT_DESC', newrec_.supplier_ship_via_transit_desc, attr_);
   Client_SYS.Add_To_Attr('DOP_NEW_QTY_DEMAND', dop_new_qty_demand_, attr_);
   Client_SYS.Add_To_Attr('DOP_CONNECTION', Dop_Connection_API.Decode(newrec_.dop_connection), attr_);
   Client_SYS.Add_To_Attr('SUPPLY_SITE_DUE_DATE', newrec_.supply_site_due_date, attr_);
   Client_SYS.Add_To_Attr('PLANNED_DUE_DATE', newrec_.planned_due_date, attr_);
   
   newrec_.planned_due_date    := newrec_.planned_due_date;

   IF (newrec_.shipment_creation = 'PICK_LIST_CREATION' AND newrec_.shipment_creation != oldrec_.shipment_creation) THEN
      OPEN get_manual_pick_lines;
      FETCH get_manual_pick_lines INTO temp_num_;
      CLOSE get_manual_pick_lines;
      IF (NVL(temp_num_, 0) > 0) THEN
         Error_SYS.Record_General(lu_name_, 'SHIPLINEMANUALERR: A customer order line connected to a manual consolidated pick list cannot use a shipment creation method where the line is connected to a shipment at pick list creation.');
      END IF;
   END IF;

   IF (indrec_.buy_qty_due) THEN
      IF (newrec_.shipment_connected = 'TRUE') THEN
         Shipment_Line_API.Get_Preliminary_Ship_Info(no_of_preliminary_shipments_, connected_shipment_id_, newrec_.order_no,
                                                     newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, Logistics_Source_Ref_Type_API.DB_CUSTOMER_ORDER);

         new_ship_connectable_qty_ := newrec_.revised_qty_due - oldrec_.qty_shipped - oldrec_.open_shipment_qty + oldrec_.qty_shipdiff;
         old_ship_connectable_qty_ := oldrec_.revised_qty_due - oldrec_.qty_shipped - oldrec_.open_shipment_qty + oldrec_.qty_shipdiff;

         IF  (oldrec_.buy_qty_due > newrec_.buy_qty_due AND new_ship_connectable_qty_ < 0) THEN
            IF (no_of_preliminary_shipments_ != 1) THEN
               Error_SYS.Record_General(lu_name_, 'COLEXCEEDSSHL: The quantity cannot be less than the total shipment connected quantity.');
            END IF;
         END IF;

         IF (no_of_preliminary_shipments_ > 1) THEN
            Client_SYS.Add_Info(lu_name_, 'NOUPDATESHPQTY1: The changed quantity will not be reflected in any shipment, since the customer order line is connected to multiple shipments in the Preliminary status.');
         ELSIF (no_of_preliminary_shipments_ = 1 AND old_ship_connectable_qty_ > 0 AND (newrec_.revised_qty_due - oldrec_.qty_shipped) > oldrec_.open_shipment_qty) THEN
            Client_SYS.Add_Info(lu_name_, 'NOUPDATESHPQTY2: The changed quantity will not be reflected in any shipment, since the customer order line is partly connected to a shipment in the Preliminary status.');
         ELSIF ((newrec_.revised_qty_due - oldrec_.qty_shipped) != oldrec_.open_shipment_qty) THEN
            IF (no_of_preliminary_shipments_ = 1) THEN
               Client_Sys.Add_To_Attr('CONNECTED_SHIPMENT_ID', connected_shipment_id_, attr_);
            ELSE
               Client_SYS.Add_Info(lu_name_, 'NOUPDATESHPQTY3: The changed quantity will not be reflected in any shipment, since the customer order line is not connected to a shipment in the Preliminary state, not blocked for automatic connection.');
            END IF;
         END IF;
      END IF;
   END IF;

   IF (NVL(oldrec_.ship_addr_no, Database_Sys.string_null_) != NVL(newrec_.ship_addr_no, Database_Sys.string_null_) AND (NOT indrec_.cust_calendar_id)) THEN
      newrec_.cust_calendar_id := Cust_Ord_Customer_Address_API.Get_Cust_Calendar_Id(newrec_.customer_no, newrec_.ship_addr_no);
   END IF;

   IF (NVL(newrec_.cust_calendar_id, Database_Sys.string_null_) != NVL(oldrec_.cust_calendar_id, Database_Sys.string_null_)) THEN
      IF newrec_.demand_code != 'IPD' THEN
         Cust_Ord_Customer_API.Validate_Customer_Calendar(newrec_.customer_no, newrec_.cust_calendar_id, TRUE);
      ELSE
         Cust_Ord_Customer_API.Validate_Customer_Calendar(newrec_.customer_no, newrec_.cust_calendar_id, FALSE);
      END IF;
   END IF;

   -- Check and update the Export License Connect Header.
   Update_License_Connect_Head__(newrec_, oldrec_, attr_);

   Validate_Pack_Instr_Id___(attr_, newrec_, oldrec_);

   Client_SYS.Add_To_Attr('MAKE_RESERVATION', make_reservation_, attr_);
   Client_SYS.Add_To_Attr('FROM_SHORTAGE', from_shortage_, attr_);

   IF (NVL(Client_SYS.Get_Item_Value('ADD_INFO', attr_), 'FALSE') = 'TRUE') THEN
      current_info_ := App_Context_SYS.Find_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_');
      current_info_ := current_info_ || Client_SYS.Get_All_Info;
      App_Context_SYS.Set_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_', current_info_);
   END IF;
EXCEPTION
   WHEN value_error THEN
      Error_SYS.Item_Format(lu_name_, name_, value_);
END Check_Update___;

-- Is_Rental_Dates_Changed___
--   This method check whether the Planned Rental Start Date or
--   Planned Rental End date will modify using the modified rental attribute value
FUNCTION Is_Rental_Dates_Changed___ (
   attr_    IN VARCHAR2,
   newrec_  IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE) RETURN BOOLEAN
IS
   rental_dates_changed_ BOOLEAN := FALSE;
BEGIN
   $IF Component_Rental_SYS.INSTALLED $THEN
      rental_dates_changed_ := Rental_Object_API.Is_Rental_Dates_Changed(newrec_.order_no,
                                                                         newrec_.line_no,
                                                                         newrec_.rel_no,
                                                                         newrec_.line_item_no,
                                                                         Rental_Type_API.DB_CUSTOMER_ORDER,
                                                                         attr_);
   $END
   RETURN rental_dates_changed_;
END Is_Rental_Dates_Changed___;


PROCEDURE Validate_Update_Service_Con___ (
   attr_                IN VARCHAR2,
   demand_code_         IN VARCHAR2 )
IS
   raise_error_          BOOLEAN := FALSE;
   ptr_                  NUMBER;
   name_                 VARCHAR2(30);
   value_                VARCHAR2(4000);
BEGIN
   IF (demand_code_ = 'FSM') THEN
      raise_error_ := TRUE;
   ELSE
      IF (Client_Sys.Item_Exist('BASE_SALE_UNIT_PRICE', attr_) OR Client_Sys.Item_Exist('BASE_UNIT_PRICE_INCL_TAX', attr_) OR
         Client_Sys.Item_Exist('SALE_UNIT_PRICE', attr_) OR Client_Sys.Item_Exist('UNIT_PRICE_INCL_TAX', attr_)) THEN
         -- Price changed are allowed only when tax changes.
         IF (NOT(Client_Sys.Item_Exist('TAX_LIABILITY' , attr_) OR Client_Sys.Item_Exist('TAX_CODE' , attr_))) THEN
            raise_error_ := TRUE;
         END IF;
      END IF;
      IF (NOT raise_error_) THEN
         WHILE (Client_SYS.Get_Next_From_Attr(attr_, ptr_, name_, value_)) LOOP
            IF (NOT (name_ IN ('TAX_CODE', 'BLOCKED_FOR_INVOICING_DB', 'TAX_LIABILITY', 'DEFAULT_ADDR_FLAG_DB', 'TAX_CLASS_ID', 'CUSTOMER_PO_LINE_NO', 'CUSTOMER_PO_REL_NO', 'CUSTOMS_VALUE', 'TAX_CALC_STRUCTURE_ID', 
               'SET_TAX_FROM_ORIGINAL', 'FETCH_TAX_FROM_DEFAULTS', 'MULTIPLE_TAX_LINES', 'DELIVERY_TERMS', 'DEL_TERMS_LOCATION', 'CATALOG_DESC', 'NOTE_TEXT'))) THEN
               IF (name_ NOT IN ('BASE_SALE_UNIT_PRICE', 'BASE_UNIT_PRICE_INCL_TAX', 'SALE_UNIT_PRICE', 'UNIT_PRICE_INCL_TAX')) THEN
                  raise_error_ := TRUE;
                  EXIT;
               END IF;
            END IF;   
         END LOOP;
       END IF;    
   END IF;
   
   IF (raise_error_) THEN
      IF (demand_code_ != 'FSM') THEN
         Raise_No_Update_Error___();
      ELSE   
         Raise_No_Update_Fsm_Error___();
      END IF;
   END IF;
END Validate_Update_Service_Con___;

PROCEDURE Create_Project_Connection___ (
   order_no_                        IN  VARCHAR2,
   line_no_                         IN  VARCHAR2,
   rel_no_                          IN  VARCHAR2,
   line_item_no_                    IN  NUMBER,
   proj_lu_name_                    IN  VARCHAR2,
   system_ctrl_connection_          IN  VARCHAR2,
   activity_info_tab_               IN  Public_Declarations_API.PROJ_Project_Conn_Cost_Tab,
   activity_revenue_info_tab_       IN  Public_Declarations_API.PROJ_Project_Conn_Revenue_Tab,
   attributes_                      IN  Public_Declarations_API.PROJ_Project_Conn_Attr_Type)
IS
   rec_                             customer_order_line_tab%ROWTYPE;
   proj_code_value_                 VARCHAR2(30);
   distr_proj_code_value_           VARCHAR2(30);
   company_                         VARCHAR2(20);
   codeno_b_                        VARCHAR2(40);
   codeno_c_                        VARCHAR2(40);
   codeno_d_                        VARCHAR2(40);
   codeno_e_                        VARCHAR2(40);
   codeno_f_                        VARCHAR2(40);
   codeno_g_                        VARCHAR2(40);
   codeno_h_                        VARCHAR2(40);
   codeno_i_                        VARCHAR2(40);
   codeno_j_                        VARCHAR2(40);
BEGIN
   -- skip the revenue calculation for PKG part component lines
   IF ((proj_lu_name_ = 'COLINEREV') AND (line_item_no_ > 0)) THEN
      RETURN;
   END IF;
   
   rec_ := Get_Object_By_Keys___ (order_no_, line_no_, rel_no_, line_item_no_);
   
   IF (Project_Connection_Exist___ (order_no_, line_no_, rel_no_, line_item_no_, rec_.activity_seq, proj_lu_name_) = 'FALSE') THEN
      company_ := Site_API.Get_Company (rec_.contract);
      Pre_Accounting_API.Get_Project_Code_Value(proj_code_value_, distr_proj_code_value_, company_, rec_.pre_accounting_id);
      IF (proj_code_value_ IS NOT NULL AND proj_code_value_ != rec_.project_id) THEN
         Error_SYS.Record_General(lu_name_, 'PROJECTCODEPARTEXIST: It is not allowed to connect an object with existing preposting on the Project code part ');
      END IF;
      
      $IF Component_Proj_SYS.INSTALLED $THEN
      IF(Transaction_Sys.Is_Session_Deferred AND (Activity_API.Check_Activity_Seq(rec_.activity_seq) = 'FALSE')) THEN
         RETURN;
      END IF;
      
      Project_Connection_Util_API.Create_Connection ( proj_lu_name_              => proj_lu_name_,
                                                      activity_seq_              => rec_.activity_seq,
                                                      system_ctrl_conn_          => system_ctrl_connection_,
                                                      keyref1_                   => rec_.order_no,
                                                      keyref2_                   => rec_.line_no,
                                                      keyref3_                   => rec_.rel_no,
                                                      keyref4_                   => rec_.line_item_no,
                                                      keyref5_                   =>  '*',
                                                      keyref6_                   =>  '*',
                                                      object_description_        => lu_name_,
                                                      activity_info_tab_         => activity_info_tab_,
                                                      activity_revenue_info_tab_ => activity_revenue_info_tab_,
                                                      attributes_                => attributes_);
      
      Project_Pre_Accounting_API.Get_Pre_Accounting3 (codeno_b_,
                                                      codeno_c_,
                                                      codeno_d_,
                                                      codeno_e_,
                                                      codeno_f_,
                                                      codeno_g_,
                                                      codeno_h_,
                                                      codeno_i_,
                                                      codeno_j_,
                                                      rec_.activity_seq);
      $ELSE
      NULL;
      $END         

      Pre_Accounting_API.Set_Pre_Posting(rec_.pre_accounting_id,
                                         rec_.contract,
                                         'M104',
                                         NULL,
                                         codeno_b_,
                                         codeno_c_,
                                         codeno_d_,
                                         codeno_e_,
                                         codeno_f_,
                                         codeno_g_,
                                         codeno_h_,
                                         codeno_i_,
                                         codeno_j_,
                                         rec_.activity_seq,
                                         'TRUE',
                                         'TRUE' );
   
   END IF;
END Create_Project_Connection___;

-- Get_Backord_Value_Base_Curr___
--   Return the net and gross value of NOT shipped items for this order row in
--   the base currency. The backorder value is calculated as the value of the
--   items ordered but not yet delivered.
PROCEDURE Get_Backord_Value_Base_Curr___ (
   net_amount_   OUT VARCHAR2,
   gross_amount_ OUT VARCHAR2,
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER )
IS
   company_               VARCHAR2(20);
   currency_code_         VARCHAR2(3);
   rounding_              NUMBER;
   rental_chargable_days_ NUMBER;
   header_rec_            CUSTOMER_ORDER_API.Public_Rec;
   
   CURSOR get_line_data IS
      SELECT (buy_qty_due + ((qty_shipdiff - qty_shipped) / conv_factor * inverted_conv_factor))  quantity, price_conv_factor, currency_rate,
             sale_unit_price, unit_price_incl_tax, order_discount, additional_discount, rental
      FROM  CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = order_no_
      AND   line_no = line_no_
      AND   rel_no = rel_no_
      AND   line_item_no = line_item_no_;

   line_discount_         NUMBER;
   rec_line_              get_line_data%ROWTYPE;
   curr_rounding_         NUMBER;
   line_disc_no_tax_      NUMBER;
   total_disc_no_tax_     NUMBER;
   tax_percentage_        NUMBER;
   total_gross_amt_       NUMBER;
BEGIN
   header_rec_ := Customer_Order_API.Get(order_no_);
   company_       := Site_API.Get_Company(header_rec_.contract);
   currency_code_ := Company_Finance_API.Get_Currency_Code(company_);
   rounding_      := Currency_Code_API.Get_Currency_Rounding(company_, currency_code_);

   curr_rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, header_rec_.currency_code);
   OPEN get_line_data;
   FETCH get_line_data INTO rec_line_;
   CLOSE get_line_data;
   rental_chargable_days_ := Get_Rental_Chargeable_Days(order_no_, line_no_, rel_no_, line_item_no_, rec_line_.rental);
   tax_percentage_        := Source_Tax_Item_API.Get_Total_Tax_Percentage(company_, Tax_Source_API.DB_CUSTOMER_ORDER_LINE, 
                                                                          order_no_, line_no_, rel_no_, TO_CHAR(line_item_no_), '*');
   line_discount_         := Cust_Order_Line_Discount_API.Get_Total_Line_Discount(order_no_, line_no_, rel_no_, line_item_no_,
                                                                               rec_line_.quantity, rec_line_.price_conv_factor, curr_rounding_);
   
   IF (header_rec_.use_price_incl_tax  = 'TRUE') THEN   
      line_disc_no_tax_   := Cust_Order_Line_Discount_API.Get_Total_Line_Discount(order_no_, line_no_, rel_no_, line_item_no_,
                                                                               rec_line_.quantity, rec_line_.price_conv_factor,  curr_rounding_, tax_percentage_ => NVL(tax_percentage_, 0));
      total_gross_amt_    := rec_line_.quantity * rec_line_.price_conv_factor * rec_line_.unit_price_incl_tax * rental_chargable_days_;

      total_disc_no_tax_  := line_disc_no_tax_;
      total_disc_no_tax_  := total_disc_no_tax_ + ROUND (ROUND((total_gross_amt_ - line_discount_) * rec_line_.order_discount, curr_rounding_)/(1+ (tax_percentage_/100)) * rec_line_.currency_rate, curr_rounding_); -- Calculating Order discount
      total_disc_no_tax_  := total_disc_no_tax_ + ROUND (ROUND((total_gross_amt_ - line_discount_) * rec_line_.additional_discount, curr_rounding_)/(1+ (tax_percentage_/100)) * rec_line_.currency_rate, curr_rounding_); -- Calculating Additional discount

      net_amount_         := NVL((ROUND( total_gross_amt_ /(1+ (tax_percentage_/100)), curr_rounding_ ) - total_disc_no_tax_), 0);
      gross_amount_       := NVL((ROUND( total_gross_amt_ , curr_rounding_ ) - total_disc_no_tax_), 0);
   ELSE
      net_amount_         := NVL(ROUND(((rec_line_.quantity * rec_line_.price_conv_factor * rec_line_.sale_unit_price * rental_chargable_days_) - line_discount_)
                                 * (1 - (rec_line_.order_discount + rec_line_.additional_discount) / 100) * rec_line_.currency_rate, curr_rounding_), 0);
      gross_amount_       := NVL(ROUND((((rec_line_.quantity * rec_line_.price_conv_factor * rec_line_.sale_unit_price * rental_chargable_days_) - line_discount_) * (1 + (tax_percentage_/100)))
                                 * (1 - (rec_line_.order_discount + rec_line_.additional_discount) / 100) * rec_line_.currency_rate, curr_rounding_), 0);
  
   END IF;
END Get_Backord_Value_Base_Curr___;

-- Get_Backlog_Value_Ord_Curr___
--   Return the net and gross value of NOT invoiced items for this order row in
--   the order currency. The backlog value is calculated as the value of the
--   items ordered but not yet invoiced.
PROCEDURE Get_Backlog_Value_Ord_Curr___ (
   net_amount_   OUT NUMBER,
   gross_amount_ OUT NUMBER,
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER )
IS
   rec_                   CUSTOMER_ORDER_API.Public_Rec;
   rounding_              NUMBER;
   rental_chargable_days_ NUMBER;

   CURSOR get_line_data IS
      SELECT (buy_qty_due + (qty_shipdiff / conv_factor * inverted_conv_factor) - qty_invoiced) quantity,
             price_conv_factor, currency_rate, sale_unit_price, unit_price_incl_tax,
             order_discount, additional_discount, rental
      FROM  CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = order_no_
      AND   line_no = line_no_
      AND   rel_no = rel_no_
      AND   line_item_no = line_item_no_;

   line_discount_         NUMBER;
   rec_line_              get_line_data%ROWTYPE;
   line_disc_no_tax_      NUMBER;
   total_disc_no_tax_     NUMBER;
   tax_percentage_        NUMBER;
   total_gross_amt_       NUMBER;
   company_               VARCHAR2(20);
BEGIN
   rec_      := CUSTOMER_ORDER_API.Get(order_no_);
   company_  := Site_API.Get_Company(rec_.contract);
   rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, rec_.currency_code);
   
   OPEN get_line_data;
   FETCH get_line_data INTO rec_line_;
   CLOSE get_line_data;

   tax_percentage_  := NVL(Source_Tax_Item_API.Get_Total_Tax_Percentage(company_, Tax_Source_API.DB_CUSTOMER_ORDER_LINE, 
                                                                        order_no_, line_no_, rel_no_, TO_CHAR(line_item_no_), '*'), 0);
   line_discount_   := Cust_Order_Line_Discount_API.Get_Total_Line_Discount(order_no_, line_no_, rel_no_, line_item_no_,
                                                                            rec_line_.quantity, rec_line_.price_conv_factor, rounding_);

   rental_chargable_days_ := Get_Rental_Chargeable_Days(order_no_, line_no_, rel_no_, line_item_no_, rec_line_.rental);
   IF (rec_.use_price_incl_tax = 'TRUE') THEN
      line_disc_no_tax_   := Cust_Order_Line_Discount_API.Get_Total_Line_Discount(order_no_, line_no_, rel_no_, line_item_no_,
                                                                               rec_line_.quantity, rec_line_.price_conv_factor,  rounding_, tax_percentage_ => NVL(tax_percentage_, 0));
      total_gross_amt_    := rec_line_.quantity * rec_line_.price_conv_factor * rec_line_.unit_price_incl_tax * rental_chargable_days_;

      total_disc_no_tax_  := line_disc_no_tax_;
      total_disc_no_tax_  := total_disc_no_tax_ + ROUND (ROUND((total_gross_amt_ - line_discount_) * rec_line_.order_discount, rounding_)/(1+ (tax_percentage_/100)), rounding_); -- Calculating Order discount
      total_disc_no_tax_  := total_disc_no_tax_ + ROUND (ROUND((total_gross_amt_ - line_discount_) * rec_line_.additional_discount, rounding_)/(1+ (tax_percentage_/100)), rounding_); -- Calculating Additional discount

      net_amount_ := NVL((ROUND( total_gross_amt_ /(1+ (tax_percentage_/100)), rounding_) - total_disc_no_tax_), 0);
      gross_amount_ := NVL((ROUND( total_gross_amt_ , rounding_) - total_disc_no_tax_), 0);

   ELSE
      net_amount_ := NVL(ROUND(((rec_line_.quantity * rec_line_.price_conv_factor * rec_line_.sale_unit_price * rental_chargable_days_) - line_discount_)
                             * (1 - (rec_line_.order_discount + rec_line_.additional_discount) / 100), rounding_) ,0);
      gross_amount_ := NVL(ROUND((((rec_line_.quantity * rec_line_.price_conv_factor * rec_line_.sale_unit_price * rental_chargable_days_) - line_discount_) * (1 + (tax_percentage_/100)) )
                               * (1 - (rec_line_.order_discount + rec_line_.additional_discount) / 100), rounding_) ,0);
   END IF;
END Get_Backlog_Value_Ord_Curr___;

   -- Get_Backlog_Value_Base_Curr___
--   Return the net and gross value of NOT invoiced items for this order row in
--   the base currency. The backlog value is calculated as the value of
--   the items ordered but not yet invoiced.
PROCEDURE Get_Backlog_Value_Base_Curr___ (
   net_amount_   OUT NUMBER,
   gross_amount_ OUT NUMBER,
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER )
IS
   CURSOR get_curr_rate IS
      SELECT currency_rate
      FROM  CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = order_no_
      AND   line_no = line_no_
      AND   rel_no = rel_no_
      AND   line_item_no = line_item_no_;

   curr_rate_     NUMBER;
   base_rounding_ NUMBER;
   company_       VARCHAR2(20);
BEGIN
   company_       := Site_API.Get_Company(CUSTOMER_ORDER_API.Get_Contract(order_no_));
   base_rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, Company_Finance_API.Get_Currency_Code(company_));

   OPEN get_curr_rate;
   FETCH get_curr_rate INTO curr_rate_;
   CLOSE get_curr_rate;
   
   Get_Backlog_Value_Ord_Curr___(net_amount_, gross_amount_, order_no_, line_no_, rel_no_, line_item_no_);
   net_amount_ := ROUND( net_amount_*curr_rate_, base_rounding_);
   gross_amount_ := ROUND( gross_amount_*curr_rate_, base_rounding_);
END Get_Backlog_Value_Base_Curr___;
 
-- Check_Default_Addr_Flag___
-- Compare the header and the line address details and set the default address flag accordingly.
FUNCTION Check_Default_Addr_Flag___(  
   line_rec_          IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   order_no_          IN VARCHAR2,
   default_addr_flag_ IN VARCHAR2,
   duplicate_line_    IN BOOLEAN DEFAULT FALSE ) RETURN VARCHAR2    
IS
   head_rec_               Customer_Order_API.public_rec;
   head_addr_rec_          Customer_Order_Address_API.Cust_Ord_Addr_Rec;
   line_addr_rec_          Cust_Order_Line_Address_API.Co_Line_Addr_rec;
   string_null_            VARCHAR2(15) := Database_SYS.string_null_;
   line_default_addr_flag_ VARCHAR2(1);
BEGIN
   line_default_addr_flag_ := default_addr_flag_;
   head_rec_               := Customer_Order_API.Get(order_no_);
   
   IF (default_addr_flag_ = 'N') AND (line_rec_.vendor_no = head_rec_.vendor_no ) THEN
      line_default_addr_flag_ := 'Y';
   END IF;
   
   IF (Validate_SYS.Is_Equal(head_rec_.route_id, line_rec_.route_id) AND
       Validate_SYS.Is_Equal(head_rec_.forward_agent_id, line_rec_.forward_agent_id) AND
       Validate_SYS.Is_Equal(head_rec_.ship_via_code, line_rec_.ship_via_code) AND
       Validate_SYS.Is_Equal(head_rec_.delivery_terms, line_rec_.delivery_terms) AND
       Validate_SYS.Is_Equal(head_rec_.del_terms_location, line_rec_.del_terms_location) AND
       Validate_SYS.Is_Equal(head_rec_.delivery_leadtime, line_rec_.delivery_leadtime) AND
       Validate_SYS.Is_Equal(head_rec_.picking_leadtime, line_rec_.picking_leadtime) AND          
       Validate_SYS.Is_Equal(head_rec_.shipment_type, line_rec_.shipment_type) AND
       Validate_SYS.Is_Equal(head_rec_.ext_transport_calendar_id, line_rec_.ext_transport_calendar_id) AND
       Validate_SYS.Is_Equal(head_rec_.cust_calendar_id, line_rec_.cust_calendar_id) AND
       Validate_SYS.Is_Equal(head_rec_.district_code, line_rec_.district_code) AND
       Validate_SYS.Is_Equal(head_rec_.region_code, line_rec_.region_code) AND
       Validate_SYS.Is_Equal(head_rec_.shipment_creation, line_rec_.shipment_creation) AND
       Validate_SYS.Is_Equal(head_rec_.cust_ref, line_rec_.contact) AND
       Validate_SYS.Is_Equal(Customer_Order_API.Get_Tax_Liability_Type_Db(order_no_), line_rec_.tax_liability_type) AND
       Validate_SYS.Is_Equal(head_rec_.tax_liability, line_rec_.tax_liability) AND
       Validate_SYS.Is_Equal(head_rec_.freight_map_id, line_rec_.freight_map_id) AND
       Validate_SYS.Is_Equal(head_rec_.zone_id, line_rec_.zone_id) AND
       Validate_SYS.Is_Equal(head_rec_.freight_price_list_no, line_rec_.freight_price_list_no) AND
       Validate_SYS.Is_Equal(head_rec_.intrastat_exempt, line_rec_.intrastat_exempt)) THEN 

      line_default_addr_flag_ := 'Y';
   ELSE
      line_default_addr_flag_ := 'N';
   END IF;
   
   
   IF (line_default_addr_flag_ = 'Y') THEN
      -- Check the customer order addr flag
      IF (head_rec_.addr_flag = 'Y') AND (line_rec_.addr_flag = 'Y') THEN
         -- Single Occurence address
         -- Surrounded with if condition as data from Cust_Order_Line_Address_API.Get is not yet available 
         -- by the time this method is called through Pre_Unpack_Insert___ during line duplication.        
         IF (NOT duplicate_line_) THEN
            head_addr_rec_       := Customer_Order_Address_API.Get_Cust_Ord_Addr(order_no_);
            line_addr_rec_       := Cust_Order_Line_Address_API.Get_Co_Line_Addr(order_no_, line_rec_.line_no, line_rec_.rel_no, line_rec_.line_item_no);

            IF(Validate_SYS.Is_Different(head_addr_rec_.addr_1, line_addr_rec_.addr_1) OR            
               Validate_SYS.Is_Different(head_addr_rec_.country_code, line_addr_rec_.country_code) OR
               Validate_SYS.Is_Different(head_addr_rec_.address1, line_addr_rec_.address1) OR
               Validate_SYS.Is_Different(head_addr_rec_.address2, line_addr_rec_.address2) OR
               Validate_SYS.Is_Different(head_addr_rec_.address3, line_addr_rec_.address3) OR
               Validate_SYS.Is_Different(head_addr_rec_.address4, line_addr_rec_.address4) OR
               Validate_SYS.Is_Different(head_addr_rec_.address5, line_addr_rec_.address5) OR
               Validate_SYS.Is_Different(head_addr_rec_.address6, line_addr_rec_.address6) OR            
               Validate_SYS.Is_Different(head_addr_rec_.zip_code, line_addr_rec_.zip_code) OR
               Validate_SYS.Is_Different(head_addr_rec_.city, line_addr_rec_.city) OR
               Validate_SYS.Is_Different(head_addr_rec_.state, line_addr_rec_.state) OR
               Validate_SYS.Is_Different(head_addr_rec_.county, line_addr_rec_.county) OR
               Validate_SYS.Is_Different(head_addr_rec_.in_city, line_addr_rec_.in_city)) THEN

              line_default_addr_flag_ := 'N';
            END IF;
         END IF; 
      ELSIF (head_rec_.addr_flag = 'N') AND (line_rec_.addr_flag = 'N') THEN

         IF (NVL(head_rec_.ship_addr_no, string_null_) != NVL(line_rec_.ship_addr_no, string_null_)) THEN
            line_default_addr_flag_ := 'N';
         END IF;
      ELSE
         -- Address Flag has been changed.
         line_default_addr_flag_ := 'N';
      END IF;
   END IF; 

   RETURN (line_default_addr_flag_);
END Check_Default_Addr_Flag___;

-- Build_Attr_For_New___ 
-- This method is used to build the attr_ which is used in New.
PROCEDURE Build_Attr_For_New___ (
   discount_            OUT    CUSTOMER_ORDER_LINE_TAB.discount%TYPE,
   copy_discount_       OUT    VARCHAR2,
   create_partial_sum_  OUT    CUST_ORDER_LINE_DISCOUNT_TAB.Create_Partial_Sum%TYPE,   
	new_attr_            OUT    VARCHAR2,
   attr_                IN     VARCHAR2  )
IS
   ptr_                      NUMBER;
   name_                     VARCHAR2(30);
   value_                    VARCHAR2(4000);
   order_no_                 CUSTOMER_ORDER_LINE_TAB.order_no%TYPE;
   contract_                 VARCHAR2(5);
   wanted_delivery_date_     DATE;
   price_effectivity_date_   DATE;
   timestamp_                VARCHAR2(35);
   target_date_              DATE;
   rental_db_                CUSTOMER_ORDER_LINE_TAB.rental%TYPE;
   deliver_to_customer_no_   CUSTOMER_ORDER_LINE_TAB.deliver_to_customer_no%TYPE;
   price_source_             CUSTOMER_ORDER_LINE_TAB.price_source%TYPE;
   insert_package_mode_      VARCHAR2(5);
   free_of_charge_           CUSTOMER_ORDER_LINE_TAB.free_of_charge%TYPE;
   free_of_charge_tax_basis_ CUSTOMER_ORDER_LINE_TAB.free_of_charge_tax_basis%TYPE;
   customer_no_              VARCHAR2(20);
   packing_instruction_id_   VARCHAR2(20);
   sales_unit_price_        NUMBER;
   curr_rate_               NUMBER;
   order_rec_               Customer_Order_API.Public_Rec;
   base_unit_price_         NUMBER;
BEGIN   
   -- Retrieve the default attribute values, order_no must be passed to Prepare_Insert___
   order_no_ := Client_SYS.Get_Item_Value('ORDER_NO', attr_);
   order_rec_ := Customer_Order_API.Get(order_no_);
   Client_SYS.Add_To_Attr('ORDER_NO', order_no_, new_attr_);
   rental_db_ := NVL(Client_SYS.Get_Item_Value('RENTAL_DB', attr_), Fnd_Boolean_API.DB_FALSE);
   Client_SYS.Add_To_Attr('RENTAL_DB', rental_db_, new_attr_);
   deliver_to_customer_no_ := Client_SYS.Get_Item_Value('DELIVER_TO_CUSTOMER_NO', attr_);
   Client_SYS.Add_To_Attr('DELIVER_TO_CUSTOMER_NO', deliver_to_customer_no_, new_attr_);

   Prepare_Insert___(new_attr_);

   -- Replace the default attribute values with the ones passed in the in parameter string
   ptr_ := NULL;
   WHILE (Client_SYS.Get_Next_From_Attr(attr_, ptr_, name_, value_)) LOOP
      -- Attribute values passed in the parameter string do not include DB values. This is taken care of here.
      IF (name_ = 'CONSIGNMENT_STOCK') THEN
         Client_SYS.Set_Item_Value('CONSIGNMENT_STOCK_DB', Consignment_Stock_API.Encode(value_), new_attr_);
      ELSIF (name_ = 'CHARGED_ITEM') THEN
         Client_SYS.Set_Item_Value('CHARGED_ITEM_DB', Charged_Item_API.Encode(value_), new_attr_);
      ELSIF (name_ = 'SUPPLY_CODE') THEN
         Client_SYS.Set_Item_Value('SUPPLY_CODE_DB', Order_Supply_Type_API.Encode(value_), new_attr_);
      -- Parameter string from quotation does not include price_source.
      ELSIF (name_ = 'PRICE_SOURCE_DB') THEN
         Client_SYS.Set_Item_Value('PRICE_SOURCE', Pricing_Source_API.Decode(value_), new_attr_);
      ELSIF (name_ = 'DISCOUNT') THEN
         discount_ := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF name_ ='WANTED_DELIVERY_DATE' THEN
         -- store this value to set price effectivity date
         wanted_delivery_date_ := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF name_ ='TARGET_DATE' THEN
         target_date_ := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF name_ ='BASE_SALE_UNIT_PRICE' THEN
         base_unit_price_ := Client_SYS.Attr_Value_To_Number(value_);
         Client_SYS.Set_Item_Value('BASE_SALE_UNIT_PRICE', Client_SYS.Attr_Value_To_Number(value_), new_attr_);
      ELSIF name_ ='SALE_UNIT_PRICE' THEN
         Client_SYS.Set_Item_Value('SALE_UNIT_PRICE', Client_SYS.Attr_Value_To_Number(value_), new_attr_);
      ELSIF name_ ='PART_PRICE' THEN
         Client_SYS.Set_Item_Value('PART_PRICE', Client_SYS.Attr_Value_To_Number(value_), new_attr_);
      ELSIF name_ ='PRICE_FREEZE_DB' THEN
         Client_SYS.Set_Item_Value('PRICE_FREEZE', Freeze_Flag_API.Decode(value_), new_attr_);
      ELSIF name_ ='PRICE_SOURCE' THEN
         Client_SYS.Set_Item_Value('PRICE_SOURCE', value_, new_attr_);
      ELSIF name_ ='CREATE_PARTIAL_SUM' THEN
         create_partial_sum_ := value_;
      ELSIF name_ ='COPY_DISCOUNT' THEN
         copy_discount_ := value_;
      ELSIF name_ = 'FREE_OF_CHARGE_DB' THEN
         free_of_charge_ := value_;
      ELSIF name_ = 'FREE_OF_CHARGE_TAX_BASIS' THEN
         free_of_charge_tax_basis_ := value_;
      ELSIF name_ = 'VAT_NO' THEN
         Client_SYS.Set_Item_Value('TAX_ID_NO', value_, new_attr_);
      ELSIF name_ = 'SM_CONNECTION_DB' THEN
         Client_SYS.Set_Item_Value('SM_CONNECTION', Service_Management_Connect_API.Decode(value_), new_attr_);
      ELSE
         Client_SYS.Set_Item_Value(name_, value_, new_attr_);
      END IF;
   END LOOP;

   IF free_of_charge_ IS NOT NULL THEN
      Client_SYS.Set_Item_Value('FREE_OF_CHARGE_DB', free_of_charge_, new_attr_);      
   END IF;
   IF free_of_charge_tax_basis_ IS NOT NULL THEN
      Client_SYS.Set_Item_Value('FREE_OF_CHARGE_TAX_BASIS', free_of_charge_tax_basis_, new_attr_);
   END IF;
   contract_ := order_rec_.contract;
   customer_no_ := order_rec_.customer_no;   
   
   price_effectivity_date_ := Client_SYS.Attr_Value_To_Date(Client_SYS.Get_Item_Value('PRICE_EFFECTIVITY_DATE', new_attr_));

   IF (wanted_delivery_date_ IS NOT NULL) AND (price_effectivity_date_  IS NOT NULL) THEN
      IF (Cust_Order_Pricing_Method_API.Encode(Site_Discom_Info_API.Get_Cust_Order_Pricing_Method(contract_)) = 'DELIVERY_DATE') THEN
         Client_SYS.Set_Item_Value('PRICE_EFFECTIVITY_DATE', wanted_delivery_date_, new_attr_);
      END IF;
   END IF;

   -- Add dummy attribut CREATED_BY_SERVER to indicate that the line was created
   -- using the public New method and not from the client.
   Client_SYS.Add_To_Attr('CREATED_BY_SERVER', 1, new_attr_);
   -- Adding dummy attribute to pass INSERT_PACKAGE_MODE_ information.
   insert_package_mode_ := 'FALSE';
   Client_SYS.Add_To_Attr('INSERT_PACKAGE_MODE_', insert_package_mode_, new_attr_);

   IF (Substitute_Sales_Part_API.Allow_Auto_Substitution(contract_, customer_no_))THEN
      Client_SYS.Add_To_Attr('BUY_QTY_DUE', Client_SYS.Get_Item_Value('BUY_QTY_DUE', attr_), new_attr_);      
   END IF;
   -- Add the default attributes for the sales part
   Get_Default_Part_Attributes___(new_attr_, Client_SYS.Attr_Value_To_Number(Client_SYS.Get_Item_Value('PART_REPLACEMENT_ALLOWED', attr_)));

   -- Reapply the attributes passed as parameters in case these were replaced by default values.
   ptr_ := NULL;
   WHILE (Client_SYS.Get_Next_From_Attr(attr_, ptr_, name_, value_)) LOOP
      -- Append Time part to Wanted Delivery Date
      IF (name_ = 'WANTED_DELIVERY_DATE') THEN
         -- calculate Default Wanted Delivery date's time
         timestamp_            := to_char(Client_SYS.Attr_Value_To_Date(value_), Report_SYS.datetime_format_);
         -- replace with the Wanted Delivery date's time
         timestamp_            := replace(timestamp_, '00:00:00', to_char(wanted_delivery_date_, 'HH24:MI:SS'));
         wanted_delivery_date_ := to_date(timestamp_, Report_SYS.datetime_format_);
         Client_SYS.Set_Item_Value('WANTED_DELIVERY_DATE', wanted_delivery_date_, new_attr_);
         IF target_date_ IS NULL THEN
            Client_SYS.Set_Item_Value('TARGET_DATE', wanted_delivery_date_ , new_attr_);
         END IF;
      ELSIF (name_ = 'TARGET_DATE') THEN
         -- calculate Default Target date's time
         timestamp_   := to_char(Client_SYS.Attr_Value_To_Date(value_), Report_SYS.datetime_format_);
         -- replace with the Target date's time
         timestamp_   := replace(timestamp_, '00:00:00', to_char(target_date_, 'HH24:MI:SS'));
         target_date_ := to_date(timestamp_, Report_SYS.datetime_format_);
         Client_SYS.Set_Item_Value('TARGET_DATE', target_date_, new_attr_);
      ELSIF (name_ = 'PRICE_SOURCE') THEN
         price_source_ := Client_SYS.Get_Item_Value('PRICE_SOURCE', new_attr_);
         IF (price_source_ IS NULL) THEN
            Client_SYS.Set_Item_Value(name_, value_, new_attr_);
         END IF;
      ELSIF (name_ = 'PACKING_INSTRUCTION_ID') THEN                 
         IF (value_ IS NOT NULL) THEN
            Client_SYS.Set_Item_Value(name_, value_, new_attr_); 
         END IF;
      ELSIF ((name_ = 'SALE_UNIT_PRICE') AND (copy_discount_ = 'TRUE')) THEN
         Customer_Order_Pricing_API.Get_Sales_Price_In_Currency(sales_unit_price_, curr_rate_, customer_no_, contract_, order_rec_.currency_code,
                                                                  base_unit_price_, order_rec_.currency_rate_type);         
         Client_SYS.Set_Item_Value('SALE_UNIT_PRICE', sales_unit_price_, new_attr_); 
         
      -- CATALOG no could have been replaced by a replacement part
      -- DISCOUNT should not be passed when a new line is created
      -- the discount on the order line should always be the sum of the discount
      -- for all discount records connected to the order line.
      ELSIF (name_ NOT IN ('CATALOG_NO', 'DISCOUNT')) THEN
         Client_SYS.Set_Item_Value(name_, value_, new_attr_);
      END IF;
   END LOOP;
   
END Build_Attr_For_New___;

-- Build_Attr_Sourced_Co_Lines___ 
-- This method is used to build the attr_ which is used in method Create_Sourced_Co_Lines. 
PROCEDURE Build_Attr_Sourced_Co_Lines___ (
	   attr_                      OUT    VARCHAR2,
      sourced_lines_             IN OUT sourced_cust_order_line_tab%ROWTYPE,
      old_attr_                  IN     VARCHAR2,
      orglinerec_                IN     CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
      first_row_                 IN     BOOLEAN,
      sourced_reservation_exist_ IN     NUMBER,
      language_code_             IN     VARCHAR2,
      order_no_                  IN     VARCHAR2,
      line_no_                   IN     VARCHAR2,
      rel_no_                    IN     VARCHAR2,
      line_item_no_              IN     NUMBER )
IS
   buy_qty_due_               NUMBER;
   supply_site_reserve_type_  VARCHAR2(20);
   source_line_count_         NUMBER;
   ship_via_code_             VARCHAR2(3);
   supplier_ship_via_transit_ VARCHAR2(3);
   planned_delivery_date_     DATE;
   planned_ship_date_         DATE;
   new_line_no_               VARCHAR2(4);
   new_rel_no_                VARCHAR2(4);
   new_line_item_no_          NUMBER;
   order_rec_                 CUSTOMER_ORDER_API.Public_Rec;

     -- Count the no of souced lines
   CURSOR sourced_lines_count IS
      SELECT  COUNT(*)
      FROM  sourced_cust_order_line_tab
      WHERE  order_no     = order_no_
      AND  line_no      = line_no_
      AND  rel_no       = rel_no_
      AND  line_item_no = line_item_no_;
        
BEGIN
   -- Update the existing line first
   IF first_row_ THEN
      Client_SYS.Clear_Attr(attr_);
   ELSE
      attr_ := old_attr_;
   END IF;

   supply_site_reserve_type_ := 'NOTALLOWED';        

   IF (sourced_lines_.vendor_no IS NULL) THEN
      -- Sourced from own inventory
      IF (orglinerec_.catalog_type = 'NON') THEN
         -- supply code = 'NO' when the purchase_part is non inventory part
         Client_SYS.Set_Item_Value('SUPPLY_CODE_DB', 'NO', attr_);
      ELSE
         -- supply code = 'IO' or 'SO' when the purchase_part is inventory part
         IF (sourced_lines_.supply_code = 'SO') THEN
            Client_SYS.Set_Item_Value('SUPPLY_CODE_DB', 'SO', attr_);
         ELSE
            Client_SYS.Set_Item_Value('SUPPLY_CODE_DB', 'IO', attr_);
         END IF;

         IF (sourced_reservation_exist_ = 1) THEN
            -- we have local site reservation and dont want a priority reservation to take place
            -- when CO line is created or updated from this sourced line
            Client_SYS.Set_Item_Value('LOCAL_SITE_RESERVATION_EXIST', 1, attr_);
         END IF;
      END IF;

      Client_SYS.Set_Item_Value('SHIP_VIA_CODE', sourced_lines_.ship_via_code, attr_);
      ship_via_code_ := sourced_lines_.ship_via_code;
      supplier_ship_via_transit_ := NULL;

      IF (orglinerec_.ship_via_code = sourced_lines_.ship_via_code) THEN
         -- IF the ship via code is the same as the one on the original order line
         -- the inherit delivery leadtime and picking leadtime as well
         Client_SYS.Set_Item_Value('DELIVERY_LEADTIME', orglinerec_.delivery_leadtime, attr_);
         Client_SYS.Set_Item_Value('CUST_CALENDAR_ID', orglinerec_.cust_calendar_id, attr_);
         Client_SYS.Set_Item_Value('EXT_TRANSPORT_CALENDAR_ID', orglinerec_.ext_transport_calendar_id, attr_);
         Client_SYS.Set_Item_Value('PICKING_LEADTIME', orglinerec_.picking_leadtime, attr_);
         Client_SYS.Set_Item_Value('SHIPMENT_TYPE', orglinerec_.shipment_type, attr_);
         Client_SYS.Set_Item_Value('ROUTE_ID', orglinerec_.route_id, attr_);
      END IF;

   ELSIF (sourced_lines_.supply_code IN ('IPD', 'PD', 'IPT', 'PT')) THEN
      Client_SYS.Set_Item_Value('SUPPLY_CODE_DB', sourced_lines_.supply_code, attr_);
      Client_SYS.Set_Item_Value('VENDOR_NO', sourced_lines_.vendor_no, attr_);

      IF (sourced_lines_.supply_code IN ('IPD', 'IPT')) THEN
         IF (sourced_lines_.supply_site_due_date IS NOT NULL) THEN
            Client_SYS.Set_Item_Value('SUPPLY_SITE_DUE_DATE', sourced_lines_.supply_site_due_date, attr_);
         END IF;
         IF (sourced_reservation_exist_ = 1) THEN
            supply_site_reserve_type_ := 'SOURCED';
         END IF;
      END IF;

      -- Set ship via code and supplier ship via transit
      IF (sourced_lines_.supply_code IN ('PD', 'IPD')) THEN
         -- Direct delivery from supplier
         Client_SYS.Set_Item_Value('SHIP_VIA_CODE', sourced_lines_.ship_via_code, attr_);
         ship_via_code_ := sourced_lines_.ship_via_code;
         supplier_ship_via_transit_ := NULL;
      ELSE
         -- Transit delivery from supplier to us
         Client_SYS.Set_Item_Value('SHIP_VIA_CODE', orglinerec_.ship_via_code, attr_);
         Client_SYS.Set_Item_Value('SUPPLIER_SHIP_VIA_TRANSIT', sourced_lines_.ship_via_code, attr_);
         Client_SYS.Set_Item_Value('SUPPLIER_SHIP_VIA_TRANSIT_DESC', Mpccom_Ship_Via_API.Get_Description(sourced_lines_.ship_via_code, language_code_), attr_);
         -- Inherit delivery leadtime from original order line
         Client_SYS.Set_Item_Value('DELIVERY_LEADTIME', orglinerec_.delivery_leadtime, attr_);
         Client_SYS.Set_Item_Value('CUST_CALENDAR_ID', orglinerec_.cust_calendar_id, attr_);
         Client_SYS.Set_Item_Value('EXT_TRANSPORT_CALENDAR_ID', orglinerec_.ext_transport_calendar_id, attr_);
         Client_SYS.Set_Item_Value('PICKING_LEADTIME', orglinerec_.picking_leadtime, attr_);
         Client_SYS.Set_Item_Value('SHIPMENT_TYPE', orglinerec_.shipment_type, attr_);
         Client_SYS.Set_Item_Value('ROUTE_ID', orglinerec_.route_id, attr_);
         ship_via_code_ := orglinerec_.ship_via_code;
         supplier_ship_via_transit_ := sourced_lines_.ship_via_code;
      END IF;

   ELSE
      Error_SYS.Record_General(lu_name_, 'WRONGPURCHASEFLAG: Wrong Sourcing method.');
   END IF;


   Client_SYS.Set_Item_Value('SUPPLY_SITE_RESERVE_TYPE_DB', supply_site_reserve_type_, attr_);
   Client_SYS.Set_Item_Value('SUPPLY_SITE_RESERVE_TYPE', Supply_Site_Reserve_Type_API.Decode(supply_site_reserve_type_), attr_);
   Client_SYS.Set_Item_Value('REVISED_QTY_DUE', sourced_lines_.sourced_qty, attr_);
   -- conversion factor cannot be zero..
   buy_qty_due_ := sourced_lines_.sourced_qty / orglinerec_.conv_factor * orglinerec_.inverted_conv_factor;
   Client_SYS.Set_Item_Value('BUY_QTY_DUE', buy_qty_due_, attr_);
   Client_SYS.Set_Item_Value('DESIRED_QTY', buy_qty_due_, attr_);
   Client_SYS.Set_Item_Value('WANTED_DELIVERY_DATE', sourced_lines_.wanted_delivery_date, attr_);
   Client_SYS.Set_Item_Value('TARGET_DATE', sourced_lines_.wanted_delivery_date, attr_);

   IF (sourced_lines_.latest_release_date IS NOT NULL) THEN   -- a capability checked sourced line
      Client_SYS.Set_Item_Value('LATEST_RELEASE_DATE', sourced_lines_.latest_release_date, attr_);
      -- calculate the dates forwards from the planned_due_date that the capability check engine have returned
      Cust_Ord_Date_Calculation_API.Calc_Order_Dates_Forwards(planned_delivery_date_, planned_ship_date_,
                                          sourced_lines_.planned_due_date, sourced_lines_.supply_site_due_date,
                                          sourced_lines_.wanted_delivery_date, orglinerec_.contract,
                                          sourced_lines_.supply_code, orglinerec_.deliver_to_customer_no, sourced_lines_.vendor_no,
                                          orglinerec_.part_no, orglinerec_.purchase_part_no, orglinerec_.ship_addr_no,
                                          ship_via_code_, orglinerec_.route_id,
                                          orglinerec_.delivery_leadtime, orglinerec_.picking_leadtime, orglinerec_.ext_transport_calendar_id, supplier_ship_via_transit_);

      Trace_SYS.Field('planned_due_date after forward calculation ', sourced_lines_.planned_due_date);

      -- send the newly calculated dates to co
      Client_SYS.Set_Item_Value('PLANNED_DELIVERY_DATE', planned_delivery_date_, attr_);
      Client_SYS.Set_Item_Value('PROMISED_DELIVERY_DATE', planned_delivery_date_, attr_);
      Client_SYS.Set_Item_Value('PLANNED_DUE_DATE', sourced_lines_.planned_due_date, attr_);
      Client_SYS.Set_Item_Value('PLANNED_SHIP_DATE', planned_ship_date_, attr_);
      -- send the capability check source flag so the customer order line do not start the backwards date calculations since we have already done a forward calculations for these dates
      Client_SYS.Set_Item_Value('CAPABILITY_CHECK_SOURCE_FLAG', 'TRUE', attr_);

   ELSE  -- a normal sourced line
      Client_SYS.Set_Item_Value('PLANNED_DELIVERY_DATE', sourced_lines_.wanted_delivery_date, attr_);
      Client_SYS.Set_Item_Value('PLANNED_DUE_DATE', sourced_lines_.planned_due_date, attr_);
   END IF;


   IF first_row_ THEN
      OPEN sourced_lines_count;
      FETCH sourced_lines_count INTO source_line_count_;
      CLOSE sourced_lines_count;
      Client_SYS.Set_Item_Value('SOURCING_FLAG','TRUE', attr_);
      IF (source_line_count_ != 1) THEN
         Client_SYS.Set_Item_Value('ORIGINATING_REL_NO', rel_no_, attr_);
         Client_SYS.Set_Item_Value('ORIGINATING_LINE_ITEM_NO', line_item_no_, attr_);
      END IF;
         Client_SYS.Set_Item_Value('INPUT_QTY','', attr_);
         Client_SYS.Set_Item_Value('INPUT_UNIT_MEAS','', attr_);
         Client_SYS.Set_Item_Value('INPUT_CONV_FACTOR','', attr_);
         Client_SYS.Set_Item_Value('INPUT_VARIABLE_VALUES','', attr_);
      ELSE
         -- Get new line numbers for customer order lines created.
         IF (sourced_lines_.line_item_no != -1 AND sourced_lines_.line_item_no != 0 ) THEN
            Get_Next_Line_Item_No(new_line_item_no_, order_no_, line_no_, rel_no_);
            new_line_no_ := line_no_;
            new_rel_no_  := rel_no_;
         ELSE
            CUSTOMER_ORDER_API.Get_Next_Line_No(new_rel_no_, new_line_item_no_, new_line_no_, order_no_, orglinerec_.contract, orglinerec_.catalog_no, NULL, orglinerec_.rental);
         END IF;
         Client_SYS.Set_Item_Value('ORDER_NO', order_no_ , attr_);
         Client_SYS.Set_Item_Value('LINE_NO', new_line_no_, attr_);
         Client_SYS.Set_Item_Value('REL_NO', new_rel_no_, attr_);
         Client_SYS.Set_Item_Value('LINE_ITEM_NO', new_line_item_no_, attr_);
      END IF;

      IF (((orglinerec_.ship_via_code != sourced_lines_.ship_via_code) OR (NVL(orglinerec_.vendor_no, Database_SYS.string_null_) != NVL(sourced_lines_.vendor_no, Database_SYS.string_null_)))
         AND sourced_lines_.supply_code NOT IN ('IPT', 'PT')) THEN
         order_rec_ := CUSTOMER_ORDER_API.Get(order_no_);
         IF (sourced_lines_.supply_code IN ('IPD', 'PD')) AND (sourced_lines_.vendor_no = order_rec_.vendor_no AND sourced_lines_.ship_via_code = order_rec_.ship_via_code) THEN
            Client_SYS.Set_Item_Value('DEFAULT_ADDR_FLAG_DB', Gen_Yes_No_API.DB_YES, attr_);
            Client_SYS.Set_Item_Value('DEFAULT_ADDR_FLAG', Gen_Yes_No_API.Decode(Gen_Yes_No_API.DB_YES), attr_);
         ELSE
            Client_SYS.Set_Item_Value('DEFAULT_ADDR_FLAG_DB', Gen_Yes_No_API.DB_NO, attr_);
            Client_SYS.Set_Item_Value('DEFAULT_ADDR_FLAG', Gen_Yes_No_API.Decode(Gen_Yes_No_API.DB_NO), attr_);
         END IF;
         -- Client value is added to attribute string not to replace default_addr_flag with the default value with later method calls from New
         Client_SYS.Set_Item_Value('DEFAULT_ADDR_FLAG', Gen_Yes_No_API.Decode('N'), attr_);
      END IF;

      -- include order line in planning / supply demand view if supply site reservations exists.
      IF (sourced_reservation_exist_ = 1) THEN
         Client_SYS.Set_Item_Value('RELEASE_PLANNING_DB', 'RELEASED', attr_);
      ELSE
         Client_SYS.Set_Item_Value('RELEASE_PLANNING_DB', 'NOTRELEASED', attr_);
      END IF;
   
   END Build_Attr_Sourced_Co_Lines___;


-- Add_Transaction_Tax_Info___
--    Fetch and calculate taxes and add tax lines to source_tax_item_tab.
PROCEDURE Add_Transaction_Tax_Info___ (
   newrec_              IN customer_order_line_tab%ROWTYPE,    
   company_             IN VARCHAR2,   
   customer_no_         IN VARCHAR2,
   ship_addr_no_        IN VARCHAR2,
   supply_country_db_   IN VARCHAR2,     
   use_price_incl_tax_  IN VARCHAR2,
   currency_code_       IN VARCHAR2,
   tax_from_defaults_   IN BOOLEAN,
   attr_                IN VARCHAR2)
IS
   line_amount_rec_       Tax_Handling_Util_API.line_amount_rec;
   source_key_rec_        Tax_Handling_Util_API.source_key_rec;
   tax_line_param_rec_    Tax_Handling_Order_Util_API.tax_line_param_rec;
   multiple_tax_          VARCHAR2(20);
   tax_info_table_        Tax_Handling_Util_API.tax_information_table;
BEGIN
   source_key_rec_     := Tax_Handling_Util_API.Create_Source_Key_Rec(Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                                                      newrec_.order_no, 
                                                                      newrec_.line_no, 
                                                                      newrec_.rel_no, 
                                                                      newrec_.line_item_no,
                                                                      '*', 
                                                                      attr_);
   
   tax_line_param_rec_ := Tax_Handling_Order_Util_API.Create_Tax_Line_Param_Rec (company_,
                                                                                 newrec_.contract,
                                                                                 customer_no_,
                                                                                 ship_addr_no_,
                                                                                 newrec_.planned_ship_date,
                                                                                 supply_country_db_,
                                                                                 NVL(newrec_.delivery_type, '*'),
                                                                                 newrec_.catalog_no,
                                                                                 use_price_incl_tax_,
                                                                                 currency_code_,
                                                                                 newrec_.currency_rate,                                                                                       
                                                                                 NULL,
                                                                                 tax_from_defaults_,
                                                                                 newrec_.tax_code,
                                                                                 newrec_.tax_calc_structure_id,
                                                                                 newrec_.tax_class_id,
                                                                                 newrec_.tax_liability,
                                                                                 newrec_.tax_liability_type,
                                                                                 newrec_.country_code,
                                                                                 add_tax_lines_             => TRUE,
                                                                                 net_curr_amount_           => NULL,
                                                                                 gross_curr_amount_         => NULL,
                                                                                 ifs_curr_rounding_         => NULL,
                                                                                 free_of_charge_tax_basis_  => newrec_.free_of_charge_tax_basis,
                                                                                 attr_                      => attr_);
   
   Tax_Handling_Order_Util_API.Add_Transaction_Tax_Info (line_amount_rec_,
                                                         multiple_tax_,
                                                         tax_info_table_,
                                                         tax_line_param_rec_,
                                                         source_key_rec_,
                                                         attr_);
END Add_Transaction_Tax_Info___;

                                  
PROCEDURE Recalculate_Tax_Lines___ (
   newrec_             IN customer_order_line_tab%ROWTYPE,
   company_            IN VARCHAR2,
   customer_no_        IN VARCHAR2,
   ship_addr_no_       IN VARCHAR2,
   supply_country_db_  IN VARCHAR2,
   use_price_incl_tax_ IN VARCHAR2,
   currency_code_      IN VARCHAR2,
   tax_from_defaults_  IN BOOLEAN,
   attr_               IN VARCHAR2)
IS
   source_key_rec_      Tax_Handling_Util_API.source_key_rec;
   tax_line_param_rec_  Tax_Handling_Order_Util_API.tax_line_param_rec;
BEGIN
   source_key_rec_     := Tax_Handling_Util_API.Create_Source_Key_Rec(Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                                                      newrec_.order_no, 
                                                                      newrec_.line_no, 
                                                                      newrec_.rel_no, 
                                                                      newrec_.line_item_no,
                                                                      '*',
                                                                      attr_); 
                                   
   tax_line_param_rec_ := Tax_Handling_Order_Util_API.Create_Tax_Line_Param_Rec (company_,
                                                                                 newrec_.contract,
                                                                                 customer_no_,
                                                                                 ship_addr_no_,
                                                                                 newrec_.planned_ship_date,
                                                                                 supply_country_db_,
                                                                                 newrec_.delivery_type,
                                                                                 newrec_.catalog_no,
                                                                                 use_price_incl_tax_,
                                                                                 currency_code_,
                                                                                 newrec_.currency_rate,                                                                                       
                                                                                 NULL,
                                                                                 tax_from_defaults_,
                                                                                 newrec_.tax_code,
                                                                                 newrec_.tax_calc_structure_id,
                                                                                 newrec_.tax_class_id,
                                                                                 newrec_.tax_liability,
                                                                                 newrec_.tax_liability_type,
                                                                                 newrec_.country_code,
                                                                                 add_tax_lines_             => TRUE,
                                                                                 net_curr_amount_           => NULL,
                                                                                 gross_curr_amount_         => NULL,
                                                                                 ifs_curr_rounding_         => NULL,
                                                                                 free_of_charge_tax_basis_  => newrec_.free_of_charge_tax_basis,
                                                                                 attr_                      => attr_);

   Tax_Handling_Order_Util_API.Recalculate_Tax_Lines (source_key_rec_,
                                                      tax_line_param_rec_,
                                                      attr_);
END Recalculate_Tax_Lines___;

PROCEDURE Build_Rec_For_Copy_Line___ (
   newrec_                      OUT NOCOPY CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   indrec_                      IN OUT NOCOPY Indicator_Rec,
   attr_                        IN OUT NOCOPY VARCHAR2,
   order_line_rec_              IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   copy_order_adresses_         IN BOOLEAN,
   copy_misc_order_info_        IN BOOLEAN,
   copy_delivery_info_          IN BOOLEAN,
   copy_tax_detail_             IN BOOLEAN,
   copy_pricing_                IN BOOLEAN,
   copy_document_texts_         IN BOOLEAN,
   copy_notes_                  IN BOOLEAN,
   same_customer_               IN BOOLEAN,
   use_price_incl_tax_db_       IN VARCHAR2,
   language_code_               IN VARCHAR2)
IS
BEGIN
   Unpack___(newrec_, indrec_,attr_);

   newrec_.supply_site := order_line_rec_.supply_site;

   ----------------------   SM Objects  ------------------------------------------
   newrec_.create_sm_object_option := order_line_rec_.create_sm_object_option;
   newrec_.equipment_object_seq := order_line_rec_.equipment_object_seq;
   newrec_.sup_sm_contract := order_line_rec_.sup_sm_contract;
   newrec_.sup_sm_object := order_line_rec_.sup_sm_object;
   --------------------------------------------------------------------------------

   newrec_.sales_unit_meas := order_line_rec_.sales_unit_meas;
   newrec_.input_qty := order_line_rec_.input_qty;            
   newrec_.input_unit_meas := order_line_rec_.input_unit_meas; 
   newrec_.input_conv_factor := order_line_rec_.input_conv_factor;
   newrec_.input_variable_values := order_line_rec_.input_variable_values;
   newrec_.qty_per_assembly := order_line_rec_.qty_per_assembly;  
   newrec_.revised_qty_due := order_line_rec_.revised_qty_due;

   newrec_.part_ownership := order_line_rec_.part_ownership;  
   IF(newrec_.part_ownership = 'CUSTOMER OWNED')THEN
      newrec_.owning_customer_no := newrec_.customer_no;
   END IF;   
   newrec_.packing_instruction_id := order_line_rec_.packing_instruction_id;
   newrec_.vendor_no := order_line_rec_.vendor_no; 
   newrec_.cust_warranty_id := order_line_rec_.cust_warranty_id;

   IF (same_customer_) THEN      
      -- Sales Part Cross reference Information
      newrec_.catalog_desc := order_line_rec_.catalog_desc;
      newrec_.customer_part_no := order_line_rec_.customer_part_no;
      newrec_.customer_part_unit_meas := order_line_rec_.customer_part_unit_meas;
      newrec_.customer_part_conv_factor :=  order_line_rec_.customer_part_conv_factor;
      newrec_.cust_part_invert_conv_fact := order_line_rec_.cust_part_invert_conv_fact;
      newrec_.customer_part_buy_qty :=  order_line_rec_.customer_part_buy_qty;

      newrec_.conv_factor := order_line_rec_.conv_factor;
      newrec_.classification_standard :=  order_line_rec_.classification_standard;
      newrec_.country_code := order_line_rec_.country_code;   
      newrec_.dock_code := order_line_rec_.dock_code;
      newrec_.sub_dock_code := order_line_rec_.sub_dock_code;

      newrec_.deliver_to_customer_no := order_line_rec_.deliver_to_customer_no;
      newrec_.consignment_stock := order_line_rec_.consignment_stock;

      newrec_.customs_value := order_line_rec_.customs_value;
      newrec_.manufacturing_department := order_line_rec_.manufacturing_department;
      newrec_.delivery_sequence := order_line_rec_.delivery_sequence;
      newrec_.end_customer_id := order_line_rec_.end_customer_id;
      newrec_.location_no := order_line_rec_.location_no;
      newrec_.rel_mtrl_planning := order_line_rec_.rel_mtrl_planning;
      newrec_.receiving_advice_type := order_line_rec_.receiving_advice_type;
      newrec_.self_billing := order_line_rec_.self_billing;
      newrec_.blocked_for_invoicing := order_line_rec_.blocked_for_invoicing;
      newrec_.contact := order_line_rec_.contact;
   END IF;

   -- Copy Address Infomation retated attributes.
   IF (copy_order_adresses_) THEN  
      newrec_.default_addr_flag := order_line_rec_.default_addr_flag;
      newrec_.ship_addr_no := order_line_rec_.ship_addr_no;        
      newrec_.addr_flag := order_line_rec_.addr_flag;  
   END IF;
   
   -- Copy Misc Order Information related attributes
   IF (copy_misc_order_info_) THEN
      newrec_.region_code := order_line_rec_.region_code;  
      newrec_.district_code := order_line_rec_.district_code;         
   END IF;
   
   -- Copy Delivery Information
   IF (copy_delivery_info_) THEN
      newrec_.ship_via_code := order_line_rec_.ship_via_code;
      newrec_.delivery_terms := order_line_rec_.delivery_terms;        
      newrec_.del_terms_location := order_line_rec_.del_terms_location;
      newrec_.route_id := order_line_rec_.route_id;
      newrec_.forward_agent_id := order_line_rec_.forward_agent_id;
      newrec_.delivery_leadtime := order_line_rec_.delivery_leadtime;
      newrec_.picking_leadtime := order_line_rec_.picking_leadtime;         
      newrec_.cust_calendar_id := order_line_rec_.cust_calendar_id;
      newrec_.ext_transport_calendar_id := order_line_rec_.ext_transport_calendar_id;
      newrec_.shipment_type := order_line_rec_.shipment_type;
      newrec_.shipment_creation := order_line_rec_.shipment_creation;
      newrec_.intrastat_exempt := order_line_rec_.intrastat_exempt;
      newrec_.supplier_ship_via_transit := order_line_rec_.supplier_ship_via_transit;
      newrec_.supplier_ship_via_transit_desc := Mpccom_Ship_Via_API.Get_Description(newrec_.supplier_ship_via_transit, language_code_);    
   END IF;
   
   -- Copy Tax Related Attributes
   IF (copy_tax_detail_) THEN
      newrec_.tax_id_no := order_line_rec_.tax_id_no;
      newrec_.tax_id_validated_date := order_line_rec_.tax_id_validated_date;
      newrec_.tax_class_id := order_line_rec_.tax_class_id;
      newrec_.tax_code := order_line_rec_.tax_code;
      newrec_.tax_liability := order_line_rec_.tax_liability;
      newrec_.tax_liability_type := order_line_rec_.tax_liability_type;
      newrec_.tax_calc_structure_id := order_line_rec_.tax_calc_structure_id;
   END IF;
   -- Copy Pricing related attributes
   IF (copy_pricing_) THEN
      newrec_.calc_char_price := order_line_rec_.calc_char_price;
      newrec_.char_price := order_line_rec_.char_price;
      newrec_.provisional_price := order_line_rec_.provisional_price;
      newrec_.price_freeze := order_line_rec_.price_freeze;
      newrec_.free_of_charge_tax_basis := order_line_rec_.free_of_charge_tax_basis;
      newrec_.rebate_builder := order_line_rec_.rebate_builder;
      newrec_.price_effectivity_date := order_line_rec_.price_effectivity_date;
      newrec_.price_unit_meas := order_line_rec_.price_unit_meas;
      newrec_.price_source := Pricing_source_API.DB_COPIED;
      newrec_.price_source_id := NULL;
      newrec_.price_source_net_price := order_line_rec_.price_source_net_price;
      newrec_.customer_level := order_line_rec_.customer_level;
      newrec_.customer_level_id := order_line_rec_.customer_level_id;
      newrec_.part_level := order_line_rec_.part_level;
      newrec_.part_level_id := order_line_rec_.part_level_id;
      newrec_.free_of_charge := order_line_rec_.free_of_charge;
      newrec_.part_price := order_line_rec_.part_price;
      newrec_.discount := 0;
      IF (newrec_.free_of_charge = Fnd_Boolean_API.DB_TRUE) THEN
         newrec_.part_price:= 0;
         newrec_.sale_unit_price := 0;
         newrec_.base_sale_unit_price:=0;
         newrec_.base_unit_price_incl_tax := 0;
         newrec_.unit_price_incl_tax := 0;
      ELSE
         IF (use_price_incl_tax_db_ = Fnd_Boolean_API.DB_TRUE) THEN
            newrec_.unit_price_incl_tax := order_line_rec_.unit_price_incl_tax;
         ELSE
            newrec_.sale_unit_price := order_line_rec_.sale_unit_price;
         END IF;
      END IF;
   END IF;
   

   IF (copy_document_texts_) THEN
      newrec_.note_id := order_line_rec_.note_id;
   END IF;

   IF (copy_notes_) THEN
      newrec_.note_text := order_line_rec_.note_text;
   END IF;
END Build_Rec_For_Copy_Line___;

PROCEDURE Copy_Order_Line_Address___ (from_order_no_     IN VARCHAR2,
                                   from_line_no_      IN VARCHAR2,
                                   from_rel_no_       IN VARCHAR2,
                                   from_line_item_no_ IN NUMBER,
                                   to_order_no_       IN VARCHAR2,
                                   to_line_no_        IN VARCHAR2,
                                   to_rel_no_         IN VARCHAR2,
                                   to_line_item_no_   IN NUMBER)
IS
   line_addr_rec_      cust_order_line_address_tab%ROWTYPE;
   attr_               VARCHAR2(2000);
   info_               VARCHAR2(2000);
   objid_              VARCHAR2(2000);
   objversion_         VARCHAR2(2000);
   line_rec_           customer_order_line_tab%ROWTYPE;
 
   CURSOR get_order_line_address IS
      SELECT *
      FROM cust_order_line_address_tab
      WHERE order_no = from_order_no_
      AND   line_no = from_line_no_
      AND   rel_no = from_rel_no_
      AND   line_item_no = from_line_item_no_;   
BEGIN
   OPEN get_order_line_address;
   FETCH get_order_line_address INTO line_addr_rec_;
   IF (get_order_line_address%FOUND) THEN
      Client_SYS.Add_To_Attr('ORDER_NO', to_order_no_, attr_);
      Client_SYS.Add_To_Attr('LINE_NO', to_line_no_, attr_);
      Client_SYS.Add_To_Attr('REL_NO', to_rel_no_, attr_);
      Client_SYS.Add_To_Attr('LINE_ITEM_NO', to_line_item_no_, attr_);
      Client_SYS.Add_To_Attr('ADDR_1', line_addr_rec_.addr_1, attr_);
      Client_SYS.Add_To_Attr('ADDRESS1', line_addr_rec_.address1, attr_);
      Client_SYS.Add_To_Attr('ADDRESS2', line_addr_rec_.address2, attr_);
      Client_SYS.Add_To_Attr('ADDRESS3', line_addr_rec_.address3, attr_);
      Client_SYS.Add_To_Attr('ADDRESS4', line_addr_rec_.address4, attr_);
      Client_SYS.Add_To_Attr('ADDRESS5', line_addr_rec_.address5, attr_);
      Client_SYS.Add_To_Attr('ADDRESS6', line_addr_rec_.address6, attr_);      
      Client_SYS.Add_To_Attr('ZIP_CODE', line_addr_rec_.zip_code, attr_);
      Client_SYS.Add_To_Attr('CITY', line_addr_rec_.city, attr_);
      Client_SYS.Add_To_Attr('STATE', line_addr_rec_.state, attr_);
      Client_SYS.Add_To_Attr('COUNTRY_CODE', line_addr_rec_.country_code, attr_);
      Client_SYS.Add_To_Attr('COUNTY', line_addr_rec_.county, attr_);
      Cust_Order_Line_Address_API.New__(info_, objid_, objversion_, attr_, 'DO'); 
      CLOSE get_order_line_address;
   ELSE
      CLOSE get_order_line_address;
      line_rec_ := Get_Object_By_Keys___(to_order_no_, to_line_no_, to_rel_no_, to_line_item_no_);
      Insert_Default_Address___(line_rec_.order_no, line_rec_.line_no, line_rec_.rel_no, line_rec_.line_item_no, line_rec_.customer_no, line_rec_.ship_addr_no, line_rec_.deliver_to_customer_no);
   END IF;
END Copy_Order_Line_Address___;
   
PROCEDURE Copy_Staged_Billing___ (
   order_no_             IN VARCHAR2,
   line_no_              IN VARCHAR2,
   rel_no_               IN VARCHAR2,
   line_item_no_         IN NUMBER,
   con_order_no_         IN VARCHAR2,   
   con_line_no_          IN VARCHAR2,
   con_rel_no_           IN VARCHAR2,
   con_line_item_no_     IN NUMBER,
   copy_document_texts_  IN BOOLEAN,
   copy_notes_           IN BOOLEAN )
IS
  -- values for stage billing from newly created customer order lines
  CURSOR get_new_line_rec IS
       SELECT buy_qty_due, discount, order_discount, price_conv_factor, base_sale_unit_price, base_unit_price_incl_tax, additional_discount,
              sale_unit_price,unit_price_incl_tax, currency_rate
       FROM  customer_order_line_tab
       WHERE order_no = order_no_
       AND   line_no = line_no_
       AND   rel_no = rel_no_
       AND   line_item_no = line_item_no_;
 
   order_rec_                 Customer_Order_API.Public_Rec;
   company_                   SITE_TAB.company%TYPE;
   rounding_                  NUMBER := 0;
   curr_rounding_             NUMBER := 0;
   line_discount_             NUMBER := 0;
   sale_price_incl_tax_       NUMBER := 0;
   sales_price_               NUMBER := 0;
   discount_amount_           NUMBER := 0;
   line_gross_                NUMBER := 0;   
   line_net_                  NUMBER := 0;
   line_qty_                  NUMBER ;
            
BEGIN
   Order_Line_Staged_Billing_API.Copy_Stages_From_Co_line(order_no_,
                                                         line_no_,
                                                         rel_no_,
                                                         line_item_no_,
                                                         con_order_no_,   
                                                         con_line_no_,
                                                         con_rel_no_,
                                                         con_line_item_no_,
                                                         copy_document_texts_,
                                                         copy_notes_);
   order_rec_  := Customer_Order_API.Get(order_no_);
   company_ := Site_API.Get_Company(order_rec_.contract);
   rounding_      := Currency_Code_API.Get_Currency_Rounding(company_, Company_Finance_API.Get_Currency_Code(company_));
   curr_rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, order_rec_.currency_code);
   -- For all new lines recalculate the stage billing values.
   FOR stage_rec_ IN get_new_line_rec LOOP        
      line_discount_ := Cust_Order_Line_Discount_API.Get_Total_Line_Discount(order_no_, line_no_, rel_no_, line_item_no_,
                                                             stage_rec_.buy_qty_due, stage_rec_.price_conv_factor,  curr_rounding_);
      IF order_rec_.use_price_incl_tax = 'TRUE' THEN
         -- NOTE: Calculations are done using order currency, then final values are converted to base currency.
         sale_price_incl_tax_ := stage_rec_.buy_qty_due * stage_rec_.price_conv_factor * stage_rec_.unit_price_incl_tax;
         discount_amount_     := ROUND(sale_price_incl_tax_,curr_rounding_) - ROUND(( sale_price_incl_tax_ -line_discount_) * (1-(stage_rec_.order_discount + stage_rec_.additional_discount)), curr_rounding_);
         sale_price_incl_tax_ := ROUND(sale_price_incl_tax_, curr_rounding_);
         line_gross_          := ROUND((sale_price_incl_tax_ - discount_amount_) * stage_rec_.currency_rate, rounding_);
      ELSE
      -- NOTE: Calculations are done using order currency, then final values are converted to base currency.
         sales_price_     := stage_rec_.buy_qty_due * stage_rec_.price_conv_factor * stage_rec_.sale_unit_price;

         discount_amount_ := ROUND(sales_price_,curr_rounding_) - ROUND(( sales_price_ - line_discount_) * (1-(stage_rec_.order_discount + stage_rec_.additional_discount)),curr_rounding_);
         sales_price_     := ROUND(sales_price_, curr_rounding_);
         line_net_        := ROUND((sales_price_ - discount_amount_) * stage_rec_.currency_rate, rounding_);
      END IF;
      line_qty_ := stage_rec_.buy_qty_due;

      Order_Line_Staged_Billing_API.Recalculate(order_no_, line_no_, rel_no_, line_item_no_,
                                                line_net_, line_net_, line_gross_, line_gross_, line_qty_, line_qty_, order_rec_.use_price_incl_tax);
   END LOOP;                                                         
END Copy_Staged_Billing___;  

FUNCTION Internal_Co_Line_Exists___(
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN BOOLEAN
IS
   po_order_no_    VARCHAR2(12);
   po_line_no_     VARCHAR2(4);
   po_rel_no_      VARCHAR2(4);
   purchase_type_  VARCHAR2(30);
   dummy_          NUMBER;
      
   CURSOR internal_co_exists(po_order_no_ IN VARCHAR2, po_line_no_ IN VARCHAR2, po_rel_no_ IN VARCHAR2) IS
      SELECT 1
        FROM customer_order_line_tab
       WHERE demand_order_ref1 = po_order_no_
         AND demand_order_ref2 = po_line_no_
         AND demand_order_ref3 = po_rel_no_
         AND rowstate != 'Cancelled';
BEGIN
   
   Customer_Order_Pur_Order_API.Get_Purord_For_Custord(po_order_no_,
                                                       po_line_no_,
                                                       po_rel_no_,
                                                       purchase_type_,
                                                       order_no_,
                                                       line_no_,
                                                       rel_no_,
                                                       line_item_no_);

   IF (po_order_no_ IS NOT NULL) THEN
      OPEN internal_co_exists (po_order_no_, po_line_no_, po_rel_no_);
      FETCH internal_co_exists INTO dummy_;
      IF (internal_co_exists%FOUND) THEN
         CLOSE internal_co_exists;
         RETURN (TRUE);
      END IF;
      CLOSE internal_co_exists;      
   END IF;   
   RETURN (FALSE);
END Internal_Co_Line_Exists___;

PROCEDURE Raise_No_Update_Error___
IS
BEGIN
   Error_SYS.Record_General(lu_name_, 'UPDATE_NOT_ALLOWED: Updates are not allowed, as any alteration should be handled either from the Service itself or by creating a credit invoice.');
END Raise_No_Update_Error___;

PROCEDURE Raise_No_Update_Fsm_Error___
IS
BEGIN
   Error_SYS.Record_General(lu_name_, 'UPDATE_NOT_ALLOWED_FSM: Updates are not allowed on the order lines created from Field Service Management.');
END Raise_No_Update_Fsm_Error___;

PROCEDURE Raise_Sm_Object_Error___ 
IS
BEGIN
   Error_SYS.Record_General(lu_name_, 'SMOBJNULL: Superior SM Object cannot be empty when Superior SM Site have a value.');
END Raise_Sm_Object_Error___;   

PROCEDURE Raise_Scrapped_Object_Error___ (
   sup_sm_object_ IN VARCHAR2 )
IS 
BEGIN
   Error_SYS.Record_General(lu_name_, 'SMSCRAPPED: It is not possible to add objects belonging to a scrapped object :P1.', sup_sm_object_);
END Raise_Scrapped_Object_Error___;   
   
PROCEDURE Raise_Sales_Qty_Less_Error___ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General(lu_name_, 'NOLESSQTYCOL: The sales quantity may not be less than the sum of the reserved/picked quantity and the delivered quantity of customer order :P1-:P2-:P3.', order_no_, line_no_, rel_no_);
END Raise_Sales_Qty_Less_Error___;   

PROCEDURE Raise_Prepay_Amount_Error___
IS
BEGIN
   Error_SYS.Record_General(lu_name_, 'PREPAYEXCEED: The prepayment amount is larger than the CO gross amount/curr including charges.');         
END Raise_Prepay_Amount_Error___;   

PROCEDURE Raise_Info_Message___
IS
BEGIN
   Client_SYS.Add_Info(lu_name_, 'SETNOAUTOCREATION: According to the shipment creation method, the line should be connected to a shipment at pick list creation. '||
                        'This will not happen for a non-inventory part, since it is never included in a pick list. A non-inventory part must be manually connected to a Shipment.');  
END Raise_Info_Message___;

PROCEDURE Raise_Delnote_Info_Message___
IS
BEGIN
   Client_SYS.Add_Info(lu_name_, 'PREL_DELNOTE_CREATE1: Preliminary Delivery Note is already created. IF the Delivery Note is already printed the delivery information needs to be updated manually.'); 
END Raise_Delnote_Info_Message___;

-- Get_Price_Total___
--   Retrive the total sale price for the specified order line.
--   If price_in_base_curr_ is false then total price is calculated in order currency
--   If price_in_base_curr_ is true total price is calculated in base currency
@UncheckedAccess
FUNCTION Get_Price_Total___ (
   order_no_              IN VARCHAR2,
   line_no_               IN VARCHAR2,
   rel_no_                IN VARCHAR2,
   line_item_no_          IN NUMBER,
   rental_chargable_days_ IN NUMBER,
   exclude_item_          IN VARCHAR2,
   price_in_base_curr_    IN BOOLEAN ) RETURN NUMBER
IS
   currency_code_             VARCHAR2(3);
   company_                   VARCHAR2(20);
   total_net_amount_          NUMBER;
   net_amount_                NUMBER := 0;
   net_amount_sum_            NUMBER := 0;
   new_rental_chargable_days_ NUMBER;
   total_discount_amount_     NUMBER;
   rounding_                  NUMBER;
   gross_curr_amount_         NUMBER;
   total_gross_amount_        NUMBER;
   line_discount_amount_      NUMBER;
   additional_disc_amount_    NUMBER;
   order_discount_amount_     NUMBER;
   total_amount_              NUMBER;
   tax_amount_                NUMBER := 0;
   contract_                  customer_order_line_tab.contract%TYPE;
   free_of_charge_            customer_order_line_tab.free_of_charge%TYPE;
   rental_                    customer_order_line_tab.rental%TYPE;
   buy_qty_due_               customer_order_line_tab.buy_qty_due%TYPE;
   price_conv_factor_         customer_order_line_tab.price_conv_factor%TYPE;
   additional_discount_       customer_order_line_tab.additional_discount%TYPE;
   order_discount_            customer_order_line_tab.order_discount%TYPE;
   tax_liability_type_        customer_order_line_tab.tax_liability_type%TYPE;
   use_price_incl_tax_        customer_order_tab.use_price_incl_tax%TYPE;   
   currency_rate_             NUMBER;
   base_rounding_             NUMBER;
   fetched_line_no_           CUSTOMER_ORDER_LINE_TAB.line_no%TYPE;
   fetched_rel_no_            CUSTOMER_ORDER_LINE_TAB.rel_no%TYPE;
   fetched_line_item_no_      CUSTOMER_ORDER_LINE_TAB.line_item_no%TYPE;
   rental_db_                 CUSTOMER_ORDER_LINE_TAB.rental%TYPE;
  
   CURSOR get_co_header_info IS
      SELECT contract, use_price_incl_tax, currency_code       
      FROM   customer_order_tab
      WHERE  order_no = order_no_;
   
   CURSOR get_co_line_info IS
      SELECT buy_qty_due * price_conv_factor * sale_unit_price total_net_amount, buy_qty_due * price_conv_factor * unit_price_incl_tax total_gross_amount,
             rental, buy_qty_due, price_conv_factor, additional_discount, order_discount, tax_liability_type,
             currency_rate, line_no, rel_no, line_item_no, rental
      FROM   customer_order_line_tab
      WHERE  order_no     = order_no_
      AND    (line_no = line_no_ OR line_no_ IS NULL)
      AND    (rel_no = rel_no_ OR rel_no_ IS NULL)
      AND    (line_item_no = line_item_no_ 
              OR (line_item_no_ IS NULL AND line_item_no <= 0 AND rowstate != 'Cancelled'))
      AND    (exclude_item_ = 'FALSE' OR (exclude_item_ = 'TRUE' AND charged_item != 'ITEM NOT CHARGED' AND exchange_item != 'EXCHANGED ITEM'))
      AND    free_of_charge != free_of_charge_;
BEGIN
   free_of_charge_ := Fnd_Boolean_API.DB_TRUE;
   OPEN  get_co_line_info;
   FETCH get_co_line_info  INTO total_net_amount_, total_gross_amount_, rental_, buy_qty_due_, price_conv_factor_,
                                additional_discount_, order_discount_, tax_liability_type_,
                                currency_rate_, fetched_line_no_, fetched_rel_no_, fetched_line_item_no_, rental_db_;
   WHILE get_co_line_info%FOUND LOOP
      IF (currency_code_ IS NULL) THEN
         OPEN  get_co_header_info;
         FETCH get_co_header_info INTO contract_, use_price_incl_tax_, currency_code_;
         CLOSE get_co_header_info;
         company_       := Site_API.Get_Company(contract_);
         rounding_      := Currency_Code_API.Get_Currency_Rounding(company_, currency_code_);
         base_rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, Company_Finance_API.Get_Currency_Code(company_));
      END IF;
      new_rental_chargable_days_ := Get_Rental_Chargeable_Days(order_no_, fetched_line_no_, fetched_rel_no_, fetched_line_item_no_, rental_db_);

      IF (use_price_incl_tax_  = 'TRUE') THEN
         total_gross_amount_  := ROUND((total_gross_amount_ * new_rental_chargable_days_), rounding_);
         total_amount_        := total_gross_amount_;        
      ELSE
         new_rental_chargable_days_ := NVL(rental_chargable_days_, new_rental_chargable_days_);
         total_net_amount_    := total_net_amount_ * new_rental_chargable_days_;
         total_amount_        := total_net_amount_;        
      END IF;     

      -- fetch discount amounts
      line_discount_amount_   := Cust_Order_Line_Discount_API.Get_Total_Line_Discount( order_no_, 
                                                                                       fetched_line_no_, 
                                                                                       fetched_rel_no_, 
                                                                                       fetched_line_item_no_, 
                                                                                       buy_qty_due_, 
                                                                                       price_conv_factor_, 
                                                                                       rounding_ );
      additional_disc_amount_ := ROUND(((total_amount_ - line_discount_amount_) * additional_discount_/100 ), rounding_);
      order_discount_amount_  := ROUND(((total_amount_ - line_discount_amount_) * order_discount_/100), rounding_);
      total_discount_amount_  := line_discount_amount_ + additional_disc_amount_ +  order_discount_amount_;

      -- calculate net_amount_
      IF (use_price_incl_tax_  = 'TRUE') THEN
         gross_curr_amount_   := total_gross_amount_ - total_discount_amount_;
         IF (tax_liability_type_ = 'EXM') THEN
            -- No tax paid for this order line
            tax_amount_ := 0;
         ELSE
            tax_amount_ := Source_Tax_Item_API.Get_Total_Tax_Curr_Amount(company_, 
                                                                         Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                                                         order_no_,
                                                                         fetched_line_no_,
                                                                         fetched_rel_no_,
                                                                         TO_CHAR(fetched_line_item_no_),
                                                                         '*');
         END IF;      
         tax_amount_ := ROUND(tax_amount_, rounding_);     
         net_amount_ := gross_curr_amount_ - NVL(tax_amount_, 0);
      ELSE 
         total_net_amount_  := ROUND(total_net_amount_, rounding_);
         net_amount_        := total_net_amount_ - total_discount_amount_;
      END IF;
      IF price_in_base_curr_ THEN
            net_amount_ := ROUND(net_amount_ * currency_rate_, base_rounding_);
      END IF;
      net_amount_sum_ := net_amount_sum_ + net_amount_;

      FETCH get_co_line_info  INTO total_net_amount_, total_gross_amount_, rental_, buy_qty_due_, price_conv_factor_,
                                additional_discount_, order_discount_, tax_liability_type_,
                                currency_rate_, fetched_line_no_, fetched_rel_no_, fetched_line_item_no_, rental_db_;

   END LOOP;
   CLOSE get_co_line_info;
   RETURN net_amount_sum_;
END Get_Price_Total___;   

-- Check_And_Add_To_Shipment___
-- When the criteria is met for a the CO Line to be connected to a shipment line, calls Shipment_Handling_Utility_API.Add_Source_Line_To_Shipment.
PROCEDURE Check_And_Add_To_Shipment___(
   line_rec_        IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   header_rowstate_ IN VARCHAR2)
IS
   shipment_id_     NUMBER;
   shipment_id_tab_ Shipment_API.Shipment_Id_Tab;
BEGIN   
   IF (line_rec_.shipment_connected = 'FALSE' AND header_rowstate_ IN ('Released','Reserved','Picked','PartiallyDelivered') AND line_rec_.line_item_no <=0 AND
      line_rec_.shipment_creation NOT IN ('NO_AUTOMATIC', 'PICK_LIST_CREATION') AND line_rec_.supply_code NOT IN ('ND', 'IPD') AND (line_rec_.rowstate != 'Cancelled'))
      THEN
      Shipment_Handling_Utility_API.Add_Source_Line_To_Shipment(shipment_id_              => shipment_id_,
                                                                source_ref1_              => line_rec_.order_no,
                                                                source_ref2_              => line_rec_.line_no,
                                                                source_ref3_              => line_rec_.rel_no,
                                                                source_ref4_              => line_rec_.line_item_no,
                                                                source_ref_type_db_       => Logistics_Source_Ref_Type_API.DB_CUSTOMER_ORDER,
                                                                receiver_type_db_         => Sender_Receiver_Type_API.DB_CUSTOMER,
                                                                shipment_id_tab_          => shipment_id_tab_,
                                                                ignore_existing_shipment_ => 'FALSE');
   END IF;
END Check_And_Add_To_Shipment___;

-- Assign_Rel_Mtrl_Planning___
-- This will assign the Rel_Mtrl_Planning flag according to the entry in site to site reservation setup. If there is no entry in site to site reservation
-- then this falg is always set to TRUE. This mehtod is being called from Check_Insert___() and Check_Before_Update___(). 
PROCEDURE Assign_Rel_Mtrl_Planning___ (
   newrec_            IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   header_rowstate_   IN VARCHAR2 )
IS
   rel_mtrl_planning_ SITE_TO_SITE_RESERVE_SETUP_TAB.rel_mtrl_planning%TYPE;
BEGIN
   IF (Site_To_Site_Reserve_Setup_API.Exists(newrec_.supply_site, newrec_.contract)) THEN  
      rel_mtrl_planning_ := Site_To_Site_Reserve_Setup_API.Get_Rel_Mtrl_Planning_Db(newrec_.supply_site, newrec_.contract);
      IF (rel_mtrl_planning_ = Rel_Mtrl_Planning_API.DB_VISIBLE_PLANNED) THEN
         newrec_.rel_mtrl_planning := 'TRUE';
      ELSIF (header_rowstate_ = 'Released' AND (rel_mtrl_planning_ = Rel_Mtrl_Planning_API.DB_VISIBLE_RELEASED)) THEN
         newrec_.rel_mtrl_planning := 'TRUE';
      ELSE
         newrec_.rel_mtrl_planning := 'FALSE';
      END IF;      
   ELSE
      newrec_.rel_mtrl_planning := 'TRUE';
   END IF;
END Assign_Rel_Mtrl_Planning___;

@IgnoreUnitTest PLSQLInSQL
-- gelr:delivery_types_in_pbi, begin
-- Get_Amt_Ratio_Per_Tax_Deliv___
--   Get the CO line gross amount ratio per tax code and Delivery Type. If the Delivery Type is null It will be calculated per Tax Code
FUNCTION Get_Amt_Ratio_Per_Tax_Deliv___ (
   order_no_      IN VARCHAR2,
   tax_code_      IN VARCHAR2,
   delivery_type_ IN VARCHAR2 DEFAULT NULL) RETURN NUMBER
IS
   gross_amount_ratio_     NUMBER;
   line_count_             NUMBER;
   rec_count_              NUMBER;
   ratio_sum_              NUMBER;
   rounding_               NUMBER;
   ordrec_                 Customer_Order_API.Public_Rec;
   ord_gross_amount_       NUMBER;
   string_null_            VARCHAR2(15) := Database_SYS.string_null_;
   
   CURSOR get_total_lines IS
      SELECT COUNT(COUNT(tax_code))
        FROM PREPAY_TAX_INFO
       WHERE order_no = order_no_
    GROUP BY tax_code, delivery_type;

   CURSOR get_gross_amount IS
      SELECT tax_code,
             delivery_type,
             (SUM(Get_Sale_Price_Total(order_no, line_no, rel_no, line_item_no)) +
              SUM(Get_Total_Tax_Amount_Curr(order_no, line_no, rel_no, line_item_no))) gross_amount
      FROM PREPAY_TAX_INFO
      WHERE order_no = order_no_
      GROUP BY tax_code, delivery_type
      ORDER BY tax_code, delivery_type;
BEGIN
   OPEN get_total_lines;
   FETCH get_total_lines INTO line_count_;
   CLOSE get_total_lines;

   ordrec_           := Customer_Order_API.Get(order_no_);
   rounding_         := Currency_Code_API.Get_Currency_Rounding(Site_API.Get_Company(ordrec_.contract), ordrec_.currency_code);

   rec_count_        := 0;
   ratio_sum_        := 0;
   ord_gross_amount_ := Customer_Order_API.Get_Ord_Gross_Amount(order_no_);
   FOR rec_ IN get_gross_amount LOOP
      rec_count_ := rec_count_ + 1;
      -- Comparison of delivery_type was added to the condition
      IF ((rec_.tax_code = tax_code_) AND 
          NVL(rec_.delivery_type, string_null_) = NVL(delivery_type_, string_null_)) THEN
         IF (rec_count_ != line_count_) THEN
            gross_amount_ratio_ := rec_.gross_amount / ord_gross_amount_;
            RETURN gross_amount_ratio_;
         ELSE
            -- This is to avoid miscalculation of rounding error.
            gross_amount_ratio_ := (1 - ratio_sum_);
            RETURN gross_amount_ratio_;
         END IF;
      END IF;
      ratio_sum_ := ratio_sum_ + (rec_.gross_amount / ord_gross_amount_);
   END LOOP;
END Get_Amt_Ratio_Per_Tax_Deliv___;
-- gelr:delivery_types_in_pbi, end

-------------------- LU SPECIFIC PRIVATE METHODS ----------------------------

@Override
PROCEDURE New__ (
   info_       OUT    VARCHAR2,
   objid_      OUT    VARCHAR2,
   objversion_ OUT    VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   insert_package_mode_ VARCHAR2(5);
   current_info_        VARCHAR2(32000);
   invalid_calendar_info_ VARCHAR2(4000);
BEGIN

   -- Clear all info if user fails to save, the first time and a message will be
   -- printed afterwards
   Client_SYS.Clear_Info;
   current_info_ := NULL;
   App_Context_SYS.Set_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_',current_info_);

   -- Adding dummy attribute to pass INSERT_PACKAGE_MODE_ information.
   insert_package_mode_ := 'FALSE';
   Client_SYS.Add_To_Attr('INSERT_PACKAGE_MODE_', insert_package_mode_, attr_);
   IF (action_ = 'DO') THEN
      Client_SYS.Add_To_Attr('ADD_INFO', 'TRUE', attr_);
   END IF;

   super(info_, objid_, objversion_, attr_, action_);
   insert_package_mode_ := NVL(Client_SYS.Get_Item_Value('INSERT_PACKAGE_MODE_', attr_), 'FALSE');
   -- only set the info if we are not in the insert package loop, in those cases
   -- we skip the info messages for the components
   IF (insert_package_mode_ = 'FALSE') THEN
      current_info_ := App_Context_SYS.Find_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_');
      current_info_ := SUBSTR(current_info_ || info_, 1, 2000);
      App_Context_SYS.Set_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_', current_info_);
      -- Show  App_Context_SYS value stored in key 'CUST_ORD_DATE_CALCULATION_API.INVALID_CALENDAR_INFO_' as info message if available
      Cust_Ord_Date_Calculation_API.Show_Invalid_Calendar_Info(invalid_calendar_info_, 'FALSE');
      IF (LENGTH(current_info_|| invalid_calendar_info_)< 32000) THEN
         current_info_ := NVL(current_info_, 'INFO' || Client_SYS.field_separator_) || invalid_calendar_info_;
      END IF;
   END IF;
   info_ := current_info_;
END New__;


@Override
PROCEDURE Modify__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   newrec_               CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   insert_package_mode_  VARCHAR2(5);
   current_info_         VARCHAR2(32000);
   temp_action_check_    VARCHAR2(5);
   dummy_attr_           VARCHAR2(32000);
   invalid_calendar_info_ VARCHAR2(4000);
BEGIN
   dummy_attr_          := attr_;
   current_info_        := NULL;
   temp_action_check_   := action_;
   App_Context_SYS.Set_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_',current_info_);
   insert_package_mode_ := 'FALSE';
   Client_SYS.Add_To_Attr('INSERT_PACKAGE_MODE_', insert_package_mode_, attr_);
   newrec_              := Get_Object_By_Id___(objid_);

   IF (action_ = 'DO') THEN
      Client_SYS.Add_To_Attr('ADD_INFO',         'TRUE', attr_);
      Client_SYS.Add_To_Attr( 'DEFAULT_CHARGES', 'TRUE', attr_);
      IF (newrec_.supply_code = 'SEO') THEN
         Validate_Update_Service_Con___(dummy_attr_, newrec_.demand_code);
      END IF;
   END IF;

   IF (temp_action_check_ = 'CHECK') THEN
      IF (newrec_.rowstate IN ('Invoiced', 'Cancelled')) THEN
         Error_SYS.Record_General(lu_name_, 'WRONG_STATE: No changes may be made when the order state is Invoiced/Closed or Cancelled.');
      END IF;
   END IF;

   super(info_, objid_, objversion_, attr_, action_);
   current_info_ :=  App_Context_SYS.Find_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_');
   -- Show  App_Context_SYS value stored in key 'CUST_ORD_DATE_CALCULATION_API.INVALID_CALENDAR_INFO_' as info message if available
   Cust_Ord_Date_Calculation_API.Show_Invalid_Calendar_Info(invalid_calendar_info_, 'FALSE');
   IF (LENGTH(current_info_|| invalid_calendar_info_)< 32000) THEN
      current_info_ := NVL(current_info_, 'INFO' || Client_SYS.field_separator_) || invalid_calendar_info_;
   END IF;
   
   info_ := current_info_ || info_;
END Modify__;


@Override
PROCEDURE Remove__ (
   info_       OUT VARCHAR2,
   objid_      IN  VARCHAR2,
   objversion_ IN  VARCHAR2,
   action_     IN  VARCHAR2 )
IS
   remrec_     CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   company_    VARCHAR2(20);
BEGIN
   IF (action_ = 'DO') THEN
      remrec_ := Get_Object_By_Id___(objid_);
   END IF;
   super(info_, objid_, objversion_, action_);
   
   company_ := Site_API.Get_Company(remrec_.contract);
   Source_Tax_Item_Order_API.Remove_Tax_Items(company_,
                                              Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                              remrec_.order_no,
                                              remrec_.line_no,
                                              remrec_.rel_no,
                                              TO_CHAR(remrec_.line_item_no),
                                              '*');
   Customer_Order_Charge_Util_API.Recalc_Percentage_Charge_Taxes(remrec_.order_no, remrec_.line_no, TRUE);
   info_ := Client_SYS.Append_Info(info_);
END Remove__;


-- Get_Sum_Invoiced_Base_Curr__
--   Return the total value of the invoiced items for this order row in
--   the base currency.
@UncheckedAccess
FUNCTION Get_Sum_Invoiced_Base_Curr__ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   CURSOR get_curr_rate IS
      SELECT currency_rate
      FROM  CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = order_no_
      AND   line_no = line_no_
      AND   rel_no = rel_no_
      AND   line_item_no = line_item_no_;

   curr_rate_     NUMBER;
   base_rounding_ NUMBER;
   company_       VARCHAR2(20);
BEGIN
   company_       := Site_API.Get_Company(CUSTOMER_ORDER_API.Get_Contract(order_no_));
   base_rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, Company_Finance_API.Get_Currency_Code(company_));

   OPEN get_curr_rate;
   FETCH get_curr_rate INTO curr_rate_;
   CLOSE get_curr_rate;

   RETURN ROUND( Get_Sum_Invoiced_Order_Curr__(order_no_, line_no_, rel_no_, line_item_no_)*curr_rate_, base_rounding_);
END Get_Sum_Invoiced_Base_Curr__;


-- Get_Sum_Invoiced_Order_Curr__
--   Return the total value of the invoiced items for this order row in
--   the order currency.
@UncheckedAccess
FUNCTION Get_Sum_Invoiced_Order_Curr__ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   sum_           NUMBER;   
   rounding_      NUMBER;

   CURSOR get_line_data IS
      SELECT qty_invoiced, price_conv_factor, sale_unit_price, unit_price_incl_tax,
             order_discount, additional_discount
      FROM  CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = order_no_
      AND   line_no = line_no_
      AND   rel_no = rel_no_
      AND   line_item_no = line_item_no_;

   line_discount_      NUMBER;
   rec_line_           get_line_data%ROWTYPE;
   line_disc_no_tax_   NUMBER;
   total_disc_no_tax_  NUMBER;
   tax_percentage_     NUMBER;
   total_gross_amt_    NUMBER;
   company_            VARCHAR2(20);
   header_rec_         Customer_Order_API.Public_Rec;
BEGIN
   header_rec_ := Customer_Order_API.Get(order_no_); 
   company_    := Site_API.Get_Company(header_rec_.contract);
   rounding_   := Currency_Code_API.Get_Currency_Rounding(company_, header_rec_.currency_code);  

   OPEN get_line_data;
   FETCH get_line_data INTO rec_line_;
   CLOSE get_line_data;
   line_discount_   := Cust_Order_Line_Discount_API.Get_Total_Line_Discount(order_no_, line_no_, rel_no_, line_item_no_,
                                                                            rec_line_.qty_invoiced, rec_line_.price_conv_factor, rounding_);

   IF (header_rec_.use_price_incl_tax  = 'TRUE') THEN
      tax_percentage_     := Source_Tax_Item_API.Get_Total_Tax_Percentage(company_, Tax_Source_API.DB_CUSTOMER_ORDER_LINE, 
                                                                          order_no_, line_no_, rel_no_, TO_CHAR(line_item_no_), '*');
      line_disc_no_tax_   := Cust_Order_Line_Discount_API.Get_Total_Line_Discount(order_no_, line_no_, rel_no_, line_item_no_,
                                                                                  rec_line_.qty_invoiced, rec_line_.price_conv_factor,  rounding_, tax_percentage_ => NVL(tax_percentage_, 0));
      total_gross_amt_    := rec_line_.qty_invoiced * rec_line_.price_conv_factor * rec_line_.unit_price_incl_tax;

      total_disc_no_tax_  := line_disc_no_tax_;
      total_disc_no_tax_  := total_disc_no_tax_ + ROUND (ROUND((total_gross_amt_ - line_discount_) * rec_line_.order_discount, rounding_)/(1+ (tax_percentage_/100)), rounding_); -- Calculating Order discount
      total_disc_no_tax_  := total_disc_no_tax_ + ROUND (ROUND((total_gross_amt_ - line_discount_) * rec_line_.additional_discount, rounding_)/(1+ (tax_percentage_/100)), rounding_); -- Calculating Additional discount

      sum_ := ROUND( total_gross_amt_ /(1+ (tax_percentage_/100)),rounding_ ) - total_disc_no_tax_;

   ELSE
      sum_ := ROUND(((rec_line_.qty_invoiced * rec_line_.price_conv_factor * rec_line_.sale_unit_price) - line_discount_)
                   * (1 - (rec_line_.order_discount + rec_line_.additional_discount) / 100), rounding_) ;
   END IF;
   sum_ := NVL(sum_, 0);

   RETURN sum_;
END Get_Sum_Invoiced_Order_Curr__;


-- Recalc_Package_Structure__
--   Recalculates a package structure after being modifyed
PROCEDURE Recalc_Package_Structure__ (
   order_no_ IN VARCHAR2,
   line_no_  IN VARCHAR2,
   rel_no_   IN VARCHAR2 )
IS
   linerec_               CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   rowid_                 VARCHAR2(2000);
   rowversion_            VARCHAR2(2000);
   insert_package_mode_   VARCHAR2(5);
   block_component_info_  VARCHAR2(5);
BEGIN
   insert_package_mode_   := 'FALSE';
   block_component_info_  := 'FALSE';
   linerec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, -1);
   -- Modify cost for the order line
   Update_Package_Cost___(linerec_.cost, order_no_, line_no_, rel_no_);
   Change_Package_Structure___(linerec_.promised_delivery_date, linerec_.planned_delivery_date,
                               linerec_.planned_ship_date, linerec_.planned_due_date, linerec_, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, insert_package_mode_, block_component_info_, NULL);

   linerec_.qty_assigned :=  Reserve_Customer_Order_API.Get_No_Of_Packages_Reserved(order_no_, line_no_, rel_no_);

   Get_Id_Version_By_Keys___(rowid_, rowversion_, order_no_, line_no_, rel_no_, -1);
   linerec_.rowversion := sysdate;

   Update_Line___(rowid_, linerec_);
END Recalc_Package_Structure__;


-- Get_Cust_Part_No_Defaults__
--   Field validation on column customer_part_no from client.
PROCEDURE Get_Cust_Part_No_Defaults__ (
   info_             OUT    VARCHAR2,
   attr_             IN OUT VARCHAR2,
   order_no_         IN     VARCHAR2,
   customer_part_no_ IN     VARCHAR2 )
IS
   customer_unit_meas_ CUSTOMER_ORDER_LINE_TAB.sales_unit_meas%TYPE;
   cross_rec_          SALES_PART_CROSS_REFERENCE_API.Public_Rec;
   header_rec_         CUSTOMER_ORDER_API.Public_Rec;
BEGIN
   header_rec_ := Customer_Order_API.Get(order_no_);
   Sales_Part_Cross_Reference_API.Exist(header_rec_.customer_no, header_rec_.contract, customer_part_no_);
   cross_rec_   := Sales_Part_Cross_Reference_API.Get(header_rec_.customer_no, header_rec_.contract, customer_part_no_);
   Get_Line_Defaults___(attr_, cross_rec_.catalog_no, order_no_, 1);

   IF (cross_rec_.catalog_desc IS NOT NULL) THEN
      Client_SYS.Set_Item_Value('CATALOG_DESC', cross_rec_.catalog_desc, attr_);
   END IF;

   Client_SYS.Add_To_Attr('CATALOG_NO', cross_rec_.catalog_no, attr_);
   customer_unit_meas_ := NVL(cross_rec_.customer_unit_meas, Client_SYS.Get_Item_Value('SALES_UNIT_MEAS', attr_));
   Client_SYS.Add_To_Attr('CUSTOMER_PART_UNIT_MEAS', customer_unit_meas_, attr_);
   -- Conv Factor may not be less than 0
   Client_SYS.Add_To_Attr('CUSTOMER_PART_CONV_FACTOR', GREATEST(NVL(cross_rec_.conv_factor, 1), 0), attr_);
   Client_SYS.Add_To_Attr('CUST_PART_INVERT_CONV_FACT', cross_rec_.inverted_conv_factor, attr_);
   info_ := Client_SYS.Get_All_Info;
END Get_Cust_Part_No_Defaults__;


-- Modify_Qty_Shipped__
--   Modify the qty_shipped attribute.
--   Should only be called via the Finite State Machine
PROCEDURE Modify_Qty_Shipped__ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_shipped_  IN NUMBER )
IS
   attr_ VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_SHIPPED', qty_shipped_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Qty_Shipped__;


-- Modify_Qty_To_Ship__
--   Modify the qty_to_ship attribute.
PROCEDURE Modify_Qty_To_Ship__ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_to_ship_  IN NUMBER )
IS
   attr_                VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_TO_SHIP', qty_to_ship_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Qty_To_Ship__;


-- Modify_Qty_Assigned__
--   Modify the qty_assigned attribute.
--   Should only be called via the Finite State Machine
PROCEDURE Modify_Qty_Assigned__ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_assigned_ IN NUMBER )
IS
   attr_ VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_ASSIGNED', qty_assigned_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Qty_Assigned__;


-- Modify_Qty_Confirmeddiff__
--   Modify the qty_confirmeddiff attribute.
--   Should only be called via the Finite State Machine
PROCEDURE Modify_Qty_Confirmeddiff__ (
   order_no_          IN VARCHAR2,
   line_no_           IN VARCHAR2,
   rel_no_            IN VARCHAR2,
   line_item_no_      IN NUMBER,
   qty_confirmeddiff_ IN NUMBER )
IS
   attr_ VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_CONFIRMEDDIFF', qty_confirmeddiff_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Qty_Confirmeddiff__;


-- Modify_Qty_Shipdiff__
--   Modify the qty_shipdiff attribute.
--   Should only be called via the Finite State Machine
PROCEDURE Modify_Qty_Shipdiff__ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_shipdiff_ IN NUMBER )
IS
   attr_ VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_SHIPDIFF', qty_shipdiff_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Qty_Shipdiff__;


-- Modify_Qty_Invoiced__
--   Modify the qty_invoiced attribute.
--   Should only be called via the Finite State Machine
PROCEDURE Modify_Qty_Invoiced__ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_invoiced_ IN NUMBER )
IS
   attr_ VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_INVOICED', qty_invoiced_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Qty_Invoiced__;


-- Get_Line_Defaults__
--   Field validation on column catalog_no from client.
PROCEDURE Get_Line_Defaults__ (
   info_       OUT    VARCHAR2,
   attr_       IN OUT VARCHAR2,
   catalog_no_ IN OUT VARCHAR2,
   order_no_   IN     VARCHAR2 )
IS
BEGIN
   Get_Line_Defaults___(attr_, catalog_no_, order_no_, 1);
   info_ := Client_SYS.Get_All_Info;
END Get_Line_Defaults__;


-- Modify_Qty_Picked__
--   Modify the qty_picked attribute.
--   Should only be called via the Finite State Machine
PROCEDURE Modify_Qty_Picked__ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_picked_   IN NUMBER )
IS
   attr_   VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_PICKED', qty_picked_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Qty_Picked__;


-- Modify_Planned_Due_Date__
--   Modify the planned_due_date attribute.
PROCEDURE Modify_Planned_Due_Date__ (
   order_no_         IN VARCHAR2,
   line_no_          IN VARCHAR2,
   rel_no_           IN VARCHAR2,
   line_item_no_     IN NUMBER,
   planned_due_date_ IN DATE )
IS
   attr_   VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('PLANNED_DUE_DATE', planned_due_date_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Planned_Due_Date__;


PROCEDURE Modify_Tax_Id_No_Details__ (
   order_no_               IN VARCHAR2,
   line_no_                IN VARCHAR2,
   rel_no_                 IN VARCHAR2,
   line_item_no_           IN NUMBER,
   tax_id_no               IN VARCHAR2,
   tax_id_validated_date_  IN DATE )
IS
   attr_   VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('tax_id_no', tax_id_no, attr_);
   Client_SYS.Add_To_Attr('TAX_ID_VALIDATED_DATE', tax_id_validated_date_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Tax_Id_No_Details__;


-- Get_Backlog_Value_Base_Curr__
--   Return the total value of NOT invoiced items for this order row in
--   the base currency. The backlog value is calculated as the value of
--   the items ordered but not yet invoiced.
@UncheckedAccess
FUNCTION Get_Backlog_Value_Base_Curr__ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   net_amount_    NUMBER;
   gross_amount_  NUMBER;
BEGIN
   Get_Backlog_Value_Base_Curr___(net_amount_, gross_amount_, order_no_, line_no_, rel_no_, line_item_no_);
   RETURN net_amount_;
END Get_Backlog_Value_Base_Curr__;


-- Get_Backlog_Value_Order_Curr__
--   Return the total value of NOT invoiced items for this order row in
--   the order currency. The backlog value is calculated as the value of the
--   items ordered but not yet invoiced.
@UncheckedAccess
FUNCTION Get_Backlog_Value_Order_Curr__ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   net_amount_   NUMBER;
   gross_amount_ NUMBER;
BEGIN
   Get_Backlog_Value_Ord_Curr___(net_amount_, gross_amount_, order_no_, line_no_, rel_no_, line_item_no_ );
   RETURN net_amount_;
END Get_Backlog_Value_Order_Curr__;


-- Get_Backord_Value_Base_Curr__
--   Return the total value of NOT shipped items for this order row in
--   the base currency. The backorder value is calculated as the value of the
--   items ordered but not yet delivered.
@UncheckedAccess
FUNCTION Get_Backord_Value_Base_Curr__ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   gross_amount_  NUMBER;
   net_amount_    NUMBER;
BEGIN
   Get_Backord_Value_Base_Curr___(net_amount_, gross_amount_, order_no_, line_no_, rel_no_, line_item_no_ );
   RETURN net_amount_;
END Get_Backord_Value_Base_Curr__;

-- Make_Service_Deliverable__
--   Make an order line for a service part or non inventory part deliverable 
--   by setting the qty_to_ship attribute.
PROCEDURE Make_Service_Deliverable__ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   shipment_id_  IN NUMBER )
IS
   ship_deliverable_qty_  NUMBER; 
   order_deliverable_qty_ NUMBER; 
   order_qty_to_ship_     NUMBER;
   order_revised_qty_due_ NUMBER;   
   shipment_line_rec_        Shipment_Line_API.Public_Rec; 
   customer_order_line_rec_  Customer_Order_Line_API.Public_Rec; 
   
BEGIN  
  customer_order_line_rec_ := Customer_Order_Line_API.Get(order_no_, line_no_, rel_no_, line_item_no_);      
   IF (shipment_id_ != 0) THEN      
      shipment_line_rec_ := Shipment_Line_API.Get_By_Source(shipment_id_, order_no_, line_no_, rel_no_, line_item_no_, Logistics_Source_Ref_Type_API.DB_CUSTOMER_ORDER);
      ship_deliverable_qty_ := shipment_line_rec_.inventory_qty - shipment_line_rec_.qty_to_ship; 
      order_revised_qty_due_ := customer_order_line_rec_.revised_qty_due;
      order_qty_to_ship_ := customer_order_line_rec_.qty_to_ship;       
      order_deliverable_qty_ := order_revised_qty_due_ - order_qty_to_ship_;      
      IF (order_deliverable_qty_ > 0) THEN           
         Modify_Qty_To_Ship__(order_no_, line_no_, rel_no_, line_item_no_, (ship_deliverable_qty_ + order_qty_to_ship_ ));
      END IF;  
   ELSE
      ship_deliverable_qty_ := customer_order_line_rec_.revised_qty_due - customer_order_line_rec_.qty_shipped - customer_order_line_rec_.qty_on_order;     
      Modify_Qty_To_Ship__(order_no_, line_no_, rel_no_, line_item_no_, ship_deliverable_qty_); 
   END IF;    
   
   IF (Get_Shipment_Connected_Db(order_no_, line_no_, rel_no_, line_item_no_) = 'TRUE') THEN       
     Shipment_Handling_Utility_API.Modify_Shipment_Qty_To_Ship(order_no_, line_no_, rel_no_, line_item_no_, 'CUSTOMER_ORDER',shipment_id_);
   END IF; 
END Make_Service_Deliverable__;

-- Check_Statutory_Fee__
--   Checks if the statutory_fee exists. If found, print an error message.
--   Used for restricted delete check when removing an statutory_fee (ACCRUL-module).
PROCEDURE Check_Statutory_Fee__ (
   key_list_ IN VARCHAR2 )
IS
   company_  VARCHAR2(20);
   tax_code_ CUSTOMER_ORDER_LINE_TAB.tax_code%TYPE;
   found_    NUMBER;

   CURSOR exist_control IS
      SELECT 1
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  Site_API.Get_Company(contract) = company_
      AND    tax_code = tax_code_;
BEGIN
   company_  := substr(key_list_, 1, instr(key_list_, '^') - 1);
   tax_code_ := substr(key_list_, instr(key_list_, '^') + 1, instr(key_list_, '^' , 1, 2) - (instr(key_list_, '^') + 1));

   OPEN exist_control;
   FETCH exist_control INTO found_;
   IF (exist_control%NOTFOUND) THEN
      found_ := 0;
   END IF;
   CLOSE exist_control;
   IF (found_ = 1) THEN
      Error_SYS.Record_General(lu_name_, 'NO_FEE_CODE: Tax Code :P1 exists on one or several Customer Order(s)', tax_code_);
   END IF;
END Check_Statutory_Fee__;


-- Check_Ship_Via_Code__
--   Checks if the ship_via_code exists. If found, print an error message.
--   Used for restricted delete check when removing a ship_via_code (MPCCOM-module).
PROCEDURE Check_Ship_Via_Code__ (
   key_list_ IN VARCHAR2 )
IS
   language_code_ CUSTOMER_ORDER_TAB.language_code%TYPE;
   ship_via_code_ CUSTOMER_ORDER_LINE_TAB.ship_via_code%TYPE;
   found_         NUMBER;

   CURSOR exist_control IS
      SELECT 1
      FROM   CUSTOMER_ORDER_LINE_TAB col, CUSTOMER_ORDER_TAB co
      WHERE  (col.ship_via_code = ship_via_code_ OR col.supplier_ship_via_transit = ship_via_code_)
      AND    co.order_no = col.order_no;
BEGIN
   ship_via_code_ := SUBSTR(key_list_, 1, INSTR(key_list_, '^') - 1);
   ship_via_code_ := SUBSTR(key_list_, 1, INSTR(key_list_, '^') - 1);

   OPEN exist_control;
   FETCH exist_control INTO found_;
   IF (exist_control%NOTFOUND) THEN
      found_ := 0;
   END IF;
   CLOSE exist_control;
   IF (found_ = 1) THEN
      Error_SYS.Record_General(lu_name_, 'NO_SHIP_VIA: Ship Via Code :P1 for Language :P2 is used on one or several Customer Order(s)', ship_via_code_, language_code_);
   END IF;
END Check_Ship_Via_Code__;


-- Check_Delivery_Terms__
--   Checks if the delivery_term exists. If found, print an error message.
--   Used for restricted delete check when removing a delivery_term (MPCCOM-module).
PROCEDURE Check_Delivery_Terms__ (
   key_list_ IN VARCHAR2 )
IS
   language_code_  CUSTOMER_ORDER_TAB.language_code%TYPE;
   delivery_terms_ CUSTOMER_ORDER_LINE_TAB.delivery_terms%TYPE;
   found_          NUMBER;

   CURSOR exist_control IS
      SELECT 1
      FROM   CUSTOMER_ORDER_LINE_TAB col, CUSTOMER_ORDER_TAB co
      WHERE  co.language_code = language_code_
      AND    col.delivery_terms = delivery_terms_
      AND    co.order_no = col.order_no;
BEGIN
   language_code_  := substr(key_list_, 1, instr(key_list_, '^') - 1);
   delivery_terms_ := substr(key_list_, instr(key_list_, '^') + 1, instr(key_list_, '^' , 1, 2) - (instr(key_list_, '^') + 1));

   OPEN exist_control;
   FETCH exist_control INTO found_;
   IF (exist_control%NOTFOUND) THEN
      found_ := 0;
   END IF;
   CLOSE exist_control;
   IF (found_ = 1) THEN
      Error_SYS.Record_General(lu_name_, 'NO_DEL_TERM: Delivery Term ID :P1 for Language :P2 is used on one or several Customer Order(s)', delivery_terms_, language_code_);
   END IF;
END Check_Delivery_Terms__;


-- Modify_Order_Defaults__
--   Modify order header specific delivery information for all order lines
--   having default_addr_flag set to Yes.
--   Don't call Modify_Line___ here, since we don't want to call Get_All_Info,
--   because this method is called from HEADPKG before Modify__ ends.
PROCEDURE Modify_Order_Defaults__ (
   order_no_                  IN VARCHAR2,
   refresh_vat_free_vat_code_ IN VARCHAR2,
   update_tax_                IN BOOLEAN DEFAULT TRUE)
IS
   oldrec_                    CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   newrec_                    CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   order_rec_                 CUSTOMER_ORDER_API.Public_Rec;
   head_attr_                 VARCHAR2(2000);
   attr_                      VARCHAR2(2000);
   info_added_                BOOLEAN := FALSE;
   line_date_changed_         BOOLEAN := FALSE;
   vat_free_vat_code_fetched_ BOOLEAN := FALSE;
   line_due_date_changed_     BOOLEAN := FALSE;
   indrec_                    Indicator_Rec;
   changed_default_addr_flag_ BOOLEAN := TRUE;

   CURSOR get_order_lines IS
      SELECT rowid objid, ltrim(lpad(to_char(rowversion,'YYYYMMDDHH24MISS'),2000)) objversion, rowstate objstate, price_source, price_source_id             
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE line_item_no <= 0
      AND order_no = order_no_;

   site_date_              DATE;
   customer_agreement_     VARCHAR2(10);
   header_sing_occ_addr_   Customer_Order_Address_API.Cust_Ord_Addr_Rec;
   line_sing_occ_addr_     Cust_Order_Line_Address_API.Co_Line_Addr_Rec;
   attr1_                  VARCHAR2(2000);
   default_addr_flag_      CUSTOMER_ORDER_LINE_TAB.default_addr_flag%TYPE;
   tax_liability_type_db_  TAX_LIABILITY_TAB.tax_liability_type%TYPE;
   vat_free_vat_code_      VARCHAR2(20);
   --packing_instruction_id_ VARCHAR2(25) := NULL;
 --  order_state_            customer_order_tab.rowstate%TYPE;
   insert_package_mode_    VARCHAR2(5);   
BEGIN
   order_rec_           := CUSTOMER_ORDER_API.Get(order_no_);
   --order_state_         := Customer_Order_API.Get_Objstate(order_no_ );
   insert_package_mode_ := 'FALSE';
   tax_liability_type_db_ := Customer_Order_API.Get_Tax_Liability_Type_Db(order_no_);   
   
   IF (tax_liability_type_db_ = 'EXM') THEN
      vat_free_vat_code_         := Customer_Order_Address_API.Get_Vat_Free_Vat_Code(order_no_);
      vat_free_vat_code_fetched_ := TRUE;
   END IF;

   FOR linerec_ IN get_order_lines LOOP
      Client_SYS.Clear_Attr(head_attr_);
      oldrec_ := Lock_By_Id___(linerec_.objid, linerec_.objversion);
      newrec_ := oldrec_;
      
      Build_Attr_For_Modfy_Ord_Def__ (oldrec_,
                                      order_rec_,
                                      vat_free_vat_code_fetched_,
                                      refresh_vat_free_vat_code_,
                                      vat_free_vat_code_,
                                      head_attr_);
       
      Client_SYS.Clear_Attr(attr_);
      -- Only uncheck the default flag if already delivered
      IF (linerec_.objstate IN ('Delivered', 'Invoiced', 'Cancelled')) THEN
         IF (oldrec_.default_addr_flag = 'Y' AND linerec_.objstate != 'Cancelled') THEN         
            IF (Validate_SYS.Is_Changed(oldrec_.region_code, order_rec_.region_code)) THEN          
               Client_SYS.Add_To_Attr('REGION_CODE', order_rec_.region_code, attr_);
               changed_default_addr_flag_ := FALSE;
            END IF;         
            IF (Validate_SYS.Is_Changed(oldrec_.district_code, order_rec_.district_code)) THEN
               Client_SYS.Add_To_Attr('DISTRICT_CODE', order_rec_.district_code, attr_);
               changed_default_addr_flag_ := FALSE;
            END IF;            
            IF (linerec_.objstate != 'Invoiced' AND Validate_SYS.Is_Changed(oldrec_.tax_liability, order_rec_.tax_liability)) THEN
               Client_SYS.Add_To_Attr('TAX_LIABILITY', order_rec_.tax_liability, attr_);
               changed_default_addr_flag_ := FALSE;
            END IF;
         END IF;
         
         IF (changed_default_addr_flag_) THEN
            Client_SYS.Add_To_Attr('DEFAULT_ADDR_FLAG_DB', 'N', attr_);
         END IF;   
      ELSE
         IF (oldrec_.default_addr_flag = 'Y') AND (order_rec_.addr_flag = 'Y') AND (vat_free_vat_code_fetched_)THEN
            IF (Sales_Part_API.Get_Taxable_Db(oldrec_.contract, oldrec_.catalog_no)= Fnd_Boolean_API.DB_TRUE) THEN
               Client_SYS.Set_Item_Value('TAX_CODE', vat_free_vat_code_, head_attr_);
            ELSE
               Client_SYS.Set_Item_Value('TAX_CODE', oldrec_.tax_code, head_attr_);
            END IF;
            Client_SYS.Set_Item_Value('TAX_CLASS_ID', '', head_attr_);
         END IF;
         attr_ := head_attr_;
      END IF;

      site_date_ := Site_API.Get_Site_Date(oldrec_.contract);

      IF (linerec_.price_source = 'AGREEMENT') THEN
         customer_agreement_ := newrec_.price_source_id;
      ELSE
         customer_agreement_ := NULL;
      END IF;
      
      default_addr_flag_ := oldrec_.default_addr_flag;
      IF (default_addr_flag_ = 'N' AND (oldrec_.tax_liability != order_rec_.tax_liability AND linerec_.objstate NOT IN ('Invoiced' , 'Cancelled' )))
         OR (linerec_.objstate = 'Delivered' AND oldrec_.tax_liability != order_rec_.tax_liability AND oldrec_.default_addr_flag = 'Y')THEN          
          Client_SYS.Add_To_Attr('TAX_LIABILITY', order_rec_.tax_liability, attr_);
      END IF;
      
      Client_SYS.Add_To_Attr('INSERT_PACKAGE_MODE_', insert_package_mode_, attr_);
      
      IF NOT update_tax_ THEN
         Client_SYS.Set_Item_Value('UPDATE_TAX', 'FALSE', attr_);
      END IF;
      
      IF (customer_agreement_ IS NOT NULL) THEN
         Client_SYS.Clear_Attr(attr1_);
         Client_SYS.Add_To_Attr('INSERT_PACKAGE_MODE_', insert_package_mode_, attr1_);
         IF (((customer_agreement_ = order_rec_.agreement_id) OR (customer_agreement_ <> order_rec_.agreement_id) OR (order_rec_.agreement_id IS NULL)) AND (default_addr_flag_='N')) THEN
            default_addr_flag_ := 'Y';
            IF ((nvl(order_rec_.route_id, ' ') != nvl(oldrec_.route_id, ' ')) OR
               (nvl(order_rec_.cust_ref, ' ') != nvl(oldrec_.contact, ' ')) OR
               (nvl(order_rec_.forward_agent_id, ' ') != nvl(oldrec_.forward_agent_id, ' ')) OR
               (nvl(order_rec_.ship_via_code, ' ') != nvl(oldrec_.ship_via_code, ' ')) OR
               (nvl(order_rec_.cust_calendar_id, Database_Sys.string_null_) != nvl(oldrec_.cust_calendar_id, Database_Sys.string_null_)) OR
               (nvl(order_rec_.ext_transport_calendar_id, Database_Sys.string_null_) != nvl(oldrec_.ext_transport_calendar_id, Database_Sys.string_null_)) OR
               (order_rec_.delivery_terms != oldrec_.delivery_terms) OR
               (nvl(order_rec_.del_terms_location, ' ') != nvl(oldrec_.del_terms_location, ' ')) OR
               (order_rec_.delivery_leadtime != oldrec_.delivery_leadtime) OR
                (order_rec_.picking_leadtime != oldrec_.picking_leadtime) OR
                (order_rec_.shipment_type!= oldrec_.shipment_type) OR
                (order_rec_.shipment_creation!= oldrec_.shipment_creation) OR
               (nvl(order_rec_.district_code, ' ') != nvl(oldrec_.district_code, ' ')) OR
               (nvl(order_rec_.region_code, ' ') != nvl(oldrec_.region_code, ' ')) OR
               (tax_liability_type_db_ != oldrec_.tax_liability_type) OR
               (order_rec_.intrastat_exempt != oldrec_.intrastat_exempt)) THEN
               default_addr_flag_ := 'N';
            END IF;
             IF (default_addr_flag_ = 'Y') THEN
                IF (oldrec_.addr_flag = 'Y') AND (order_rec_.addr_flag = 'Y') THEN
                   header_sing_occ_addr_ := Customer_Order_Address_API.Get_Cust_Ord_Addr(oldrec_.order_no);
                   line_sing_occ_addr_ := Cust_Order_Line_Address_API.Get_Co_Line_Addr(oldrec_.order_no,oldrec_.line_no,oldrec_.rel_no,oldrec_.line_item_no);
                   IF (nvl(header_sing_occ_addr_.addr_1,' ') != nvl(line_sing_occ_addr_.addr_1,' ')) OR (nvl(header_sing_occ_addr_.addr_2,' ') != nvl(line_sing_occ_addr_.addr_2,' ')) OR (nvl(header_sing_occ_addr_.addr_3,' ') != nvl(line_sing_occ_addr_.addr_3,' ')) OR
                      (nvl(header_sing_occ_addr_.addr_4,' ') != nvl(line_sing_occ_addr_.addr_4,' ')) OR (nvl(header_sing_occ_addr_.addr_5,' ') != nvl(line_sing_occ_addr_.addr_5,' ')) OR (nvl(header_sing_occ_addr_.addr_6,' ') != nvl(line_sing_occ_addr_.addr_6,' ')) OR
                      (nvl(header_sing_occ_addr_.country_code,' ') != nvl(line_sing_occ_addr_.country_code,' ')) OR (nvl(header_sing_occ_addr_.address1,' ') != nvl(line_sing_occ_addr_.address1,' ')) OR (nvl(header_sing_occ_addr_.address2,' ') != nvl(line_sing_occ_addr_.address2,' ')) OR
                      (nvl(header_sing_occ_addr_.zip_code,' ') != nvl(line_sing_occ_addr_.zip_code,' ')) OR (nvl(header_sing_occ_addr_.city,' ') != nvl(line_sing_occ_addr_.city,' ')) OR (nvl(header_sing_occ_addr_.state,' ') != nvl(line_sing_occ_addr_.state,' ')) OR
                      (nvl(header_sing_occ_addr_.county,' ') != nvl(line_sing_occ_addr_.county,' ')) THEN
                      default_addr_flag_ := 'N';
                   END IF;
                ELSIF (oldrec_.addr_flag = 'N' AND order_rec_.addr_flag='N') THEN
                   IF (nvl(oldrec_.ship_addr_no, ' ') != nvl(order_rec_.ship_addr_no, ' ')) THEN
                      default_addr_flag_ := 'N';
                   END IF;
                ELSE
                   default_addr_flag_ := 'N';
                END IF;
             END IF;
             IF (oldrec_.default_addr_flag <> default_addr_flag_) THEN
               Client_SYS.Add_To_Attr('DEFAULT_ADDR_FLAG_DB', default_addr_flag_, attr1_);

               Unpack___(newrec_, indrec_, attr1_);
               Check_Update___(oldrec_, newrec_, indrec_, attr1_);
               Update___(linerec_.objid, oldrec_, newrec_, attr1_, linerec_.objversion);
             END IF;        
             IF (default_addr_flag_ = 'N' AND (oldrec_.tax_liability != order_rec_.tax_liability AND linerec_.objstate NOT IN ('Invoiced' , 'Cancelled' ))) THEN 
               Unpack___(newrec_, indrec_, attr_);
               Check_Update___(oldrec_, newrec_, indrec_, attr_);
               Update___(linerec_.objid, oldrec_, newrec_, attr_, linerec_.objversion);
             END IF;     
         ELSIF (default_addr_flag_='Y') THEN
            Unpack___(newrec_, indrec_, attr_);
            Check_Update___(oldrec_, newrec_, indrec_, attr_);
            Update___(linerec_.objid, oldrec_, newrec_, attr_, linerec_.objversion);
         END IF;
      ELSIF (default_addr_flag_ = 'Y') THEN          
          Unpack___(newrec_, indrec_, attr_);
          Check_Update___(oldrec_, newrec_, indrec_, attr_);
          Update___(linerec_.objid, oldrec_, newrec_, attr_, linerec_.objversion);
      END IF;

      IF NOT info_added_ THEN
         IF (linerec_.objstate IN ('Picked', 'PartiallyDelivered', 'Delivered')) THEN
            -- Check if any attributes that is used on a delivery note has been updated.
            IF (NVL(oldrec_.route_id, ' ') != NVL(order_rec_.route_id, ' ') OR
                NVL(oldrec_.contact, ' ') != NVL(order_rec_.cust_ref, ' ') OR
                NVL(oldrec_.forward_agent_id, ' ') != NVL(order_rec_.forward_agent_id, ' ') OR
                NVL(oldrec_.ship_via_code, ' ') != NVL(order_rec_.ship_via_code, ' ') OR
                NVL(oldrec_.ship_addr_no, ' ') != NVL(order_rec_.ship_addr_no, ' ') OR
                oldrec_.addr_flag != order_rec_.addr_flag) THEN
               info_added_ := TRUE;
            END IF;
         END IF;
      END IF;

      IF (default_addr_flag_ = 'Y') THEN
         IF ((oldrec_.planned_delivery_date != newrec_.planned_delivery_date) OR
             (oldrec_.planned_ship_date != newrec_.planned_ship_date)) THEN
            line_date_changed_ := TRUE;
         END IF;
         IF (trunc(newrec_.planned_due_date) < trunc(site_date_)) THEN
            line_due_date_changed_ := TRUE;
         END IF;
      END IF;
   END LOOP;

   IF info_added_ THEN
      Raise_Delnote_Info_Message___;
   END IF;

   IF (line_date_changed_) THEN
      Client_SYS.Add_Info(lu_name_, 'LINEDATESCHANGED: Planned Delivery Date/Planned Ship Date has been changed on applicable order lines.');
   END IF;

   IF (line_due_date_changed_) THEN
      Client_SYS.Add_Info(lu_name_, 'EARLYLINEDUEDATE: The planned due date is earlier than today''s date in some order lines.');
   END IF;
END Modify_Order_Defaults__;

PROCEDURE Build_Attr_For_Modfy_Ord_Def__ (
   oldrec_                       IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   order_rec_                    IN CUSTOMER_ORDER_API.Public_Rec,
   vat_free_vat_code_fetched_    IN BOOLEAN,
   refresh_vat_free_vat_code_    IN VARCHAR2,
   vat_free_vat_code_            IN VARCHAR2,
   head_attr_                    IN OUT VARCHAR2 )
IS
   packing_instruction_id_ VARCHAR2(50) := NULL;
BEGIN
      IF (NVL(oldrec_.addr_flag, ' ') != NVL(order_rec_.addr_flag, ' ')) THEN
         IF (oldrec_.default_addr_flag = 'Y') THEN 
            Client_SYS.Set_Item_Value('ADDR_FLAG_DB', order_rec_.addr_flag, head_attr_);
         ELSE
            Client_SYS.Set_Item_Value('ADDR_FLAG_DB', oldrec_.addr_flag, head_attr_);
         END IF;
         IF (oldrec_.shipment_type IS NOT NULL) THEN
            IF (order_rec_.addr_flag = 'Y' AND oldrec_.addr_flag = 'N') THEN
               packing_instruction_id_ := Def_Pack_Instruct_Shipment_API.Get_Packing_Instruction_Id(order_rec_.contract, oldrec_.catalog_no, order_rec_.customer_no, NULL);
            ELSE
               IF (order_rec_.addr_flag = 'N' AND oldrec_.addr_flag = 'Y') THEN
                  packing_instruction_id_ := Def_Pack_Instruct_Shipment_API.Get_Packing_Instruction_Id(order_rec_.contract, oldrec_.catalog_no, order_rec_.customer_no, order_rec_.ship_addr_no);
               END IF;
            END IF;
            Client_SYS.Set_Item_Value('PACKING_INSTRUCTION_ID', packing_instruction_id_, head_attr_);
         END IF;
      END IF;

      IF (NVL(oldrec_.ship_addr_no, ' ') != NVL(order_rec_.ship_addr_no, ' ')) THEN
         Client_SYS.Set_Item_Value('SHIP_ADDR_NO', order_rec_.ship_addr_no, head_attr_);
      END IF;

      IF (NVL(oldrec_.contact, ' ') != NVL(order_rec_.cust_ref, ' ')) THEN
         Client_SYS.Set_Item_Value('CONTACT', order_rec_.cust_ref, head_attr_);
      END IF;

      IF (NVL(oldrec_.route_id, ' ') != NVL(order_rec_.route_id, ' ')) THEN
         Client_SYS.Set_Item_Value('ROUTE_ID', order_rec_.route_id, head_attr_);
      END IF;

      IF (NVL(oldrec_.forward_agent_id, ' ') != NVL(order_rec_.forward_agent_id, ' ') ) THEN
         Client_SYS.Set_Item_Value('FORWARD_AGENT_ID', order_rec_.forward_agent_id, head_attr_);
      END IF;

      IF (NVL(oldrec_.ship_via_code, ' ') != NVL(order_rec_.ship_via_code, ' ')) THEN
         Client_SYS.Set_Item_Value('SHIP_VIA_CODE', order_rec_.ship_via_code, head_attr_);
      END IF;

      IF (NVL(oldrec_.cust_calendar_id, Database_Sys.string_null_) != NVL(order_rec_.cust_calendar_id, Database_Sys.string_null_)) THEN
         Client_SYS.Set_Item_Value('CUST_CALENDAR_ID', order_rec_.cust_calendar_id, head_attr_);
      END IF;

      IF (NVL(oldrec_.ext_transport_calendar_id, Database_Sys.string_null_) != NVL(order_rec_.ext_transport_calendar_id, Database_Sys.string_null_)) THEN
         Client_SYS.Set_Item_Value('EXT_TRANSPORT_CALENDAR_ID', order_rec_.ext_transport_calendar_id, head_attr_);
      END IF;

      IF (oldrec_.delivery_terms != order_rec_.delivery_terms) THEN
         Client_SYS.Set_Item_Value('DELIVERY_TERMS', order_rec_.delivery_terms, head_attr_);
      END IF;

      IF (NVL(oldrec_.del_terms_location, ' ') != NVL(order_rec_.del_terms_location, ' ')) THEN
         Client_SYS.Set_Item_Value('DEL_TERMS_LOCATION', order_rec_.del_terms_location, head_attr_);
      END IF;

      IF (oldrec_.delivery_leadtime != order_rec_.delivery_leadtime) THEN
         Client_SYS.Set_Item_Value('DELIVERY_LEADTIME', order_rec_.delivery_leadtime, head_attr_);
      END IF;

      IF (NVL(oldrec_.district_code, ' ') != NVL(order_rec_.district_code, ' ')) THEN
         Client_SYS.Set_Item_Value('DISTRICT_CODE', order_rec_.district_code, head_attr_);
      END IF;

      IF (NVL(oldrec_.region_code, ' ') != NVL(order_rec_.region_code, ' ')) THEN
         Client_SYS.Set_Item_Value('REGION_CODE', order_rec_.region_code, head_attr_);
      END IF;

      IF (oldrec_.tax_liability != order_rec_.tax_liability) THEN
         Client_SYS.Set_Item_Value('TAX_LIABILITY', order_rec_.tax_liability, head_attr_);
         IF (Customer_Order_API.Get_Tax_Liability_Type_Db(oldrec_.order_no) = 'EXM' AND refresh_vat_free_vat_code_ = 'FALSE' AND (NOT vat_free_vat_code_fetched_)) THEN
            Client_SYS.Set_Item_Value('TAX_CODE', '', head_attr_);
         END IF;
      END IF;

      IF (oldrec_.intrastat_exempt != order_rec_.intrastat_exempt) THEN
         Client_SYS.Set_Item_Value('INTRASTAT_EXEMPT_DB', order_rec_.intrastat_exempt, head_attr_);
      END IF;

      IF (oldrec_.shipment_creation != order_rec_.shipment_creation) THEN
--         IF( NOT (order_rec_.shipment_creation = 'ORDER_RELEASE' AND order_state_ != 'Planned')) THEN
         IF( NOT (order_rec_.shipment_creation = 'ORDER_RELEASE' AND order_rec_.rowstate != 'Planned')) THEN
            Client_SYS.Set_Item_Value('SHIPMENT_CREATION_DB', order_rec_.shipment_creation, head_attr_);
         END IF;
      END IF;

      IF (NVL(oldrec_.freight_map_id, ' ') != NVL(order_rec_.freight_map_id, ' ')) THEN
         Client_SYS.Set_Item_Value('FREIGHT_MAP_ID', order_rec_.freight_map_id, head_attr_);
      END IF;

      IF (NVL(oldrec_.zone_id, ' ') != NVL(order_rec_.zone_id, ' ')) THEN
         Client_SYS.Set_Item_Value('ZONE_ID', order_rec_.zone_id, head_attr_);
      END IF;

      IF (NVL(oldrec_.freight_price_list_no, ' ') != NVL(order_rec_.freight_price_list_no, ' ')) THEN
         Client_SYS.Set_Item_Value('FREIGHT_PRICE_LIST_NO', order_rec_.freight_price_list_no, head_attr_);
      END IF;
      
      IF (refresh_vat_free_vat_code_ = 'TRUE')  THEN
         IF vat_free_vat_code_fetched_ THEN
            Client_SYS.Set_Item_Value('TAX_CODE', vat_free_vat_code_, head_attr_);
         END IF;
         Client_SYS.Set_Item_Value('SUPPLY_COUNTRY_CHANGED', 'TRUE', head_attr_);
      END IF;         

      IF ((oldrec_.picking_leadtime != order_rec_.picking_leadtime) AND (oldrec_.rowstate NOT IN('Picked', 'Delivered', 'Invoiced', 'Cancelled'))) THEN
         Client_SYS.Set_Item_Value('PICKING_LEADTIME', order_rec_.picking_leadtime, head_attr_);
      END IF;

      IF (NVL(oldrec_.shipment_type, ' ') != NVL(order_rec_.shipment_type, ' ')) THEN
         Client_SYS.Set_Item_Value('SHIPMENT_TYPE', order_rec_.shipment_type, head_attr_);
--         IF (order_rec_.shipment_type IS NULL AND newrec_.shipment_connected = 'FALSE') THEN
         IF (order_rec_.shipment_type IS NULL AND oldrec_.shipment_connected = 'FALSE') THEN
            packing_instruction_id_ := NULL;
            Client_SYS.Set_Item_Value('PACKING_INSTRUCTION_ID', packing_instruction_id_, head_attr_);
         END IF;
      END IF;

END Build_Attr_For_Modfy_Ord_Def__;




-- Modify_Discount__
--   Update the discount attribute.
PROCEDURE Modify_Discount__ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   discount_     IN NUMBER,
   update_tax_   IN VARCHAR2 DEFAULT 'TRUE' )
IS
   discount_temp_  NUMBER;
   attr_           VARCHAR2(2000);
BEGIN

   Client_SYS.Clear_Attr(attr_);

   IF (discount_ IS NULL) THEN
      discount_temp_ := 0;
   ELSE
      discount_temp_ := discount_;
   END IF;
   Client_SYS.Add_To_Attr('DISCOUNT', discount_temp_, attr_);
   -- gelr:disc_price_rounded, begin
   IF (Customer_Order_API.Get_Discounted_Price_Rounded(order_no_)) THEN
      discount_temp_ := Cust_Order_Line_Discount_API.Calculate_Original_Discount__(order_no_, line_no_, rel_no_, line_item_no_);
      Client_SYS.Add_To_Attr('ORIGINAL_DISCOUNT', NVL(discount_temp_, 0), attr_);
   END IF;  
   -- gelr:disc_price_rounded, end
   Client_SYS.Add_To_Attr('SERVER_DATA_CHANGE', 1, attr_);
   Client_SYS.Add_To_Attr('UPDATE_TAX', update_tax_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Discount__;


-- Modify_Wanted_Delivery_Date__
--   Update the wanted_delivery_date attribute and the planned_delivery_date
PROCEDURE Modify_Wanted_Delivery_Date__ (
   planned_delivery_date_    IN OUT DATE,
   order_no_                 IN     VARCHAR2,
   line_no_                  IN     VARCHAR2,
   rel_no_                   IN     VARCHAR2,
   line_item_no_             IN     NUMBER,
   wanted_delivery_date_     IN     DATE,
   replicate_changes_        IN     VARCHAR2,
   change_request_           IN     VARCHAR2,
   dop_changed_              IN     VARCHAR2,
   price_effec_date_changed_ IN     VARCHAR2,
   disconnect_exp_license_   IN     VARCHAR2,
   changed_attrib_not_in_pol_ IN VARCHAR2)
IS
   attr_    VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('WANTED_DELIVERY_DATE', wanted_delivery_date_, attr_);
   Client_SYS.Add_To_Attr('PLANNED_DELIVERY_DATE', planned_delivery_date_, attr_);
   Client_SYS.Add_To_Attr('REPLICATE_CHANGES', replicate_changes_, attr_);
   Client_SYS.Add_To_Attr('CHANGE_REQUEST', change_request_, attr_);
   Client_SYS.Add_To_Attr('DOP_NEW_QTY_DEMAND', dop_changed_, attr_);
   Client_SYS.Add_To_Attr('UPDATE_PRICE_EFFECTIVE_DATE', price_effec_date_changed_, attr_);
   Client_SYS.Add_To_Attr('DISCONNECT_EXP_LICENSE', disconnect_exp_license_, attr_);
   Client_SYS.Add_To_Attr('CHANGED_ATTRIB_NOT_IN_POL', changed_attrib_not_in_pol_, attr_);
   Client_SYS.Set_Item_Value('SERVER_DATA_CHANGE', 1, attr_);
   Client_SYS.Set_Item_Value('MODIFIED_FROM_HEADER', 1, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
   planned_delivery_date_ := Client_SYS.Attr_Value_To_Date(Client_SYS.Get_Item_Value('PLANNED_DELIVERY_DATE', attr_));
END Modify_Wanted_Delivery_Date__;


-- Modify_Delivery_Address__
-- Update the ship address number and the single occurance address flag
-- This method call from header to update line delivery address to header delivery 
-- addr for line with default info set to no but having same delivery address.
PROCEDURE Modify_Delivery_Address__ (
   message_attr_           IN OUT VARCHAR2,
   order_no_               IN     VARCHAR2,
   line_no_                IN     VARCHAR2,
   rel_no_                 IN     VARCHAR2,
   line_item_no_           IN     NUMBER,
   addr_flag_              IN     VARCHAR2,
   ship_addr_changed_      IN     BOOLEAN,
   refresh_tax_code_       IN     BOOLEAN,
   supply_country_changed_ IN     BOOLEAN,
   update_tax_             IN     BOOLEAN DEFAULT TRUE)
IS
   objid_                     VARCHAR2(2000);
   objversion_                VARCHAR2(2000);
   oldrec_                    CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   newrec_                    CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   insert_package_mode_       VARCHAR2(5) := 'FALSE';
   attr_                      VARCHAR2(2000);
   indrec_                    Indicator_Rec;
   order_rec_                 CUSTOMER_ORDER_API.Public_Rec;
   vat_free_vat_code_         VARCHAR2(20);
   vat_free_vat_code_fetched_ BOOLEAN := FALSE;
   pegged_obj_                VARCHAR2(5); 
   po_order_no_               VARCHAR2(20);
   po_line_no_                VARCHAR2(20);
   po_rel_no_                 VARCHAR2(20);
   purchase_type_db_          VARCHAR2(20);  
   create_poco_auto_          VARCHAR2(5) := 'FALSE';
   tax_liability_type_db_     TAX_LIABILITY_TAB.tax_liability_type%TYPE;
   sales_part_taxable_        SALES_PART_TAB.taxable%TYPE;
BEGIN
   
   order_rec_           := CUSTOMER_ORDER_API.Get(order_no_);
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   oldrec_              := Lock_By_Id___(objid_, objversion_);
   newrec_              := oldrec_;
   
   IF ship_addr_changed_ THEN
      Client_SYS.Set_Item_Value('SHIP_ADDR_NO', order_rec_.ship_addr_no, attr_);
   END IF ;
   
   IF addr_flag_ IS NOT NULL THEN
      Client_SYS.Set_Item_Value('ADDR_FLAG_DB', addr_flag_, attr_);
   END IF ;   
   tax_liability_type_db_ := Customer_Order_API.Get_Tax_Liability_Type_Db(order_no_);  
   sales_part_taxable_ :=  Sales_Part_API.Get_Taxable_Db(oldrec_.contract, oldrec_.catalog_no);  
   IF (refresh_tax_code_ AND tax_liability_type_db_ = 'EXM' AND 
       sales_part_taxable_ = Fnd_Boolean_API.DB_TRUE) AND
       order_rec_.addr_flag = 'Y' THEN
         vat_free_vat_code_ := Customer_Order_Address_API.Get_Vat_Free_Vat_Code(order_no_);
         Client_SYS.Set_Item_Value('TAX_CODE', vat_free_vat_code_, attr_);
         Client_SYS.Set_Item_Value('TAX_CLASS_ID', '', attr_);
         vat_free_vat_code_fetched_ := TRUE;
   END IF;
   
   IF (oldrec_.tax_liability != order_rec_.tax_liability) THEN
      Client_SYS.Set_Item_Value('TAX_LIABILITY', order_rec_.tax_liability, attr_);
      IF (tax_liability_type_db_ = 'EXM' AND 
          sales_part_taxable_ = Fnd_Boolean_API.DB_TRUE AND 
          NOT vat_free_vat_code_fetched_) THEN
         Client_SYS.Set_Item_Value('TAX_CODE', '', attr_);
      END IF;
   END IF;
   IF (supply_country_changed_ = TRUE) THEN
         Client_SYS.Set_Item_Value('SUPPLY_COUNTRY_CHANGED', 'TRUE', attr_);
   END IF;      
  
   Client_SYS.Set_Item_Value('EVALUATE_DEFAULT_INFO', 'TRUE', attr_);
   Client_SYS.Add_To_Attr('INSERT_PACKAGE_MODE_', insert_package_mode_, attr_);
   Client_SYS.Set_Item_Value('COPY_ADDR_TO_LINE', 'TRUE', attr_);
   IF Client_SYS.Get_Item_Value('NON_DEFAULT_ADDR_CHANGE', message_attr_) = 'TRUE' THEN
      Client_SYS.Set_Item_Value('NON_DEFAULT_ADDR_CHANGE', 'TRUE', attr_);
   END IF;

   pegged_obj_ := Check_Address_Replication__(order_no_ ,line_no_ ,rel_no_ ,line_item_no_ );
   IF pegged_obj_ = 'TRUE' THEN 
      Client_SYS.Add_To_Attr('CHANGED_ATTRIB_NOT_IN_POL', 'FALSE', attr_);
      IF (Fnd_Session_API.Is_Odp_Session) THEN
         Client_SYS.Add_To_Attr('REPLICATE_CHANGES', Client_SYS.Get_Item_Value('REPLICATE_CHANGES', attr_), message_attr_);
         Client_SYS.Add_To_Attr('CHANGE_REQUEST', Client_SYS.Get_Item_Value('CHANGE_REQUEST', attr_), message_attr_);
      ELSE
         Client_SYS.Add_To_Attr('REPLICATE_CHANGES', 'TRUE', attr_);
         Client_SYS.Add_To_Attr('CHANGE_REQUEST', 'TRUE', attr_);
      END IF;

      IF Client_SYS.Get_Item_Value('POCO_AUTO', message_attr_) = 'FALSE' THEN
         Customer_Order_Pur_Order_API.Fetch_Po_Info(po_order_no_, po_line_no_, po_rel_no_, purchase_type_db_, create_poco_auto_, order_no_, line_no_, rel_no_, line_item_no_);      
         IF create_poco_auto_ = 'TRUE' THEN
            Client_SYS.Set_Item_Value('POCO_AUTO','TRUE', message_attr_);
         END IF ; 
      END IF;
   END IF ;
   
   IF NOT update_tax_ THEN 
      Client_SYS.Set_Item_Value('UPDATE_TAX', 'FALSE', attr_);
   END IF;

   Unpack___(newrec_, indrec_, attr_);
   Check_Update___(oldrec_, newrec_, indrec_, attr_);
   Update___(objid_, oldrec_, newrec_, attr_, objversion_);
   
   IF Client_SYS.Get_Item_Value('INFO_ADDED', message_attr_) = 'FALSE' THEN
      IF (oldrec_.rowstate IN ('Picked', 'PartiallyDelivered', 'Delivered')) THEN
         -- Check if any attributes that is used on a delivery note has been updated.
         IF (NVL(oldrec_.route_id, ' ') != NVL(order_rec_.route_id, ' ') OR
             NVL(oldrec_.contact, ' ') != NVL(order_rec_.cust_ref, ' ') OR
             NVL(oldrec_.forward_agent_id, ' ') != NVL(order_rec_.forward_agent_id, ' ') OR
             NVL(oldrec_.ship_via_code, ' ') != NVL(order_rec_.ship_via_code, ' ') OR
             NVL(oldrec_.ship_addr_no, ' ') != NVL(order_rec_.ship_addr_no, ' ') OR
             oldrec_.addr_flag != order_rec_.addr_flag) THEN
            Client_SYS.Set_Item_Value('INFO_ADDED','TRUE', message_attr_);
         END IF;
      END IF;
   END IF;

   IF ((oldrec_.planned_delivery_date != newrec_.planned_delivery_date) OR
       (oldrec_.planned_ship_date != newrec_.planned_ship_date)) THEN
         Client_SYS.Set_Item_Value('LINE_DATE_CHANGED','TRUE', message_attr_);
   END IF;
   
   IF (trunc(newrec_.planned_due_date) < trunc(Site_API.Get_Site_Date(oldrec_.contract))) THEN
         Client_SYS.Set_Item_Value('LINE_DUE_DATE_CHANGED','TRUE', message_attr_);
   END IF;
END Modify_Delivery_Address__;


   
FUNCTION Check_Address_Replication__ (
   order_no_ IN VARCHAR2,
   line_no_ IN VARCHAR2,
   rel_no_ IN VARCHAR2,
   line_item_no_ IN VARCHAR2) RETURN VARCHAR2
IS
   dummy_ NUMBER;
   
   CURSOR get_address_replication IS
      SELECT 1   
        FROM CUSTOMER_ORDER_LINE_TAB 
       WHERE rowstate NOT IN ('Delivered', 'Invoiced', 'Cancelled')
         AND order_no = order_no_
         AND line_no      = line_no_
         AND rel_no       = rel_no_
         AND line_item_no = line_item_no_
         AND supply_code IN ('IPD', 'PD')
         AND qty_on_order > 0
         AND EXISTS (SELECT 1
                      FROM CUSTOMER_ORDER_PUR_ORDER_TAB
                       WHERE oe_order_no   = order_no
                       AND oe_line_no      = line_no
                       AND oe_rel_no       = rel_no
                       AND oe_line_item_no = line_item_no
                       AND purchase_type   = 'O' );
BEGIN
   OPEN get_address_replication;
   FETCH get_address_replication INTO dummy_;
   IF (get_address_replication%FOUND) THEN
      CLOSE get_address_replication;
      RETURN 'TRUE';
   END IF;
   CLOSE get_address_replication;
   RETURN 'FALSE';
END Check_Address_Replication__;


-- Check_Cancel_Reason_Ref___
--   Perform validation on the CancelReasonRef reference.
PROCEDURE Check_Cancel_Reason_Ref___ (
   newrec_ IN OUT customer_order_line_tab%ROWTYPE )
IS
BEGIN
   Order_Cancel_Reason_Api.Exist( newrec_.cancel_reason, Reason_Used_By_Api.DB_CUSTOMER_ORDER );
END Check_Cancel_Reason_Ref___;



-- Check_Base_Part_Config__
--   Check that the configuration of the configurable part is set if the order has
--   reached further than to the 'Planned' state.
PROCEDURE Check_Base_Part_Config__ (
   rec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
   pkg_part_   CUSTOMER_ORDER_LINE_TAB.catalog_no%TYPE;
BEGIN
   IF (Part_Catalog_API.Get_Configurable_Db(nvl(rec_.part_no, rec_.catalog_no)) = 'CONFIGURED') THEN
      IF (CUSTOMER_ORDER_API.Get_Objstate(rec_.order_no) NOT IN ('Planned')) THEN
         IF (Order_Config_Util_API.Is_Base_Part_Config_Valid(nvl(rec_.part_no, rec_.catalog_no), rec_.configuration_id) = 0) THEN
            -- if the item is not a header item, we look for it
            IF rec_.line_item_no > 0 THEN
               pkg_part_ := Get_Catalog_No(rec_.order_no, rec_.line_no, rec_.rel_no, -1);
               Error_SYS.Record_General(lu_name_, 'MISSINGCONFIG1: A complete configuration should be defined for the configurable part :P1 in package :P2 as the order is not in Planned state.', rec_.part_no, pkg_part_);
            ELSE
               Error_SYS.Record_General(lu_name_, 'MISSINGCONFIG2: A complete configuration should be defined for the configurable part :P1 as the order is not in Planned state.', rec_.part_no);
            END IF;
         END IF;
      END IF;
   END IF;
END Check_Base_Part_Config__;


-- Modify_Acquisition_Type__
--   Method updates supply_code value, use this method with EXTREME care.
--   Mainly used by method Connect_Customer_Order_API.Connect_To_Ctp_Generated_Order
PROCEDURE Modify_Acquisition_Type__ (
   order_no_       IN VARCHAR2,
   line_no_        IN VARCHAR2,
   rel_no_         IN VARCHAR2,
   line_item_no_   IN NUMBER,
   supply_code_db_ IN VARCHAR2 )
IS
   objid_           VARCHAR2(2000);
   rowversion_      VARCHAR2(2000);
   rec_             CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
BEGIN
   rec_ := Lock_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   rec_.supply_code := supply_code_db_;
   Get_Id_Version_By_Keys___(objid_, rowversion_, order_no_, line_no_, rel_no_, line_item_no_);
   rec_.rowversion := sysdate;

   Update_Line___(objid_, rec_);
END Modify_Acquisition_Type__;


-- Get_Vendor_Contract__
--   Returns the acquisition site for the supplier of a purchase part.
@UncheckedAccess
FUNCTION Get_Vendor_Contract__ (
   vendor_no_   IN VARCHAR2,
   contract_    IN VARCHAR2,
   part_no_     IN VARCHAR2,
   supply_code_ IN VARCHAR2,
   rental_db_   IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_vendor_no_      CUSTOMER_ORDER_LINE_TAB.vendor_no%TYPE;
   vendor_contract_     CUSTOMER_ORDER_LINE_TAB.contract%TYPE := NULL;
BEGIN
   IF (vendor_no_ IS NULL) THEN
      temp_vendor_no_ := Retrieve_Default_Vendor__(contract_, part_no_, supply_code_, rental_db_);
   ELSE
      temp_vendor_no_ := vendor_no_;
   END IF;
   $IF (Component_Purch_SYS.INSTALLED)$THEN
      vendor_contract_ := Supplier_API.Get_Acquisition_Site(temp_vendor_no_);
   $END
   RETURN vendor_contract_;
END Get_Vendor_Contract__;


-- Modify_Additional_Discount__
--   Modifies the additional discount in Customer Order Line,
--   If additonal discount is changed in order header.
PROCEDURE Modify_Additional_Discount__ (
   order_no_            IN VARCHAR2,
   additional_discount_ IN NUMBER )
IS
  attr_                       VARCHAR2(2000);
  rental_period_exists_       BOOLEAN := FALSE;
  tax_method_                 VARCHAR2(50);
  fetch_tax_on_line_update_   BOOLEAN := TRUE;
  company_                    VARCHAR2(50);
 
  CURSOR get_order_lines IS
     SELECT line_no,rel_no,line_item_no, supply_code, rental, demand_code, additional_discount
     FROM   CUSTOMER_ORDER_LINE_TAB
     WHERE  order_no = order_no_
     AND    rowstate NOT IN ('Invoiced', 'Cancelled')
     AND    qty_invoiced = 0;
BEGIN
    company_    := Site_API.Get_Company(Customer_Order_API.Get_Contract(order_no_));
    tax_method_ := Company_Tax_Control_API.Get_External_Tax_Cal_Method_Db(company_);

    -- gelr:br_external_tax_integration, Modified condition to include Avalara Brazil
    IF tax_method_ IN (External_Tax_Calc_Method_API.DB_AVALARA_SALES_TAX, External_Tax_Calc_Method_API.DB_AVALARA_TAX_BRAZIL) THEN
      fetch_tax_on_line_update_ := FALSE;
    END IF;  
          
    Client_SYS.Clear_Attr(attr_);
    FOR  order_line_ IN get_order_lines LOOP
       IF (order_line_.supply_code = 'SEO') THEN
         IF (order_line_.demand_code != 'FSM') THEN
            Raise_No_Update_Error___();
         ELSE
            Raise_No_Update_Fsm_Error___();
         END IF;   
       END IF;
       IF (order_line_.rental = Fnd_Boolean_API.DB_TRUE) THEN
          rental_period_exists_ := Rental_Period_Exists(order_no_,
                                                                                     order_line_.line_no,
                                                                                     order_line_.rel_no,
                                                        order_line_.line_item_no);
          -- If rental period exists go to the next order line,
          -- additional discount is not updated for the current line.
          CONTINUE WHEN rental_period_exists_;
       END IF;
       Client_SYS.Clear_Attr(attr_);
       Client_SYS.Add_To_Attr('ADDITIONAL_DISCOUNT', additional_discount_, attr_);
       
       IF NOT fetch_tax_on_line_update_ THEN
         Client_SYS.Add_To_Attr('UPDATE_TAX', 'FALSE', attr_);
       END IF; 
       
       Modify_Line___(attr_, order_no_, order_line_.line_no, order_line_.rel_no, order_line_.line_item_no);
    END LOOP;
    
    IF NOT fetch_tax_on_line_update_ THEN
       Customer_Order_API.Fetch_External_Tax(order_no_, 'FALSE', 'FALSE' );
    END IF;
    
END Modify_Additional_Discount__;


-- Get_Def_Supplier_Ship_Via__
--   Used by CustomerOrder (ordhead) and SourceOrderLines in the date calculation
--   methods to be able to retreive the correct leadtimes for transit deliveries.
PROCEDURE Get_Def_Supplier_Ship_Via__ (
   supplier_ship_via_transit_ OUT VARCHAR2,
   vendor_no_                 IN  VARCHAR2,
   contract_                  IN  VARCHAR2,
   part_no_                   IN  VARCHAR2,
   supply_code_db_            IN  VARCHAR2,
   rental_db_                 IN  VARCHAR2 )
IS
   supply_site_  VARCHAR2(5);
   dummy_        VARCHAR2(35);
BEGIN
   supply_site_ := Get_Vendor_Contract__(vendor_no_, NULL, NULL, NULL, rental_db_);

   Get_Def_Supplier_Ship_Via___(supplier_ship_via_transit_, dummy_,
      vendor_no_, contract_, supply_site_, part_no_, supply_code_db_, NULL);
END Get_Def_Supplier_Ship_Via__;


-- Validate_Delivery_Conf__
--   Searches all order lines' for the correct Delivery Confirmation settings.
--   If an invalid combination is found, an error message is presented.
--   Called from Order Header.
PROCEDURE Validate_Delivery_Conf__ (
   order_no_                      IN VARCHAR2,
   confirm_deliveries_db_         IN VARCHAR2,
   check_sales_grp_deliv_conf_db_ IN VARCHAR2 )
IS
   CURSOR get_record IS
      SELECT *
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = order_no_
      AND rowstate NOT IN ('Cancelled');

   catalog_group_     VARCHAR2(10);
   pkg_catalog_group_ VARCHAR2(10);
BEGIN
   IF ((confirm_deliveries_db_ = 'TRUE') OR (check_sales_grp_deliv_conf_db_ = 'TRUE')) THEN
      FOR rec_ IN get_record LOOP
         catalog_group_ := Sales_Part_API.Get_Catalog_Group(rec_.contract, rec_.catalog_no);
         -- only send package sales group for component lines
         IF (rec_.line_item_no > 0) THEN
            pkg_catalog_group_ := Sales_Part_API.Get_Catalog_Group(rec_.contract, Get_Catalog_No(rec_.order_no, rec_.line_no, rec_.rel_no, -1));
         ELSE
            pkg_catalog_group_ := NULL;
         END IF;
         Validate_Delivery_Conf___(rec_, FALSE, catalog_group_, pkg_catalog_group_,
            confirm_deliveries_db_, check_sales_grp_deliv_conf_db_, TRUE);
         -- store sales group to next order line - i.e. the package component(s)!
         IF (rec_.line_item_no = -1) THEN
            pkg_catalog_group_ := catalog_group_;
         END IF;
         Check_Demand_Code___(rec_.demand_code, confirm_deliveries_db_, rec_.consignment_stock);
      END LOOP;
   END IF;
END Validate_Delivery_Conf__;


-- Unpeg__
--   Initialtes the unpeg process of the line. Called from the Order Line.
PROCEDURE Unpeg__ (
   info_         OUT VARCHAR2,
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER )
IS
   pegged_order_no_   VARCHAR2(12);
   pegged_line_no_    VARCHAR2(4);
   pegged_rel_no_     VARCHAR2(4);
   purchase_type_     VARCHAR2(50);
   stmt_              VARCHAR2(2000);
   supply_code_db_    VARCHAR2(3);
   current_info_      VARCHAR2(32000);

   CURSOR get_so_rec IS
      SELECT so_order_no, so_release_no, so_sequence_no
      FROM   customer_order_shop_order_tab
      WHERE  oe_order_no = order_no_
      AND    oe_line_no = line_no_
      AND    oe_rel_no = rel_no_
      AND    oe_line_item_no = line_item_no_ ;

   CURSOR get_supply_code IS
      SELECT supply_code
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = order_no_
      AND line_no = line_no_
      AND rel_no = rel_no_
      AND line_item_no = line_item_no_;
BEGIN
  Customer_Order_Pur_Order_API.Get_Purord_For_Custord(pegged_order_no_, pegged_line_no_, pegged_rel_no_, purchase_type_,
                                                       order_no_, line_no_, rel_no_, line_item_no_);

   IF (pegged_order_no_ IS NOT NULL) THEN
      $IF (Component_Purch_SYS.INSTALLED)$THEN
         Purchase_Order_Line_Part_API.Unpeg_Order(pegged_order_no_, pegged_line_no_, pegged_rel_no_, purchase_type_);
      $ELSE
         NULL;
      $END
   ELSE
      FOR rec_ IN get_so_rec LOOP
         stmt_ := '
                   DECLARE
                      dummy_str_ VARCHAR2(12) := NULL;
                      dummy_no_  NUMBER := NULL;
                   BEGIN
                      Shop_Ord_Util_API.Modify_Cust_Ord_Details(  :so_order_no_,
                                                                  :so_release_no_,
                                                                  :so_sequence_no_,
                                                                  dummy_str_,
                                                                  dummy_str_,
                                                                  dummy_str_,
                                                                  dummy_no_,
                                                                  dummy_str_,
                                                                  :demand_code,
                                                                  :qty_on_order );
                   END;';
         @ApproveDynamicStatement(2010-01-14,kayolk)
         EXECUTE IMMEDIATE stmt_ USING
               IN  rec_.so_order_no,
               IN  rec_.so_release_no,
               IN  rec_.so_sequence_no,
               IN  Order_Supply_Type_API.Decode('IO'),
               IN  0;
      END LOOP;
   END IF;

   -- The call to method Unpeg_Line modifies the supply_code of the CO line to IO or NO.
   -- Therefore the old supply_code should be fetched beforehand.
   OPEN get_supply_code;
   FETCH get_supply_code INTO supply_code_db_;
   CLOSE get_supply_code;
   
   Unpeg_Line(order_no_, line_no_, rel_no_, line_item_no_, 'FALSE');

   -- The demand information of the connected PO/PR should only be updated for transit deliveries,
   -- not for direct deliveries, becuase there's a possibility that in a PD or IPD order, a delivery
   -- has already been made. However, for a PD line, where only a PR is created so far, it is not needed
   -- to keep the demand info, thus, in such cases, the demand info would be updated.
   IF ((supply_code_db_ IN ('PT', 'IPT')) OR ((supply_code_db_ = 'PD') AND (Purchase_Type_API.Encode(purchase_type_) = 'R'))) THEN
      Client_SYS.Add_Info(lu_name_, 'CON_POPR_UPDATED: Demand Code on the connected Purchase Order and/or Purchase Requisition has been updated. You may want to check the address related information on Purchase Order/Purchase Requisition :P1.', pegged_order_no_);
   ELSIF (supply_code_db_ IN ('PD', 'IPD')) THEN
      Client_SYS.Add_Info(lu_name_, 'CON_POPR_NOT_UPDATED: This refers to a direct delivery where the connected Purchase Order/Purchase Requisition :P1 will not be updated automatically.', pegged_order_no_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
   current_info_  := App_Context_SYS.Find_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_');
   current_info_  := SUBSTR(current_info_, (INSTR(current_info_, CHR(31))+1), LENGTH(current_info_));
   info_ := info_ || current_info_;
END Unpeg__;


-- Modify_Default_Addr_Flag__
--   Modify the default_addr_flag attribute
PROCEDURE Modify_Default_Addr_Flag__ (
   order_no_          IN VARCHAR2,
   line_no_           IN VARCHAR2,
   rel_no_            IN VARCHAR2,
   line_item_no_      IN NUMBER,
   default_addr_flag_ IN VARCHAR2 )
IS
   attr_   VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('DEFAULT_ADDR_FLAG_DB', default_addr_flag_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Default_Addr_Flag__;


-- Retrieve_Default_Vendor__
--   Dynamic call to receive default vendor_no.
@UncheckedAccess
FUNCTION Retrieve_Default_Vendor__ (
   contract_    IN  VARCHAR2,
   part_no_     IN  VARCHAR2,
   supply_code_ IN  VARCHAR2,
   rental_db_   IN  VARCHAR2 ) RETURN VARCHAR2
IS
   default_vendor_no_ CUSTOMER_ORDER_LINE_TAB.vendor_no%TYPE := NULL;
   vendor_no_         CUSTOMER_ORDER_LINE_TAB.vendor_no%TYPE := NULL;
   category_          VARCHAR2(200) := NULL;
BEGIN
   $IF (Component_Purch_SYS.INSTALLED)$THEN
      -- replaced Get_Primary_Rental_Supplier_No() with Get_Active_Rental_Primary_Supp()
      IF rental_db_ = Fnd_Boolean_API.DB_FALSE THEN
         default_vendor_no_ := Purchase_Part_Supplier_API.Get_Active_Primary_Supplier_No(contract_, part_no_);
      ELSE
         default_vendor_no_ := Purchase_Part_Supplier_API.Get_Active_Rental_Primary_Supp(contract_, part_no_);
      END IF;
      category_ := Supplier_Category_API.Encode(Supplier_API.Get_Category(default_vendor_no_));
      IF (default_vendor_no_ IS NOT NULL) THEN
         -- Check the supplier category
         IF (((category_ = 'I') AND (supply_code_ IN ('IPT', 'IPD'))) OR
             ((category_ = 'E') AND (supply_code_ IN ('PD', 'PT')))) THEN
            vendor_no_ := default_vendor_no_;
         END IF;
      END IF;
   $END
   RETURN vendor_no_;
END Retrieve_Default_Vendor__;


-- Check_Delivery_Type__
--   Checks if delivery_type exists. If found, print an error message.
--   Used for restricted delete check when removing an delivery_type (INVOIC-module).
PROCEDURE Check_Delivery_Type__ (
   key_list_ IN VARCHAR2 )
IS
   company_       VARCHAR2(20);
   delivery_type_ CUSTOMER_ORDER_LINE_TAB.delivery_type%TYPE;
   found_         NUMBER;

   CURSOR exist_control IS
      SELECT 1
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  Site_API.Get_Company(contract) = company_
      AND    delivery_type = delivery_type_;
BEGIN
   company_       := substr(key_list_, 1, instr(key_list_, '^') - 1);
   delivery_type_ := substr(key_list_, instr(key_list_, '^') + 1, instr(key_list_, '^' , 1, 2) - (instr(key_list_, '^') + 1));

   OPEN exist_control;
   FETCH exist_control INTO found_;
   IF (exist_control%NOTFOUND) THEN
      found_ := 0;
   END IF;
   CLOSE exist_control;
   IF found_ = 1 THEN
      Error_SYS.Record_General(lu_name_, 'NO_DEL_TYPE: Delivery Type :P1 exists on one or several Customer Order Line(s)', delivery_type_ );
   END IF;
END Check_Delivery_Type__;

@IgnoreUnitTest TrivialFunction
-- Get_Gross_Amnt_Ratio_Per_Tax__
--   Get the CO line gross amount ratio per tax code
FUNCTION Get_Gross_Amnt_Ratio_Per_Tax__ (
   order_no_      IN VARCHAR2,
   tax_code_      IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   -- gelr:delivery_types_in_pbi, Moved the existing logic to Get_Amt_Ratio_Per_Tax_Deliv___
   RETURN Get_Amt_Ratio_Per_Tax_Deliv___(order_no_, tax_code_, NULL);
END Get_Gross_Amnt_Ratio_Per_Tax__;


@IgnoreUnitTest TrivialFunction
-- gelr:delivery_types_in_pbi, begin
-- Get_Gross_Amnt_Ratio_Per_Tax__
-- Get the CO line gross amount ratio per tax code and delivery type
FUNCTION Get_Amt_Ratio_Per_Tax_Deliv__ (
   order_no_      IN VARCHAR2,
   tax_code_      IN VARCHAR2,
   delivery_type_ IN VARCHAR2 DEFAULT NULL) RETURN NUMBER
IS
BEGIN
   RETURN Get_Amt_Ratio_Per_Tax_Deliv___(order_no_, tax_code_, delivery_type_);
END Get_Amt_Ratio_Per_Tax_Deliv__;
-- gelr:delivery_types_in_pbi, end

-- Validate_Vendor_No__
--   Retrives the vendor category and passes the values to implementation method
--   for validation. Used from the client side.
PROCEDURE Validate_Vendor_No__ (
   vendor_no_   IN VARCHAR2,
   supply_code_ IN VARCHAR2 )
IS
   category_    VARCHAR2(200) := NULL;
BEGIN
   $IF (Component_Purch_SYS.INSTALLED)$THEN
      IF (vendor_no_ IS NOT NULL) THEN
         category_ := Supplier_Category_API.Encode(Supplier_API.Get_Category(vendor_no_));
      END IF;
   $END
   Validate_Vendor_No___(vendor_no_, supply_code_, category_);
END Validate_Vendor_No__;


-- Valid_Project_Customer__
--   Returns "TRUE" if passed customer and the project customer are same;
--   "FALSE" otherwise.
@UncheckedAccess
FUNCTION Valid_Project_Customer__ (
   activity_seq_   IN NUMBER,
   customer_no_    IN VARCHAR2,
   demand_code_db_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   proj_customer_id_  VARCHAR2(20);
   return_value_      VARCHAR2(5) := 'TRUE';
BEGIN

   $IF (Component_Proj_SYS.INSTALLED) $THEN
      proj_customer_id_ := Project_API.Get_Customer_Id(Activity_API.Get_Project_Id(activity_seq_));
      -- Check if the customer is external or internal
      IF (Cust_Ord_Customer_API.Get_Category(customer_no_) = Cust_Ord_Customer_Category_API.Decode('E')) AND (NVL(demand_code_db_, Database_SYS.string_null_) != 'PO') THEN
         IF (NVL(proj_customer_id_, '*') != customer_no_) THEN
            return_value_ := 'FALSE';
         END IF;
      END IF;
   $END

   RETURN return_value_;
END Valid_Project_Customer__;


-- Check_Released_Activity__
--   Includes the validationes that needs to be executed when a Customer Order
--   header is changed to Released state.
PROCEDURE Check_Released_Activity__ (
   order_no_ IN VARCHAR2 )
IS
   activity_state_   VARCHAR2(30);

   CURSOR get_lines(order_no_ VARCHAR2) IS
      SELECT *
        FROM CUSTOMER_ORDER_LINE_TAB
       WHERE order_no = order_no_
         AND rowstate != 'Cancelled'
         AND line_item_no <= 0;
BEGIN
   FOR linerec_ IN get_lines(order_no_) LOOP
      -- Configuration is mandatory for configurable parts when the order is no more in Planned state
      Check_Base_Part_Config__(linerec_);

      IF (linerec_.activity_seq IS NOT NULL AND linerec_.project_id IS NOT NULL AND linerec_.rowstate IN ('Released', 'Reserved')) THEN
         $IF (Component_Proj_SYS.INSTALLED)$THEN
            activity_state_:= Activity_API.Get_Objstate(linerec_.activity_seq);
            IF (activity_state_ = 'Planned') THEN
               Error_SYS.Record_General(lu_name_, 'PLANNEDACT: Activity :P1 Connected to Line No :P2, Release No :P3 must be released before releasing the Customer Order.', linerec_.activity_seq, linerec_.line_no, linerec_.rel_no);
            END IF;
         $ELSE
            NULL;
         $END
      END IF;
   END LOOP;
END Check_Released_Activity__;


PROCEDURE Set_Released__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   rec_ CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
BEGIN
   IF (action_ = 'CHECK') THEN
      NULL;
   ELSIF (action_ = 'DO') THEN
      rec_ := Lock_By_Id___(objid_, objversion_);
      Finite_State_Machine___(rec_, 'SetReleased', attr_);
      objversion_ := to_char(rec_.rowversion,'YYYYMMDDHH24MISS');
      Finite_State_Add_To_Attr___(rec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Set_Released__;

PROCEDURE Update_Pegged_Orders__ (
   order_no_      IN VARCHAR2,
   line_no_       IN VARCHAR2,
   rel_no_        IN VARCHAR2,
   line_item_no_  IN NUMBER )
IS
   CURSOR po_connections IS
      SELECT po_order_no, po_line_no, po_rel_no, purchase_type, qty_on_order
      FROM   customer_order_pur_order_tab
      WHERE  oe_order_no = order_no_
      AND    oe_line_no = line_no_
      AND    oe_rel_no = rel_no_
      AND    oe_line_item_no  = line_item_no_
      AND    qty_on_order > 0;

   CURSOR so_connections IS
      SELECT so_order_no, so_release_no, so_sequence_no, qty_on_order
      FROM   customer_order_shop_order_tab
      WHERE  oe_order_no = order_no_
      AND    oe_line_no = line_no_
      AND    oe_rel_no = rel_no_
      AND    oe_line_item_no  = line_item_no_
      AND    qty_on_order > 0;

   attr_                VARCHAR2(2000);
   state_               VARCHAR2(20);
BEGIN
   state_ := Get_Objstate(order_no_, line_no_, rel_no_, line_item_no_);
   IF state_ = 'Delivered' THEN
      FOR pur_rec_ IN po_connections LOOP
         Client_SYS.Clear_Attr(attr_);
         Client_SYS.Add_To_Attr('QTY_ON_ORDER', 0, attr_);
         Customer_Order_Pur_Order_API.Modify(order_no_, line_no_, rel_no_, line_item_no_, pur_rec_.po_order_no, pur_rec_.po_line_no, pur_rec_.po_rel_no, attr_);
         $IF (Component_Purch_SYS.INSTALLED)$THEN
            IF (pur_rec_.purchase_type = 'R') THEN
               DECLARE
                  old_pegged_qty_   NUMBER;
               BEGIN
                  old_pegged_qty_ := Purchase_Req_Line_Part_API.Get_Qty_On_Order(pur_rec_.po_order_no, pur_rec_.po_line_no, pur_rec_.po_rel_no);
                  IF (old_pegged_qty_ > 0) THEN
                     Purchase_Req_Line_Part_API.Set_Qty_On_Order(pur_rec_.po_order_no, pur_rec_.po_line_no, pur_rec_.po_rel_no, old_pegged_qty_ - pur_rec_.qty_on_order);
                  END IF;
               END;
            ELSE
               DECLARE
                  old_pegged_qty_   NUMBER;
               BEGIN
                  old_pegged_qty_ := Purchase_Order_Line_Part_API.Get_Qty_On_Order(pur_rec_.po_order_no, pur_rec_.po_line_no, pur_rec_.po_rel_no);
                  IF (old_pegged_qty_ > 0) THEN
                     Purchase_Order_Line_Part_API.Modify_Qty_On_Order(pur_rec_.po_order_no, pur_rec_.po_line_no, pur_rec_.po_rel_no, old_pegged_qty_ - pur_rec_.qty_on_order);
                  END IF;
               END;
            END IF;
         $END
      END LOOP;
      FOR so_rec_ IN so_connections LOOP
         Client_SYS.Clear_Attr(attr_);
         Client_SYS.Add_To_Attr('QTY_ON_ORDER', 0, attr_);
         Customer_Order_Shop_Order_API.Modify(order_no_, line_no_, rel_no_, line_item_no_, so_rec_.so_order_no, so_rec_.so_release_no, so_rec_.so_sequence_no, attr_);
         Client_SYS.Clear_Attr(attr_);
         $IF (Component_Shpord_SYS.INSTALLED)$THEN
            DECLARE
               pegged_qty_   NUMBER;
            BEGIN
               pegged_qty_ := Shop_Ord_API.Get_Qty_On_Order_By_Keys(so_rec_.so_order_no, so_rec_.so_release_no, so_rec_.so_sequence_no);
               IF (pegged_qty_ > 0) THEN
                  Client_SYS.Add_To_Attr( 'QTY_ON_ORDER', pegged_qty_ - so_rec_.qty_on_order, attr_);
                  Client_SYS.Add_To_Attr( 'DEMAND_CODE_DB', 'IO', attr_);
                  Shop_Ord_API.Modify(so_rec_.so_order_no, so_rec_.so_release_no, so_rec_.so_sequence_no, attr_);
               END IF;
            END;
         $END
      END LOOP;
      Modify_Qty_On_Order(order_no_, line_no_, rel_no_, line_item_no_, 0);
   END IF;
END Update_Pegged_Orders__;


PROCEDURE Calculate_Revenue__ (
   attr_ IN VARCHAR2 )
IS
   order_no_      CUSTOMER_ORDER_LINE_TAB.order_no%TYPE;
   line_no_       CUSTOMER_ORDER_LINE_TAB.line_no%TYPE;
   rel_no_        CUSTOMER_ORDER_LINE_TAB.rel_no%TYPE;
   line_item_no_  CUSTOMER_ORDER_LINE_TAB.line_item_no%TYPE;
BEGIN

   order_no_     := Client_SYS.Get_Item_Value('ORDER_NO', attr_);
   line_no_      := Client_SYS.Get_Item_Value('LINE_NO', attr_);
   rel_no_       := Client_SYS.Get_Item_Value('REL_NO', attr_);
   line_item_no_ := Client_SYS.Get_Item_Value('LINE_ITEM_NO', attr_);

   Calculate_Revenue___(order_no_, line_no_, rel_no_, line_item_no_);
END Calculate_Revenue__;


PROCEDURE Update_License_Connect_Head__ (
   newrec_ IN OUT CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   oldrec_ IN     CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   attr_   IN     VARCHAR2 )
IS
BEGIN
   $IF Component_Expctr_SYS.INSTALLED $THEN
      IF(Customer_Order_Flow_API.Get_License_Enabled(newrec_.order_no, 'INTERACT_CUST_ORD') = 'TRUE') THEN
         DECLARE
            connect_head_id_      NUMBER;
            disconnect_           VARCHAR2(5);
            connect_status_       VARCHAR2(30);
            server_data_change_   NUMBER;
            licensed_order_type_  VARCHAR2(25);
         BEGIN
            licensed_order_type_ := Get_Expctr_License_Order_Type(newrec_.demand_code, newrec_.demand_order_ref1, newrec_.demand_order_ref2, newrec_.demand_order_ref3);
            connect_head_id_ := Exp_License_Connect_Head_API.Get_Connect_Id_From_Ref(licensed_order_type_, newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
            IF connect_head_id_ IS NOT NULL THEN
               disconnect_         := Client_SYS.Get_Item_Value('DISCONNECT_EXP_LICENSE', attr_);
               server_data_change_ := Client_SYS.Get_Item_Value('SERVER_DATA_CHANGE', attr_);
               connect_status_     := Exp_license_Connect_Head_API.Get_Objstate(connect_head_id_);
               
               -- Need to check both disconnect_ and connect_status_ since disconnect_ will be null when the status is Unconnected and Planned.
               -- server_data_change_ becomes 1 when the update originates from the pegged PO or SO.
               -- Update the license date in export license connect header if the plan ship date has been changed.
               IF (oldrec_.planned_ship_date != newrec_.planned_ship_date) AND ((disconnect_ = 'TRUE') OR
                   (connect_status_ IN ('Unconnected', 'Planned')) OR (server_data_change_ = 1)) THEN
                  Exp_License_Connect_Head_API.Set_License_Date(connect_head_id_, newrec_.planned_ship_date);
               END IF;
               -- Update the license quantity in export license connect header if the revised_qty_due has been changed.
               IF (oldrec_.revised_qty_due != newrec_.revised_qty_due) THEN
                  -- Cannot update the attributes when an export license is (partly) connected.
                  Exp_License_Connect_Util_API.Check_Allow_Update(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, licensed_order_type_);
                  Exp_License_Connect_Head_API.Set_License_Qty(connect_head_id_, newrec_.revised_qty_due);
               END IF;
               -- Update the supplier id in export license connect header if the vendor number has been changed.
               IF (NVL(oldrec_.vendor_no, ' ') != newrec_.vendor_no) THEN
                  -- Cannot update the attributes when an export license is (partly) connected.
                  Exp_License_Connect_Util_API.Check_Allow_Update(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, licensed_order_type_);
                  Exp_License_Connect_Head_API.Set_Supplier_Info(connect_head_id_, newrec_.vendor_no);
               END IF;
               IF (NVL(newrec_.forward_agent_id, CHR(2)) != NVL(oldrec_.forward_agent_id, CHR(2))) THEN
                  Exp_License_Connect_Util_API.Check_Allow_Update(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, licensed_order_type_);
                  Exp_License_Connect_Head_API.Set_Forwarder_Info(connect_head_id_, newrec_.forward_agent_id);
               END IF;
               IF(NVL(newrec_.configuration_id, CHR(2)) != NVL(oldrec_.configuration_id, CHR(2))) THEN
                  Exp_License_Connect_Util_API.Check_Allow_Update(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, licensed_order_type_);
                  -- This is does not need to update in Export License Connect Head since configuration id doesn't store there. But this will lead to change the structure
                  -- of the configured part due to different kind of parts can be used for the different configurations. 
               END IF;
               IF(newrec_.sale_unit_price != oldrec_.sale_unit_price) THEN
                  Exp_License_Connect_Util_API.Check_Allow_Update(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, licensed_order_type_);                                          
               END IF;
            END IF;
         END;
      END IF;
   $ELSE
      NULL;
   $END
 END Update_License_Connect_Head__;


-- Validate_Jinsui_Constraints__
--   Performs validation with the Junsi Invoice Constraints.
@UncheckedAccess
PROCEDURE Validate_Jinsui_Constraints__(
   newrec_                 IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   company_max_jinsui_amt_ IN NUMBER,
   co_header_validation_   IN BOOLEAN )
IS
   company_                 VARCHAR2(20);
   company_maximum_amt_     NUMBER := 0;
   gross_charge_amount_     NUMBER := 0;
   gross_total_incl_charge_ NUMBER := 0;
   net_amount_curr_         NUMBER := 0;
   total_tax_curr_          NUMBER := 0;
   gross_total_base_curr_   NUMBER := 0;
BEGIN
   IF newrec_.self_billing = 'SELF BILLING' THEN
      Error_SYS.Record_General(lu_name_, 'SBNOTALLOWEED: Self billing is not allowed for a jinsui order.');
   END IF;

   company_maximum_amt_ := company_max_jinsui_amt_;
   company_             := Site_API.Get_Company(newrec_.contract);
   IF (company_maximum_amt_ = 0) THEN
      $IF Component_Jinsui_SYS.INSTALLED $THEN
         company_maximum_amt_ := Js_Company_Info_API.Get_Virtual_Inv_Max_Amount(company_);
      $ELSE
         company_maximum_amt_ := 0;
      $END
   END IF;

   gross_charge_amount_   := Customer_Order_Charge_API.Get_Gross_Amount_For_Col(newrec_.order_no,
                                                                                newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
   net_amount_curr_       := Get_Sale_Price_Total(newrec_.order_no,
                                                  newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
   total_tax_curr_        := Get_Total_Tax_Amount_Curr(newrec_.order_no,
                                                       newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
   gross_total_base_curr_ := net_amount_curr_+ total_tax_curr_;
   IF (newrec_.qty_picked > newrec_.revised_qty_due) THEN
      -- The line has been overpicked, the check should be made agains the total amount picked rather than what was ordered
      gross_total_base_curr_ := (newrec_.qty_picked / newrec_.revised_qty_due) * gross_total_base_curr_;
   END IF;
   gross_total_incl_charge_ := gross_total_base_curr_ + gross_charge_amount_;

   IF (gross_total_base_curr_ > company_maximum_amt_) THEN
      IF (co_header_validation_) THEN
         Error_SYS.Record_General(lu_name_, 'COLIAMTEXCEEDED: The total line amount of customer order line :P1 cannot be greater than the maximum amount for Jinsui invoice :P2 for the company :P3.', newrec_.order_no||'-'||newrec_.line_no||'-'||newrec_.rel_no, company_maximum_amt_,company_);
      ELSE
         Error_SYS.Record_General(lu_name_, 'AMTEXCEEDED: The total line amount cannot be greater than the maximum amount for Jinsui invoice :P1 for the company :P2.',company_maximum_amt_,company_);
      END IF;
   ELSIF (gross_total_incl_charge_ > company_maximum_amt_ ) THEN
      IF (co_header_validation_) THEN
         Error_SYS.Record_General(lu_name_, 'COAMTLINECHEXCEED: The total line and the connected charge amount of customer order line :P1 cannot be greater than the maximum amount for Jinsui invoice :P2 for the company :P3.', newrec_.order_no||'-'||newrec_.line_no||'-'||newrec_.rel_no, company_maximum_amt_,company_);
      ELSE
         Error_SYS.Record_General(lu_name_, 'AMTLINECHEXCEED: The total line and the connected charge amount cannot be greater than the maximum amount for Jinsui invoice :P1 for the company :P2.',company_maximum_amt_,company_);
      END IF;
   END IF;
END Validate_Jinsui_Constraints__;


@UncheckedAccess
PROCEDURE Get_Internal_Co_Qty__ (
   qty_shipped_  OUT NUMBER,
   qty_assigned_ OUT NUMBER,
   order_no_     IN  VARCHAR2,
   line_no_      IN  VARCHAR2,
   rel_no_       IN  VARCHAR2,
   line_item_no_ IN  NUMBER )
IS
   int_order_no_     VARCHAR2(12);
   int_line_no_      VARCHAR2(4);
   int_rel_no_       VARCHAR2(4);
   int_line_item_no_ NUMBER;
   co_line_status_   VARCHAR2(20);
   po_order_no_      VARCHAR2(12);
   po_line_no_       VARCHAR2(4);
   po_rel_no_        VARCHAR2(4);
   supply_site_      VARCHAR2(5);
   demand_code_      VARCHAR2(20);
   supply_code_      VARCHAR2(20);
   purchase_type_    VARCHAR2(20);

   CURSOR get_internal_co_info(po_order_no_ IN VARCHAR2, po_line_no_ IN VARCHAR2, po_rel_no_ IN VARCHAR2) IS
      SELECT order_no, line_no, rel_no, line_item_no, rowstate,
             contract, qty_shipped, qty_assigned, demand_code, supply_code
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE demand_order_ref1 = po_order_no_
      AND   demand_order_ref2 = po_line_no_
      AND   demand_order_ref3 = po_rel_no_;
BEGIN
   IF Customer_Order_Transfer_API.Is_Multi_Tier_Ordchg_Enabled(order_no_, line_no_, rel_no_, line_item_no_) = 'FALSE' THEN
      int_order_no_     := order_no_;
      int_line_no_      := line_no_;
      int_rel_no_       := rel_no_;
      int_line_item_no_ := line_item_no_;

      LOOP
         Customer_Order_Pur_Order_API.Get_Purord_For_Custord(po_order_no_,
                                                             po_line_no_,
                                                             po_rel_no_,
                                                             purchase_type_,
                                                             int_order_no_,
                                                             int_line_no_,
                                                             int_rel_no_,
                                                             int_line_item_no_);
         IF (po_order_no_ IS NULL) THEN
            -- Assign NULL for qty_shipped_ and qty_assigned_ to skip the warning message.
            qty_shipped_  := NULL;
            qty_assigned_ := NULL;
         ELSE
            OPEN  get_internal_co_info(po_order_no_, po_line_no_, po_rel_no_);
            FETCH get_internal_co_info INTO int_order_no_, int_line_no_, int_rel_no_, int_line_item_no_, co_line_status_,
                                            supply_site_, qty_shipped_, qty_assigned_, demand_code_, supply_code_;
            CLOSE get_internal_co_info;

            IF (supply_code_ NOT IN ('IPD','IPT') AND co_line_status_ IN ('Released', 'Cancelled')) THEN
               -- Assign NULL for qty_shipped_ and qty_assigned_ to skip the warning message.
               qty_shipped_  := NULL;
               qty_assigned_ := NULL;
            END IF;
         END IF;
         EXIT WHEN ((qty_shipped_ IS NULL) OR (supply_code_ IS NOT NULL AND supply_code_ NOT IN ('IPD','IPT'))) ;
      END LOOP;
   ELSE
      -- Assign NULL for qty_shipped_ and qty_assigned_ to skip the warning message.
      qty_shipped_  := NULL;
      qty_assigned_ := NULL;
   END IF;
 END Get_Internal_Co_Qty__;


-- Qty_On_Order_Exist__
--    This method returns 1 if the line or any of its components in the case of a package
--    has qty_on_order greater than 0. Returns 0 otherwise.
 @UncheckedAccess
 FUNCTION Qty_On_Order_Exist__ (
   order_no_ IN VARCHAR2,
   line_no_  IN VARCHAR2,
   rel_no_   IN VARCHAR2 ) RETURN NUMBER
IS
   dummy_ NUMBER;
   CURSOR exist_control IS
      SELECT 1
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE order_no     = order_no_
      AND   line_no      = line_no_
      AND   rel_no       = rel_no_
      AND   qty_on_order > 0;
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RETURN (1);
   END IF;
   CLOSE exist_control;
   RETURN (0);
END Qty_On_Order_Exist__;


-- Replication, start
PROCEDURE Update_Line__ (
   info_                      OUT    VARCHAR2,
   attr_                      IN OUT VARCHAR2,
   order_no_                  IN     VARCHAR2,
   changed_attrib_not_in_pol_ IN     VARCHAR2,
   replicate_changes_         IN     VARCHAR2,
   address_changed_           IN     VARCHAR2 DEFAULT 'FALSE' ) 
IS
   po_order_no_         VARCHAR2(12);
   i_                   NUMBER;
   found_               BOOLEAN := FALSE;
   change_request_      VARCHAR2(5) := 'FALSE';
   dop_new_qty_demand_  VARCHAR2(100);
   no_of_dop_conns_     NUMBER;
   no_of_dop_conns_pkg_ NUMBER;
   msg_                 VARCHAR2(32000);
   dummy_               VARCHAR2(2000);
   ipd_exist_           VARCHAR2(5);
   ipt_exist_           VARCHAR2(5);
   shpmnt_info_         VARCHAR2(2000); 
   
   CURSOR get_lines IS 
      SELECT line_no, rel_no, line_item_no, rowid objid, to_char(rowversion,'YYYYMMDDHH24MISS') objversion, supply_code
      FROM customer_order_line_tab
      WHERE order_no      = order_no_
      AND   line_item_no != -1;
BEGIN
   IF (replicate_changes_ = 'TRUE') THEN
      Customer_Order_API.Check_Ipd_Ipt_Exist__(dummy_, 
                                               ipd_exist_, 
                                               ipt_exist_, 
                                               dummy_, 
                                               dummy_, 
                                               dummy_, 
                                               order_no_, 
                                               'FALSE');
                                               
      FOR rec_ IN get_lines LOOP
         po_order_no_ := Customer_Order_Pur_Order_API.Get_Po_Order_No_For_Custord__(order_no_,
                                                                                    rec_.line_no,
                                                                                    rec_.rel_no,
                                                                                    rec_.line_item_no);
         IF (po_order_no_ IS NOT NULL) THEN
            IF (purchase_order_no_tab_.COUNT > 0) THEN
               IF ((address_changed_ = 'TRUE') AND (ipd_exist_ = 'TRUE') AND (ipt_exist_ = 'TRUE')) THEN
                  -- If the address has been changed and the lines are a mix of IPD and IPT, then check the supply code
                  FOR j_ IN purchase_order_no_tab_.FIRST .. purchase_order_no_tab_.LAST LOOP
                     IF ((purchase_order_no_tab_(j_).po_order_no = po_order_no_) AND (purchase_order_no_tab_(j_).supply_code = rec_.supply_code)) THEN
                        found_ := TRUE;
                        EXIT;
                     END IF;
                  END LOOP;
               ELSE
                  FOR j_ IN purchase_order_no_tab_.FIRST .. purchase_order_no_tab_.LAST LOOP
                     IF (purchase_order_no_tab_(j_).po_order_no = po_order_no_) THEN
                        found_ := TRUE;
                        EXIT;
                     END IF;         
                  END LOOP;
               END IF;
            END IF;

            IF (NOT found_) THEN -- add po_order_no and line key
               i_ := purchase_order_no_tab_.COUNT + 1;
               purchase_order_no_tab_(i_).po_order_no  := po_order_no_;
               purchase_order_no_tab_(i_).order_no     := order_no_;
               purchase_order_no_tab_(i_).line_no      := rec_.line_no;
               purchase_order_no_tab_(i_).rel_no       := rec_.rel_no;
               purchase_order_no_tab_(i_).line_item_no := rec_.line_item_no;
               purchase_order_no_tab_(i_).supply_code  := rec_.supply_code;
            ELSE -- if the po_order_no is the same, update the line keys to set the last line so change_request is set to 'TRUE' on the last line
               i_ := purchase_order_no_tab_.COUNT;
               purchase_order_no_tab_(i_).order_no     := order_no_;
               purchase_order_no_tab_(i_).line_no      := rec_.line_no;
               purchase_order_no_tab_(i_).rel_no       := rec_.rel_no;
               purchase_order_no_tab_(i_).line_item_no := rec_.line_item_no;
               purchase_order_no_tab_(i_).supply_code  := rec_.supply_code;
               found_ := FALSE;
            END IF;
         END IF;
      END LOOP;
   END IF;
   
   FOR rec_ IN get_lines LOOP
      attr_ := NULL;
      
      IF (replicate_changes_ = 'TRUE') THEN
         Client_SYS.Add_To_Attr('REPLICATE_CHANGES', replicate_changes_, attr_);
         Client_SYS.Add_To_Attr('UPDATE_PEGGED_ORDERS', 'TRUE', attr_);
         Client_SYS.Add_To_Attr('CHANGED_ATTRIB_NOT_IN_POL', changed_attrib_not_in_pol_, attr_);

         IF (purchase_order_no_tab_.COUNT > 0) THEN
            IF ((address_changed_ = 'TRUE') AND (ipd_exist_ = 'TRUE') AND (ipt_exist_ = 'TRUE')) THEN
               -- If the address has been changed and the lines are a mix of IPD and IPT, then check the supply code
               FOR k_ IN purchase_order_no_tab_.FIRST..purchase_order_no_tab_.LAST LOOP
                  IF ((purchase_order_no_tab_(k_).order_no = order_no_) AND (purchase_order_no_tab_(k_).line_no = rec_.line_no) AND 
                      (purchase_order_no_tab_(k_).rel_no = rec_.rel_no) AND (purchase_order_no_tab_(k_).line_item_no = rec_.line_item_no) AND 
                      (purchase_order_no_tab_(k_).supply_code = rec_.supply_code)) THEN
                     change_request_ := 'TRUE';
                     EXIT;
                  ELSE
                     change_request_ := 'FALSE';
                  END IF;
               END LOOP;
            ELSE
               FOR k_ IN purchase_order_no_tab_.FIRST..purchase_order_no_tab_.LAST LOOP
                  IF ((purchase_order_no_tab_(k_).order_no = order_no_) AND (purchase_order_no_tab_(k_).line_no = rec_.line_no) AND 
                      (purchase_order_no_tab_(k_).rel_no = rec_.rel_no) AND (purchase_order_no_tab_(k_).line_item_no = rec_.line_item_no)) THEN
                     change_request_ := 'TRUE';
                     EXIT;
                  ELSE
                     change_request_ := 'FALSE';
                  END IF;
               END LOOP;
            END IF;
         END IF;

         Client_SYS.Add_To_Attr('CHANGE_REQUEST', change_request_, attr_); 

         IF ((rec_.supply_code = 'DOP') OR (rec_.supply_code = 'PKG')) THEN
            dop_new_qty_demand_ := Client_SYS.Get_Item_Value('DOP_NEW_QTY_DEMAND', attr_);
            $IF Component_Dop_SYS.INSTALLED $THEN
               no_of_dop_conns_     := Dop_Demand_Cust_Ord_API.Get_No_Of_All_Dop_Headers(order_no_, 
                                                                                         rec_.line_no, 
                                                                                         rec_.rel_no, 
                                                                                         rec_.line_item_no);
               no_of_dop_conns_pkg_ := Dop_Demand_Cust_Ord_API.Get_No_Of_All_Dop_Headers(order_no_, 
                                                                                         rec_.line_no, 
                                                                                         rec_.rel_no, 
                                                                                         rec_.line_item_no,
                                                                                         'TRUE');
               IF (((no_of_dop_conns_ > 0) OR ((rec_.supply_code = 'PKG') AND (no_of_dop_conns_pkg_ > 0))) AND (dop_new_qty_demand_ IS NULL)) THEN 
                  Message_SYS.Add_Attribute(msg_, 'FROM_CO_LINE_CLIENT', 'TRUE');
                  Message_SYS.Add_Attribute(msg_, 'FROM_CO_HEAD_CLIENT', 'TRUE');
                  Client_SYS.Add_To_Attr('DOP_NEW_QTY_DEMAND', msg_, attr_);
               END IF;
            $ELSE
               NULL;
            $END
         END IF;
      ELSE
         Client_SYS.Add_To_Attr('REPLICATE_CHANGES', 'FALSE', attr_);
         Client_SYS.Add_To_Attr('UPDATE_PEGGED_ORDERS', 'FALSE', attr_);
         Client_SYS.Add_To_Attr('CHANGED_ATTRIB_NOT_IN_POL', changed_attrib_not_in_pol_, attr_);
         Client_SYS.Add_To_Attr('CHANGE_REQUEST', 'FALSE', attr_); 
      END IF;
      
      IF ((address_changed_ = 'TRUE') AND (rec_.supply_code != 'IPT')) THEN
         Cust_Order_Line_Address_API.Modify_Connected_Addr_Line__(order_no_          => order_no_, 
                                                                  line_no_           => rec_.line_no, 
                                                                  rel_no_            => rec_.rel_no, 
                                                                  line_item_no_      => rec_.line_item_no, 
                                                                  replicate_changes_ => replicate_changes_,
                                                                  change_request_    => change_request_, 
                                                                  co_status_         => Customer_Order_API.Get_Objstate(order_no_),
                                                                  supply_code_       => rec_.supply_code);
         IF(rec_.supply_code IN ('IPD', 'IPT')) THEN
            shpmnt_info_ := App_Context_SYS.Find_Value('CUSTOMER_ORDER_LINE_API.SHPMNT_INFO_');
            IF (shpmnt_info_ IS NOT NULL) THEN               
               Client_SYS.Add_Info(lu_name_, shpmnt_info_);   
            END IF; 
            info_ := info_ || Client_SYS.Get_All_Info;
         END IF;
      ELSE
         Modify__(info_, rec_.objid, rec_.objversion, attr_, 'DO');
      END IF;
   END LOOP;
END Update_Line__;
-- Replication, end

-- gelr:disc_price_rounded, begin
FUNCTION Get_Displayed_Discount__ (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER) RETURN NUMBER
IS
BEGIN
   IF (Customer_Order_API.Get_Discounted_Price_Rounded(order_no_)) THEN
      RETURN Get_Original_Discount(order_no_, line_no_, rel_no_, line_item_no_);
   ELSE
      RETURN Get_Discount(order_no_, line_no_, rel_no_, line_item_no_);
   END IF;
END Get_Displayed_Discount__;
-- gelr:disc_price_rounded, end

-------------------- LU SPECIFIC PROTECTED METHODS --------------------------

-------------------- LU SPECIFIC PUBLIC METHODS -----------------------------

-- Get_Part_Ownership_And_Owner
--   Returns part_ownership and owner for an order line.
@UncheckedAccess
PROCEDURE Get_Part_Ownership_And_Owner (
   part_ownership_ OUT VARCHAR2,
   owner_          OUT VARCHAR2,
   order_no_       IN  VARCHAR2,
   line_no_        IN  VARCHAR2,
   rel_no_         IN  VARCHAR2,
   line_item_no_   IN  NUMBER )
IS
   temp_ CUSTOMER_ORDER_LINE_TAB.part_ownership%TYPE;
   CURSOR get_attr IS
      SELECT part_ownership
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no  = line_no_
      AND    rel_no   = rel_no_
      AND    line_item_no = line_item_no_;
BEGIN
   OPEN  get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   part_ownership_ := temp_;
   owner_ := Get_Owner_For_Part_Ownership(order_no_, line_no_, rel_no_, line_item_no_, part_ownership_);
END Get_Part_Ownership_And_Owner;


-- Get_Owning_Cust_After_Delivery
--    This method returns the owning customer of the order line after part serial delivery.
-------------------------------------------------------------------------------------------
FUNCTION Get_Owning_Cust_After_Delivery (
   order_no_               IN  VARCHAR2,
   line_no_                IN  VARCHAR2,
   rel_no_                 IN  VARCHAR2,
   line_item_no_           IN  NUMBER ) RETURN VARCHAR2
IS
   ownership_before_delivery_ CUSTOMER_ORDER_LINE_TAB.part_ownership%TYPE;
   line_rec_                  CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   keep_ownership_            BOOLEAN := FALSE;
   new_owning_customer_no_    CUSTOMER_ORDER_LINE_TAB.deliver_to_customer_no%TYPE;
BEGIN
   line_rec_                  := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   ownership_before_delivery_ := line_rec_.part_ownership;

   IF (ownership_before_delivery_ IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                      Part_Ownership_API.DB_CONSIGNMENT)) THEN
      IF ((line_rec_.demand_code = Order_Supply_Type_API.DB_COMPONENT_REPAIR_EXCHANGE) AND
          (line_rec_.supply_code = Order_Supply_Type_API.DB_COMPONENT_REPAIR_ORDER)) THEN
          keep_ownership_ := TRUE;
      END IF;
   ELSIF (ownership_before_delivery_ IN (Part_Ownership_API.DB_CUSTOMER_OWNED,
                                         Part_Ownership_API.DB_SUPPLIER_LOANED)) THEN
      keep_ownership_ := TRUE;
   ELSIF (ownership_before_delivery_ IN (Part_Ownership_API.DB_SUPPLIER_RENTED,
                                         Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)) THEN
      IF (line_rec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
          keep_ownership_ := TRUE; 
      END IF;
   END IF;
   
   IF NOT (keep_ownership_) THEN
      new_owning_customer_no_ := line_rec_.deliver_to_customer_no;
   END IF;

   RETURN (new_owning_customer_no_);
END Get_Owning_Cust_After_Delivery;


PROCEDURE Lock_By_Id (
   objid_      IN VARCHAR2,
   objversion_ IN VARCHAR2 )
IS
   dummy_ CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
BEGIN
   dummy_ := Lock_By_Id___(objid_, objversion_);
END Lock_By_Id;


-- Modify_Real_Ship_Date
--   Modify the real_ship_date attribute.
PROCEDURE Modify_Real_Ship_Date (
   order_no_       IN VARCHAR2,
   line_no_        IN VARCHAR2,
   rel_no_         IN VARCHAR2,
   line_item_no_   IN NUMBER,
   real_ship_date_ IN DATE )
IS
   attr_                   VARCHAR2(2000);
   first_actual_ship_date_ DATE;

   CURSOR get_first_actual_ship_date IS
      SELECT first_actual_ship_date
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    line_item_no = line_item_no_;
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('REAL_SHIP_DATE', real_ship_date_, attr_);

   OPEN get_first_actual_ship_date;
   FETCH get_first_actual_ship_date INTO first_actual_ship_date_;
   CLOSE get_first_actual_ship_date;
   IF first_actual_ship_date_ IS NULL THEN
      Client_SYS.Add_To_Attr('FIRST_ACTUAL_SHIP_DATE', real_ship_date_, attr_);
   END IF;

   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Real_Ship_Date;


PROCEDURE Set_First_Actual_Ship_Date (
   order_no_       IN VARCHAR2,
   line_no_        IN VARCHAR2,
   rel_no_         IN VARCHAR2,
   line_item_no_   IN NUMBER )
IS
   attr_                   VARCHAR2(2000);
   first_actual_ship_date_ DATE;
   line_rec_                  CUSTOMER_ORDER_LINE_TAB%ROWTYPE; 
   set_date_               BOOLEAN := FALSE;
BEGIN
   first_actual_ship_date_ := Customer_Order_Delivery_API.Get_First_Delivery_Date(order_no_, line_no_, rel_no_, line_item_no_);
   line_rec_                  := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   
   IF (first_actual_ship_date_ IS NOT NULL AND line_rec_.first_actual_ship_date IS NOT NULL) THEN
      IF (first_actual_ship_date_ != line_rec_.first_actual_ship_date) THEN
         set_date_ := TRUE;   
      END IF;   
   ELSE
      IF ((first_actual_ship_date_ IS NULL AND line_rec_.first_actual_ship_date IS NOT NULL) OR 
         (first_actual_ship_date_ IS NOT NULL AND line_rec_.first_actual_ship_date IS NULL)) THEN
         set_date_ := TRUE;
      END IF;
   END IF;   
     
   IF (set_date_) THEN
      Client_SYS.Clear_Attr(attr_);
      Client_SYS.Add_To_Attr('FIRST_ACTUAL_SHIP_DATE', first_actual_ship_date_, attr_);
      Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
   END IF;
END Set_First_Actual_Ship_Date;   


-- Modify_Ref_Id
--   Updates RefId attribute of customer order lines belonging to given order no
@IgnoreUnitTest NoOutParams
PROCEDURE Modify_Ref_Id(
   order_no_       IN   VARCHAR2,
   ref_id_         IN   VARCHAR2 )
IS
   attr_                   VARCHAR2(2000);
   
   CURSOR get_lines IS
      SELECT order_no, line_no, rel_no, line_item_no 
      FROM customer_order_line_tab
      WHERE order_no = order_no_;     
BEGIN

   FOR line_rec_ IN get_lines LOOP 
      Client_SYS.Clear_Attr(attr_);
      Client_SYS.Add_To_Attr('REF_ID', ref_id_, attr_);
      Modify_Line___(attr_, line_rec_.order_no, line_rec_.line_no,line_rec_.rel_no, line_rec_.line_item_no);
   END LOOP;

END Modify_Ref_Id;

-- Modify_Order_Discount
--   Update the order_discount attribute.
PROCEDURE Modify_Order_Discount (
   order_no_       IN VARCHAR2,
   line_no_        IN VARCHAR2,
   rel_no_         IN VARCHAR2,
   line_item_no_   IN NUMBER,
   order_discount_ IN NUMBER,
   update_tax_     IN BOOLEAN DEFAULT TRUE )
IS
   attr_   VARCHAR2(2000);
   CURSOR get_package_lines IS
      SELECT line_item_no
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    line_item_no > 0
      AND    rowstate != 'Cancelled';
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('ORDER_DISCOUNT', order_discount_, attr_);
   
   IF NOT update_tax_ THEN 
      Client_SYS.Add_To_Attr('UPDATE_TAX', 'FALSE', attr_);
   END IF;
   
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
   IF (line_item_no_ = -1) THEN
      FOR component_ IN get_package_lines LOOP
         -- Reinitialize the attribute string as it might have been changed in the previous update
         Client_SYS.Clear_Attr(attr_);
         Client_SYS.Add_To_Attr('ORDER_DISCOUNT', order_discount_, attr_);
         IF NOT update_tax_ THEN 
            Client_SYS.Add_To_Attr('UPDATE_TAX', 'FALSE', attr_);
         END IF;
         Modify_Line___(attr_, order_no_, line_no_, rel_no_, component_.line_item_no);
      END LOOP;
   END IF;
END Modify_Order_Discount;


-- Modify_Qty_On_Order
--   Update the qty_on_order attribute.
PROCEDURE Modify_Qty_On_Order (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_on_order_ IN NUMBER )
IS
   attr_  VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_ON_ORDER', qty_on_order_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Qty_On_Order;


-- Modify_Arrival
--   Modifies quantities due to a purchase order arrival.
PROCEDURE Modify_Arrival (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_assigned_ IN NUMBER )
IS
   attr_ VARCHAR2(2000);
   rec_  CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
BEGIN
   IF NOT Check_Exist___(order_no_, line_no_, rel_no_, line_item_no_) THEN
      Error_SYS.Record_Not_Exist(lu_name_);
   ELSE
      rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
      Client_SYS.Clear_Attr(attr_);
      Client_SYS.Add_To_Attr('QTY_ON_ORDER', greatest(rec_.qty_on_order - qty_assigned_, 0), attr_);
      Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
      CUSTOMER_ORDER_API.Set_Line_Qty_Assigned(order_no_, line_no_, rel_no_, line_item_no_, rec_.qty_assigned + qty_assigned_);
   END IF;
END Modify_Arrival;


-- Modify_Qty_Returned
--   Update the qty_returned attribute and writes history line.
PROCEDURE Modify_Qty_Returned (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_returned_ IN NUMBER )
IS
   oldrec_ CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   attr_   VARCHAR2(2000);
BEGIN
   oldrec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_RETURNED', qty_returned_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);

   -- Insert a new entry in CustomerOrderLineHistory
   IF (oldrec_.qty_returned < qty_returned_) THEN
      Customer_Order_Line_Hist_API.New(order_no_, line_no_, rel_no_, line_item_no_,
         Language_SYS.Translate_Constant(lu_name_, 'CUSTORDERRETURN: Customer order return'));
   ELSIF (oldrec_.qty_returned > qty_returned_) THEN
      Customer_Order_Line_Hist_API.New(order_no_, line_no_, rel_no_, line_item_no_,
         Language_SYS.Translate_Constant(lu_name_, 'CUSTORDREM: Customer order return removed'));
   END IF;
END Modify_Qty_Returned;


-- Modify_Revised_Qty_Due
--   Update the revised_qty_due attribute.
PROCEDURE Modify_Revised_Qty_Due (
   order_no_        IN VARCHAR2,
   line_no_         IN VARCHAR2,
   rel_no_          IN VARCHAR2,
   line_item_no_    IN NUMBER,
   revised_qty_due_ IN NUMBER )
IS
   attr_  VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_to_Attr('REVISED_QTY_DUE', revised_qty_due_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Revised_Qty_Due;


-- Modify_Cost
--   Update the cost attribute.
PROCEDURE Modify_Cost (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   cost_         IN NUMBER )
IS
   attr_  VARCHAR2(2000);
   line_rec_                   Customer_Order_Line_API.Public_Rec;
   header_rec_                 Customer_Order_api.Public_Rec;
   free_of_charge_tax_basis_   NUMBER := 0;
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_to_Attr('COST', cost_, attr_);
   IF (NVL(cost_,0) != NVL(Get_Cost(order_no_, line_no_, rel_no_, line_item_no_),0)) THEN
      header_rec_   := Customer_Order_API.Get(order_no_);   
      line_rec_     := Customer_Order_Line_API.Get(order_no_, line_no_, rel_no_, line_item_no_);  
      IF (line_rec_.free_of_charge = Fnd_Boolean_API.DB_TRUE AND line_rec_.rowstate != 'Invoiced') THEN
         Tax_Handling_Order_Util_API.Calc_And_Save_Foc_Tax_Basis(free_of_charge_tax_basis_, 
                                                                 Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                                                 order_no_, 
                                                                 line_no_,
                                                                 rel_no_,
                                                                 line_item_no_,    
                                                                 '*',
                                                                 cost_, 
                                                                 line_rec_.part_price, 
                                                                 line_rec_.revised_qty_due,                                      
                                                                 nvl(header_rec_.customer_no_pay,line_rec_.customer_no), 
                                                                 line_rec_.contract,
                                                                 header_rec_.currency_code,
                                                                 header_rec_.currency_rate_type,
                                                                 'TRUE');
      END IF;  
      Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
   END IF;
END Modify_Cost;


-- Modify_Char_Price
--   Update the char_price and the calc_char_price attribute.
PROCEDURE Modify_Char_Price (
   order_no_        IN VARCHAR2,
   line_no_         IN VARCHAR2,
   rel_no_          IN VARCHAR2,
   line_item_no_    IN NUMBER,
   calc_char_price_ IN NUMBER,
   char_price_      IN NUMBER )
IS
   attr_  VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('CALC_CHAR_PRICE', calc_char_price_, attr_);
   Client_SYS.Add_To_Attr('CHAR_PRICE', char_price_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Char_Price;


-- Modify_Foc_Tax_Basis
--   Update the free_of_charge_tax_basis attribute.
--   *** This method is dynamically called from Tax_Handling_Order_Util_API. ***
PROCEDURE Modify_Foc_Tax_Basis (
   order_no_      IN VARCHAR2,
   line_no_       IN VARCHAR2,
   rel_no_        IN VARCHAR2,
   line_item_no_  IN NUMBER,
   foc_tax_basis_ IN NUMBER )
IS
   attr_          VARCHAR2(2000);
BEGIN   
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('FREE_OF_CHARGE_TAX_BASIS', foc_tax_basis_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Foc_Tax_Basis;

-- Get_Qty_Demand
--   Get the quantity demand for a specific part
@UncheckedAccess
FUNCTION Get_Qty_Demand (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   qty_demand_ NUMBER;

   CURSOR get_demand IS
      SELECT NVL(sum(revised_qty_due - qty_assigned - qty_shipped), 0)
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  contract = contract_
      AND    part_no = part_no_
      AND    rowstate IN ('Released', 'Reserved', 'Picked', 'PartiallyDelivered')
      AND    revised_qty_due - qty_assigned - qty_shipped > 0
      AND    part_ownership IN ('COMPANY OWNED' , 'CONSIGNMENT');
BEGIN
   OPEN get_demand;
   FETCH get_demand INTO qty_demand_;
   IF get_demand%NOTFOUND THEN
      qty_demand_ := 0;
   END IF;
   CLOSE get_demand;
   RETURN qty_demand_;
END Get_Qty_Demand;


-- Get_Sale_Price_Total
--   Retrive the total sale price for the specified order line in order currency.
--   If Price Including Tax setup is used then amount is calculated as Gross Amount in order currency - Tax Amount in order currency
--   If Price Including Tax setup is not used then amount is calculated using values on the line considering discounts
--   ****** It should consider the method Get_Rental_Line_Total() when changing any tax calculation here. *****
@UncheckedAccess
FUNCTION Get_Sale_Price_Total (
   order_no_              IN VARCHAR2,
   line_no_               IN VARCHAR2,
   rel_no_                IN VARCHAR2,
   line_item_no_          IN NUMBER,
   rental_chargable_days_ IN NUMBER DEFAULT NULL,
   exclude_item_          IN VARCHAR2 DEFAULT 'FALSE') RETURN NUMBER
IS  
BEGIN      
   RETURN Get_Price_Total___( order_no_, line_no_, rel_no_, line_item_no_, rental_chargable_days_, exclude_item_, false );
END Get_Sale_Price_Total;

-- Get_Sale_Price_Incl_Tax_Total
--   Retrive the total sale price including tax for the specified order line in order currency.
--   If Price Including Tax setup is used then amount is calculated using values on the line considering discounts
--   If Price Including Tax setup is not used then amount is calculated as Net Amount in order currency + Tax Amount in order currency
--   ****** It should consider the method Get_Rental_Line_Total() when changing any tax calculation here. *****
@UncheckedAccess
FUNCTION Get_Sale_Price_Incl_Tax_Total (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2 DEFAULT NULL,
   rel_no_       IN VARCHAR2 DEFAULT NULL,
   line_item_no_ IN NUMBER DEFAULT NULL,
   exclude_item_ IN VARCHAR2 DEFAULT 'FALSE') RETURN NUMBER
IS
   contract_               CUSTOMER_ORDER_LINE_TAB.contract%TYPE;
   currency_code_          VARCHAR2(3);
   total_gross_amount_     NUMBER;
   net_curr_amount_        NUMBER;
   gross_curr_amount_      NUMBER := 0;
   rounding_               NUMBER;
   rental_chargeable_days_ NUMBER;
   total_discount_amount_  NUMBER;
   fetched_line_no_        CUSTOMER_ORDER_LINE_TAB.line_no%TYPE;
   fetched_rel_no_         CUSTOMER_ORDER_LINE_TAB.rel_no%TYPE;
   fetched_line_item_no_   CUSTOMER_ORDER_LINE_TAB.line_item_no%TYPE;   
   free_of_charge_db_      VARCHAR2(20);
   rental_db_              VARCHAR2(20);
   header_rec_             Customer_Order_API.Public_Rec;
   CURSOR get_total IS
      SELECT contract, buy_qty_due * price_conv_factor * unit_price_incl_tax total_gross_amount, line_no, rel_no, line_item_no, free_of_charge, rental
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no     = order_no_
      AND    (line_no = line_no_ OR line_no_ IS NULL)
      AND    (rel_no = rel_no_ OR rel_no_ IS NULL)
      AND    (line_item_no = line_item_no_ 
              OR (line_item_no_ IS NULL AND line_item_no <= 0 AND rowstate != 'Cancelled'))
      AND    (exclude_item_ != 'TRUE' OR (charged_item != 'ITEM NOT CHARGED' AND exchange_item != 'EXCHANGED ITEM')); 
BEGIN
   OPEN get_total;
   FETCH get_total INTO contract_, total_gross_amount_, fetched_line_no_, fetched_rel_no_, fetched_line_item_no_, free_of_charge_db_, rental_db_;
   
   header_rec_ := Customer_Order_API.Get(order_no_);    
   WHILE get_total%FOUND LOOP
      IF (currency_code_ IS NULL) THEN
         -- Enough to fetch once in the loop
         currency_code_          := header_rec_.currency_code;
         rounding_               := Currency_Code_API.Get_Currency_Rounding(Site_API.Get_Company(contract_), currency_code_);
      END IF;
      IF (free_of_charge_db_ = Fnd_Boolean_API.DB_TRUE) THEN
         gross_curr_amount_ := gross_curr_amount_ + Get_Total_Tax_Amount_Curr(order_no_, fetched_line_no_, fetched_rel_no_, fetched_line_item_no_, rounding_);
      ELSE 
         IF header_rec_.use_price_incl_tax = 'TRUE' THEN
            rental_chargeable_days_ := Get_Rental_Chargeable_Days(order_no_, fetched_line_no_, fetched_rel_no_, fetched_line_item_no_, rental_db_);

            total_gross_amount_     := ROUND((total_gross_amount_ * rental_chargeable_days_), rounding_);
            total_discount_amount_  := Get_Total_Discount_Amount(order_no_, fetched_line_no_, fetched_rel_no_, fetched_line_item_no_, total_gross_amount_);
            gross_curr_amount_      := gross_curr_amount_ + total_gross_amount_ - total_discount_amount_;      
         ELSE
            net_curr_amount_   := Get_Sale_Price_Total(order_no_, fetched_line_no_, fetched_rel_no_, fetched_line_item_no_);
            gross_curr_amount_ := gross_curr_amount_ + net_curr_amount_ + Get_Total_Tax_Amount_Curr(order_no_, fetched_line_no_, fetched_rel_no_, fetched_line_item_no_, rounding_);
         END IF;
      END IF;
      FETCH get_total INTO contract_, total_gross_amount_, fetched_line_no_, fetched_rel_no_, fetched_line_item_no_, free_of_charge_db_, rental_db_;
   END LOOP;
   CLOSE get_total; 
   RETURN gross_curr_amount_;
END Get_Sale_Price_Incl_Tax_Total;


-- Get_Sale_Price_Excl_Tax_Total
--   Retrive the total sale price excluding tax for the specified order line in order currency.
@UncheckedAccess
FUNCTION Get_Sale_Price_Excl_Tax_Total (
   order_no_       IN VARCHAR2,
   line_no_        IN VARCHAR2,
   rel_no_         IN VARCHAR2,
   line_item_no_   IN NUMBER,
   tax_percentage_ IN NUMBER ) RETURN NUMBER
IS
   contract_               VARCHAR2(5);
   currency_code_          VARCHAR2(3);
   total_gross_amount_     NUMBER;
   total_net_amount_       NUMBER;
   discount_               NUMBER;
   order_discount_         NUMBER;
   additional_discount_    NUMBER;
   line_discount_amount_   NUMBER;
   add_disc_amt_           NUMBER;
   order_discount_amount_  NUMBER;
   net_curr_amount_        NUMBER;
   rounding_               NUMBER;
   rental_db_              CUSTOMER_ORDER_LINE_TAB.rental%TYPE;
   buy_qty_due_            NUMBER;
   price_conv_factor_      NUMBER;
   total_discount_         NUMBER;
   rental_chargeable_days_ NUMBER;

   CURSOR get_total IS
      SELECT contract, buy_qty_due * price_conv_factor * unit_price_incl_tax total_gross_amount,
             discount, order_discount, additional_discount, buy_qty_due, price_conv_factor, rental
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    line_item_no = line_item_no_;
BEGIN
   OPEN get_total;
   FETCH get_total INTO contract_, total_gross_amount_, discount_, order_discount_, additional_discount_, buy_qty_due_, price_conv_factor_, rental_db_;
   CLOSE get_total;
   currency_code_          := CUSTOMER_ORDER_API.Get_Currency_Code(order_no_);
   rounding_               := Currency_Code_API.Get_Currency_Rounding(Site_API.Get_Company(contract_),currency_code_);

   rental_chargeable_days_ := Get_Rental_Chargeable_Days(order_no_, line_no_, rel_no_, line_item_no_, rental_db_);

   total_gross_amount_     := total_gross_amount_ * rental_chargeable_days_;
   total_gross_amount_     := ROUND(total_gross_amount_, rounding_);
   total_net_amount_       := ROUND(total_gross_amount_ / (1 + (tax_percentage_/100)), rounding_);
   line_discount_amount_   := Cust_Order_Line_Discount_API.Get_Total_Line_Discount(order_no_, line_no_, rel_no_, line_item_no_,
                                                                                   buy_qty_due_, price_conv_factor_, rounding_);
   add_disc_amt_           := ROUND(((total_gross_amount_ - line_discount_amount_) * additional_discount_/100 ), rounding_);
   order_discount_amount_  := ROUND((total_gross_amount_ - line_discount_amount_) * (order_discount_ / 100), rounding_);

   -- discount without tax is calculated seperately for discount types
   line_discount_amount_   := Cust_Order_Line_Discount_API.Get_Total_Line_Discount(order_no_, line_no_, rel_no_, line_item_no_,
                                                                                   buy_qty_due_, price_conv_factor_, rounding_, tax_percentage_ => tax_percentage_);
   add_disc_amt_           := ROUND(add_disc_amt_ / (1 + (tax_percentage_/100)), rounding_);
   order_discount_amount_  := ROUND(order_discount_amount_ / (1 + (tax_percentage_/100)), rounding_);
   total_discount_         := line_discount_amount_ + add_disc_amt_ + order_discount_amount_;
   net_curr_amount_        := total_net_amount_ - total_discount_;

   RETURN net_curr_amount_;
END Get_Sale_Price_Excl_Tax_Total;


-- Get_Base_Sale_Price_Total
--   Gets the Sale_Price_Total for the specified order line in base Currency
--   If Price Including Tax setup is used then amount is calculated as Gross Amount in base currency - Tax Amount in base currency
--   If Price Including Tax setup is not used then amount is calculated as Net Amount in order currency * currency rate
@UncheckedAccess
FUNCTION Get_Base_Sale_Price_Total (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   net_base_amount_  NUMBER;
BEGIN
   -- Please Note : Since sale_unit_price (price each) can have as many decimals as you like discounts and total_gross_base_amount_ needed to get rounded using Order Currency settings though the calculation is for base amounts.
   -- The final line total base amount (net_base_amount_) is rounded using accounting currency settings. This is to tally with invoice figures.
   net_base_amount_ := Get_Price_Total___( order_no_, line_no_, rel_no_, line_item_no_, NULL, 'FALSE', true );

   RETURN net_base_amount_;
END Get_Base_Sale_Price_Total;

-- Get_Base_Sale_Price_Total
--   Logic is same as above. Difference is we have net_curr_amount_ on hand.
--   This method is introduced to improve performance in POST_ORDER_UpdateSourceTaxItem.sql.
@UncheckedAccess
FUNCTION Get_Base_Sale_Price_Total (
   order_no_         IN VARCHAR2,
   line_no_          IN VARCHAR2,
   rel_no_           IN VARCHAR2,
   line_item_no_     IN NUMBER,
   net_curr_amount_  IN NUMBER) RETURN NUMBER
IS
   currency_rate_    NUMBER;
   rounding_         NUMBER;
   company_          VARCHAR2(20);
   net_base_amount_  NUMBER;
   contract_         customer_order_line_tab.contract%TYPE;
   
   CURSOR get_curr_rate IS
      SELECT currency_rate, contract
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no     = order_no_
      AND    line_no      = line_no_
      AND    rel_no       = rel_no_
      AND    line_item_no = line_item_no_;
BEGIN
   OPEN  get_curr_rate;
   FETCH get_curr_rate INTO currency_rate_, contract_;
   CLOSE get_curr_rate;
   company_    := Site_API.Get_Company(contract_);
   rounding_   := Currency_Code_API.Get_Currency_Rounding(company_, Company_Finance_API.Get_Currency_Code(company_));   
   -- Please Note : Since sale_unit_price (price each) can have as many decimals as you like discounts and total_gross_base_amount_ needed to get rounded using Order Currency settings though the calculation is for base amounts.
   -- The final line total base amount (net_base_amount_) is rounded using accounting currency settings. This is to tally with invoice figures.
   net_base_amount_ := ROUND(net_curr_amount_ * currency_rate_, rounding_);

   RETURN net_base_amount_;
END Get_Base_Sale_Price_Total;

-- Get_Base_Sale_Price_Total
--   Gets the Sale_Price_Total in base Currency for freight price list
@UncheckedAccess
FUNCTION Get_Base_Sale_Price_Total (
   order_no_              IN VARCHAR2,
   freight_map_id_        IN VARCHAR2,
   zone_id_               IN VARCHAR2,
   freight_price_list_no_ IN VARCHAR2,
   planned_ship_date_     IN DATE ) RETURN NUMBER
IS
   temp_          NUMBER;
   company_       VARCHAR2(20);
   currency_code_ VARCHAR2(3);
   rounding_      NUMBER;
   line_discount_ NUMBER;
   price_total_   NUMBER :=0;
   price_curr_    NUMBER;
   curr_rounding_ NUMBER;
   sale_amount_   NUMBER;
   header_rec_    Customer_Order_API.Public_Rec;
   
   CURSOR get_line_data IS
      SELECT line_no, rel_no, line_item_no, buy_qty_due, price_conv_factor, currency_rate,
             (buy_qty_due * sale_unit_price * price_conv_factor) sale_amount,
             (buy_qty_due * unit_price_incl_tax * price_conv_factor) sale_amt_with_tax,
             order_discount, additional_discount
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    freight_map_id = freight_map_id_
      AND    zone_id = zone_id_
      AND    freight_price_list_no = freight_price_list_no_
      AND    planned_ship_date = planned_ship_date_
      AND    rowstate != 'Cancelled';
BEGIN
   header_rec_    := Customer_Order_API.Get(order_no_);    
   company_       := Site_API.Get_Company(header_rec_.contract);
   currency_code_ := Company_Finance_API.Get_Currency_Code(company_);
   rounding_      := Currency_Code_API.Get_Currency_Rounding(company_, currency_code_);

   curr_rounding_ := Currency_Code_API.Get_Currency_Rounding(company_,  header_rec_.currency_code);
   FOR rec_ IN get_line_data LOOP
      IF (header_rec_.use_price_incl_tax  = 'TRUE' )THEN
         sale_amount_ := rec_.sale_amt_with_tax;
      ELSE
         sale_amount_ := rec_.sale_amount;
      END IF;
      line_discount_ :=  Cust_Order_Line_Discount_API.Get_Total_Line_Discount(order_no_, rec_.line_no, rec_.rel_no, rec_.line_item_no,
                                                                              rec_.buy_qty_due, rec_.price_conv_factor, curr_rounding_);
      price_curr_    := ROUND((sale_amount_ - line_discount_) * (1-(rec_.order_discount + rec_.additional_discount)/100), curr_rounding_);
      price_total_   := price_total_ + ROUND(price_curr_ * rec_.currency_rate, rounding_ ) ;
   END LOOP;
   IF price_total_ = 0 THEN
      temp_ := NULL;
   ELSE
      temp_ := price_total_;
   END IF;
   RETURN temp_;
END Get_Base_Sale_Price_Total;


-- Get_Base_Price_Incl_Tax_Total
--   Gets the Sale_Price_Total for the specified order line in base Currency
--   If Price Including Tax setup is used then amount is calculated as Gross Amount in order currency * currency rate
--   If Price Including Tax setup is not used then amount is calculated as Net Amount in base currency + Tax Amount in base currency
@UncheckedAccess
FUNCTION Get_Base_Price_Incl_Tax_Total (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   currency_rate_       NUMBER;
   rounding_            NUMBER;
   company_             VARCHAR2(20);
   gross_base_amount_   NUMBER;
   CURSOR get_curr_rate IS
      SELECT currency_rate, Site_API.Get_Company(contract) company
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    line_item_no = line_item_no_;
BEGIN
   IF (Customer_Order_API.Get_Use_Price_Incl_Tax_Db(order_no_)  = 'TRUE') THEN
      OPEN  get_curr_rate;
      FETCH get_curr_rate INTO currency_rate_, company_;
      CLOSE get_curr_rate;
      rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, Company_Finance_API.Get_Currency_Code(company_));
      -- Please Note : Since unit_price_incl_tax (price each) can have as many decimals as you like discounts and total_gross_base_amount_ needed to get rounded using Order Currency settings though the calculation is for base amounts.
      -- The final line total base amount (gross_base_amount_) is rounded using accounting currency settings. This is to tally with invoice figures.
      gross_base_amount_ := ROUND(Get_Sale_Price_Incl_Tax_Total(order_no_, line_no_, rel_no_, line_item_no_) * currency_rate_, rounding_);
   ELSE
      gross_base_amount_ := Get_Base_Sale_Price_Total(order_no_, line_no_, rel_no_, line_item_no_) + Get_Total_Tax_Amount_Base(order_no_, line_no_, rel_no_, line_item_no_);
   END IF;
   RETURN gross_base_amount_;
END Get_Base_Price_Incl_Tax_Total;


-- Get_Next_Line_Item_No
--   Used from orderpkg.apl:
--   Gets the next line item no for a package structure.
PROCEDURE Get_Next_Line_Item_No (
   line_item_no_ IN OUT NUMBER,
   order_no_     IN     VARCHAR2,
   line_no_      IN     VARCHAR2,
   rel_no_       IN     VARCHAR2 )
IS
   CURSOR get_line_item_no IS
   SELECT NVL(max(line_item_no + 1), 1)
   FROM   CUSTOMER_ORDER_LINE_TAB
   WHERE  order_no = order_no_
   AND    line_no = line_no_
   AND    rel_no = rel_no_
   AND    line_item_no != -1;
BEGIN
   OPEN  get_line_item_no;
   FETCH get_line_item_no into line_item_no_;
   CLOSE get_line_item_no;
END Get_Next_Line_Item_No;


-- Get_Shop_Order_Info
--   Return relevant shop order information for an instance.
PROCEDURE Get_Shop_Order_Info (
   so_order_no_      IN OUT VARCHAR2,
   so_release_no_    IN OUT VARCHAR2,
   so_sequence_no_   IN OUT VARCHAR2,
   revised_qty_due_  IN OUT NUMBER,
   revised_due_date_ IN OUT DATE,
   status_code_      IN OUT VARCHAR2,
   order_no_         IN     VARCHAR2,
   line_no_          IN     VARCHAR2,
   rel_no_           IN     VARCHAR2,
   line_item_no_     IN     NUMBER )
IS
   number_ NUMBER := NULL;
   date_   DATE := NULL;
   string_ VARCHAR2(252) := NULL;
BEGIN
   Customer_Order_Shop_Order_API.Get_Shop_Order(so_order_no_, so_release_no_,
   so_sequence_no_, order_no_, line_no_, rel_no_, line_item_no_);
   $IF (Component_Shpord_SYS.INSTALLED) $THEN
      number_  := Shop_Ord_API.Get_Revised_Qty_Due(so_order_no_, so_release_no_, so_sequence_no_);
      date_    := Shop_Ord_Util_API.Get_Due_Date(so_order_no_, so_release_no_, so_sequence_no_);
      string_  := Shop_Ord_Util_API.Get_State(so_order_no_, so_release_no_, so_sequence_no_);
   $END
   revised_qty_due_  := number_;
   revised_due_date_ := date_;
   status_code_      := string_;
END Get_Shop_Order_Info;


-- Get_Purchase_Order_Info
--   Return relevant purchase order information for an instance.
PROCEDURE Get_Purchase_Order_Info (
   po_order_no_          IN OUT VARCHAR2,
   po_line_no_           IN OUT VARCHAR2,
   po_rel_no_            IN OUT VARCHAR2,
   revised_qty_          IN OUT NUMBER,
   planned_receipt_date_ IN OUT DATE,
   status_code_          IN OUT VARCHAR2,
   vendor_no_            IN OUT VARCHAR2,
   contract_             IN OUT VARCHAR2,
   part_no_              IN OUT VARCHAR2,
   description_          IN OUT VARCHAR2,
   unit_meas_            IN OUT VARCHAR2,
   purchase_type_        IN OUT VARCHAR2,
   order_no_             IN     VARCHAR2,
   line_no_              IN     VARCHAR2,
   rel_no_               IN     VARCHAR2,
   line_item_no_         IN     NUMBER )
IS
   $IF Component_Purch_SYS.INSTALLED $THEN
      pur_order_line_part_rec_  Purchase_Order_Line_Part_API.Public_Rec;        
   $END   
BEGIN
   Customer_Order_Pur_Order_API.Get_Purord_For_Custord(po_order_no_, po_line_no_,
                     po_rel_no_, purchase_type_, order_no_, line_no_, rel_no_, line_item_no_);

-- Purchase order
   $IF (Component_Purch_SYS.INSTALLED)$THEN
      IF (purchase_type_ = Purchase_Type_API.Decode('O')) THEN
         pur_order_line_part_rec_ := Purchase_Order_Line_Part_API.Get(po_order_no_, po_line_no_, po_rel_no_);
         vendor_no_            := Purchase_Order_API.Get_Vendor_No(order_no_);
         revised_qty_          := pur_order_line_part_rec_.revised_qty;
         planned_receipt_date_ := pur_order_line_part_rec_.planned_receipt_date;
         status_code_          := Purchase_Order_Line_Util_API.Get_State(po_order_no_, po_line_no_, po_rel_no_);
         description_          := pur_order_line_part_rec_.description;
         unit_meas_            := pur_order_line_part_rec_.unit_meas;
         part_no_              := pur_order_line_part_rec_.part_no;
         contract_             := pur_order_line_part_rec_.contract;
      ELSE
         revised_qty_          := Purchase_Req_Util_API.Get_Line_Original_Qty(po_order_no_, po_line_no_, po_rel_no_);
         part_no_              := Purchase_Req_Util_API.Get_Line_Part_No(po_order_no_, po_line_no_, po_rel_no_);
         contract_             := Purchase_Req_Util_API.Get_Line_Contract(po_order_no_, po_line_no_, po_rel_no_);
         description_          := Purchase_Req_Util_API.Get_Line_Description(po_order_no_, po_line_no_, po_rel_no_);
         planned_receipt_date_ := Purchase_Req_Util_API.Get_Line_Wanted_Receipt_Date(po_order_no_, po_line_no_, po_rel_no_);
         vendor_no_            := Purchase_Req_Util_API.Get_Line_Vendor_No(po_order_no_, po_line_no_, po_rel_no_);
         status_code_          := Purchase_Req_Line_API.Get_State( po_order_no_, po_line_no_, po_rel_no_ );
         unit_meas_            := Purchase_Req_Util_API.Get_Line_Unit_Meas(po_order_no_, po_line_no_, po_rel_no_);
      END IF;
   $ELSE
      NULL;
   $END
END Get_Purchase_Order_Info;


-- Part_Exist
--   Checks if inventory part exist on order lines not 'Invoiced' or 'Cancelled'
@UncheckedAccess
FUNCTION Part_Exist (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   dummy_  NUMBER;
   CURSOR exist_control IS
      SELECT 1
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  contract = contract_
      AND    part_no = part_no_
      AND    rowstate NOT IN ('Invoiced', 'Cancelled');
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF exist_control%NOTFOUND THEN
      dummy_ := 0;
   END IF;
   CLOSE exist_control;
   RETURN dummy_;
END Part_Exist;


-- Exist_Line_No
--   Returns an error message if order line already exist.
PROCEDURE Exist_Line_No (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER )
IS
   dummy_ NUMBER;
   CURSOR exist_control IS
      SELECT 1
        FROM CUSTOMER_ORDER_LINE_TAB
       WHERE order_no = order_no_
         AND line_no = line_no_
         AND rel_no = rel_no_
         AND line_item_no = NVL(line_item_no_, line_item_no);
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      Error_SYS.Record_General(lu_name_, 'LINE_ALREADY_EXISTS: This order line already exists!');
   END IF;
   CLOSE exist_control;
END Exist_Line_No;


-- Exist_Note_Text
--   Return 1 if note_text has a value otherwise 0.
@UncheckedAccess
FUNCTION Exist_Note_Text (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN VARCHAR2
IS
   temp_ CUSTOMER_ORDER_LINE_TAB.note_text%TYPE;
   CURSOR get_attr IS
      SELECT note_text
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    line_item_no = line_item_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   IF (temp_ IS NOT NULL) THEN
      RETURN '1';
   ELSE
      RETURN '0';
   END IF;
END Exist_Note_Text;


-- Get_Part_Description
--   Returns the part description for inventory parts and sales part description
--   for non inventory parts.
@UncheckedAccess
FUNCTION Get_Part_Description (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN VARCHAR2
IS
   CURSOR get_attr IS
      SELECT contract, catalog_no, part_no
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    line_item_no = line_item_no_;
   rec_  get_attr%ROWTYPE;
BEGIN
   IF NOT Check_Exist___(order_no_, line_no_, rel_no_, line_item_no_) THEN
      RETURN NULL;
   ELSE
      OPEN get_attr;
      FETCH get_attr INTO rec_.contract, rec_.catalog_no, rec_.part_no;
      CLOSE get_attr;
      IF (rec_.part_no IS NULL) THEN
         RETURN Sales_Part_API.Get_Catalog_Desc(rec_.contract, rec_.catalog_no);
      ELSE
         RETURN Inventory_Part_API.Get_Description(rec_.contract, rec_.part_no);
      END IF;
   END IF;
END Get_Part_Description;


-- Line_On_Delivery_Note
--   Return TRUE if the specified order line exists on the specified
--   delivery note.
@UncheckedAccess
FUNCTION Line_On_Delivery_Note (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   delnote_no_   IN VARCHAR2 ) RETURN NUMBER
IS
   found_   NUMBER;

   CURSOR on_delnote IS
      SELECT 1
      FROM   CUSTOMER_ORDER_DELIVERY
      WHERE  order_no = order_no_
      AND    line_no  = line_no_
      AND    rel_no   = rel_no_
      AND    line_item_no = line_item_no_
      AND    delnote_no = delnote_no_
      AND    cancelled_delivery_db = 'FALSE';
BEGIN
   OPEN on_delnote;
   FETCH on_delnote INTO found_;
   IF (on_delnote%NOTFOUND) THEN
      found_ := 0;
   END IF;
   CLOSE on_delnote;
   RETURN found_;
END Line_On_Delivery_Note;


-- Get_Qty_Shipped_On_Deliv_Note
--   Return the total qty_shipped for the specified delivery note for
--   the specified order line.
@UncheckedAccess
FUNCTION Get_Qty_Shipped_On_Deliv_Note (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   delnote_no_   IN VARCHAR2 ) RETURN NUMBER
IS
   sum_ NUMBER;
   CURSOR get_sum_qty_shipped IS
      SELECT SUM(qty_shipped)
      FROM   CUSTOMER_ORDER_DELIVERY_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    line_item_no = line_item_no_
      AND    delnote_no = delnote_no_
      AND    cancelled_delivery = 'FALSE';
BEGIN
   OPEN get_sum_qty_shipped;
   FETCH get_sum_qty_shipped INTO sum_;
   IF (get_sum_qty_shipped%NOTFOUND) THEN
      sum_ := 0;
   END IF;
   CLOSE get_sum_qty_shipped;
   RETURN NVL(sum_, 0);
END Get_Qty_Shipped_On_Deliv_Note;


-- Get_Shipped_Not_Invoiced
--   Counts and returns shipped but not invoiced qty
@UncheckedAccess
FUNCTION Get_Shipped_Not_Invoiced (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   temp_  NUMBER;
   CURSOR get_attr IS
      SELECT qty_shipped - qty_invoiced
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    line_item_no = line_item_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Shipped_Not_Invoiced;


-- Set_Qty_Assigned
--   Public interface used to generate a SetQtyAssigned event and pass it
--   to the state diagram
PROCEDURE Set_Qty_Assigned (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_assigned_ IN NUMBER,
   add_hist_log_ IN VARCHAR2 DEFAULT 'TRUE' )
IS
   attr_             VARCHAR2(32000);
   info_             VARCHAR2(32000);
   rec_              CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_            VARCHAR2(2000);
   objversion_       VARCHAR2(2000);
   msg_              VARCHAR2(200);
   old_qty_assigned_ NUMBER;
BEGIN
   old_qty_assigned_ := NVL(Get_Qty_Assigned(order_no_, line_no_, rel_no_, line_item_no_),0);
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_ASSIGNED', qty_assigned_, attr_);
   rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   Set_Qty_Assigned__(info_, objid_, objversion_, attr_, 'DO');
   IF ((qty_assigned_ > old_qty_assigned_) AND NVL(add_hist_log_, 'TRUE') != 'FALSE') THEN
      msg_ := Language_SYS.Translate_Constant(lu_name_, 'LINERESERVED: :P1 :P2 Reserved', NULL, to_char(qty_assigned_ - old_qty_assigned_), Inventory_Part_API.Get_Unit_Meas(rec_.contract, rec_.part_no));
      Customer_Order_Line_Hist_API.New(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no, msg_);
   END IF;
END Set_Qty_Assigned;


-- Set_Qty_Confirmeddiff
--   Generates the SetQtyConfirmeddiff state event
PROCEDURE Set_Qty_Confirmeddiff (
   order_no_          IN VARCHAR2,
   line_no_           IN VARCHAR2,
   rel_no_            IN VARCHAR2,
   line_item_no_      IN NUMBER,
   qty_confirmeddiff_ IN NUMBER )
IS
   attr_        VARCHAR2(32000);
   info_        VARCHAR2(32000);
   rec_         CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_       VARCHAR2(2000);
   objversion_  VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_CONFIRMEDDIFF', qty_confirmeddiff_, attr_);
   rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   Set_Qty_Confirmeddiff__(info_, objid_, objversion_, attr_, 'DO');
   -- IF the state has changed create a history record
   IF (rec_.rowstate != Get_Objstate(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no)) THEN
      Customer_Order_Line_Hist_API.New(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
   END IF;
END Set_Qty_Confirmeddiff;


-- Set_Qty_Picked
--   Public interface used to generate a SetQtyPicked event and pass it to
--   the state diagram
PROCEDURE Set_Qty_Picked (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_picked_   IN NUMBER,
   add_hist_log_ IN VARCHAR2 DEFAULT 'TRUE')
IS
   attr_       VARCHAR2(32000);
   info_       VARCHAR2(32000);
   rec_        CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_      VARCHAR2(2000);
   objversion_ VARCHAR2(2000);
   msg_        VARCHAR2(200);
   new_state_  CUSTOMER_ORDER_LINE_TAB.rowstate%TYPE;
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_PICKED', qty_picked_, attr_);
   rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   Set_Qty_Picked__(info_, objid_, objversion_, attr_, 'DO');
   new_state_ := Get_Objstate(order_no_, line_no_, rel_no_, line_item_no_);   
   IF ((rec_.rowstate != new_state_) AND (new_state_ = 'Released') AND (add_hist_log_ = 'TRUE')) THEN
      -- Added message saying 0 delivered.
      msg_ := Language_SYS.Translate_Constant(lu_name_, 'ZERODELIVERED: 0 :P1 delivered with differences', NULL, rec_.sales_unit_meas);
      Customer_Order_Line_Hist_API.New(order_no_, line_no_, rel_no_, line_item_no_, msg_);
   END IF;
END Set_Qty_Picked;


PROCEDURE Set_Qty_Shipped (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_shipped_  IN NUMBER,
   from_undo_delivery_ IN VARCHAR2 DEFAULT 'FALSE')
IS
   attr_              VARCHAR2(32000);
   info_              VARCHAR2(32000);
   rec_               CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_             VARCHAR2(2000);
   objversion_        VARCHAR2(2000);
   msg_               VARCHAR2(200);
   old_qty_shipped_   NUMBER;
BEGIN
   old_qty_shipped_ := Get_Qty_Shipped(order_no_, line_no_, rel_no_, line_item_no_);
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_SHIPPED', qty_shipped_, attr_);
   rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   Set_Qty_Shipped__(info_, objid_, objversion_, attr_, 'DO');
   -- The state after delivery could be Invoiced/Closed, but the message should still be 'Delivered'.
   msg_ := Language_SYS.Translate_Constant(lu_name_, 'LINEDELIVERED: :P1 :P2 Delivered', NULL, to_char(qty_shipped_ - old_qty_shipped_), Inventory_Part_API.Get_Unit_Meas(rec_.contract, rec_.part_no));
   -- Added a new condition to state the delivered state when the CO line is in Invoiced/Closed state after the delivery.
   IF(Get_Objstate(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no) = 'Invoiced') THEN
      Customer_Order_Line_Hist_API.New(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no, msg_, 'Delivered');
      IF (from_undo_delivery_ = 'FALSE') THEN
         Customer_Order_Line_Hist_API.New(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
      END IF;
   ELSE
      Customer_Order_Line_Hist_API.New(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no, msg_);
   END IF;
END Set_Qty_Shipped;


-- Set_Qty_Shipdiff
--   Public interface used to generate the SetQtyShipdiff event and pass
--   it to the finite state machine for processing.
PROCEDURE Set_Qty_Shipdiff (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_shipdiff_ IN NUMBER )
IS
   attr_       VARCHAR2(32000);
   info_       VARCHAR2(32000);
   rec_        CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_      VARCHAR2(2000);
   objversion_ VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_SHIPDIFF', qty_shipdiff_, attr_);
   rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   Set_Qty_Shipdiff__(info_, objid_, objversion_, attr_, 'DO');

   -- IF the state has changed create a history record
   IF (rec_.rowstate != Get_Objstate(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no)) THEN
      Customer_Order_Line_Hist_API.New(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
   END IF;
END Set_Qty_Shipdiff;


-- Set_Qty_Invoiced
--   Public interface used to generate the SetQtyInvoiced event and pass
--   it to the finite state machine
PROCEDURE Set_Qty_Invoiced (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_invoiced_ IN NUMBER )
IS
   attr_         VARCHAR2(32000);
   info_         VARCHAR2(32000);
   rec_          CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_        VARCHAR2(2000);
   objversion_   VARCHAR2(2000);
   new_objstate_ VARCHAR2(30);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_INVOICED', qty_invoiced_, attr_);
   rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   Set_Qty_Invoiced__(info_, objid_, objversion_, attr_, 'DO');

   -- IF the state has changed create a history record
   new_objstate_ := Get_Objstate(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
   IF (rec_.rowstate != new_objstate_) THEN
      Customer_Order_Line_Hist_API.New(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
   END IF;
END Set_Qty_Invoiced;


-- Set_Cancelled
--   Public interface used to generate the SetCancelled event and pass it
--   to the finite state machine for processing.
PROCEDURE Set_Cancelled (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER )
IS
   attr_       VARCHAR2(32000);
   info_       VARCHAR2(32000);
   rec_        CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_      VARCHAR2(2000);
   objversion_ VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   Set_Cancelled__(info_, objid_, objversion_, attr_, 'DO');
   Order_Line_Commission_API.Cancel_Order_Commission_Lines(order_no_, line_no_, rel_no_, line_item_no_);

   -- IF the state has changed create a history record
   IF (rec_.rowstate != Get_Objstate(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no)) THEN
      Customer_Order_Line_Hist_API.New(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
   END IF;
END Set_Cancelled;


-- Set_Released
--   Public interface used to generate the SetRelased event and pass it to
--   the finite state machine for processing.
PROCEDURE Set_Released (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER )
IS
   attr_       VARCHAR2(32000);
   info_       VARCHAR2(32000);
   rec_        CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_      VARCHAR2(2000);
   objversion_ VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   Set_Released__(info_, objid_, objversion_, attr_, 'DO');

   -- IF the state has changed create a history record
   IF (rec_.rowstate != Get_Objstate(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no)) THEN
      Customer_Order_Line_Hist_API.New(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
   END IF;
END Set_Released;

-- Set_Qty_Short
--   This method updates the qty_short column with the passed in value.
PROCEDURE Set_Qty_Short (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_short_    IN NUMBER )
IS
   attr_  VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_SHORT', qty_short_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Set_Qty_Short;


-- Calculate_Qty_To_Load
--   Calculates Quantity to Load that is available for Shipment.
@UncheckedAccess
FUNCTION Calculate_Qty_To_Load (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   temp_ NUMBER;
   CURSOR get_attr IS
      SELECT DECODE(col.part_no, NULL, col.qty_to_ship, col.qty_picked)
      FROM   CUSTOMER_ORDER_LINE_TAB col, CUSTOMER_ORDER_TAB co
      WHERE  col.order_no = co.order_no
      AND    col.order_no = order_no_
      AND    col.line_no = line_no_
      AND    col.rel_no = rel_no_
      AND    col.line_item_no = line_item_no_
      AND    co.rowstate != 'Planned';
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN NVL(temp_, 0);
END Calculate_Qty_To_Load;


-- Get_Sum_Invoiced_Base_Curr
--   Return the total value of the invoiced items for this order row in
--   the base currency.
@UncheckedAccess
FUNCTION Get_Sum_Invoiced_Base_Curr (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
BEGIN
   RETURN Get_Sum_Invoiced_Base_Curr__(order_no_, line_no_, rel_no_, line_item_no_);
END Get_Sum_Invoiced_Base_Curr;


-- New
--   Public interface for creating a new order line.
PROCEDURE New (
   info_ OUT    VARCHAR2,
   attr_ IN OUT VARCHAR2 )
IS   
   new_attr_                VARCHAR2(32000);
   newrec_                  CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_                   VARCHAR2(2000);
   objversion_              VARCHAR2(2000);   
   discount_                CUSTOMER_ORDER_LINE_TAB.discount%TYPE := NULL;   
   insert_package_mode_     VARCHAR2(5);
   current_info_            VARCHAR2(32000);
   indrec_                  Indicator_Rec;   
   create_partial_sum_      CUST_ORDER_LINE_DISCOUNT_TAB.Create_Partial_Sum%TYPE;
   copy_discount_           VARCHAR2(5);
BEGIN
   Client_SYS.Clear_Info;
   current_info_ := NULL;
   App_Context_SYS.Set_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_',current_info_);   
   
   Build_Attr_For_New___(discount_, copy_discount_, create_partial_sum_, new_attr_, attr_);
   
   Unpack___(newrec_, indrec_, new_attr_);
   Check_Insert___(newrec_, indrec_, new_attr_);
   current_info_ := Client_SYS.Get_All_Info;
   App_Context_SYS.Set_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_',current_info_);
   Insert___(objid_, objversion_, newrec_, new_attr_);

   insert_package_mode_ := Client_SYS.Get_Item_Value('INSERT_PACKAGE_MODE_', new_attr_);

   Add_Info___(insert_package_mode_);
   current_info_ := App_Context_SYS.Find_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_');

   info_ := current_info_;
   attr_ := new_attr_;

   -- IF the discount passed in is not the same as the current discount for the order line
   -- then all the default discount records should be removed and a new record containing
   -- the desired discount should be created.
   IF (discount_ IS NOT NULL) THEN
      IF ((discount_ != newrec_.discount) OR NVL(copy_discount_, 'FALSE') = 'TRUE') THEN
         Customer_Order_Pricing_API.Replace_Default_Discount_Rec(newrec_.order_no, newrec_.line_no, newrec_.rel_no,
                                                                 newrec_.line_item_no, discount_, create_partial_sum_, copy_discount_);
      END IF;
   END IF;
END New;


-- Modify
--   Public interface for modifying an order line.
--   Attributes holding different quantities for the order line such as
--   qty_assigned, qty_picked, qty_shipped and qty_invoiced should not
--   be modified using this procedure.
PROCEDURE Modify (
   attr_         IN OUT VARCHAR2,
   order_no_     IN     VARCHAR2,
   line_no_      IN     VARCHAR2,
   rel_no_       IN     VARCHAR2,
   line_item_no_ IN     NUMBER )
IS
   newrec_          CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   header_rowstate_ CUSTOMER_ORDER_TAB.rowstate%TYPE;
   oldrec_          Public_Rec;
   qty_on_order_    NUMBER;
   sent_configuration_ VARCHAR2(5);
BEGIN
   oldrec_ := Get (order_no_, line_no_, rel_no_, line_item_no_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);

   newrec_          := Lock_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   header_rowstate_ := CUSTOMER_ORDER_API.Get_Objstate(order_no_);
   IF ((newrec_.supply_code IN ('SO', 'PT', 'PD', 'IPT', 'IPD', 'DOP' )) AND
      (header_rowstate_ NOT IN ('Planned', 'Blocked'))) THEN
      -- Note: Connected orders are normally created when the order is released,
      -- Note: but if the configured lines are added after releasing the order, connected orders must be created
      -- Note: while entering the configuration details
      sent_configuration_ := Client_Sys.Get_Item_Value('SENT_CONFIGURATION', attr_);
      IF (Sales_Part_API.Get_Configurable_Db(newrec_.contract, NVL(newrec_.part_no, newrec_.catalog_no)) = 'CONFIGURED'
          AND newrec_.configuration_id != '*'
          AND oldrec_.qty_on_order = 0
          AND sent_configuration_ = 'TRUE'
          AND Order_Config_Util_API.Get_Config_Spec_Objstate(NVL(newrec_.part_no, newrec_.catalog_no), newrec_.configuration_id) = 'Completed') THEN
         Connect_Customer_Order_API.Create_Connected_Order_Line(qty_on_order_, order_no_, line_no_, rel_no_, line_item_no_, FALSE);
      END IF;
   END IF;

   IF ((newrec_.configuration_id != '*') AND (oldrec_.configuration_id != newrec_.configuration_id)) THEN
      IF (newrec_.load_id IS NOT NULL) THEN
         Cust_Order_Load_List_Line_API.Modify_Line_Weights(load_id_      => newrec_.load_id,
                                                           pos_          => Cust_Order_Load_List_Line_API.Get_Pos(newrec_.load_id, newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no),
                                                           weight_net_   => newrec_.line_total_weight,
                                                           weight_gross_ => newrec_.line_total_weight_gross);
      END IF;
   END IF;

END Modify;


-- Remove
--   Public interface for removing an order line.
PROCEDURE Remove (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER )
IS
   remrec_     CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_      VARCHAR2(2000);
   objversion_ VARCHAR2(2000);
BEGIN
   remrec_ := Lock_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   Check_Delete___(remrec_);
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   Delete___(objid_, remrec_);
END Remove;

@IgnoreUnitTest TrivialFunction
-- Get_Objversion
--   Return the current objversion for line.
@UncheckedAccess
FUNCTION Get_Objversion (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN VARCHAR2
IS
   temp_  CUSTOMER_ORDER_LINE_TAB.rowversion%TYPE;
   CURSOR get_attr IS
      SELECT rowversion
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    line_item_no = line_item_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN TO_CHAR(temp_, 'YYYYMMDDHH24MISS');
END Get_Objversion;


-- Check_State
--   This method should be called when changes have been made to an order
--   which could cause state changes on the order header, and the changes
--   have not been made using the Finite_State_Machine methods.
--   One example of when the method should be called is if the buy qty on
--   an order line is decreased. In some cases this should cause a state change.
PROCEDURE Check_State (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER )
IS
   rec_      CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   attr_     VARCHAR2(2000);
   objstate_ CUSTOMER_ORDER_LINE_TAB.rowstate%TYPE;
BEGIN
   rec_      := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   objstate_ := rec_.rowstate;
   IF (objstate_ != 'Invoiced') THEN
      Finite_State_Machine___(rec_, NULL, attr_);
   END IF;

   IF (objstate_ != rec_.rowstate) THEN
      -- Objstate was changed, the state of the header should also be checked
      CUSTOMER_ORDER_API.Check_State(order_no_);
   END IF;
END Check_State;


-- Modify_Sm_Connection
--   Modify SM_Connection, used by Service Management
PROCEDURE Modify_Sm_Connection (
   order_no_         IN VARCHAR2,
   line_no_          IN VARCHAR2,
   rel_no_           IN VARCHAR2,
   line_item_no_     IN NUMBER,
   sm_connection_db_ IN VARCHAR2 )
IS
   attr_  VARCHAR2(2000);
BEGIN
   -- Checks for prepayment exists before a work order is connected to a customer order line.
   IF (Customer_Order_API.Get_Proposed_Prepayment_Amount(order_no_) > 0) THEN
      Error_SYS.Record_General(lu_name_, 'PREPAY_EXIST_SM: When required prepayment exists for the customer order SM object can not be connected.');
   END IF;

   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_to_Attr('SM_CONNECTION_DB', sm_connection_db_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Sm_Connection;


-- Get_Total_Cost
--   Returns the total cost of an order line.
@UncheckedAccess
FUNCTION Get_Total_Cost (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   temp_          NUMBER;
   contract_      VARCHAR2(5);
   company_       VARCHAR2(20);
   currency_code_ VARCHAR2(3);
   rounding_      NUMBER;

   CURSOR get_total(rounding_ in NUMBER) IS
      SELECT round(revised_qty_due * cost, rounding_)
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    line_item_no = line_item_no_;
BEGIN
   contract_      := CUSTOMER_ORDER_API.Get_Contract(order_no_);
   company_       := Site_API.Get_Company(contract_);
   currency_code_ := Company_Finance_API.Get_Currency_Code(company_);
   rounding_      := Currency_Code_API.Get_Currency_Rounding(company_, currency_code_);
   OPEN get_total(rounding_);
   FETCH get_total INTO temp_;
   IF (get_total%NOTFOUND) THEN
      temp_ := NULL;
   END IF;
   CLOSE get_total;
   RETURN temp_;
END Get_Total_Cost;


-- Get_Total_Discount_Percentage_
--   Returns the rounded total disount percentage for an order line.
--   Rounding done only at the end, for the percentage amount.
@UncheckedAccess
FUNCTION Get_Total_Discount_Percentage (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   -- -- gelr:disc_price_rounded, added original_order_discount, original_add_discount
   CURSOR get_attr IS
      SELECT buy_qty_due * sale_unit_price * price_conv_factor     net_amount_,
             buy_qty_due * unit_price_incl_tax * price_conv_factor gross_amount_,
             buy_qty_due, price_conv_factor, order_discount, additional_discount, rental,
             original_order_discount, original_add_discount
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no     = order_no_
      AND    line_no      = line_no_
      AND    rel_no       = rel_no_
      AND    line_item_no = line_item_no_;

   rec_                    get_attr%ROWTYPE;
   discount_percentage_    CUSTOMER_ORDER_LINE_TAB.discount%TYPE := 0;
   amount_                 NUMBER;
   rental_chargable_days_  NUMBER;
   line_discount_amount_   NUMBER;
   additional_disc_amount_ NUMBER;
   order_discount_amount_  NUMBER;
BEGIN   
   OPEN get_attr;
   FETCH get_attr INTO rec_;
   CLOSE get_attr;
   
   IF (Customer_Order_API.Get_Use_Price_Incl_Tax_Db(order_no_)  = 'TRUE') THEN
      amount_ := NVL(rec_.gross_amount_, 0);
   ELSE
      amount_ := NVL(rec_.net_amount_, 0);
   END IF;   
   
   IF (amount_ != 0) THEN
      rental_chargable_days_  := Get_Rental_Chargeable_Days(order_no_, line_no_, rel_no_, line_item_no_, rec_.rental);
      IF (rental_chargable_days_ != 0) THEN
         amount_                 := amount_ * rental_chargable_days_;
         -- gelr:disc_price_rounded, begin
         -- use  original_order_discount, original_add_discount when using Discounted Price Rounded
         IF (Customer_Order_API.Get_Discounted_Price_Rounded(order_no_)) THEN
            line_discount_amount_ := Cust_Order_Line_Discount_API.Get_Original_Total_Line_Disc (order_no_,
                                                                  line_no_,
                                                                  rel_no_,
                                                                  line_item_no_,
                                                                  rec_.buy_qty_due,
                                                                  rec_.price_conv_factor);                       
            additional_disc_amount_ := (amount_ - line_discount_amount_) * rec_.original_add_discount/100 ;
            order_discount_amount_  := (amount_ - line_discount_amount_) * rec_.original_order_discount /100;                  
         ELSE
         -- gelr:disc_price_rounded, end
            line_discount_amount_   := Cust_Order_Line_Discount_API.Get_Total_Line_Discount(order_no_, 
                                                                                            line_no_, 
                                                                                            rel_no_, 
                                                                                            line_item_no_,
                                                                                            rec_.buy_qty_due, 
                                                                                            rec_.price_conv_factor);           
            additional_disc_amount_ := (amount_ - line_discount_amount_) * rec_.additional_discount/100 ;
            order_discount_amount_  := (amount_ - line_discount_amount_) * rec_.order_discount /100;  
         -- gelr:disc_price_rounded, begin
         END IF;
         -- gelr:disc_price_rounded, end
         discount_percentage_    := (line_discount_amount_ + additional_disc_amount_ + order_discount_amount_) / amount_ * 100;
         discount_percentage_    := ROUND(discount_percentage_, 2);
      END IF;         
   END IF;
   RETURN discount_percentage_;
END Get_Total_Discount_Percentage;


-- Get_Total_Discount_Amount
--   Retrieve the total discount amount for given net/PIV amount.
--   Line, additional and order discounts are rounded separately and add together.
FUNCTION Get_Total_Discount_Amount (
   order_no_              IN VARCHAR2,
   line_no_               IN VARCHAR2,
   rel_no_                IN VARCHAR2,
   line_item_no_          IN NUMBER,
   total_amount_          IN NUMBER ) RETURN NUMBER
IS
   rec_                    Public_Rec;
   currency_code_          VARCHAR2(3);
   rounding_               NUMBER;
   line_discount_amount_   NUMBER;
   additional_disc_amount_ NUMBER;
   order_discount_amount_  NUMBER;
   total_discount_amount_  NUMBER;
BEGIN
   rec_           := Get(order_no_, line_no_, rel_no_, line_item_no_);      
   currency_code_ := Customer_Order_API.Get_Currency_Code(order_no_);
   rounding_      := Currency_Code_API.Get_Currency_Rounding(Site_API.Get_Company(rec_.contract), currency_code_);   
   
   line_discount_amount_   := Cust_Order_Line_Discount_API.Get_Total_Line_Discount( order_no_, 
                                                                                    line_no_, 
                                                                                    rel_no_, 
                                                                                    line_item_no_, 
                                                                                    rec_.buy_qty_due, 
                                                                                    rec_.price_conv_factor, 
                                                                                    rounding_ );
   additional_disc_amount_ := ROUND(((total_amount_ - line_discount_amount_) * rec_.additional_discount/100 ), rounding_);
   order_discount_amount_  := ROUND(((total_amount_ - line_discount_amount_) * rec_.order_discount /100), rounding_);
   total_discount_amount_  := line_discount_amount_ + additional_disc_amount_ +  order_discount_amount_;
  
   RETURN total_discount_amount_;
END Get_Total_Discount_Amount;


-- Get_Total_Discount_Incl_Tax
--   Retrieve the total discount amount incluging tax for PIV scenario.
FUNCTION Get_Total_Discount_Incl_Tax (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   contract_               CUSTOMER_ORDER_LINE_TAB.contract%TYPE;
   currency_code_          VARCHAR2(3);
   total_gross_amount_     NUMBER;
   rounding_               NUMBER;
   rental_chargeable_days_ NUMBER;
   total_discount_amount_  NUMBER;
   rental_db_              VARCHAR2(20);
   CURSOR get_total IS
      SELECT contract, buy_qty_due * price_conv_factor * unit_price_incl_tax total_gross_amount, rental
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no     = order_no_
      AND    line_no      = line_no_
      AND    rel_no       = rel_no_
      AND    line_item_no = line_item_no_;
BEGIN
   OPEN get_total;
   FETCH get_total INTO contract_, total_gross_amount_, rental_db_;
   CLOSE get_total;
   
   currency_code_          := Customer_Order_API.Get_Currency_Code(order_no_);
   rounding_               := Currency_Code_API.Get_Currency_Rounding(Site_API.Get_Company(contract_), currency_code_);
   rental_chargeable_days_ := Get_Rental_Chargeable_Days(order_no_, line_no_, rel_no_, line_item_no_, rental_db_);
   total_gross_amount_     := ROUND((total_gross_amount_ * rental_chargeable_days_), rounding_);
   
   total_discount_amount_  := Get_Total_Discount_Amount(order_no_, line_no_, rel_no_, line_item_no_, total_gross_amount_);      
   RETURN total_discount_amount_;
END Get_Total_Discount_Incl_Tax;


-- Set_Ctp_Planned
--   Sets CTP_Planned flag.
PROCEDURE Set_Ctp_Planned (
   order_no_         IN VARCHAR2,
   line_no_          IN VARCHAR2,
   rel_no_           IN VARCHAR2,
   line_item_no_     IN NUMBER )
IS
   attr_   VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('CTP_PLANNED_DB', 'Y', attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Set_Ctp_Planned;


-- Clear_Ctp_Planned
--   Clears CTP_Planned flag.
PROCEDURE Clear_Ctp_Planned (
   order_no_         IN VARCHAR2,
   line_no_          IN VARCHAR2,
   rel_no_           IN VARCHAR2,
   line_item_no_     IN NUMBER )
IS
   attr_       VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('CTP_PLANNED_DB', 'N', attr_);
   Client_SYS.Add_To_Attr('LATEST_RELEASE_DATE', TO_DATE(NULL), attr_);
   -- adding new delivery date so we get some default dates back
   Client_SYS.Add_To_Attr('PLANNED_DELIVERY_DATE', Get_Wanted_Delivery_Date(order_no_, line_no_, rel_no_, line_item_no_), attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Clear_Ctp_Planned;


-- Update_Planning_Date
--   Updates planned_due_date and recalculate all dates forward.
PROCEDURE Update_Planning_Date (
   order_no_                    IN VARCHAR2,
   line_no_                     IN VARCHAR2,
   rel_no_                      IN VARCHAR2,
   line_item_no_                IN NUMBER,
   planned_due_date_            IN DATE,
   message_                     IN VARCHAR2,
   latest_release_date_         IN DATE DEFAULT NULL,
   allocate_db_                 IN VARCHAR2 DEFAULT NULL,
   ignore_wanted_delivery_date_ IN BOOLEAN DEFAULT FALSE )
IS
   text_message_                VARCHAR2(200);
   objid_                       VARCHAR2(2000);
   rowversion_                  VARCHAR2(2000);
   old_delivery_date_           DATE;
   newrec_                      CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   header_rowstate_             CUSTOMER_ORDER_TAB.rowstate%TYPE;
   text_                        VARCHAR2(200);
   wanted_delivery_date_        DATE;
   oldrec_                      CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   attr_                        VARCHAR2(100);
   ctp_run_id_                  NUMBER;   
   lowest_node_count_           NUMBER;
   lowest_node_finish_date_     DATE;
   lowest_node_part_no_         VARCHAR2(25);
   lowest_node_contract_        VARCHAR2(5);   
   lowest_node_info_            VARCHAR2(400);
   cc_info_                     VARCHAR2(3200);
BEGIN
   newrec_                  := Lock_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   oldrec_                  := newrec_;
   header_rowstate_         := CUSTOMER_ORDER_API.Get_Objstate(newrec_.order_no);
   newrec_.planned_due_date := planned_due_date_;
   old_delivery_date_       := newrec_.planned_delivery_date;

   -- ignore_wanted_delivery_date_ is set to TRUE when we want to eliminate the calculation based on the wanted_delivery date
   -- This is used when calling the forward calculation for the Dist Orders created from Dist Allcoation Lines and the Dist Allocation Line's PLanned due date is changed.
   IF ignore_wanted_delivery_date_ THEN
      wanted_delivery_date_ := NULL;
   ELSE
      wanted_delivery_date_ := newrec_.target_date;
   END IF;

   -- calculate planned_delivery_date ,planned_ship_date, supply_site_due_date forwards from planned_due_date
   Calc_Dates_Forwards___(newrec_.planned_delivery_date, newrec_.planned_ship_date, newrec_.planned_due_date,
                          newrec_.supply_site_due_date, newrec_.promised_delivery_date, newrec_.planned_ship_period,
                          wanted_delivery_date_, newrec_.contract, newrec_.supply_code, newrec_.deliver_to_customer_no,
                          newrec_.vendor_no, newrec_.part_no, newrec_.purchase_part_no, newrec_.ship_addr_no, newrec_.ship_via_code,
                          newrec_.route_id, newrec_.delivery_leadtime, newrec_.picking_leadtime, newrec_.ext_transport_calendar_id, newrec_.supplier_ship_via_transit, header_rowstate_);

   -- When the wanted delviery date is ignores, it will be equal to the updated planned delivery date.
   IF  ignore_wanted_delivery_date_ THEN
      newrec_.wanted_delivery_date := newrec_.planned_delivery_date;
      newrec_.target_date          := newrec_.wanted_delivery_date;
   END IF;

   IF (newrec_.rowstate !='Cancelled') THEN
      IF (line_item_no_ <= 0 )  THEN
         IF (old_delivery_date_ != newrec_.planned_delivery_date AND latest_release_date_ IS NULL) THEN
            text_ := SUBSTR(Language_SYS.Translate_Constant(lu_name_, 'TARGETDATECHG2: The planned delivery date has been changed from :P1 to :P2',
                            NULL, TO_CHAR(old_delivery_date_, 'YYYY-MM-DD HH24.MI.SS'), to_char(newrec_.planned_delivery_date, 'YYYY-MM-DD HH24.MI.SS')), 1, 200);
            Customer_Order_Line_Hist_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no, text_);
         END IF;
      END IF;
   END IF;

   -- the capability check engine have returned a date and its one of the allocate/reserve cc alternatives, set the cc planned flag
   IF (latest_release_date_ IS NOT NULL AND allocate_db_ IN ('RESERVE AND ALLOCATE','ALLOCATE ONLY')) THEN
      newrec_.latest_release_date := latest_release_date_;
      newrec_.ctp_planned         := 'Y';
   -- for the neither case set the latest_release_date and set flag to false
   ELSIF (latest_release_date_ IS NOT NULL AND allocate_db_ = 'NEITHER RESERVE NOR ALLOCATE') THEN
      newrec_.latest_release_date := latest_release_date_;
      newrec_.ctp_planned         := 'N';
   END IF;

   IF (old_delivery_date_ != newrec_.planned_delivery_date AND newrec_.latest_release_date IS NOT NULL) THEN
      $IF (Component_Ordstr_SYS.INSTALLED) $THEN
         IF (App_Context_SYS.Find_Number_Value('CTP_RUN_ID') IS NOT NULL) THEN
            ctp_run_id_ := App_Context_SYS.Get_Number_Value('CTP_RUN_ID');
         END IF;
         IF (ctp_run_id_ > 0) THEN
            Interim_Ctp_Critical_Path_API.Update_Is_Deliverable(ctp_run_id_, Fnd_Boolean_API.DB_FALSE);
            Interim_Ctp_Critical_Path_API.Get_Lowest_Node_Details(lowest_node_part_no_, lowest_node_contract_, lowest_node_finish_date_, lowest_node_count_, ctp_run_id_);
            
            IF (lowest_node_count_ > 1) THEN
               lowest_node_info_ := Language_SYS.Translate_Constant(lu_name_,'SEVLOWESTNODE: Several parts exist as lower nodes in the critical path. Would you like to analyze the capability check result?');
            ELSIF (lowest_node_count_ = 1) THEN
               lowest_node_info_ := Language_SYS.Translate_Constant(lu_name_,'LOWESTNODEXIST: Would you like to analyze the capability check result?', NULL,lowest_node_part_no_, lowest_node_contract_, to_char(lowest_node_finish_date_, 'YYYY-MM-DD'));
            END IF;
         END IF;
      $END
      cc_info_ := Language_SYS.Translate_Constant(lu_name_, 'MCCDELDATECHANGED: The planned delivery date will be changed from :P1 to :P2.', NULL,
                           to_char(old_delivery_date_, 'YYYY-MM-DD'), to_char(newrec_.planned_delivery_date, 'YYYY-MM-DD'));
      Client_SYS.Add_Info(lu_name_, cc_info_ ||' '|| lowest_node_info_);
      text_message_ := SUBSTR(Language_SYS.Translate_Constant(lu_name_, 'DATESCHANGEDBYMCC: Ran Capability Check. Planned Del Date changed from :P1 to :P2.',NULL,
                                       to_char(old_delivery_date_, 'YYYY-MM-DD'),
                                       to_char(newrec_.planned_delivery_date, 'YYYY-MM-DD')), 1, 200);
      Customer_Order_Line_Hist_API.New(order_no_, line_no_, rel_no_, line_item_no_, text_message_);      
   ELSIF (newrec_.latest_release_date IS NOT NULL) THEN
      Client_SYS.Add_Info(lu_name_, 'MCCDELDATENOCHANGE: The delivery date can be fulfilled as planned.');
      $IF (Component_Ordstr_SYS.INSTALLED) $THEN
         IF (App_Context_SYS.Find_Number_Value('CTP_RUN_ID') IS NOT NULL) THEN
            ctp_run_id_ := App_Context_SYS.Get_Number_Value('CTP_RUN_ID');
         END IF;
         IF (ctp_run_id_ > 0) THEN
            Interim_Ctp_Critical_Path_API.Update_Is_Deliverable(ctp_run_id_, Fnd_Boolean_API.DB_TRUE);
         END IF;
      $END
   END IF;

   Get_Id_Version_By_Keys___(objid_, rowversion_, order_no_, line_no_, rel_no_, line_item_no_);
   newrec_.rowversion := sysdate;
   IF (NOT (newrec_.planned_delivery_date = old_delivery_date_)) THEN
      Cust_Ord_Date_Calculation_API.Check_Date_On_Cust_Calendar_(newrec_.customer_no, newrec_.cust_calendar_id,
                                               newrec_.planned_delivery_date, 'PLANNED');
   END IF;

   IF (message_ = 'Shop Order Schedule Changed') THEN
      Client_SYS.Add_To_Attr('SERVER_DATA_CHANGE', 1, attr_);
      Update_License_Connect_Head__(newrec_, oldrec_, attr_);
   END IF;

   Update_Line___(objid_, newrec_);

   IF (NOT (newrec_.planned_delivery_date = old_delivery_date_)) THEN
      IF (header_rowstate_ != 'Planned') THEN
         Cust_Order_Event_Creation_API.Delivery_Date_Or_Qty_Changed(oldrec_.order_no, oldrec_.line_no, oldrec_.rel_no, oldrec_.line_item_no,
                                                                 oldrec_.planned_delivery_date, oldrec_.revised_qty_due,
                                                                 newrec_.planned_delivery_date, newrec_.revised_qty_due,
                                                                 newrec_.supply_code, newrec_.qty_on_order, newrec_.part_no);  
      END IF;
   END IF;

   -- package handling
   IF (line_item_no_ > 0) THEN
      Update_Package_Dates(order_no_, line_no_, rel_no_);
   END IF;

   IF (message_ IS NOT NULL) THEN
      text_message_ := SUBSTR(message_, 1, 200);
      Customer_Order_Line_Hist_API.New( order_no_, line_no_, rel_no_, line_item_no_, text_message_);
   END IF;
END Update_Planning_Date;


-- Update_Package_Dates
--   This method is used to update package order line dates when
--   changing component line dates upon replicating from a PO.
PROCEDURE Update_Package_Dates (
   order_no_            IN VARCHAR2,
   line_no_             IN VARCHAR2,
   rel_no_              IN VARCHAR2 )
IS
   max_planned_delivery_date_ DATE;
   newrec_                    CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   oldrec_                    CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_                     VARCHAR2(2000);
   rowversion_                VARCHAR2(2000);

   CURSOR get_max_del_date IS
      SELECT planned_delivery_date
      FROM  CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = order_no_
      AND   line_no = line_no_
      AND   rel_no = rel_no_
      AND   line_item_no > 0
      ORDER BY planned_delivery_date DESC;
BEGIN
   newrec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, -1);
   oldrec_ := newrec_;

   OPEN  get_max_del_date;
   FETCH get_max_del_date INTO max_planned_delivery_date_;
   CLOSE get_max_del_date;

   newrec_.planned_delivery_date := max_planned_delivery_date_;

   IF (max_planned_delivery_date_ < newrec_.target_date) THEN
      newrec_.target_date := max_planned_delivery_date_;
   END IF;

   Get_Id_Version_By_Keys___(objid_, rowversion_, order_no_, line_no_, rel_no_, -1);
   Calculate_Order_Line_Dates___(newrec_, oldrec_, objid_);
   Update_Line___(objid_, newrec_);
END Update_Package_Dates;


-- Set_Job_Id
--   Method used by Project module
PROCEDURE Set_Job_Id (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   job_id_       IN VARCHAR2 )
IS
   attr_          VARCHAR2(32000);
   activity_seq_  NUMBER := 0;
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Set_Item_Value('JOB_ID', job_id_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
   Set_Job_Pre_Posting___(order_no_, line_no_, rel_no_, line_item_no_, job_id_, activity_seq_);
END Set_Job_Id;


-- Check_Order_Line_For_Planning
--   Checks if order lines exist.
FUNCTION Check_Order_Line_For_Planning (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   temp_ CUSTOMER_ORDER_LINE_TAB.line_item_no%TYPE;
   CURSOR get_line_no IS
      SELECT line_item_no
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE part_no = part_no_
      AND  contract = contract_
      AND  rowstate IN ('Released', 'Reserved', 'Picked', 'PartiallyDelivered');
BEGIN
    OPEN get_line_no;
    FETCH get_line_no INTO temp_;
    IF (get_line_no%FOUND) THEN
       CLOSE get_line_no;
       RETURN TRUE;
    END IF;
    CLOSE get_line_no;
    RETURN FALSE;
END Check_Order_Line_For_Planning;


-- Is_Pre_Posting_Mandatory
--   This Function  returns 1 if mandarory pre posting is set for
--   order Line and there is no value for the mandatory code parts.
FUNCTION Is_Pre_Posting_Mandatory (
   company_  IN VARCHAR2,
   order_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   code_a_flag_        NUMBER;
   code_b_flag_        NUMBER;
   code_c_flag_        NUMBER;
   code_d_flag_        NUMBER;
   code_e_flag_        NUMBER;
   code_f_flag_        NUMBER;
   code_g_flag_        NUMBER;
   code_h_flag_        NUMBER;
   code_i_flag_        NUMBER;
   code_j_flag_        NUMBER;
   pre_accounting_id_  NUMBER;
   pre_accounting_rec_ PRE_ACCOUNTING_API.Public_Rec;
BEGIN
   pre_accounting_id_ := CUSTOMER_ORDER_API.Get_Pre_Accounting_Id(order_no_);
   Trace_SYS.Field('pre_accounting_id_', pre_accounting_id_);
   Trace_SYS.Field('order_no_', order_no_);

   pre_accounting_rec_ := PRE_ACCOUNTING_API.get(pre_accounting_id_);

   Accounting_Codestr_API.Execute_Accounting(code_a_flag_,
                                             code_b_flag_,
                                             code_c_flag_,
                                             code_d_flag_,
                                             code_e_flag_,
                                             code_f_flag_,
                                             code_g_flag_,
                                             code_h_flag_,
                                             code_i_flag_,
                                             code_j_flag_,
                                             NULL,
                                             company_,
                                             'M104',
                                             'C58');

   IF (code_a_flag_ = 1) AND (pre_accounting_rec_.account_no  IS NULL) OR
      (code_b_flag_ = 1) AND (pre_accounting_rec_.codeno_b    IS NULL) OR
      (code_c_flag_ = 1) AND (pre_accounting_rec_.codeno_c    IS NULL) OR
      (code_d_flag_ = 1) AND (pre_accounting_rec_.codeno_d    IS NULL) OR
      (code_e_flag_ = 1) AND (pre_accounting_rec_.codeno_e    IS NULL) OR
      (code_f_flag_ = 1) AND (pre_accounting_rec_.codeno_f    IS NULL) OR
      (code_g_flag_ = 1) AND (pre_accounting_rec_.codeno_g    IS NULL) OR
      (code_h_flag_ = 1) AND (pre_accounting_rec_.codeno_h    IS NULL) OR
      (code_i_flag_ = 1) AND (pre_accounting_rec_.codeno_i    IS NULL) OR
      (code_j_flag_ = 1) AND (pre_accounting_rec_.codeno_j    IS NULL) THEN
      RETURN 1;
   ELSE
      RETURN 0;
   END IF;
END Is_Pre_Posting_Mandatory;


-- New_Cust_Sched
--   Public interface for creating a new order line from customer schedule.
--   Includes check - new order lines not allowed when the order header is
--   in state 'Cancelled'.
PROCEDURE New_Cust_Sched (
   info_ OUT    VARCHAR2,
   attr_ IN OUT VARCHAR2 )
IS
   order_no_        CUSTOMER_ORDER_LINE_TAB.order_no%TYPE;
   header_rowstate_ CUSTOMER_ORDER_TAB.rowstate%TYPE;
BEGIN
   Client_SYS.Clear_Info;
   -- New order lines not allowed when the order is in state 'Cancelled'
   -- when creating new lines from Cust_Sched. Check New_Order_Lines_Allowed
   -- in method New does not cover this.

   order_no_        := Client_SYS.Get_Item_Value('ORDER_NO', attr_);
   header_rowstate_ := CUSTOMER_ORDER_API.Get_Objstate(order_no_);
   IF header_rowstate_ = 'Cancelled' THEN
      Error_SYS.Record_General(lu_name_, 'CANCELORD: Order lines cannot be added if the order is Cancelled.');
   END IF;
   New(info_, attr_);
END New_Cust_Sched;


-- Shop_Ord_Req_Exist
--   Check the Shop Order Requisition Exists
FUNCTION Shop_Ord_Req_Exist (
   contract_ IN VARCHAR2,
   order_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   CURSOR get_order_data IS
      SELECT part_no,supply_code,planned_due_date
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  ORDER_NO = order_no_
      AND    CONTRACT = contract_;

   ret_   VARCHAR2(20) := NULL;
BEGIN
   FOR order_lines_ IN get_order_data LOOP
      IF (order_lines_.supply_code = 'SO') THEN
         $IF (Component_Shpord_SYS.INSTALLED)$THEN
            ret_ := Shop_Order_Prop_API.Get_Shop_Ord_Req(contract_, order_lines_.part_no, order_lines_.planned_due_date);

            Trace_SYS.Field('............ret_', ret_);

            IF (ret_ IS NOT NULL) THEN
               RETURN ret_;
            END IF;
         $ELSE
            NULL;
         $END
      END IF;
   END LOOP;
   RETURN ret_;
END Shop_Ord_Req_Exist;

-- Get_Interim_Order_No
--   Returns the interim order no if an interim order is created.
@UncheckedAccess
FUNCTION Get_Interim_Order_No (
   order_no_       IN VARCHAR2,
   line_no_        IN VARCHAR2,
   rel_no_         IN VARCHAR2,
   line_item_no_   IN NUMBER,
   ctp_planned_db_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   dop_id_               VARCHAR2(12);
   interim_ord_id_       VARCHAR2(12);
   order_usage_          VARCHAR2(20);
   temp_order_no_        CUSTOMER_ORDER_LINE_TAB.order_no%TYPE;
   temp_line_no_         CUSTOMER_ORDER_LINE_TAB.line_no%TYPE;
   temp_rel_no_          CUSTOMER_ORDER_LINE_TAB.rel_no%TYPE;
   temp_line_item_no_    CUSTOMER_ORDER_LINE_TAB.line_item_no%TYPE;
BEGIN
   $IF (Component_Dop_SYS.INSTALLED) $THEN
      dop_id_ := Dop_Demand_Cust_Ord_API.Get_Dop_Id_For_Cust_Ord_Line(order_no_, line_no_, rel_no_, line_item_no_);
   $END
   IF (dop_id_ IS NOT NULL) THEN
      order_usage_ :='DOPHEAD';
      temp_order_no_:= to_char(dop_id_);
      temp_line_no_:= '*';
      temp_rel_no_:='*';
      temp_line_item_no_:= 0;
   ELSE
      order_usage_:='CUSTOMERORDER';
      temp_order_no_:=order_no_;
      temp_line_no_:=line_no_;
      temp_rel_no_:=rel_no_;
      temp_line_item_no_:=line_item_no_;
   END IF;

   $IF (Component_Ordstr_SYS.INSTALLED)$THEN
      IF (NVL(ctp_planned_db_, 'N') = 'N') THEN
         Interim_ord_id_ := Interim_Demand_Head_API.Get_Int_Head_By_Usage(order_usage_, temp_order_no_, temp_line_no_, temp_rel_no_, temp_line_item_no_);
      ELSIF (NVL(ctp_planned_db_, 'N') = 'Y')THEN
         Interim_ord_id_ := Interim_Ctp_Manager_API.Get_Top_Int_Head_By_Usage(order_usage_, temp_order_no_, temp_line_no_, temp_rel_no_, temp_line_item_no_);
      END IF;
   $END
   RETURN Interim_ord_id_;
END Get_Interim_Order_No;


-- Check_Line_Total_Discount_Pct
--   Checks the sum of order discount and additional discount of an order
--   line.If it exceeds 100% it raises an error message.
PROCEDURE Check_Line_Total_Discount_Pct (
   order_no_            IN VARCHAR2,
   additional_discount_ IN NUMBER )
IS
   CURSOR get_lines IS
      SELECT line_no, rel_no, line_item_no, order_discount
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_item_no <= 0
      AND    rowstate NOT IN ('Cancelled', 'Closed');

    total_order_discount_  NUMBER := 0;
BEGIN
    FOR next_line_ IN get_lines LOOP
      total_order_discount_ := next_line_.order_discount + additional_discount_;
      IF total_order_discount_ > 100 THEN
         Error_SYS.Record_General(lu_name_, 'LINEDISCOUNTEXCEED: Total Order Discount should not exceed 100% in line (Line No :P1, Del No :P2)', next_line_.line_no,next_line_.rel_no );
      END IF;
      total_order_discount_ := 0;
    END LOOP;
END Check_Line_Total_Discount_Pct;


-- Modify_Tax_Code
--   Modifies the tax code with the tax line tax code at the same time.
PROCEDURE Modify_Tax_Code (
   attr_         IN OUT VARCHAR2,
   order_no_     IN     VARCHAR2,
   line_no_      IN     VARCHAR2,
   rel_no_       IN     VARCHAR2,
   line_item_no_ IN     NUMBER )
IS
   objid_            VARCHAR2(2000);
   objversion_       VARCHAR2(2000);
   oldrec_           CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   newrec_           CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   tax_code_         CUSTOMER_ORDER_LINE_TAB.tax_code%TYPE;
BEGIN
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   oldrec_ := Lock_By_Id___(objid_, objversion_);
   newrec_ := oldrec_;
   tax_code_ := Client_Sys.Get_Item_Value('TAX_CODE', attr_);
   Client_SYS.Add_To_Attr('TAX_CODE_CHANGED', 'TRUE', attr_);
   newrec_.tax_code := tax_code_;
   Update___(objid_, oldrec_, newrec_, attr_, objversion_);
END Modify_Tax_Code;


-- Modify_Tax_Class_Id
--   Modifies the tax class id when the tax code is changed from the
--   customer order tax lines dialog
PROCEDURE Modify_Tax_Class_Id (
   attr_         IN OUT VARCHAR2,
   order_no_     IN     VARCHAR2,
   line_no_      IN     VARCHAR2,
   rel_no_       IN     VARCHAR2,
   line_item_no_ IN     NUMBER )
IS
   objid_            VARCHAR2(2000);
   objversion_       VARCHAR2(2000);
   oldrec_           CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   newrec_           CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
BEGIN
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   oldrec_ := Lock_By_Id___(objid_, objversion_);
   newrec_ := oldrec_;
   newrec_.tax_class_id := Client_Sys.Get_Item_Value('TAX_CLASS_ID', attr_);
   Update___(objid_, oldrec_, newrec_, attr_, objversion_);
END Modify_Tax_Class_Id;


-- Modify_Tax_Details_For_IPD
--   When a single occurence address is passed for IPD deliveries to the internal customer order line
--   this will refetch the tax code of the customer order line according to the delivery country by
PROCEDURE Modify_Tax_Details_For_IPD(
   order_no_     IN     VARCHAR2,
   line_no_      IN     VARCHAR2,
   rel_no_       IN     VARCHAR2,
   line_item_no_ IN     NUMBER )
IS
   attr_             VARCHAR2(2000);
   newrec_           CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   oldrec_           CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_            VARCHAR2(2000);
   objversion_       VARCHAR2(2000);
   order_rec_  Customer_Order_API.Public_Rec;
BEGIN
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   oldrec_ := Lock_By_Id___(objid_, objversion_);
   newrec_ := oldrec_;
   
   IF (newrec_.demand_code = 'IPD' AND Get_Ship_Addr_No( newrec_.order_No, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no) != newrec_.ship_addr_no) THEN
      Client_SYS.Add_Info(lu_name_, 'NOTAXUPDATE: The tax information will not be updated automatically. Consider reviewing the information.');
   END IF;
   order_rec_ := Customer_Order_API.Get(newrec_.order_no);
   Add_Transaction_Tax_Info___ ( newrec_,  
                                 Site_API.Get_Company(newrec_.contract),                                      
                                 order_rec_.customer_no,
                                 order_rec_.ship_addr_no,                                      
                                 order_rec_.supply_country,                                        
                                 order_rec_.use_price_incl_tax,
                                 order_rec_.currency_code,                                       
                                 TRUE,                                      
                                 attr_  => NULL);
   IF (NVL(oldrec_.tax_code, Database_SYS.string_null_) != NVL(newrec_.tax_code, Database_SYS.string_null_) OR NVL(oldrec_.tax_class_id, Database_SYS.string_null_) != NVL(newrec_.tax_class_id, Database_SYS.string_null_)) THEN
       client_SYS.Add_To_Attr('TAX_CODE', newrec_.tax_code, attr_);
       client_SYS.Add_To_Attr('TAX_CLASS_ID', newrec_.tax_class_id, attr_);
       Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
   END IF;
END Modify_Tax_Details_For_IPD;


-- Get_Owner_For_Part_Ownership
--   This method returns the correct owner for the given order line
--   and the part ownership of that line.
@UncheckedAccess
FUNCTION Get_Owner_For_Part_Ownership (
   order_no_       IN VARCHAR2,
   line_no_        IN VARCHAR2,
   rel_no_         IN VARCHAR2,
   line_item_no_   IN NUMBER,
   part_ownership_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   customer_no_    CUSTOMER_ORDER_LINE_TAB.customer_no%TYPE;
   vendor_no_      CUSTOMER_ORDER_LINE_TAB.vendor_no%TYPE;
BEGIN
   IF (part_ownership_ IN (Part_Ownership_API.DB_COMPANY_OWNED, Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)) THEN
      RETURN NULL;
   ELSIF (part_ownership_ = Part_Ownership_API.DB_CUSTOMER_OWNED) THEN
      RETURN Get_Owning_Customer_No(order_no_, line_no_, rel_no_, line_item_no_);
   ELSIF (part_ownership_ = Part_Ownership_API.DB_SUPPLIER_LOANED) THEN
      $IF (Component_Purch_SYS.INSTALLED)$THEN
         customer_no_ := CUSTOMER_ORDER_API.Get_Customer_No(order_no_);
         vendor_no_   := Supplier_API.Get_Cust_Vendor_No(customer_no_);
         RETURN vendor_no_;
      $ELSE
         RETURN NULL;
      $END
   ELSE
      RETURN NULL;
   END IF;
END Get_Owner_For_Part_Ownership;

-- Get_Next_Rel_No
--   Get next rel_no
FUNCTION Get_Next_Rel_No (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   line_item_no_ IN NUMBER,
   contract_     IN VARCHAR2 ) RETURN VARCHAR2
IS
   CURSOR get_rel_no IS
      SELECT to_char(max(to_number(rel_no)))
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    contract || '' = contract_
      AND    line_item_no <= 0;

   CURSOR count_rel_no IS
      SELECT count(DISTINCT(to_number(rel_no)))
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    contract || '' = contract_;

   rel_          VARCHAR2(4);
   rel_no_count_ NUMBER;
BEGIN
   IF (line_no_ IS NOT NULL) THEN
      OPEN get_rel_no;
      FETCH get_rel_no INTO rel_;
      CLOSE get_rel_no;
      IF (rel_ IS NOT NULL) THEN
         IF (to_number(rel_) + 1 > 9999) THEN
            OPEN count_rel_no;
            FETCH count_rel_no INTO rel_no_count_;
            CLOSE count_rel_no;

            IF (rel_no_count_ < 9999) THEN
               Error_Sys.Record_General(lu_name_,'RELNOMAX: The maximum limit of the delivery number has been reached. Enter a value less than 9999 in the Del No field manually.');
            ELSE
               Error_Sys.Record_General(lu_name_,'NOMORERELNO: The maximum limit of the delivery number has been reached.');
            END IF;
         END IF;
         rel_ := to_char(to_number(rel_) + 1);
         RETURN rel_;
      ELSE
         rel_ := '1';
         RETURN rel_;
      END IF;
   END IF;
   RETURN rel_;
END Get_Next_Rel_No;


-- Modify_Staged_Billing
--   Updates the staged billing flag
PROCEDURE Modify_Staged_Billing (
   order_no_       IN VARCHAR2,
   line_no_        IN VARCHAR2,
   rel_no_         IN VARCHAR2,
   line_item_no_   IN NUMBER,
   staged_billing_ IN VARCHAR2 )
IS
   attr_           VARCHAR2(2000);
   qty_to_invoice_ NUMBER;
   ordrec_         CUSTOMER_ORDER_API.Public_Rec;
   company_        VARCHAR2(20);

   co_line_rec_    Public_Rec;

   CURSOR get_qty_to_invoiced IS
      SELECT qty_shipped, qty_invoiced, deliv_no, line_item_no, date_delivered, cost
      FROM   customer_order_delivery_tab
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    cancelled_delivery = 'FALSE';
BEGIN

   co_line_rec_ := Get(order_no_, line_no_, rel_no_, line_item_no_);

   IF (staged_billing_ = 'STAGED BILLING') THEN
      IF (co_line_rec_.consignment_stock = 'CONSIGNMENT STOCK') THEN
         Error_SYS.Record_General(lu_name_, 'STAGE_BILL_CON_STOCK: Staged Billing cannot be used together with Customer Consignment Stock.');
      END IF;

      IF Get_Objstate(order_no_, line_no_, rel_no_, line_item_no_) IN ('PartiallyDelivered','Delivered') THEN
         Error_SYS.Record_General(lu_name_, 'ORD_DELIV: Cannot add new profile once the order line is Partially Delivered or Delivered.');
      END IF;
      IF (co_line_rec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
         Error_SYS.Record_General(lu_name_, 'NOSTBILLFORRENTAL: Staged billing is not allowed for rental customer order lines.');
      END IF;
   END IF;

   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('STAGED_BILLING_DB', staged_billing_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);

   IF (staged_billing_ = 'NOT STAGED BILLING') THEN
      ordrec_ := CUSTOMER_ORDER_API.Get(order_no_);
      company_ := Site_API.Get_Company(ordrec_.contract);

      -- fetch all deliveries for the order line (incl. package components)
      FOR delivrec_ IN get_qty_to_invoiced LOOP
         qty_to_invoice_ := delivrec_.qty_shipped / co_line_rec_.conv_factor * co_line_rec_.inverted_conv_factor;

         Customer_Order_Delivery_API.Modify_Qty_To_Invoice(delivrec_.deliv_no, qty_to_invoice_);

         -- IF COGS is NOT posted at delivery confirmation (or Delivery confirmation is not used at all),
         -- a record in Outstanding Sales has to be created - but only if quantity > 0.
         -- Package components should not create outstanding sales records.
         IF (delivrec_.line_item_no <= 0) AND (qty_to_invoice_ > 0) THEN
            IF (ordrec_.delay_cogs_to_deliv_conf = 'FALSE') THEN
               Client_SYS.Clear_Attr(attr_);
               Client_SYS.Add_To_Attr('DELIV_NO', delivrec_.deliv_no, attr_);
               Client_SYS.Add_To_Attr('CONTRACT', ordrec_.contract, attr_);
               Client_SYS.Add_To_Attr('COMPANY', company_, attr_);
               Client_SYS.Add_To_Attr('QTY_EXPECTED', qty_to_invoice_, attr_);
               Client_SYS.Add_To_Attr('QTY_SHIPPED', delivrec_.qty_shipped, attr_);
               Client_SYS.Add_To_Attr('COST', delivrec_.cost, attr_);
               -- use the date when the delivery record was created (otherwise default sysdate)
               Client_SYS.Add_To_Attr('DATE_COGS_POSTED', delivrec_.date_delivered, attr_);
               Outstanding_Sales_API.New(attr_);
            END IF;
         END IF;

      END LOOP;
   END IF;
END Modify_Staged_Billing;


-- Copy_Customer_Order_Line
--   Sets the order line details to the to the new_attr_values_ variable.
PROCEDURE Copy_Customer_Order_Line (
   new_attr_values_ IN OUT VARCHAR2,
   order_no_        IN     VARCHAR2,
   line_no_         IN     VARCHAR2,
   rel_no_          IN     VARCHAR2,
   line_item_no_    IN     NUMBER )
IS
   -- Public get not used since some of the private variables may be needed.
   CURSOR order_line IS
      SELECT *
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
        AND  line_no = line_no_
        AND  rel_no = rel_no_
        AND  line_item_no = line_item_no_;

   order_line_rec_  CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   order_objstate_  VARCHAR2(20);
BEGIN
   OPEN order_line;
   FETCH order_line INTO order_line_rec_;
   CLOSE order_line;
   
   Client_SYS.Add_To_Attr('ORIGINATING_REL_NO', order_line_rec_.rel_no, new_attr_values_);
   Client_SYS.Add_To_Attr('ORIGINATING_LINE_ITEM_NO', order_line_rec_.line_item_no, new_attr_values_);
   
   Client_SYS.Add_To_Attr('CATALOG_NO', order_line_rec_.catalog_no, new_attr_values_);
   Client_SYS.Add_To_Attr('CATALOG_DESC', order_line_rec_.catalog_desc, new_attr_values_);
   Client_SYS.Add_To_Attr('DISCOUNT', order_line_rec_.discount, new_attr_values_);
   Client_SYS.Add_To_Attr('NOTE_TEXT', order_line_rec_.note_text, new_attr_values_);
   Client_SYS.Add_To_Attr('ORDER_DISCOUNT', order_line_rec_.order_discount, new_attr_values_);
   Client_SYS.Add_To_Attr('SALE_UNIT_PRICE', order_line_rec_.sale_unit_price, new_attr_values_);
   Client_SYS.Add_To_Attr('UNIT_PRICE_INCL_TAX', order_line_rec_.unit_price_incl_tax, new_attr_values_);
   Client_SYS.Add_To_Attr('DELIVERY_TYPE', order_line_rec_.delivery_type, new_attr_values_);
   Client_SYS.Add_To_Attr('TAX_CODE', order_line_rec_.tax_code, new_attr_values_);
   Client_SYS.Add_To_Attr('TAX_CLASS_ID', order_line_rec_.tax_class_id, new_attr_values_);

   Client_SYS.Add_To_Attr('CONSIGNMENT_STOCK_DB', order_line_rec_.consignment_stock, new_attr_values_);
   Client_SYS.Add_To_Attr('CLOSE_TOLERANCE', order_line_rec_.close_tolerance, new_attr_values_);
   Client_SYS.Add_To_Attr('PRICE_LIST_NO', order_line_rec_.price_list_no, new_attr_values_);
   Client_SYS.Add_To_Attr('CHARGED_ITEM_DB', order_line_rec_.charged_item, new_attr_values_);
   Client_SYS.Add_To_Attr('DOP_CONNECTION_DB', order_line_rec_.dop_connection, new_attr_values_);
   Client_SYS.Add_To_Attr('CREATE_SM_OBJECT_OPTION_DB', order_line_rec_.create_sm_object_option, new_attr_values_);
   Client_SYS.Add_To_Attr('DEFAULT_ADDR_FLAG', Gen_Yes_No_API.Decode(order_line_rec_.default_addr_flag), new_attr_values_);
   Client_SYS.Add_To_Attr('DEFAULT_ADDR_FLAG_DB', order_line_rec_.default_addr_flag, new_attr_values_);
   Client_SYS.Add_To_Attr('ADDR_FLAG_DB', order_line_rec_.addr_flag, new_attr_values_);
   Client_SYS.Add_To_Attr('SHIP_ADDR_NO', order_line_rec_.ship_addr_no, new_attr_values_);
   Client_SYS.Add_To_Attr('CONTACT', order_line_rec_.contact, new_attr_values_);
   Client_SYS.Add_To_Attr('ROUTE_ID', order_line_rec_.route_id, new_attr_values_);
   Client_SYS.Add_To_Attr('FORWARD_AGENT_ID', order_line_rec_.forward_agent_id, new_attr_values_);

   Client_SYS.Add_To_Attr('DELIVERY_TERMS', order_line_rec_.delivery_terms, new_attr_values_);
   Client_SYS.Add_To_Attr('DEL_TERMS_LOCATION', order_line_rec_.del_terms_location, new_attr_values_);
   Client_SYS.Add_To_Attr('DISTRICT_CODE', order_line_rec_.district_code, new_attr_values_);
   Client_SYS.Add_To_Attr('REGION_CODE', order_line_rec_.region_code, new_attr_values_);
   Client_SYS.Add_To_Attr('STAGED_BILLING_DB', order_line_rec_.staged_billing, new_attr_values_);
   Client_SYS.Add_To_Attr('TAX_LIABILITY', order_line_rec_.tax_liability, new_attr_values_);
   Client_SYS.Add_To_Attr('ORIGINAL_PART_NO', order_line_rec_.original_part_no, new_attr_values_);
   Client_SYS.Add_To_Attr('EQUIPMENT_OBJECT_SEQ', order_line_rec_.equipment_object_seq, new_attr_values_);
   Client_SYS.Add_To_Attr('SUP_SM_CONTRACT', order_line_rec_.sup_sm_contract, new_attr_values_);
   Client_SYS.Add_To_Attr('SUP_SM_OBJECT', order_line_rec_.sup_sm_object, new_attr_values_);
   Client_SYS.Add_To_Attr('SM_CONNECTION_DB', order_line_rec_.sm_connection, new_attr_values_);
   Client_SYS.Add_To_Attr('PRICE_FREEZE_DB', order_line_rec_.price_freeze, new_attr_values_);
   Client_SYS.Add_To_Attr('DOCK_CODE', order_line_rec_.dock_code, new_attr_values_);
   Client_SYS.Add_To_Attr('SUB_DOCK_CODE', order_line_rec_.sub_dock_code, new_attr_values_);
   Client_SYS.Add_To_Attr('REF_ID', order_line_rec_.ref_id, new_attr_values_);
   Client_SYS.Add_To_Attr('LOCATION_NO', order_line_rec_.location_no, new_attr_values_);
   Client_SYS.Add_To_Attr('CONFIGURATION_ID', order_line_rec_.configuration_id, new_attr_values_);
   Client_SYS.Add_To_Attr('PRICE_EFFECTIVITY_DATE', order_line_rec_.price_effectivity_date, new_attr_values_);
   Client_SYS.Add_To_Attr('INTRASTAT_EXEMPT_DB', order_line_rec_.intrastat_exempt, new_attr_values_);
   Client_SYS.Add_To_Attr('ADDITIONAL_DISCOUNT', order_line_rec_.additional_discount, new_attr_values_);
   Client_SYS.Add_To_Attr('CONDITION_CODE', order_line_rec_.condition_code, new_attr_values_);
   Client_SYS.Add_To_Attr('PART_OWNERSHIP_DB', order_line_rec_.part_ownership, new_attr_values_);
   Client_SYS.Add_To_Attr('PART_OWNERSHIP', Part_Ownership_API.Decode(order_line_rec_.part_ownership), new_attr_values_);
   Client_SYS.Add_To_Attr('DELIVER_TO_CUSTOMER_NO', order_line_rec_.deliver_to_customer_no, new_attr_values_);
   Client_SYS.Add_To_Attr('TAX_ID_NO', order_line_rec_.tax_id_no, new_attr_values_);
   Client_SYS.Add_To_Attr('TAX_ID_VALIDATED_DATE', order_line_rec_.tax_id_validated_date, new_attr_values_);
   Client_SYS.Add_To_Attr('ABNORMAL_DEMAND_DB', order_line_rec_.abnormal_demand, new_attr_values_);
   Client_SYS.Add_To_Attr('REL_MTRL_PLANNING', order_line_rec_.rel_mtrl_planning, new_attr_values_);
   Client_SYS.Add_To_Attr('RENTAL_DB', order_line_rec_.rental, new_attr_values_);
   Client_SYS.Add_To_Attr('COUNTRY_CODE', order_line_rec_.country_code, new_attr_values_);
   Client_SYS.Add_To_Attr('TAX_LIABILITY_TYPE_DB', order_line_rec_.tax_liability_type, new_attr_values_);
   -- IF the customer order has been released the promised delivery date should also be copied
   order_objstate_ := CUSTOMER_ORDER_API.Get_Objstate(order_no_);
   IF (order_objstate_ != 'Planned') THEN
      Client_SYS.Add_To_Attr('PROMISED_DELIVERY_DATE', order_line_rec_.promised_delivery_date, new_attr_values_);
   END IF;
   -- Note: Add the rental information to the attr_
   IF (order_line_rec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
      Add_Rental_Info_To_Attr___ (new_attr_values_,
                                  order_no_,
                                  line_no_,
                                  rel_no_,
                                  line_item_no_);
   END IF;
   Client_SYS.Add_To_Attr('FREE_OF_CHARGE_DB', order_line_rec_.free_of_charge, new_attr_values_);
   Client_SYS.Add_To_Attr('FREE_OF_CHARGE_TAX_BASIS', order_line_rec_.free_of_charge_tax_basis, new_attr_values_);
END Copy_Customer_Order_Line;


-- Create_Sourced_Co_Lines
--   Creates new customer order lines or updates existing ones from any
--   sourcing alternatives connected to each customer order line.
PROCEDURE Create_Sourced_Co_Lines (
   created_flag_ OUT VARCHAR2,
   order_no_     IN  VARCHAR2,
   line_no_      IN  VARCHAR2,
   rel_no_       IN  VARCHAR2,
   line_item_no_ IN  NUMBER )
IS
   new_line_no_               VARCHAR2(4);
   new_rel_no_                VARCHAR2(4);
   new_line_item_no_          NUMBER;
   total_sourced_qty_         NUMBER := 0;   
   first_row_                 BOOLEAN := TRUE;
   attr_                      VARCHAR2(32000);
   old_attr_                  VARCHAR2(32000);
   attr2_                     VARCHAR2(32000);
   info_                      VARCHAR2(2000);
   milestone_flag_            VARCHAR2(6);
   language_code_             VARCHAR2(2);   
   sourced_reservation_exist_ NUMBER;
   orglinerec_                CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   co_line_address_           Cust_Order_Line_Address_API.Co_Line_Addr_Rec;
   objid_                     VARCHAR2(2000);
   objversion_                VARCHAR2(2000);
   sales_price_               NUMBER;
   discount_amount_           NUMBER;
   rounding_                  NUMBER;
   line_net_                  NUMBER;
   line_gross_                NUMBER;
   line_qty_                  NUMBER;
   contract_                  VARCHAR2(10);   
   msg_text_                  VARCHAR2(200);
   curr_rounding_             NUMBER;
   line_discount_             NUMBER;
   order_rec_                 CUSTOMER_ORDER_API.Public_Rec;
   sale_price_incl_tax_       NUMBER;
   ptr_                       NUMBER;
   name_                      VARCHAR2(30);
   value_                     VARCHAR2(4000);
   company_                   VARCHAR2(20);

  -- values for stage billing from newly created customer order lines
  CURSOR get_new_line_rec ( line_no_ IN VARCHAR2, rel_no_ IN VARCHAR2, line_item_no_ IN NUMBER ) IS
       SELECT buy_qty_due, discount, order_discount, price_conv_factor, base_sale_unit_price, base_unit_price_incl_tax, additional_discount,
              sale_unit_price,unit_price_incl_tax, currency_rate
       FROM CUSTOMER_ORDER_LINE_TAB
       WHERE order_no = order_no_
         AND line_no = line_no_
         AND rel_no = rel_no_
         AND line_item_no = line_item_no_;

  -- Connected discount lines for the old order line
  CURSOR old_discount_lines IS
     SELECT *
       FROM cust_order_line_discount_tab
      WHERE  order_no = order_no_
        AND  line_no = line_no_
        AND  rel_no  = rel_no_
        AND  line_item_no = line_item_no_;

  -- New Created lines discount no
  CURSOR new_discount_lines ( dis_line_no_ IN VARCHAR2, dis_rel_no_ IN VARCHAR2, dis_line_item_no_ IN NUMBER) IS
     SELECT discount_no
       FROM cust_order_line_discount_tab
      WHERE order_no = order_no_
        AND line_no = dis_line_no_
        AND rel_no = dis_rel_no_
        AND line_item_no = dis_line_item_no_;

  -- All the attributes with the source_id required for a corresponding CO line
  CURSOR sourced_cust_lines IS
     SELECT  *
       FROM  sourced_cust_order_line_tab
      WHERE  order_no     = order_no_
        AND  line_no      = line_no_
        AND  rel_no       = rel_no_
        AND  line_item_no = line_item_no_
   ORDER BY  source_id;

BEGIN
   order_rec_:= Customer_Order_API.Get(order_no_);
   language_code_ := order_rec_.language_code;

   total_sourced_qty_ := Sourced_Cust_Order_Line_API.Get_Total_Sourced_Qty(order_no_,line_no_,rel_no_,line_item_no_);

   -- get original line details.
   orglinerec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   milestone_flag_ := Customer_Order_Milestone_API.Milestone_Exist(order_no_, line_no_, rel_no_, line_item_no_ );
   company_    := Site_API.Get_Company(orglinerec_.contract);	

   IF (total_sourced_qty_ = orglinerec_.revised_qty_due) THEN
      Client_SYS.Clear_Attr(old_attr_);

      -- set order line values to attr.
      Copy_Customer_Order_Line(old_attr_, order_no_, line_no_, rel_no_, line_item_no_);

      -- For all sourced lines create new customer order lines,(do update for first sourced line)
      FOR sourced_lines_ IN sourced_cust_lines LOOP

         sourced_reservation_exist_ := Sourced_Co_Supply_Site_Res_API.Sourced_Reservation_Exist(order_no_, line_no_, rel_no_,
                                                                 line_item_no_, sourced_lines_.source_id);
                                                                 
         Build_Attr_Sourced_Co_Lines___(attr_, sourced_lines_, old_attr_, orglinerec_, first_row_, sourced_reservation_exist_, language_code_, 
                                        order_no_, line_no_, rel_no_, line_item_no_);  
         
         -- modify first row
         IF first_row_ THEN
            Modify(attr_, order_no_, line_no_, rel_no_, line_item_no_ );
            msg_text_ := SUBSTR(Language_SYS.Translate_Constant(lu_name_,'DESIREDQTYCHANGED: This order line was modified by automatic/manual sourcing. The desired quantity on the line was :P1.', NULL, orglinerec_.desired_qty), 1, 200);
            Customer_Order_Line_Hist_API.New(order_no_, line_no_, rel_no_, line_item_no_, msg_text_);
            first_row_ := FALSE;
         -- Create New Customer Order Lines for rest of sourcing lines.
         ELSE
	    -- Removed the dicsount before inserting the new CO line. Discount will get added to the new line by calling
            -- Cust_Order_Line_Discount_API.New() at the latter part of this method.
            attr_ := Client_SYS.Remove_Attr('DISCOUNT', attr_);
            New(info_, attr_);
            
            WHILE (Client_SYS.Get_Next_From_Attr(attr_, ptr_, name_, value_)) LOOP
               IF(name_ = 'LINE_NO') THEN
                  new_line_no_ := value_;
               ELSIF(name_ = 'REL_NO') THEN
                  new_rel_no_ := value_;
               ELSIF(name_ = 'LINE_ITEM_NO') THEN
                  new_line_item_no_ := value_;
               END IF;
            END LOOP;
            
            -- Update all related objects to the original customer order line.

            -- IF the original line had connected milestone details copy those to newly created lines.
            IF milestone_flag_ = 'TRUE' THEN
               -- First the new line parameters then the connected line parameters.
               Customer_Order_Milestone_API.Copy_Milestone_Lines( order_no_, new_line_no_, new_rel_no_, new_line_item_no_, order_no_, line_no_, rel_no_, line_item_no_);
            END IF;

            -- IF tax lines exist for the line Remove tax lines created
            IF Source_Tax_Item_API.Tax_Items_Exist(company_, Tax_Source_API.DB_CUSTOMER_ORDER_LINE, order_no_, new_line_no_, new_rel_no_, TO_CHAR(new_line_item_no_), '*') = 'TRUE' THEN
               Source_Tax_Item_Order_API.Remove_Tax_Items(company_, Tax_Source_API.DB_CUSTOMER_ORDER_LINE, order_no_, new_line_no_, new_rel_no_, TO_CHAR(new_line_item_no_), '*');
            END IF;
            -- Copy originating line tax details.
            Tax_Handling_Order_Util_API.Transfer_Tax_lines(company_, Tax_Source_API.DB_CUSTOMER_ORDER_LINE, order_no_, line_no_, rel_no_, TO_CHAR(line_item_no_), '*',
                                                            Tax_Source_API.DB_CUSTOMER_ORDER_LINE, order_no_, new_line_no_, new_rel_no_, new_line_item_no_, '*');
            
            -- Create New Discount lines if originating line was related to any discount information.
            FOR get_line_rec_ IN new_discount_lines( new_line_no_, new_rel_no_, new_line_item_no_ ) LOOP
               Cust_Order_Line_Discount_API.Remove_Discount_Row(order_no_, new_line_no_, new_rel_no_, new_line_item_no_, get_line_rec_.discount_no);
            END LOOP;
            FOR get_old_line_rec_ IN old_discount_lines LOOP
               Cust_Order_Line_Discount_API.New(order_no_, new_line_no_,
                                                new_rel_no_, new_line_item_no_,
                                                get_old_line_rec_.discount_type,
                                                get_old_line_rec_.discount,
                                                get_old_line_rec_.discount_source,
                                                get_old_line_rec_.create_partial_sum,
                                                get_old_line_rec_.discount_line_no,
                                                get_old_line_rec_.discount_source_id,
                                                get_old_line_rec_.discount_amount,
                                                get_old_line_rec_.part_level,
                                                get_old_line_rec_.part_level_id,
                                                get_old_line_rec_.customer_level,
                                                get_old_line_rec_.customer_level_id );
               Cust_Order_Line_Discount_API.Calc_Discount_Upd_Co_Line__(order_no_, new_line_no_, new_rel_no_, new_line_item_no_);
            END LOOP;

            -- IF the original line had connected staged billing details copy those to newly created lines.
            IF (orglinerec_.staged_billing = 'STAGED BILLING') THEN
               -- IF CO header contains stage billing the lines will inheret so remove those first.
               IF (order_rec_.staged_billing = Staged_Billing_Type_API.DB_STAGED_BILLING) THEN
                  Order_Line_Staged_Billing_API.Remove_Stage_Lines( order_no_, new_line_no_, new_rel_no_, new_line_item_no_);
               END IF;
               -- Copy for new lines originating lines stage billing informations.
               Copy_Staged_Billing___(order_no_, 
                                   new_line_no_, 
                                   new_rel_no_,
                                   new_line_item_no_,
                                   order_no_,
                                   line_no_,
                                   rel_no_,
                                   line_item_no_,
                                   TRUE,
                                   TRUE);

            END IF;

            -- Copy Commission Information if originating line had any related commission information.
            Order_Line_Commission_API.Copy_Commission_Lines(order_no_, new_line_no_, new_rel_no_, new_line_item_no_, line_no_, rel_no_, line_item_no_);

            -- Order Line Address Information on originating line
            IF (orglinerec_.default_addr_flag = 'N') AND (orglinerec_.addr_flag = 'Y') THEN
               -- remove any address occurence
               Cust_Order_Line_Address_API.Remove_Address__(order_no_, new_line_no_, new_rel_no_, new_line_item_no_);
               co_line_address_ := Cust_Order_Line_Address_API.Get_Co_Line_Addr(orglinerec_.order_no, orglinerec_.line_no, orglinerec_.rel_no, orglinerec_.line_item_no );
               attr2_ := NULL;
               Client_SYS.Add_To_Attr('ORDER_NO', order_no_, attr2_);
               Client_SYS.Add_To_Attr('LINE_NO', new_line_no_, attr2_);
               Client_SYS.Add_To_Attr('REL_NO', new_rel_no_, attr2_);
               Client_SYS.Add_To_Attr('LINE_ITEM_NO', new_line_item_no_, attr2_);
               Client_SYS.Add_To_Attr('ADDR_1',   co_line_address_.addr_1 , attr2_);
               Client_SYS.Add_To_Attr('ADDRESS1', co_line_address_.address1 , attr2_);
               Client_SYS.Add_To_Attr('ADDRESS2', co_line_address_.address2 , attr2_);
               Client_SYS.Add_To_Attr('ZIP_CODE', co_line_address_.zip_code , attr2_);
               Client_SYS.Add_To_Attr('CITY', co_line_address_.city , attr2_);
               Client_SYS.Add_To_Attr('IN_CITY', co_line_address_.in_city , attr2_);
               Client_SYS.Add_To_Attr('COUNTY', co_line_address_.county , attr2_);
               Client_SYS.Add_To_Attr('STATE', co_line_address_.state , attr2_);
               Client_SYS.Add_To_Attr('COUNTRY_CODE', co_line_address_.country_code , attr2_);
               -- create lines corresponding to the originating lines.
               Cust_Order_Line_Address_API.New__(info_, objid_, objversion_, attr2_, 'DO');
            END IF;

            -- IF Originating line contained a cust_warranty_id update the new line with this cust_warranty_id_.
            IF (orglinerec_.cust_warranty_id IS NOT NULL) THEN
               Client_SYS.Clear_Attr(attr2_);
               Client_SYS.Add_To_Attr('CUST_WARRANTY_ID', orglinerec_.cust_warranty_id, attr2_);
               Modify(attr2_, order_no_, new_line_no_, new_rel_no_, new_line_item_no_);
            END IF;
         END IF;

         -- transfer any sourced supply site reservation to CO supply site reservations
         IF (sourced_reservation_exist_ = 1) THEN
            Sourced_Co_Supply_Site_Res_API.Transfer_Sourced_Reservations(order_no_, line_no_, rel_no_,
                                                                line_item_no_, sourced_lines_.source_id,
                                                                new_line_no_, new_rel_no_, new_line_item_no_);
         END IF;
      END LOOP;

     created_flag_ := 'TRUE';
     -- Remove all source lines related to the customer order line that is sourced.
     Sourced_Cust_Order_Line_API.Remove(info_, order_no_, line_no_, rel_no_, line_item_no_);
  ELSE
     -- No Order Line Creation for not fully sourced Lines
     created_flag_ := 'FALSE';
  END IF;
END Create_Sourced_Co_Lines;


-- Get_Send_Change_Msg_For_Supp
--   Get the Send Change Message flag from supplier
@UncheckedAccess
FUNCTION Get_Send_Change_Msg_For_Supp (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN VARCHAR2
IS
   message_class_          VARCHAR2(30);
   send_change_msg_        VARCHAR2(2);
   edi_setup_              VARCHAR2(30);
   vendor_no_              CUSTOMER_ORDER_LINE_TAB.vendor_no%TYPE;
   supply_code_            VARCHAR2(10);
   purchase_type_          VARCHAR2(50);
   dummy_msg_              VARCHAR2(20);
   comp_line_exist_        BOOLEAN := FALSE;
   send_change_msg_supp_   VARCHAR2(5):='FALSE';

   CURSOR get_purchase_type IS
      SELECT purchase_type
      FROM   customer_order_pur_order_tab
      WHERE  oe_order_no = order_no_
      AND    oe_line_no = line_no_
      AND    oe_rel_no = rel_no_
      AND    oe_line_item_no  = line_item_no_;

   CURSOR component_line_vendor IS
      SELECT DISTINCT vendor_no
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    line_item_no > 0
      AND    supply_code IN ('IPT', 'PT', 'IPD', 'PD');
BEGIN
   message_class_ := 'ORDCHG';
   send_change_msg_ := 'N';
   supply_code_ := Order_Supply_Type_API.Encode(Get_Supply_Code(order_no_, line_no_, rel_no_, line_item_no_));

   OPEN get_purchase_type;
   FETCH get_purchase_type INTO purchase_type_;
   CLOSE get_purchase_type;

   IF supply_code_ IN ('IPD','IPT', 'PD', 'PT') THEN
      vendor_no_ := Get_Vendor_no(order_no_, line_no_, rel_no_, line_item_no_);
      $IF (Component_Purch_SYS.INSTALLED)$THEN
         send_change_msg_supp_ := Supplier_API.Get_Send_Change_Msg_For_Supp(vendor_no_);
      $END      
      IF ((send_change_msg_supp_ = 'TRUE') AND (purchase_type_ = 'O')) THEN
        RETURN 'TRUE';
      END IF;
   ELSIF supply_code_ = 'PKG' THEN
      FOR comp_line_ IN component_line_vendor LOOP
         edi_setup_ := Supplier_Info_Msg_Setup_API.Get_Default_Media_Code(comp_line_.vendor_no, message_class_);
         $IF (Component_Purch_SYS.INSTALLED)$THEN
            dummy_msg_ := Supplier_API.Get_Send_Change_Message(comp_line_.vendor_no);
         $END
         send_change_msg_ := Gen_Yes_No_API.Encode(dummy_msg_);
         IF (edi_setup_ IS NOT NULL) THEN
            IF (send_change_msg_ != 'Y') THEN
               RETURN 'FALSE';
            END IF;
            comp_line_exist_ := TRUE;
         END IF;
      END LOOP;
      IF comp_line_exist_ THEN
         RETURN 'TRUE';
      END IF;
   END IF;
   RETURN 'FALSE';
END Get_Send_Change_Msg_For_Supp;


-- Get_Purchase_Order_No
--   Returns the purchase order reference and will be useful for ESO's.
@UncheckedAccess
FUNCTION Get_Purchase_Order_No (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN VARCHAR2
IS
   po_order_no_          CUSTOMER_ORDER_LINE_TAB.demand_order_ref1%TYPE;

   CURSOR get_rec IS
      SELECT demand_order_ref1
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    line_item_no = line_item_no_;
BEGIN
   OPEN  get_rec;
   FETCH get_rec INTO po_order_no_;
   CLOSE get_rec;

   RETURN po_order_no_;
END Get_Purchase_Order_No;


-- Check_Pegged_Component_Exist
--   Used to check if the Package part components, are pegged to another
--   object (Purchase Order/Purchase Requsition).
@UncheckedAccess
FUNCTION Check_Pegged_Component_Exist (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN VARCHAR2
IS
   temp_  NUMBER;

   CURSOR component_lines IS
      SELECT 1
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    line_item_no > 0
      AND    qty_on_order > 0;
BEGIN
   OPEN component_lines;
   FETCH component_lines INTO temp_;
   CLOSE component_lines;
   IF (temp_ = 1) THEN
      RETURN 'TRUE';
   ELSE
      RETURN 'FALSE';
   END IF;
END Check_Pegged_Component_Exist;

@UncheckedAccess
FUNCTION Check_Auto_Pegged_Comp_Exist (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN VARCHAR2
IS
      temp_  NUMBER;
   
      CURSOR component_lines IS
         SELECT 1
         FROM   CUSTOMER_ORDER_LINE_TAB
         WHERE  order_no = order_no_
         AND    line_no = line_no_
         AND    rel_no = rel_no_
         AND    line_item_no > 0
         AND    qty_on_order > 0
         AND    supply_code IN ('IPD', 'PD', 'IPT', 'PT', 'SO', 'DOP');
   BEGIN
      OPEN component_lines;
      FETCH component_lines INTO temp_;
      CLOSE component_lines;
      IF (temp_ = 1) THEN
         RETURN 'TRUE';
      ELSE
         RETURN 'FALSE';
      END IF;
END Check_Auto_Pegged_Comp_Exist;

-- Check_Ipd_Pd_Comp_Exist
--   Used to check if the Package part components, are pegged to another
--   object (Purchase Order/Purchase Requsition) with supply code IPD or PD.
@UncheckedAccess
FUNCTION Check_Ipd_Pd_Comp_Exist (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN VARCHAR2
IS
   temp_  NUMBER;

   CURSOR component_lines IS
      SELECT 1
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    line_item_no > 0
      AND    qty_on_order > 0
      AND    supply_code IN ('IPD', 'PD');
BEGIN
   OPEN component_lines;
   FETCH component_lines INTO temp_;
   CLOSE component_lines;
   IF (temp_ = 1) THEN
      RETURN 'TRUE';
   ELSE
      RETURN 'FALSE';
   END IF;
END Check_Ipd_Pd_Comp_Exist;

-- Check_Custord_For_Purord
--   Check whether the internal customer order delivered(CO lines are writen in inventory transaction hist tab).
@UncheckedAccess
FUNCTION Check_Custord_For_Purord (
   po_order_no_     IN  VARCHAR2,
   po_line_no_      IN  VARCHAR2,
   po_rel_no_       IN  VARCHAR2 ) RETURN VARCHAR2
IS
   dummy_ NUMBER;
   return_ VARCHAR2(5);

   CURSOR get_oerel IS
      SELECT 1
      FROM   CUSTOMER_ORDER_LINE_TAB col, inventory_transaction_hist_pub ith
      WHERE  col.demand_order_ref1 = po_order_no_
      AND    col.demand_order_ref2 = po_line_no_
      AND    col.demand_order_ref3 = po_rel_no_
      AND    ith.source_ref1  = col.order_no
      AND    ith.source_ref2  = col.line_no
      AND    ith.source_ref3  = col.rel_no
      AND    ith.transaction_code IN ('SHIPDIR', 'INTPODIRIM', 'PODIRINTEM', 'OESHIP', 'INTPODIRSH', 'PODIRSH');
BEGIN
   return_ := 'TRUE';
   OPEN get_oerel;
   FETCH get_oerel INTO dummy_;
   IF (get_oerel%NOTFOUND) THEN
      return_ := 'FALSE';
   END IF;
   CLOSE get_oerel;
   RETURN return_;
END Check_Custord_For_Purord;


-- Get_Demand_Order_Info
--   Returns the demand order references connected to the CO line.
PROCEDURE Get_Demand_Order_Info (
   demand_order_ref1_ OUT VARCHAR2,
   demand_order_ref2_ OUT VARCHAR2,
   demand_order_ref3_ OUT VARCHAR2,
   demand_order_ref4_ OUT NUMBER,
   order_no_          IN  VARCHAR2,
   line_no_           IN  VARCHAR2,
   rel_no_            IN  VARCHAR2,
   line_item_no_      IN  NUMBER )
IS
   CURSOR get_rec IS
      SELECT demand_order_ref1, demand_order_ref2, demand_order_ref3, demand_order_ref4
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no     = order_no_
      AND    line_no      = line_no_
      AND    rel_no       = rel_no_
      AND    line_item_no = line_item_no_;
BEGIN
   OPEN  get_rec;
   FETCH get_rec INTO demand_order_ref1_, demand_order_ref2_, demand_order_ref3_, demand_order_ref4_;
   CLOSE get_rec;
END Get_Demand_Order_Info;


-- Modify_Shipment_Connection
--   Connect to or disconnect from a shipment.
PROCEDURE Modify_Shipment_Connection (
   order_no_          IN VARCHAR2,
   line_no_           IN VARCHAR2,
   rel_no_            IN VARCHAR2,
   line_item_no_      IN NUMBER,
   connect_           IN VARCHAR2,
   open_shipment_qty_ IN NUMBER )
IS
   attr_  VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('SHIPMENT_CONNECTED_DB', connect_, attr_);
   Client_SYS.Add_To_Attr('OPEN_SHIPMENT_QTY', open_shipment_qty_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Shipment_Connection;

-- Finite_State_Decode
--   Calls the private method Finite_State_Decode__.
@UncheckedAccess
FUNCTION Finite_State_Decode (
   db_state_ IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN Finite_State_Decode__(db_state_);
END Finite_State_Decode;

-- Modify_Delivery_Data
--   Update the customer order line with new date info.
PROCEDURE Modify_Delivery_Data (
   order_no_              IN VARCHAR2,
   line_no_               IN VARCHAR2,
   rel_no_                IN VARCHAR2,
   line_item_no_          IN NUMBER,
   ship_via_code_         IN VARCHAR2,
   route_id_              IN VARCHAR2,
   wanted_delivery_date_  IN DATE,
   planned_delivery_date_ IN DATE,
   planned_ship_date_     IN DATE,
   buy_qty_due_           IN NUMBER,
   forward_agent_id_      IN VARCHAR2,
   delivery_terms_        IN VARCHAR2,
   revised_qty_due_       IN NUMBER )
IS
   attr_                  VARCHAR2(2000);
   oldrec_                CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   changed_               BOOLEAN := FALSE;
   default_               BOOLEAN := TRUE;
   current_info_          VARCHAR2(32000);
BEGIN
   oldrec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   current_info_ := NULL;
   App_Context_SYS.Set_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_',current_info_);

   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('SERVER_DATA_CHANGE', 1, attr_);

   IF (oldrec_.ship_via_code != ship_via_code_) THEN
      Client_SYS.Add_To_Attr('SHIP_VIA_CODE', ship_via_code_, attr_);
      changed_ := TRUE;
      default_ := FALSE;
   END IF;
   IF (NVL(oldrec_.route_id, ' ') != NVL(route_id_, ' ')) THEN
      Client_SYS.Add_To_Attr('ROUTE_ID', route_id_, attr_);
      changed_ := TRUE;
      default_ := FALSE;
   END IF;
   IF (oldrec_.wanted_delivery_date != wanted_delivery_date_) THEN
     Client_SYS.Add_To_Attr('WANTED_DELIVERY_DATE', wanted_delivery_date_, attr_);
     changed_ := TRUE;
   END IF;
   IF (oldrec_.planned_delivery_date != planned_delivery_date_) THEN
     Client_SYS.Add_To_Attr('PLANNED_DELIVERY_DATE', planned_delivery_date_, attr_);
     changed_ := TRUE;
   END IF;
   IF (oldrec_.planned_ship_date != planned_ship_date_) THEN
      Client_SYS.Add_To_Attr('PLANNED_SHIP_DATE', planned_ship_date_, attr_);
      changed_ := TRUE;
   END IF;
   IF (oldrec_.buy_qty_due != buy_qty_due_) THEN
      Client_SYS.Add_To_Attr('BUY_QTY_DUE', buy_qty_due_, attr_);      
      changed_ := TRUE;
   END IF;
   IF (NVL(oldrec_.forward_agent_id, ' ') != NVL(forward_agent_id_, ' ')) THEN
     Client_SYS.Add_To_Attr('FORWARD_AGENT_ID', forward_agent_id_, attr_);
     changed_ := TRUE;
     default_ := FALSE;
   END IF;
   IF (NVL(oldrec_.delivery_terms, ' ') != NVL(delivery_terms_, ' ')) THEN
     Client_SYS.Add_To_Attr('DELIVERY_TERMS', delivery_terms_, attr_);
     changed_ := TRUE;
     default_ := FALSE;
   END IF;
   IF (oldrec_.revised_qty_due != revised_qty_due_) THEN
      Client_SYS.Add_To_Attr('REVISED_QTY_DUE', revised_qty_due_, attr_);
      changed_ := TRUE;
   END IF;

   -- IF any of the delivery data has been changed update the default address flag.
   IF NOT default_ THEN
      Client_SYS.Add_To_Attr('DEFAULT_ADDR_FLAG_DB', 'N', attr_);
   END IF;

   IF changed_ THEN
      Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
   END IF;

   current_info_ := App_Context_SYS.Find_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_');

   IF (current_info_ IS NOT NULL) THEN
      current_info_ := SUBSTR(current_info_, 6, LENGTH(current_info_));
      current_info_ := RTRIM(current_info_, CHR(30));
      App_Context_SYS.Set_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_',current_info_);
      Client_SYS.Add_Info(lu_name_, SUBSTR(current_info_,1,1024));
      current_info_ := NULL;
   END IF;
END Modify_Delivery_Data;


-- Calculate_Cost_And_Progress
--   Calculate and returns the cost and progress of the customer order line to project.
PROCEDURE Calculate_Cost_And_Progress (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER )
IS
   activity_info_tab_            Public_Declarations_API.PROJ_Project_Conn_Cost_Tab;
   activity_revenue_info_tab_    Public_Declarations_API.PROJ_Project_Conn_Revenue_Tab;
   attributes_                   Public_Declarations_API.PROJ_Project_Conn_Attr_Type;
BEGIN
   $IF (Component_Proj_SYS.INSTALLED) $THEN
      Refresh_Project_Connection (activity_info_tab_         => activity_info_tab_,
                                  activity_revenue_info_tab_ => activity_revenue_info_tab_,
                                  attributes_                => attributes_,
                                  activity_seq_              => NULL,
                                  keyref1_                   => order_no_,
                                  keyref2_                   => line_no_,
                                  keyref3_                   => rel_no_,
                                  keyref4_                   => line_item_no_,
                                  keyref5_                   => '*',
                                  keyref6_                   => '*',
                                  refresh_old_data_          => 'FALSE',
                                  proj_lu_name_              => 'COLINE');
   $ELSE
       NULL;
   $END
END Calculate_Cost_And_Progress;

-- Is_Uom_Group_Connected
--   This method returns TRUE if given inventory part  is connected to
--   Input Unit Group and that group is allowed to use in Customer Order module.
@UncheckedAccess
FUNCTION Is_Uom_Group_Connected (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   uom_group_id_ VARCHAR2(30);
   connected_    VARCHAR2(10);
BEGIN
   uom_group_id_ := Inventory_Part_API.Get_Input_Unit_Meas_Group_Id(contract_, part_no_);
   IF uom_group_id_ IS NOT NULL THEN
      connected_ := Input_Unit_meas_Group_API.Is_Usage_Allowed (uom_group_id_,'ORDER');
      RETURN connected_ ;
   ELSE
      RETURN 'FALSE' ;
   END IF;
END Is_Uom_Group_Connected;


-- Modify_Activity_Seq
--   This method is used to modify the activity sequence
PROCEDURE Modify_Activity_Seq (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   activity_seq_ IN NUMBER )
IS
   attr_  VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('ACTIVITY_SEQ', activity_seq_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Activity_Seq;


-- Modify_Price_Conv_Factor
--   Modifies Price Conv Factor on a Customer Order Line.
PROCEDURE Modify_Price_Conv_Factor (
   order_no_          IN VARCHAR2,
   line_no_           IN VARCHAR2,
   rel_no_            IN VARCHAR2,
   line_item_no_      IN NUMBER,
   price_conv_factor_ IN NUMBER )
IS
   attr_   VARCHAR2(2000) := NULL;
BEGIN
   Client_SYS.Add_To_Attr('PRICE_CONV_FACTOR', price_conv_factor_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Price_Conv_Factor;


-- Set_Cancel_Reason
--   Updates the value of cancel_reason for the order line with the passed in value.
PROCEDURE Set_Cancel_Reason (
   order_no_      IN VARCHAR2,
   line_no_       IN VARCHAR2,
   rel_no_        IN VARCHAR2,
   line_item_no_  IN NUMBER,
   cancel_reason_ IN VARCHAR2 )
IS
   attr_          VARCHAR2(32000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Set_Item_Value('CANCEL_REASON', cancel_reason_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Set_Cancel_Reason;


-- Check_Part_Used
--   Returns whether or not active order lines are using the passed part.
--   Used from Inventory Part validation of cost level.
--   Used for update validation of the Inventory Part.
@UncheckedAccess
FUNCTION Check_Part_Used (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   CURSOR check_exist IS
      SELECT 1
      FROM CUSTOMER_ORDER_TAB
      WHERE order_no IN (SELECT order_no
                         FROM CUSTOMER_ORDER_LINE_TAB
                         WHERE contract = contract_
                           AND part_no = part_no_
                           AND part_no IS NOT NULL
                           AND rowstate NOT IN ('Cancelled', 'Invoiced')
                           AND delivery_confirmed = 'FALSE')
        AND contract = contract_
        AND confirm_deliveries = 'TRUE'
        AND rowstate NOT IN ('Cancelled', 'Invoiced');
   exist_  NUMBER;
BEGIN
   OPEN check_exist;
   FETCH check_exist INTO exist_;
   IF (check_exist%NOTFOUND) THEN
      exist_ := 0;
   END IF;
   CLOSE check_exist;
   RETURN exist_;
END Check_Part_Used;


-- Calc_Sales_Qty_To_Deliver
--   Returns the quantity yet to be delivered in this line, in sales UOM
@UncheckedAccess
FUNCTION Calc_Sales_Qty_To_Deliver (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   qty_to_deliver_   NUMBER;

   CURSOR get_qty_to_deliver IS
      SELECT DECODE(part_no, NULL, qty_to_ship, qty_picked) / conv_factor * inverted_conv_factor
        FROM CUSTOMER_ORDER_LINE_TAB
       WHERE order_no     = order_no_
         AND line_no      = line_no_
         AND rel_no       = rel_no_
         AND line_item_no = line_item_no_;
BEGIN
   OPEN  get_qty_to_deliver;
   FETCH get_qty_to_deliver INTO qty_to_deliver_;
   CLOSE get_qty_to_deliver;
   RETURN qty_to_deliver_;
END Calc_Sales_Qty_To_Deliver;


-- Unpeg_Line
--   Modifies pegged attributes in the line.
PROCEDURE Unpeg_Line (
   order_no_       IN VARCHAR2,
   line_no_        IN VARCHAR2,
   rel_no_         IN VARCHAR2,
   line_item_no_   IN NUMBER,
   unpeg_ipd_flag_ IN VARCHAR2)
IS
   attr_              VARCHAR2(32000);
   pegged_order_no_   VARCHAR2(12);
   pegged_line_no_    VARCHAR2(4);
   pegged_rel_no_     VARCHAR2(4);
   purchase_type_     VARCHAR2(50);
   so_order_no_       VARCHAR2(12);
   so_release_no_     VARCHAR2(4);
   so_sequence_no_    VARCHAR2(4);
   co_line_rec_       Customer_Order_Line_API.Public_Rec;
   msg_text_          VARCHAR2(200);
BEGIN
   co_line_rec_ := Get(order_no_, line_no_, rel_no_, line_item_no_);
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Set_Item_Value('QTY_ON_ORDER', 0, attr_);
      
   IF (Inventory_Part_API.Check_Exist(co_line_rec_.contract, co_line_rec_.part_no)) THEN
      IF ((co_line_rec_.supply_code IN ('PT', 'SO', 'PD', 'IPT', 'IPD')) AND (co_line_rec_.activity_seq IS NOT NULL)) THEN
         Client_SYS.Set_Item_Value('SUPPLY_CODE', Order_Supply_Type_API.Decode('PI'), attr_);
      ELSE
         Client_SYS.Set_Item_Value('SUPPLY_CODE', Order_Supply_Type_API.Decode('IO'), attr_);
      END IF;
   ELSE
      IF ((co_line_rec_.supply_code IN ('PD', 'PT', 'IPT', 'IPD')) AND (co_line_rec_.activity_seq IS NOT NULL)) THEN
         Client_SYS.Set_Item_Value('SUPPLY_CODE', Order_Supply_Type_API.Decode('PRJ'), attr_);
      ELSE
         Client_SYS.Set_Item_Value('SUPPLY_CODE', Order_Supply_Type_API.Decode('NO'), attr_);
      END IF;
   END IF;
   Client_SYS.Set_Item_Value('VENDOR_NO', '', attr_);
   Client_SYS.Set_Item_Value('SERVER_DATA_CHANGE', 1, attr_);
   Client_SYS.Set_Item_Value('UNPEG_IPD_FLAG', unpeg_ipd_flag_, attr_);

   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);

   Customer_Order_Pur_Order_API.Get_Purord_For_Custord(pegged_order_no_, pegged_line_no_, pegged_rel_no_, purchase_type_,
                                                       order_no_, line_no_, rel_no_, line_item_no_);
   IF (pegged_order_no_ IS NOT NULL) THEN
      Customer_Order_Pur_Order_API.Remove(order_no_, line_no_, rel_no_, line_item_no_);
      msg_text_ := Language_SYS.Translate_Constant(lu_name_, 'UNPEGPURREQORD: Unpegged from purchase requisition/order line :P1-:P2-:P3',NULL, pegged_order_no_, pegged_line_no_, pegged_rel_no_);
      Customer_Order_Line_Hist_API.New( order_no_, line_no_, rel_no_, line_item_no_, msg_text_);
   ELSE
      IF (unpeg_ipd_flag_ = 'FALSE') THEN
         Customer_Order_Shop_Order_API.Get_Shop_Order(so_order_no_     => so_order_no_,
                                                      so_release_no_   => so_release_no_,
                                                      so_sequence_no_  => so_sequence_no_,
                                                      oe_order_no_     => order_no_,
                                                      oe_line_no_      => line_no_,
                                                      oe_rel_no_       => rel_no_,
                                                      oe_line_item_no_ => line_item_no_);
         msg_text_ := Language_SYS.Translate_Constant(lu_name_, 'UNPEGSHOPORD: Unpegged from shop order :P1-:P2-:P3',NULL, so_order_no_, so_release_no_, so_sequence_no_);
         Customer_Order_Line_Hist_API.New( order_no_, line_no_, rel_no_, line_item_no_, msg_text_);
      END IF;
   END IF;   
   Customer_Order_Shop_Order_API.Remove_Cancelled_Order(order_no_, line_no_, rel_no_, line_item_no_);
END Unpeg_Line;


-- Modify_Sale_Unit_Price
--   This method will update the sale unit prices.
PROCEDURE Modify_Sale_Unit_Price (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   new_price_    IN NUMBER )
IS
   CURSOR get_order_line IS
   SELECT colt.contract, cot.currency_code, colt.provisional_price, cot.customer_no, cot.customer_no_pay, cot.currency_rate_type
        FROM customer_order_line_tab colt, customer_order_tab cot
       WHERE colt.order_no      = cot.order_no
         AND colt.order_no      = order_no_
         AND colt.line_no       = line_no_
         AND colt.rel_no        = rel_no_
         AND colt.line_item_no  = line_item_no_
         AND colt.price_freeze  = 'FREE' ;

    contract_                 VARCHAR2(5);
    currency_code_            VARCHAR2(3);
    currency_rate_            NUMBER;
    sale_unit_price_          NUMBER;
    unit_price_incl_tax_      NUMBER;
    base_sale_unit_price_     NUMBER;
    base_unit_price_incl_tax_ NUMBER;
    attr_                     VARCHAR2(2000);
    provisional_price_        VARCHAR2(5);
    customer_no_              CUSTOMER_ORDER_LINE_TAB.customer_no%TYPE;
    customer_no_pay_          CUSTOMER_ORDER_LINE_TAB.customer_no%TYPE;
    currency_rate_type_       VARCHAR2(10);
BEGIN

   OPEN  get_order_line;
   FETCH get_order_line INTO contract_, currency_code_, provisional_price_, customer_no_, customer_no_pay_, currency_rate_type_;
   IF (get_order_line%FOUND) THEN
      CLOSE get_order_line;
      IF Customer_Order_API.Get_Use_Price_Incl_Tax_Db(order_no_) = 'TRUE' THEN
         unit_price_incl_tax_ := new_price_;
         Customer_Order_Pricing_API.Get_Base_Price_In_Currency(base_unit_price_incl_tax_,
                                                               currency_rate_,
                                                               NVL(customer_no_pay_,customer_no_),
                                                               contract_,
                                                               currency_code_,
                                                               unit_price_incl_tax_,
                                                               currency_rate_type_);
      ELSE
         sale_unit_price_ := new_price_;
         Customer_Order_Pricing_API.Get_Base_Price_In_Currency(base_sale_unit_price_,
                                                               currency_rate_,
                                                               NVL(customer_no_pay_,customer_no_),
                                                               contract_,
                                                               currency_code_,
                                                               sale_unit_price_,
                                                               currency_rate_type_);
      END IF;
      Calculate_Prices(sale_unit_price_, unit_price_incl_tax_, base_sale_unit_price_, base_unit_price_incl_tax_,
                       order_no_, line_no_, rel_no_, line_item_no_);
      Client_SYS.Add_to_Attr('SALE_UNIT_PRICE',          sale_unit_price_,          attr_);
      Client_SYS.Add_to_Attr('UNIT_PRICE_INCL_TAX',      unit_price_incl_tax_,      attr_);
      Client_SYS.Add_to_Attr('BASE_SALE_UNIT_PRICE',     base_sale_unit_price_,     attr_);
      Client_SYS.Add_to_Attr('BASE_UNIT_PRICE_INCL_TAX', base_unit_price_incl_tax_, attr_);
      IF (provisional_price_ = 'TRUE') THEN
         Client_SYS.Add_to_Attr('PROVISIONAL_PRICE_DB', 'FALSE',               attr_);
      END IF;
      $IF (Component_Deford_SYS.INSTALLED) $THEN
        IF sale_unit_price_ = 0 AND (Def_Contract_Order_Item_API.CO_Line_On_Defense_Contract(order_no_, line_no_,rel_no_,line_item_no_)) THEN 
         Client_SYS.Add_To_Attr('SERVER_DATA_CHANGE',1, attr_);
        END IF;
      $END
      Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_ );
   ELSE
      CLOSE get_order_line;
   END IF;
END Modify_Sale_Unit_Price;


-- Modify_Blocked_For_Invoicing
--   This method updates the column blocked for invoicing.
PROCEDURE Modify_Blocked_For_Invoicing (
   order_no_                 IN VARCHAR2,
   line_no_                  IN VARCHAR2,
   rel_no_                   IN VARCHAR2,
   line_item_no_             IN NUMBER,
   blocked_for_invoicing_db_ IN VARCHAR2 )
IS
 attr_  VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_to_Attr('BLOCKED_FOR_INVOICING_DB', blocked_for_invoicing_db_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Blocked_For_Invoicing;


-- Modify_Provisional_Price
--   Updates the provisional price flag
PROCEDURE Modify_Provisional_Price (
   order_no_             IN VARCHAR2,
   line_no_              IN VARCHAR2,
   rel_no_               IN VARCHAR2,
   line_item_no_         IN NUMBER,
   provisional_price_db_ IN VARCHAR2 )
IS
   attr_    VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_to_Attr('PROVISIONAL_PRICE_DB', provisional_price_db_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Provisional_Price;

-- Added parameter curr_rounding_ not to refetch in order to improve performance
-- Get_Total_Tax_Amount_Curr
--   Returns the total tax amount (VAT or Sales Tax) for an order line
--   in order currency.
@UncheckedAccess
FUNCTION Get_Total_Tax_Amount_Curr (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   curr_rounding_ IN NUMBER DEFAULT NULL ) RETURN NUMBER
IS
   order_rec_         CUSTOMER_ORDER_API.Public_Rec;
   line_rec_          CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   tax_amount_        NUMBER := 0;
   rounding_          NUMBER;
   company_           VARCHAR2(20);
   tax_paying_party_  VARCHAR2(20);
BEGIN
   line_rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   company_  := Site_API.Get_Company(line_rec_.contract);
   order_rec_ := Customer_Order_API.Get(order_no_);
   IF curr_rounding_ IS NULL THEN
      rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, order_rec_.currency_Code);
   ELSE
      rounding_ := curr_rounding_;
   END IF;
   tax_paying_party_ := order_rec_.free_of_chg_tax_pay_party;
   
   IF (line_rec_.tax_liability_type = 'EXM') OR (line_rec_.free_of_charge = Fnd_Boolean_API.DB_TRUE AND tax_paying_party_ = Tax_Paying_Party_API.DB_COMPANY) THEN
      -- No tax paid for this order line
      tax_amount_ := 0;
   ELSE
      tax_amount_ := Source_Tax_Item_API.Get_Total_Tax_Curr_Amount(company_, 
                                                                   Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                                                   order_no_,
                                                                   line_no_,
                                                                   rel_no_,
                                                                   TO_CHAR(line_item_no_),
                                                                   '*');
   END IF;
   
   tax_amount_ := ROUND(tax_amount_, rounding_);
   RETURN NVL(tax_amount_, 0);
END Get_Total_Tax_Amount_Curr;

-- Added parameter base_rounding_ not to refetch in order to improve performance
-- Get_Total_Tax_Amount_Base
--    Returns the total tax amount (VAT or Sales Tax) for an order line
--    in base currency.
@UncheckedAccess
FUNCTION Get_Total_Tax_Amount_Base (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   base_rounding_ IN NUMBER DEFAULT NULL) RETURN NUMBER
IS
   line_rec_          CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   tax_amount_        NUMBER := 0;
   rounding_          NUMBER;
   company_           VARCHAR2(20);
   tax_paying_party_  VARCHAR2(20);
   CURSOR get_lines(free_of_charge_ VARCHAR2, company_pay_tax_ VARCHAR2) IS
      SELECT line_no, rel_no, line_item_no, contract
      FROM  CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = order_no_
      AND   line_item_no <= 0
      AND   rowstate != 'Cancelled'
      AND   tax_liability_type != 'EXM'
      AND  (free_of_charge != free_of_charge_ OR tax_paying_party_ != company_pay_tax_);

   PROCEDURE Fetch_Company_And_Rounding___(contract_ VARCHAR2) IS
   BEGIN
      IF company_ IS NULL THEN
         company_ := Site_API.Get_Company(contract_);
      END IF;
      IF base_rounding_ IS NULL THEN
         rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, Company_Finance_API.Get_Currency_Code(company_));
      ELSE
         rounding_ := base_rounding_;
      END IF;
   END Fetch_Company_And_Rounding___;
   
BEGIN
   tax_paying_party_ := Customer_Order_API.Get_Free_Of_Chg_Tax_Pay_Par_Db(order_no_);   
   IF (line_no_ IS NULL) THEN
      tax_amount_ := 0;
      FOR rec_ IN get_lines(Fnd_Boolean_API.DB_TRUE, Tax_Paying_Party_API.DB_COMPANY) LOOP
         -- Assign correct value for company_ and rounding_
         Fetch_Company_And_Rounding___(rec_.contract);

         tax_amount_ := tax_amount_ +
                        Source_Tax_Item_API.Get_Total_Tax_Dom_Amount(company_, 
                                                                     Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                                                     order_no_,
                                                                     rec_.line_no,
                                                                     rec_.rel_no,
                                                                     TO_CHAR(rec_.line_item_no),
                                                                     '*');
      END LOOP;
   ELSE
      line_rec_         := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
      company_          := Site_API.Get_Company(line_rec_.contract);
      -- Assign correct value for rounding_
      Fetch_Company_And_Rounding___(line_rec_.contract);      
      
      IF (line_rec_.tax_liability_type = 'EXM') OR (line_rec_.free_of_charge = Fnd_Boolean_API.DB_TRUE AND tax_paying_party_ = Tax_Paying_Party_API.DB_COMPANY) THEN
         -- No tax paid for this order line
         tax_amount_ := 0;
      ELSE
         tax_amount_ := Source_Tax_Item_API.Get_Total_Tax_Dom_Amount(company_, 
                                                                     Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                                                     order_no_,
                                                                     line_no_,
                                                                     rel_no_,
                                                                     TO_CHAR(line_item_no_),
                                                                     '*');
      END IF;
   END IF;
   
   tax_amount_ := ROUND(tax_amount_, rounding_);
   RETURN NVL(tax_amount_, 0);
END Get_Total_Tax_Amount_Base;


-- Modify_Condition_Code
--   Modify Condition Code
PROCEDURE Modify_Condition_Code (
   order_no_       IN VARCHAR2,
   line_no_        IN VARCHAR2,
   rel_no_         IN VARCHAR2,
   line_item_no_   IN NUMBER,
   condition_code_ IN VARCHAR2 )
IS
   ord_attr_       VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(ord_attr_);
   Client_SYS.Add_To_Attr( 'CONDITION_CODE', condition_code_, ord_attr_);
   Client_SYS.Add_To_Attr( 'SERVER_DATA_CHANGE', 1, ord_attr_);
   Modify_Line___(ord_attr_,order_no_,line_no_,rel_no_,line_item_no_);
END Modify_Condition_Code;


-- New_Comp_Lines_Allowed
--   Checks if new component lines are allowed for a specific package header.
@UncheckedAccess
FUNCTION New_Comp_Lines_Allowed (
   order_no_ IN VARCHAR2,
   line_no_  IN VARCHAR2,
   rel_no_   IN VARCHAR2 ) RETURN NUMBER
IS
   pkg_header_status_ CUSTOMER_ORDER_LINE_TAB.rowstate%TYPE;
BEGIN
   pkg_header_status_  := Get_Objstate(order_no_, line_no_, rel_no_, -1);
   IF pkg_header_status_ IN ('Cancelled', 'Delivered', 'Invoiced') THEN
      RETURN 0;
   ELSE
      RETURN 1;
   END IF;
END New_Comp_Lines_Allowed;


-- Get_Full_Qty_Assigned
--   Returns qty reserved for a particular customer order line for
--   normal parts and for package part.
@UncheckedAccess
FUNCTION Get_Full_Qty_Assigned (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   qty_assigned_ NUMBER := 0;
BEGIN
   IF (line_item_no_ >= 0) THEN
      qty_assigned_ := Customer_Order_Line_API.Get_Qty_Assigned(order_no_, line_no_,
                                                                rel_no_, line_item_no_);
   ELSE
      qty_assigned_ := Reserve_Customer_Order_API.Get_No_Of_Packages_Reserved(order_no_,
                                                                              line_no_,
                                                                              rel_no_);
   END IF;
   RETURN qty_assigned_;
END Get_Full_Qty_Assigned;


-- Get_Qty_Shipped_And_State
--   Selects the line status and delivered quantity of the customer order line
--   connected to the passed purchase order line.
@UncheckedAccess
PROCEDURE Get_Qty_Shipped_And_State (
   line_status_        OUT VARCHAR2,
   qty_shipped_        OUT NUMBER,
   demand_order_ref1_  IN  VARCHAR2,
   demand_order_ref2_  IN  VARCHAR2,
   demand_order_ref3_  IN  VARCHAR2 )
IS
   CURSOR get_line_info IS
      SELECT rowstate, qty_shipped
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE demand_order_ref1 = demand_order_ref1_
      AND   demand_order_ref2 = demand_order_ref2_
      AND   demand_order_ref3 = demand_order_ref3_
      AND   demand_code IN ('PO', 'IPT', 'IPD', 'IPT_RO')
      AND   rowstate IN ('PartiallyDelivered', 'Delivered', 'Invoiced')
      ORDER BY NVL(demand_order_ref4, -1);
BEGIN
   OPEN get_line_info;
   FETCH get_line_info INTO line_status_, qty_shipped_;
   CLOSE get_line_info;
END Get_Qty_Shipped_And_State;


-- Customer_Is_Internal
--   Returns TRUE when customer category is internal
@UncheckedAccess
FUNCTION Customer_Is_Internal (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN VARCHAR2
IS
   customer_no_ CUSTOMER_ORDER_LINE_TAB.customer_no%TYPE;
   cust_rec_    Cust_Ord_Customer_API.Public_Rec;
BEGIN
   customer_no_ := Get_Customer_No (order_no_, line_no_, rel_no_, line_item_no_);
   cust_rec_ := Cust_Ord_Customer_API.Get(customer_no_);

   IF (cust_rec_.category = 'I') THEN
      RETURN ('TRUE');
   ELSE
      RETURN ('FALSE');
   END IF;
END Customer_Is_Internal;


-- Handle_Pre_Posting_Change
--   This method will update Customer Order Line History when user adds or
--   changes customer order line pre postings.
PROCEDURE Handle_Pre_Posting_Change (
   pre_accounting_id_ IN NUMBER )
IS
   order_no_      CUSTOMER_ORDER_LINE_TAB.order_no%TYPE;
   line_no_       CUSTOMER_ORDER_LINE_TAB.line_no%TYPE;
   release_no_    CUSTOMER_ORDER_LINE_TAB.rel_no%TYPE;
   line_item_no_  CUSTOMER_ORDER_LINE_TAB.line_item_no%TYPE;
   message_text_  VARCHAR2(80);

   CURSOR get_keys IS
      SELECT order_no, line_no, rel_no, line_item_no
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  pre_accounting_id = pre_accounting_id_;
BEGIN

   OPEN get_keys;
   FETCH get_keys INTO order_no_, line_no_, release_no_, line_item_no_;
   CLOSE get_keys;

   message_text_ := Language_SYS.Translate_Constant(lu_name_, 'PREACCCHG: The preposting has been added/changed.');
   Customer_Order_Line_Hist_API.New(order_no_, line_no_, release_no_, line_item_no_, message_text_);

END Handle_Pre_Posting_Change;


-- All_Non_Inv_Parts
--   This method returns TRUE if a given package part consists of all non
--   inventory parts .
@UncheckedAccess
FUNCTION All_Non_Inv_Parts (
   order_no_ IN VARCHAR2,
   line_no_  IN VARCHAR2,
   rel_no_   IN VARCHAR2 ) RETURN BOOLEAN
IS
   exist_        NUMBER;
   all_non_inv_  BOOLEAN := FALSE;

   CURSOR get_components IS
      SELECT 1
      FROM   CUSTOMER_ORDER_LINE_TAB col, SALES_PART_TAB sp
      WHERE  col.order_no     = order_no_
      AND    col.line_no      = line_no_
      AND    col.rel_no       = rel_no_
      AND    col.line_item_no > 0
      AND    col.rowstate    != 'Cancelled'
      AND    col.contract     = sp.contract
      AND    col.catalog_no   = sp.catalog_no
      AND    sp.catalog_type  = 'INV';
BEGIN
   OPEN get_components;
   FETCH get_components INTO exist_;
   IF (get_components%NOTFOUND) THEN
      all_non_inv_ := TRUE;
   END IF;
   CLOSE get_components;

   RETURN all_non_inv_;
END All_Non_Inv_Parts;


-- All_Components_Supply_Ipd
--   This method returns TRUE if a given package part consists of components all supplied from Int Purch Direct
--   or if the package does not have any components.
@UncheckedAccess
FUNCTION All_Components_Supply_Ipd (
   order_no_ IN VARCHAR2,
   line_no_  IN VARCHAR2,
   rel_no_   IN VARCHAR2 ) RETURN BOOLEAN
IS
   exist_   NUMBER;
   CURSOR get_component_supply IS
      SELECT   1
      FROM     CUSTOMER_ORDER_LINE_TAB
      WHERE    order_no = order_no_
      AND      line_no  = line_no_
      AND      rel_no   = rel_no_
      AND      line_item_no > 0
      AND      rowstate    != 'Cancelled'
      AND      supply_code != 'IPD';
BEGIN
   OPEN get_component_supply;
   FETCH get_component_supply INTO exist_;
   IF (get_component_supply%NOTFOUND) THEN
      CLOSE get_component_supply;
      RETURN TRUE;
   END IF;
   CLOSE get_component_supply;
   RETURN FALSE;
END All_Components_Supply_Ipd;


-- Get_Catch_Qty_Del_On_Delivnote
--   Return the total catch_qty_delivered for the specified delivery
--   note for the specified order line.
@UncheckedAccess
FUNCTION Get_Catch_Qty_Del_On_Delivnote (
   order_no_      IN VARCHAR2,
   line_no_       IN VARCHAR2,
   rel_no_        IN VARCHAR2,
   line_item_no_  IN NUMBER,
   delnote_no_    IN VARCHAR2 ) RETURN NUMBER
IS
   sum_ NUMBER;
   CURSOR get_sum_catch_qty_shipped IS
      SELECT SUM(catch_qty_shipped)
        FROM customer_order_delivery_tab
       WHERE order_no = order_no_
         AND line_no = line_no_
         AND rel_no = rel_no_
         AND line_item_no = line_item_no_
         AND delnote_no = delnote_no_
         AND cancelled_delivery = 'FALSE';
BEGIN
   OPEN get_sum_catch_qty_shipped;
   FETCH get_sum_catch_qty_shipped INTO sum_;
   IF (get_sum_catch_qty_shipped%NOTFOUND) THEN
      sum_ := 0;
   END IF;
   CLOSE get_sum_catch_qty_shipped;
   RETURN NVL(sum_, 0);
END Get_Catch_Qty_Del_On_Delivnote;

-- Get_Internal_Or_Customer_Po_No
--   Returns the internal PO number or the Customer PO number depending
--   on the demand code.
@UncheckedAccess
FUNCTION Get_Internal_Or_Customer_Po_No (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN VARCHAR2
IS
   order_rec_   CUSTOMER_ORDER_API.Public_Rec;
BEGIN
   order_rec_   := CUSTOMER_ORDER_API.Get(order_no_);

   IF (Get_Demand_Code_Db(order_no_,line_no_,rel_no_,line_item_no_) IN ('IPT', 'IPT_RO')) THEN
      RETURN order_rec_.internal_po_no;
   ELSE
      RETURN order_rec_.customer_po_no;
   END IF;
END Get_Internal_Or_Customer_Po_No;

-- Connect_To_Load_List
--   This method connects a order line to the specified load list.
PROCEDURE Connect_To_Load_List (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   load_id_      IN NUMBER )
IS
   attr_     VARCHAR2(2000);
   msg_text_ VARCHAR2(200);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('LOAD_ID', load_id_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);

   msg_text_ := Language_SYS.Translate_Constant(lu_name_, 'CONNLOADLISTID: This line is connected to Load list :P1', NULL, load_id_);
   Customer_Order_Line_Hist_API.New( order_no_,
                                     line_no_,
                                     rel_no_,
                                     line_item_no_,
                                     msg_text_);
END Connect_To_Load_List;


-- Disconnect_From_Load_List
--   This method disconnects the load list from a specified  order line.
PROCEDURE Disconnect_From_Load_List (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   load_id_      IN NUMBER )
IS
   attr_         VARCHAR2(2000);
   msg_text_     VARCHAR2(200);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('LOAD_ID', TO_NUMBER(NULL), attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
   msg_text_ := Language_SYS.Translate_Constant(lu_name_, 'DISCONLOADLISTID: This line is disconnected from Load list :P1', NULL, load_id_);
   Customer_Order_Line_Hist_API.New( order_no_,
                                     line_no_,
                                     rel_no_,
                                     line_item_no_,
                                     msg_text_);

END Disconnect_From_Load_List;


-- Check_Or_Modify_Activity_Seq
--   This method is performing two actions. Action CHECK will check whether
--   any reservation for partcular customer order has been made when material
--   allocation for the project is within activity. Action MODIFY will update
--   the activity sequence.
PROCEDURE Check_Or_Modify_Activity_Seq (
   res_within_activity_exist_ OUT VARCHAR2,
   order_no_                  IN  VARCHAR2,
   project_id_                IN  VARCHAR2,
   demand_ref1_               IN  VARCHAR2,
   demand_ref2_               IN  VARCHAR2,
   demand_ref3_               IN  VARCHAR2,
   new_activity_seq_          IN  NUMBER,
   action_                    IN  VARCHAR2)
IS
   dummy_                NUMBER;
   material_allocation_  VARCHAR2(25);

   CURSOR get_qty_assigned_exist IS
      SELECT 1
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = order_no_
      AND demand_code = 'PO'
      AND demand_order_ref1 = demand_ref1_
      AND demand_order_ref2 = demand_ref2_
      AND demand_order_ref3 = demand_ref3_
      AND project_id = project_id_
      AND qty_shipped = 0
      AND qty_assigned > 0;

   CURSOR get_order_lines IS
      SELECT line_no, rel_no, line_item_no, qty_assigned
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = order_no_
      AND demand_code = 'PO'
      AND demand_order_ref1 = demand_ref1_
      AND demand_order_ref2 = demand_ref2_
      AND demand_order_ref3 = demand_ref3_
      AND project_id = project_id_;
BEGIN
   res_within_activity_exist_ := 'FALSE';

   IF (action_ = 'CHECK') THEN
      IF ( project_id_ IS NOT NULL) THEN
         $IF (Component_Proj_SYS.INSTALLED)$THEN
            material_allocation_ := Project_API.Get_Material_Allocation_Db(project_id_);
         $END

         IF (material_allocation_ = 'WITHIN_ACTIVITY') THEN

            OPEN get_qty_assigned_exist;
            FETCH get_qty_assigned_exist INTO dummy_;
            IF (get_qty_assigned_exist%FOUND) THEN
               res_within_activity_exist_ := 'TRUE';
            END IF;
            CLOSE get_qty_assigned_exist;

         END IF;
      END IF;

   ELSIF (action_ = 'MODIFY') THEN

      FOR rec_ IN get_order_lines LOOP
         -- Should pass null before actually changing the activity sequence to reverse previous actions.
         Customer_Order_Line_API.Modify_Activity_Seq(order_no_, rec_.line_no, rec_.rel_no, rec_.line_item_no, NULL);
         Customer_Order_Line_API.Modify_Activity_Seq(order_no_, rec_.line_no, rec_.rel_no, rec_.line_item_no, new_activity_seq_);
      END LOOP;

   END IF;
END Check_Or_Modify_Activity_Seq;


-- Recalc_Line_Tot_Net_Weight
--   Recalculates line total net weight.
PROCEDURE Recalc_Line_Tot_Net_Weight (
   part_no_             IN VARCHAR2,
   configuration_id_    IN VARCHAR2 )
IS
   objid_             VARCHAR2(2000);
   rowversion_        VARCHAR2(2000);
   line_rec_          CUSTOMER_ORDER_LINE_TAB%ROWTYPE;

   CURSOR get_co_lines IS
      SELECT order_no, line_no, rel_no, line_item_no
        FROM CUSTOMER_ORDER_LINE_TAB
       WHERE configuration_id = configuration_id_
         AND part_no = part_no_
         AND rowstate NOT IN ('Invoiced', 'Cancelled', 'Delivered');
BEGIN

   FOR rec_ IN get_co_lines LOOP
      line_rec_ := Lock_By_Keys___(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
      Sales_Weight_Volume_Util_API.Get_Total_Weight_Volume(total_net_weight_      => line_rec_.line_total_weight,
                                                           total_gross_weight_    => line_rec_.line_total_weight_gross,
                                                           total_volume_          => line_rec_.line_total_qty,
                                                           adjusted_net_weight_   => line_rec_.adjusted_weight_net,
                                                           adjusted_gross_weight_ => line_rec_.adjusted_weight_gross,
                                                           adjusted_volume_       => line_rec_.adjusted_volume,
                                                           contract_              => line_rec_.contract,
                                                           catalog_no_            => line_rec_.catalog_no,
                                                           part_no_               => line_rec_.part_no,
                                                           buy_qty_due_           => line_rec_.buy_qty_due,
                                                           configuration_id_      => line_rec_.configuration_id,
                                                           input_unit_meas_       => line_rec_.input_unit_meas,
                                                           input_qty_              => line_rec_.input_qty,
                                                           packing_instruction_id_ => line_rec_.packing_instruction_id);
      Get_Id_Version_By_Keys___(objid_, rowversion_, rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
      line_rec_.rowversion := SYSDATE;
      -- This will not clear the info_. This is necessary because this method is used in CFGCHR.
      Update_Line___(objid_, line_rec_);
      IF (line_rec_.load_id IS NOT NULL) THEN
         Cust_Order_Load_List_Line_API.Modify_Line_Weights(load_id_      => line_rec_.load_id,
                                                           pos_          => Cust_Order_Load_List_Line_API.Get_Pos(line_rec_.load_id, rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no),
                                                           weight_net_   => line_rec_.line_total_weight,
                                                           weight_gross_ => line_rec_.line_total_weight_gross);
      END IF;
   END LOOP;
END Recalc_Line_Tot_Net_Weight;


-- Modify_Purchase_Part_No
--   Modifies the value of purchase part no field of a given customer order line
--   when the purchase part is connected to an inventory part which has a connection to a sales part.
PROCEDURE Modify_Purchase_Part_No (
   order_no_         IN VARCHAR2,
   line_no_          IN VARCHAR2,
   rel_no_           IN VARCHAR2,
   line_item_no_     IN NUMBER,
   purchase_part_no_ IN VARCHAR2 )
IS
   attr_             VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('PURCHASE_PART_NO', purchase_part_no_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Purchase_Part_No;


PROCEDURE Modify_Line_Default_Addr_Flag(
   line_rec_          IN     CUSTOMER_ORDER_LINE_TAB%ROWTYPE,
   order_no_          IN     VARCHAR2,
   default_addr_flag_ IN     VARCHAR2) 
IS
   new_default_addr_flag_ VARCHAR2(1);
BEGIN
   new_default_addr_flag_ := Check_Default_Addr_Flag___(line_rec_, order_no_, default_addr_flag_);
   IF (new_default_addr_flag_ != default_addr_flag_) THEN
      Modify_Default_Addr_Flag__(order_no_, line_rec_.line_no, line_rec_.rel_no, line_rec_.line_item_no, new_default_addr_flag_);
   END IF;      
END Modify_Line_Default_Addr_Flag;


-- Get_Qty_Picked_On_Deliv_Note
--   Return the total qty_picked for the specified delivery note for
--   the specified order line.
@UncheckedAccess
FUNCTION Get_Qty_Picked_On_Deliv_Note (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   delnote_no_   IN VARCHAR2 ) RETURN NUMBER
IS
   qty_picked_ NUMBER := 0;

   CURSOR get_sum_qty_picked IS
      SELECT sum(qty_picked)
      FROM   customer_order_reservation_tab
      WHERE  order_no     = order_no_
      AND    line_no      = line_no_
      AND    rel_no       = rel_no_
      AND    line_item_no = line_item_no_
      AND    delnote_no   = delnote_no_;
BEGIN
   OPEN get_sum_qty_picked;
   FETCH get_sum_qty_picked INTO qty_picked_;
   IF (get_sum_qty_picked%NOTFOUND) THEN
      qty_picked_ := 0;
   END IF;
   CLOSE get_sum_qty_picked;
   RETURN qty_picked_;
END Get_Qty_Picked_On_Deliv_Note;


-- Get_Current_Info
--   Return Global variable current_info_.
@UncheckedAccess
FUNCTION Get_Current_Info RETURN VARCHAR2
IS
  current_info_   VARCHAR2(32000);
BEGIN
   current_info_ :=  App_Context_SYS.Find_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_');
   RETURN current_info_;
END Get_Current_Info;


-- Clear_Current_Info
--   Clear Global variable current_info_.
PROCEDURE Clear_Current_Info
IS
   current_info_  VARCHAR2(32000);
BEGIN
   current_info_ := NULL;
   App_Context_SYS.Set_Value('CUSTOMER_ORDER_LINE_API.CURRENT_INFO_',current_info_);
END Clear_Current_Info;


-- Get_Calculated_Pkg_Cost
--   Calls the Update_Package_Cost___ implementation method to calculate the package cost for top part.
PROCEDURE Get_Calculated_Pkg_Cost (
   pkg_cost_     OUT NUMBER,
   pkg_order_no_ IN  VARCHAR2,
   pkg_line_no_  IN  VARCHAR2,
   pkg_rel_no_   IN  VARCHAR2)
IS
BEGIN
   Update_Package_Cost___(pkg_cost_, pkg_order_no_, pkg_line_no_, pkg_rel_no_);
END Get_Calculated_Pkg_Cost;


PROCEDURE Update_Freight_Free (
   rec_ IN CUSTOMER_ORDER_LINE_TAB%ROWTYPE )
IS
   charge_amount_ NUMBER;
   attr_          VARCHAR2(2000);
   freight_free_  VARCHAR2(5);

   CURSOR get_rec IS
      SELECT charge_amount
      FROM  customer_order_charge_tab
      WHERE order_no = rec_.order_no
      AND   line_no = rec_.line_no
      AND   rel_no = rec_.rel_no
      AND   line_item_no = rec_.line_item_no
      AND   charge_price_list_no IS NOT NULL;
BEGIN
   OPEN get_rec;
   FETCH get_rec INTO charge_amount_;
   CLOSE get_rec;

   Client_SYS.Clear_Attr(attr_);
   IF charge_amount_ = 0 THEN
      Client_SYS.Add_To_Attr('FREIGHT_FREE_DB', 'TRUE', attr_);
      freight_free_ := 'TRUE';
   ELSE
      Client_SYS.Add_To_Attr('FREIGHT_FREE_DB', 'FALSE', attr_);
      freight_free_ := 'FALSE';
   END IF;

   IF (rec_.freight_free != freight_free_) THEN
      Modify_Line___(attr_, rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no);
   END IF;
END Update_Freight_Free;


-- Copy_Prepostings_To_Line
--   Pre postings from the given order header will get copied to given line.
--   Intended to use in Order Quotation when creating order from quotation, with prepostings information added at that moment.
PROCEDURE Copy_Prepostings_To_Line (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER )
IS
   header_pre_acc_         NUMBER;
   pre_accounting_id_      NUMBER;
   contract_               VARCHAR2(5);
   CURSOR get_line_accounting_id IS
      SELECT pre_accounting_id, contract
        FROM CUSTOMER_ORDER_LINE_TAB
       WHERE order_no = order_no_
         AND line_no = line_no_
         AND rel_no = rel_no_
         AND line_item_no = line_item_no_;
BEGIN
   header_pre_acc_   := Customer_Order_API.Get_Pre_Accounting_Id(order_no_);

   OPEN get_line_accounting_id;
   FETCH get_line_accounting_id INTO pre_accounting_id_, contract_;
   CLOSE get_line_accounting_id;

   Pre_Accounting_API.Copy_Pre_Accounting(header_pre_acc_, pre_accounting_id_, contract_);

END Copy_Prepostings_To_Line;


PROCEDURE Calculate_Revenue (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER )
IS
   deferred_call_       VARCHAR2(1000) := 'CUSTOMER_ORDER_LINE_API.Calculate_Revenue__';
   posted_jobs_tab_     Transaction_SYS.Arguments_Table;

   attrib_value_        VARCHAR2(2000) := '';
   job_order_no_        CUSTOMER_ORDER_LINE_TAB.order_no%TYPE;
   job_line_no_         CUSTOMER_ORDER_LINE_TAB.line_no%TYPE;
   job_rel_no_          CUSTOMER_ORDER_LINE_TAB.rel_no%TYPE;
   job_line_item_no_    CUSTOMER_ORDER_LINE_TAB.line_item_no%TYPE;

   attr_                VARCHAR2(2000);
   batch_desc_          VARCHAR2(1000);
   posted_job_exists_   BOOLEAN := FALSE;
   
   activity_info_tab_          Public_Declarations_API.PROJ_Project_Conn_Cost_Tab;
   activity_revenue_info_tab_  Public_Declarations_API.PROJ_Project_Conn_Revenue_Tab;
   attributes_                 Public_Declarations_API.PROJ_Project_Conn_Attr_Type;
BEGIN
   posted_jobs_tab_ := Transaction_SYS.Get_Posted_Job_Arguments(deferred_call_, NULL);

   IF posted_jobs_tab_.COUNT > 0 THEN
      FOR i_ IN posted_jobs_tab_.FIRST..posted_jobs_tab_.LAST LOOP
         attrib_value_     := posted_jobs_tab_(i_).arguments_string;
         job_order_no_     := Client_SYS.Get_Item_Value('ORDER_NO',attrib_value_);
         job_line_no_      := Client_SYS.Get_Item_Value('LINE_NO',attrib_value_);
         job_rel_no_       := Client_SYS.Get_Item_Value('REL_NO',attrib_value_);
         job_line_item_no_ := Client_SYS.Get_Item_Value('LINE_ITEM_NO',attrib_value_);

         -- Check whether another job for same order line is posted
         IF ( job_order_no_ = order_no_ AND job_line_no_ = line_no_ AND
              job_rel_no_ = rel_no_ AND job_line_item_no_ = line_item_no_ ) THEN
            posted_job_exists_ := TRUE;
            EXIT;
         END IF;
      END LOOP;
   END IF;

   -- Create a new job if no posted job exists for the same order line
   IF ( NOT posted_job_exists_ ) THEN
      --Project connection header created seprately as an online call to avoid connection not created due to posting error in background job
      $IF (Component_Proj_SYS.INSTALLED) $THEN
      Create_Project_Connection___ (order_no_                        => order_no_,
                                    line_no_                         => line_no_,
                                    rel_no_                          => rel_no_,
                                    line_item_no_                    => line_item_no_,
                                    proj_lu_name_                    => 'COLINEREV',
                                    system_ctrl_connection_          => 'TRUE',
                                    activity_info_tab_               => activity_info_tab_,
                                    activity_revenue_info_tab_       => activity_revenue_info_tab_,
                                    attributes_                      => attributes_);
      $END
      Client_SYS.Clear_Attr(attr_);
      Client_SYS.Add_To_Attr('ORDER_NO', order_no_ , attr_);
      Client_SYS.Add_To_Attr('LINE_NO', line_no_ , attr_);
      Client_SYS.Add_To_Attr('REL_NO', rel_no_ , attr_);
      Client_SYS.Add_To_Attr('LINE_ITEM_NO', line_item_no_ , attr_);

      batch_desc_ := Language_SYS.Translate_Constant(lu_name_,'REFRESHPROJREVENUE: Refresh project revenue for Customer Order Line');
      Transaction_SYS.Deferred_Call(deferred_call_, attr_, batch_desc_);
   END IF;
END Calculate_Revenue;


PROCEDURE Refresh_Project_Connection (
   activity_info_tab_         IN OUT NOCOPY Public_Declarations_API.PROJ_Project_Conn_Cost_Tab,
   activity_revenue_info_tab_ IN OUT NOCOPY Public_Declarations_API.PROJ_Project_Conn_Revenue_Tab,
   attributes_                IN OUT NOCOPY Public_Declarations_API.PROJ_Project_Conn_Attr_Type,
   activity_seq_              IN     NUMBER,
   keyref1_                   IN     VARCHAR2,
   keyref2_                   IN     VARCHAR2,
   keyref3_                   IN     VARCHAR2,
   keyref4_                   IN     VARCHAR2,
   keyref5_                   IN     VARCHAR2,
   keyref6_                   IN     VARCHAR2,
   refresh_old_data_          IN     VARCHAR2 DEFAULT 'FALSE',
   proj_lu_name_              IN     VARCHAR2 DEFAULT NULL )
IS
   order_no_                         VARCHAR2(12)  := keyref1_;
   line_no_                          VARCHAR2(4)   := keyref2_;
   rel_no_                           VARCHAR2(4)   := keyref3_;
   line_item_no_                     NUMBER        := TO_NUMBER(keyref4_);
   rec_                              customer_order_line_tab%ROWTYPE;
   object_progress_                  NUMBER;
   committed_cost_elements_          Mpccom_Accounting_API.Project_Cost_Element_Tab;
   used_cost_elements_               Mpccom_Accounting_API.Project_Cost_Element_Tab;
   empty_tab_                        Mpccom_Accounting_API.Project_Cost_Element_Tab;
   planned_cost_elements_            Mpccom_Accounting_API.Project_Cost_Element_Tab;
   inventory_part_                   BOOLEAN;
   base_currency_code_               VARCHAR2(3);
   base_currency_type_               VARCHAR2(10);
   company_                          VARCHAR2(20);
   $IF Component_Proj_SYS.INSTALLED $THEN
   project_id_                       project_tab.project_id%TYPE;
   $END         
   count_                            PLS_INTEGER   := 0;
   countr_                           PLS_INTEGER   := 0;
   child_object_key1_                VARCHAR2(20);
   child_object_key2_                VARCHAR2(20);
   child_object_key3_                VARCHAR2(20);
   child_object_key4_                VARCHAR2(12);
   child_object_value_               VARCHAR2(30);
   progress_qty_                     NUMBER        := 0;
   progress_cost_                    NUMBER;
   progress_cost_tmp_                NUMBER;
   progress_hours_                   NUMBER;
   transaction_currency_code_        VARCHAR2(3);
   transaction_currency_rate_        NUMBER;
   planned_revenue_element_tab_      Order_Proj_Revenue_Manager_API.Project_Revenue_Element_Tab;
   co_currency_code_                 Customer_Order_tab.Currency_Code%TYPE;
   include_in_ev_                    VARCHAR2(10);
   transaction_curr_rate_cost_       NUMBER :=1;

   CURSOR get_project_cost_elements IS
      SELECT project_cost_element   project_cost_element,
             SUM(planned_amount)    planned_amount,
             SUM(planned_hours)     planned_hours,
             SUM(committed_amount)  committed_amount,
             SUM(used_amount)       used_amount
      FROM   project_cost_element_tmp
      GROUP BY project_cost_element;

   CURSOR get_proj_revenue_elements IS
      SELECT project_revenue_element project_revenue_element,
             SUM (amount)            planned_revenue
      FROM   TABLE(planned_revenue_element_tab_)
      GROUP BY project_revenue_element;

BEGIN
   rec_                       := Get_Object_By_Keys___ (order_no_, line_no_, rel_no_, line_item_no_);
   company_                   := Site_API.Get_Company (rec_.contract);
   co_currency_code_          := Customer_Order_API.Get_Currency_Code (order_no_ => order_no_);
   $IF Component_Proj_SYS.INSTALLED $THEN
   project_id_                := Activity_API.Get_Project_Id (activity_seq_ => rec_.activity_seq);
   base_currency_type_        := Project_API.Get_Currency_Type (project_id_, company_);
   $END         
   base_currency_code_        := Company_Finance_API.Get_Currency_Code (company_);
   transaction_currency_rate_ := 1 / rec_.currency_rate;
   count_                     := activity_info_tab_.COUNT;
   countr_                    := activity_revenue_info_tab_.COUNT;
   -- We need to consider demand codes 'IPT', 'IPD', 'SO', 'IO', 'NO', 'PD', 'DOP' and 'PT' to report EV under COLINE.   
   IF (rec_.supply_code IN ('IPT', 'IPD', 'SO', 'IO', 'PT', 'NO', 'PD', 'DOP')) THEN
      include_in_ev_          := 'TRUE';
   ELSE
      include_in_ev_          := 'FALSE';
   END IF;

   -- Start 'COLINE'
   IF (proj_lu_name_ = 'COLINE') THEN
      IF (( rec_.demand_code = 'WO' ) OR (Is_External_Service_Order___(rec_.demand_code, rec_.demand_order_ref1) = 'TRUE')) THEN
         RETURN;
      END IF;

      IF (Project_Connection_Exist___ (order_no_, line_no_, rel_no_, line_item_no_, rec_.activity_seq, proj_lu_name_) = 'TRUE') THEN

         Get_Activity_Info___ (planned_cost_elements_     => planned_cost_elements_,
                               committed_cost_elements_   => committed_cost_elements_,
                               used_cost_elements_        => used_cost_elements_,
                               object_progress_           => object_progress_,
                               rec_                       => rec_);

         IF (rec_.demand_code = Order_Supply_Type_API.DB_REPLACEMENT_CUSTOMER_ORDER) THEN
            RETURN;
         END IF;

         Invent_Proj_Cost_Manager_API.Fill_Project_Cost_Element_Tmp (planned_amount_tab_           => planned_cost_elements_,
                                                                     planned_committed_amount_tab_ => empty_tab_,
                                                                     committed_amount_tab_         => committed_cost_elements_,
                                                                     used_amount_tab_              => used_cost_elements_);

         -- PT: Purch Order Trans, PD: Purch Order Dir, IPT: Int Purch Trans, IPD: Int Purch Dir
         IF (rec_.supply_code IN ('PT', 'PD', 'IPT', 'IPD')) THEN
            inventory_part_                 := Inventory_Part_API.Check_Exist (contract_ => rec_.contract,
                                                                               part_no_  => rec_.part_no);
            IF (inventory_part_ = FALSE) THEN
               $IF (Component_Purch_SYS.INSTALLED) $THEN
                  transaction_currency_code_   := Purchase_Part_Supplier_API.Get_Currency_Code  (contract_  => rec_.contract,
                                                                                                 part_no_   => rec_.purchase_part_no,
                                                                                                 vendor_no_ => rec_.vendor_no);
               $END                                                                                              
               IF (transaction_currency_code_ IS NOT NULL) THEN
                  Currency_Rate_API.Get_Project_Currency_Rate (transaction_currency_rate_,
                                                               company_,
                                                               transaction_currency_code_,
                                                               base_currency_code_,
                                                               base_currency_type_,
                                                               Site_API.Get_Site_Date(rec_.contract));
                  transaction_curr_rate_cost_:= transaction_currency_rate_;
               END IF;
            END IF;
         END IF;

         -- IO: Invent Order, NO: Non Inventory, PI: Project Inventory
         IF (rec_.supply_code IN ('IO', 'NO', 'PI') AND NVL(rec_.revised_qty_due, 0) != 0) THEN
            progress_qty_                   := (NVL(rec_.qty_shipped, 0) - NVL(rec_.qty_returned, 0)) / rec_.revised_qty_due;
            progress_cost_                  := progress_qty_;
         END IF;

         -- PJD: Project Deliverables
         IF (rec_.supply_code = 'PJD' AND rec_.rowstate = 'Delivered') THEN
            progress_cost_                  := 1;
         END IF;

         -- PT: Purch Order Trans, PD: Purch Order Dir, IPT: Int Purch Trans, IPD: Int Purch Dir
         $IF Component_Purch_SYS.INSTALLED $THEN
            IF (rec_.supply_code IN ('PT', 'PD', 'IPT', 'IPD')) THEN
               Customer_Order_Pur_Order_API.Get_Purord_For_Custord (po_order_no_     => child_object_key1_,  --OUT parameter
                                                                    po_line_no_      => child_object_key2_,  --OUT parameter
                                                                    po_rel_no_       => child_object_key3_,  --OUT parameter
                                                                    purchase_type_   => child_object_value_, --OUT parameter
                                                                    oe_order_no_     => rec_.order_no,
                                                                    oe_line_no_      => rec_.line_no,
                                                                    oe_rel_no_       => rec_.rel_no,
                                                                    oe_line_item_no_ => rec_.line_item_no);

               progress_cost_               := Purchase_Order_Line_API.Get_Proj_Cost_Element_Progress (order_no_         => child_object_key1_,
                                                                                                       line_no_          => child_object_key2_,
                                                                                                       release_no_       => child_object_key3_,
                                                                                                       original_qty_due_ => NULL);
               IF (NVL(progress_cost_, 0) > 1) THEN
                  progress_cost_            := 1;
               END IF;
            END IF;
         $END

         -- SO: Shop Order
         $IF Component_Shpord_SYS.INSTALLED $THEN
            IF (rec_.supply_code = 'SO') THEN
               Customer_Order_Shop_Order_API.Get_Shop_Order (so_order_no_     => child_object_key1_, --OUT parameter
                                                             so_release_no_   => child_object_key2_, --OUT parameter
                                                             so_sequence_no_  => child_object_key3_, --OUT parameter
                                                             oe_order_no_     => rec_.order_no,
                                                             oe_line_no_      => rec_.line_no,
                                                             oe_rel_no_       => rec_.rel_no,
                                                             oe_line_item_no_ => rec_.line_item_no);
            END IF;
         $END

         -- DOP: DOP Order
         $IF Component_Dop_SYS.INSTALLED $THEN
            IF (rec_.supply_code = 'DOP') THEN
               child_object_key4_ := Dop_Demand_Cust_Ord_API.Get_Dop_Id_For_Cust_Ord_Line (order_no_        => rec_.order_no,
                                                                                           line_no_         => rec_.line_no,
                                                                                           rel_no_          => rec_.rel_no,
                                                                                           line_item_no_    => rec_.line_item_no);
            END IF;
         $END

         FOR proj_cost_element_rec_ IN get_project_cost_elements LOOP
            activity_info_tab_(count_).control_category          := proj_cost_element_rec_.project_cost_element;
            activity_info_tab_(count_).planned                   := proj_cost_element_rec_.planned_amount;
            activity_info_tab_(count_).planned_hours             := proj_cost_element_rec_.planned_hours;
            activity_info_tab_(count_).committed                 := proj_cost_element_rec_.committed_amount;
            activity_info_tab_(count_).used                      := proj_cost_element_rec_.used_amount;
            activity_info_tab_(count_).transaction_currency_code := transaction_currency_code_;
            activity_info_tab_(count_).planned_transaction       := activity_info_tab_(count_).planned * transaction_curr_rate_cost_;
            activity_info_tab_(count_).committed_transaction     := activity_info_tab_(count_).committed * transaction_curr_rate_cost_;
            activity_info_tab_(count_).used_transaction          := activity_info_tab_(count_).used * transaction_curr_rate_cost_;
            progress_cost_tmp_                                   := progress_cost_;
            IF (NVL(activity_info_tab_(count_).planned, 0) = 0) THEN
               progress_cost_tmp_                                := 0;
            END IF;
            IF (NVL(activity_info_tab_(count_).planned_hours, 0) = 0) THEN
               progress_hours_                                   := 0;
            END IF;
            -- SO: Shop Order
            $IF Component_Shpord_SYS.INSTALLED $THEN
               IF (rec_.supply_code = 'SO') THEN
                  IF (NVL(activity_info_tab_(count_).planned, 0) <> 0 OR
                      NVL(activity_info_tab_(count_).planned_hours, 0) <> 0) THEN
                     Shop_Order_Project_Cost_API.Get_Proj_Cost_Element_Progress (progress_cost_        => progress_cost_tmp_, --OUT parameter
                                                                                 progress_hours_       => progress_hours_,    --OUT parameter
                                                                                 order_no_             => child_object_key1_,
                                                                                 release_no_           => child_object_key2_,
                                                                                 sequence_no_          => child_object_key3_,
                                                                                 project_cost_element_ => activity_info_tab_(count_).control_category);
                  END IF;
               END IF;
            $END
            -- DOP: DOP Order
            -- Defect DE303 removed condition check for DOP-Connection
            $IF Component_Dop_SYS.INSTALLED $THEN
               IF (rec_.supply_code = 'DOP') THEN
                  IF (NVL(activity_info_tab_(count_).planned, 0) <> 0 OR
                      NVL(activity_info_tab_(count_).planned_hours, 0) <> 0) THEN
                     Dop_Head_API.Get_Proj_Cost_Element_Progress (progress_cost_        => progress_cost_tmp_,  --OUT parameter
                                                                  progress_hours_       => progress_hours_,     --OUT parameter
                                                                  dop_id_               => child_object_key4_,
                                                                  project_cost_element_ => activity_info_tab_(count_).control_category);
                  END IF;
               END IF;
            $END
            -- When CO-Line and child-object both does not report this project-cost-element to project-activity
            -- Only CO-Line is reporting this project-cost-element
            IF (NVL(progress_cost_tmp_, 0) = 0) AND (rec_.rowstate = 'Delivered') THEN
               progress_cost_tmp_                                := 1;
            END IF;
            IF (NVL(progress_hours_, 0) = 0) AND (rec_.rowstate = 'Delivered') THEN
               progress_hours_                                   := 1;
            END IF;
            activity_info_tab_(count_).progress_cost             := progress_cost_tmp_;
            activity_info_tab_(count_).progress_hours            := progress_hours_;
            activity_info_tab_(count_).earned_value_cost         := proj_cost_element_rec_.planned_amount * progress_cost_tmp_;
            activity_info_tab_(count_).earned_value_hours        := proj_cost_element_rec_.planned_hours * progress_hours_;
            count_                                               := count_ + 1;
         END LOOP;

         attributes_.include_in_ev         := include_in_ev_;
         attributes_.last_transaction_date := SYSDATE;

         IF (refresh_old_data_ = 'FALSE') THEN
            $IF Component_Proj_SYS.INSTALLED $THEN
            Project_Connection_Util_API.Refresh_Connection (proj_lu_name_              => proj_lu_name_,
                                                            activity_seq_              => rec_.activity_seq,
                                                            keyref1_                   => rec_.order_no,
                                                            keyref2_                   => rec_.line_no,
                                                            keyref3_                   => rec_.rel_no,
                                                            keyref4_                   => rec_.line_item_no,
                                                            keyref5_                   => '*',
                                                            keyref6_                   => '*',
                                                            object_description_        => lu_name_,
                                                            activity_info_tab_         => activity_info_tab_,
                                                            activity_revenue_info_tab_ => activity_revenue_info_tab_,
                                                            attributes_                => attributes_);
            $ELSE
            NULL;
            $END         
         END IF;
      END IF;

      -- Purchase Component Parts should report their cost and progress back to the Purchase Order Line.
      IF (refresh_old_data_ = 'FALSE') THEN
         -- Purchase Component Parts should report their cost and progress back to the Purchase Order Line.
         $IF (Component_Purch_SYS.INSTALLED) $THEN
            IF (Is_Purch_Comp_Part_Line___(rec_)) THEN
               Purchase_Order_Line_API.Calculate_Cost_And_Progress (rec_.demand_order_ref1, rec_.demand_order_ref2, rec_.demand_order_ref3);
            END IF;
         $ELSE
            NULL;
         $END
      END IF;

   END IF;

   -- Start 'COLINEREV'
   IF (proj_lu_name_ = 'COLINEREV') THEN
      -- skip the revenue calculation for PKG part component lines
      IF (line_item_no_ > 0) THEN
         RETURN;
      END IF;

      planned_revenue_element_tab_ := Order_Proj_Revenue_Manager_API.Get_Planned_Revenue_Elements (rec_,
                                                                                                   refresh_old_data_ );

      FOR proj_revenue_element_rec_ IN get_proj_revenue_elements LOOP
         IF (Project_Cost_Element_API.Get_Element_Type_Db (company_, proj_revenue_element_rec_.project_revenue_element) = 'REVENUE') THEN
            activity_revenue_info_tab_(countr_).control_category          := proj_revenue_element_rec_.project_revenue_element;
            activity_revenue_info_tab_(countr_).planned_revenue           := proj_revenue_element_rec_.planned_revenue;
            activity_revenue_info_tab_(countr_).transaction_currency_code := co_currency_code_;
            activity_revenue_info_tab_(countr_).planned_transaction       := activity_revenue_info_tab_(countr_).planned_revenue * transaction_currency_rate_;
            countr_                                                       := countr_ + 1;
         ELSE
            activity_info_tab_(count_).control_category                   := proj_revenue_element_rec_.project_revenue_element;
            activity_info_tab_(count_).planned                            := -1 * proj_revenue_element_rec_.planned_revenue;
            activity_info_tab_(count_).transaction_currency_code          := co_currency_code_;
            activity_info_tab_(count_).planned_transaction                := activity_info_tab_(count_).planned * transaction_currency_rate_;
            count_                                                        := count_ + 1;
         END IF;
      END LOOP;

      IF (refresh_old_data_ = 'FALSE') THEN
         IF (Project_Connection_Exist___ (order_no_, line_no_, rel_no_, line_item_no_, rec_.activity_seq, proj_lu_name_) = 'FALSE') THEN
            Create_Project_Connection___ (order_no_                        => rec_.order_no,
                                          line_no_                         => rec_.line_no,
                                          rel_no_                          => rec_.rel_no,
                                          line_item_no_                    => rec_.line_item_no,
                                          proj_lu_name_                    => 'COLINEREV',
                                          system_ctrl_connection_          => 'TRUE',
                                          activity_info_tab_               => activity_info_tab_,
                                          activity_revenue_info_tab_       => activity_revenue_info_tab_,
                                          attributes_                      => attributes_);

         ELSE
            $IF Component_Proj_SYS.INSTALLED $THEN
            Project_Connection_Util_API.Refresh_Connection (proj_lu_name_              =>  proj_lu_name_,
                                                            activity_seq_              =>  rec_.activity_seq,
                                                            keyref1_                   =>  rec_.order_no,
                                                            keyref2_                   =>  rec_.line_no,
                                                            keyref3_                   =>  rec_.rel_no,
                                                            keyref4_                   =>  rec_.line_item_no,
                                                            keyref5_                   =>  '*',
                                                            keyref6_                   =>  '*',
                                                            object_description_        =>  lu_name_,
                                                            activity_info_tab_         =>  activity_info_tab_,
                                                            activity_revenue_info_tab_ =>  activity_revenue_info_tab_ );
            $ELSE
            NULL;
            $END         
         END IF;
      END IF;

   END IF;
END Refresh_Project_Connection;


PROCEDURE Modify_Freight_Info (
   order_no_          IN VARCHAR2,
   line_no_           IN VARCHAR2,
   rel_no_            IN VARCHAR2,
   line_item_no_      IN NUMBER,
   freight_map_id_    IN VARCHAR2,
   zone_id_           IN VARCHAR2 )
IS
   freight_price_list_no_  CUSTOMER_ORDER_LINE_TAB.freight_price_list_no%TYPE;
   contract_               CUSTOMER_ORDER_LINE_TAB.contract%TYPE;
   ship_via_code_          CUSTOMER_ORDER_LINE_TAB.ship_via_code%TYPE;
   forward_agent_id_       CUSTOMER_ORDER_LINE_TAB.forward_agent_id%TYPE;
   supply_code_            CUSTOMER_ORDER_LINE_TAB.supply_code%TYPE;
   vendor_no_              CUSTOMER_ORDER_LINE_TAB.vendor_no%TYPE;
   attr_                   VARCHAR2(2000);
   use_price_incl_tax_     CUSTOMER_ORDER_TAB.use_price_incl_tax%TYPE;

   CURSOR get_line IS
      SELECT contract, ship_via_code, forward_agent_id, supply_code, vendor_no
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = order_no_
      AND   line_no = line_no_
      AND   rel_no = rel_no_
      AND   line_item_no = line_item_no_;
BEGIN
   IF (freight_map_id_ IS NOT NULL) AND (zone_id_ IS NOT NULL) THEN
      OPEN get_line;
      FETCH get_line INTO contract_, ship_via_code_, forward_agent_id_, supply_code_, vendor_no_;
      CLOSE get_line;
      use_price_incl_tax_ := CUSTOMER_ORDER_API.Get_Use_Price_Incl_Tax_Db(order_no_);
      IF ((supply_code_ IN ('PD', 'IPD') AND vendor_no_ IS NOT NULL)) THEN
         freight_price_list_no_ := Freight_Price_List_Direct_API.Get_Active_Freight_List_No(contract_, ship_via_code_, freight_map_id_, forward_agent_id_, use_price_incl_tax_, vendor_no_);
      ELSE
         freight_price_list_no_ := Freight_Price_List_API.Get_Active_Freight_List_No(contract_, ship_via_code_, freight_map_id_, forward_agent_id_, use_price_incl_tax_);
      END IF;
   END IF;
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('FREIGHT_MAP_ID', freight_map_id_, attr_);
   Client_SYS.Add_To_Attr('ZONE_ID', zone_id_, attr_);
   Client_SYS.Add_To_Attr('FREIGHT_PRICE_LIST_NO', freight_price_list_no_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Freight_Info;


-- Check_Exist
--   Check if the specified record exists.
@UncheckedAccess
FUNCTION Check_Exist (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN BOOLEAN
IS
BEGIN
   RETURN Check_Exist___(order_no_, line_no_, rel_no_, line_item_no_);
END Check_Exist;


-- Is_Comp_Not_Rel_Mtrl_Planned
--   This method returns 'TRUE' if the given customer order line with a package part
--   has a component line(s) having rel_mtrl_planning set to FALSE.
@UncheckedAccess
FUNCTION Is_Comp_Not_Rel_Mtrl_Planned (
   order_no_ IN VARCHAR2,
   line_no_  IN VARCHAR2,
   rel_no_   IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ NUMBER := 0;
   CURSOR check_rel_mtrl_pln IS
      SELECT 1
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE order_no = order_no_
      AND   line_no  = line_no_
      AND   rel_no   = rel_no_
      AND   line_item_no > 0
      AND   rel_mtrl_planning = 'FALSE';
BEGIN
   OPEN check_rel_mtrl_pln;
   FETCH check_rel_mtrl_pln INTO temp_;

   IF (check_rel_mtrl_pln%FOUND) THEN
      CLOSE check_rel_mtrl_pln;
      RETURN 'TRUE';
   END IF;
   CLOSE check_rel_mtrl_pln;
   RETURN 'FALSE';

END Is_Comp_Not_Rel_Mtrl_Planned;


@UncheckedAccess
FUNCTION Get_Possible_Sales_Promo_Deal (
   order_no_                   IN VARCHAR2,
   line_no_                    IN VARCHAR2,
   rel_no_                     IN VARCHAR2,
   line_item_no_               IN NUMBER,
   rowstate_                   IN VARCHAR2,
   price_source_net_price_db_  IN VARCHAR2,
   charged_item_db_            IN VARCHAR2,
   exchange_item_db_           IN VARCHAR2,
   self_billing_db_            IN VARCHAR2,
   part_ownership_db_          IN VARCHAR2,
   rental_db_                  IN VARCHAR2 ) RETURN VARCHAR2
IS
   deal_description_    VARCHAR2(200);
   header_rec_          Customer_Order_API.Public_Rec;
BEGIN
   header_rec_ := Customer_Order_API.Get(order_no_); 
   -- any changes in these conditions could also affect where statements in cursor get_possible_order_lines in methods Sales_Promotion_Util_API.Calculate_Order_Deal_Buy___/Calculate_Order_Deal_Get___
   IF (rowstate_ NOT IN ('Cancelled','Invoiced') AND
       price_source_net_price_db_ = 'FALSE' AND
       charged_item_db_ = 'CHARGED ITEM' AND
       exchange_item_db_ = 'ITEM NOT EXCHANGED' AND
       self_billing_db_ = 'NOT SELF BILLING' AND
       part_ownership_db_ = 'COMPANY OWNED' AND
       NVL(Site_API.Get_Company(Cust_Ord_Customer_API.Get_Acquisition_Site(header_rec_.customer_no)), ' ') != Site_API.Get_Company(header_rec_.contract) AND
       line_item_no_ <= 0 AND
       rental_db_ = Fnd_Boolean_API.DB_FALSE)  THEN
      deal_description_ := Sales_Promotion_Util_API.Get_Possible_Sales_Promo_Deal(order_no_, line_no_, rel_no_, line_item_no_, 'ORDER');
   END IF;

   RETURN deal_description_;
END Get_Possible_Sales_Promo_Deal;


-- Is_Change_Config_Allowed
--   Returns TRUE if the customer order line can have its connected
--   configuration modified.
@UncheckedAccess
FUNCTION Is_Change_Config_Allowed (
   order_no_      IN VARCHAR2,
   line_no_       IN VARCHAR2,
   rel_no_        IN VARCHAR2,
   line_item_no_  IN NUMBER ) RETURN BOOLEAN
IS
   change_allowed_   BOOLEAN := FALSE;
   part_no_          CUSTOMER_ORDER_LINE_TAB.part_no%TYPE;
   catalog_no_       CUSTOMER_ORDER_LINE_TAB.catalog_no%TYPE;
   rowstate_         CUSTOMER_ORDER_LINE_TAB.rowstate%TYPE;

   CURSOR get_rec IS
      SELECT part_no, catalog_no, rowstate
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no     = order_no_
      AND    line_no      = line_no_
      AND    rel_no       = rel_no_
      AND    line_item_no = line_item_no_;
BEGIN
   OPEN  get_rec;
   FETCH get_rec INTO part_no_, catalog_no_, rowstate_;
   IF (get_rec%FOUND) THEN
      change_allowed_ := ((rowstate_ = 'Released') AND (Part_Catalog_API.Get_Configurable_Db(NVL(part_no_, catalog_no_)) = 'CONFIGURED'));
   END IF;
   CLOSE get_rec;

   RETURN change_allowed_;
END Is_Change_Config_Allowed;


-- Get_Rental_No
--   Returns the rental_no for a customer order rental line.
@UncheckedAccess
FUNCTION Get_Rental_No (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   rental_no_    NUMBER := NULL;
BEGIN
   IF (Get_Rental_Db(order_no_, line_no_, rel_no_, line_item_no_) = Fnd_Boolean_API.DB_TRUE) THEN
      $IF Component_Rental_SYS.INSTALLED $THEN
         rental_no_ := Rental_Object_API.Get_Rental_No(order_no_,
                                                       line_no_,
                                                       rel_no_,
                                                       line_item_no_,
                                                       Rental_Type_API.DB_CUSTOMER_ORDER);
      $ELSE
         NULL;
      $END
   END IF;
   RETURN rental_no_;
END Get_Rental_No;


-- Calculate_Prices
--   Calculates price columns of the order line.
--   if use_price_incl_tax_ is checked, price excluding tax will be calculated using price including tax
--   else price including tax will be calculated using price excluding tax.
PROCEDURE Calculate_Prices (
   sale_unit_price_            IN OUT NUMBER,
   unit_price_incl_tax_        IN OUT NUMBER,
   base_sale_unit_price_       IN OUT NUMBER,
   base_unit_price_incl_tax_   IN OUT NUMBER,
   order_no_                   IN     VARCHAR2,
   line_no_                    IN     VARCHAR2,
   rel_no_                     IN     VARCHAR2,
   line_item_no_               IN     NUMBER )
IS
   line_rec_   Customer_Order_Line_Tab%ROWTYPE;
BEGIN
   line_rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   
   line_rec_.sale_unit_price := sale_unit_price_;
   line_rec_.unit_price_incl_tax := unit_price_incl_tax_;
   line_rec_.base_sale_unit_price := base_sale_unit_price_;
   line_rec_.base_unit_price_incl_tax := base_unit_price_incl_tax_;
   
   Calculate_Prices(line_rec_);
   
   sale_unit_price_ := line_rec_.sale_unit_price ;
   unit_price_incl_tax_ := line_rec_.unit_price_incl_tax;
   base_sale_unit_price_ := line_rec_.base_sale_unit_price;
   base_unit_price_incl_tax_ := line_rec_.base_unit_price_incl_tax;
END Calculate_Prices;


PROCEDURE Calculate_Prices (
   newrec_ IN OUT Customer_Order_Line_Tab%ROWTYPE )
IS
   multiple_tax_           VARCHAR2(20);
   order_rec_              Customer_Order_API.Public_Rec;   
   tax_liability_type_db_ VARCHAR2(20);
BEGIN 
   order_rec_          := Customer_Order_API.Get(newrec_.order_no);
         
   IF (Order_Supply_Type_API.Encode(newrec_.demand_code) = 'IPD') THEN
      tax_liability_type_db_ := External_Cust_Order_Line_API.Get_Tax_Liability(newrec_.order_no, newrec_.line_no, newrec_.rel_no);
   ELSE
      tax_liability_type_db_ := newrec_.tax_liability_type;
   END IF;
   
   IF (newrec_.base_sale_unit_price = 0 AND newrec_.sale_unit_price = 0 AND newrec_.free_of_charge = Fnd_Boolean_API.DB_TRUE) THEN
      newrec_.base_unit_price_incl_tax := 0 ;
      newrec_.unit_price_incl_tax := 0;
   ELSIF (newrec_.part_ownership NOT IN (Part_Ownership_API.DB_CUSTOMER_OWNED, Part_Ownership_API.DB_SUPPLIER_LOANED )) THEN
      Tax_Handling_Order_Util_API.Get_Prices(newrec_.base_sale_unit_price,
                                             newrec_.base_unit_price_incl_tax,
                                             newrec_.sale_unit_price,
                                             newrec_.unit_price_incl_tax,
                                             multiple_tax_,
                                             newrec_.tax_code,
                                             newrec_.tax_calc_structure_id,
                                             newrec_.tax_class_id,
                                             newrec_.order_no, 
                                             newrec_.line_no, 
                                             newrec_.rel_no, 
                                             newrec_.line_item_no,
                                             '*',
                                             Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                             order_rec_.contract,
                                             order_rec_.customer_no,
                                             newrec_.ship_addr_no,
                                             newrec_.planned_ship_date,
                                             order_rec_.supply_country,
                                             NVL(newrec_.delivery_type, '*'),
                                             newrec_.catalog_no,
                                             order_rec_.use_price_incl_tax,
                                             order_rec_.currency_code,
                                             newrec_.currency_rate,
                                             'FALSE',                                          
                                             newrec_.tax_liability,
                                             tax_liability_type_db_,
                                             delivery_country_db_ => NULL,
                                             ifs_curr_rounding_ => 16,
                                             tax_from_diff_source_ => 'FALSE',
                                             attr_ => NULL);
   ELSE
      newrec_.part_price               := 0;
      newrec_.sale_unit_price          := 0;
      newrec_.unit_price_incl_tax      := 0;
      newrec_.base_sale_unit_price     := 0;
      newrec_.base_unit_price_incl_tax := 0;
      newrec_.cost                     := 0;
      newrec_.price_source             := 'UNSPECIFIED';
      newrec_.price_source_id          := NULL;
      IF (newrec_.char_price IS NOT NULL) THEN
         newrec_.char_price := 0;
      END IF;
      IF (newrec_.calc_char_price IS NOT NULL) THEN
         newrec_.calc_char_price := 0;
      END IF;
   END IF;                                       
END Calculate_Prices;


@UncheckedAccess
FUNCTION Is_Route_Excp_Date_On_Shipdate (
   contract_               IN VARCHAR2,
   route_id_               IN VARCHAR2,
   exception_date_time_    IN DATE ) RETURN VARCHAR2
IS
   dummy_ NUMBER;
   CURSOR line_exist IS
      SELECT 1
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE contract = contract_
      AND   route_id = route_id_
      AND   TO_CHAR(planned_ship_date, Report_SYS.datetime_format_) = TO_CHAR(exception_date_time_, Report_SYS.datetime_format_)
      AND   rowstate NOT IN ('Invoiced', 'Cancelled', 'Delivered');
BEGIN
   OPEN line_exist;
   FETCH line_exist INTO dummy_;
   IF (line_exist%FOUND) THEN
      CLOSE line_exist;
      RETURN 'TRUE';
   END IF;
   CLOSE line_exist;
   RETURN 'FALSE';
END;


-- Modify_Open_Shipment_Qty
--   Modify the Open_Shipment_Qty attribute.
PROCEDURE Modify_Open_Shipment_Qty (
   order_no_          IN VARCHAR2,
   line_no_           IN VARCHAR2,
   rel_no_            IN VARCHAR2,
   line_item_no_      IN NUMBER,
   open_shipment_qty_ IN NUMBER )
IS
   attr_ VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('OPEN_SHIPMENT_QTY', open_shipment_qty_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Open_Shipment_Qty;


-- Get_Custord_From_Demand_Info
--   This method returns the customer order line details for a given demand order info.
@UncheckedAccess
PROCEDURE Get_Custord_From_Demand_Info (
   order_no_           OUT VARCHAR2,
   line_no_            OUT VARCHAR2,
   rel_no_             OUT VARCHAR2,
   line_item_no_       OUT NUMBER,
   demand_order_ref1_  IN  VARCHAR2,
   demand_order_ref2_  IN  VARCHAR2,
   demand_order_ref3_  IN  VARCHAR2,
   demand_order_ref4_  IN  NUMBER,
   demand_code_        IN  VARCHAR2 )
IS
   CURSOR get_order_info IS
      SELECT order_no, line_no, rel_no, line_item_no
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  demand_order_ref1 = demand_order_ref1_
      AND    demand_order_ref2 = demand_order_ref2_
      AND    demand_order_ref3 = demand_order_ref3_
      AND    (demand_order_ref4 = demand_order_ref4_ OR demand_order_ref4_ IS NULL)
      AND    demand_code        = demand_code_;
BEGIN
   OPEN get_order_info;
   FETCH get_order_info INTO order_no_, line_no_, rel_no_, line_item_no_;
   CLOSE get_order_info;
END Get_Custord_From_Demand_Info;


-- Get_Serials_From_Demand_Info
--   This method returns a list of serial numbers for a given demand order info.
@UncheckedAccess
PROCEDURE Get_Serials_From_Demand_Info (
   list_serial_no_     OUT CLOB,
   demand_order_ref1_  IN  VARCHAR2,
   demand_order_ref2_  IN  VARCHAR2,
   demand_order_ref3_  IN  VARCHAR2)
IS
   order_no_    VARCHAR2(32);
   line_no_     VARCHAR2(32);
   rel_no_      VARCHAR2(32);
   supply_code_ VARCHAR2(32);
   po_no_       VARCHAR2(32);
   po_line_no_  VARCHAR2(32);
   po_rel_no_   VARCHAR2(32);

  CURSOR get_co_info_ IS
      SELECT col.order_no, col.line_no, col.rel_no, col.supply_code
      FROM   customer_order_line_tab col
      WHERE  col.demand_order_ref1 = po_no_
      AND    col.demand_order_ref2 = po_line_no_
      AND    col.demand_order_ref3 = po_rel_no_;

  CURSOR get_po_info_ is
      SELECT cop.po_order_no, cop.po_line_no, cop.po_rel_no
      FROM   customer_order_pur_order_tab cop
      WHERE  cop.oe_order_no = order_no_
      AND    cop.oe_line_no = line_no_
      AND    cop.oe_rel_no = rel_no_;

  CURSOR get_serials_ IS
      SELECT ith.serial_no serial_no
         FROM   inventory_transaction_hist_pub ith
         WHERE  ith.source_ref1       = order_no_
         AND    ith.source_ref2       = line_no_
         AND    ith.source_ref3       = rel_no_
         AND    ith.transaction_code IN ('SHIPDIR', 'INTPODIRIM', 'PODIRINTEM', 'OESHIP');
BEGIN
   po_no_      := demand_order_ref1_;
   po_line_no_ := demand_order_ref2_;
   po_rel_no_  := demand_order_ref3_;

   LOOP
      OPEN  get_co_info_;
      FETCH get_co_info_ INTO order_no_, line_no_, rel_no_, supply_code_;
      CLOSE get_co_info_;
      EXIT  WHEN order_no_ IS NULL OR supply_code_ !='IPD';

      OPEN  get_po_info_;
      FETCH get_po_info_ INTO po_no_, po_line_no_, po_rel_no_;
      CLOSE get_po_info_;
      EXIT WHEN po_no_ IS NULL;
   END LOOP;

   FOR rec_ IN get_serials_ LOOP
     IF (list_serial_no_ IS NULL) THEN
       list_serial_no_ := ''''|| rec_.serial_no || '''';
     ELSE
        list_serial_no_ := list_serial_no_ || ',' ||  '''' || rec_.serial_no || '''';
     END IF;
   END LOOP;
END Get_Serials_From_Demand_Info;


-- Get_Custord_From_Supply_Info
--   This method returns the customer order number for a given supply order info.
@UncheckedAccess
PROCEDURE Get_Custord_From_Supply_Info (
   ext_order_no_ OUT VARCHAR2,
   order_no_     IN  VARCHAR2 )
IS
   CURSOR get_order_info IS
      SELECT oe_order_no
      FROM  customer_order_line_Tab col, customer_order_pur_order_tab copo
      WHERE demand_code IN ('IPD', 'IPT', 'IPT_RO')
      AND   copo.po_order_no     = col.demand_order_ref1
      AND   copo.po_line_no      = col.demand_order_ref2
      AND   copo.po_rel_no       = col.demand_order_ref3
      AND   copo.purchase_type   = 'O'
      AND   rownum               = 1
      AND   col.order_no         = order_no_;
BEGIN
   OPEN  get_order_info;
   FETCH get_order_info INTO ext_order_no_ ;
   CLOSE get_order_info;
END Get_Custord_From_Supply_Info;


@UncheckedAccess
PROCEDURE Get_Parent_Cust_Order (
   parent_order_no_ OUT VARCHAR2,
   order_no_        IN  VARCHAR2 )
IS
   CURSOR get_order_info IS
      SELECT oe_order_no
      FROM   customer_order_line_Tab col, customer_order_pur_order_tab copo
      WHERE  demand_code IN ('IPD', 'IPT')
      AND    copo.po_order_no   = col.demand_order_ref1
      AND    copo.po_line_no    = col.demand_order_ref2
      AND    copo.po_rel_no     = col.demand_order_ref3
      AND    copo.purchase_type = 'O'
      AND    rownum             = 1
      AND    col.order_no       = order_no_;
BEGIN
   OPEN  get_order_info;
   FETCH get_order_info INTO parent_order_no_;
   CLOSE get_order_info;
END Get_Parent_Cust_Order;


@UncheckedAccess
PROCEDURE Get_External_Cust_Order(
   ext_order_no_ OUT VARCHAR2,
   order_no_     IN  VARCHAR2 )
IS
   temp_ext_order_no_ VARCHAR2(20);
   parent_order_no_   VARCHAR2(20);
BEGIN
   temp_ext_order_no_ := order_no_;
   LOOP
      Get_Parent_Cust_Order(parent_order_no_, temp_ext_order_no_);
      EXIT WHEN parent_order_no_ IS NULL;
      temp_ext_order_no_ := parent_order_no_;
   END LOOP;
   ext_order_no_ := temp_ext_order_no_;
END Get_External_Cust_Order;


@UncheckedAccess
FUNCTION Check_All_Comp_Non_Inv (
   order_no_ IN VARCHAR2,
   line_no_  IN VARCHAR2,
   rel_no_   IN VARCHAR2 ) RETURN BOOLEAN
IS
   all_comp_non_inv_ BOOLEAN := TRUE;
   CURSOR get_comp_part_no IS
      SELECT part_no
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no     = order_no_
      AND    line_no      = line_no_
      AND    rel_no       = rel_no_
      AND    line_item_no > 0;
BEGIN
   FOR comprec_ IN  get_comp_part_no LOOP
      IF (comprec_.part_no IS NOT NULL) THEN
         all_comp_non_inv_ := FALSE;
         EXIT;
      END IF;
   END LOOP;
   RETURN all_comp_non_inv_;
END Check_All_Comp_Non_Inv;


-- Get_Connectable_Sales_Qty
--   Returns the available quantity to connect for a shipment for a given order line
@UncheckedAccess
FUNCTION Get_Connectable_Sales_Qty (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   connectable_qty_  NUMBER;

   CURSOR get_connectable_qty IS
      SELECT ((revised_qty_due - qty_shipped - open_shipment_qty + qty_shipdiff) * inverted_conv_factor/conv_factor)
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = order_no_
      AND    line_no = line_no_
      AND    rel_no = rel_no_
      AND    line_item_no = line_item_no_;
BEGIN
   OPEN get_connectable_qty;
   FETCH get_connectable_qty INTO connectable_qty_;
   CLOSE get_connectable_qty;
   RETURN connectable_qty_;
END Get_Connectable_Sales_Qty;


-- Set_Rel_Mtrl_Planning
--   Sets rel_mtrl_planning according to the setting in site to site reservation setup. Therefor rel_mtrl_planning 
--   will not be always TRUE when Releasing the customer order. However if there is no entry in site to site reservation setup
--   then it will be always set to TRUR when Release.
PROCEDURE Set_Rel_Mtrl_Planning (
   order_no_               IN VARCHAR2,
   line_no_                IN VARCHAR2,
   rel_no_                 IN VARCHAR2,
   line_item_no_           IN NUMBER,
   rel_mtrl_planning_      IN VARCHAR2,
   create_connected_order_ IN VARCHAR2 )
IS
   attr_             VARCHAR2(2000);
   col_rec_          Customer_Order_Line_API.Public_Rec;
BEGIN

   Client_SYS.Clear_Attr(attr_);
   col_rec_ := Get(order_no_, line_no_, rel_no_, line_item_no_);
   
   IF ((Site_To_Site_Reserve_Setup_API.Exists(col_rec_.supply_site, col_rec_.contract)) AND
      (Site_To_Site_Reserve_Setup_API.Get_Rel_Mtrl_Planning_Db(col_rec_.supply_site, col_rec_.contract) = Rel_Mtrl_Planning_API.DB_NOT_VIS_PLANNED_RELEASED)) THEN
      
      Client_SYS.Add_To_Attr('REL_MTRL_PLANNING', 'FALSE', attr_);      
   ELSE
      Client_SYS.Add_To_Attr('REL_MTRL_PLANNING', rel_mtrl_planning_, attr_);
   END IF;
   Client_SYS.Add_To_Attr('CREATE_CONNECTED_ORDER', create_connected_order_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Set_Rel_Mtrl_Planning;


-- Get_Qty_Returned
--   Return an order line's qty_returned.
--   External Service Orders call this to get the quantity returned and buy qty due.
@UncheckedAccess
PROCEDURE Get_Qty_Returned (
   buy_qty_due_  OUT NUMBER,
   qty_returned_ OUT NUMBER,
   order_no_     IN  VARCHAR2,
   ord_ref1_     IN  VARCHAR2,
   ord_ref2_     IN  VARCHAR2,
   ord_ref3_     IN  VARCHAR2 )
IS
   CURSOR get_attr IS
      SELECT buy_qty_due, qty_returned
      FROM  CUSTOMER_ORDER_LINE_TAB
      WHERE order_no             = order_no_
      AND   demand_order_ref1    = ord_ref1_
      AND   demand_order_ref2    = ord_ref2_
      AND   demand_order_ref3    = ord_ref3_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO buy_qty_due_,qty_returned_;
   CLOSE get_attr;
END Get_Qty_Returned;


PROCEDURE New_Rental_Replacement_Line (
   new_order_no_      IN  VARCHAR2,
   old_order_no_      IN  VARCHAR2,
   old_line_no_       IN  VARCHAR2,
   old_rel_no_        IN  VARCHAR2,
   old_line_item_no_  IN  NUMBER,
   new_buy_qty_due_   IN  NUMBER,
   rental_attr_       IN  VARCHAR2 )
IS
   ptr_                       NUMBER;
   name_                      VARCHAR2(30);
   value_                     VARCHAR2(4000);
   objid_                     VARCHAR2(2000);
   objversion_                VARCHAR2(2000);
   attr_                      VARCHAR2(32000);
   addr_attr_                 VARCHAR2(4000);
   addr_flag_db_              VARCHAR2(10);
   newrec_                    CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   old_col_rec_               CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   order_rec_                 Customer_Order_API.Public_Rec;
   addr_rec_                  CUST_ORDER_LINE_ADDRESS_TAB%ROWTYPE;
   indrec_                    Indicator_Rec;
   order_objstate_            VARCHAR2(20);
   planned_rental_end_date_   DATE;
   planned_rental_end_time_   DATE;

   CURSOR get_ord_line_addr IS
      SELECT *
      FROM cust_order_line_address_tab
      WHERE order_no = old_order_no_
      AND line_no = old_line_no_
      AND rel_no = old_rel_no_
      AND line_item_no = old_line_item_no_;
BEGIN
   old_col_rec_ := Get_Object_By_Keys___(old_order_no_, old_line_no_, old_rel_no_, old_line_item_no_);

   IF (new_buy_qty_due_ > (old_col_rec_.qty_shipped / old_col_rec_.conv_factor * old_col_rec_.inverted_conv_factor)) THEN
      Error_SYS.Record_General(lu_name_, 'RCODELIVQTY: Quantity to replace cannot be greater than the delivered quantity.');
   END IF;

   order_rec_ := Customer_Order_API.Get(new_order_no_);

   Client_SYS.Set_Item_Value('ORDER_NO', new_order_no_, attr_);
   Client_SYS.Set_Item_Value('CONTRACT', order_rec_.contract, attr_);
   Client_SYS.Set_Item_Value('WANTED_DELIVERY_DATE', order_rec_.wanted_delivery_date, attr_);
   Client_SYS.Set_Item_Value('RENTAL_DB', Fnd_Boolean_API.DB_TRUE, attr_);
   Client_SYS.Set_Item_Value('DELIVER_TO_CUSTOMER_NO', old_col_rec_.deliver_to_customer_no, attr_);
   Client_SYS.Set_Item_Value('PRICE_CONV_FACTOR', 0, attr_);
   Client_SYS.Set_Item_Value('QTY_ASSIGNED', 0, attr_);

   -- Assign old order line values to attr.
   Copy_Customer_Order_Line(attr_, old_order_no_, old_line_no_, old_rel_no_, old_line_item_no_);

   -- IF the customer order has been released the promised delivery date should also be copied
   order_objstate_ := CUSTOMER_ORDER_API.Get_Objstate(old_order_no_);

   IF (order_objstate_ = 'Planned') THEN
      Client_SYS.Set_Item_Value('PROMISED_DELIVERY_DATE', '', attr_);
   END IF;

   Client_SYS.Set_Item_Value('BUY_QTY_DUE', new_buy_qty_due_, attr_);
   Client_SYS.Set_Item_Value('DESIRED_QTY', new_buy_qty_due_, attr_);
   Client_SYS.Set_Item_Value('DEMAND_CODE_DB', Order_Supply_Type_API.DB_REPLACEMENT_CUSTOMER_ORDER, attr_);
   Client_SYS.Set_Item_Value('SUPPLY_CODE', Sales_Part_API.Get_Default_Supply_Code(old_col_rec_.contract, old_col_rec_.catalog_no, Fnd_Boolean_API.DB_TRUE), attr_);
   Client_SYS.Set_Item_Value('SALES_UNIT_MEAS', old_col_rec_.sales_unit_meas, attr_);
   Client_SYS.Set_Item_Value('BASE_SALE_UNIT_PRICE', old_col_rec_.base_sale_unit_price, attr_);
   Client_SYS.Set_Item_Value('BASE_UNIT_PRICE_INCL_TAX', old_col_rec_.base_unit_price_incl_tax, attr_);
   Client_SYS.Set_Item_Value('CATALOG_TYPE_DB', old_col_rec_.catalog_type, attr_);
   Client_SYS.Set_Item_Value('PART_PRICE', old_col_rec_.part_price, attr_);
   Client_SYS.Set_Item_Value('PRICE_SOURCE_DB', old_col_rec_.price_source, attr_);
   Client_SYS.Set_Item_Value('CURRENCY_RATE', old_col_rec_.currency_rate, attr_);
   Client_SYS.Set_Item_Value('PURCHASE_PART_NO', old_col_rec_.purchase_part_no, attr_);
   Client_SYS.Set_Item_Value('SELF_BILLING_DB', Self_Billing_Type_API.DB_NOT_SELF_BILLING, attr_);
   Client_SYS.Set_Item_Value('REVISED_QTY_DUE', (new_buy_qty_due_ * old_col_rec_.conv_factor / old_col_rec_.inverted_conv_factor), attr_);
   Client_SYS.Set_Item_Value('DEMAND_ORDER_REF1', '', attr_);
   Client_SYS.Set_Item_Value('DEMAND_ORDER_REF2', '', attr_);
   Client_SYS.Set_Item_Value('DEMAND_ORDER_REF3', '', attr_);
   Client_SYS.Set_Item_Value('DEMAND_ORDER_REF4', '', attr_);
   Client_SYS.Set_Item_Value('ORIGINATING_REL_NO', '', attr_);
   Client_SYS.Set_Item_Value('ORIGINATING_LINE_ITEM_NO', '', attr_);
   Client_SYS.Set_Item_Value('ACTIVITY_SEQ', old_col_rec_.activity_seq, attr_);
   Client_SYS.Set_Item_Value('NOTE_TEXT', '', attr_);
   Client_SYS.Set_Item_Value('NOTE_ID', '', attr_);
   Client_SYS.Set_Item_Value('COST', 0, attr_);
   -- Copy the rental attributes to attr_
   ptr_ := NULL;
   WHILE (Client_SYS.Get_Next_From_Attr(rental_attr_, ptr_, name_, value_)) LOOP
      Client_SYS.Set_Item_Value(name_, value_, attr_);
   END LOOP;

   --Start rental date defaults to wanted delivery date.
   Client_SYS.Set_Item_Value('PLANNED_RENTAL_START_DATE', order_rec_.wanted_delivery_date, attr_);
   Client_SYS.Set_Item_Value('PLANNED_RENTAL_START_TIME', order_rec_.wanted_delivery_date, attr_);

   planned_rental_end_date_ := Client_SYS.Attr_Value_To_Date(Client_SYS.Get_Item_Value('PLANNED_RENTAL_END_DATE', rental_attr_));
   planned_rental_end_time_ := Client_SYS.Attr_Value_To_Date(Client_SYS.Get_Item_Value('PLANNED_RENTAL_END_TIME', rental_attr_));
   -- Combine date and timestamps
   planned_rental_end_date_ := planned_rental_end_date_ + (planned_rental_end_time_ - TRUNC(planned_rental_end_time_));
   -- Set end date/time equal to start date/time if earlier than the start date/time.
   IF (planned_rental_end_date_ < order_rec_.wanted_delivery_date) THEN
      Client_SYS.Set_Item_Value('PLANNED_RENTAL_END_DATE', order_rec_.wanted_delivery_date, attr_);
      Client_SYS.Set_Item_Value('PLANNED_RENTAL_END_TIME', order_rec_.wanted_delivery_date, attr_);
   END IF;

   Unpack___(newrec_, indrec_, attr_);
   Check_Insert___(newrec_, indrec_, attr_);
   Insert___(objid_, objversion_, newrec_, attr_);

   --Update the line address if the original line has a custom address.
   addr_flag_db_ := Customer_Order_Line_API.Get_Addr_Flag(old_order_no_, old_line_no_, old_rel_no_, old_line_item_no_);
   IF addr_flag_db_ = Gen_Yes_No_API.DB_YES THEN
      --Copy the original address
      OPEN get_ord_line_addr;
      FETCH get_ord_line_addr INTO addr_rec_;
      CLOSE get_ord_line_addr;
      Client_Sys.Clear_Attr(addr_attr_);
      Client_SYS.Add_To_Attr('ADDR_FLAG_DB', addr_flag_db_, addr_attr_);
      Client_SYS.Add_To_Attr('ADDR_1', addr_rec_.addr_1, addr_attr_);
      Client_SYS.Add_To_Attr('COUNTRY_CODE', addr_rec_.country_code, addr_attr_);
      Client_SYS.Add_To_Attr('ADDRESS1', addr_rec_.address1, addr_attr_);
      Client_SYS.Add_To_Attr('ADDRESS2', addr_rec_.address2, addr_attr_);
      Client_SYS.Add_To_Attr('ZIP_CODE', addr_rec_.zip_code, addr_attr_);
      Client_SYS.Add_To_Attr('CITY', addr_rec_.city, addr_attr_);
      Client_SYS.Add_To_Attr('STATE', addr_rec_.state, addr_attr_);
      Client_SYS.Add_To_Attr('COUNTY', addr_rec_.county, addr_attr_);
      Client_SYS.Add_To_Attr('IN_CITY', addr_rec_.in_city, addr_attr_);
      Client_SYS.Add_To_Attr('COMPANY', addr_rec_.company, addr_attr_);
      Cust_Order_Line_Address_API.Change_Address(addr_attr_,
                                                 newrec_.order_no,
                                                 newrec_.line_no,
                                                 newrec_.rel_no,
                                                 newrec_.line_item_no);
   END IF;
END New_Rental_Replacement_Line;


-- Get_Primary_Rental_No
--    Returns the primary rental_no for a customer order rental line.
@UncheckedAccess
FUNCTION Get_Primary_Rental_No (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   primary_rental_no_    NUMBER := NULL;
BEGIN
   IF (Get_Rental_Db(order_no_, line_no_, rel_no_, line_item_no_) = Fnd_Boolean_API.DB_TRUE) THEN
      $IF Component_Rental_SYS.INSTALLED $THEN
         primary_rental_no_ := Rental_Object_API.Get_Primary_Rental_No(Rental_Object_API.Get_Rental_No(order_no_,
                                                                                                     line_no_,
                                                                                                     rel_no_,
                                                                                                     line_item_no_,
                                                                                                     Rental_Type_API.DB_CUSTOMER_ORDER));
      $ELSE
         NULL;
      $END
   END IF;
   RETURN primary_rental_no_;
END Get_Primary_Rental_No;

-- Set_Rental_Completed
--    This will complete the rental and closed the order.
PROCEDURE Set_Rental_Completed (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER)
IS
   attr_       VARCHAR2(32000);
   info_       VARCHAR2(32000);
   rec_        CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_      VARCHAR2(2000);
   objversion_ VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   Set_Rental_Completed__(info_, objid_, objversion_, attr_, 'DO');
END Set_Rental_Completed;

-- Set_Rental_Reopened
--    This will reopen the rental order line for invoicing.
PROCEDURE Set_Rental_Reopened (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER)
IS
   attr_       VARCHAR2(32000);
   info_       VARCHAR2(32000);
   rec_        CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_      VARCHAR2(2000);
   objversion_ VARCHAR2(2000);
BEGIN
   Client_SYS.Clear_Attr(attr_);
   rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   Set_Rental_Reopened__(info_, objid_, objversion_, attr_, 'DO');
END Set_Rental_Reopened;

-- Set_Uninvoiced
--    This will un-invoice the order line
PROCEDURE Set_Uninvoiced (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   qty_invoiced_ IN NUMBER )
IS
   attr_             VARCHAR2(32000);
   info_             VARCHAR2(32000);
   rec_              CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_            VARCHAR2(2000);
   objversion_       VARCHAR2(2000);
   invoice_exists_   BOOLEAN := FALSE;
BEGIN
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('QTY_INVOICED', qty_invoiced_, attr_);
   rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   IF (rec_.rowstate != 'Cancelled' ) THEN
      IF ((NVL(rec_.qty_invoiced, 0) != 0)) THEN
         invoice_exists_ := TRUE;
      ELSIF (rec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
         $IF (Component_Rental_SYS.INSTALLED) $THEN
            invoice_exists_ := Rental_Transaction_API.Invoiced_Transactions_Exist(rec_.order_no, rec_.line_no, rec_.rel_no, rec_.line_item_no, Rental_Type_API.DB_CUSTOMER_ORDER);
         $ELSE
            invoice_exists_ := FALSE;
         $END
      END IF;
   END IF;
   
   IF (invoice_exists_ ) THEN
      Set_Uninvoiced__(info_, objid_, objversion_, attr_, 'DO');
   END IF;
   IF (rec_.rowstate != Get_Objstate(order_no_, line_no_, rel_no_, line_item_no_)) THEN
      Customer_Order_Line_Hist_API.New(order_no_, line_no_, rel_no_, line_item_no_);
   END IF;
END Set_Uninvoiced;


-- Undo_Delivery
--   This will undo the delivery and reverting state back to the 'Picked'.
PROCEDURE Undo_Delivery (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   deliv_no_     IN NUMBER)
IS
   attr_          VARCHAR2(32000);
   info_          VARCHAR2(32000);
   rec_           CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   objid_         VARCHAR2(2000);
   objversion_    VARCHAR2(2000);
   msg_           VARCHAR2(200);
   new_state_     CUSTOMER_ORDER_LINE_TAB.rowstate%TYPE;
   catalog_type_  SALES_PART_TAB.catalog_type%TYPE;
BEGIN
   Client_SYS.Clear_Attr(attr_); 
   Client_SYS.Add_To_Attr('DELIV_NO', deliv_no_, attr_);
   
   rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   Undo_Delivery__(info_, objid_, objversion_, attr_, 'DO');
   new_state_ := Get_Objstate(order_no_, line_no_, rel_no_, line_item_no_);   
   catalog_type_ := Sales_Part_API.Get_Catalog_Type_Db(rec_.contract, rec_.catalog_no);
   
   IF (catalog_type_ = 'NON') THEN 
      IF (new_state_ = 'Released' AND (rec_.rowstate IN ('Delivered' , 'PartiallyDelivered'))) THEN
         -- Added message saying 0 delivered.
         msg_ := Language_SYS.Translate_Constant(lu_name_, 'UNDODELIVERY: Undo customer order line delivery :P1', NULL, deliv_no_);
         Customer_Order_Line_Hist_API.New(order_no_, line_no_, rel_no_, line_item_no_, msg_);
      END IF;
   ELSIF ((new_state_ IN ('PartiallyDelivered', 'Picked')) AND (rec_.rowstate IN ('Delivered', 'PartiallyDelivered', 'Invoiced'))) 
         OR (new_state_ = rec_.rowstate AND line_item_no_ > 0) THEN
      IF (line_item_no_ >= 0) THEN
         -- Added message saying 0 delivered.
         msg_ := Language_SYS.Translate_Constant(lu_name_, 'UNDODELIVERY: Undo customer order line delivery :P1', NULL, deliv_no_);
         Customer_Order_Line_Hist_API.New(order_no_, line_no_, rel_no_, line_item_no_, msg_);
         IF line_item_no_ > 0 THEN
            Customer_Order_Line_Hist_API.New(order_no_, line_no_, rel_no_, -1, msg_);
         END IF;
      END IF;
   END IF;
END Undo_Delivery;

-- Get_Rental_Chargeable_Days
--   This method calculates and return rental chargeable days
--   for given rental references.
@UncheckedAccess
FUNCTION Get_Rental_Chargeable_Days (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER,
   rental_db_    IN VARCHAR2 DEFAULT NULL) RETURN NUMBER
IS
   rental_chargeable_days_ NUMBER;
   rental_db_value_        VARCHAR2(20);
BEGIN
   rental_db_value_ := NVL(rental_db_, Get_Rental_Db(order_no_, line_no_, rel_no_, line_item_no_));
   IF ( rental_db_value_ = Fnd_Boolean_API.DB_FALSE) THEN
      rental_chargeable_days_ := 1;
   ELSE
      rental_chargeable_days_ := Get_Rental_Chargeable_Days___(order_no_, line_no_, rel_no_, line_item_no_);
   END IF;
   RETURN NVL(rental_chargeable_days_,1);
END Get_Rental_Chargeable_Days;

-- Get_Planned_Rental_Start_Dt___
--   This method returns planned rental start date
--   using the rental attribute values.
@UncheckedAccess
FUNCTION Get_Planned_Rental_Start_Dt___ (
   attr_        IN  VARCHAR2,
   newrec_      IN  CUSTOMER_ORDER_LINE_TAB%ROWTYPE) RETURN DATE
IS
   planned_rental_start_date_ DATE := NULL;
BEGIN
   $IF Component_Rental_SYS.INSTALLED $THEN
      planned_rental_start_date_ := Rental_Object_API.Get_Planned_Rental_Start_Dt(newrec_.order_no,
                                                                                  newrec_.line_no,
                                                                                  newrec_.rel_no,
                                                                                  newrec_.line_item_no,
                                                                                  Rental_Type_API.DB_CUSTOMER_ORDER,
                                                                                  attr_);
   $END
   RETURN planned_rental_start_date_;
END Get_Planned_Rental_Start_Dt___;

----------------------------------------------------------------
-- Is_Expctr_Connected
--   Returns true if a line with export license connected exist.
----------------------------------------------------------------
@UncheckedAccess
FUNCTION Is_Expctr_Connected(
   order_no_         IN VARCHAR2,
   line_no_          IN VARCHAR2,
   rel_no_           IN VARCHAR2,
   line_item_no_     IN NUMBER) RETURN VARCHAR2
IS
   connection_exist_    VARCHAR2(5) := 'FALSE';
   co_line_rec_         Customer_Order_Line_API.Public_Rec;
   licensed_order_type_ VARCHAR2(25);
BEGIN
   $IF Component_Expctr_SYS.INSTALLED $THEN
      IF (Customer_Order_Flow_API.Get_License_Enabled(order_no_, 'INTERACT_CUST_ORD') = 'TRUE') THEN
         co_line_rec_ := Get(order_no_, line_no_, rel_no_, line_item_no_);
         licensed_order_type_ := Customer_Order_Line_API.Get_Expctr_License_Order_Type(co_line_rec_.demand_code, co_line_rec_.demand_order_ref1, co_line_rec_.demand_order_ref2, co_line_rec_.demand_order_ref3);
		 connection_exist_ := Exp_License_Connect_Util_API.Is_Expctr_Connected(order_no_, line_no_, rel_no_, line_item_no_, licensed_order_type_);
      END IF;
   $ELSE
      NULL;
   $END
   RETURN connection_exist_;
END Is_Expctr_Connected;

-- Rental_Period_Exists
--   Returns TRUE if the customer order rental line exist any rental events.
--   FALSE otherwise.
@UncheckedAccess
FUNCTION Rental_Period_Exists (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN BOOLEAN
IS
   rental_period_exists_ BOOLEAN := FALSE;
BEGIN
   IF (Get_Rental_Db(order_no_, line_no_, rel_no_, line_item_no_) = Fnd_Boolean_API.DB_TRUE) THEN
      $IF Component_Rental_SYS.INSTALLED $THEN
         rental_period_exists_ := Rental_Object_Manager_API.Rental_Period_Exists(order_no_,
                                                                                 line_no_,
                                                                                 rel_no_,
                                                                                 line_item_no_,
                                                                                 Rental_Type_API.DB_CUSTOMER_ORDER);
      $ELSE
         NULL;
      $END
   END IF;
   RETURN rental_period_exists_;
END Rental_Period_Exists;


@UncheckedAccess
FUNCTION Get_Dop_Id_From_Ext_Cust_Info (
   order_no_           IN  VARCHAR2,
   line_no_            IN  VARCHAR2,
   rel_no_             IN  VARCHAR2,
   line_item_no_       IN  NUMBER) RETURN NUMBER
IS
   po_order_no_	       VARCHAR2(12);
   po_line_no_           VARCHAR2(4);
   po_release_no_        VARCHAR2(4);
   purchase_type_        VARCHAR2(30);
   ico_ord_no_           VARCHAR2(12);
   ico_line_no_          VARCHAR2(4);
   ico_rel_no_           VARCHAR2(4);
   ico_line_item_no_     NUMBER;
   demand_code_db_       CUSTOMER_ORDER_LINE_TAB.demand_code%TYPE;
   dop_id_               VARCHAR2(12) := 0;
BEGIN
   Customer_Order_Pur_Order_API.Get_Purord_For_Custord(po_order_no_, po_line_no_, po_release_no_, purchase_type_, order_no_, line_no_, rel_no_, line_item_no_);
   demand_code_db_ := Order_Supply_Type_API.Encode(Get_Supply_Code(order_no_, line_no_, rel_no_, line_item_no_));
   Get_Custord_From_Demand_Info(ico_ord_no_, ico_line_no_, ico_rel_no_, ico_line_item_no_, po_order_no_, po_line_no_, po_release_no_, null, demand_code_db_);
   RETURN dop_id_;
END Get_Dop_Id_From_Ext_Cust_Info;


----------------------------------------------------------------
--  Get_Order_Line_Contribution
--    This method is used to get the contribution margin of the
--  customer order line.
----------------------------------------------------------------
@UncheckedAccess
FUNCTION Get_Order_Line_Contribution (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER    ) RETURN NUMBER
IS
   line_cost_      NUMBER;
   company_        VARCHAR2(20);
   rounding_       NUMBER;
   contribution_   NUMBER;

   CURSOR get_cost IS
      SELECT ROUND((cost * buy_qty_due * conv_factor / inverted_conv_factor), rounding_)
      FROM  CUSTOMER_ORDER_LINE_TAB
      WHERE rowstate != 'Cancelled'
      AND   line_item_no <= 0
      AND   order_no = order_no_
      AND   line_no = line_no_
      AND   rel_no = rel_no_
      AND   line_item_no = line_item_no_;
BEGIN
   company_  := Site_API.Get_Company(Get_Contract(order_no_, line_no_, rel_no_, line_item_no_));
   rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, Company_Finance_API.Get_Currency_Code(company_));

   OPEN get_cost;
   FETCH get_cost INTO line_cost_;
   IF (get_cost%NOTFOUND) THEN
      line_cost_ := 0;
   END IF;
   CLOSE get_cost;

   contribution_ := Get_Base_Sale_Price_Total(order_no_, line_no_, rel_no_, line_item_no_) - line_cost_;
   RETURN contribution_;
END Get_Order_Line_Contribution;

-----------------------------------------------------------------------------------------------------------------------------
--  Get_Expctr_License_Order_Type
--    This method will return license_order_type of the customer order line specified.
--    If the customer order line is connected to an external service order the license_order_type is ESO_CUSTOMER_ORDER.
-----------------------------------------------------------------------------------------------------------------------------
@UncheckedAccess
FUNCTION Get_Expctr_License_Order_Type (
   demand_code_     IN VARCHAR2,
   demand_ref1_     IN VARCHAR2,
   demand_ref2_     IN VARCHAR2,
   demand_ref3_     IN VARCHAR2 ) RETURN VARCHAR2 
IS  
   order_code_         VARCHAR2(3);
   license_order_type_ VARCHAR2(25) := 'CUSTOMER_ORDER';
BEGIN
   $IF (Component_Purch_SYS.INSTALLED)$THEN
      IF (NVL(demand_code_, Database_SYS.string_null_) = 'PO') THEN
         order_code_ := Purchase_Order_Line_Part_API.Get_Order_Code(demand_ref1_, demand_ref2_, demand_ref3_);
         IF order_code_ = 6 THEN 
            license_order_type_ := 'ESO_CUSTOMER_ORDER';
         END IF;
      END IF;
   $END
   RETURN license_order_type_;
END Get_Expctr_License_Order_Type;

@UncheckedAccess
FUNCTION Get_Demand_Contract (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN VARCHAR2
IS
   linerec_             CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   customer_contract_   CUSTOMER_ORDER_LINE_TAB.contract%TYPE;
BEGIN
   linerec_           := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   customer_contract_ := Cust_Ord_Customer_API.Get_Acquisition_Site(linerec_.customer_no);
   IF (customer_contract_ IS NOT NULL) THEN
      $IF (Component_Purch_SYS.INSTALLED) $THEN
         customer_contract_ := Purchase_Order_Line_Part_API.Get_Contract(linerec_.demand_order_ref1,
                                                                         linerec_.demand_order_ref2,
                                                                         linerec_.demand_order_ref3);
      $ELSE
         NULL;
      $END
   END IF;
   RETURN customer_contract_;
END Get_Demand_Contract;

@UncheckedAccess
FUNCTION Get_Total_Qty_Returned (
   demand_order_ref1_ IN VARCHAR2 ) RETURN NUMBER 
IS
   total_qty_returned_ NUMBER;

   CURSOR get_total_qty IS 
      SELECT SUM(qty_returned)
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE demand_order_ref1 = demand_order_ref1_;
BEGIN
   OPEN get_total_qty;
   FETCH get_total_qty INTO total_qty_returned_;
   CLOSE get_total_qty;
   
   RETURN total_qty_returned_;
END Get_Total_Qty_Returned;

@UncheckedAccess
FUNCTION Get_Total_Qty_Shipped (
   demand_order_ref1_ IN VARCHAR2 ) RETURN NUMBER 
IS
   total_qty_shipped_ NUMBER;

   CURSOR get_total_qty IS 
      SELECT SUM(qty_shipped)
      FROM CUSTOMER_ORDER_LINE_TAB
      WHERE demand_order_ref1 = demand_order_ref1_;
BEGIN
   OPEN get_total_qty;
   FETCH get_total_qty INTO total_qty_shipped_;
   CLOSE get_total_qty;
   
   RETURN total_qty_shipped_;
END Get_Total_Qty_Shipped;

@UncheckedAccess
FUNCTION Rental_Is_Completed  (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN BOOLEAN
IS
   linerec_       CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
BEGIN
   linerec_           := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   RETURN Rental_Is_Completed___(linerec_);
END Rental_Is_Completed;

-- Get_Rental_Line_Total
--   Calculates base/curr net_amount and gross_amount according to the use_price_incl_tax_ value.
@UncheckedAccess
PROCEDURE Get_Rental_Line_Total (
   net_base_amount_   OUT    NUMBER,
   gross_base_amount_ OUT    NUMBER,
   net_curr_amount_   IN OUT NUMBER,
   gross_curr_amount_ IN OUT NUMBER,   
   order_no_          IN     VARCHAR2,
   line_no_           IN     VARCHAR2,
   rel_no_            IN     VARCHAR2,
   line_item_no_      IN     NUMBER )
IS
   order_rec_              CUSTOMER_ORDER_API.Public_Rec;
   tax_line_param_rec_     Tax_Handling_Order_Util_API.tax_line_param_rec;
   company_                VARCHAR2(20);
   line_tax_dom_amount_    NUMBER;
   line_tax_curr_amount_   NUMBER;
BEGIN
   order_rec_          := Customer_Order_API.Get(order_no_);
   company_            := Site_API.Get_Company(order_rec_.contract);
   tax_line_param_rec_ := Fetch_Tax_Line_Param(company_, order_no_, line_no_, rel_no_, line_item_no_);
          
   Tax_Handling_Order_Util_API.Get_Amounts(line_tax_dom_amount_,
                                           net_base_amount_,
                                           gross_base_amount_,
                                           line_tax_curr_amount_,
                                           net_curr_amount_,
                                           gross_curr_amount_,
                                           tax_line_param_rec_.tax_calc_structure_id,
                                           order_no_,
                                           line_no_,
                                           rel_no_,
                                           line_item_no_,
                                           '*',
                                           Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                           tax_line_param_rec_.company,
                                           tax_line_param_rec_.contract,
                                           tax_line_param_rec_.customer_no,
                                           tax_line_param_rec_.ship_addr_no,
                                           tax_line_param_rec_.planned_ship_date,
                                           tax_line_param_rec_.supply_country_db,
                                           tax_line_param_rec_.delivery_type,
                                           tax_line_param_rec_.object_id,
                                           order_rec_.use_price_incl_tax,
                                           tax_line_param_rec_.currency_code,
                                           tax_line_param_rec_.currency_rate,   
                                           'FALSE',   
                                           tax_line_param_rec_.tax_code,
                                           tax_line_param_rec_.tax_liability,
                                           tax_line_param_rec_.tax_liability_type_db,
                                           tax_line_param_rec_.delivery_country_db,   
                                           free_of_charge_tax_basis_ => NULL,
                                           tax_from_diff_source_ => 'FALSE',
										             add_tax_curr_amount_ => 'FALSE',
                                           quantity_ => NULL,
                                           attr_ => NULL);
END Get_Rental_Line_Total;

-- Get_Backord_Value_Base_Curr
--   Return the net and gross value of NOT shipped items for this order row in
--   the base currency. The backorder value is calculated as the value of the
--   items ordered but not yet delivered.
@UncheckedAccess
PROCEDURE Get_Backord_Value_Base_Curr (
   net_amount_   OUT NUMBER,
   gross_amount_ OUT NUMBER,
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER )
IS
BEGIN
   Get_Backord_Value_Base_Curr___(net_amount_, gross_amount_, order_no_, line_no_, rel_no_, line_item_no_ );
END Get_Backord_Value_Base_Curr;

-- Get_Backlog_Value_Base_Curr
--   Return the net and gross value of NOT invoiced items for this order row in
--   the base currency. The backlog value is calculated as the value of
--   the items ordered but not yet invoiced.
@UncheckedAccess
PROCEDURE Get_Backlog_Value_Base_Curr (
   net_amount_   OUT NUMBER,
   gross_amount_ OUT NUMBER,
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER )
IS
BEGIN
   Get_Backlog_Value_Base_Curr___(net_amount_, gross_amount_, order_no_, line_no_, rel_no_, line_item_no_);
END Get_Backlog_Value_Base_Curr;


PROCEDURE Modify_Country_Code (
   order_no_         IN VARCHAR2,
   line_no_          IN VARCHAR2,
   rel_no_           IN VARCHAR2,
   line_item_no_     IN NUMBER,
   country_code_     IN VARCHAR2)
IS   
   attr_  VARCHAR2(2000);
BEGIN   
   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr('COUNTRY_CODE', country_code_, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Country_Code;

--   *** This method is dynamically called from Tax_Handling_Order_Util_API. ***
@UncheckedAccess
PROCEDURE Get_Tax_Info (
   attr_          OUT VARCHAR2,
   order_no_      IN  VARCHAR2,
   line_no_       IN  VARCHAR2,
   rel_no_        IN  VARCHAR2,
   line_item_no_  IN  NUMBER)
IS
   linerec_                CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   tax_liability_type_db_  VARCHAR2(20);
   tax_paying_party_       VARCHAR2(20);
   header_rec_             CUSTOMER_ORDER_API.Public_Rec;
BEGIN
   linerec_  := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   header_rec_ := Customer_Order_API.Get(order_no_);
   
   Client_SYS.Set_Item_Value('TAX_CODE', linerec_.tax_code, attr_);
   Client_SYS.Set_Item_Value('TAX_CLASS_ID', linerec_.tax_class_id, attr_);
   Client_SYS.Set_Item_Value('TAX_LIABILITY', linerec_.tax_liability, attr_);
   IF (Order_Supply_Type_API.Encode(linerec_.demand_code) = 'IPD') THEN
      tax_liability_type_db_ := External_Cust_Order_Line_API.Get_Tax_Liability(order_no_, line_no_, rel_no_);
   ELSE
      tax_liability_type_db_ := linerec_.tax_liability_type;
   END IF;
   Client_SYS.Set_Item_Value('TAX_LIABILITY_TYPE_DB', tax_liability_type_db_, attr_);   
   Client_SYS.Set_Item_Value('IS_TAXABLE_DB', Sales_Part_API.Get_Taxable_Db(linerec_.contract, linerec_.catalog_no), attr_);
   Client_SYS.Set_Item_Value('TAX_LIABILITY_DATE', NVL(linerec_.planned_ship_date, TRUNC(Site_API.Get_Site_Date(linerec_.contract))), attr_);
   Client_SYS.Set_Item_Value('SHIP_ADDR_NO', linerec_.ship_addr_no, attr_);
   Client_SYS.Set_Item_Value('PLANNED_SHIP_DATE', linerec_.planned_ship_date, attr_);
   Client_SYS.Set_Item_Value('SUPPLY_COUNTRY_DB', header_rec_.supply_country, attr_);
   Client_SYS.Set_Item_Value('DELIVERY_TYPE', linerec_.delivery_type, attr_);
   IF order_no_ IS NOT NULL AND line_no_ IS NULL THEN
      Client_SYS.Set_Item_Value('DELIVERY_COUNTRY_DB', Customer_Order_Address_API.Get_Country_Code(order_no_), attr_);
   ELSE
      Client_SYS.Set_Item_Value('DELIVERY_COUNTRY_DB', Cust_Order_Line_Address_API.Get_Country_Code(order_no_, line_no_, rel_no_, line_item_no_), attr_);
   END IF;

   IF (linerec_.free_of_charge = Fnd_Boolean_API.DB_TRUE) THEN
      Client_SYS.Set_Item_Value('FREE_OF_CHARGE', linerec_.free_of_charge, attr_);
      Client_SYS.Set_Item_Value('FREE_OF_CHARGE_TAX_BASIS', linerec_.free_of_charge_tax_basis, attr_);
      tax_paying_party_ := header_rec_.free_of_chg_tax_pay_party;
      Client_SYS.Set_Item_Value('FREE_OF_CHG_TAX_PAY_PARTY', tax_paying_party_, attr_);
   END IF;
END Get_Tax_Info;


--   *** This method is dynamically called from Tax_Handling_Order_Util_API. ***
@UncheckedAccess
PROCEDURE Get_External_Tax_Info (
   attr_          OUT VARCHAR2,
   source_ref1_   IN VARCHAR2,
   source_ref2_   IN VARCHAR2,
   source_ref3_   IN VARCHAR2,
   source_ref4_   IN VARCHAR2,
   company_       IN VARCHAR2)
IS
   linerec_    CUSTOMER_ORDER_LINE_TAB%ROWTYPE;   
BEGIN
   linerec_  := Get_Object_By_Keys___(source_ref1_, source_ref2_, source_ref3_, source_ref4_);   
   Client_SYS.Set_Item_Value('QUANTITY', linerec_.buy_qty_due, attr_);

   -- gelr:br_external_tax_integration, begin
   IF Company_Tax_Control_API.Get_External_Tax_Cal_Method_Db(company_) = External_Tax_Calc_Method_API.DB_AVALARA_TAX_BRAZIL THEN
      Client_SYS.Set_Item_Value('SHIP_ADDR_NO',            linerec_.ship_addr_no,           attr_);
      Client_SYS.Set_Item_Value('DOC_ADDR_NO',             Customer_Order_API.Get_Bill_Addr_No(source_ref1_), attr_);
      Client_SYS.Set_Item_Value('DOCUMENT_CODE',           source_ref1_,                    attr_);
      Client_SYS.Set_Item_Value('CATALOG_NO',              linerec_.catalog_no,             attr_);
      Client_SYS.Set_Item_Value('SALE_UNIT_PRICE',         linerec_.sale_unit_price,        attr_);
      --Client_SYS.Set_Item_Value('LINE_TAXED_DISCOUNT',     Cust_Order_Line_Discount_API.Get_Total_Line_Discount__(source_ref1_, source_ref2_, source_ref3_, source_ref4_, linerec_.buy_qty_due, linerec_.price_conv_factor), attr_);
      Client_SYS.Set_Item_Value('EXTERNAL_USE_TYPE',       Acquisition_Reason_API.Get_External_Use_Type_Db(company_, linerec_.acquisition_reason_id),  attr_);
      Client_SYS.Set_Item_Value('BUSINESS_TRANSACTION_ID', Business_Transaction_Id_API.Get_External_Tax_System_Ref(company_, Customer_Order_API.Get_Business_Transaction_Id(source_ref1_)), attr_);
      Client_SYS.Set_Item_Value('ORDER_NO',                linerec_.order_no,               attr_);
      Client_SYS.Set_Item_Value('LINE_NO',                 linerec_.line_no,                attr_);
      Client_SYS.Set_Item_Value('AVALARA_TAX_CODE',        Sales_Part_Ext_Tax_Params_API.Get_Avalara_Tax_Code(linerec_.contract, linerec_.catalog_no), attr_);
      Client_SYS.Set_Item_Value('STATISTICAL_CODE',        linerec_.statistical_code,       attr_);
      Client_SYS.Set_Item_Value('CEST_CODE',               Part_Br_Spec_Attrib_API.Get_Cest_Code(linerec_.part_no), attr_);
      Client_SYS.Set_Item_Value('SALES_UNIT_MEAS',         linerec_.sales_unit_meas,        attr_);
      Client_SYS.Set_Item_Value('ACQUISITION_ORIGIN',      linerec_.acquisition_origin,     attr_);
      Client_SYS.Set_Item_Value('PRODUCT_TYPE_CLASSIF',    Part_Br_Spec_Attrib_API.Get_Product_Type_Classif_Db(linerec_.part_no), attr_);
   END IF;
   -- gelr:br_external_tax_integration, end
END Get_External_Tax_Info;


-- Modify_Tax_Info
--   Modifies the tax information with the tax line tax information at the same time.
--   *** This method is dynamically called from Tax_Handling_Order_Util_API. ***
PROCEDURE Modify_Tax_Info (
   attr_         IN OUT VARCHAR2,
   order_no_     IN     VARCHAR2,
   line_no_      IN     VARCHAR2,
   rel_no_       IN     VARCHAR2,
   line_item_no_ IN     NUMBER )
IS
   objid_            VARCHAR2(2000);
   objversion_       VARCHAR2(2000);
   oldrec_           CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   newrec_           CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   tax_class_id_     VARCHAR2(20);
   
BEGIN
   Get_Id_Version_By_Keys___(objid_, objversion_, order_no_, line_no_, rel_no_, line_item_no_);
   oldrec_ := Lock_By_Id___(objid_, objversion_);
   newrec_ := oldrec_;
   newrec_.tax_code  := Client_Sys.Get_Item_Value('TAX_CODE', attr_);
   Client_SYS.Add_To_Attr('TAX_CODE_CHANGED', 'TRUE', attr_);
   tax_class_id_:= Client_Sys.Get_Item_Value('TAX_CLASS_ID', attr_);    
   IF (oldrec_.tax_code = newrec_.tax_code) AND (newrec_.tax_code IS NOT NULL AND oldrec_.tax_code IS NOT NULL) 
      AND (tax_class_id_ IS NULL) THEN
      --Assign to oldrec_.tax_class_id to prevent overriding when set default tax information.
      newrec_.tax_class_id := oldrec_.tax_class_id;
   ELSE
      newrec_.tax_class_id := tax_class_id_;
   END IF;
   newrec_.tax_calc_structure_id  := Client_Sys.Get_Item_Value('TAX_CALC_STRUCTURE_ID', attr_);
   Update___(objid_, oldrec_, newrec_, attr_, objversion_);

END Modify_Tax_Info;

--   *** This method is dynamically called from Tax_Handling_Order_Util_API. ***
@UncheckedAccess
PROCEDURE Validate_Source_Pkg_Info (
   source_ref1_  IN VARCHAR2,
   source_ref2_  IN VARCHAR2,
   source_ref3_  IN VARCHAR2,
   source_ref4_  IN VARCHAR2,
   attr_         IN VARCHAR2)
IS
   header_rec_              Customer_Order_API.Public_Rec;
   do_additional_validate_  VARCHAR2(5):= 'FALSE';
BEGIN
   IF (Get_Objstate(source_ref1_, source_ref2_, source_ref3_, source_ref4_) IN ('Invoiced', 'Cancelled')) THEN
      Error_SYS.Record_General(lu_name_, 'INVOICED_LINE: Tax lines cannot be altered when the charge line has been Cancelled or Invoiced/Closed.');
   END IF;
   
   do_additional_validate_ := nvl(Client_SYS.Get_Item_Value('DO_ADDITIONAL_VALIDATE', attr_),'TRUE');
   
   IF (do_additional_validate_ = 'TRUE') THEN
      IF Sales_Promotion_Util_API.Check_Promo_Exist_For_Ord_Line(source_ref1_, source_ref2_, source_ref3_, source_ref4_) THEN
         Error_SYS.Record_General(lu_name_, 'NOMODIFYTAXLINESPROMO: You are not allowed to modify the tax information unless sales promotion calculations have been cleared.');
      END IF;
      
      header_rec_ := Customer_Order_API.Get(source_ref1_); 
      IF header_rec_.proposed_prepayment_amount > 0 AND 
         Source_Tax_Item_API.Multiple_Tax_Items_Exist(Site_API.Get_Company(header_rec_.contract),
                                                      Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                                      source_ref1_,
                                                      source_ref2_,
                                                      source_ref3_,
                                                      source_ref4_,
                                                      '*') = 'TRUE' THEN
         Error_SYS.Record_General(lu_name_, 'PREPAYINVMULTITAX: Multiple tax codes may not be added when a prepayment based invoice is connected to a customer order.');
      END IF;
   END IF;
END Validate_Source_Pkg_Info;

--   *** This method is dynamically called from Tax_Handling_Order_Util_API. ***
@UncheckedAccess
FUNCTION Fetch_Tax_Line_Param(   
   company_                IN VARCHAR2,
   source_ref1_            IN VARCHAR2,
   source_ref2_            IN VARCHAR2,
   source_ref3_            IN VARCHAR2,
   source_ref4_            IN VARCHAR2) RETURN Tax_Handling_Order_Util_API.tax_line_param_rec
IS
   order_rec_           Customer_Order_API.Public_Rec;
   order_line_rec_      Customer_Order_Line_API.Public_Rec;
   tax_line_param_rec_  Tax_Handling_Order_Util_API.tax_line_param_rec;
   tax_liability_type_db_ VARCHAR2(20);
BEGIN
   order_rec_          := Customer_Order_API.Get(source_ref1_);
   order_line_rec_     := Customer_Order_Line_API.Get(source_ref1_, source_ref2_, source_ref3_, source_ref4_);
      
   tax_line_param_rec_.company                  := company_;
   tax_line_param_rec_.contract                 := order_rec_.contract;
   tax_line_param_rec_.customer_no              := order_rec_.customer_no;
   tax_line_param_rec_.ship_addr_no             := order_line_rec_.ship_addr_no;
   tax_line_param_rec_.planned_ship_date        := order_line_rec_.planned_ship_date;
   tax_line_param_rec_.supply_country_db        := order_rec_.supply_country;
   tax_line_param_rec_.delivery_type            := NVL(order_line_rec_.delivery_type, '*');
   tax_line_param_rec_.object_id                := order_line_rec_.catalog_no;
   tax_line_param_rec_.use_price_incl_tax       := order_rec_.use_price_incl_tax;
   tax_line_param_rec_.currency_code            := order_rec_.currency_code;
   tax_line_param_rec_.currency_rate            := order_line_rec_.currency_rate;
   tax_line_param_rec_.free_of_charge_tax_basis := order_line_rec_.free_of_charge_tax_basis;
   tax_line_param_rec_.tax_liability            := order_line_rec_.tax_liability;
   IF (Order_Supply_Type_API.Encode(order_line_rec_.demand_code) = 'IPD') THEN
      tax_liability_type_db_ := External_Cust_Order_Line_API.Get_Tax_Liability(source_ref1_, source_ref2_, source_ref3_);
   ELSE
      tax_liability_type_db_ := order_line_rec_.tax_liability_type;
   END IF;
   tax_line_param_rec_.tax_liability_type_db    := tax_liability_type_db_;
   tax_line_param_rec_.tax_code                 := order_line_rec_.tax_code;
   tax_line_param_rec_.tax_calc_structure_id    := order_line_rec_.tax_calc_structure_id;
   tax_line_param_rec_.tax_class_id             := order_line_rec_.tax_class_id;
   tax_line_param_rec_.taxable                  := Sales_Part_API.Get_Taxable_Db(order_rec_.contract, order_line_rec_.catalog_no);
   
   RETURN tax_line_param_rec_;   
END Fetch_Tax_Line_Param;


--   *** This method is dynamically called from Tax_Handling_Order_Util_API. ***
@UncheckedAccess
PROCEDURE Fetch_Gross_Net_Tax_Amounts(
   gross_curr_amount_      OUT NUMBER,
   net_curr_amount_        OUT NUMBER,
   tax_curr_amount_        OUT NUMBER,
   company_                IN VARCHAR2,
   source_ref1_            IN VARCHAR2,
   source_ref2_            IN VARCHAR2,
   source_ref3_            IN VARCHAR2,
   source_ref4_            IN VARCHAR2) 
IS 
BEGIN
   gross_curr_amount_  := Customer_Order_Line_API.Get_Sale_Price_Incl_Tax_Total(source_ref1_, source_ref2_, source_ref3_, source_ref4_);
   net_curr_amount_  := Customer_Order_Line_API.Get_Sale_Price_Total(source_ref1_, source_ref2_, source_ref3_, source_ref4_);
   tax_curr_amount_  := Customer_Order_Line_API.Get_Total_Tax_Amount_Curr(source_ref1_, source_ref2_, source_ref3_, source_ref4_);
END Fetch_Gross_Net_Tax_Amounts;


--   *** This method is dynamically called from Tax_Handling_Order_Util_API. ***
@UncheckedAccess
FUNCTION Get_Price_Total (
   source_ref1_   IN VARCHAR2,
   source_ref2_   IN VARCHAR2,
   source_ref3_   IN VARCHAR2,
   source_ref4_   IN VARCHAR2) RETURN NUMBER
IS
BEGIN
   RETURN Get_Sale_Price_Total(source_ref1_, source_ref2_, source_ref3_, source_ref4_);
END Get_Price_Total;

--   *** This method is dynamically called from Tax_Handling_Order_Util_API. ***
@UncheckedAccess
FUNCTION Get_Price_Incl_Tax_Total  (
   source_ref1_   IN VARCHAR2,
   source_ref2_   IN VARCHAR2,
   source_ref3_   IN VARCHAR2,
   source_ref4_   IN VARCHAR2) RETURN NUMBER
IS
BEGIN
   RETURN Get_Sale_Price_Incl_Tax_Total (source_ref1_, source_ref2_, source_ref3_, source_ref4_);
END Get_Price_Incl_Tax_Total ;


@UncheckedAccess
FUNCTION Check_Qty_To_Reserve (
   order_no_           IN VARCHAR2,
   line_no_            IN VARCHAR2,
   rel_no_             IN VARCHAR2,
   line_item_no_       IN VARCHAR2) RETURN VARCHAR2
IS
   qty_reserve_available_   VARCHAR2(5):= 'FALSE';
   dummy_                   NUMBER;
   
   CURSOR get_qty_to_reserve IS
      SELECT 1  
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no     = order_no_
      AND    line_no      = line_no_
      AND    rel_no       = rel_no_
      AND    line_item_no = line_item_no_
      AND    ((revised_qty_due - qty_assigned - qty_to_ship - qty_shipped + qty_shipdiff) > 0);
BEGIN
   OPEN get_qty_to_reserve;
   FETCH get_qty_to_reserve INTO dummy_;
   IF (get_qty_to_reserve%FOUND) THEN
      qty_reserve_available_  := 'TRUE';
   END IF;
   CLOSE get_qty_to_reserve;
   RETURN qty_reserve_available_;  
END Check_Qty_To_Reserve;


-----------------------------------------------------------------------
-- Get_Comp_Bearing_Tax_Amount
--    Returns the total tax amount (VAT or Sales Tax) for an order line
--    in base currency. This is the amount the company should bear if 
--    the company pays tax for free of charge lines.
-----------------------------------------------------------------------
@UncheckedAccess
FUNCTION Get_Comp_Bearing_Tax_Amount (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   line_rec_          CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   tax_amount_        NUMBER := 0;
   rounding_          NUMBER;
   company_           VARCHAR2(20);
   tax_paying_party_  VARCHAR2(20);   
BEGIN
   line_rec_         := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   company_          := Site_API.Get_Company(line_rec_.contract);
   rounding_         := Currency_Code_API.Get_Currency_Rounding(company_, Company_Finance_API.Get_Currency_Code(company_));
   tax_paying_party_ := Customer_Order_API.Get_Free_Of_Chg_Tax_Pay_Par_Db(order_no_);
         
   IF (line_rec_.free_of_charge = Fnd_Boolean_API.DB_TRUE AND tax_paying_party_ = Tax_Paying_Party_API.DB_COMPANY) THEN
      IF (line_rec_.tax_liability_type = 'EXM') THEN
         -- No tax paid for this order line
         tax_amount_ := 0;
      ELSE
         tax_amount_ := Source_Tax_Item_API.Get_Total_Tax_Dom_Amount(company_, 
                                                                     Tax_Source_API.DB_CUSTOMER_ORDER_LINE,
                                                                     order_no_,
                                                                     line_no_,
                                                                     rel_no_,
                                                                     TO_CHAR(line_item_no_),
                                                                     '*');         
      END IF;   
      tax_amount_ := ROUND(tax_amount_, rounding_);
   ELSE
      tax_amount_ := NULL;
   END IF;
   RETURN tax_amount_;
END Get_Comp_Bearing_Tax_Amount;


@UncheckedAccess
FUNCTION Get_Inv_Qty_To_Ship_Connect (
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   inv_qty_to_ship_connect_   NUMBER:=0;
   customer_order_line_rec_   Public_Rec;
BEGIN
   customer_order_line_rec_ := Get(order_no_, line_no_, rel_no_, line_item_no_);
   inv_qty_to_ship_connect_ := (customer_order_line_rec_.revised_qty_due - customer_order_line_rec_.qty_shipped - customer_order_line_rec_.open_shipment_qty + customer_order_line_rec_.qty_shipdiff);
   RETURN NVL(inv_qty_to_ship_connect_, 0);
END Get_Inv_Qty_To_Ship_Connect;

-- Get_Uncancelled_Pkg_Line_Count
--   Returns the number of package lines which are not cancelled.
@UncheckedAccess
FUNCTION Get_Uncancelled_Pkg_Line_Count (
   order_no_ IN VARCHAR2,
   line_no_  IN VARCHAR2,
   rel_no_   IN VARCHAR2 ) RETURN NUMBER
IS
   count_             NUMBER;

   CURSOR uncancelled IS
      SELECT COUNT(*)
      FROM   customer_order_line_tab
      WHERE  order_no = order_no_
      AND    line_no  = line_no_
      AND    rel_no   = rel_no_
      AND    line_item_no > 0
      AND    rowstate != 'Cancelled';
BEGIN
   OPEN uncancelled;
   FETCH uncancelled INTO count_;
   IF (uncancelled%NOTFOUND) THEN
      count_ := 0;
   END IF;
   CLOSE uncancelled;
   RETURN count_;
END Get_Uncancelled_Pkg_Line_Count;

-- Get_Line_Address_Info
--   Returns Customer Order line Address information.
--   *** This method is dynamically called from Tax_Handling_Order_Util_API. ***
@UncheckedAccess
PROCEDURE Get_Line_Address_Info (
   address1_      OUT VARCHAR2,
   address2_      OUT VARCHAR2,
   country_code_  OUT VARCHAR2,
   city_          OUT VARCHAR2,
   state_         OUT VARCHAR2,
   zip_code_      OUT VARCHAR2,
   county_        OUT VARCHAR2,
   in_city_       OUT VARCHAR2,
   source_ref1_   IN  VARCHAR2,
   source_ref2_   IN  VARCHAR2,
   source_ref3_   IN  VARCHAR2,
   source_ref4_   IN  VARCHAR2,
   company_       IN  VARCHAR2)
IS
   addr_rec_      Cust_Order_Line_Address_API.Co_Line_Addr_Rec;
   co_addr_rec_   Customer_Order_Address_API.Cust_Ord_Addr_Rec;
BEGIN
   IF source_ref1_ IS NOT NULL AND source_ref2_ IS NULL THEN
     co_addr_rec_   := Customer_Order_Address_API.Get_Cust_Ord_Addr(source_ref1_);
     address1_      := co_addr_rec_.address1;
     address2_      := co_addr_rec_.address2;
     country_code_  := co_addr_rec_.country_code;
     city_          := co_addr_rec_.city;
     state_         := co_addr_rec_.state;
     zip_code_      := co_addr_rec_.zip_code;
     county_        := co_addr_rec_.county;
     in_city_       := co_addr_rec_.in_city;
   ELSE
      addr_rec_      := Cust_Order_Line_Address_API.Get_Co_Line_Addr(source_ref1_, source_ref2_, source_ref3_, source_ref4_);
      address1_      := addr_rec_.address1;
      address2_      := addr_rec_.address2;
      country_code_  := addr_rec_.country_code;
      city_          := addr_rec_.city;
      state_         := addr_rec_.state;
      zip_code_      := addr_rec_.zip_code;
      county_        := addr_rec_.county;
      in_city_       := addr_rec_.in_city;
   END IF;
END Get_Line_Address_Info;


PROCEDURE Get_Info_For_Desadv (
   receiver_source_ref1_           OUT VARCHAR2,
   receiver_source_ref2_           OUT VARCHAR2,
   receiver_source_ref3_           OUT VARCHAR2,
   receiver_source_ref_type_       OUT VARCHAR2,
   customer_part_no_               OUT VARCHAR2,
   customer_part_desc_             OUT VARCHAR2,
   customer_contract_              OUT VARCHAR2,
   receiver_uom_                   OUT VARCHAR2,
   shipped_qty_                    OUT NUMBER,
   order_line_rec_                 IN  Public_Rec,
   contract_                       IN  VARCHAR2,
   customer_no_                    IN  VARCHAR2,
   inventory_part_no_              IN  VARCHAR2,
   gtin_no_                        IN  VARCHAR2,
   qty_shipped_                    IN  NUMBER) 
IS
   acquisition_site_    VARCHAR2(5); 
   demand_order_ref1_   VARCHAR2(15); 
   demand_order_ref2_   VARCHAR2(10); 
   demand_order_ref3_   VARCHAR2(4); 
   demand_order_ref4_   NUMBER;
   oe_order_no_         VARCHAR2(15); 
   oe_line_no_          VARCHAR2(10); 
   oe_rel_no_           VARCHAR2(4); 
   oe_line_item_no_     NUMBER;
   oe_source_type_      VARCHAR2(25);
   source_rec_          Customer_Order_Line_API.Public_Rec;
   purchase_type_       VARCHAR2(30);
   header_rec_          Customer_Order_API.Public_Rec;
BEGIN
   acquisition_site_  := Cust_Ord_Customer_API.Get_Acquisition_Site(customer_no_);
   customer_contract_ := acquisition_site_;   
   
   IF (order_line_rec_.catalog_type = 'INV' AND acquisition_site_ IS NOT NULL ) THEN
      IF (Inventory_Part_API.Part_Exist(acquisition_site_, inventory_part_no_) = 1) THEN
         shipped_qty_ := Inventory_Part_API.Get_Site_Converted_Qty(contract_, inventory_part_no_, qty_shipped_, acquisition_site_, 'REMOVE');
      ELSE
         shipped_qty_             := qty_shipped_ / NVL(order_line_rec_.customer_part_conv_factor, 1) * NVL(order_line_rec_.cust_part_invert_conv_fact, 1);
      END IF;
   ELSE
      shipped_qty_   := qty_shipped_;
   END IF;
   
   receiver_uom_            := order_line_rec_.customer_part_unit_meas; 
   header_rec_ := Customer_Order_API.Get(order_line_rec_.order_no);
   
   IF (order_line_rec_.demand_code IS NULL) THEN
      receiver_source_ref1_ := header_rec_.customer_po_no;
      receiver_source_ref2_ := order_line_rec_.customer_po_line_no;
      receiver_source_ref3_ := order_line_rec_.customer_po_rel_no;
   ELSIF (order_line_rec_.demand_code = 'IPD') THEN 
      Supply_Order_Analysis_API.Find_Source(oe_order_no_,
                                            oe_line_no_,
                                            oe_rel_no_,
                                            oe_line_item_no_,
                                            oe_source_type_,
                                            order_line_rec_.order_no,
                                            order_line_rec_.line_no,
                                            order_line_rec_.rel_no,
                                            order_line_rec_.line_item_no,
                                            Logistics_Source_Ref_Type_API.DB_CUSTOMER_ORDER,
                                            TRUE);
      IF (oe_source_type_ = Logistics_Source_Ref_Type_API.DB_CUSTOMER_ORDER ) THEN                                        
         Customer_Order_Pur_Order_API.Get_Purord_For_Custord(receiver_source_ref1_,
                                                             receiver_source_ref2_,
                                                             receiver_source_ref3_,                                                                
                                                             purchase_type_,
                                                             oe_order_no_,
                                                             oe_line_no_,
                                                             oe_rel_no_,
                                                             oe_line_item_no_);  
         source_rec_            := Get(oe_order_no_, oe_line_no_,  oe_rel_no_, oe_line_item_no_);
         -- If the source supply code is 'IPD' then get customer PO number, PO Line and PO Rel as receiver_source_ref1_, receiver_source_ref2_, receiver_source_ref3_
         IF (source_rec_.supply_code = 'IPD') THEN 
            receiver_source_ref1_ := Customer_Order_API.Get_Customer_Po_No(oe_order_no_);
            receiver_source_ref2_ := source_rec_.customer_po_line_no;
            receiver_source_ref3_ := source_rec_.customer_po_rel_no;         
         END IF;
      ELSE
         receiver_source_ref1_ := oe_order_no_;
         receiver_source_ref2_ := oe_line_no_;
         receiver_source_ref3_ := oe_rel_no_;               
      END IF;                                                    
   ELSE
      IF (order_line_rec_.demand_code IN ('IPT', 'DO', 'IPT_RO')) THEN
         Get_Demand_Order_Info(demand_order_ref1_,
                               demand_order_ref2_,
                               demand_order_ref3_,
                               demand_order_ref4_,
                               order_line_rec_.order_no,
                               order_line_rec_.line_no,
                               order_line_rec_.rel_no,
                               order_line_rec_.line_item_no);

         IF (order_line_rec_.demand_code = 'DO') THEN
            $IF (Component_Disord_SYS.INSTALLED) $THEN
               Distribution_Order_API.Get_Purchase_Order_Info(receiver_source_ref1_, receiver_source_ref2_,
                                                              receiver_source_ref3_, demand_order_ref1_);  
            $ELSE
               NULL;   
            $END
         ELSE
            receiver_source_ref1_     := demand_order_ref1_;
            receiver_source_ref2_     := demand_order_ref2_;
            receiver_source_ref3_     := demand_order_ref3_;
         END IF;
      END IF;
   END IF;
   
   IF (receiver_source_ref1_ IS NOT NULL) THEN
      receiver_source_ref_type_ := Logistics_Source_Ref_Type_API.DB_PURCHASE_ORDER;
   END IF;   
   
   IF (order_line_rec_.customer_part_no IS NULL) AND (gtin_no_ IS NULL) THEN
      -- Note: If an internal PO connected to the CO, the assumption is done that the same part no is used on both sites and
      --       the Sales Part No is assigned as the Customer's Part No.
      IF (header_rec_.internal_po_no IS NOT NULL) THEN 
         $IF (Component_Purch_SYS.INSTALLED)$THEN
            customer_part_no_   := Purchase_Order_Line_Part_API.Get_Part_No(receiver_source_ref1_, receiver_source_ref2_, receiver_source_ref3_);
            customer_part_desc_ := Purchase_Order_Line_API.Get_Description(receiver_source_ref1_, receiver_source_ref2_, receiver_source_ref3_);
         $ELSE
            NULL;
         $END
      END IF;
   ELSE
      customer_part_no_   := order_line_rec_.customer_part_no;
      customer_part_desc_ := Sales_Part_Cross_Reference_API.Get_Catalog_Desc(customer_no_, contract_, customer_part_no_);
   END IF;

   
END Get_Info_For_Desadv;

@UncheckedAccess
FUNCTION Uses_Shipment_Inventory(
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER ) RETURN NUMBER
IS
   rec_                    Customer_Order_Line_API.Public_Rec;
   pick_inventory_type_    VARCHAR2(7);
BEGIN
   rec_ := Get(order_no_, line_no_, rel_no_, line_item_no_);
   -- Go for header value: When it is not shipment connected, shipment_creation has to be 'Create_pick_List' 
   -- and it has to be before pick list creation
   IF(rec_.shipment_connected = 'TRUE' OR (rec_.shipment_creation = 'PICK_LIST_CREATION' AND rec_.rowstate = 'Reserved')) THEN
      pick_inventory_type_ := Pick_Inventory_Type_API.DB_SHIPMENT_INVENTORY;
   ELSE
      pick_inventory_type_ := Customer_Order_API.Get_Pick_Inventory_Type_Db(order_no_);
   END IF;

   RETURN CASE WHEN pick_inventory_type_ = 'SHIPINV' THEN 1 ELSE 0 END;
END Uses_Shipment_Inventory;

-- Recalculate_Prices
-- When CO Line with multiple tax is created from Sales Quotation and we have no tax calculation structure then
-- after transfering tax lines from SQ to CO we need to recalculate prices
PROCEDURE Recalculate_Prices (
   order_no_      IN VARCHAR2,
   line_no_       IN VARCHAR2,
   rel_no_        IN VARCHAR2,
   line_item_no_  IN NUMBER )
IS
   line_rec_   Customer_Order_Line_Tab%ROWTYPE;
   objid_      VARCHAR2(2000);
   rowversion_ VARCHAR2(2000);
BEGIN   
   line_rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   Get_Id_Version_By_Keys___(objid_, rowversion_, order_no_, line_no_, rel_no_, line_item_no_);
   
   Calculate_Prices(line_rec_);   
   line_rec_.rowversion := sysdate;
   Update_Line___(objid_, line_rec_);   
END Recalculate_Prices;

-- Copy_Customer_Order_Line
-- Copies order lines and rental lines from an existing cutomer order to a new customer order 
-- according to the copy options passed in the parameter list.
PROCEDURE Copy_Customer_Order_Line (
   from_order_no_               IN     VARCHAR2,
   to_order_no_                 IN     VARCHAR2,
   copy_order_lines_            IN     VARCHAR2,
   copy_rental_order_lines_     IN     VARCHAR2,   
   copy_charges_                IN     VARCHAR2,
   copy_order_adresses_         IN     VARCHAR2,
   copy_delivery_info_          IN     VARCHAR2,
   copy_misc_order_info_        IN     VARCHAR2,  
   copy_tax_detail_             IN     VARCHAR2,   
   copy_pricing_                IN     VARCHAR2,
   copy_document_texts_         IN     VARCHAR2,
   copy_notes_                  IN     VARCHAR2,
   copy_pre_accounting_         IN     VARCHAR2)
IS
   -- component lines in the proper order.
   CURSOR get_order_line IS
      SELECT *
      FROM   CUSTOMER_ORDER_LINE_TAB
      WHERE  order_no = from_order_no_
      AND    (demand_code NOT IN ('PO', 'DO', 'CRE', 'CRO', 'WO', 'IPD', 'IPT') OR demand_code IS NULL)
      AND    supply_code NOT IN ('MRO')
      AND    ((rental = 'FALSE' AND (NVL(copy_order_lines_, 'FALSE') = 'TRUE')) OR
              (rental = 'TRUE' AND (NVL(copy_rental_order_lines_, 'FALSE') = 'TRUE')))
      ORDER BY order_no, line_no, rel_no, line_item_no;
 
   CURSOR get_old_discount_line(order_no_ IN VARCHAR2, line_no_ IN VARCHAR2, rel_no_ IN VARCHAR2, line_item_no_ IN NUMBER) IS
      SELECT *
      FROM cust_order_line_discount_tab
      WHERE order_no = order_no_
      AND  line_no = line_no_
      AND  rel_no  = rel_no_
      AND  line_item_no = line_item_no_;

   from_order_rec_                Customer_Order_API.Public_Rec;
   to_order_rec_                  Customer_Order_API.Public_Rec;  
   newrec_                        CUSTOMER_ORDER_LINE_TAB%ROWTYPE; 
   indrec_                        Indicator_Rec;
   objid_                         VARCHAR2(20);
   objversion_                    VARCHAR2(100);   
   attr_                          VARCHAR2(32000);
   new_attr_                      VARCHAR2(32000);
   true_                          VARCHAR2(5) := Fnd_Boolean_API.DB_TRUE;
   false_                         VARCHAR2(5) := Fnd_Boolean_API.DB_FALSE;   
   same_customer_                 BOOLEAN := TRUE;
   copy_address_                  BOOLEAN := FALSE;
   copy_delivery_information_     BOOLEAN := FALSE;
   copy_misc_order_information_   BOOLEAN := FALSE;
   copy_tax_information_          BOOLEAN := FALSE;
   copy_pricing_information_      BOOLEAN := FALSE;
   copy_original_pre_accounting_  BOOLEAN := FALSE;
   copy_document_text_            BOOLEAN := FALSE;
   copy_note_text_                BOOLEAN := FALSE;
   line_discount_exist_           BOOLEAN := FALSE;
   discount_                      CUSTOMER_ORDER_LINE_TAB.discount%TYPE;
   copy_discount_                 VARCHAR2(5);
   dummy_info_                    VARCHAR2(32000);
   create_partial_sum_            CUST_ORDER_LINE_DISCOUNT_TAB.Create_Partial_Sum%TYPE;   
   orginal_pre_accounting_id_     CUSTOMER_ORDER_LINE_TAB.pre_accounting_id%TYPE;
   original_config_line_price_id_ CUSTOMER_ORDER_LINE_TAB.configured_line_price_id%TYPE;
   rental_chargeable_days_        NUMBER;
   supply_code_                   CUSTOMER_ORDER_LINE_TAB.supply_code%TYPE;
   
BEGIN
   from_order_rec_ := Customer_Order_API.Get(from_order_no_);   
   to_order_rec_ := Customer_Order_API.Get(to_order_no_);
   same_customer_  := from_order_rec_.customer_no = to_order_rec_.customer_no;
   
   IF (same_customer_) THEN
      copy_address_                 := (NVL(copy_order_adresses_,false_) = true_);
      copy_misc_order_information_  := (NVL(copy_misc_order_info_,false_) = true_) ;
   END IF;
   copy_tax_information_         := (NVL(copy_tax_detail_,false_) = true_);   
   copy_delivery_information_    := (NVL(copy_delivery_info_,false_) = true_);
   copy_pricing_information_     := (NVL(copy_pricing_,false_) = true_);   
   copy_document_text_           := (NVL(copy_document_texts_, false_) = true_);
   copy_note_text_               := (NVL(copy_notes_, false_) = true_);
   copy_original_pre_accounting_ := (NVL(copy_pre_accounting_, false_) = true_);
  
   FOR order_line_rec_ IN get_order_line LOOP
      attr_ := NULL;
      new_attr_ := NULL;
      -- Values that can be fetched regardless of the customer the order was created
      Client_SYS.Add_To_Attr('ORDER_NO', to_order_no_, attr_);
      Client_SYS.Add_To_Attr('LINE_NO', order_line_rec_.line_no, attr_);
      Client_SYS.Add_To_Attr('REL_NO', order_line_rec_.rel_no, attr_);
      Client_SYS.Add_To_Attr('LINE_ITEM_NO', order_line_rec_.line_item_no, attr_);
      Client_SYS.Add_To_Attr('CATALOG_NO', order_line_rec_.catalog_no, attr_);
      Client_SYS.Add_To_Attr('BUY_QTY_DUE', order_line_rec_.buy_qty_due, attr_);     
      Client_SYS.Add_To_Attr('CONTRACT', to_order_rec_.contract, attr_);
      Client_SYS.Add_To_Attr('WANTED_DELIVERY_DATE', to_order_rec_.wanted_delivery_date, attr_); 
      Client_SYS.Add_To_Attr('CLOSE_TOLERANCE', order_line_rec_.close_tolerance, attr_);
      Client_SYS.Add_To_Attr('CONDITION_CODE', order_line_rec_.condition_code, attr_);
      Client_SYS.Add_To_Attr('CONFIGURATION_ID', order_line_rec_.configuration_id, attr_);
      Client_SYS.Add_To_Attr('CHARGED_ITEM_DB', order_line_rec_.charged_item, attr_);
      Client_SYS.Add_To_Attr('DELIVERY_TYPE', order_line_rec_.delivery_type, attr_);     
      Client_SYS.Add_To_Attr('RENTAL_DB', order_line_rec_.rental, attr_);
      Client_SYS.Add_To_Attr('ABNORMAL_DEMAND_DB', order_line_rec_.abnormal_demand, attr_);
      
      IF order_line_rec_.supply_code IN ('IO', 'NO', 'PKG', 'PD', 'PT', 'IPD', 'IPT','ND','PS','DOP','SO') THEN
         supply_code_ := order_line_rec_.supply_code;       
      ELSIF order_line_rec_.supply_code IN('PRJ') THEN
         supply_code_ := 'NO';
      ELSE
         supply_code_ := 'IO'; 
      END IF;
      Client_SYS.Add_To_Attr('SUPPLY_CODE', Order_Supply_Type_API.Decode(supply_code_), attr_);
      --------------------------------------------------------------------------------      
            
      Build_Attr_For_New___(discount_, copy_discount_, create_partial_sum_, new_attr_, attr_);
      
      -- Note: Add the rental information to the attr_
      IF (order_line_rec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
         Add_Rental_Info_To_Attr___ (new_attr_,
                                    from_order_no_,
                                    order_line_rec_.line_no,
                                    order_line_rec_.rel_no,
                                    order_line_rec_.line_item_no);         
      END IF;
      
      Build_Rec_For_Copy_Line___ (newrec_,
                                 indrec_,
                                 new_attr_,
                                 order_line_rec_,
                                 copy_address_, 
                                 copy_misc_order_information_,
                                 copy_delivery_information_,
                                 copy_tax_information_,
                                 copy_pricing_information_,
                                 copy_document_text_,
                                 copy_note_text_,
                                 same_customer_,
                                 to_order_rec_.use_price_incl_tax,
                                 from_order_rec_.language_code);    
      
      Client_SYS.Add_To_Attr('COPY_ORDER_LINE', 'TRUE', new_attr_);   

      IF (NVL(copy_charges_, 'FALSE') = 'TRUE') THEN
         Client_SYS.Add_To_Attr('DEFAULT_CHARGES', 'FALSE', new_attr_);     
      END IF;

      IF (copy_delivery_information_) THEN
         Client_SYS.Add_To_Attr('FETCH_SUPPLY_CHAIN_DEFAULTS', 'FALSE', new_attr_);      
      END IF;
      
      IF (copy_tax_information_) THEN
         Client_SYS.Add_To_Attr('FETCH_TAX_FROM_DEFAULTS', 'FALSE', new_attr_);
         Client_SYS.Add_To_Attr('ORIGINAL_ORDER_NO', order_line_rec_.order_no, new_attr_);
         Client_SYS.Add_To_Attr('ORIGINAL_LINE_NO', order_line_rec_.line_no, new_attr_);
         Client_SYS.Add_To_Attr('ORIGINAL_REL_NO', order_line_rec_.rel_no, new_attr_);
         Client_SYS.Add_To_Attr('ORIGINAL_ITEM_NO', order_line_rec_.line_item_no, new_attr_);
         IF (NOT copy_pricing_information_) THEN
            Client_SYS.Add_To_Attr('RECALC_TAX_AMOUNTS', 'TRUE', new_attr_);
         END IF;
      END IF;

      -- Configured Line Price
      IF(copy_pricing_information_) THEN
         original_config_line_price_id_ := order_line_rec_.configured_line_price_id;
      END IF;
      
      -- Preposting
      IF (copy_original_pre_accounting_) THEN
         orginal_pre_accounting_id_ := order_line_rec_.pre_accounting_id;
      END IF;
      
      Check_Insert___(newrec_, indrec_, new_attr_);
                
      Insert___(objid_, objversion_, newrec_, new_attr_);
      
      Custom_Objects_SYS.Copy_Cf_Instance(lu_name_, order_line_rec_.rowkey, newrec_.rowkey);
      
      -- Copy Order line Address
      IF ((copy_address_) AND (newrec_.default_addr_flag = 'N') AND (order_line_rec_.addr_flag = 'Y')) THEN
         
         Copy_Order_Line_Address___ (order_line_rec_.order_no,
                                     order_line_rec_.line_no,
                                     order_line_rec_.rel_no,
                                     order_line_rec_.line_item_no,
                                     newrec_.order_no,
                                     newrec_.line_no,
                                     newrec_.rel_no,
                                     newrec_.line_item_no);
      END IF;
      -- Fetch Correct Default Info Flag
      Modify_Line_Default_Addr_Flag(newrec_ ,
                                    newrec_.order_no,
                                    newrec_.default_addr_flag);      
      
      -- Copy Pre-Accounting
      IF (copy_original_pre_accounting_) THEN
         Pre_Accounting_API.Copy_Pre_Accounting(orginal_pre_accounting_id_,
                                                newrec_.pre_accounting_id,
                                                newrec_.contract,
                                                TRUE,
                                                'CUSTOMER ORDER',
                                                TRUE,
                                                TRUE);     
      END IF;
      
      IF (copy_pricing_information_) THEN
         -- Copy Configuration Line Price 
         Configured_Line_price_API.Transfer_Pricing__(dummy_info_, original_config_line_price_id_, newrec_.configured_line_price_id, FALSE);
         
         -- Copy Discount Lines
         FOR get_old_line_rec_ IN get_old_discount_line(order_line_rec_.order_no,order_line_rec_.line_no,order_line_rec_.rel_no,order_line_rec_.line_item_no) LOOP    
            Cust_Order_Line_Discount_API.New(newrec_.order_no, 
                                              newrec_.line_no, 
                                              newrec_.rel_no, 
                                              newrec_.line_item_no, 
                                              get_old_line_rec_.discount_type,
                                              get_old_line_rec_.discount, 
                                              Discount_Source_API.DB_MANUAL, 
                                              get_old_line_rec_.create_partial_sum,
                                              get_old_line_rec_.discount_line_no,
                                              NULL,
                                              get_old_line_rec_.discount_amount,
                                              get_old_line_rec_.part_level,
                                              get_old_line_rec_.part_level_id,
                                              get_old_line_rec_.customer_level,
                                              get_old_line_rec_.customer_level_id);
            line_discount_exist_ := TRUE;
         END LOOP;
         IF (line_discount_exist_) THEN
            Cust_Order_Line_Discount_API.Calc_Discount_Upd_Co_Line__(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no);
         END IF;
      ELSE
         -- Default Configuration Line Price 
         Configured_Line_price_API.Transfer_Pricing__(dummy_info_, original_config_line_price_id_, newrec_.configured_line_price_id, TRUE);
         
         -- Default Line Discounts
         IF (newrec_.rental = Fnd_Boolean_API.DB_TRUE) THEN
            rental_chargeable_days_ := Get_Latest_Rent_Charge_Days___(new_attr_, newrec_);
         END IF;  
                  
         Customer_Order_Pricing_API.New_Default_Discount_Rec(newrec_.order_no,
                                                             newrec_.line_no,
                                                             newrec_.rel_no,
                                                             newrec_.line_item_no,
                                                             newrec_.contract,
                                                             newrec_.customer_no,
                                                             to_order_rec_.currency_code,
                                                             to_order_rec_.agreement_id,
                                                             newrec_.catalog_no,
                                                             newrec_.buy_qty_due,
                                                             newrec_.price_list_no,
                                                             newrec_.customer_level,
                                                             newrec_.customer_level_id,
                                                             rental_chargeable_days_);
      END IF;
      
      -- Copy Milestones
      IF (Customer_Order_Milestone_API.Milestone_Exist(order_line_rec_.order_no, order_line_rec_.line_no, order_line_rec_.rel_no, order_line_rec_.line_item_no ) = 'TRUE') THEN
         Customer_Order_Milestone_API.Copy_Milestone_Lines(newrec_.order_no,
                                                          newrec_.line_no,
                                                          newrec_.rel_no,
                                                          newrec_.line_item_no,
                                                          order_line_rec_.order_no,
                                                          order_line_rec_.line_no,
                                                          order_line_rec_.rel_no,
                                                          order_line_rec_.line_item_no);   
      END IF;

      -- Copy Staged Billing
      IF (order_line_rec_.staged_billing = 'STAGED BILLING') THEN
         Copy_Staged_Billing___(newrec_.order_no, 
                                newrec_.line_no, 
                                newrec_.rel_no,
                                newrec_.line_item_no,
                                order_line_rec_.order_no,
                                order_line_rec_.line_no,
                                order_line_rec_.rel_no,
                                order_line_rec_.line_item_no,
                                copy_document_text_,
                                copy_note_text_);
      END IF;               

      -- Copy Commission Information if the line copied had any related manual commission information.
      Order_Line_Commission_API.Copy_Manual_Commission_Lines(newrec_.order_no, 
                                                            newrec_.line_no, 
                                                            newrec_.rel_no,
                                                            newrec_.line_item_no,
                                                            order_line_rec_.order_no,
                                                            order_line_rec_.line_no,
                                                            order_line_rec_.rel_no,
                                                            order_line_rec_.line_item_no,
                                                            copy_document_text_,
                                                            copy_note_text_);
      -- Create a customer Order Line History Record
      Customer_Order_Line_Hist_API.New(newrec_.order_no, newrec_.line_no, newrec_.rel_no, newrec_.line_item_no,
                                       Language_SYS.Translate_Constant(lu_name_, 'LINECOPIED: Copied from order :P1',NULL, order_line_rec_.order_no));
   END LOOP;  
END Copy_Customer_Order_Line;

PROCEDURE Raise_Shipment_Chaged_New 
IS
BEGIN
   Client_SYS.Add_Info(lu_name_, 'SHIPMENT_CHANGED_NEW: Shipment Creation of Customer Order Line will be changed to No Automatic Creation.');
END Raise_Shipment_Chaged_New;

-- Validate_Prepayment
--   Validate connected prepayment.
PROCEDURE Validate_Prepayment(
  order_no_      IN VARCHAR2,
  line_no_       IN VARCHAR2,
  rel_no_        IN VARCHAR2,
  line_item_no_  IN NUMBER,
  action_        IN VARCHAR2)
IS
   linerec_      CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
BEGIN
   linerec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_); 
   Validate_Prepayment___(linerec_, action_);  
END Validate_Prepayment;

FUNCTION Get_Unit_Contribution_Margin (
   order_no_       IN VARCHAR2,
   line_no_        IN VARCHAR2,
   rel_no_         IN VARCHAR2,
   line_item_no_   IN NUMBER,
   rounding_       IN NUMBER,
   extra_discount_ IN NUMBER) RETURN NUMBER
IS
   line_rec_                 Public_Rec;
   unit_contribution_margin_ NUMBER;
BEGIN
   IF (Customer_Order_API.Exists(order_no_)) THEN
      line_rec_ := Get(order_no_, line_no_, rel_no_, line_item_no_);
      unit_contribution_margin_ := line_rec_.price_conv_factor * line_rec_.base_sale_unit_price * (1 - (line_rec_.discount + extra_discount_) / 100) * (1 - (line_rec_.order_discount + Customer_Order_API.Get_Additional_Discount(order_no_)) / 100) 
                                   - line_rec_.cost * line_rec_.conv_factor / line_rec_.inverted_conv_factor; 
      unit_contribution_margin_ := ROUND(unit_contribution_margin_, rounding_);
   END IF;
   RETURN unit_contribution_margin_;
END Get_Unit_Contribution_Margin;

FUNCTION Get_Base_Contribution_Margin (
   order_no_       IN VARCHAR2,
   line_no_        IN VARCHAR2,
   rel_no_         IN VARCHAR2,
   line_item_no_   IN NUMBER,
   rounding_       IN NUMBER,
   extra_discount_ IN NUMBER) RETURN NUMBER
IS
   line_rec_  Public_Rec;
   base_contribution_margin_ NUMBER;
BEGIN
   IF (Customer_Order_API.Exists(order_no_)) THEN
      line_rec_ := Get(order_no_, line_no_, rel_no_, line_item_no_);
      base_contribution_margin_ := line_rec_.buy_qty_due * line_rec_.price_conv_factor * line_rec_.base_sale_unit_price * (1 - (line_rec_.discount + extra_discount_) / 100) * (1 - (line_rec_.order_discount + Customer_Order_API.Get_Additional_Discount(order_no_)) / 100)
                                   - line_rec_.cost * line_rec_.buy_qty_due * line_rec_.conv_factor / line_rec_.inverted_conv_factor;
      base_contribution_margin_ := ROUND(base_contribution_margin_, rounding_);
   END IF;
   RETURN base_contribution_margin_;
END Get_Base_Contribution_Margin;


FUNCTION Get_No_Of_Sold_Sales_Parts (
   customer_no_ IN VARCHAR2,
   company_     IN VARCHAR2 DEFAULT NULL ) RETURN NUMBER 
IS
   no_of_sold_parts_ NUMBER;
   
   CURSOR get_no_of_sold_sales_parts IS
      SELECT COUNT(*)
      FROM (SELECT COUNT(catalog_no)
            FROM customer_order_line
            WHERE customer_no = customer_no_
            AND   company LIKE NVL(company_, '%')
            AND   objstate IN ('PartiallyDelivered', 'Delivered', 'Invoiced')
            GROUP BY customer_no, catalog_no, catalog_desc, contract, company);
BEGIN
   OPEN get_no_of_sold_sales_parts;
   FETCH get_no_of_sold_sales_parts INTO no_of_sold_parts_;
   CLOSE get_no_of_sold_sales_parts;
   
   RETURN NVL(no_of_sold_parts_, 0);
END Get_No_Of_Sold_Sales_Parts;


PROCEDURE Modify_Tax_Id_Validated_Date (
   order_no_          IN VARCHAR2,
   line_no_           IN VARCHAR2,
   rel_no_            IN VARCHAR2,
   line_item_no_      IN NUMBER)
IS
   attr_   VARCHAR2(2000) := NULL;
BEGIN
   Client_SYS.Add_To_Attr('TAX_ID_VALIDATED_DATE', CURRENT_DATE, attr_);
   Modify_Line___(attr_, order_no_, line_no_, rel_no_, line_item_no_);
END Modify_Tax_Id_Validated_Date;


-- Get_Packages_Shipped
--    Get the full package qty shipped
FUNCTION Get_Packages_Shipped (
   order_no_ IN VARCHAR2,
   line_no_  IN VARCHAR2,
   rel_no_   IN VARCHAR2) RETURN NUMBER
IS 
   pkg_shipped_ NUMBER;
   
   CURSOR get_pkg_shipped IS
      SELECT NVL(MIN(TRUNC(qty_shipped * (inverted_conv_factor/conv_factor)/qty_per_assembly)),0) qty_shipped
      FROM   CUSTOMER_ORDER_LINE_TAB c
      WHERE  order_no = order_no_
      AND    line_no  = line_no_
      AND    rel_no   = rel_no_
      AND    line_item_no > 0
      AND    rowstate != 'Cancelled'
      AND    new_comp_after_delivery = 'FALSE';
BEGIN
   OPEN get_pkg_shipped;
   FETCH get_pkg_shipped INTO pkg_shipped_;
   CLOSE get_pkg_shipped;
   
   RETURN pkg_shipped_;
END Get_Packages_Shipped;


-- Check_And_Add_To_Shipment
-- The public interface for Check_And_Add_To_Shipment___. When the criteria is met for a the CO Line to be connected to a shipment line,
-- calls Shipment_Handling_Utility_API.Add_Source_Line_To_Shipment.
PROCEDURE Check_And_Add_To_Shipment(
   order_no_     IN VARCHAR2,
   line_no_      IN VARCHAR2,
   rel_no_       IN VARCHAR2,
   line_item_no_ IN NUMBER)
IS
   line_rec_        CUSTOMER_ORDER_LINE_TAB%ROWTYPE;
   header_rowstate_ VARCHAR2(20);
BEGIN
   
   line_rec_ := Get_Object_By_Keys___(order_no_, line_no_, rel_no_, line_item_no_);
   header_rowstate_ := Customer_Order_API.Get_Objstate(line_rec_.order_no);
   Check_And_Add_To_Shipment___(line_rec_, header_rowstate_);

END Check_And_Add_To_Shipment;

-- This method fetch Order reference info for Pick Part By Choice
@UncheckedAccess
PROCEDURE Get_Order_Reference_Info (
   source_ref_status_   OUT VARCHAR2,
   condition_code_      OUT VARCHAR2,
   condition_code_desc_ OUT VARCHAR2,
   project_id_          OUT VARCHAR2,
   project_name_        OUT VARCHAR2,
   supply_code_db_      OUT VARCHAR2,
   rental_db_           OUT VARCHAR2,
   part_ownership_db_   OUT VARCHAR2,
   owner_               OUT VARCHAR2,
   owner_name_          OUT VARCHAR2,
   order_no_            IN  VARCHAR2,
   line_no_             IN  VARCHAR2,
   rel_no_              IN  VARCHAR2,
   line_item_no_        IN  VARCHAR2)
IS 
   co_line_rec_    Public_Rec;
BEGIN
   co_line_rec_   := Get(order_no_, 
                         line_no_, 
                         rel_no_, 
                         line_item_no_);
                         
   source_ref_status_     := co_line_rec_.rowstate;
   condition_code_        := co_line_rec_.condition_code;                          
   condition_code_desc_   := Condition_Code_API.Get_Description(condition_code_); 
   project_id_            := co_line_rec_.project_id;
   rental_db_             := co_line_rec_.rental;
   supply_code_db_        := co_line_rec_.supply_code; 
   part_ownership_db_     := co_line_rec_.part_ownership;
   owner_                 := Get_Owner_For_Part_Ownership(order_no_, 
                                                          line_no_, 
                                                          rel_no_, 
                                                          line_item_no_, 
                                                          part_ownership_db_);
   owner_name_            := Cust_Ord_Customer_API.Get_Name(co_line_rec_.owning_customer_no); 
   $IF Component_Proj_SYS.INSTALLED $THEN
      project_name_       := Project_API.Get_Name(co_line_rec_.project_id);
   $END 
END Get_Order_Reference_Info;

@IgnoreUnitTest TrivialFunction
PROCEDURE Validate_Cust_Ord_Lin_Defaults(
   catalog_no_          IN OUT VARCHAR2 ,
   catalog_desc_        IN OUT VARCHAR2 ,   
   supply_code_         IN OUT VARCHAR2,
   vendor_no_           IN OUT VARCHAR2,
   supply_site_         IN OUT VARCHAR2,
   condition_code_      IN OUT VARCHAR2,    
   supply_code_client_  IN OUT VARCHAR2,
   contract_            IN VARCHAR2,
   language_code_       IN VARCHAR2,
   customer_no_         IN VARCHAR2, 
   demand_code_         IN VARCHAR2,
   purchase_part_no_    IN VARCHAR2,
   configurable_        IN VARCHAR2,
   part_no_             IN VARCHAR2,
   sourcing_option_     IN VARCHAR2,
   created_by_server_   IN BOOLEAN DEFAULT FALSE,
   rental_db_           IN VARCHAR2 DEFAULT 'FALSE')
IS
BEGIN 
  
   IF catalog_desc_ IS NULL THEN
     catalog_desc_ := Get_Catalog_Description___(contract_, catalog_no_, language_code_, customer_no_);
   END IF;
   
   IF (part_no_ IS NOT NULL) THEN
      Get_Condition_Code___(condition_code_, part_no_);
   END IF;
   
   Get_Supply_Code___(supply_code_, supply_code_client_, contract_, configurable_, catalog_no_, rental_db_,
                      sourcing_option_, demand_code_, purchase_part_no_, created_by_server_);
   
   vendor_no_ := Get_vendor_No___(supply_code_, rental_db_, contract_, purchase_part_no_);
   
   supply_site_ := Get_Supply_Site___(supply_code_, vendor_no_, rental_db_);
 
END Validate_Cust_Ord_Lin_Defaults;

   
FUNCTION Get_Catalog_Description___(
   contract_         IN VARCHAR2,
   catalog_no_       IN VARCHAR2,
   language_code_    IN VARCHAR2,
   customer_no_      IN VARCHAR2 ) RETURN VARCHAR2
IS
   customer_part_no_           Customer_Order_Line_Tab.customer_part_no%TYPE;      
   catalog_desc_               Customer_Order_Line_Tab.catalog_desc%TYPE;
BEGIN
    customer_part_no_ := Sales_Part_Cross_Reference_API.Get_Customer_Part_No(customer_no_, contract_, catalog_no_);
   IF customer_part_no_ IS NOT NULL THEN
      catalog_desc_  := Sales_Part_Cross_Reference_API.Get_Catalog_Desc(customer_no_, contract_, customer_part_no_);         
   END IF;
   
   IF catalog_desc_ IS NULL  THEN
      catalog_desc_ := Sales_Part_Language_Desc_API.Get_Catalog_Desc(contract_, catalog_no_, language_code_);   
   END IF;
   
   IF catalog_desc_ IS NULL THEN
      catalog_desc_ := Sales_Part_API.Get_Catalog_Desc(contract_, catalog_no_, language_code_);
   END IF;
   RETURN catalog_desc_;
END Get_Catalog_Description___;


PROCEDURE Get_Condition_Code___(
   condition_code_ IN OUT VARCHAR2,
   part_no_        IN     VARCHAR2   )
IS
BEGIN
   IF (Part_Catalog_API.Get_Condition_Code_Usage_Db(part_no_) = 'ALLOW_COND_CODE') THEN
      IF (condition_code_ IS NULL) THEN
         condition_code_ := Condition_Code_API.Get_Default_Condition_Code;
      END IF;
   END IF;
END;
   
PROCEDURE Get_Supply_Code___(
   supply_code_        IN OUT VARCHAR2,
   supply_code_client_ IN OUT VARCHAR2,
   contract_           IN VARCHAR2,
   configurable_       IN VARCHAR2,
   catalog_no_         IN VARCHAR2,
   rental_db_          IN VARCHAR2, 
   sourcing_option_    IN VARCHAR2,
   demand_code_        IN VARCHAR2,
   purchase_part_no_   IN VARCHAR2,
   created_by_server_  IN BOOLEAN )
IS
BEGIN
   IF ( supply_code_client_ IS NOT NULL AND supply_code_ IS NULL ) THEN
      supply_code_ := Order_Supply_Type_API.Encode(supply_code_client_);
   END IF;        
   
   IF (supply_code_ IS NULL) THEN
      supply_code_client_ := Sales_Part_API.Get_Default_Supply_Code(contract_, catalog_no_, rental_db_);
      supply_code_        := Order_Supply_Type_API.Encode(supply_code_client_);
   
      -- if no supply code was "found" - i.e. sourcing option PRIMARYSUPP... is used and primary supplier is not connect to the part.
      IF (supply_code_ IS NULL) AND (sourcing_option_ IN ('PRIMARYSUPPTRANSIT', 'PRIMARYSUPPDIRECT')) THEN
         IF created_by_server_ THEN
            Error_SYS.Record_General(lu_name_, 'NO_PRIMARY_SUPP: No primary supplier exists for purchase part :P1.', purchase_part_no_);
         ELSE
            Client_SYS.Add_Info(lu_name_, 'NO_PRIMARY_SUPP: No primary supplier exists for purchase part :P1.', purchase_part_no_);
         END IF;
      END IF;
      IF (supply_code_ = 'DOP') AND (sourcing_option_ = 'INVENTORYORDER') THEN
         supply_code_        := 'IO';
      END IF;
   ELSE
      -- if supply code is 'Invent Order' and the part is configured - set supply code to 'Not Decided'
      IF (supply_code_ = 'IO') AND (configurable_ = 'CONFIGURED') AND (NVL(demand_code_, Database_SYS.string_null_) != 'CQ') THEN
         supply_code_ := 'ND';
      END IF;
   END IF;
   
   IF supply_code_ IS NOT NULL THEN
      supply_code_client_ := Order_Supply_Type_API.Decode(supply_code_);
   END IF;
END Get_Supply_Code___;


FUNCTION Get_Vendor_No___(   
   supply_code_ IN VARCHAR2,
   rental_db_   IN VARCHAR2,
   contract_    IN VARCHAR2,
   purchase_part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   vendor_no_ Customer_Order_Line_Tab.vendor_no%TYPE;
BEGIN

   -- Get Primary Supplier No for the part_no, contract
   IF (supply_code_ IN ('IPT', 'IPD', 'PT', 'PD')) THEN
      $IF (Component_Purch_SYS.INSTALLED) $THEN
         IF (rental_db_ = Fnd_Boolean_API.DB_FALSE) THEN
            vendor_no_ := Purchase_Part_Supplier_API.Get_Active_Primary_Supplier_No(contract_,
                                                                                purchase_part_no_);
         ELSE
            vendor_no_ := Purchase_Part_Supplier_API.Get_Active_Rental_Primary_Supp(contract_,
                                                                                    purchase_part_no_);

         END IF;
         $ELSE
            NULL;
         $END
      END IF;
   RETURN vendor_no_;
END Get_Vendor_No___;
   
   
FUNCTION Get_Supply_Site___(
      supply_code_ IN VARCHAR2,
      vendor_no_   IN VARCHAR2,
      rental_db_   IN VARCHAR2 ) RETURN VARCHAR2
   IS
      supply_site_  Customer_Order_Line_Tab.supply_site%TYPE;
   BEGIN
      IF (supply_code_ IN ('IPT', 'IPD')) THEN
      -- get default supply_site_reserve_type_
      -- check if the inventory part exists on the supply_site (is the supply_site in the same database)
      supply_site_ := Get_Vendor_Contract__(vendor_no_, NULL, NULL, NULL, rental_db_);
   END IF;
   RETURN supply_site_;   
END Get_Supply_Site___;

@IgnoreUnitTest TrivialFunction
@UncheckedAccess
FUNCTION Get_Tax_Id_Type (
   order_no_      IN VARCHAR2,
   line_no_       IN VARCHAR2,
   rel_no_        IN VARCHAR2,
   line_item_no_  IN NUMBER) RETURN VARCHAR2
IS
   tax_id_type_         VARCHAR2(10);
   company_             VARCHAR2(20);
   delivery_country_    VARCHAR2(2);
   header_rec_          Customer_Order_API.Public_Rec;
BEGIN    
   header_rec_       := Customer_Order_API.Get(order_no_);
   company_          := Site_API.Get_Company(header_rec_.contract);
   delivery_country_ := Cust_Order_Line_Address_API.Get_Country_Code(order_no_, line_no_, rel_no_, line_item_no_);
   tax_id_type_      := Tax_Handling_Order_Util_API.Fetch_And_Validate_Tax_Id(header_rec_.customer_no, header_rec_.bill_addr_no, company_, header_rec_.supply_country, delivery_country_);
   
   RETURN tax_id_type_;
END Get_Tax_Id_Type;

@IgnoreUnitTest TrivialFunction
PROCEDURE Handle_Replacement_Part (
   catalog_no_     IN OUT VARCHAR2,
   org_catalog_no_ IN OUT VARCHAR2,
   contract_       IN     VARCHAR2,
   by_info_        IN     BOOLEAN )   
IS
BEGIN
   Handle_Replacement_Part___(catalog_no_, org_catalog_no_, contract_, by_info_);
END Handle_Replacement_Part;

