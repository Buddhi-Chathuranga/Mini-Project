-----------------------------------------------------------------------------
--
--  Logical unit: InventoryTransactionHist
--  Component:    INVENT
--
--  IFS Developer Studio Template Version 3.0
--
--  Date    Sign    History
--  ------  ------  ---------------------------------------------------------
--  220201  ApWilk  SC21R2-7304, Added the method Get_Weighted_Average_Part_Cost() to get the inventory transaction cost based on the part cost level.
--  220127  RasDlk  SC21R2-7427, Modified Undo_Move_To_Order_Transit___ by passing the owning_vendor_no of the old transaction when creating the history record
--  220127          in order to prevent the error raiesd during Undo Shipment Delivery for a Supplier Loaned stock.
--  220126  RasDlk  SC21R2-7228, Modified Undo_Move_To_Order_Transit___ by passing the relevant parameters to the Remove_From_Order_Transit in order to support Undo Shipment Delivery.
--  220122  RasDlk  SC21R2-7282, Modified Call_Lot_Batch_Master__, Call_Part_Serial_Catalog___ and Get_Serial_Message___ to support 'UND-SHPODW', 'UND-SHPODS' and 'PD-UNSHIP' transactions.
--  220111  AsZelk  SC21R2-6630, Added Get_Earliest_Transaction_Id() method to fetch earliest transaction_id for given source record and Transaction Code.
--  211215  SeJalk  SC21R2-6600, Modified Get_Po_Line_Qty_Received___() to consider the direct quantity delivered to customer into consideration when calculation POINV-WIP transaction costs.
--  211214  ApWilk  SC21R2-6311, Modified method Get_Latest_Transaction_Id() by adding new parameter source_ref5 .
--  211203  SBalLK  SC21R2-3202, Reverted changes done with previous commit.
--  211117  MalLlk  SC21R2-5971, Added method Get_Src_Ref_By_Part_Mov_Tax_Id to returns source ref keys, source type and transaction code for given part move tax id.
--  211101  ChJalk  SC21R2-5478, Added method Get_Purch_Comp_Consum_Tran_Tab to return all the transaction IDs for a particular receipt. Restructured the  
--  211101          method Get_Purch_Comp_Consume_Trans to get all the transaction_IDs using the method Get_Purch_Comp_Consum_Tran_Tab and return only the  
--  211101          first transaction IDs. Modified Get_Consumed_Comp_Curr_Details to use Get_Purch_Comp_Consum_Tran_Tab to get all the transaction_IDs.
--  211101          Reverted the modifiactions done for the methods Get_Consumed_Component_Cost and Get_Consumed_Comp_Cost_Details under SCZ-15524.
--  211101  NEKOLK  AM21R2-2960 : EQUIP redesign PARTCA changes : alternate_id obsolete work .
--  211027  RoJalk  SC21R2-3082, Modified Inventory_Part_In_Transit_API.Unreceive_Part_To_Transit call in Cancel_Order_Receipt to consider external ownerships for Shipment Order.
--  211006  SBalLK  SC21R2-3202, Removed Check_Lot_Batch_In_Use() method. Existing logic moved to LotBatchMaster LU with received_qty > 0.
--  211005  RoJalk  SC21R2-688, Modified Insert___ to call Pre_Accounting_API.Set_Project_Code_Part for Shipment Order.
--  211001  WaSalk  Bug 160979 (SCZ-16390), Modified type of number_array to VARCHAR2 to avoid numeric overflow of transaction_id_ in Calculate_Qty_Onhand_Date.
--  210930  Asawlk  SC21R2-2770, Added method Set_Part_Move_Tax_Id() and Get_Sum_Inventory_Cost().
--  210922  RoJalk  SC21R2-688, Modified Inventory_Part_In_Transit_API.Unreceive_Part_To_Transit call in Cancel_Order_Receipt and passed activity_seq from transaction history.
--  210917  Asawlk  SC21R2-2770, Modified method New() in order to set part_move_tax_id to 0 when the transaction code is having part_move_tax_direction as RECEIVER or SENDER.
--  210915  Skanlk  Bug 160575(SC21R2-2598), Added new parameter handling_unit_id into Get_Rma_Multi_Site_Return_Qty.
--  210915  MaEelk  SC21R2-2751, Added Get_Sum_Qty_Part_Move_Tax_Id. This will give the summation of the field Quntity of the transactions having the same Part Move Tax Id
--  210908  ChJalk  SCZ-15873, Modified Handle_Purch_Order_Line_Close to consider UNRET-WIP when getting value details posted on M15 in relation to the PO line when closing. 
--  210714  ChJalk  SCZ-15524, Restructured the method Get_Purch_Comp_Consume_Trans to add IN parameter include_all_comp_consume_trans_ and return all the transaction IDs for a particular
--  210714          receipt if it is TRUE. Modified Get_Consumed_Comp_Curr_Details to pass TRUE for include_all_comp_consume_trans_ when calling Get_Purch_Comp_Consume_Trans.  
--  210714          Modified the methods Get_Consumed_Component_Cost and Get_Consumed_Comp_Cost_Details to handle Transaction_Id_Tab returned by the method Get_Purch_Comp_Consume_Trans.
--  210629  TKAVLK  FI21R2-2112, Modified New() adding new default parameters, move_dest_contract_ and move_dest_location_no_.
--  210628  Cpeilk  SCZ-15300, Modified Make_Po_Invoice_Balance_Trans to get rid of error raised when curr_amount_detail_tab_ is empty.
--  210601  WaSalk  SC21R2-1235, Modified New() to fetch warehouse_id_  and modified parameter list of Check_Insert___() by adding warehouse_id_.
--  210601          Added Check_Warehouse_Access___() to support gelr functionalities.
--  210527  LEPESE  SC21R2-794, Added call to Site_Invent_Info_API.Get_First_Viable_Posting_Date in Intersite_Move_Revaluation___. Added parameter date_applied_ to
--  210527          methods Post_Curr_Diff_After_Reval___, Reval_Wa_At_Empty_Inventory___, Balance_Transit_And_Invent___, Create_Revaluation_Postings___,
--  210527          Revalue_Ret_Rework_Or_Cred___, Post_Booking_Actions___, Part_Id_Change_Revaluation___, Condition_Code_Change_Reval___, Reverse_Accounting,
--  210527          Reval_WA_Supplier_Shipment and Balance_Transit_And_Invent_Acc.
--  210309  Cpeilk  SCZ-13999, Modified Make_Po_Invoice_Balance_Trans to handle 3rd currency scenarios for upgraded data from APP9 and earlier releases.
--  210217  LEPESE  SC2020R1-12529, Removed the source_ref parameters on methods Create_Data_Capture_Lov, Record_With_Column_Value_Exist and Get_Column_Value_If_Unique.
--  210126  LEPESE  SC2020R1-12294, Replaced some Get method calls for individual entity attributes with the generic Get that returns Public_Rec.
--  210126          Changes made in Call_Part_Serial_Catalog___ and Create_Stage_Pay_Postings___. Also done some generic cleanup. 
--  201218  LEPESE  SC2020R1-11853, Removed all occurences of Client_SYS.Add_To_Attr and made assignments directly to record instead.
--  201203  DiJwlk  GESPRING20-6008, Modified Modify_Date_Applied() and Modify_Delivery_Info() by adding 'SHIPDIR' and 'SHIPTRAN' transaction codes to support Inter-Site Flow
--  201201  JaThlk  GESPRING20-6007, Modified Modify_Delivery_Info to add transaction code OESHIPNI in the condition.
--  201026  WaSalk  SC2020R1-10885, Modified Modify_Delivery_Info() and Modify_Delivery_Info___() by adding remove_del_info_ to parameter list to support gelr functionalities.
--  201019  NiEdlk  SCZ-11859, Modified Get_Returned_Rental_Qty to convert the rma_no_ and rma_line_no_ to string before the comparison to avoid invalid number error.
--  201013  ErFelk  Bug 155583(SCZ-11660), Modified Get_Transaction_Curr_Info___() by adding event codes ARRCHGIDIR, PODIRINTEM to the condition.
--  200924  LEPESE  SC2021R1-291, change in Refresh_Activity_Info to call Jt_Task_API.Refresh_Project_Connection for Work Tasks.
--  200923  JaThlk  SC2020R1-1189, Modified the method Call_Part_Serial_Catalog___ to add if conditions when the transaction code is 'SERIAL IN' and to remove unnecessary assignment block.
--  200923  RoJalk  SC2020R1-1985, Modified Call_Lot_Batch_Master__, Call_Part_Serial_Catalog___ so the message text for 'SHIPODWHS-' and 'SHIPODSIT-' will be similar to internal customer order delivery.
--  200922  LEPESE  SC2021R1-291, adapted method Refresh_Activity_Info for Work Task transactions. 
--  200824  RoJalk  SC2020R1-9252, Added the new key parameters(ownership/project/delivery info) to Inventory_Part_In_Transit_API.Remove_From_Order_Transit/Unreceive_Part_To_Transit method calls.
--  200825  ErRalk  SC2020R1-1985, Added new error code SHIPODPSCPICKIN for Shipment Order in Get_Serial_Message___() and modified Call_Part_Serial_Catalog___() and Call_Lot_Batch_Master__() accordingly.
--  200728  RasDlk  Bug 154346 (SCZ-10369), Added the new method Dir_Del_Non_Serial_On_RMA___. Modified the method Serial_Processed_On_Order by adding the default parameter transaction_code_.
--  200728          Modified Call_Part_Serial_Catalog___ to call either Unissue or New_In_Inventory during 'OERETURN' transaction and to call New_In_Issued during 'OERET-SCP' transaction
--  200728          by checking whether the CO connected to the RMA have being delivered without a serial number when the supply code is Purchase Order Dir and 
--  200728          the Stop Creation of New Serials in RMA is unchecked. Also checked whether the serial entered exists or not before calling the above two methods.
--  200727  BudKlk  Bug 154810(SCZ-10801), Modified method Get_Sum_Quantity introducing two parameters to consider expiration_date_ and ignore_expiration_date_ to get the correct calculation for sum quantity.
--  200611  LEPESE  SC2021R1-294, Removed unused methods Is_Issued_On_Work_Order and Check_Work_Order_Transaction since no reference to these ones since apps 8.
--  200611          Changes in Call_Part_Serial_Catalog___, Call_Lot_Batch_Master__ and Get_Serial_Message___ to support the new Work Task transactions.
--  200604  WaSalk  GESPRING20-4345, Added delivery_resaon_id_ as default null parameter to Modify_Delivery_Info().
--  200527  ErRalk  SC2020R1-2094, Modified Call_Lot_Batch_Master__() and Call_Part_Serial_Catalog___() to support cancellation of shipment order receipt for serial and lot tracked parts.
--  200519  ErRalk  SC2020R1-2094, Modified Get_Site_And_Warehouse_Info___ method to return dafault values for delivering warehouse and receiving warehouse 
--  200519          when the receiver and sender type is not a remote warehouse.
--  200511  ErRalk  SC2020R1-2094, Modified Cancel_Order_Receipt to support Receipt cancellation for shipment order receipt.   
--  200324  BudKlk  Bug 152368(SCZ-8891), Modified the method Modify_Connected_Trans_Date___() to retrive multiple transaction ids from Invent_Trans_Interconnect_API.Get_All_Connected_Trans_id_Tab().
--  200311  DaZase  SCXTEND-3803, Small change in Create_Data_Capture_Lov to change 1 param in call to Data_Capture_Session_Lov_API.New.
--  200306  WaSalk  GESPRING20-3889, Removed Reverse_Transaction___() added code by GESPRING20-1776.
--  200202  KHVESE  SCSPRING20-1749, Renamed method Get_Purch_Receipt_Serials___ to Get_Order_Receipt_Serials___and Modified it to include 'SHIPODSIT+', 'SHIPODWHS+'
--  200202          SCSPRING20-1749, Renamed method Get_Pur_Rec_Serial_Count___ to Get_Order_Rec_Serial_Count___ and made it generic by adding source_ref_type_ to the method's 
--  200202          SCSPRING20-1749, Renamed method Get_Pur_Receipt_Serial_Count to Get_Order_Receipt_Serial_Count and made it generic by adding source_ref_type_ to the method's 
--  200219  Kagalk  GESPRING20-1795, Added delnote_no_, delnote_date_ to New method, Added Modify_Delivery_Info method.
--  200217  KHVESE  SCSPRING20-674, Modified methods Call_Part_Serial_Catalog___, Calc_Plus_Dir_Trans_Cost___, Call_Lot_Batch_Master__, Insert___ and Get_Serial_Message___ to support SHIPODSIT+, SHIPODWHS+, UNR-SHPODW and UNR-SHPODS.
--  200211  WaSalk  GESPRING20-1793, Added Delivery Reason attribute to New() methods.
--  200210  WaSalk  GESPRING20-1776, Modified Reverse_Transaction___() to call Modify_Date_Applied() if localization added.
--  200206  kusplk  GESPRING20-1792, Added method Modify_Delivery_Info to update DeliverReson,DelnoteDate and AltDelNoteNo.
--  200117  SBalLK  Bug 151864(SCZ-8504), Modified Cancel_Order_Receipt() to avoid create 'UNRCPT' transaction for purchase order direct delivery('PURDIR', 'INTPURDIR') transactions.
--  200116  RasDlk  SCSPRING20-984, Modified Post_Booking_Actions___ to support SHIPODSIT-.
--  200116  DIPELK  GESPRING20-1773, Added genaric method Modify_Date_Applied in order to modify applied date by source ref 
--  200116  DIPELK  GESPRING20-1773, Modified  method Modify_Connected_Trans_Date___ in order to support localization functionality modify_date_applied.
--  200109  PAMMLK  MFSPRING20-381, Added new parameter ownership_transfer_reason_id_ to New(). 
--  200107  NISMLK  MFSPRING20-712, Added Check_Part_Ownership_Transfer___ method to validate ownership transfer reason.
--  200107  NISMLK  MFSPRING20-712, Added Check_Material_Ownership_Transfer___ method to validate ownership transfer reason.  
--  200103  NISMLK  MFSPRING20-812, Added new parameter ownership_transfer_reason_id_ to New().
--  191227  RasDlk  SCSPRING20-984, Modified Calc_Minus_Dir_Trans_Cost___ to support SHIPODSIT-.
--  191220  Navdlk  MFZ-3065 Bug 151520, Modified Actual_Cost_Transactions_Exist to filter out transactions only for Company_Owned Parts. 
--  191219  DaZase  Bug 151456 (SCZ-8111), Changed the dynamic selects in methods Create_Data_Capture_Lov, Get_Column_Value_If_Unique and
--  191219          Record_With_Column_Value_Exist to increase performance. Also changed Get_Column_Value_If_Unique to have distinct select and 
--  191219          'FETCH FIRST 2 ROWS ONLY' statement and use a collection instead of having a loop to increase performance.
--  191206  PamPlk  Bug 151151 (SCZ-7975), Modified Call_Part_Serial_Catalog___and Call_Lot_Batch_Master__ by including transaction UNCODELVIN and UNCODELVOU.
--  191209  DaZase  SCXTEND-1005, Changed the dynamic selects in methods Create_Data_Capture_Lov, Get_Column_Value_If_Unique and
--  191209          Record_With_Column_Value_Exist to increase performance. Also changed Get_Column_Value_If_Unique to have distinct select and 
--  191209          'FETCH FIRST 2 ROWS ONLY' statement and use a collection instead of having a loop to increase performance.
--  191127  RoJalk  SCSPRING20-984, Modified Call_Part_Serial_Catalog___, Call_Lot_Batch_Master__ to support SHIPODSIT-.
--  191114  UdGnlk  Bug 150811 (SCZ-7354), Modified Get_Transaction_Curr_Info___() to pass receipt_no to receive purchase order.
--  191007  SURBLK  Bug SCSPRING20-102, Added Get_Serial_Message___ to handle error messages and avoid code duplication.
--  190802  NiDalk  Bug 149058(SCZ-5668), Modified Get_Sum_Quantity to ignore source_ref5_ and handling_unit_id_ when they don't have values.
--  190719  AmPalk  Bug 146843, Merged.
--  190719          Bug 146843, Modified Call_Shop_Order_Receipt___ () to pass FALSE for the update_structure_ parameter in the call to Set_Serial_Ownership() 
--  190119          to prevent updating ownership of the entire structure.
--  190710  Asawlk  Bug 149020(PJZ-2015), Added method Get_Source_Ref_By_Acc_Id.
--  190527  Cpeilk  Bug 148336 (SCZ-4921), Modified Make_Po_Invoice_Balance_Trans to ignore Balance invoice rounding for 3rd currency scenarios.
--  190524  ShPrlk  Bug 145072, Modified Call_Part_Serial_Catalog___ to set ownership correctly for transaction code ARRTRAN.
--  190419  Asawlk  Bug 145704, Added method Validate_Subsequent_Trans___. Modified Reverse_Transaction___ by calling Validate_Subsequent_Trans___ for old transaction directions '+' and '-' .  
--  190330  Cpeilk  Bug 146663 (SCZ-3816), Modified Make_Po_Invoice_Balance_Trans to call method Get_Val_Qty_Bal_Invoice_Rnd___ which will give arrival values of M10 postings only.
--  181103  Cpeilk  Bug 143550, Modified Make_Po_Invoice_Balance_Trans to handled NULL before calling Make_Po_Line_Diff_Transaction.
--  181020  Cpeilk  Bug 143550, Added method Get_Returned_Suppl_Consignment to get the total unissued and returned due to counting consignment quantity for a receipt.
--  181020          Modified Make_Po_Invoice_Balance_Trans to consider consignment stock unissue and returns by using COUNSUCONS and CO-RETURN transactions.
--  181020          Passed TRUE for price_diff_for_balinvrou_ indicate BALINVROU transaction. Modified WHERE condition to add alt source ref keys to handle 'RETPODIRSH' and 'RETPODSINT' transactions 
--  181020          to handle direct supplier returns. Also handled price diff postings when standard cost part changed to transaction based part creating price diff.
--  180825  NiLalk  Bug 143646, Modified Call_Part_Serial_Catalog___ method by adding eng_part_revision variable, obtaining value for it and passed it to Part_Serial_Catalog_API.New_In_Inventory, 
--  180825          Move_To_Inventory and Unissue methods to add or update engineering part revision.
--  180824  Cpeilk  Bug 143550, Modified Make_Po_Invoice_Balance_Trans to balance the transaction currency by calculating currency difference and creating new posting lines for BALINVROU transaction.
--  180811  RasDlk  Bug 143514, Modified Call_Part_Serial_Catalog___ by changing the translatable constant PSCOPFEED-SCP.
--  180716  Cpeilk  Bug 140847, Added Make_Po_Invoice_Balance_Trans to calculate and create the balance invoice transaction amount and quantity for a particular purchase receipt.
--  180716          Also added Make_Po_Line_Diff_Transaction removing method from Transaction_Revaluation_API.Make_Diff_Transaction___.
--  180710  Asawlk  Bug 142597, Re-structured the method Get_Transaction_Curr_Info___ in a way, if it fails to get the currency information from mpccom accountings then to get the information from purchasing.
--  180504  Cpeilk  Bug 139605, Modified Create_Price_Diff_Postings___ to use inv quantity return method instead of calculating using conv factor.
--  180504  ShPrlk  Bug 141396, Modified Check_Invoice_Reval_Running___ by adding a condition to implement the locking depending on whether the method is executed online or background.
--  180504          Also modified the error message in the method to be more generic.
--  180220  SBalLK  Bug 138993, Modified Cancel_Order_Receipt() method to remove superior part connection from component part serials. Added Remove_Superior_Connection___() method
--  180220          before reversing the inventory transactions.
--  180129  TiRalk  STRSC-14368, Added new method Undo_Ord_Direct_Del_Serials___ by moving code from Call_Part_Serial_Catalog___ for transaction codes UNPODRINEM and POUNDIRSH.
--  171213  SHAFLK  STRSA-30588, Modified Call_Part_Serial_Catalog___ to allow Move to inventory for Work Return parts in Facility. 
--  171205  KHVESE  STRSC-9352, Modified calls to method Consume_Customer_Consignment and added an overload of method Get_Sum_Quantity.
--  171127  TiRalk  STRSC-14368, Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ by including transactions UNPODRINEM and UNINPODRIM.
--  171127  TiRalk  STRSC-13753, Modified Reverse_Transaction___ to move the goods back into transit upon undo delivery CO which creates transaction UNINPODRIM.
--  171116  TiRalk  STRSC-14369, Modified Reverse_Transaction___ by adding alt_source_references for reverse transactions when the direction is zero.
--  171109  SBalLK  Bug 138413, Added Check_Lot_Batch_In_Use() method to validate lot batch number is already used for the part in inventory transactions.
--  171110  KHVESE  STRSC-9352, Replaced all appearances of method Report_Consumed() to Consume_Customer_Consignment() due to method name change.
--  171107  Asawlk  Bug 138248, Modified Post_Booking_Actions___ by eliminating a duplicate code block and modified Condition_Code_Change_Reval___ to exit the method if the cost level of the transaction
--  171107          does not equal to 'COST PER CONDITION'.
--  171102  ChFolk  STRSC-14019, Modifed message constant PSCUNRCPTC in method Call_Part_Serial_Catalog___ to a different name (PSCPOUNDIRSH) as the same constant exists in Cancel_Order_Receipt with a different description.
--  171101  TiRalk  STRSC-13136, Modified Reverse_Transaction___ to move the goods back into transit upon undo delivery of external CO which creates transaction UNINTPODIR.
--  171030  KHVESE  STRSC-9352, Modified method Call_Lot_Batch_Master__ to call method Lot_Batch_Master_API.Report_Consumed when transaction code is CO-CONSUME and
--  171030          modified message description when transaction code is CO-DELV-OU.
--  171025  UdGnlk  Bug 137642, Modified Handle_Purch_Order_Line_Close() to include Undo transaction of UNREPSCRAP.
--  171024  TiRalk  STRSC-13735, Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ by including transaction UNSHIPDIR.
--  171023  TiRalk  STRSC-13136, Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ by including transaction UNINTPODIR.
--  171019  MAJOSE  STRMF-15603, Added functions Get_Sum_Qty_Received and Get_Sum_Qty_Issued.
--  171018  ErRalk  Bug 138010, Modified Call_Part_Serial_Catalog___ in order to check whether the latest transaction on part serial is reversed by Material Requisition unissue.
--  171013  RaNhlk  CAM-1137, Modified Reverse_Transaction___ to pass the correct transaction_id to Part_Serial_Catalog_API.Issue().
--  171010  TiRalk  STRSC-12296, Modified Call_Part_Serial_Catalog___, Call_Lot_Batch_Master__, Check_Contract___ and Get_Average_Intersite_Cost by including the reverse
--  171010          transactions UNINTREV, UNINTCOS, UNINTREVR, UNINTCOSR.
--  171010  UdGnlk  Bug 137642, Modified Handle_Purch_Order_Line_Close() to include Undo transactions of the previous build logic and removed the clause of quantity in cursor get_supplier_wip_acc_id.
--  171004  KHVESE  STRSC-9352, Modified method Call_Part_Serial_Catalog___ to call method Part_Serial_Catalog_API.Report_Consumed when transaction code is CO-CONSUME.
--  171003  TiRalk  STRSC-12293, Modified Call_Part_Serial_Catalog___, Calc_Zero_Dir_Trans_Cost___, Reval_Canc_After_Oh_Adjust___, Check_Contract___ and Call_Lot_Batch_Master__
--  171003          by including UNINTORDTR transaction to relevant places. Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ by including UNSHIPTRAN transaction.
--  170922  TiRalk  STRSC-12292, Renamed Reverse_Rintotrcor_Trans___ to Undo_Move_To_Order_Transit___. Modified Reverse_Transaction___ to handle reverse transaction UNINTORDTR.
--  170912  UdGnlk  Bug 136645, Modified Call_Part_Serial_Catalog___() and Call_Lot_Batch_Master__() and Post_Booking_Actions___() to introduce 'PURTRAN' transaction.
--  170911  TiRalk  STRSC-11806, Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ by changing history messages for PODIRSH, INTPODIRSH and POUNDIRSH.
--  170901  ChFolk  STRSC-11797, Modified Cost_Group_Changes_Exists___ to avoid numeric or value error.
--  170824  TiRalk  STRSC-10758, Reversed the correction of STRSC-10765. Modified Call_Part_Serial_Catalog___ to delete part serial record if it's initiated by same order reference
--  170824          or handle the part serial state properly if it is an existing part serial record. Modified Call_Lot_Batch_Master__ by handling the logic separately for POUNDIRSH.
--  170815  JoAnSe  STRMF-13748, Added new parameters lot_batch_no_, serial_no_, eng_chg_level_, waiv_dev_rej_no_, activity_seq_, handling_unit_id_ to Get_Sum_Qty_Received.
--  170808  ChFolk  STRSC-11197, Renamed parameters old_curr_amount_posting_tab_ and post_accumulated_curr_amt_ as pwa_curr_amount_posting_tab_ and post_accum_curr_amt_for_pwa_ 
--  170808          and variable accumulated_curr_posted_ as accum_curr_posted_for_pwa_ in Do_Booking___ and their usages. Renamed method Get_Cost_Group_Chg_For_Curr___ as Cost_Group_Changes_Exists___.
--  170726  TiRalk  STRSC-10765, Modified Call_Lot_Batch_Master__ to unissue lot tracking parts and Call_Part_Serial_Catalog___ to unissue serial parts for the transaction POUNDIRSH.
--  1707011 SHAFLK  STRSA-26792, Modified Call_Part_Serial_Catalog___ to allow Move to inventory for Work Return parts in Repair Workshop. 
--  170706  ChFolk  STRSC-9304, Modified Get_Arrival_Trans_Amounts___ to fetch the currency amount details for periodic weighted average parts.
--  170703  ChFolk  STRSC-9304, Added new method Do_Booking___ and copy the content from Do_booking. The new implementation method is calling from Update_Cost_For_Part
--  170703          to handle currency amount postings for periodic weighted average. Modified public methods of Do_Booking to use new implemetation method.
--  170703          Modified Update_Cost_For_Part to copy the old currency amount postings and use them to post with new postings for base surrency.
--  170703          Added new method Get_Pwa_Curr_Info___ which returns the transaction currency amount when periodic weighted average postings are created.
--  170703          Added new method Get_Cost_Group_Chg_For_Curr___ which determine if there is a change in posting cost group which is affected with curr amount postings.
--  170615  DAYJLK  STRSC-9028, Modified Get_Transaction_Curr_Info___ by replacing type declaration with Mpccom_Transaction_Code_API.Transaction_Code_Tab.
--  170602  ChFolk  STRSC-7108, Modified Do_Str_Event_Acc_Impl___ to remove unnessary calculation for local_curr_amount_ when trans_curr_rate_ = 0 which is no longer valid
--  170602          as now the return transactions after the cascade postings is supported for currency diff postings. 
--  170601  ChFolk  STRSC-7108, Renamed Create_Balance_Curr_Posting___ as Post_Curr_Diff_After_Reval___.
--  170530  ChBnlk  Bug 135688, Added new method Get_Handling_Unit_Row_Count() to check the number of rows that are using a particular handling_unit_id.
--  170529  ChFolk  STRSC-8610, Added new parameter receipt_curr_code_ to Create_Balance_Curr_Posting___ which is used in calling Do_Curr_Amt_Balance_Posting.
--  170516  ChFolk  STRSC-7925, Added new method Create_Balance_Curr_Posting___ to support currency amount postings when return. It is called from Do_Booking.
--  170509  ChFolk  STRSC-7741, Modified Get_Transaction_Curr_Info___ to handle po exchange flow for cascade postings where we need to get the current currency rate.
--  170508  ChFolk  STRSC-7108, Modified Cancel_Order_Receipt and Get_Sum_Amounts_For_Receipt to use suppl_mtrl_issue_trans_tab_ since all transaction codes are same.
--  170507  ChFolk  STRSC-7925, Modified Do_Str_Event_Acc_Impl___ to avoid devision by zero error when calculating local_curr_amount when transaction curr rate is zero. 
--  170503  ChFolk  STRSC-7583, Modified Get_Sum_Amounts_For_Receipt to add new parameter only_arrival_ which separate whether to consider only arrival cose or cascade costs as well.
--  170503  TiRalk  STRSC-7612, Modified Get_Transaction_Curr_Info___ to include consignment stock transactions.
--  170502  ChFolk  STRSC-7586, Modified Get_Transaction_Curr_Info___ to include direct delivery transactions to the condition which supports cascade postings.
--  170424  ChFolk  STRSC-7046, Added new OUT parameter curr_amount_detail_tab_  to Get_Arrival_Info_For_Delivery.
--  170412  ChFolk  STRSC-7108, Removed default parameter from method Get_Transaction_Curr_Info___ and modified logic to get currency information separately for transaction_revaluation.
--  170412          Modified Get_Sum_Amounts_For_Receipt to change the variable names.
--  170402  ChFolk  STRSC-4972, Added new method Get_Sum_Amounts_For_Receipt which returns posted sum amounts in both base and transaction currency.
--  170331  LEPESE  LIM-11352, Added code to replace NULL with zero for handling_unit_id in Cancel_Order_Receipt to support cancel of intersite-receipts.  
--  170331  SeJalk  STRSC-5395, Modified Revalue_Ret_Rework_Or_Cred___ to send correct source reference to method Get_Arrival_Cost_Value_Qty___ for the transaction code RETPODSINT.
--  170327  ChFolk  STRSC-4971, Modified method signature of Get_Arrival_Cost by adding curr_amount_detail_tab_ and arrival_qty_ as OUT parameters.
--  170320  LEPESE  LIM-11227, Corrected bug in Cancel_Order_Receipt by checking if serials exists before finding out if created by this receipt.
--  170320  UdGnlk  LIM-11222, Modified Cancel_Order_Receipt() to pass reserved_by_source_ to Transport_Task_API.Remove_Unexecuted_Tasks().
--  170317  NiDalk  Bug 134248, Modified Get_Purch_Order_Receipt_Date to support to get the receipt date for transactions from direct delivery or internal direct delivery.
--  170306  TiRalk  LIM-10949, Modified Cancel_Order_Receipt to validate the records only which has a handling_unit_id.
--  170219  tratlk  STRPJ-19941, Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master___ to support PD-SHIP transaction.  
--  170217  Chfose  LIM-10759, Reworked the snapshot functionality in Cancel_Order_Receipt to now validate the handling unit structure on the most outermost
--  170217          handling unit possible after all the transactions have been reverted.
--  170208  Chfose  STRSC-5033, Added missing filter for work order in Check_Work_Order_Transaction.
--  170207  Chfose  LIM-10534, Added snapshot functionality to Cancel_Order_Receipt & Cancel_Material_Backflush___ to try to keep handling units within the transactions intact.
--  170207  ErFelk  Bug 126856, Modified Get_Pur_Order_Charge_Cost___() by calling Inventory_part_In_Stock_API.Get_Company_Owned_Inventory() instead of Inventory_Part_In_Stock_API.Get_Inventory_Quantity
--  170207          to get the qty_onhand_ and qty_in_transit_ values. Modified Get_Accounting_Id_Tab___() to filter only the COMPANY OWNED transactions.
--  170207  ChFolk  STRSC-5707, Added new procedure Get_Arrival_Cost_For_Delivery which returns both curr_amount_detail_tab and arrival_cost together.
--  170201  DAYJLK  STRSC-5671, Added method Get_Consumed_Comp_Curr_Details.
--  170120  ChFolk  STRSC-4948, Modified Do_Str_Event_Acc_Impl___ to handle curr_amount calculation inside the method. Modified Balance_Po_Exchange_Cost___, Create_Po_Return_Price_Diff___
--  170120          and Create_Price_Diff_Postings___ to add curency infomation as IN parameters.
--  170119  Chfolk  STRSC-5332, Added new methdo Get_Sum_Curr_Amount_Details retruns Curr_Amount_Detail_Tab for the given source_ref details and str_code. 
--  170119          Modified Create_Stage_Pay_Postings___ to calculate average rate for transaction currency when handling BALRETSP transaction in stage payments.
--  170109  SAALLK  STRPJ-16949, Removed obsolete method Get_Pur_Rec_Nonstocked_Serials.
--  170106  ChFolk  STRSC-5303, Added transaction currency info as new IN parameters to the method Do_Str_Event_Acc_Impl___. Modified methods Do_Booking,
--  170106          Balance_Po_Exchange_Cost___, Create_Po_Return_Price_Diff___, Create_Price_Diff_Postings___ and Create_Stage_Pay_Postings___
--  170106          to calculate transaction currency information.
--  170104  DAYJLK  STRSC-4946, Added new parameters to method Get_Arrival_Cost_Value_Qty___, Set_Original_Amount___, Create_Stage_Pay_Postings___, Get_Arrival_Trans_Amounts___
--  170104          Add_Reverse_Return_Pwa_Diff___, Get_Arrival_Cost, Get_Arrival_Value_And_Qty, Get_Arrival_Cost_For_Delivery, and Get_Arrival_Info_For_Delivery.
--  161229  tratlk  STRPJ-19054, Added Get_Sum_Qty_Scrapped_In_Invent to get scrapped quantity in project inventory
--  161219  ChFolk  STRSC-5229, Modified Get_Transaction_Curr_Info___ and Do_Str_Event_Acc_Impl___ to do code re-structuring.
--  161207  ChFolk  STRSC-5086, Created new method Get_Transaction_Curr_Info___ and moved code for retrieving transaction currency info inside Do_Str_Event_Acc_Impl___.
--  161207          Also removed M6 from the list of posting types as it is not related to 2455 account.
--  161205  ApWilk  Bug 132700, Modified Call_Part_Serial_Catalog___() to return a serial into the inventory through a RMA when the serial is in 'InFacility'.
--  161202  ChFolk  STRSC-4991, Modified Do_Str_Event_Acc_Impl___ to support direct deliveries and direct delivery returns.
--  161201  ChFolk  STRSC-4986, Modified Do_Str_Event_Acc_Impl___ to support return transaction with arrival currency rate instead of currenct currency rate.
--  161130  ChFolk  STRSC-4942, Modified Do_Str_Event_Acc_Impl___ to handle Standard Cost parts.
--  161128  ChFolk  STRSC-4941, Modified Do_Str_Event_Acc_Impl___ to store the transaction currency information for curr_amount, currency_code, currency_rate and conversion_factor.
--  161128          Modified Redo_Transaction_Postings___ to store the previous value for curr_amount when redo posting is done.
--  161101  ShPrlk  Bug 132081, Modified Check_Contract___() in order to ignore the user allowed site validation when transaction codes is INVM-TRIN.
--	161005	Chfose	LIM-3661, Added Check_Handling_Unit_Exist.
--  160930  SeJalk  Bug 131162, Modified Get_Rma_Multi_Site_Return_Qty to reurn the total quantity returns against the receipt if Serial no, lot batch no and wdr no is not passed..
--  160929  LEPESE  LIM-8882, Added value for parameter handling_unit_id_ in call to method Inventory_Part_In_Stock_API.Get_Serial_No_For_Stock.
--  160923  ChBnlk  Bug 131024, Modified Get_Purch_Comp_Consume_Trans() by adding a NULL check for source_ref4_ in the cursor get_purch_comp_consume_trans and
--  160923          modified Reval_WA_Supplier_Shipment() by removing the quantity check that had been used to raise the exception exit_procedure_ and added PURBKFL.
--  160922  TiRalk  Bug 131311, Modified the error message 1230 in method New() by adding additional information.  
--  160920  RAEKLK  STRPJ-16646, Added Get_Pur_Rec_Nonstocked_Serials method to get non-stocked(unreceived/returned/scrapped)serial nos for a specific purchase order receipt.
--  160905  NISMLK  STRMF-6613, Modified Call_Shop_Order_Receipt___ method to update manufactured_date field from the value in manufactured_date in ShopOrd LU for OOREC transaction code.
--  160824  SWeelk  Bug 130465, Modified the return type of Get_Ext_Service_Comp_Trans___ to Transaction_Id_Tab. Modified Get_Ext_Service_Comp_Cost___ to handle the cost details from 
--  160824          multiple transactions and calculated a weighted average value. 
--  160824  JeeJLK  Bug 130281, Modified Cancel_Order_Receipt to forcibly delete renamed serial if the Serial no combination was originated from the same order in the receipt. 
--  160819  SWiclk  Bug 131000, Modified Cancel_Order_Receipt() in order to pass value for expiration date when calling Inventory_Part_In_Stock_API.Unissue_Part().
--  160816  LEPESE  LIM-7892, Added parameter validate_hu_struct_position_ to Reverse_Transaction___ and passed values for inventory_event_id_ and 
--  160816          validate_hu_struct_position_ in call to Inventory_Part_In_Stock_API.Receive_Part. Added parameter validate_hu_struct_position_ to Reverse_Transaction
--  160816          and passed value in call to Reverse_Transaction___.
--  160728  LaThlk  Bug 130029, Modified Check_Contract___() in order to ignore the user allowed site validation when transaction code in 'RETINTPODS' or 'RETPODIRSH'.
--  160719  Jhalse  LIM-7789, Added inventory_event_id to Reverse_Transaction()
--  160706  SWeelk  Bug 129929, Modified New() by checking project acesss only for transactions 'PROJTRAN+', 'PROJTRAN-'.
--  160624  ChJalk  Bug 129628, Modified Call_Part_Serial_Catalog___ to change the part ownership in part serial catalog to COMPANY OWNED if the transaction code is 'RETINTPODS'.
--  160621  NaLrlk  LIM-7750, Modified Create_Price_Diff_Postings___() to redirect Inv_Purchase_Receipt_API call to Receipt_Info_API.
--  160526  BudKlk  Bug 129342, Modified the method Get_Accting_Value_Latest_Trans() to check the data base value of source_ref_type with the encoded client value in order to 
--  160526          get to correct standarad_price value for the posting generation.
--  160525  DAYJLK  Bug 126008, Modified Call_Part_Serial_Catalog___ to set ownership information on serial for transaction WOUNISS.
--  160503  MeAblk  Bug 128650, Added new parameter waiv_dev_rej_no_ into the method Get_Rma_Multi_Site_Return_Qty() to correctly get the rma qty by considering waiv_dev_rej_no.
--  160324  JeeJlk  Bug 128154, Introduced a new parameter use_trans_date_applied_ to Reverse_Accounting method to stop resetting the date_applied from system date when calculating PWA.
--  160218  ThEdlk  Bug 125487, Modified Modify_Date_Applied___() by passing reapply_old_date_applied_ argument appropriately to Update___() and Check_Update___().
--  160202  Cpeilk  Bug 124968, Modified Handle_Purch_Order_Line_Close() to check for the remainder of the posted values instead of created transaction costs upon creating 
--  160202          "CLEAR-WIP+" or "CLEAR-WIP-" transactions to balance M15.
--  160201  ErFelk  Bug 124683, Modified Get_Poinv_Wip_Trans_Cost___() and Get_Po_Line_Qty_Received___() by removing source_ref_4_ parameter.
--  160201          Restructured the method Get_Po_Line_Qty_Received___() by writing a cursor to get the Qty_Received. 
--  160122  ThEdlk  Bug 125487, Modified Modify_Date_Applied___() to reapply date_applied to the same date by allowing a new parameter 'reapply_old_date_applied_' to be passed to Update___()and Check_Update___().
--  160112  ErFelk  Bug 126435, Modified Reverse_Transaction___() to pass TRUE for replace_star_cost_bucket_ upon calling Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details()
--  160112          only if the part is an inventory part. 
--  160105  KiSalk  Bug 126278, Added new overloaded method Trans_With_Ownership_Exist with 8 parameters.
--  160105  AwWelk  STRSC-578, Bug 124047, Modified Call_Lot_Batch_Master__ to handle 'OWNTRANOUT' and 'UNRCPT+'. Added new parameter original_transaction_id_ to 
--  160105          Call_Lot_Batch_Master__. Replaced the usages of INVM-IN and INVM-ISS with LOT-IN and LOT-OUT transactions in lot_batch context. Also handled 
--  160105          Consignment stock in lot batch context.
--  160104  PrYaLK  Bug 124271, Modified Call_Lot_Batch_Master__() to insert expiration_date_ when creating new Lot Batch master record, when the original_trans_code_ is 'ARRIVAL',
--  160104          'CO-ARRIVAL', 'ARR-COMP','SERLOTSWAP', 'PARTSWAP', 'NREC', 'WORECEIPT', 'COUNT-IN', 'PSRECEIVE', 'SERIAL-IN' and 'CROREC'.
--  151209  JeLise  STRSC-495, Added @UncheckedAccess to function Get_Returned_Rental_Qty.
--  151117  Erlise  LIM-4317, Added handling_unit_id to Create_Data_Capture_Lov, Get_Column_Value_If_Unique and Record_With_Column_Value_Exist.
--  151110  UdGnlk  LIM-3750, Removed pallet_id column from Purch_Receipt_Pallet_Rec/Purch_Receipt_Pallet_Tab since pallet functionality will be obsolete.   
--  151103  UdGnlk  LIM-3671, Removed Pallet entity related logic, hence removed Check_and_Remove_Pallets___(), Set_Pallet_Id()  
--  151030  Maeelk  Renamed order_type as source_ref_type at the cursor get_consumed_total_comp_values in Get_Consumed_Tot_Comp_Value
--  151020  JeLise  LIM-3893, Removed check on pallet related location types in Cancel_Order_Receipt.
--  151019  Chfose  LIM-3893, Removed pallet location types from validation in Get_Sum_Value_Order_Line.
--  150911  JoAnSe  AFT-4741, Added transaction_id to the order by clause in the cursor get_period_part_trans in Update_Cost_For_Part.
--  150910  JoAnSe  AFT-4136, Receipts from open shop orders not counted in Get_Actual_Cost_Receipts
--  150908  Vwloza  Added Get_Returned_Rental_Qty().
--  150901  AyAmlk  Bug 114937, In order to transfer the value trans_reval_event_id from TransactionRevalution to the MpccomAccounting postings, added a new parameter to 
--  150901          set of methods and passed the value accordingly.
--  150901  NipKlk  Bug 123738, Modified the error message under constant MOVERD to be more meaningful in the method Cancel_Order_Receipt().
--  150831  ErFelk  Bug 122622, Converted the implementation fuction Get_Consumed_Tot_Comp_Value___ to public with name Get_Consumed_Tot_Comp_Value.
--  150831  DaZase  AFT-2670, Added condition_code to Create_Data_Capture_Lov, Get_Column_Value_If_Unique and Record_With_Column_Value_Exist.
--  150825  MAHPLK  KES-1343, Added new parameter source_ref5_ to Check_Order_Transaction() and Check_Order_Exist() methods. --  150822  ErFelk  Bug 120380, Changed method Get_Avg_Charge_On_Receipt___() into public having name Get_Avg_Charge_On_Receipt().
--  150821  ErFelk  Bug 117650, Modified methods New() and Update_Cost_For_Part() by adding the cost_source 'INVOICE IMBALANCE' to the conditions to behave as 'PRICE DIFFERENCE'.
--  150820  MAJOSE  MONO-404, Changes in Get_Actual_Cost_Receipts to not consider Repair Shop Orders.
--  150818  DaZase  COB-712, Changes in Create_Data_Capture_Lov, Get_Column_Value_If_Unique and Record_With_Column_Value_Exist to match the changes made in KESHI project, 
--  150818          so order_no_ is changed to source_ref1_ and line_item_no_ is changed to source_ref4_.
--  150727  Disklk  Bug 121762, Modified Refresh_Activity_Info___,Transfer_To_Finance___,Redo_Error_Postings___ to pass values to transfer_to_fianance_ and transfer_to_finance_date_ 
--                  when calling method Inventory_Transaction_Hist_API.Refresh_Activity_Info.
--  150723  Asawlk  Bug 122382, Modified Intersite_Profit_Reval___ to calculate the unit_cost of the part in destination site when UoM is different in source and destination sites
--  150709  MAHPLK  KES-905, Modified Reverse_Transaction___ for pass the deliv_no_ as parameter to Inventory_Part_In_Stock_API.Receive_Part().
--  150706  IsSalk  KES-905, Code restructuring.
--  150703  IsSalk  KES-921, Corrected database invalids.
--  150701  LEPESE  LIM-3099, added handling of transaction codes HANDLUNIT-, HANDLUNIT+, CO-HANDLU- and CO-HANDLU+ in Call_Part_Serial_Catalog___, 
--  150701          Call_Lot_Batch_Master__, Calc_Plus_Dir_Trans_Cost___ and Calc_Minus_Dir_Trans_Cost___.
--  150723          for INTCOSR transaction.
--  150622  NaSalk  RED-543, Added Set_Fa_Object_Ref_On_Serial___. Modified Call_Part_Serial_Catalog___ 
--  150622          to set FA object references for transaction codes ARRIVAL,SERIAL-IN, COTOCRA+.
--  150602  JaBalk  RED-361, Added default null parameters part_ownership_db_ and location_no for Get_Latest_Transaction_Id.
--  150527  DaZase  COB-439, Changed Create_Data_Capture_Lov to handle new version of Data_Capture_Session_Lov_API.New and the new set of parameters it needs.
--  150520  DaZase  COB-437, Removed 100 record description limitation in method Create_Data_Capture_Lov, 
--  150414  LEPESE  LIM-88, added handling_unit_id as a new attribute.
--  150406  IsSalk  KES-594, Added new parameter source_ref5_ to Call_Lot_Batch_Master__() to unissue lot tracking parts for the transaction OEUNSHIP.
--  150406  IsSalk  KES-517, Added new parameter source_ref5_ to Call_Part_Serial_Catalog___() to unissue serial parts for the transaction OEUNSHIP.
--  150512  MAHPLK  KES-403, Renamed attribute OrderType to SourceRefType.
--  150512  IsSalk  KES-422, Added new parameter source_ref5_ to method Create_And_Account().
--  150512  IsSalk  KES-421, Added new parameter source_ref5_ to method New().
--  150512  MAHPLK  KES-402, Renamed attributes OrderNo, ReleaseNo, SequenceNo, LineItemNo to SourceRef1, SourceRef2, SourceRef3, SourceRef4.
--  150520          this will be replaced with a new configurable LOV record limitation in WADACO framework.
--  150519  JoAnSe  MONO-186, Added Get_Shop_Ord_Variance_Detail.
--  150420  DaZase  COB-18, Added methods Create_Data_Capture_Lov, Get_Column_Value_If_Unique and Record_With_Column_Value_Exist.
--  150410  JoAnSe  MONO-186, Added Get_Shop_Ord_Scrap_Detail.
--  150323  JoAnSe  MONO-109, Changes in Intersite_Move_Revaluation___ and Intersite_Profit_Reval___ to handle Periodic Weighted Average parts.
--  150318  Vwloza  RED-63, Added Get_Part_Ownership_DB() and Get_Part_Ownership().
--  150309  CPriLK  ANPJ-22, Removed the object_staus from project_connection_util_api related method calls.
--  150114  BudKlk  Bug 120531, Modified method Call_Shop_Order_Receipt___() in order to change the part_ownership by calling Part_Serial_Catalog_API.Set_Serial_Ownership(). 
--  141208  AwWelk  GEN-239, Modified New() to call Inventory_Part_API.Add_Issue_For_Decline_Expired() when it is an inventory issue and when the lifecycle stage in
--  141208          Decline or Expired state.
--  141205  RasDlk  Bug 119288, Added Consign_Consump_Trans_Exist___(), Suppl_Consignment_Consumpt___() and Unconsumed_Consign_Receipt___().
--  141205          Modified parameter list of Get_Arrival_Trans_Amounts___() and changed logic in order to get the average of COSUPCONSM transactions not CO-ARRIVAL 
--  141205          when the part is consignment and goods are consumed. Modified Get_Arrival_Cost_Value_Qty___() and Set_Original_Amount___() in order to call Get_Arrival_Trans_Amounts___()  
--  141205          with correct parameters. Modified Purchase_Order_Receipt___() by adding a parameter include_supplier_consignment_ in order to decide whether to consider CO-ARRIVAL or not. 
--  141203  Chfose  PRSC-4368, Modified Set_Cost to get costs via Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details if there is an original transaction id.
--  141119  NiDalk  Bug 119747, Modified cursor get_transactions of Get_Avg_Charge_On_Receipt___  to not to include records with PART_OWNERSHIP as 'SUPPLIER OWNED'.
--  141107  LEPESE  PRSC-2214, Removed the Overtake of method Insert___ and replaced with Override.
--  141106  LEPESE  PRSC-2214, Added new attribute availabity_control_id_ as parameter to method New(). Passed availability_id_ as a new parameter
--  141106          when calling Inventory_Part_In_Stock_API.Receive_Part from Reverse_Transaction___.
--  141028  AwWelk  GEN-158, Modified New() to update the DECLINE_ISSUE_COUNTER and EXPIRED_ISSUE_COUNTER in inventory part.
--  141014  Disklk  Bug 119009, Changed function name Get_Max_Untransf_Date_Applied to Get_Max_Date_Applied.
--  141009  SWiclk  PRSC-3949 (Bug 116991), Modified Get_Pur_Order_Charge_Cost___() by replacing the method call Receive_Purchase_Order_API.Get_Receipt_Charge_Price() with 
--  141009          Purchase_Receipt_Charge_API.Get_Charge_For_Inventory_Trans().
--  140912  NaSalk  Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ to include transaction codes CRATOCO+ and CRATOCO-.
--  140912  Asawlk  PRSC-1950, Replaced the usages of Mpccom_Accounting_API.Control_Type_Key_Rec with local variables or parameters of same type. Also removed the obsolete version of
--  140912          overloaded method Do_Str_Event_Acc().
--  140829  UdGnlk  PRSC-1057, Modified Check_Insert___() error messages EVACTIVITYSEQERROR and EVTRANSACTIONCODEERROR spelling mistakes.
--  140828  NaSalk  Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ to include transaction codes COTOCRA+ and COTOCRA-.
--  140825  Cpeilk  Bug 118411, Modified Call_Part_Serial_Catalog___ to move In Facility serials into inventory for transaction codes SERLOTSWAP and PARTSWAP.
--  140725  SWiclk  Bug 117657, Modified Get_Rejected_Purch_Receipt_Qty() in order to select records when to_date_applied_ is null.
--  140708  IsSalk  Bug 117761, Modified Balance_Po_Exchange_Cost___() in order to balance PO Exchange Cost Correctly according to the applicable currency and it's no of decimals in amount.
--  140620  IsSalk  Bug 113974, Modified Calc_Zero_Dir_Trans_Cost___() in order to transfer standard cost per configuration from one site to another in intersite flows.
--  140619  RaNhlk  Bug 116210, Modified Call_Shop_Order_Receipt___() and Call_Part_Serial_Catalog___() by passing configuration_id_ when calling Part_Serial_Catalog_API.Unissue().
--  140617  UdGnlk  PRSC-1062, Modified Call_Part_Serial_Catalog___(), Call_Lot_Batch_Master__(), Post_Booking_Actions___(), Condition_Code_Change_Reval___() and
--  140617          Calc_Zero_Dir_Trans_Cost___() to include CONDCHGCU+ and CONDCHGCU- posting types for invenory part at customer functionality.
--  140613  AwWElk  PRSC-1451, Modified Get_Sales_Overhead_Details___() by adding conditional compilation for ORDER methods.
--  140612  Jeguse  PRPJ-539, Modified Refresh_Activity_Trans_Cost___, Handle_Activity_Transfer___ and added Refresh_Connection
--  140508  UdGnlk  PBSC-9031, Merged bug 112507, Added the parameter periodic_weighted_avg_calc_ to Do_Booking().
--  140508          Added the new column original_amount and modified INVENTORY_TRANSACTION_HIST view, Unpack_Check_Insert___(), Insert___(), Unpack_Check_Update___()
--  140508          and Update___(). Added the new methods Get_Arrival_Trans_Amounts___ (), Set_Original_Amount___ () and modified Get_Arrival_Cost_Value_Qty___(),
--  140508          Revalue_Ret_Rework_Or_Cred___(), Update_Cost_For_Part(), Get_Arrival_Value_And_Qty(), Get_Arrival_Cost_For_Delivery(), Get_Arrival_Info_For_Delivery() to use the 
--  140508          original transaction amounts when calculating purchase diff for periodic weighted average parts. Modified all the methods Get_Arrival_Cost_Value_Qty___()
--  140508          is called to adjust parameters passed in reference-by-name format and removed the default option of serial_no_ in the same method.
--  140508          Added Add_Reverse_Return_Pwa_Diff___() to include INVREVAL+/-  when calculating the purchase diff when the transactions are aggregated.
--  140508          Modified Reverse_Transaction___() and Revalue_Ret_Rework_Or_Cred___() to calculate price diff and absorbed into Cum Price Diff.
--  140508          Added the parameter periodic_weighted_avg_calc_ to Do_Booking(), Post_Booking_Actions___() and modified them and
--  140508          Update_Cost_For_Part() to indicate whether to calculate the price diff or not for return transactions.
--  140424  UdGnlk  PBSC-8475, Merged Bug 111740, Modified Call_Part_Serial_Catalog___() method when the original_trans_code_ is 'PODIRSH', to set the
--  140424          current position to 'Issued' when a serial is delivered through the intersite flow where supply and demand sites belong to different companies.
--  140423  Chselk  PBPJ-3085, Modified Get_Activity_Transfer_Cost___ to fetch the values regardless of the accounting status when fetching earned value. 
--  140408  Cpeilk  Bug 114430, Modified Check_Serial_Tracking___ to check renamed serials backwards to find whether it is processed from the particular purchase order.
--  140327  ErFelk  Bug 113207, Added function Trans_Exist_For_Activity_Seq().
--  140314  MaEdlk  Bug 115505, Added Pragma to the method Clear_Onhand_Develop_Globals.
--  140124  Asawlk  Bug 114556, Added function Get_Max_Untransf_Date_Applied.
--  131128  ErFelk  Bug 113889, Modified the code block under original_trans_code_ 'WORECEIPT' of Call_Part_Serial_Catalog___() by removing the call to   
--  131128          Part_Serial_Catalog_API.Set_Serial_Ownership() from current_position_ 'Issued' and placed it unconditionally at the beginning of that same code block.  
--  130925  JanWse  Bug 110613, Modified Call_Part_Serial_Catalog___() to set the current position to 'Issued' when a serial is delivered through the intersite flow where
--  130925          supply and demand sites belong to different companies.
--  130917  PraWlk  Bug 99627, Modified New() by calling Inventory_Part_Fifo_Issue_API.Get_Total_Issued_Quantity() instead of Issue_Info_Exist().
--  130917  Asawlk  Bug 112469, Modified Call_Part_Serial_Catalog___() by passing configuration_id_ when calling Part_Serial_Catalog_API.Move_To_Inventory().  
--  130912  Asawlk  Bug 102707, Added parameter serial_no to both overloaded versions of Get_Arrival_Cost_Value_Qty___() and used it when extracting data in cursors 
--  130912          get_trans_info_primary_source and get_trans_info_alt_source. Also modified Revalue_Ret_Rework_Or_Cred___() by passing serial_no when calling
--  130912          Get_Arrival_Cost_Value_Qty___().
--  130829  ChBnlk  Bug 109847, Modified Call_Part_Serial_Catalog___() to retrieve buyer_code and currency_code using Purchase_Order_API and 
--  130829          passed them to the method call Part_Serial_Catalog_API.New_In_Inventory().
--  130625  ErFelk  Bug 109671, Removed the NVL in cursor get_old_postings in method Redo_Transaction_Postings___(). 
--  130612  ErFelk  Bug 109671, Modified Do_Str_Event_Acc_Impl___() by passing conversion_factor to Do_Accounting() method call. Removed currency_code_ and currency_rate_ 
--  130612          from Handle_Modify_Date_Applied___, Redo_Transaction_Postings___() and Redo_Error_Booking().
--  130920   MADGLK Black-746 Replace conditional compilation that refers PCM.
-- ----------- Black Pearl----------------------------------------------------
--  130828  Asawlk  TIBE-2517, Removed calls to obsolete method Mpccom_Accounting_API.End_Booking. 
--  130812  MaRalk  TIBE-887, Removed following global LU constants, used conditional compilation instead and modified relevant methods accordingly. 
--  130812          inst_StandardCostBucket_ - Get_Mtrl_Overhead_Details___, Get_Sales_Overhead_Details___. inst_PurchaseOrderLinePart_ - 
--  130812          Call_Part_Serial_Catalog___, Create_Stage_Pay_Postings___, Refresh_Activity_Info. inst_PurOrderExchangeComp_ - Balance_Po_Exchange_Cost___. 
--  130812          inst_PurchaseOrderLine_ - Balance_Po_Exchange_Cost___. inst_ReceiptInventoryLocation_ - Check_and_Remove_Pallets___. 
--  130812          inst_Supplier_ - Check_Owning_Vendor_No___, Cancel_Order_Receipt. inst_CustOrdCustomer_ - Check_Owning_Customer_No___. 
--  130812          inst_PurchaseOrder_ - Cancel_Order_Receipt. inst_CustomerOrderLine_ - Refresh_Activity_Info. inst_ShopOrd_ - Call_Lot_Batch_Master__, 
--  130812          Refresh_Activity_Info. inst_CustomerOrder_ - Call_Part_Serial_Catalog___. inst_Activity_ - Insert___. inst_ReceivePurchaseOrder_ - 
--  130812          Create_Price_Diff_Postings___, Get_Pur_Order_Charge_Cost___. inst_ReturnMaterialLine_  - Call_Part_Serial_Catalog___, 
--  130812          Call_Lot_Batch_Master__. inst_ProjectConnectionUtil_ - Refresh_Activity_Trans_Cost___, Handle_Activity_Transfer___. inst_ProjectMiscProcurement_ - 
--  130812          Refresh_Activity_Info. inst_PurchaseOrderMilestone_ - Create_Stage_Pay_Postings___. inst_VimSerial_ - Cancel_Order_Receipt. 
--  130812          Removed unused global LU constants inst_PurOrdChargedComp_, inst_InvPurchaseReceipt_, inst_WorkOrder_. Removed global LU constant 
--  130812          first_calendar_date_ and modified New , Get_Last_Non_Updatable_Day, Get_Last_Transaction_For_Part methods. Renamed global variables 
--  130812          which used to kind of micro cache functionality, onhand_dev_cache_contract_, onhand_dev_cache_part_no_, onhand_dev_cache_config_id_,  
--  130812          onhand_dev_cache_filled_, onhand_dev_cache_time_, onhand_dev_acc_quantity_ as micro_cache_onh_dev_contract_, micro_cache_onh_dev_part_no_, 
--  130812          micro_cache_onh_dev_config_id_, micro_cache_onh_dev_filled_, micro_cache_onh_dev_time_, micro_cache_onh_dev_acc_qty_ respectively.
--  130730  ChFolk  Renamed function Get_Rma_Returned_Qty as Get_Rma_Multi_Site_Return_Qty as it only consider return qty when delivered to different site than delivered. 
--  130712  ChFolk  Added new parameters serial_no into method Get_Rma_Returned_Qty to support serial parts.
--  130627  ChFolk  Removed method Get_Delivery_Transaction_Id as the delivery transaction is taken from new connection introduced in INVENT_TRANS_INTERCONNECT_TAB.
--  130626  ChFolk  Renamed function Get_Direct_Del_Transaction_Id with Get_Delivery_Transaction_Id and modified method to get delivery transaction id for a given receipt transaction id.
--  130626          Added new method Get_Rma_Returned_Qty which returns the sum of qty already returned for the given alt source ref info.
--  130624  UdGnlk  EBALL-94, Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ to correct business event CRO-EXR-IN messages and 
--  130624          Calc_Zero_Dir_Trans_Cost___() to retrieve the cost of business event CRO-EXR-OU.
--  130620  ChFolk  Modified method New to include RETDIFS-NI as a transaction code which handles non inventory parts.
--  130618  UdGnlk  EBALL-128, Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ to include CRO-EX-SCR business event to scrap part exchange. 
--  130617  ChFolk  Modified Calc_Zero_Dir_Trans_Cost___ to get the cost from issued transaction when transaction code is RETDIFSSCP.
--  130613  ChFolk  Modified Calc_Plus_Dir_Trans_Cost___ to get the cost detail for RETDIFSREC transaction from corresponding delivery transaction and modified Post_Booking_Actions___
--  130613          to include move revaluation postings for RETDIFSREC transaction. Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ to support RETINTPODS transaction
--  130613          only if return to the delivered supplier. 
--  130613  ChFolk  Replaced usages of transaction codes RETDIFSITE and RETDIF-SCP with RETDIFSREC and RETDIFSSCP respectively.--  130612  NaLrlk  Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ to update lot batch master/part serial history for transaction code RENTRET.
--  130613  UdGnlk  EBALL-93, Modified Calc_Zero_Dir_Trans_Cost___() to include business event CRO-EXR-OU and Call_Part_Serial_Catalog___() and Call_Lot_Batch_Master__()
--  130613          to seperate business event CRO-EXR-IN.  
--  130612  NaLrlk  Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ to update lot batch master/part serial history for transaction code RENTRET.
--  130610  UdGnlk  EBALl-93, Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ include CRO-EXR-IN and CRO-EXR-OU business events.  
--  130610  AwWelk  EBALL-98, Modified Call_Part_Serial_Catalog___, Calc_Zero_Dir_Trans_Cost___ and Call_Lot_Batch_Master__ methods for the transaction CRO-EX-SCR.
--  130610  ChFolk  Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ to support RETDIFSITE and RETDIF-SCP transactions for serial and lot batch parts. 
--  130603  AwWelk  EBALL-49, Modified Call_Part_Serial_Catalog___, Calc_Zero_Dir_Trans_Cost___ and Call_Lot_Batch_Master__ methods for the transaction CRO-EX-DEL.
--  130521  UdGnlk  EBALL-44, Modified Call_Part_Serial_Catalog___(), and Call_Lot_Batch_Master__() include CRO-EX-ARR business event.--  130522  ChFolk  Modified Calc_Zero_Dir_Trans_Cost___ to get the cost from issue transaction when the transaction code is RETDIR-SCP. Modified Calc_Plus_Dir_Trans_Cost___ to replace the cursor
--  130522          from method Get_Transaction_Contract.
--  130515  IsSalk  Bug 106680, Replaced Installed_Component_SYS.<component> with Component_<component>_SYS.<component>.
--  130513  NaLrlk  Modified Call_Lot_Batch_Master__ to allow original_trans_code_ RENTRET.
--  130510  AwWelk  EBALL-67, Modified Call_Part_Serial_Catalog___(), Calc_Minus_Dir_Trans_Cost___(), Post_Booking_Actions___() and Call_Lot_Batch_Master__()
--  130510          to handle CRO-EXD-OU transaction.
--  130510  ChJalk  EBALL-68, Modified methods Call_Part_Serial_Catalog___, Calc_Plus_Dir_Trans_Cost___, Call_Lot_Batch_Master__ and Get_Sum_Value_Order_Line to add the transaction code CRO-EXD-IN.
--  130429  Asawlk  EBALL-37, Modified Calc_Zero_Dir_Trans_Cost___() to retrieve the cost_detail_tab when transaction code is either 'CO-CONSUME' or 'DELIVCONF'.
--  130419  THTHLK  Modified Call_Part_Serial_Catalog___ to allow original_trans_code_ RENTRET and RENTRET-NI.
--  130513  NaLrlk  Modified Call_Lot_Batch_Master__ to allow original_trans_code_ RENTRET.
--  130419  THTHLK  Modified Call_Part_Serial_Catalog___ to allow original_trans_code_ RENTRET and RENTRET-NI.
--  121130  NaLrlk  Modified Trans_With_Ownership_Exist to consider the Supplier Rented and Company Rental Asset part ownerships.
--  121116  NaLrlk  Modified Check_Part_Ownership___ to validate the new ownerships Supplier Rented and Company Rental Asset.
--  121115  NaSalk  Modified Do_Booking method to exclude Supplier Rented and Company Rental Asset ownerships from creating postings.
--  130514  ChFolk  Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ to support RETDIR-SCP transaction for serial and lot batch parts.
--  130430  ChFolk  Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ to support RETINTPODS and RETSHIPDIR transactions for serial and lot batch parts.
--  130426  ChFolk  Modified Post_Booking_Actions___ to change the balance transaction from ORDTREVAL-/+ to MOVEREVAL+/- for the transaction RETSHIPDIR.
--  130417  ChFolk  Added new method Get_Direct_Del_Transaction_Id which returns the direct delivery transaction_id corresponding to the the given return transaction_id. Modified
--  130417          Calc_Plus_Dir_Trans_Cost___ to avoid geting cost detail from customer return cost for transaction RETSHIPDIR as it should be taken from corresponding RETINTPODS transaction.
--  130417          Modified Post_Booking_Actions___ to revaluate direct return.   
--  130306  Cpeilk  Bug 108181, Added method Check_Contract___() to encapsulate the user allowed site check by removing some logic from Unpack_Check methods and placing
--  130306          them together with some more logic inside Check_Contract___().
--  130228  ChFolk  Modified parameters of the method Get_Direct_Ship_Return_Qty to make it more general use.
--  130227  ChFolk  Modified Get_Po_Rejected_Qty_And_Value and Get_Rejected_Purch_Receipt_Qty to write in using two cursors instead of one cursor which is more readable and correct
--  130227          wrong value for alt_source_ref2 in cursor get_trans_info_2 in Get_Po_Rejected_Qty_And_Value.
--  130221  UdGnlk  Modified Unpack_Check_Insert___(), Unpack_Check_Update___(), Call_Lot_Batch_Master__(), Call_Part_Serial_Catalog___(), 
--  130221          Calc_Zero_Dir_Trans_Cost___() and Post_Booking_Actions___() to include the transaction RINTORDTRX.
--  130221  ChFolk  Modified Get_Avg_Charge_On_Receipt___ by adding alt_source_ref parameters to distinguish noramal purchase return transactions and direct return transactions.
--  130201  Asawlk  Bug 108144, Modified the Get_External_Service_Costs() to include the service cost when costing module is not installed which resulted in 
--  130201          having a dummy cost bucket type.
--  130128  UdGnlk  Modified Revalue_Ret_Rework_Or_Cred___() to support revaluation for transaction 'RETPODSINT'. 
--  130118  ChFolk  Added new Get_Dirrettosup_Message___ to avoid using same message key in more than one place.
--  130117  UdGnlk  Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ to include serial catalog and lotbatch master infomation for RETPODSINT transaction.
--  130117          Modified Post_Booking_Actions___() to include RETPODSINT for revaluation.
--  130116  PraWlk  Bug 106676, Modified Reverse_Transaction___() by setting the allow_exceeding_available_qty_ to TRUE if issue_mtrl_shop_order_split_ is TRUE.  
--  130116          Passed it when calling Inventory_Part_In_Stock_API.Issue_Part() to avoid quantity checks.
--  130111  ChFolk  Modified Calc_Zero_Dir_Trans_Cost___ to get the transaction cost details for given transaction id when issue_transaction_id_ is given in the transaction. Modified
--  120111          Get_Cust_Shipment_Transactions to remove transaction code RETPODIRSH as the transaction cost is taken from issue transaction.
--  130104  UdGnlk  Modified Do_Booking() and Get_Direct_Ship_Return_Qty()to include RETPODSINT transaction.
--  130103  AyAmlk  Bug 106636, Modified Cancel_Order_Receipt() to pass parameter prevent_fifo_action_ when calling Inventory_Part_In_Stock_API.Unreceive_Part().
--  130102  ChSllk  ONESA-269 , Modified errror message CROSERIALCANCEL.
--  121204  ChFolk  Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__ to update serial catalog and lotbatch master infomation for RETPODIRSH transaction.
--  121122  ChFolk  Added new method Get_Direct_Ship_Return_Qty which returns total quantity returned against direct delivered. Modified Call_Part_Serial_Catalog___.
--  121108  ChFolk  Modified Get_Avg_Charge_On_Receipt__ to get average charge for purchase direct return. Modified method Do_Booking to get average charge for receipt RETPODIRSH
--  121108          transaction. Include new event code, RETARCHGDS to represent charges for RETPODIRSH transaction.
--  121106  ChFolk  Modified Get_Deliv_Overhead_Settings___ to include delivery overhead event code for RETPODIRSH transaction.
--  121101  ChFolk  Modified Get_Rejected_Purch_Receipt_Qty and Get_Po_Rejected_Qty_And_Value to add the return qty for customer order direct ship to supplier.
--  121030  ChFolk  Modified Get_Cust_Shipment_Transactions to add RETPODIRSH to the transaction code list.
--  121012  Darklk  Bug 99815, Added the function Get_Total_Source_Ref_Amount.
--  121204  AyAmlk  Bug 106914, Rolled back previous correction done for the bug 106914 in Do_Booking().
--  121203  PraWlk  Bug 106889, Modified Get_Last_Serial_Trans_Of_Type() by changing the cursor get_last_serial_trans to accept NULL in the serial_no_ parameter 
--  121203          and then picks up a transaction_id regardless of serial_no.
--  121130  NaLrlk  Modified Trans_With_Ownership_Exist to consider the Supplier Rented and Company Rental Asset part ownerships. 
--  121122  Raablk  Bug 106914, Modified PROCEDURE Do_Booking .  
--  121116  NaLrlk  Modified Check_Part_Ownership___ to validate the new ownerships Supplier Rented and Company Rental Asset.
--  121115  NaSalk  Modified Do_Booking method to exclude Supplier Rented and Company Rental Asset ownerships from creating postings.
--  121015  TiRalk  Bug 105627, Added parameter include_reversed_transactions_ to method Get_Supplier_Return_Cost. 
--  121012  Darklk  Bug 99815, Added the function Get_Total_Source_Ref_Amount.
--  121010  RoJalk  Bug 102645, Added method Revalue_Reverse_Transaction___ and called it inside the method Reverse_Transaction___ in order to handle the reversal of receipts.
--  121010          Modified Cancel_Order_Receipt() to call Reval_Cancel_Order_Receipt___ when inventory_valuation_method is Weighted Average. 
--  121010          Merged FIFO, LIFO and AV code blocks in to one and grouped common code sections together in Cancel_Order_Receipt().
--  121010          Modified Reval_Cancel_Order_Receipt___ method signature by removing the parameter correction_type_ and added a call towards Company_Finance_API.Get() 
--  121010          and removed the same implementation from methods Reval_Canc_After_Oh_Adjust___, Cancel_Order_Receipt and Reval_Cancel_Receipt_In_Place. 
--  121009  MaEelk  Bug 104958, Modified Call_Part_Serial_Catalog___(). Called Supplier_Is_Internal() in Purchase_Order_API instead of Customer_Order_Line_API for the original_trans_code_
--  121009          'PODIRSH' and 'PURDIR'. When the original_trans_code_ is 'PODIRINTEM', the serial_state_ 'UnderTransportation' is allowed and will be updated in PartSerialHistory.
--  121009  PraWlk  Bug 102549, Moved Check_Activity_Seq___() into InventoryTransactionHist from InventoryPartInStock and called it from New() and Unpack_Check_Insert___().
--  121008  RoJalk  Bug 102672, Modified Cancel_Order_Receipt() to handle revalue of a cancellation of a FIFO receipt.
--  121008  GayDLK  Bug 101862, Modified Calc_Minus_Dir_Trans_Cost___() by setting fifo_action_ to 'REMOVE' instead of NULL when the quantity is reversed for FIFO, LIFO parts. 
--  121008          Modified Cancel_Order_Receipt() and Reverse_Transaction___() by removing method calls to Remove_Fifo_Lifo_Cost(). Modified Reverse_Transaction___() by passing
--  121008          old_transaction_id_ and prevent_fifo_action_ when calling Inventory_Part_In_Stock_API.Issue_Part. Modified New() by adding parameters original_transaction_id_ and        
--  121008          prevent_fifo_action_ and used prevent_fifo_action_ to override the fifo_action_ to handle Shop Order splits. Passed original_transaction_id_ if conn_transaction_id_ 
--  121008          is NULL when calling Remove_Fifo_Lifo_Cost() inside New().  
--  121002  RoJalk  Bug 100341, Modified Reverse_Transaction___ to add transaction code SCPCREDCOR to execute Reverse_Return_Wip_Trans___. Modified Modify_Connected_Trans_Date__
--  121002          to add transaction codes SCPCREDCOR and SCPCREDIT.
--  120921  IRJALK  Bug 104826, Added new parameter part_no_ to function Create_Value_Detail_Tab() to invoke Inventory_Transaction_Cost_API.Get_Cost_Bucket_Group_And_Type().
--  120920  PraWlk  Bug 104921, Modified the exception handling of Redo_Transaction_Postings___() to raise errors using Error_SYS.Record_General.
--  120912  Asawlk  Bug 104948, Modified Recalc_Cost_On_Price_Update() to calculate costs for transactions 'SERLOTSWAP' and 'PARTSWAP' similarly to 'ARR-COMP'.
--  120906  PraWlk  Bug 104756, Modified Call_Shop_Order_Receipt___() by passing eng_part_revision_ to Part_Serial_Catalog_API.Unissue(). 
--  120823  SeJalk  Bug 100347, Modified the cursors get_sum_qty and get_sum_alt_ref_qty  in Get_Sum_Quantity to make the selection against order_type and  alt_source_ref_type respectively
--  120823          instead of mpccom_transaction_code_pub.order_type_db.
--  120822  Asawlk  Bug 103820, Modified Refresh_Activity_Info() by changing the method call from Work_Order_API.Update_Costs_Progress to 
--  120822          Work_Order_API.Calculate_Cost_And_Progress as the previous one is obsolete.
--  120726  MaRalk  Bug 102752, Modified method Calc_Zero_Dir_Trans_Cost___ in order to handle 'OERET-SINT' transaction in RMA scrapping.
--  120716  GayDLK  Bug 102754, Modified New() to allow the transactions having cost_source as 'INTERNAL SALES PRICE' to bypass the zero cost check.
--  120620  UdGnlk  Bug 101323, Added Get_Po_Arrival_Condition_Code() to get the condition code entered when registering the PO arrival.
--  120405  NaLrlk  Modified Get_Cust_Shipment_Transactions to remove the unused demand_order_ref variables.
--  120220  Asawlk  Bug 100479, Moved the code segment for raising error message 1230 from up in the code to down in the code in New() method to raise the same error
--  120220          message if needed, only after calculating the actual transaction cost.
--  120220  IsSalk  Bug 100515, Added parameter include_reversed_transactions_ to the method Get_Arrival_Cost_Value_Qty___ and modified methods Create_Stage_Pay_Postings___,
--  120220          Get_Arrival_Cost, Get_Arrival_Value_And_Qty, Get_Arrival_Info_For_Delivery accordingly. Modified cursors get_trans_info_primary_source and get_trans_info_alt_source
--  120220          ifsto filter non reversed parts according to the value of added parameter.
--  120210  PraWlk  Bug 100984, Modified Intersite_Profit_Reval___() by passing the date_applied_ for adjustment_date_ parameter when calling Do_Booking().
--  120127  MaEelk  Corrected the DATE FORMAT of date_created, date_time_created and date_applied in view comments.
--  111125  HimRlk  Bug 99673, Added new methods Modify_Connected_Trans_Date___() and Modify_Date_Applied___(). Moved the logic of Modify_Date_Applied() to the 
--  111125          implementation method. Modified Handle_Modify_Date_Applied___() to call Modify_Connected_Trans_Date___() in order to modify the date_applied
--  111125          of the connected transaction as well. Modified Reverse_Return_Wip_Trans___() by adding new parameter reverse_return_transaction_id_ and modified  
--  111213          method to add a connection between reverse return transactions and their WIP transaction.
--  111213          Modified Modify_Connected_Trans_Date___() to handle RETCORCRE, RETCORWORK, RETCORWINT and UNRET-WIP transactions.
--  120109  HimRlk  Bug 100630, Modified INVENTORY_TRANSACTION_HIST view by changing the reference for CustOrdCustomer from owning_customer_no and previous_owning_customer_no to NOCHECK.
--  120116  ErFelk  Bug 99981, Modified Handle_Purch_Order_Line_Close by removing condition code so that PO line condition code is not been passed to Create_And_Account().
--  111222  HimRlk  Bug 100269, Modified Get_Comp_Line_Wa_Cost_Tab___() by changing the order of the two cursors so that cost details are fetched only if the shipped_quantity_
--  111222          is greater than zero.
--  111207  DaZase  Added changes in Call_Part_Serial_Catalog___ for OERET-NO and OERET-SPNO so it possible to create new serials for a return/scrap. Added new check in Check_Serial_Tracking___.
--  111201  AwWelk  Bug 99756, Added Trans_With_Ownership_Exist() function to check for the existence of any inventory transaction for a considered
--  111201          part/configuration with intended ownership.
--  111122  THLILK  Added parameter operational_condition_db_ to Call_Shop_Order_Receipt___ and modified Call_Part_Serial_Catalog___.
--  111121  LEPESE  Added part_no in call to Inventory_Part_In_Stock_API.Get_Serial_No_For_Stock from Cancel_Order_Receipt.
--  111027  NISMLK  SMA-285, Increased eng_chg_level length to VARCHAR2(6)/STRING(6).
--  111025  HimRlk  Bug 99522, Modified Manage_Condition_Code___ to avoid errors if the condition_code given on the transaction does not match the condition code 
--  111025          currently stored in PartSerialCatalog or LotBatchMaster for the serial or lot. And also to make sure that it is the condition code sent from
--  111025          InventoryValueCalc that is used on the transaction, to have the correct condition code for posting control (control type C89).
--  111025  Asawlk  Bug 99213, Modified New() by calling Set_Pre_Trans_Level_Qty___() to set the pre trans level quantities when fifo_action_ = 'ISSUE'.
--  111018  IsSalk  Bug 98060, Removed procedure Get_Arrival_Cost_For_Delivery() and added method Get_Arrival_Info_For_Delivery().
--  111018          Also Replaced call Get_Arrival_Cost_Value_Qty___ with Get_Arrival_Info_For_Delivery in function Get_Arrival_Cost_For_Delivery().
--  110825  Asawlk  Bug 98274, Modified Get_Deducted_Cost_Details___() to handle negative cost details. Also removed function Get_Positive_Cost_Details___().  
--  110812  Asawlk  Bug 98035, Modified the logic to perform the checks against the end dates of relevant periods when raising error ILLEGALPERIOD in Check_Modify_Date_Applied___().
--  110810  ErFelk  Bug 97851, Modified Get_Sum_Quantity by adding serial_no and eng_chg_level_ as parameters. Added them to get_sum_qty and get_sum_alt_ref_qty cursors also. 
--  110809  SWiclk  Bug 98055, Modified Do_Booking() method in order to pass the basic_event_accounting_value_ correctly.
--  110726  NWeelk  Bug 98183, Modified Call_Part_Serial_Catalog___ to allow the ARR-COMP transaction for serials that are "InFacility" to be received to inventory.
--  110726  JoAnSe  Renamed Get_Byproduct_Receipt_Detail to Get_Shop_Ord_Receipt_Detail
--  110707  TiRalk  Bug 97940, Modified Reverse_Transaction___ by adding transaction SCPCREDCOR to display the scrap reason in Inventory transaction history window.
--  110707  AmPalk  Bug 95748, Added Get_Sum_Quantity. Made Lot_Batch_No_On_Order obsolete, because usage removed from RMA Line.
--  110628  PraWlk  Bug 94103, Modified Get_Supplier_Return_Cost() by adding parameters contract_, part_no_, configuration_id_,
--  110628          lot_batch_no_ and serial_no_ and passed the values of those parameters when calling Get_Latest_Transaction_Id().
--  110628          Modified Calc_Minus_Dir_Trans_Cost___() by passing the values for above parameters when calling Get_Supplier_Return_Cost().
--  110628  PraWlk  Bug 93152, Added new method Copy_Fifo_Lifo_Issues___() and modified Reverse_Transaction___() by calling it instead of calling
--  110628          Remove_Fifo_Lifo_Cost(). Modified New() by passing the value of transaction_id_ when calling Inventory_Part_Cost_Fifo_API.Unissue_Cost().
--  110627  PraWlk  Bug 95368, Modified Remove_Fifo_Lifo_Cost() by adding new parameters cost_successfully_removed_ and error_when_not_successful_. Modified New()
--  110627          to call Remove_Fifo_Lifo_Cost() with error_when_not_successful_ = FALSE to switch into a normal issue-transaction behavior when the removal
--  110627          of FIFO stack records belonging to the original arrival transaction fails.
--  110615  LEPESE  Added call to Part_Serial_History_API.Set_Inv_Transaction_Id_On_Last from Call_Part_Serial_Catalog___
--  110615          for transaction codes 'PARTREN+' and 'SERREN+'.
--  110531  LEPESE  Added methods Get_Purchase_Receipt_Serials and Get_Purch_Receipt_Serials___.
--  110531  PraWlk  Bug 93908, Modified Get_Cust_Shipment_Transactions() by removing cursor get_alt_source_ref_trans and modified the code
--  110531          accordingly to execute the cursor get_source_ref_transactions for 'OERET-EX' and 'OERET-SPEX' transactions.
--  110531  Asawlk  Bug 95885, Passed parameters correctly when calling Mpccom_Accounting_API.Get_Sum_Value_Details() inside Get_Arrival_Cost_Value_Qty___().
--  110526  ShKolk  Added General_SYS for Calculate_Cost_And_Progress().
--  110526  Asawlk  Bug 94974, Added new parameter cost_detail_tab_ to Get_Arrival_Cost_Value_Qty___() and modified Revalue_Ret_Rework_Or_Cred___() to use
--  110526          cost_detail_tab_ received by calling over loaded method Get_Arrival_Cost_Value_Qty___(), which handles the cost details. Moved the logic
--  110526          from the existed method which got the same name and call the new method from the old one. Modified method Revalue_Ret_Rework_Or_Cred___()
--  110526          to handle the value details by using newly added Get_Arrival_Cost_Value_Qty___() and Mpccom_Accounting_API.Get_Sum_Value_Details(). Replaced
--  110526          two calls to Mpccom_Accounting_API.Add_Value_Details() with calls to Mpccom_Accounting_API.Get_Merged_Value_Detail_Tab() in Create_Revaluation_Postings___().
--  110524  AmPalk  Bug 96448, Modified Call_Part_Serial_Catalog___, original_trans_code_ IN ARRIVAL, CO-ARRIVAL, SERIAL-IN section
--  110524          by removing the condition restricted the Part_Serial_Catalog_API calls only for MRO demand cods.
--  110524          With a slight change than the APP75.
--  110524  LEPESE  Passing TRUE in parameter reversing_earlier_update_ when calling
--  110524          Part_Serial_Catalog_API.Set_Operational_Condition from Cancel_Order_Receipt.
--  110503  LEPESE  Modification in Cancel_Order_Receipt to restore operational_condition on a serial when cancelling receipt.
--  110420  JeLise  Declared Get_Consumed_Tot_Comp_Value___() method signature. Modified Create_Stage_Pay_Postings___ in order to get the wip_value_ and deduct it from receipt_value_
--  110420          so that the correct value is passed for the BALRECSP.
--  110418  Cpeilk  Bug 95265, Modified method Call_Part_Serial_Catalog___ to remove fetching value to operational_status_db_ and passed 
--  110418          'OUT_OF_OPERATION' to method Part_Serial_Catalog_API.Move_To_Facility.
--  110418  PraWlk  Bug 93686, Modified Refresh_Activity_Info() by adding Added new parameter accounting_id_ and passed the value of if when
--  110418          calling Project_Refresh_Accounting_API.Fill_Temporary_Table(). Modified Handle_Modify_Date_Applied___() by passing 
--  110418          accounting id when calling Refresh_Activity_Info().
--  110414  LEPESE  Added parameter lot_batch_no_ in call to Part_Serial_Catalog_API.Move_In_Inventory
--  110414          from method Call_Part_Serial_Catalog___.
--  110406  LEPESE  Added call to Transport_Task_API.Remove_Unexecuted_Tasks in Cancel_Order_Receipt.
--  110314  MaEelk  Added condition_code_db_ to the Part_Serial_Catalog_API calls for the transaction code CROREC in Call_Part_Serial_Catalog.
--  110313  Nuwklk  Modified Call_Part_Serial_Catalog calls for operational_condition_db_.
--  110308  Nuwklk  Modified Call_Part_Serial_Catalog calls for operational_condition_db_.
--  110308  MaEelk  Modified Call_Part_Serial_Catalog___ to make part serial catalog calls without changing the operational status for CROREC.
--  ----------------------- Blackbird Merge End -----------------------------
--  110302  harplk  Merge Blackbird Code
--  100916  ImFelk  BB10, Add parameter operational_condition_db_ to methods New , Call_Part_Serial_Catalog___.
--  ----------------------- Blackbird Merge Start -----------------------------
--  110204  KiSalk  Moved 'User Allowed Site' Default Where condition from client to VIEW2.
--  111005  DeKoLK  EANE-3741, Moved 'User Allowed Site' in Default Where condition from client.
--  101112  CHSELK  Corrected two incorrectly placed ifs_assert_safe places due to user comments. 
--  100916  THTHLK  HIGHPK-2302, PA Changes.
--  101029  Asawlk  Bug 93883, Handled transaction 'UNRET-WIP' inside Call_Part_Serial_Catalog___() and Call_Lot_Batch_Master__() to do
--  101029          nothing at all.
--  101021  PraWlk  Bug 89847, Modified method Get_Customer_Return_Cost() and added new public method Get_Cust_Shipment_Transactions() 
--  101021          to find the issue transaction(s) that were created when the returning item which was originally shipped to the customer.
--  101021          Modified methods New(), Calculate_Transaction_Cost___(), calling Calc_Plus_Dir_Trans_Cost___() and Calc_Zero_Dir_Trans_Cost___()
--  101021          by passing the value of parameter issue_transaction_id_ from method New() via Calculate_Transaction_Cost___() into 
--  101021          Calc_Plus_Dir_Trans_Cost___() and Calc_Zero_Dir_Trans_Cost___().  
--  101020  Hasplk  Bug 93519, Added method Get_Latest_Transaction_Id.
--  110304  JoAnSe  Added Get_Latest_Trans_Id_For_Part
--  110225  LEPESE  Modification in Cancel_Order_Receipt to call Inventory_Part_In_Stock_API.Get_Serial_No_For_Stock()
--  110225          which takes care of the situation where a serial of a part that is not tracked in Inventory 
--  110225          is about to be issued from a Picking, floor stock or Production line location. 
--  110218  LEPESE  Added methods Get_Pur_Rec_Serial_Count___ and Serial_Is_On_Purchase_Receipt.
--  110217  LEPESE  Added method Get_Pur_Receipt_Serial_Count.
--  110217  LEPESE  Added method Check_Serial_Tracking___ and calling it from Unpack_Check_Insert___.
--  101216  LEPESE  Added transaction description in error message RECISSERTRACK.
--  101103  LEPESE  Added check in Unpack_Check_Insert___ to make sure that serial number are not specified on the transaction
--  101019          unless the parts is configured for receipt_issue_serial_track.
--  101019  LEPESE  Added check in Unpack_Check_Insert___ to make sure that a proper serial number exists on the transaction when
--  101019          the parts is configured for receipt_issue_serial_track and the transaction_code is configured for receipt_issue_tracking.
--  101019          Added parameters trancode_rec_ and part_catalog_rec_ to Unpack_Check_Insert___. Added parameter part_catalog_rec_
--  101019          to methods Insert___, Check_Zero_Cost_Flag___ and Manage_Condition_Code___. Removed obsolete method Do_Modify__.
--  101019          Added fetch of part_catalog_rec_ in method New. Inserted error messages instead of generated code in
--  101019          methods New__ and Modify__ to prevent illegal inserts and updates through private base methods.
--  101019          Replaced hardcoded strings 'TRUE' and 'FALSE' with global package constants true_ and false_.
--  101019          Redefined global package constants to get values from Fnd_Boolean_API.db_true and Fnd_Boolean_API.db_false.
--  101015  LEPESE  Removed handling of obsolete transaction codes 'INC-RCPT', 'INC-RETURN', 'INC-NPART',
--  101015          'INC-SOISS' and 'INC-UNISS' from Call_Lot_Batch_Master__.
--  -----------------------------  Best Price Start  --------------------------------------------
--  100826  MalLlk   Added method Reverse_Cro_Serial_Receipt___ and triggered it from Reverse_Transaction___.
--  100826           Removed the method Cancel_Cro_Serial_Parts___. Modified the way it handle transaction codes
--  100826           'CROREC' and 'CROUNREC' in Call_Part_Serial_Catalog___.
--  100820  PraWlk   Bug 92274, Modified Lot_Received_On_Shop_Order() by adding condition to cursor exist_control to check whether 
--  100820           the received qty is not reversed for a Shop Order receipt. 
--  100811  PraWlk   Bug 89848, Modified Reverse_Transaction___() by including FIFO and LIFO into the condition to call Create_Revaluation_Postings___()
--  100811           correctly for cancelling of Issue transactions.
--  100818  UdGnlk  Modified Call_Part_Serial_Catalog___() and Call_Lot_Batch_Master__() inorder to
--  100818          correct the handling of transaction code 'WOREPREC'.
--  100813  MalLlk  Added method Cancel_Cro_Serial_Parts___ to handle cancel serial parts from CRO.
--  100810  Asawlk   Bug 92361, Added missing assert safe anotation for a dynamic call in Cancel_Order_Receipt() method.
--  100730  PraWlk   Bug 90669, Modified New() to prevent fetching of Material Overhead costs for reversal transactions.
--  100726  MalLlk   Modified Call_Part_Serial_Catalog___() and Call_Lot_Batch_Master__() in order to
--  100726           handle transaction codes 'CROREC' and 'CROUNREC'.
--  100713  PraWlk   Bug 91877, Modified Get_Customer_Return_Cost() to retrieve the cost_detail_tab_ by replacing the star cost bucket.
--  100712  PraWlk   Bug 91831, Modified Cancel_Order_Receipt() to dynamically call Vim_Serial_API.Remove_Serial() in order to remove 
--  100712           the existing VIM serial record when cancelling the PO record.
--  100617  MaEelk  Modified Cancel_Order_Receipt and restructured some validations.
--  100614  MaEelk  Modified Cancel_Order_Receipt and removed unused codes.
--  100609  UdGnlk  Modified Is_Issued_On_Work_Order(), Call_Part_Serial_Catalog___(), Call_Lot_Batch_Master__() inorder to
--  100609          handle transaction code 'WOREPISS'.
--  100608  MaEelk  Replaced the call Inventory_Part_Stock_API.Get with Inventory_Part_In_Stock_API.Get in Cancel_Order_Receipt.
--  100507  MaEelk  Modified Unpack_Check_Update___ and Update___ to work the logic for Previous Part Ownership Information.
--  100430  MaEelk  Modified validations in Check_Part_Ownership___ and assigned null values to Owning_Vendor_No and
--  100430          Owning_Customer_No when required in Unpack_Check_Insert___
--  100430  MaRalk  Replaced method call Inventory_Part_In_Stock_API.Check_Consignment_Stock with
--  100430          Inventory_Part_In_Stock_API.Get_Part_Ownership_Db and Part_Ownership_API.DB_CONSIGNMENT check
--  100430          within Revalue_Ret_Rework_Or_Cred___ method.
--  100426  MaRalk  Replaced method call Inventory_Part_Stock_Owner_API.Check_Consignment_Stock with
--  100426          Inventory_Part_In_Stock_API.Check_Consignment_Stock within Revalue_Ret_Rework_Or_Cred___ method.
--  100420  MaEelk  Removed the call to Inv_Part_Ownership_Manager_API.Unissue_Part from Reverse_Transaction___.
--  100420  MaEelk  Made a call to Mpccom_Transaction_Code_API.Get_Vendor_Consignment_Trans to fetch the correspoding transaction code
--  100420          Modiffied Insert and Do_Booking.
--  100419  MaRalk  Renamed parameter names part_ownership_, vendor_no_, customer_no_ as part_ownership_db_, owning_vendor_no_, 
--  100419          owning_customer_no_ in Create_And_Account and overloaded New method and modified accordingly. 
--  100419          Modified reference by name usage for Create_And_Account within Create_Return_Wip_Trans___, 
--  100419          Handle_Purch_Order_Line_Close and Handle_Purch_Order_Line_Close methods. 
--  100416  MaEelk  Made part_ownership, owning_vendor_no and owning_customer_no update not allowed. Made previous_part_ownership, previous_owning_vendor_no
--  100416          owning_customer_no insert not allowed. Modified Unpack_Check_Insert___ and Unpack_Check_Insert___ and,
--  100416          Moved part_ownership validations to Check_Ownership. Called Mpccom_Transaction_Code_API.Check_Part_ownership_Db
--  100416          to make the part ownership validations against the transaction code. Modified Do_Booking to remove unnecessary codes.
--  100416          Modified Insert___ to fetch the corresponding consignment transaction if the part ownershpi is Consignment.
--  100407  MaEelk  Modified New and replaced the usage of local variables new_part_ownership_, owning_vendor_no_ and owning_customer_no_
--  100407          with renamed parameters part_ownership_db_, owning_vendor_no_ and owning_customer_no_ respectively.
--  100406  MaRalk  Renamed parameter names part_ownership_, vendor_no_, customer_no_ as part_ownership_db_, owning_vendor_no_, 
--  100406          owning_customer_no_ in New method. Modified reference by name usage in Reverse_Rintotrcor_Trans___,
--  100406          Reverse_Transaction___, Cancel_Order_Receipt and Revoke_Stage_Payment_Approval methods accordingly.
--  100406          Removed Inv_Part_Ownership_Manager_API.Inventory_Transaction method call from New method.
--  100514  AndDse   Bug 90190, Modified Do_Booking to create the PO charge events also for charge_amount = 0 during value_adjustment.
--  100514           Modified Get_Avg_Charge_On_Receipt___ and Get_Pur_Order_Charge_Cost___ to avoid NULL as return value.
--  100510  Asawlk   Bug 90044, Added OUT parameter transaction_required_ to methods Calc_Zero_Dir_Trans_Cost___ and 
--  100510           Calculate_Transaction_Cost___. Modified New() to exit when transaction_required_ = FALSE. Also
--  100510           modified Create_And_Account() accordingly to create accountings only if the transaction is successful.
--  100509  Nsillk   EAFH-3136 , used the new values when comparing correction_type.
--  100507  KRPELK   Merge Rose Method Documentation.
--  100506  MaAtlk   Bug 89842, Modified the method Refresh_Activity_Info to replace Shop_Ord_API.Calculate_Cost_And_Progress to   
--  100506           Shop_Ord_Services_API.Calculate_Cost_And_Progress in order to execute the cost calculation without checking the site paramter setting. 
--  100423  PraWlk   Bug 88817, Modified new() in order to trigger the cascade correctly for manufactured parts.
--  100422  NuVelk   Merged TWIN PEAKS.
--  100409  DAYJLK   Bug 89861, Modified Call_Shop_Order_Receipt___ to pass client value using function Order_Type_API.Decode 
--  100409           for parameter order_type_ in call to method Part_Serial_Catalog_API.Unissue.
--  100401  SaWjlk   Bug 89323, Modified the procedure Handle_Purch_Order_Line_Close to set the condition code to NULL
--  100401           in situations where a lot/batch number and the serial number is NULL on the PO line.
--  100331  SaWjlk   Bug 89031, Modified the function Get_Sum_Value_Per_Part to facilitate the  PODIFF transaction.
--  100325  ErFelk   Bug 87080, Added function Source_Has_Posting_In_Status.
--  100323  Cpeilk   Bug 88868, Added new method Get_Purchase_Order_Vendor___ and called it where Purchase_Order_API.Get_Vendor_No
--  100323           has been dynamically called. Added new parameter alt_source_ref1_ to method Call_Part_Serial_Catalog___.
--  100323           When the original_trans_code_ is PODIRSH passed vendor_no_ to method Part_Serial_Catalog_API.New_In_Issued.
--  100318  SuSalk   Bug 89119, Modified Call_Shop_Order_Receipt___  and Call_Part_Serial_Catalog___ methods to pass
--  100318           site date as the manufactured date when receiving a manufactured part to inventory.
--  100315  NiBalk   Bug 89472, Modified Get_Avg_Charge_On_Receipt___ and Do_Booking 
--  100315           in order to consider negative charges at PO receipt.
--  100308  PraWlk   Bug 89151, Modified the check for negative unit cost in method New() in order to skip the  
--  100308           validation for "Posting Cost Group Change" transactions.
--  100226  Asawlk   Bug 89148, Modified Get_Supplier_Return_Cost() to retrieve the cost_detail_tab_ by replacing the star cost bucket. 
--  100211  SaWjlk   Bug 87746, Added new public function Get_Shop_Order_Lot_Batch_Tab to return Part no, Lot batch no 
--  100211           and the quantity of a given shop order.
--  100209  KAELLK   Replaced parameter attribute_string_ with attributes_ in Project_Connection_Util_API.Refresh_Activity_Info.
--  100120  JENASE   Replaced usage of Logical_Unit_Is_Installed before dynamic calls with constants.
--  100106  ChFolk   Redirect method calls from obsolete package Shop_Order_Int_API.
--  100105  PraWlk   Bug 88061, Modified New() to call Check_Zero_Cost_Flag___() only if it is necessary.
--  091221  PraWlk   Bug 84712, Modified New() by removing unnecessary code.
--  091217  PraWlk   Bug 84712, Modified Calc_Minus_Dir_Trans_Cost___ and Calc_Zero_Dir_Trans_Cost___ to
--  091217           set fifo_action. Modified Reverse_Transaction___ and New methods to handle fifo 
--  091217           transaction in newly introduced way.
--  091217  PraWlk   Bug 87550, Modified Intersite_Profit_Reval___() by calling Get_Transaction_Contract() instead of Get_Contract().
--  091211  PraWlk   Bug 87201, Modified Check_Modify_Date_Applied___() by calling Mpccom_Accounting_API.Check_Date_Applied().
--  091211           to check the Date Applied against the financial period it belongs.
--  091209  THTHLK   Defect DE368, Modified views INVENTORY_TRANSACTION_HIST and INVENTORY_TRANSACTION_HIST2 and 
--                   Methods Get_Activity_Transfer_Cost___, Refresh_Activity_Trans_Cost___,Unpack_Check_Insert__, 
--                   Insert___, Unpack_Check_Update__,Update___, Handle_Activity_Transfer___, Refresh_Activity_Info.
--  091209  LEPESE   Bug 85944, Added method Include_Event_In_Statistics.
--  091202  SaWjlk   Bug 85919, Modified the content of the error message PALLETQTY in Check_and_Remove_Pallets___().
--  091202           Moved pallet receipt cancellation logic from Cancel_Order_Receipt() to Check_and_Remove_Pallets___().
--  091202           Also made some changes to the same logic inside Check_and_Remove_Pallets___().
--  091130  SuSalk   Bug 86245, Removed Balance_Ext_Service_Cost___ method and call to it were in Do_Booking method.
--  091130  PraWlk   Bug 86675, Added code to validate activity state for transaction code 'OERET-NI'in Unpack_Check_Insert___().
--  091127  PraWlk   Bug 86400, Added methods Issue_Mtrl_Shop_Order_Split, Get_Latest_Cancel_Trans_Id___ and
--  091127           Set_Earlier_Date_Applied___. Restructured method Redo_Transaction_Postings___ so that now the
--  091127           recreation of posting for cancel transactions are centralized and handled within this method by
--  091127           a recursive call. Removed handling of cancel transactions from Handle_Modify_Date_Applied___.
--  091127           Restructured checks for cancel transaction dates in Check_Modify_Date_Applied___ so that also 
--  091127           "cancel-of-cancel" transactions will be checked. Moved all code from Reverse_Transaction into 
--  091127           a new implementation method Reverse_Transaction___. Reverse_Transaction___ is modified with 
--  091127           new parameters issue_mtrl_shop_order_split_, new_issue_order_no_, new_issue_release_no_, 
--  091127           new_issue_sequence_no_ and new_issue_line_item_no_. Modifications are done in Reverse_Transaction___
--  091127           to enable the possibility to "cancel" a transaction and have the cancel trans connected to
--  091127           a new order reference which is needed during shop order split for the second SO.
--  091127           Simplified Redo_Error_Booking by removing handling of cancel transactions which is now 
--  091127           centrally handled within Redo_Transaction_Postings___. 
--  091118  SuSalk   Bug 86245, Modified Balance_Ext_Service_Cost___ function to create correct postings 
--  091118           when performing partial receipt for external service order.
--  091118  ShKolk   Bug 86768, Modified Unpack_Check_Insert___() to handle null values for abnormal_demand.
--  091030  ShKolk   Bug 86768, Merge IPR to APP75 core.
--  090930  ChFolk   Removed parameter location_no_, project_id_ from Redo_Transaction_Postings___, trancode_rec_ from
--  090930           Calc_Plus_Dir_Trans_Cost___, Calc_Minus_Dir_Trans_Cost___, Calc_Zero_Dir_Trans_Cost___ and event_code_
--  090930           from Create_Price_Diff_Postings___. Removed unused variables and global constants in the package.
--  090924  ChFolk   Removed function Ext_Serv_Order_Comp_Receipt___ which is no longer used.
--  090901  Chselk   Modified Refresh_Activity_Trans_Cost___,Handle_Activity_Transfer___. Passed used cost as the earned value to the activity.
--  090828  MaEelk   Bug 85071, Modified Get_Consumed_Comp_Cost_Details Pasing TRUE value to the parameter replace_star_cost_bucket_ 
--  090828           in Inventory_Transaction_Hist_API.Get_Transaction_Cost_Details.
--  090828           Added two functions Get_Shop_Ord_Mtrl_Cost_Details and Get_Byproduct_Receipt_Details.
--  090825  MalLlk   Bug 84869, Used CHR(31) as the field separater for objid in views INVENTORY_TRANS_USAGE_TRACING 
--  090825           and INVENTORY_TRANS_ORIGIN_TRACING.
--  090708  IrRalk   Bug 83667, Added new function Reversing_Issue_Transaction___.Modified the check for negative
--  090619           unit cost in method New in order to allow negative unit cost when reversing issue transactions.
--  090609  HoInlk   Bug 83142, Modified Call_Part_Serial_Catalog___ to handle DELCONF-OU transactions
--  090609           similar to OESHIP transactions.
--  090608  DAYJLK   Bug 82854, Added function Actual_Cost_Transactions_Exist.
--  090528  SaWjlk   Bug 83173, Removed the prog text duplications.
--  090516  HoInlk   Bug 77408, Added method Get_Supplier_Return_Cost to return cost for ARRIVAL and XO-ARRIVAL transactions.
--  090516           Added parameter conn_transaction_id_ to Calculate_Transaction_Cost___ and Calc_Minus_Dir_Trans_Cost___
--  090516           to get the related transaction id. Used parameter fifo_action_ with options 'INSERT', 'REMOVE' and 'NONE'
--  090516           in Calc methods instead of insert_fifo_. Changed the way 'RETWORK' and 'RETCREDIT' transaction costs
--  090516           are calculated for 'AV' and 'FIFO'. Added call to Reval_Wa_At_Empty_Inventory___ within Revalue_Ret_Rework_Or_Cred___.
--  090516  SuThlk   Bug 82760, Added new parameter eng_chg_level_ to method Call_Part_Serial_Catalog___ and
--  090516           added new parameters contract_ and eng_chg_level_ to method Call_Shop_Order_Receipt___
--  090516           inorder to get and pass the eng_part_revision_ to Part_Serail_Catalog in Call_Shop_Order_Receipt___.
--  090424  HoInlk   Bug 81944, Modified Intersite_Move_Revaluation___ to use accounting_id in call to Mpccom_Accounting_API.Get_Sum_Value.
--  090324  RoJalk   Added the parameter event_code_ to the method Get_Activity_Costs_By_Status.
--  090217  SaWjlk   Bug 80494, Modified New to consider transaction codes OERET-NI, OERET-NINO, OERETIN-NI, OERETIN-NO as Non-Inventory Parts
--  090206  MaEelk   Bug 80215, Modified Create_Revaluation_Postings___ to pass site date 
--  090206           as adjustment_date_ when calling Do_Booking
--  090203  MoNilk   Bug 79768, Modified Revalue_Ret_Rework_Or_Cred___ and added date_applied_ as a parameter to method call Do_Booking.
--  090119  NWeelk   Bug 78881, Modified New to allow the transactions having cost_source as SCRAP VARIANCE     
--  090119           to have costs for zero cost parts.
--  081215  DAYJLK   Bug 78957, Modified Call_Part_Serial_Catalog___ to handle ownership change for
--  081215           transaction codes NREC and COUNT-IN.
--  081125  RoJalk   Bug 77820, Modified Call_Part_Serial_Catalog___ to handle ownership change for
--  081125           Inventory Transfer transactions.
--  081103  DAYJLK   Bug 78170, Modified Set_Cost to ensure that Material OH is not removed.
--  081023  RoJalk   Bug 75685, Modified Cancel_Order_Receipt to prevent cancelling the original receipt
--  081023           if other transactions which are not cancelled have been performed after the receipt.
--  081022  PraWlk   Bug 77314, Modified Call_Lot_Batch_Master__ by adding parameter expiration_date_.
--  081020  PraWlk   Bug 77822, Modified Call_Part_Serial_Catalog___ by adding paramerter transaction_id_ to
--  081020           Part_Serial_Catalog_API.New_In_Issued when the transaction code is 'PURDIR'.
--  081002  HoInlk   Bug 76602, Changed the call Active_Work_Order_API.Update_Costs_Progress to Work_Order_API.Update_Costs_Progress.
--  081002           Removed constant inst_ActiveWorkOrder_ and added inst_WorkOrder_.
--  080925  NuVelk   Bug 76386, Passed TRUE for create_serial_history_ when calling the method
--  080925           Part_Serial_Catalog_API.Set_Serial_Ownership from Call_Part_Serial_Catalog___.
--  080919  MaEelk   Bug 76467, Removed the implementation method Get_Cost_Bucket_Id_Added___ and moved its contents
--  080919           to Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details by introducing a new parameter replace_star_cost_bucket_.
--  080919           Modified Reverse_Transaction,Cancel_Order_Receipt and Get_Ext_Service_Comp_Cost___ to pass TRUE
--  080919           to replace_star_cost_bucket_.
--  080909  NiBalk   Bug 75178, Added new OUT parameter info_ to Modify_Date_Applied and modified
--  080909           Handle_Modify_Date_Applied___ by calling  Purchase_Receipt_API.Handle_Modify_Date_Applied.
--  080908  MaEelk   Bug 75750, Modified Get_Customer_Return_Cost to get the correct order reference and the
--  080908           correct cost of the return transaction when the customer order was originated from a purchase order.
--  080808  Prawlk   Bug 75736, Modified procedure Call_Part_Serial_Catalog___ to allow scraping
--  080808           in RMA for Exchange Orders and No Charge purchase component flow (OERET-SPNC).
--  080721  SuSalk   Bug 75168, Moved Modify_Date_Applied code to Check_Modify_Date_Applied___ and
--  080721           Handle_Modify_Date_Applied___ methods. Added new error messages to validate Date_Applied.
--  080717  HoInlk   Bug 74565, Modified methods Get_Poinv_Wip_Trans_Cost___ and Get_Po_Line_Qty_Received___
--  080717           to consider quantities of current PO receipt to calculate cost. Modified Calc_Zero_Dir_Trans_Cost___
--  080717           to avoid adding NULL unit cost to cost_detail_tab.
--  080715  NiBalk   Bug 75271, Added new public method Issue_Supplier_Owned_Stock.
--  080714  SuSalk   Bug 75268, Modified transaction_report_id prompt to Inv Trans Report ID in base view and
--  080714           INVENTORY_TRANSACTION_HIST2 view.
--  080709  RoJalk   Bug 74811, Removed project_id from the  Mpccom_Accounting_API.Set_Control_Type_Key method call.
--  080627  NiBalk   Bug 74581, Added new condition to avoid considering the MRP code for
--  080627           rounding transactions in procedure New().
--  080626  NiBalk   Bug 74578, Modified Calculate_Qty_Onhand_Date by adding new condition,
--  080626           to avoid getting ORA error if cursor get_transactions finds no records.
--  080624  HoInlk   Bug 69398, Added method Get_Customer_Return_Cost to calculate the cost to be used for the
--  080624           customer return transaction. Used method in Calc_Plus_Dir_Trans_Cost___ and Calc_Zero_Dir_Trans_Cost___.
--  080617  SuSalk   Bug 74547, Modified Unpack_Check_Update___ method by adding new IF condition.
--  080807  KiSalk   Modified Do_Booking to set pur_order_charge_cost_exist_ true when po_charge_event_acc_value_ != 0.
--  ------------  Nice Price ------------------------------------------------
--  080528  KaEllk   Bug 74045, Added function Get_Sales_Overhead_Details.
--  080509  NiBalk   Bug 73079, Modified Get_Consumed_Component_Cost to avoid getting incorrect price
--  080509           difference when matching supplier invoice with purchase components.
--  080508  NuVelk   Bug 72249, Added method Cancel_Purch_Component_Issue.
--  080507  HoInlk   Bug 72829, Modified method Get_Arrival_Cost_Value_Qty___ to check if alt_source_ref information
--  080507           is included. Modified method Handle_Purch_Order_Close to consider transaction codes 'ARR-COMP',
--  080507           'PARTSWAP', 'REP-SCRAP', 'SERLOTSWAP' and 'ARR-REPAIR'.
--  080507  RoJalk   Bug 73185, Removed the view INVENTORY_TRANSACTION_PROJECT, Calc_Activity_Transfer_Cost___
--  080507           and Update_Project_Connection___.Changed the scope of Create_Value_Detail_Tab to be public.
--  080507           Added Get_Activity_Costs_By_Status. Modified Redo_Transaction_Postings___ and called
--  080507           Project_Refresh_Accounting_API.New for transactions having project related postings.
--  080507           Redesigned method Calc_Activity_Transfer_Cost___ to return a project_cost_element_tab_and
--  080507           renamed it to Get_Activity_Transfer_Cost___. Redesigned Refresh_Activity_Trans_Cost___
--  080507           so that is uses Get_Activity_Transfer_Cost___ to fetch project cost elements.Redesigned
--  080507           Update_Project_Connection___ so that it uses Get_Activity_Transfer_Cost___ to fetch project
--  080507            cost elements and renamed it to Handle_Activity_Transfer___.
--  080502  NiBalk   Bug 73278, Modified Do_Booking() to avoid booking Charges (ARRCHG) twice at purchase order
--  080502           receipt when both charges and delivery overheads are used.
--  080424  Prawlk   Bug 73018, Modified FUNCTION Lot_Batch_No_On_Order to avoid insufficient check that
--  080424           lot/batch no is delivered on an order connected RMA line.
--  080422  Prawlk   Bug 73153, Modified PROCEDURE Call_Part_Serial_Catalog___ by adding an IF conditon to
--  080422           avoid wrong transaction description when serialized part is recieved.
--  080409  NiBalk   Bug 70198, Modified parameter of Refresh_Activity_Info from accounting_id_ to contract_ and
--  080409           restructured that method to solve a performance issue by selecting accounting_id's from
--  080409           MPCCOM_ACCOUNTING_ID_TMP. Modified Update_Cost_For_Part by calling Project_Refresh_Accounting_API.New().
--  080409           Removed Accounting_Id_Tab from this package and defined it in Mpccom_Accounting_API and
--  080409           corrected all the required places to use Mpccom_Accounting_API.Accounting_Id_Tab.
--  080401  HoInlk   Bug 72186, Modified method Set_Alt_Source_Ref to avoid update when transaction_id is NULL.
--  080201  HoInlk   Bug 71009, Added column expiration_date to view INVENTORY_TRANSACTION_HIST2.
--  080201  HoInlk   Bug 68763, Added parameters to method New to transfer alt_source_ref information.
--  080129  NuVelk   Bug 70468, Modified procedure Reverse_Transaction by Calling Part_Serial_Catalog_API.
--  080129           Created_By to check if the serial no originated from current shop order, before
--  080129           removing it when reversing the shop order receipt.
--  080123  LEPESE   Bug 68763, modifications in method Handle_Purch_Order_Line_Close to avoid
--  080123           getting 'CLEAR-WIP-' transactions without postings.
--  080123  LEPESE   Bug 68763, modifications in method Cancel_Material_Backflush___ to fetch the
--  080123           purchase order receipt reference from the alt_source_ref columns since we have
--  080123           changed the place where this reference is stored. Main reference on the
--  080123           PURBKFL transactions is against the purcase componment line.
--  080123  LEPESE   Bug 68763, Modifications in methods Get_Deliv_Overhead_Settings___ and
--  080123           Do_Booking because accounting events 'RETWORK', 'RETCREDIT' and 'SCPCREDIT'
--  080123           does now have the delivery_overhead_flag set to 'Y' and can therefore be
--  080123           handled in the same way as all other events triggering delivery overhead postings.
--  080123  LEPESE   Bug 68763, Added 'CLEAR-WIP+' and 'CLEAR-WIP-' to cursor
--  080123           get_supplier_wip_value_details in method Handle_Purch_Order_Line_Close.
--  080123  LEPESE   Bug 68763, Added method Handle_Purch_Order_Line_Close. Added transaction codes
--  080123           'CLEAR-WIP+' and 'CLEAR-WIP-' to Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__.
--  080123  LEPESE   Bug 68763, Added method Get_Purch_Order_Ref___. Added calls to this method
--  080123           from Create_Price_Diff_Postings___, Create_Trans_Cost_Details___, Set_Cost
--  080123           and Recalc_Cost_On_Price_Update.
--  080123  LEPESE   Bug 68763, Added method Get_Purch_Comp_Consume_Trans.
--  080123  LEPESE   Bug 68763, changes in Balance_Ext_Service_Cost___ to create SER-REVAL+ and
--  080123           SER-REVAL- postings with value detail information. Created method
--  080123           Get_Ext_Service_Comp_Trans___ used to fetch transaction_id of component ship.
--  080123  LEPESE   Bug 68763, Renamed Get_External_Service_Comp_Cost to Get_Ext_Service_Comp_Cost___.
--  080123           Added method Get_External_Service_Costs. This method is moved from LU ReceivePurchaseOrder.
--  080123           Modifications in Recalc_Cost_On_Price_Update to fetch the correct cost
--  080123           details for transaction 'ARR-COMP'.
--  080123  LEPESE   Bug 68763, Renamed Get_Rep_Scrap_Trans_Cost___ to Get_External_Service_Comp_Cost.
--  080123  LEPESE   Bug 68763, Added method Get_Rep_Scrap_Trans_Cost___ and call it from
--  080123           Calc_Zero_Dir_Trans_Cost___ for transaction code 'REP-SCRAP'.
--  080123  LEPESE   Bug 68763, Modification in Recalc_Cost_On_Price_Update to fetch the
--  080123           component cost details for PODIRSH and PODIRINTEM transactions.
--  080123  LEPESE   Bug 68763, Modification in Recalc_Cost_On_Price_Update to fetch the
--  080123           component cost details for ARRIVAL transaction and include in transaction cost.
--  080123  LEPESE   Bug 68763, Modifications in Create_Price_Diff_Postings___ to fetch
--  080123           component cost from POINV-WIP via method Get_Consumed_Component_Cost.
--  080123  LEPESE   Bug 68763, Added method Get_Consumed_Component_Cost. Modifications in
--  080123           methods Calc_Plus_Dir_Trans_Cost___, Calc_Minus_Dir_Trans_Cost___ and
--  080123           Calc_Zero_Dir_Trans_Cost___ to make sure that variable local_unit_cost__
--  080123           only get a value when inparameter cost_detail_tab_ is empty.
--  080123           Added logic in Calc_Plus_Dir_Trans_Cost___ to fetch consumed component cost
--  080123           details using Get_Consumed_Component_Cost for the ARRIVAL transaction.
--  080123  LEPESE   Bug 68763, Added method Reverse_Return_Wip_Trans___. Added call to
--  080123           Reverse_Return_Wip_Trans___ from method Reverse_Transaction.
--  080123  LEPESE   Bug 68763, Removed method Handle_Wip_When_Return_Rework. Added methods
--  080123           Return_To_Vendor_For_Rework___, Return_To_Vendor_For_Credit___ and Scrap_For_Credit___.
--  080123           Added call to Create_Return_Wip_Trans___ from method Insert___.
--  080123  LEPESE   Bug 68763, added methods Handle_Wip_When_Return_Rework,
--  080123           Handle_Wip_When_Return_Credit and Create_Return_Wip_Trans___.
--  080123  LEPESE   Bug 68763, Added method Get_Positive_Cost_Details___.
--  080123  LEPESE   Bug 68763, Added methods Get_Po_Line_Qty_Ordered___, Add_To_Temporary_Table___,
--  080123           Load_Purch_Comp_Ship_Trans___, Get_Purch_Component_Lines___, Get_Comp_Line_Wa_Cost_Tab___,
--  080123           Get_Purch_Comp_Qty_Required___, Clear_Temporary_Table___, Get_Expect_Total_Comp_Value___,
--  080123           Get_Consumed_Tot_Comp_Value___, Get_Po_Line_Qty_Received___, Get_Deducted_Cost_Details___,
--  080123           and Get_Poinv_Wip_Trans_Cost___. Added call to Get_Poinv_Wip_Trans_Cost___
--  080123           from inside of Calc_Zero_Dir_Trans_Cost___. Defined type Line_Item_No_Tab.
--  080117  HoInlk   Bug 70464, Modified method Call_Part_Serial_Catalog___ to support
--  080117           current position ReturnedToSupplier for transaction code WORECEIPT.
--  071227  JaBalk   Bug 68639, Renamed Get_Qty_Returned_To_Supplier to Get_Rejected_Purch_Receipt_Qty
--  071227           and added SCPCREDIT, SCPCREDCOR to where clause of cursor get_qty_rejected in Get_Rejected_Purch_Receipt_Qty.
--  071206  IsAnlk   Bug 69467, Created two implementation methods Get_Return_Scrap_Serial_Msg___ and Get_Return_Stock_Serial_Msg___.
--  071206           Modified Call_Part_Serial_Catalog___ to handle 'OERETURN' and 'OERET-SCP'
--  071201  NuVelk   Bug 69430, Reversed part of the correction done by 67900, where
--  071201           Work Order material issue transactions (WOISS/CO-WOISS) should not average
--  071201           Inventory value at issuing of parts, if the part is using FIFO functionality.
--  071201  NuVelk   Bug 69428, Modified procedure Call_Part_Serial_Catalog___ to allow scraping
--  071201           when original_trans_code_ is REP-SCRAP without giving an error message.
--  071114  MaEelk   Bug 68184, Modified procedure Cancel_Order_Receipt to avoid changes in
--  071114           std_value_detail_tab_ and receipt_value_detail_tab_.
--  071113  JaBalk   Bug 68640, Added default null parameter line_item_no_ in Get_Last_Trans_Id_Ord.
--  071031  RoJalk   Bug 68811, Increased the length to 2000 in source cloumn in view comments of
--  071031           INVENTORY_TRANSACTION_HIST,INVENTORY_TRANSACTION_HIST2.Added the method Get_Transaction_Id_Tab.
--  071106  NuVelk   Bug 67900, Added missing conditions to prevent the use of FIFO functionality
--  071106           when transaction code is WOISS, CO-WOISS, WOUNISS or CO-WOUNISS.
--  071031  NuVelk   Bug 67900, Added conditions to prevent use of FIFO functionality in methods
--  071031           Calc_Plus_Dir_Trans_Cost___ and Calc_Minus_Dir_Trans_Cost___ when transaction
--  071031           code is PROJTRAN+, CO-PRJTRN+, PROJTRAN-,or CO-PRJTRN- respectively.
--  071019  MarSlk   Bug 68097, Modified function Calculate_Qty_Onhand_Date and used record to
--  071019           fetch the bulk record. Added condition to return the correct quantity for
--  071019           transaction XO-ARRIVAL.
--  070919  RoJalk   Modifications to the method Create_Stage_Pay_Postings___.
--  070913  RoJalk   Defined the PLSQL table type Accounting_Id_Tab, removed the parameter first_receipt_in_lot_
--  070913           from Get_Pur_Order_Charge_Cost___, Do_Booking, Do_Transaction_Booking. Added the
--  070913           method Get_Accounting_Id_Tab___. Modified the logic in Get_Pur_Order_Charge_Cost___
--  070913           to correct the problems in lot batch parts with ST cost method.
--  070820  ErSrLK   Bug 65666, Added parameter tran_hist_rec_ to method Create_Trans_Cost_Details___.
--  070820           New parameters in call to Inventory_Transaction_Cost_API.New from method
--  070820           Create_Trans_Cost_Details___. Changes in method Do_Booking to make use of
--  070820           new column level_unit_cost in inventory_transaction_cost_tab. Cursor get_transaction_values
--  070820           is modified with an additional select statement "union all" and the grouping is
--  070820           removed from cursor and done with collections instead. Changes in methods
--  070820           Reverse_Transaction and New for new parameter in Create_Trans_Cost_Details.
--  070820           New parameters when calling Inventory_Transaction_Cost_API.Create_Or_Modify_Details
--  070820           from methods Set_Cost and Recalc_Cost_On_Price_Update. The purpose of all this
--  070820           is to make it possible to post DELOH event only for the level_unit_cost portion
--  070820           of the DELOH cost details. unit_cost - level_unit_cost is posted as OTHER.
--  070817  RoJalk   Modified Create_Stage_Pay_Postings___ and used Get_Last_Stage_Payment_Db instaed
--  070817           of Get method. Removed coding realted to PRICEDIFF in a return from Get_Po_Rejected_Qty_And_Value.
--  070810  JaBalk   Bug 66354, Added function Get_Qty_Returned_To_Supplier in order to get
--  070810           purchase order return qty for a given purchase order and to-date.
--  070713  ChBalk   Bug 66261, Modified Create_Price_Diff_Postings___ to include the component cost into
--  070713           the price difference calculation.
--  070712  AmPalk   Bug 64893, Modified function Get_Latest_Transaction_Id to be able to select the direction to include.
--  070710  MaJalk   Bug 66182, Added function Lot_Batch_No_On_Order to check whether Lot Batch No is used in a previous order.
--  070703  MaMalk   Bug 65635, Modified method Modify_Date_Applied to check period is open and if not raise an error message.
--  070627  DAYJLK   Project Enterprise Merge.
--  070626  NaWilk   Modified method Get_Deliv_Overhead_Settings___ to handle delivery_overhead_event when PODIRINTEM.
--  070626  WaJalk   Bug 65560, Added parameter date_applied_ when calling Mpccom_Accounting_API.Redo_Reverse_Accounting
--  070626           in method Redo_Transaction_Postings___.
--  070605  LEPESE   Added public nullable attribute transit_location_group. Added parameter
--  070605           transit_location_group_ to method New. Added code in Insert___ to set correct
--  070605           value for newrec_.transit_location_group. Added methods Check_Remove_Transit_Loc_Grp__
--  070605           and Get_Transit_Location_Group. Added value for parameter transit_location_group
--  070605           when calling method New from Reverse_Rintotrcor_Trans___, Cancel_Order_Receipt
--  070605           and Reverse_Transaction,
--  070605           Removed code for INCREASE INTERNAL ORDER QTY and DECREASE INTERNAL ORDER QTY
--  070605           as values for transit_qty_direction in method Reval_Wa_At_Empty_Inventory___.
--  070530  LEPESE   Added code for INCREASE INTERNAL ORDER QTY and DECREASE INTERNAL ORDER QTY
--  070530           as values for transit_qty_direction in method Reval_Wa_At_Empty_Inventory___.
--  070522  WaJalk   Bug 53629, Added parameter condition_code_ to call Lot_Batch_Master_API.Unissue in Call_Lot_Batch_Master__.
--  070509  IsAnlk   Added column condition_code to views INVENTORY_TRANS_ORIGIN_TRACING, INVENTORY_TRANS_USAGE_TRACING
--                   and INVENTORY_TRANSACTION_TRACING.
--  070424  NiDalk   Bug 64114, Corrected the error in ERRORDIRECTION error message in Reverse_Transaction
--  070417  RoJalk   Restructure the code in Get_Pur_Order_Charge_Cost___.
--  070417  RaKalk   Removed obsolete code from New procedure
--  070416  RaKalk   Changed transaction column to a private derived column.
--  070416           Removed it from Inventory_Transaction_Tracing view. Modified functions Get
--  070416           and procedures Unpack_Check_Insert___, Unpack_Check_Update___, Insert___, Update___, New
--  070416           Removed function Get_Transaction
--  070410  RaKalk   Renamed Get_Return_Charge_Value___ to Get_Avg_Charge_On_Receipt___ removed inv_qty_return_ parameter
--  070405  RoJalk   Modified Create_Stage_Pay_Postings___ and used Get_Sum_Value to post BALRETSP.
--  070405  RaKalk   Removed view INVENTORY_TRANSACTION_VALUES.
--  070404  ErSrLK   Bug 62890, Modified method Update_Cost_For_Part and added new cost_source 'OVERHEAD'.
--  070404           Modified methods Call_Part_Serial_Catalog___, Call_Lot_Batch_Master__ by adding new transaction codes
--  070404           PSGENOH, UNPSGENOH in the original_trans_code_ condition check.
--  070404  RaKalk   Modified the new method to remove the transaction parameter from the call to Inv_Part_Ownership_Manager_API.Inventory_Transaction method
--  070404  RoJalk   Modified Create_Stage_Pay_Postings___ related to diff postings.
--  070330  SuSalk   Added SCPCREDIT to basic_event_code_ conditional check in the Get_Deliv_Overhead_Settings___ procedure.
--  070330  RoJalk   Added the function Lot_Received_On_Shop_Order.
--  070327  RoJalk   Modified Get_Arrival_Cost_Value_Qty__ and Get_Po_Rejected_Qty_And_Value and added TO_CHAR(receipt_no_).
--  070326  RaKalk   Set the po_return_charge_exist_ to false in do_booking___ once the return charges are added.
--  070326  SuSalk   Added SCPCREDCOR to the transaction_ conditional check in Reverse_Transaction method.
--  070323  RoJalk   Added Create_Stage_Pay_Postings___ and called from Do_Booking.Modified Update_Cost_For_Part
--  070323           and Set_Control_Type_Key___ to include 'STAGE PAYMENT'. Modified  Get_Arrival_Cost_Value_Qty__
--  070323           and Get_Po_Rejected_Qty_And_Value to support when receipt_no is null.
--  070323           Changed the milestone_id parameter to NUMBER in Revoke_Stage_Payment_Approval.
--  070316  MaMalk   Bug 63735, Modifications in method Get_Arrival_Cost_Value_Qty___. Splitted cursor get_trans_info into
--  070316           two cursors get_trans_info_primary_source and get_trans_info_alt_source in order to avoid full table scan.
--  070316           Modified the cursor get_quantity_not_reversed, in the function Get_Quantity_Not_Reversed.
--  070315  DAYJLK   Added procedure Revoke_Stage_Payment_Approval. Removed parameter cost_diff_transaction_ from Check_Zero_Cost_Flag___.
--  070315           Modified procedure New by replacing variable cost_diff_transaction_ with new variables.
--  070314  RaKalk   Renamed Get_Value_On_M189 to Get_Sum_Value_For_Receipt and added str_code and to_date parameters
--  070312  LEPESE   Removed assignment to Control_Type_Key_Rec.location_no_ in methods
--  070312           Redo_Transaction_Postings___ and Do_Booking.
--  070309  MiKulk   Bug 63653, Modified method New in order to perform an additional check in an if condition.
--  070306  SuSalk   LCS Merge 63404, Modified method Calc_Plus_Dir_Trans_Cost___ in order to handle situations where
--  070306           qty_reversed_ <= 0 and inventory_valuation_method is FIFO or LIFO and transaction_code_ is ARRTRAN.
--  070301  SuSalk   Added SCPCREDIT,SCPCREDCOR transaction codes to Call_Part_Serial_Catalog___ &
--  070301           Call_Lot_Batch_Master__ methods.
--  070228  RaKalk   Removed Get_Acct_Id_By_Alt_Source_Ref and Get_Accounting_Id_By_Order_Ref
--  070223  RoJalk   Modified Get_Pur_Order_Charge_Cost___ and Do_Booking to include modifications
--  070223           need to supportARRCHGIDIR,PURDIR-CHG,ARRCHG-REP.
--  070221  RaKalk   Added functions Get_Return_Charge_Value___ and Get_Value_On_M189
--  070221           Modfied do_booking to handle posting event RET-CHARGE
--  070215  SuSalk   Renamed Get_Po_Return_Qty_And_Value as Get_Po_Rejected_Qty_And_Value. Modified Get_Pur_Order_Exchange_Cost___
--  070215           Do_Booking & Post_Booking_Actions___ methods to add SCPCREDIT to the conditions.
--  -------------------------- Wings Merge End ---------------------------------------------------
--  070130  DAYJLK   Merged Wings Code.
--  070110  DAYJLK   Added handling of SERREN+/- and PARTREN+/- in Call_Lot_Batch_Master__.
--  070103  JoAnSe   Added Part_Id_Change_Revaluation___ and called it from Post_Booking_Actions___
--  070103           Added handling of PARTREN+/- in Call_Part_Serial_Catalog___.
--  -------------------------- Wings Merge Start -------------------------------------------------
--  070126  NuVelk   Bug 61856, Modified view INVENTORY_TRANSACTION_HIST to add receipt_date and also modified methods Unpack_Check_Insert__,
--  070126           Insert__,Unpack_Check_Update__ and Update__ to handle the receipt_date.Also Modified method Reverse_Transaction to
--  070126           pass old_transaction_.receipt_date to the parameter list of Inventory_Part_In_Stock_API.Receive_Part.
--  070126           Added receipt_date_ as a default parameter to procedure New.
--  070123  ChBalk   Added extra condition when inserting Trans Cost Details for Sales Overhead.
--  070112  ChBalk   Added Customer_Order_Line_API.Get_Revised_Qty_Due to get the order line qty when calculating sales overhead cost.
--  070108  RaKalk   Removed method Get_Sales_Overhead_Settings___ and modified Get_Sales_Overhead_Details___ and Do_Booking___
--  061229  RaKalk   Modified Recalc_Cost_On_Price_Update and Set_Cost methods to handle sales overhead.
--  061227  RaKalk   Added Methods Get_Sales_Overhead_Settings___ and Get_Sales_Overhead_Details___
--  061227  RaKalk   Modified Do_Booking method to create the salse overhead postings
--  061213  ThGulk   Bug 61008, Modified method Reverse_Transaction by replacing the first method call to Modify_Qty_Reversed.
--  061207  NaLwlk   Bug 60731, Added Is_Completely_Reversed to check whether transaction is completely reversed.
--  061102           Added Error message in Reverse_Transaction when Subsequent transaction prevent the reversal of the receipt.
--  061205  RaKalk   Added Method Get_Acct_Id_By_Alt_Source_Ref
--  061127  ChBalk   Bug 60757, Modified code related to PURDIR, PODIRSH and PODIRINTEM transactions of Call_Lot_Batch_Master__
--  061127           and Call_Part_Serial_Catalog___ to pass condition_code_ as a parameter.
--  061122  LEPESE   Added transaction codes LOCGRP+, LOCGRP-, LOCGRPTR+, LOCGRPTR-, CO-LOCGRP+
--  061122           and CO-LOCGRP- in methods Call_Part_Serial_Catalog___ ,
--  061122           Call_Lot_Batch_Master___, Calc_Plus_Dir_Trans_Cost___,
--  0611122          Calc_Minus_Dir_Trans_Cost___ and Calc_Zero_Dir_Trans_Cost___.
--  061117  RoJalk   Added the parameter to Get_Pur_Order_Charge_Cost___, Do_Booking and Do_Transaction_Booking.
--  061117           Modified the method Get_Pur_Order_Charge_Cost___.
--  061110  RoJalk   Modifications to the method Do_Booking, removed Create_Charge_Diff_Postings___ method.
--  061109  RoJalk   Added the methods Create_Charge_Diff_Postings___ and Get_Pur_Order_Charge_Cost___
--  061109           and modified Do_Booking to handle posting event ARRCHG.
--  061108  RaKalk   Added new function Get_Accounting_Id_By_Order_Ref
--  061025  RaKalk   Added columns Modify_Date_Applied_Date and Modify_Date_Applied_User columns.
--  061025           Modified the methods Insert___, Update___, Unpack_Check_Insert___, Unpack_Check_Update___
--  061024  NiDalk   Bug 60730, Modified method Unpack_Check_Update___ to add validation for qty_reversed.
--  061024           Modified method Reverse_Transaction to fetch old_transaction_ with Lock_By_Keys___ in order to
--  061024           lock the record properly before modifying qty_reversed.
--  060915  KaDilk   Bug 58785, Fetched manufacturer_no_ , manufacturer_part_no_ to call
--  060627           Part_Serial_Catalog_API.New_In_Inventory in PROCEDURE Call_Part_Serial_Catalog___.
--  060913  DAYJLK   Bug 59625, Modified New() method to Add the transaction code 'PODIRSH-NI' to an if condition.
--  060911  MalLlk   Bug 52710, Modified code related to 'PURDIR','INTPURDIR','PODIRSH','INTPODIRSH','PODIRINTEM','INTPODIRIM'
--  060911           in Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master___.
--  060905  IsWilk   Added the FUNCTION Connected_Lines_Exist.
--  060810  ChJalk   Modified hard_coded dates to be able to use any calendar.
--  060810  NaLrlk   Removed the method Copy_To_Company.
--  060718  KeFelk   Added method Copy_To_Company and will be used in Basic Data for Inventory Transaction Report client.
--  060713  MaMalk   Added methods Get_Userid and Get_Date_Time_Created. Modified method Get to fetch userid and date_time_created.
--  060712  NaLrlk   Added public attribute transport_report_id and modified the base view, function Get,
--  060712           Unpack_Check_Insert___, Unpack_Check_Update___ and Update___. Added function Get_Transaction_Report_Id.
--  060712           Added methods Set_Report_Id,Reset_Report_Id and Check_Inv_Trans_Rep_Code_Exist.
--  060520  Ishelk   Bug 56108, Changed the parameters passed to the Part_Serial_Catalog_API.Unscrap_At_Supplier
--  060520           within method Call_Part_Serial_Catalog___
--  060518  HoInlk   Bug 57413, Modified Call_Part_Serial_Catalog___ to set part ownership for transaction codes SERLOTSWAP and PARTSWAP.
--  060508  ErFelk   Bug 55818, Added method Get_Purch_Order_Receipt_Date.
--  060504  IsAnlk   Enlarge supplier - Changed variable definitions.
--  060503  ChFolk   Bug 56598, Added non insertable public attribute pallet_id and modified the base view, function Get,
--  060503           Unpack_Check_Insert___, Unpack_Check_Update___ and Update___. Added function Get_Pallet_Id and procedure Set_Pallet_Id.
--  060420  IsAnlk   Enlarge customer - Changed variable definitions.
--  060418  NaLrlk   Enlarge Identity - Changed view comments.
--  ------------------------- 13.4.0 -----------------------------------------
--  060330  LEPESE   Added method Get_Cost_Bucket_Id_Added___ and called it from Reverse_Transaction
--  060330           and Cancel_Order_Receipt. This method solves the problem with cancelling
--  060330           transactions done before upgrade to Applications 7 when costing is installed.
--  060329  JoAnSe   Allowed NULL values for part_no_ and contract_ in Get_Wip_Cost_Details
--  060321  JaBalk   Added ifs_assert_safe to dynamic call.
--  060320  JoAnSe   Modified Modify_Cust_Ord_Deliv_Cost___ to handle direct deliveries.
--  060317  JaBalk   Modified code to retrieve external service cost method from inv_purchase_receipt instead of inventory_part.
--  060317           for the patch 56147.
--  060316  LEPESE   Removed obsolete method Get_Delivery_Overhead___ and some temporary comments.
--  060314  JoAnSe   Changed posting event used for differences in Create_Po_Return_Price_Diff___
--  060314           from PRICEDIFF+/- to REVPRDIFF+/-
--  060313  NuFilk   Modified the cursor get_acc in method Get_Sum_Value_Per_Part.
--  060310  SaJjlk   Changed the length of the sql error message to 2000 in method Redo_Transaction_Postings___.
--  060309  JOHESE   Added NVL checks in Cancel_Order_Receipt and Reverse_Transaction to handle
--                   transactions created before project inventory was implemented
--  060309  ShVese   Added methods Map_Receipt_Direct_Ship___ and Map_Receipt_Move_To_Inv___ for
--                   MAP localized transactions and included them in Get_Arrival_Cost_Value_Qty___.
--  060309  JaBalk   Added Get_Sum_Reversed_Catch_Qty to returned reversed catch quantity.
--  060308  LEPESE   Added method Transaction_In_Period_Exist.
--  060307  PrKolk   Bug 56328, Added new implementation method Set_Reject_Code___, which is used to update scrap cause(reject code)
--  060307           after a new, undo scrap inventory transaction and used it inside the procedure Reverse_Transaction.
--  060303  JoAnSe   Changes in Reval_WA_At_Empty_Inventory___ to handle INVREVTR postings
--  060301  JoAnSe   Changes in Reverse_Accounting for creation of UNRCPTBAL postings.
--  060301           Changed interface for Revalue_Reverse_Transaction___ and changed the name to
--  060301           Create_Revaluation_Postings___
--  060228  JoAnSe   Added call to Reval_WA_At_Empty_Inventory___ in Reverse_Rintotrcor_Trans___
--  060227  LEPESE   Replaced usage of obsolete column DATED with new columns DATE_CREATED and
--  060227           DATE_TIME_CREATED.
--  060224  LEPESE   Added condition for cost_source = 'ROUNDING DIFFERENCE' in Manage_Condition_Code___.
--  060224           Otherwise the ROUNDDIFF+/- transactions will cause errors for parts with cost
--  060224           level = 'COST PER CONDITION' since lot- and serial_no will be '*'.
--  060223  SeNslk   Added Column Catch_Quantity, Catch_Direction in VIEW6-INVENTORY_TRANSACTION_TRACING
--  060223  ShVese   Included MAP transaction J-ARRIVAL in method Purchase_Order_Receipt___.
--  060222  JoAnSe   Added Revalue_Ret_Rework_Or_Cred___ called from Post_Booking_Actions___
--  060221  JoAnSe   Changed the way the order keys are retrived for PODIRSH and PODIRINTEM in
--  060221           Create_Price_Diff_Postings___
--  060221  IsAnlk   Modified Cancel_Order_Receipt by changing pallet_list_ parameter as plsql table
--  060221           type and changed the code accordingly.
--  060220  IsWilk   Modified the text of FAC2INV by adding repairshop instead of facility
--  060220           in PROCEDURE Call_Part_Serial_Catalog___.
--  060217  JoAnSe   Added pre_trans_level_qty_in_stock and pre_trans_level_qty_in_transit
--  060217           to Get-metod. Removed obsolete column cost from public view
--  060217  DAYJLK   Removed handling for transaction codes COSUPCONSM and CO-RETURN in Calc_Zero_Dir_Trans_Cost___.
--  060217  NiDalk   Small modifiaction in Call_Part_Serial_Catalog___ method.
--  060215  JoAnSe   Swapped use of pos_diff_transaction and neg_diff_transaction for Weighted Average
--  060215           case in Reverse_Rintotrcor_Trans___
--  060215           Added method Balance_Transit_And_Invent___ called from Post_Booking_Actions___
--  060215           to balance the inventory and transit accounts.
--  060215           Added parameter value_adjustment_ to Reverse_Accounting
--  060211  NuFilk   Modified method Get_Sum_Value_Per_Part to consider only M10 Postings.
--  060210  LEPESE   Removed attribute prior_weighted_average_qty. Added attribues
--  060210           pre_trans_level_qty_in_stock and pre_trans_level_qty_in_transit.
--  060210           Large modifications in methods Calc_Plus_Dir_Trans_Cost___,
--  060210           Calc_Minus_Dir_Trans_Cost___ and Calc_Zero_Dir_Trans_Cost___ for inventory
--  060210           valuation methods AV, FIFO and LIFO. Created methods Remove_Fifo_Lifo_Cost and
--  060210           Set_Pre_Trans_Level_Qty___. Modifications in methods Cancel_Order_Receipt,
--  060210           Reverse_Transaction and New for valuation methods FIFO and LIFO.
--  060207  LEPESE   Modifications in method Reverse_Transaction in order to copy also transaction
--  060207           cost details with added_to_this_transacton = 'TRUE' from the original transaction
--  060207           to the cancel transaction. This concerns Material OH and Administration OH.
--  060207  LEPESE   Modifications in method Manage_Condition_Code___ in order to allow transactions
--  060207           with source_application_ = 'POSTCOSTGROUPCHANGE' although the serial_no_ is
--  060207           NULL for a CC enabled and serial tracked part.
--  060207  LEPESE   Modifications in methods Calc_Plus_Dir_Trans_Cost___, Calc_Minus_Dir_Trans_Cost___
--  060207           and Calc_Zero_Dir_Trans_Cost___ to transform transaction codes CONDCHGTR+ and
--  060207           CONDCHGTR- into zero direction transactions.
--  060206  JoAnSe   Set per_oh_adjustment_id to NULL in call to Do_Booking in Intersite_Move_Revaluation___
--  060206           when updating postings in another company to avoid reference errors.
--  060203  JoAnSe   Added Reval_WA_Supplier_Shipment, Reverse_Accounting.
--  060203           Change Reval_Cancel_After_Oh_Adjust to implementation method Reval_Canc_After_Oh_Adjust___.
--  060203           Rewrote Reval_WA_At_Empty_Inventory___
--  060202  LEPESE   Added configuration_id_ in calls to Inventory_Part_Unit_Cost_API.Generate_Cost_Details.
--  060202  LEPESE   Modifications in method Get_Mtrl_Overhead_Details___ because Costing has added
--  060202           parameters condition_code, value_method, cost_level and unit_cost to
--  060202           method Standard_Cost_Bucket_API.Issue_Material_Overhead_Cost.
--  060131  ShVese   Modified Create_Price_Diff_Postings___ to fetch qty arrived on purchase receipt.
--  060130  JoAnSe   Removed Reval_Cancel_Intord_Receipt___, replaced by Revalue_Reverse_Transaction___.
--  060127  JoAnSe   Changed Reval_Cancel_After_Oh_Adjust to handle new types of reversals.
--  060127           Changed interface for Reval_Cancel_Intord_Receipt___ and Revalue_Reverse_Transaction___
--  060126  LEPESE   Added parameter cost_source_ to method Manage_Condition_Code___ in order to
--  060126           avoid error message when making stock revaluation transactions for parts
--  060126           which are condition code handled.
--  060121  NuFilk   Added Get_Sum_Value_Per_Part to fetch PWA part value on 'M10' accounts for Receive Not Yet Invoiced Report.
--  060126  NiDalk   Added Assert safe annotation.
--  060125  JoAnSe   Corrected average cost calculation in Get_Average_Intersite_Cost
--  060124  PrPrlk   Bug 55534, Modified the function Serial_Processed_On_Order.
--  060124  JoAnSe   In Cancel_Order_Receipt changed the value passed in to Unissue when
--  060124           Standard Cost is used. Changed the interface for Reval_Cancel_Order_Receipt___
--  060124           to allow the method to be used in more cases.
--  060124           Added Reval_Cancel_After_Oh_Adjust.
--  060119  JoAnSe   Bug 55374 corrected calculation of cost details in Calc_Plus_Dir_Trans_Cost___
--  060116  JoAnSe   Added Reval_Cancel_Receipt_In_Place.
--  060113  LEPESE   Modifications in method Manage_Condition_Code___ in order to avoid error msg
--  060113           when making transactions with source_application = 'POSTCOSTGROUPCHANGE' for
--  060113           parts with cost level = Cost per Condition.
--  060113           Modifications in method Update_Cost_For_Part to be able to get a correct
--  060113           cost detail tab for transactions with cost_source = 'POST COST GROUP CHG'.
--  060113           Removed methods Get_Cost_Bucket_Type_Db___ and Get_Cost_Minus_Deliv_Oh___.
--  060113           Created method Get_Cost_Group_Chg_Cleaned___ for this purpose.
--  060111  JoAnSe   Removed obsolete attribute original_receipt_price.
--  060111           Removed parameter get_current_cost from several methods.
--  060111           Removed Get_Component_Arrival_Cost
--  060111  JaBalk   Passed the order_type_db_ parameter to Get_Sum_Value
--  060111           instead of passing its client value and removed the default null for to_date_ parameter.
--  060106  JaBalk   Changed the parameter order_type_ to order_type_db in Get_Wip_Cost.
--  060105  LEPESE   Bug 55037. Major redesign of methods Modify_Date_Applied, Redo_Error_Booking
--  060105           and Redo_Transaction_Postings___ in order to correctly handle the recreation of
--  060105           additional postings on cancel transactions.
--  051230  LEPESE   Added error message inside obsolete version of method Do_Booking.
--  051229  LEPESE   Major redesign of method Update_Cost_For_Part because of Cost Details.
--  051229  OSALLK   Modified the method Get_Consumed_Suppl_Consignment.
--  051229  LEPESE   Changes in method Condition_Code_Change_Reval___ to use revaluation events
--  051229           CO-CCREV- and CO-CCREV+ for supplier consignment stock.
--  051229  JaBalk   Modified Get_Pur_Order_Exchange_Cost___ to add TO_DATE(NULL).
--  051229  JaBalk   Modified GUI modification to Get_Consumed_Suppl_Consignment.
--  051228  JaBalk   Modified Get_Arrival_Cost_Value_Qty___ to add brakets for to_date_ condition.
--  051228  LEPESE   Added transaction codes PCGCHG-, PCGCHG+, PCGCHGTR-, PCGCHGTR+, CO-PCGCHG-'
--  051228           and 'CO-PCGCHG+' to Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master___.
--  051228  JaBalk   Modified defalut null to_date_ to normal parameter in Get_Arrival_Cost_For_Delivery,Get_Po_Return_Qty_And_Value
--  051228           Get_Arrival_Value_And_Qty
--  051227  OsAllk   Added new Procedure Get_Consumed_Suppl_Consignment.
--  051223  JaBalk   Added to_date as default null to Get_Arrival_Cost,Get_Sum_Value,Get_Arrival_Cost_Value_Qty___
--  051223           Get_Arrival_Cost_For_Delivery procedure and function,Get_Po_Return_Qty_And_Value,Get_Arrival_Value_And_Qty.
--  051222  DAYJLK   Removed parameter co_consum_deliv_oh_ from Get_Deliv_Overhead_Settings___ and modified
--  051222           the conditions that create the CO-DELIVOH postings. Modified Call_Part_Serial_Catalog___ and
--  051222           Call_Lot_Batch_Master___ to handle transaction codes COSUPCONSM, CO-RETURN, and COUNSUCONS.
--  051222           Modified Do_Booking to remove the creation of CO-CONSUM and CO-RETURN postings.
--  051222           Modified Calc_Zero_Dir_Trans_Cost___ to handle COSUPCONSM, and CO-RETURN.
--  051219  LEPESE   Changes in method Condition_Code_Change_Reval___ for value_adjustment_.
--  051216  LEPESE   Changes in methods Calc_Plus_Dir_Trans_Cost___ for transaction codes
--  051216           CONDCHG+, 'CONDCHGTR+' and 'CO-CONDCH+'.
--  051216           Changes in methods Calc_Minus_Dir_Trans_Cost___ for transaction codes
--  051216           CONDCHG-, 'CONDCHGTR-' and 'CO-CONDCH-'.
--  051216           Changes in method Post_Booking_Actions___ for condition code change.
--  051216           Created method Condition_Code_Change_Reval___.
--  051214  OSALLK   Added new Function Get_Arrival_Cost_For_Delivery and added alt_source_ref
--                   columns as parametes to Get_Arrival_Cost_Value_Qty___
--  051213  LEPESE   Added boolean parameter retain_acc_year_cost_source_ in calls to method
--  051213           Inventory_Transaction_Cost_API.Create_Or_Modify_Details.
--  051213  LEPESE   Modifications in method Update_Cost_For_Part because the cost column has
--  051213           been removed from the database table.
--  051209  LEPESE   Removed method A_Unit_Cost_Is_Negative___. Changed validation of negative price
--  051209           in method New to only raise error if sum of unit cost details is negative.
--  051208  JoAnSe   Changed Recalc_Cost_On_Price_Update to allow all 'AV' cases.
--  051207  PrPrlk   Bug 54556, Added new function Serial_Processed_On_Order that validates delivered serial handled parts.
--  051205  JaBalk   Changed the alternate keys and alt_source_ref_type from private to public.
--  051201  LEPESE   Correction in method New to avoid error message when having quantity = 0
--  051201           on a 'ROUNDDIFF+' or 'ROUNDDIFF-' transaction with a serial_no != '*'.
--  051201  LEPESE   Removed check for invalid postings in method Modify_Date_Applied.
--  051129  LEPESE   Avoid period check in Modify_Date_Applied for ROUNDDIFF+ and ROUNDDIFF-.
--  051129  LEPESE   Added check for cost source = 'ROUNDING DIFFERENCE' in method New.
--  051128  LEPESE   Changes in method Get_Mtrl_overhead_Details___ : removed obsolete parameters
--  051128           in call to method Standard_Cost_Bucket_API.Issue_Material_Overhead_Cost.
--  051128           Moved implementation for transaction code CO-UNPSHIP to correct place in
--  051128           methods Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master___.
--  051125  LEPESE   Added handling of transaction codes PURDIR and INTPURDIR. Also added new
--  051125           new delivery overhead event code PC-DELIVOH.
--  051125  JoAnSe   Changes in Intersite_Move_Revaluation to handle different types of adjustments.
--  051122  JoAnSe   Added new attribute inventory_valuation_method assigned a value in the New method
--                   Cost no longer returned by Get-method.
--  051121  LEPESE   Added transaction codes 'ROUNDDIFF+' and 'ROUNDDIFF-' to methods
--  051121           call_Part_Serial_Catalog___ and Call_Lot_Batch_Master___.
--  051117  JoAnSe   Added parameters value_adjustment_ and per_oh_adjustment_id_ to Do_Str_Event_Acc
--  051115  JoAnSe   Added new attribute inventory_part_cost_level assigned a value in the New method
--  051114  JoAnSe   Changed Intersite_Profit_Reval___ to update transaction cost as well as
--                   postings.
--  051111  JoAnSe   Removed attribute associated_transaction_id and corresponding methods
--                   now replaced with LU Invent_Trans_Interconnect.
--                   Added Intersite_Profit_Reval___
--  051107  JoAnSe   Replaced Set_Associated_Transaction_Id with Associate_Transactions
--                   Added Post_Booking_Actions___, Intersite_Move_Revaluation___ and
--                   Modify_Cust_Ord_Deliv_Cost___
--                   Added missing declarations for several implementation methods.
--                   Added parameter do_post_booking_actions_ to Do_Booking
--  051104  LEPESE   Added DATED as parameter when calling methods Merge_And_Complete_Details and
--  051104           Genereate_Cost_Details in package Inventory_Part_Unit_Cost_API.
--  051102  LEPESE   Changes in method Calc_Zero_Dir_Trans_Cost___ to create one default record in
--  051102           the cost_detail_tab_ when a single unit_cost_ is sent in instead of details.
--  051028  LEPESE   Complete redesign of method Set_Cost for cost details.
--  051028           Complete redesign of method Recalc_Cost_On_Price_Update for cost details.
--  051028           Added parameter per_oh_adjustment_id_ method Do_Booking. Also added this
--  051028           parameter to a lot of implementation methods in order to finally pass it
--  051028           when calling method Mpccom_Accounting_API.Do_Accounting from
--  051028           Do_Str_Event_Acc_Impl___. Changed Add_Mtrl_Overhead_Details___ into
--  051028           Get_Mtrl_Overhead_Details___.
--  051028           Total redesign of method Set_Cost because of cost details.
--  051028           Removed method Set_Prior_Weighted_Avg_Cost because of cost details.
--  051028           Total redesign of method Recalc_Cost_On_Price_Update due to cost details.
--  051023  LEPESE   Major changes in method Reverse_Transaction in order to enable inventory
--  051023           revaluation postings per cost detail. Created new methods
--  051023           Revalue_Reverse_Transaction___ and Reverse_Rintotrcor_Trans___.
--  051014  LEPESE   Major changes in method Cancel_Order_Receipt in order to enable inventory
--  051014           revaluation postings per cost detail. Created new methods
--  051014           Create_Value_Detail_Tab___, Reval_Cancel_Order_Receipt___,
--  051014           Reval_Wa_At_Empty_Inventory___ and Reval_Cancel_Intord_Receipt___.
--  051013  LEPESE   Added part_no_ in call to Inventory_Part_Unit_Cost_API.Merge_And_Complete_Details().
--  051010  LEPESE   Adapted methods Create_Price_Diff_Postings___ and Create_Po_Return_Price_Diff___
--  051010           to the new situation with cost details in method Do_Booking.
--  051007  LEPESE   Implemented solutions for Balance_Ext_Service_Cost___ and
--  051007           Balance_Po_Exchange_Cost___ in combination with cost details.
--  051006  LEPESE   Created new method Create_And_Account. Modifications in method Do_Booking
--  051006           to allow creation of value_detail_tab when single value is passed in.
--  051003  LEPESE   Added parameters in call to Inventory_Part_Loc_Pallet_API.Remove_Instance__.
--  050930  LEPESE   Merged DMC changes below.
--  ********************* DMC Merge Begin **************************
--  050921   LEPESE  Added new overloaded version of method Do_Transaction_Booking
--  050921           only one parameter transaction_id_.
--  050909  SeJalk   Bug 52988, Added parameter lot_batch_no_ to method calls Unissue, Unscrap and
--  050909           Move_To_Inventory in Part_Serial_Catalog_API. Removed the conditions and method call
--  050909           Part_Serial_Catalog_API.Modify_Lot_Batch_No from method Call_Part_Serial_Catalog___
--  050907  LEPESE   Changes in method Reverse_Transaction to fetch cost_detail_tab_ from
--  050907           old transacton and pass to Receive_Part when reversing an issue transaction.
--  050902  LEPESE   Complete redesign of method Do_Booking because of Cost Details.
--  050902           Added method Get_Deliv_Overhead_Settings___. Removed a lot of obsolete
--  050902           parameters to implementation methods (rcode_, ac_error_flag_).
--  050830  LEPESE   Removed attribute prior_weighted_average_cost. Added call in New to store
--  050830           prior_avg_cost_detail_tab_ in LU PreInventTransAvgCost.
--  050825  LEPESE   Changed datatypes of parameters and return values for the different calls
--  050825           to methods Inventory_Part_Cost_Fifo_API.Receive_Cost and
--  050825           Inventory_Part_Cost_Fifo_API.Receive_Cost. Added new parameters
--  050825           cost_bucket_group and cost_source_id in call to method
--  050825           Mpccom_Accounting_API.Do_Accounting from Do_Str_Event_Acc_Impl___.
--  050822  LEPESE   Added company as parameter to method Calc_Minus_Dir_Trans_Cost___.
--  050819  LEPESE   Added company as parameter to methods Calculate_Transaction_Cost___,
--  050819           Calc_Plus_Dir_Trans_Cost___ and Calc_Zero_Dir_Trans_Cost___. Added call to
--  050819           method Inventory_Part_Unit_Cost_API.Generate_Cost_Details from methods
--  050819           Calc_Plus_Dir_Trans_Cost___ and Calc_Zero_Dir_Trans_Cost___ for FIFO/LIFO.
--  050816  LEPESE   Changed interface in calls to Inventory_Part_Unit_Cost_API.Modify_Average_Cost.
--  050816           Added cost_detail_tab_ and source_ref info as parameters.
--  050812  LEPESE   A major redesign of the transaction cost handling due to introduction of
--  050812           cost details. Redesigned methods are New, Calculate_Transaction_Cost___,
--  050812           Calc_Plus_Dir_Trans_Cost___, Calc_Minus_Dir_Trans_Cost___ and
--  050812           Calc_Zero_Dir_Trans_Cost___. Also created several new smaller methods at the
--  050812           same time: Check_Zero_Cost_Flag___, Raise_Serial_No_Mandatory___ and
--  050812           Unknown_Value_Method___.
--  050809  LEPESE   Added method A_Unit_Cost_Is_Negative___.
--  050721  LEPESE   Added method Get_Latest_Transaction_Id.
--  050630  JoAnSe   Added Get_Last_Serial_Trans_Of_Type.
--  050518  JoAnSe   Added new method Create_Trans_Cost_Details___. Also added a new overloaded
--                   version of the New method taking cost details instead of price as parameter.
--                   Changed the Get_Cost method to retrieve cost by adding up cost in InventoryTransactionCost
--                   Cost no longer stored in the table, modified base methods accordingly
--                   Removed obsolete cursor Get_Inv_Tran_Hist.
--                   cost_ parameter in Calculate_Transaction_Cost___ replaced with cost_detail_tab_
--                   Added implementation methods Calc_Plus_Dir_Trans_Cost___,
--                   Calc_Minus_Dir_Trans_Cost___ and Calc_Zero_Dir_Trans_Cost____
--  ********************* DMC Merge End **************************
--  050923  AnLaSe   Changed to decode to fetch order_class_ in Refresh_Activity_Info.
--  050922  RoJalk   Bug 53344, Modified the variable length of latest_transaction_ in Call_Part_Serial_Catalog___ .
--  050921  NiDalk   Removed unused variables.
--  050906  JaBalk   Removed SUBSTRB from the base view INVENTORY_TRANSACTION_HIST.
--  050902  ErFelk   Bug 52052, Added parameter configuration_id_ to Call_Part_Serial_Catalog___
--  050902           and Call_Shop_Order_Receipt___. Added configuration_id_ to every method call
--  050902           to Part_Serial_Catalog_API.New_In_Inventory in above two methods.
--  050901  AnLaSe   SCAD623: Added transaction codes CONDCHG-/+, CONDCHGTR-/+ and CO-CONDCH-/+.
--  050831  KaDilk   Bug 52783, Increased the length of the variable user_group_ in procedure Modify_Date_Applied.
--  050824  NaLrlk   EMAD248: Added SODSPSCP to message for OPFEED-SCP and replace with comparison to IN( UNOPFDSCP, UNSODSPSCP)
--  050824           for UNOPFEED in methods Call_Lot_Batch_Master__ and Call_Part_Serial_Catalog___.
--  050823  IsAnlk   Added EXPIRATION_DATE as a key to InventoryPartInTransit LU and changed the code accordingly.
--  050817  DaYjlk   Bug 49976, Modified Calculate_Transaction_Cost___, Call_Part_Serial_Catalog___, and Call_Lot_Batch_Master___
--  050817           to handle new transaction codes WDR-OUT, WDR-IN, CO-WDR-OUT and CO-WDR-IN.
--  050725  NaWalk   Made the variable catch_quantity public.
--  050713  Asawlk   Bug 52051, Added two new parameters, acquisition_cost_ and purchased_date_ to method Call_Part_Serial_Catalog___.
--  050713           and modified body. Modifed method New inorder to pass values to new parameters added to Call_Part_Serial_Catalog___.
--  050705  IsWilk   Added the dynamic call to purch instead of the added static call of LCS patch 51176
--  050705           in PROCEDURE Balance_Po_Exchange_Cost___.
--  050630  HoInlk   Bug 49682, Modified Call_Lot_Batch_Master___ to handle MRO orders seperately when transaction code is OOREC or SUNREC.
--  050620  Asawlk   Bug 51930, Modified Unpack_Check methods and Modify_Date_Applied to check the
--  050620           whether the user is allowed for the site in particular situations.
--  050609  RoJalk   Bug 51670, Modified the message_ contents for RETCORCRE in Call_Part_Serial_Catalog___ and
--  050609           and Call_Lot_Batch_Master___.
--  050608  DAYJLK   Bug 51247, Modified Calculate_Transaction_Cost___ to include Delivery Overhead costs when valuation method is standard cost and direction is '+'.
--  050608  Asawlk   Bug 51176, Modified the method Balance_Po_Exchange_Cost___.
--  050428  Asawlk   Bug 49377, Added private attributes alt_source_ref1, alt_source_ref2, alt_source_ref3, alt_source_ref4 and alt_source_ref_type to the LU.
--  050428           Added procedures Set_Alt_Source_Ref and Validate_Alt_Source_Ref___. Callled Validate_Alt_Source_Ref___ inside Unpack_Check methods.Added new parameters
--  050428           alt_source_ref1_, alt_source_ref2_, alt_source_ref3_, alt_source_ref4_ and alt_source_ref_type_db_ to method Get_Sum_Value_Order_Line
--  050428           and modified the WHERE condition of cursor get_acc.
--  050420  KaDilk   Bug 50405, Modified the procedure Modify_Date_Applied.
--  050420           Added user_group to method Accounting_Period_API.Get_Accounting_Year.
--  050503  GeKalk   Modified method call to Inventory_Part_In_Transit_API.Unreceive_Part_To_Transit
--  050503           in Cancel_Receipt to handle catch quantity.
--  050429  GeKalk   Modified method calls to Inventory_Part_In_Stock_API.Unreceive_Part and Unissue_Part to handle catch quantity.
--  050404  Asawlk   Bug 49928, Modified Call_Part_Serial_Catalog___. Changed the serial_message and call to Part_Serial_Catalog_API.Unscrap_During_Disposition
--  050404           when original_trans_code_ = 'UNOPFEED'. Added function Get_Latest_Transaction_Id.
--  050329  JOHESE   Replaced calls to Customer_Consignment_Stock_API.Get_Sum_Consignment_Stock_Qty
--                   with Inventory_Part_At_Customer_Api.Get_Our_Total_Qty_At_Customer calls to include
--                   parts in consignment as well as parts awaiting delivery confirmation.
--  050324  Asawlk   Bug 49928, Modified Call_Part_Serial_Catalog___ to support transaction 'UNOPFEED'.
--  050316  AnLaSe   SCJP625: Handled new transaction codes in Calculate_Transaction_Cost, and Get_Sum_Value_Order_Line.
--  050316  AnLaSe   SCJP625: Added transaction codes DELCONF-OU, DELCONF-IN and DELIVCONF.
--  050310  SaLalk   Bug 49580, Added the method Check_Order_Exist.
--  050310  Samnlk   Modified the method Refresh_Activity_Info ,include order_type project to the selecttion.
--  050302  Samnlk   Renamed the method Get_Po_Qty_Scrap_Per_Ownship to Get_Quantity_Not_Reversed.
--  050224  Samnlk   Added a new parameter event_code to Create_Price_Diff_Postings___ and modify the method accordinly.
--  050207  SaNalk   Added Method Get_Po_Qty_Scrap_Per_Ownship.
--  050207  Samnlk   Modified the method Call_Part_Serial_Catalog___ to validate the part ownership for transaction 'ARR-COMP'.
--  050207  SaNalk   Modified Get_Po_Return_Qty_And_Value.Changed the cursor and FOR loop.
--  050204  JOHESE   Added call to Refresh_Activity_Info in Update_Cost_For_Part for project transactions.
--                   Removed procedure Refresh_Activity_Info___ and moved content to Refresh_Activity_Info.
--                   Removed call to Refresh_Activity_Info___ from Update___.
--                   Added Calc_Activity_Transfer_Cost___, Refresh_Activity_Trans_Cost___, Update_Project_Connection___ and
--                   a call to Update_Project_Connection___ in Do_Booking to handle the update of project cost
--                   when inventory parts are transferred in or out of projects.
--  050125  JaJalk   Modified the methods Cancel_Material_Backflish___ and made some corrections to the bkfl transactions after the review.
--  050125  SaNalk   Modified Get_Arrival_Cost_Value_Qty___.
--  050120  JaJalk   modified the method Cancel_Material_Backflush___ to update the quantity in the component.
--  050120  SaNalk   Modified Get_Arrival_Cost_Value_Qty___.
--  050118  JaJalk   Modified the get_backflush_transactions cursor in the method Cancel_Material_Backflush___.
--  050117  JaJalk   Modifed the method call Backflushed_Component_API to Backflushed_Supplier_Mtrl_API in Cancel_Material_Backflush___.
--  050111  WaJalk   Modified method Create_Po_Return_Price_Diff___, absolute value of price_diff_ was taken.
--  050107  SeJalk   Bug 48192, Truncated expiration date in procedures Insert___ and Update___.
--  050107  JaJalk   Modified the method Cancel_Material_Backflush___ to update the correct component line of the
--  050107           transaction been cancelled with the quantity issued.
--  050106  WaJalk   Modified method Get_Arrival_Price_Diff___, initialized the variable total_sum_value_.
--  050106  NuFilk   Modified method Reverse_Transaction.
--  050106  SaNalk   Modified Get_Arrival_Value_And_Qty.
--  041230  WaJalk   Modified Create_Price_Diff_Postings__, passed parameter price_diff_ to method call Do_Str_Event_Acc_Impl___.
--  041222  JOHESE   Added procedure Refresh_Activity_Info
--  041221  Samnlk   Remove the check for post price difference flag from Create_Po_Return_Price_Diff___.
--  041217  IsAnlk   Modified call to Mpccom_Accounting_API.Do_Accounting in Redo_Transaction_Postings___.
--  041216  WaJalk   Modified Create_Price_Diff_Postings___.
--  041216  SaNalk   Modified method Get_Po_Return_Qty_And_Value.
--  041215  Samnlk   Rename a method Get_Arrival_Cost_And_Qty___ to Get_Arrival_Cost_Value_Qty___ and added a new method Get_Arrival_Value_And_Qty.
--  041214  SaNalk   Added Method Get_Po_Return_Qty_And_Value.Removed methods Get_Po_Return_Qty_And_Cost___ and Get_Unmatched_Cost.
--  041213  Samnlk   Added condition to Create_Po_Return_Price_Diff___ and change the method call name in Get_Arrival_Price_Diff___.
--  041210  MaEelk   Added conditions when calling Create_Price_Diff_Postings___
--  041210           and Create_Po_Return_Price_Diff___ from Do_Booking___
--  041210  SaNalk   Modified Get_Po_Return_Qty_And_Cost___.
--  041210  Samnlk   Added a new method call Create_Po_Return_Price_Diff___ to procedure Do_Booking.
--  041210  NuFilk   Modified Cancel_Order_Receipt to handle posting value and Call_Lot_Batch_Master___ to handle OERET-INT and OERET-SINT.
--  041210           Modified method Reverse_Transaction to fetch the correct inventory value. Modifed Calculate_Transaction_Cost___.
--  041210           Modifed method Cancel_Order_Receipt to reverse receipt of serial parts using default value * for ARRTRAN.
--  041210  NuFilk   Modified method Get_Sum_Qty_Received, checked for inventory_stat_direction_db as 'RECEIPT' in cursor get_sum_qty_received.
--  041208  DiVelk   Changed position of PURBKFL,UN-PURBKFL in Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__.
--                   Modified parameters and logic of Cancel_Material_Backflush___.
--                   Added UN-PURSHIP,CO-UNPSHIP in cursor get_transactions.
--  041207  WaJalk   Modified Create_Price_Diff_Postings___ and called it from Do_Booking.
--  041207  SaNalk   Modified Get_Unmatched_Cost.
--  041206  WaJalk   Added Create_Price_Diff_Postings___.
--  041206  SaNalk   Added Get_Unmatched_Cost.Modified parameters in Get_Po_Return_Qty_And_Cost___.
--  041206  Samnlk   Added new implimentation method Get_Arrival_Cost_And_Qty___ and modify the methods  Get_Arrival_Cost and Get_Arrival_Cost_For_Delivery.
--  041203  DiVelk   Modified cursor get_bkfl_transactions in Cancel_Material_Backflush___. Added Cancel_Material_Backflush___ in Cancel_Order_Receipt.
--  041203  IsWilk   Added the relavant messages of the CO-UNPSHIP in PROCEDUREs Call_Part_Serial_Catalog___,
--  041203           Call_Lot_Batch_Master__.
--  041203  SaNalk   Added method Get_Po_Return_Qty_And_Cost___.
--  041202  SaJjlk   Modified catch quantity validation in Reverse_Transaction.
--  041202  DiVelk   Added UN-PURSHIP,UN-PURBKFL in Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__.
--                   Added PURBKFL in Calculate_Transaction_Cost___.Modified Cancel_Material_Backflush___.
--                   Added PURBKFL,CO-PURBKFL in cursor get_transactions.
--  041202  ErSolk   Bug 48139, Modified procedure Call_Lot_Batch_Master__.
--  041129  SaJjlk   Added more validations for catch unit handled parts in method Insert___.
--  041125  DiVelk   Added method Cancel_Material_Backflush___. Added 'PURBKFL' in Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master__.
--  041125  Samnlk   Added new implimentation methods Create_Po_Return_Price_Diff___ and Get_Arrival_Price_Diff___.
--  041123  IsWilk   Modified the PROCEDURE Prepare_Transfer to pass the execution_offset_ into the Transfer_To_Finance.
--  041122  WaJalk   Added coding to handle serial tracking parts for transaction code OWNTRANOUT in Call_Part_Serial_Catalog___.
--  041119  DaYjlk   Bug 48090, Modified Reverse_Transaction by replacing condition code with NULL in calls to methods New and Inventory_Part_In_Stock_API.Receive_Part.
--  041118  DaYjlk   Bug 48064, Added code to handle part cost level COST PER CONDITION to create revaluation transactions in Reverse_Transaction.
--  041118  MaEelk   Added implementation method End_Do_Booking___ and moved the code that is common to
--  041118           both externally owned stocks and company owned stock from Do_Booking to the new method.
--  041119           Created a exeption for Externally Owned Stocks inside Do_Booking.
--  041116  AnLaSe   Modified method Get_Average_Intersite_Cost.
--  041115  IsAnlk   Made implentation method Call_Lot_Batch_Master___ as private and changed the file accordingly (LCS-46421).
--  041110  JOHESE   Modified Insert___, Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master___
--  041108  SaJjlk   Removed unused variable qty_in_transit_ from Reverse_Transaction.
--  041105  SaJjlk   Added parameter catch_quantity_ to method Reverse_Transaction.
--  041103  AnHose   Bug 46466, Added userid as inparameter to the following methods, Do_Str_Event_Acc, Do_Str_Event_Acc_Impl___, Create_Delivery_Overhead___, Create_Po_Exchange_Postings___,
--  041103           Create_Retwor_Exch_Postings___, Create_Retcre_Exch_Postings___, Create_Material_Overhead___, Create_Admin_Overhead___, Balance_Ext_Service_Cost___, Balance_Po_Exchange_Cost___.
--  041103           Added userid in call to Do_Str_Event_Acc_Impl___ and Mpccom_Accounting_API.Do_Accounting.
--  041101  Samnlk   Added a another TRUE value to call Inventory_Part_In_Stock_API.Check_Quantity_Exist in method Cancel_Order_Receipt.
--  041101  WaJalk   Added new transaction code OWNTRANOUT to methods Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master___.
--  041029  SaJjlk   Added missing catch_quantity_ parameter to method calls for New in Reverse_Transaction.
--  041027  AnLaSe   Inter-site Profitability: Added transaction codes INTREV+,INTREV-,INTREVR+ and INTREVR-
--                   in Call_Lot_Batch_Master___ and Call_Part_Serial_Catalog___. Changed method Get_Average_Cost to
--                   Get_Average_Intersite_Cost.
--  041025  AnLaSe   Inter-site Profitability: Modified default values in method Get_Average_Cost.
--  041021  Samnlk   Modify methods New,Get_Arrival_Cost and Get_Arrival_Cost_And_Del_Oh to handle part ownership supplier owned.
--  041020  SaJjlk   Modifications to catch_direction in Insert___.
--  041015  SaJjlk   Added new column CATCH_DIRECTION.
--  041015  GaJalk   Bug 45454, Modified the procedure Cancel_Order_Receipt.
--  041014  AnLaSe   Inter-site_profitability: Added method Check_Order_Transaction.
--  041013  SaJjlk   Modifications to Inventory_Part_In_Stock_API.Issue_Part, Receive_Part.
--  040930  AnLaSe   Inter-site profitability: Added method Get_Average_Cost.
--  040914  JeLise   Bug 44704, Changed the calculation in Calculate_Qty_Onhand_Date and added
--                   Clear_Onhand_Develop_Globals.
--  040914  AnLaSe   Inter-site Profitability: Added check for cost_source 'INTERNAL SALES PRICE' in method Update_Cost_For_Part.
--                   Added transaction codes INTREV, INTREVR, INTCOS and INTCOSR in Call_Lot_Batch_Master___ and
--                   Call_Part_Serial_Catalog___.
--  040916  HeWelk   Modified New()- Added new parameter catch_quantity_.
--  040910  SaJjlk   Added catch_qty_ parameter to method calls Inventory_Part_In_Transit_API.Unreceive_Part_To_Transit and Remove_From_Order_Transit.
--  040909  ErSolk   Bug 46761, Modified function Get_Delivery_Overhead___ to stop the creation of
--  040909           postings when using zero_cost_only with delivery overhead in inventory part.
--  040908  HeWelk   Added catch_quantity to INVENTORY_TRANSACTION_HIST,INVENTORY_TRANSACTION_HIST2.
--  040907  DaRulk   Bug 46737, Modified Call_Part_Serial_Catalog___.
--  040906  ErSolk   Bug 46217, Renamed function Get_Received_Qty_Per_Order to Get_Sum_Qty_Received
--  040906           and changed parameters and content.
--  040827  DAYJLK   Call ID 117232, Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master___ to handle transactions TRANSIBAL+/-.
--  040825  DAYJLK   Call ID 117035, Modified Cancel_Order_Receipt to prevent removal of unit cost for ARRTRAN transactions.
--  040820  DAYJLK   Call ID 116866, Modified Call_Lot_Batch_Master___ to handle PODIRINTEM,INTPODIRIM,OERET-INT,OERET-SINT,RETWORKINT and RETCORWINT.
--  040818  DhWilk   Inserted General_SYS.Init_Method to Get_Component_Arrival_Cost.
--  040813  DAYJLK   Call Id 116516, Modified Call_Lot_Batch_Master___ to handle new transactions INTORDTR, RINTORDTR, RINTOTRCOR and UNRC-ARRTR.
--  040811  DAYJLK   Call Id 116342, Modified Calculate_Transaction_Cost___ to exclude WA calculation for ARRTRAN and OERET-INT.
--  040729  UsRalk   Added activity_seq to the calls to Receipt_Inventory_Location_API [Cancel_Order_Receipt].
--  040721  ErSolk   Bug 44801, Added function Get_Received_Qty_Per_Order.
--  040719  NuFilk   Modified method New, Calculate_Transaction_Cost___, Call_Part_Serial_Catalog___. Also Reverse_Transaction for case when direction is 0.
--  040719           Added code to create postings for INVREVTR+/- in Reverse_Transaction. Modified method Cancel_Order_Receipt for transaction ARRTRAN to handle parts in Internal Order Transit,
--  040709  MaEelk   Modified Set_Previous_Ownership.
--  040705  JOHESE   Modified methods Insert__ and New
--  040701  MaJalk   Bug 45566, truncated new_date_applied_ in  procedure Modify_Date_Applied.
--  040701  NuFilk   Added transaction to cursor in the Get method.
--  040623  JOHESE   Added function Get_Project_Id and modified Do_Booking and Redo_Transaction_Postings___
--  040621  SHVESE   M4/Transibal- Added parameter transit_qty_direction in call to InventoryPartUnitCost.Modify_Average_Cost.
--  040621           Added parameter transit_qty_direction in all calls to InventoryPartCostFifo methods Receive_Cost,
--  040621           Remove_Cost and Issue_Cost. Transibal changes in methods Cancel_Order_Receipt, New and Reverse_Transaction.
--  040616  JOHESE   Modified Reverse_Transaction to support project inventory
--  040616  ErSolk   Bug 39943, Added new IF statement in procedure Cancel_Order_Receipt to overcome error.
--  040608  ErSolk   Bug 39943, Modified procedure Cancel_Order_Receipt to create revaluation
--  040608           transaction to overcome error in inventory value when using weighted average.
--  040614  DaZaSe   Project Inventory: added activity_seq and project_id to view INVENTORY_TRANSACTION_HIST2.
--  040609  SaNalk   Added checks for work order and shop order in method Refresh_Activity_Info___.
--  040607  RoJalk   Bug 43715, Modified Update_Cost_For_Part.Corrected the code to prevent the imbalances
--  040607           in revaluation postings.
--  040603  RoJalk   Bug 45113, Added/Modified some valiadtions in Unpack_Check_Insert___ .
--  040526  DiVelk   Added procedure Refresh_Activity_Info___ and modified Update___.
--  040518  GaJalk   Bug 44042, Modified the procedure Call_Part_Serial_Catalog___.
--  040517  AnHose   Bug 44400, Changed out parameter cost_ from varchar2 to number in Get_Arrival_Cost,
--  040517           Get_Arrival_Cost_For_Delivery and in Get_Arrival_Cost_And_Del_Oh del_oh_ too.
--  040514  SeJalk  Bug 44460, Changed the error massages with the constants '1226' and 'PARTZEROCOSTONLY'.
--  040514  JOHESE   Adaptations for project inventory
--  040511  DaZaSe   Project Inventory: Added zero-parameter to calls to different Inventory_Part_In_Stock_API methods,
--                   the parameter should be changed to a real Activity_Seq value if this functionality uses Project Inventory.
--  ***********************  Touchdown Merge Begin  *********************************
--  040319  LEPESE   Correctd minor mistake in method Recalc_Cost_On_Price_Update. Removed
--                   hard-coded inventory valuation method in call to get delivery overhead.
--  040317  LEPESE   Modifications in method Recalc_Cost_On_Price_Update to make is usable
--                   also when running Transaction Based Invoice Revaluation with Standard Cost.
--  040312  LEPESE   Added default parameter get_current_cost_ to methods Get_Arrival_Cost and
--                   Get_Arrival_Cost_For_Delivery.
--  040312  LEPESE   Added default parameter get_current_cost_ to method Get_Component_Arrival_Cost.
--  040312  LEPESE   Modifications in Cancel_Order_Receipt. Unit Cost is stored in an internal
--                   PL table for later use when making revaluation bookings for standard cost.
--  040310  LEPESE   Major modifications: Removed the second package. Method Do_Booking_Impl___
--                   is moved to Do_Booking. Method also rewritten to use Lock_By_Keys___ instead
--                   of own cursor. Modifications in method Create_Delivery_Overhead___ to
--                   set the value of original_receipt_price for certain transaction codes.
--                   Modifications of method Get_Arrival_Cost, Get_Arrival_Cost_For_Delivery and
--                   Get_Component_Arrival_Cost in order to use original_receipt_price.
--                   Modification to method Set_Cost to make it possible to reset the
--                   original_receipt_price when method is used in Periodic Weighted Average
--                   Invoice Consideration. Removed method Set_Delivery_Overhead.
--                   Created new implementation methods Purchase_Order_Receipt___ and
--                   Direct_Ship_Customer_Order___ and Ext_Serv_Order_Comp_Receipt___.
--  040305  LEPESE   Modifications in Cancel_Order_Receipt to handle cancel of revaluation
--                   in corrective or reversive way depending on settings on the Company.
--  040305  LEPESE   Changed release_no, sequence_no, line_item_no into public attributes.
--  040304  LEPESE   Modifications in Calculate_Transaction_Cost___ to add delivery overhead
--                   to transaction price when cost level is Serial, Lot/Batch or Condition.
--  040304  JoAnSe   Made prior_weighted_average_cost updateable and
--                   prior_weighted_average_qty not updatable
--  040303  JoAnSe   Allowed Unissue for transactions 'PARTSWAP' and 'SERLOTSWAP' in
--                   Call_Part_Serial_Catalog___.
--  040302  LEPESE   Added call to Inventory_Part_Unit_Cost_API.Modify_Average_Cost in method
--                   Calculate_Transaction_Cost___ for PURSHIP, CO-PURSHIP, EXCH-SHIP and CO-EX-SHIP.
--  040301  JoAnSe   Added OUT parameter new_cost to Recalc_Cost_On_Price_Update
--  040227  JoAnSe   Added Recalc_Cost_On_Price_Update
--  040226  JoAnSe   Replaced original_cost with original_receipt_price
--                   Added Set_Delivery_Overhead and Set_Prior_Weighted_Avg_Cost
--  040225  JoAnSe   Added new attributes original_cost, prior_weighted_average_qty and
--                   prior_weighted_average_qty. Also added references for the existing
--                   attributes previous_part_ownership, previous_owning_vendor_no and
--                   previous_owning_customer_no.
--  040224  ChAmlk   Modified procedure Call_Lot_Batch_Master___ to set the condition code
--                   for new lot batch numbers when they are returned from the work order.
--                   Inserted tags to new code added, to identify changes done during Touch Down.
--                   Modified procedure Call_Part_Serial_Catalog___, to call
--                   Set_Serial_Ownership from Part Serial Catalog when trans
--                   code is WORECEIPT and current position is Issued.
--  040223  LEPESE   Moved fetch of current_part_cost_ in Cancel_Order_Receipt so that cost is
--                   fetched before any transactions are cancelled.
--                   Added attempt to lock InventoryPartUnitCost with NOWAIT in method New. The
--                   reason for this is to prevent any transactions from beeing created when
--                   the transaction based invoice revaluation is executing.
--  040220  LEPESE   Changes in Cancel_Order_Receipt. Moved fetch of current_cost_ before
--                   unissue transaction to avoid getting wrong cost when unit_cost record deleted.
--  040219  LEPESE   Added test on adjustment_date_ in Do_Booking_Impl___.
--  040217  LEPESE   Added PARTSWAP and SERLOTSWAP to Get_Component_Arrival_Cost.
--  040216  LEPESE   Added function Repair_Cost_Added_On_Arrival.
--  040215  LEPESE   Added function Get_Component_Arrival_Cost.
--  040213  LEPESE   Created method Transaction_Has_Posting_Error.
--  040129  LEPESE   Complete redesign of method Get_Committed_And_Actual_Costs.
--  040127  LEPESE   Added parameters value_adjustment and date_adjustment to methods
--                   Do_Booking and Do_Transaction_Booking. Added parameter value_adjustment to methods
--                   Do_Booking_Impl___, Do_Str_Event_Acc_Impl___, Create_Delivery_Overhead___,
--                   Create_Material_Overhead___, Create_Admin_Overhead___, Create_Po_Exchange_Postings___,
--                   Balance_Ext_Service_Cost___, Balance_Po_Exchange_Cost___, Create_Retwor_Exch_Postings___,
--                   and Create_Retcre_Exch_Postings___.
--  040122  LEPESE   Modifications in method Redo_Transaction_Postings___ due to the changed concept
--                   in Mpccom_Accounting where the values for debit and credit have the same sign.
--  040113  LEPESE   Modifications in method Get_Last_Non_Updatable_Day. Added call to method in
--                   Mpccom_Accounting_API. Modifications in method Get_Actual_Cost_Receipts. Added
--                   call to method Mpccom_Accounting_API.Transferred_Posting_Exists and removed
--                   check on obsolete column status_code in cursor.
--  040113  LEPESE   Bug correction in method Redo_Transaction_Postings___.
--  031219  LEPESE   Major redesign.
--  ***********************  Touchdown Merge End  *********************************
--  040316  ErSolk   Bug 43449, Removed bug 39943 correction.
--  040312  ThPalk   Bug 43172, Modified Call_Part_Serial_Catalog___ to support REP-SCRAP,UNREPSCRAP transactions.
--  040311  Asawlk   Bug 42385, Added private attribute expiration_date.
--  040311           Added expiration_date_ as a default null inparameter to public New Method.
--  040311           Modified the method of retrieving expiration_date in method Reverse_Transaction.
--  040305  ThPalk   Bug 43174, Modified method Call_Part_Serial_Catalog___
--  040302  GeKalk   Removed substrb from views for UNICODE modifications.
--  040227  ThPalk   Bug 36308, Added method Get_Activity_Cost_By_Status.
--  040223  ErSolk   Bug 39943, Modified Cancel_Order_Receipt.
--  040220  JOHESE   Bug 40241, Added new parameter in calls to Voucher_API.Voucher_End.
--                   Changes in Transfer_Invtran_Impl___ to take care of result_code
--                   from calling Mpccom_Accounting__API.Accounting_Transfer. If result_code_ = ERROR
--                   then the transaction history record receives status 99.
--  040212  ChAmlk   Bug 42683, Modified procedure Call_Part_Serial_Catalog___, to call Set_Serial_Ownership
--                   from Part Serial Catalog when trans code is WORECEIPT and current position is Issued.
--                   Modified procedure Call_Lot_Batch_Master___ to set the condition code for new
--                   lot batch numbers when they are returned from the work order.
--  040129  NaWalk   Rewrote the DBMS_SQL to Native dynamic SQL for Unicode modification.
--  040127  LoPrlk   Merge split packages, Package spec and body of INVENTORY_TRANSACTION_HIS2_API were removed with the init method.
--  040127  LoPrlk   Merge split packages, Methods Transfer_Invtran_Impl___ and Prepare_Transfer_Priv__ were moved form PKG2 to PKG.
--  040126  LoPrlk   Merge split packages, Method Call_Lot_Batch_Master___ was moved form PKG2 to PKG.
--  040126  LoPrlk   Merge split packages, Method Manage_Condition_Code___ was moved form PKG2 to PKG.
--  040126  LoPrlk   Merge split packages, Methods Call_Shop_Order_Receipt___ and Call_Part_Serial_Catalog___ were moved form PKG2 to PKG.
--  040123  LoPrlk   Merge split packages, Methods Modify_Status_Code_Impl___, Check_And_Complete_Booking___, Do_Booking_Impl___, Set_Control_Type_Key___, Create_Delivery_Overhead___,
--  040123           Get_Delivery_Overhead___, Create_Po_Exchange_Postings___, Create_Retwor_Exch_Postings___, Create_Retcre_Exch_Postings___, Do_Str_Event_Acc_Impl___, Balance_Ext_Service_Cost___,
--  040123           Balance_Po_Exchange_Cost___, Create_Material_Overhead___, Create_Admin_Overhead___ and Redo_Transaction_Postings___ were moved from PKG2 to PKG.
--  040123           Method PKG2.Redo_Error_Booking_Impl___ was absorbed into PKG.Redo_Error_Booking.
--  040121  ChBalk   Bug 38752, Modified the PROCEDURES Get_Arrival_Cost_For_Delivery and Call_Part_Serial_Catalog___.
--  040116  SaNalk   Added the obsolete cursor comment to cursor Get_Inv_Tran_Hist.Used the INVENTORY_TRANSACTION_HIST_PUB instead of this cursor.
--  040114  SaNalk   Removed Public cursor Get_Transaction_Value_Sum.
--  040113  LaBolk   Removed the call to public cursor get_str_event_acc in Do_Str_Event_Acc_Impl___ and used a local cursor instead.
--  040113  Asawlk   Bug 41885, Modified method Call_Part_Serial_Catalog___,
--  040113           stopped change of operational status for transaction codes PROJISS, PROJREC, SOISS, UNISS, BACFLUSH.
--  040108  JOHESE   Bug 40873, Modified Transfer_Invtran_Impl___, removed cursor get_zerocost_transaction and Modified the loop
--  031205  AnLaSe   Bug 40252, added method Check_Unissue_Allowed.
--  -------------------------- 13.3.0 ---------------------------------------------
--  031029  DAYJLK   Call Id 108682, Added checks in Manage_Condition_Code___ to raise error when a serial or lot/batch no is not entered when its required.
--  031022  JoAnSe   Changed Call_Part_Serial_Catalog___. Same processing for SERIAL-IN as for ARRIVAL
--                   Also added possibility to Unissue for NREC transaction.
--  031022  GaJalk   Modified the procedure Call_Lot_Batch_Master___.
--  031020  ChBalk   Bug fixed LCS #39564, Added 'SHIPDIR' to Call_Lot_Batch_Master___.
--  031017  DAYJLK   Merged Bug 32604, Added function Get_Committed_And_Actual_Costs. Added Global LU constant inst_GenLedProjVoucherRow_.
--  031016  PrJalk   Bug fix 106237, Added procedure Init.
--  031015  PrJalk   Bug Fix 106224, Corrected wrong General_Sys.Init_Method calls for Implementation methods declared in Package.
--  031014  NuFilk   Modified method Call_Part_Serial_Catalog___, Removed unnecessary check to Lot_Batch_Master_API.Exist when transaction code is 'ARRTRAN'
--  031014  MaGulk   Merged bug 39456, Changed the cursor get_zerocost_transaction added to 37131 to catch 0.0001 values.
--  031010  SuAmlk   Removed the error message added to raise when trying to receive a serial that is
--                   already in inventory in method Call_Part_Serial_Catalog___.
--  031010  DAYJLK   Call Id 106459, Modified Cancel_Order_Receipt to disable reversal of transactions when current ownership differs to that of the original transaction.
--  031009  AnLaSe   Call Id 105593: added method Modify_Lot_Batch_No.
--  031009  SuAmlk   Modified method Cancel_Order_Receipt to change the current position to 'In Facility' when the purchase receipt is canceled for MRO Flow.
--  031008  SuAmlk   Added an error message to be raised when trying to receive a serial that is
--                   already in inventory in method Call_Part_Serial_Catalog___.
--  031002  LEPESE   Call ID 103619: replaced the execution order for some statements in method
--                   Cancel_Order_Receipt to prevent the removal of records in InventoryPartUnitCost
--                   before the decision about revaluation transactions should be taken.
--  031002  SuAmlk   Added transaction code 'XO-ARRIVAL' to the where condition of cursor get_cost in method Get_Arrival_Cost.
--  030930  DAYJLK   Call Id 104193, Removed procedure Set_Transaction_Ownership.
--  030926  LEPESE   Call ID 103858: Added different error message for the zero_cost exception in
--                   method Calculate_Transaction_Cost___ for specific cost levels.
--  030922  PrTilk   Merged Bug 37447, Added an additional check in method NEW in order to skip fetching Inventory part information for non-inventory sales parts.
--  030918  JaBalk   Bug 38380, Added contract to Do_Accounting in Do_Str_Event_Acc_Impl___,Redo_Transaction_Postings___.
--  030917  JoAnSe   Added code to reverse the state in PartSerialCatalog in Reverse_Transaction
--                   And rewrote Call_Shop_Order_Receipt___
--  030916  ErSolk   Bug 37349, Modified Create_Delivery_Overhead___ and Calculate_Transaction_Cost___ to handle Delivery Overhead posting for Direct Delivery.
--  030915  JOHESE   Added handling of transaction OPFEED-SCP in Call_Part_Serial_Catalog___
--  030912  RaSilk   Bug 36868, Modified Call_Part_Serial_Catalog___ to Handle direct delivery of serial parts and transaction SERIAL_IN.
--  030912  RaSilk   Bug 37187, Added new parameters new_event_code_, order_no_, release_no_, sequence_no_, line_item_no_ to Create_Delivery_Overhead___
--  030912           and modifications to trigger new event RET-DEL-OH.
--  030912  JaJalk   Modified the method Reverse_Transaction for 0 direction.
--  030909  DAYJLK   Modified parameter list of Check_Receipt_In_Place.
--  030908  JoAnSe   Bug 30106 Call Part_Serial_Catalog_API.Issue instead of Unissue in Cancell_Order_Receipt.
--  030908  DAYJLK   Added public method Set_Transaction_Ownership.
--  030908  PrTilk   Changed method Call_Lot_Batch_Master___. Added new transaction code OERET-EX for returns for exchange order.
--  030908           Added new code for transaction codes 'OERET-SCP', 'OERET-SPEX' for scrap.
--  030905  JoAnSe   Additional changes in Cancel_Order_Receipt for reimplementation of bug 30106
--  030905  MaEelk   Reimplementation of LCS Bug ID 28689.
--  030905  MaEelk   Reimplementation of Bug ID 36364, Checked whether the transaction code is'CO-CONSUME' and fifo_lifo is true.
--  030905           If it satisfied the condition Called Inventory_Part_Cost_Fifo_API.Issue_Cost. Modifications were done in Calculate_Transaction_Cost___.
--  030904  LEPESE   Reimplementation of bug ID 32465. Also made some other modifications in
--                   method Reverse_Transaction.
--  030904  JaJalk   Modified the method Reverse_Transaction for service orders.
--  030903  Chamlk   Modified method Call_Part_Serial_Catalog___ to handle Parts with Current Position in 'Contained'.
--  030901  JoAnSe   Bug 30106 Part Serial History deleted when cancelling PO Receipt.
--                   Made changes in Cancel_Order_Receipt to reverse the state of a serial when
--                   a purchase receipt has been cancelled.
--                   Also made changes to allow receipt of existing serial no:s for transactions
--                   'ARRIVAL' and 'CO-ARRIVAL' in Call_Part_Serial_Catalog___
--  030828  PrTilk   Modified PROCEDURE Call_Part_Serial_Catalog___. Added new transaction codes for scrap and returns
--  030828           for exchange orders.
--  030826  GEBOSE   Added public method Get_Sum_Value_Imp_Fa_Object.
--  030820  DAYJLK   Performed CR Merge.
--  030512  NaWalk   Made changes to take the value of the 'Order_Code' from Order Line.
--  ********************************** CR Merge **************************************************
--  030815  DAYJLK   Modified Cancel_Receipt_In_Place and Cancel_Receipt_In_Place_Done. Beautified Call_Part_Serial_Catalog___ and Call_Shop_Order_Receipt___.
--  030814  Chamlk   Modified method Call_Part_Serial_Catalog___.
--  030725  DAYJLK   Modified method Cancel_Receipt_In_Place, Call_Part_Serial_Catalog___ and Unpack_Check_Update___.
--  030725           Added method Cancel_Receipt_In_Place_Done and Set_Transaction_Ownership___.
--  030725  JaJalk   Modified the method Cancel_Order_Receipt.
--  030724  DAYJLK   Modified method Cancel_Receipt_In_Place.
--  030724  GeKalk   Added previous_part_ownership, previous_owning_customer_no, previous_owning_vendor_no to INVENTORY_TRANSACTION_HIST2.
--  030723  DAYJLK   Added public method Cancel_Receipt_In_Place. Modified Call_Part_Serial_Catalog___ and Call_Lot_Batch_Master___ to handle 'XO-ARRIVAL' and 'XO-UNRCPT'.
--  030722  GeKalk   Added previous_part_ownership, previous_owning_customer_no, previous_owning_vendor_no to Insert and Update methods.
--  030721  DAYJLK   Added public Function Check_Receipt_In_Place.
--  030721  MaEelk   Added Part_Serial_Catalog_API.Set_Serial_Ownership to OERETURN and ARRIVAL in Call_Part_Serial_Catalog.
--  030718  GeKalk   Added previous_part_ownership, previous_owning_customer_no, previous_owning_vendor_no to
--  030718           INVENTORY_TRANSACTION_HIST_TAB and public method Set_Previous_Ownership().
--  030715  KiSalk   GEDI206NK Owner Codes- added transaction codes 'XO-TR-IN' & 'XO-TR-OUT' to ELSIF condition
--  030715           in methods Call_Part_Serial_Catalog___ & Call_Lot_Batch_Master___
--  030710  JaJalk   Modified the method Reverse_Transaction to handle the Scrap at Supplier functionality.
--  030709  MAJOSE   Added lot_batch_no_ and serial_no_ as new parameters in following methods:
--                   Create_Delivery_Overhead___, Create_Material_Overhead___ and Create_Admin_Overhead___.
--                   Modified Do_Booking_Impl___ due to changes in above methods.
--  030707  AnJplk   Added Create_Retwor_Exch_Postings___, Create_Retcre_Exch_Postings___ and modified Do_Booking_Impl___.
--  030701  JaJalk   Modified the method Balance_Ext_Service_Cost___, added exclude service cost restriction.
--  030627  KiSalk   GEEM219NC - PartSerialCatalog & New SO types - Applied the changes in procedure Call_Part_Serial_Catalog___
--  030627             and added Call_Shop_Order_Receipt___, as suggested by KeSmus and approved by JoAnSe & ShVese.
--  030625  AnJplk   modified procedure Balance_Po_Exchange_Cost___ .
--  030624  AnJplk   Add new procedure Balance_Po_Exchange_Cost___ and modified  Do_Booking_Impl___
--  030623  Chamlk   Modified procedures Call_Lot_Batch_Master___ and Call_Part_Serial_Catalog___ in order to handle WORECEIPT transaction.
--  030620  JaJalk   Added the method Balance_Ext_Service_Cost___ to handle the external service order functionality.
--  030618  MaGulk   Modified cursor get_Period_Part_Trans of Update_Cost_For_Part to exclude externally owned stock
--  030618  MaGulk   Modified cursor get_Actual_Cost_Receipts of Get_Actual_Cost_Receipts to exclude externally owned stock
--  030618  MaGulk   Modified Reverse_Transaction to exclude externally owned stock in inventory valuations
--  030618  MaGulk   Modified Cancel_Order_Receipt to exclude externally owned stock in inventory valuations
--  030618  MaEelk   Added Implementation Method Create_Po_Exchange_Postings___ and called it from Do_Booking_Impl___.
--  030617  AnJplk   Modified procedures Call_Lot_Batch_Master___ and Call_Part_Serial_Catalog___ in order to handle EXCH-SHIP transaction.
--  030616  DAYJLK   Moved restrictions that prevent changes in qty of parts frozen for counting from PROC Calculate_Transaction_Cost___ to New.
--  030613  GEBOSE   Added transaction codes REMFAPOOL and REPFAPOOL to Call_Part_Serial_Catalog___ & Call_Lot_Batch_Master___
--  030606  JOHESE   Added transaction codes SCRAPPOOL & IMPFAPOOL to Call_Part_Serial_Catalog___ & Call_Lot_Batch_Master___
--  030605  JOHESE   Added values for fixed asset object in Set_Control_Type_Key
--  030605           and added transaction code ADDFAPOOL to Call_Part_Serial_Catalog___ & Call_Lot_Batch_Master___
--  030529  JaJalk   Modified the procedure Call_Part_Serial_Catalog___ to Unissue MRO objects.
--  030528  DAYJLK   Modified method Reverse_Transaction to use Inv_Part_Ownership_Manager_API.Unissue_Part instead of
--  030528           the corresponding method in Consignment_Stock_Manager_API.
--  030523  JaJalk   Modified the procedure Call_Part_Serial_Catalog___.
--  030521  JaJalk   Removed the chr 132 from the procedure Call_Part_Serial_Catalog___.
--  030521  JaJalk   Modified the dynamic sql of Purchase_Order_Line_Part_API.Get_Order_Code in the procedure Call_Part_Serial_Catalog___.
--  030521  MaEelk   Modified prcedure Reverse_Transaction to pass ownership details for the call to Inventory_Part_In_Stock_API.Receive_Part
--  030520  JaJalk   Modified the procedure Call_Part_Serial_Catalog___ to handle the 'MRO' objects.
--  030519  DAYJLK   Modified Cancel_Order_Receipt, to use Inventory_Part_Stock_Owner_API.Get instead of using consecutive calls to methods Check_Exist
--  030519           and Get_Owning_Vendor_No in Inventory_Part_Stock_Owner_API and removed variables location_exist_ and location_vendor_no_.
--  030519  CaRase   Bug 37460, Replace bug 37041. Check if Ordertype is a Work Order before Call Work_Order_Coding_Api.Update_Voucher_Details in procedure Update__.
--  030509  MaEelk   Created Implementation methods Create_Delivery_Overhead___, Create_Material_Overhead___ and Create_Material_Overhead___.
--  030509           Moved the code written in Do_Booking_Impl___ to get Delivery Overhead, Material Overhead and Admin_Overhead to these three methods.
--  030508  JeLise   Bug 35121, Removed Norwegian Investment Tax.
--  030506  JaBalk   Bug 37131, Added cursor get_zerocost_transaction to update the staus of zero cost transcations
--  030506           to transferred in Transfer_Invtran_Impl___.
--  030502  ErSolk   Bug 36191, Removed bug correction.
--  030502  DhAalk   Bug 37041, Modified PROCEDURE Transfer_Invtran_Impl___ to dynamically call the PROCEDURE
--  030502           WORK_ORDER_CODING_API.Update_Voucher_Details.
--  030430  MaEelk   Replaced the Call to Consignment_Stock_Manager_API.Inventory_Transaction with Inv_Part_Ownership_Manager_API.Inventory_Transaction in Procedure New.
--  030429  ErSolk   Bug 36191, Modified if condition in Do_Booking_Impl___ by adding "order_type_db_ = 'CUST ORDER'".
--  030428  LEPESE   Added condition_code, valuation_method and part_cost_level as parameters
--  030428           in calls to method Inventory_Part_Unit_Cost_API.Init_Inventory_Value.
--  030427  LEPESE   Added lot_batch_no and serial_no as parameters in calls to method
--  030427           Inventory_Part_Unit_Cost_API.Init_Inventory_Value.
--  030425  MaEelk   Renamed New_Impl___ as Calculate_Transaction_Cost___.
--  030425           Part_Ownership, Owning_Vendor_No and Owning_Customer_No were made update not allowed.
--  030417  MaEelk   Modified Do_Booking_Impl___ to exclude overhead costs from External Owned Stocks.
--  030417  MaEelk   Added part_pwnership and owning_customer_no to the Public New Method.
--  030417  MaEelk   Created New_Impl___ and moved necessary validations for company owned and consignment stocks, to this method.
--  030417  ErSolk   Bug 36191, Modified if condition in Do_Booking_Impl___.
--  030331  JaBalk   Bug 36410, Changed the calculation in Get_Arrival_Cost_And_Del_Oh to show the difference
--  030331           between original transaction and return transaction on Report Diff when return to supplier report.
--  030324  MeEelk   Made new associations Part_Ownership, Owning_Vendor_No and Owning_Customer_No.
--  030324           Modifications were done that are relevent to Owner Code changes.
-- ********************************        TAKEOFF 2        ********************************
--  030315  ErSolk   Bug 36191, Modified Do_Booking_Impl___ to handle Delivery Overhead posting for Direct Delivery.
--  030220  ZAHALK   Bug ID 35269, Modified the code in order to fetch the reject_code as well.
--  030114  AnJplk   Bug 34853, Modified Set_Control_Type_Key___ Procedure.
--  021204  AnLaSe   Bug 28560. Added loop in method Get_Arrival_Cost, Get_Arrival_Cost_And_Del_Oh and
--                   Get_Arrival_Cost_For_Delivery to get an avarage cost for all transactions found.
--  021122  JeLise   Bug 34379, Removed correction done in bug id 32604.
--  021024  LEPESE   Bug 32465, Added new public attribute location_group.
--  021011  ANHOSE   Bug 33486. Correction in method Modify_Date_Applied to prevent transactions from being
--                   moved to anything but the latest period in the inventory value statistics.
--  021001  GaJalk   Bug 32604, Added function Get_Wip_Cost_So.
--  020924  AnHose   Bug 31329, Added Get_Arrival_Cost_For_Delivery.
--  020912  LEPESE   Bug 32806, Changes in methods New and Cancel_Order_Receipt in order to activate
--                   a recalculation of Weighted Average Purchase Price when cancelling an issue trans.
--  021024  LEPESE   Added transaction_code UNRCPT in Call_Part_Serial_Catalog___ and
--                   Call_Lot_Batch_Master___ to make cancel of repair order receipts work.
--  021023  ERHOUS   Added condition code to the call to Lot_Batch_Master_API.Issue for 'soiss' in method
--                   Call_Lot_Batch_Master___ to insure that condition code is place in lot batch history
--                   when issueing parts to a shop order.
--  021017  LEPESE   Added function Get_Id_List_For_Order_Trans.
--  021016  LEPESE   Added new transaction_codes ARR-COMP, SERLOTSWAP, PARTSWAP and ARR-REPAIR
--                   to methods Get_Arrival_Cost, Cancel_Order_Receipt, Call_Part_Serial_Catalog___,
--                   Call_Lot_Batch_Master and Get_Arrival_Cost_And_Del_Oh.
--  021014  LEPESE   Added check for cost source COST OF SERVICE in method Update_Cost_For_Part.
--  021014  JoAnSe   Replaced prefix PSC with LBM for all string constants defined in Call_Lot_Batch_Master.
--                   Also corrected the message created for transaction OERETURN in same method.
--  021010  LEPESE   Correction in method Modify_Date_Applied to prevent transactions from being
--                   moved to anything but the latest period in the inventory value statistics.
--  020923  LEPESE  ***************** IceAge Merge Start *********************
--  020830  LEPESE   Bug 32454, added call to method Set_Original_Transaction_Id in method
--                   Cancel_Order_Receipt also for transactions with direction = '0'.
--  020821  LEPESE   Bug 25415, redesign of behaviour when running Modify_Date_Applied and
--                   Redo_Error_Booking. When recreating postings for a transaction, all connected
--                   cancel-transactions must also be re-copied from their original-transaction.
--                   Running Modify_Date_Applied on a cancel-transaction should only update the
--                   field date_applied, no recreation of postings should occur.
--  020815  DaZa     Bug 30134, added Is_Pending checks to transactions codes OERETURN, OERET-NC, OERET-NO,
--                   OERET-SCP, OERET-SPNC and OERET-SPNO in method Call_Part_Serial_Catalog___.
--  020711  MiKulk   Bug 29351, Added transacation codes 'OERET-NC' and 'OERET-SPNC' to Call_Part_Serial_Catalog___.
--  020708  MAJE     Bug 30106, added code in CallPartSerialCatalog to reverse the transactions even when inspected.
--  020627  DaZa     Bug 30134, added transaction_codes OERET-INT and OERET-SINT to method Call_Part_Serial_Catalog___.
--  020625  MAJE     Modified serial message for bug fix 30106.
--  020603  MAJE     Bug fix 30106. Instead of always removing the part/serial number when unreceiving,
--                   we set it back to Under Transport in CallPartSerialCatalog for order code 4 - INTERNAL TRANSIT DELIVERY
--                   if receiving from the same company, else we set it back to Issued.
--  020510  JSAnse   Bug 28622, Added RETWORKINT and RETCORWINT in Call_Part_Serial_Catalog so it is handled as RETWORK and RETCORWORK.
--  020412  MAJE     Bug fix 29208. Stop the PrepareTransferPriv process if it will interfere with an already running process.
--  020923  LEPESE  ***************** IceAge Merge End ***********************
--  020913  LEPESE   Modifications in methods New and Cancel_Order_Receipt in order to get
--                   a correct recalculation of Weighted Average Purchase Price when
--                   running a Cancel_Order_Receipt. Moved call to method
--                   Part_Serial_Catalog_API.Remove from Call_Part_Serial_Catalog___ to
--                   Cancel_Order_Receipt for UNRCPT- transactions. Moved call to method
--                   Part_Serial_Catalog_API.Remove from Call_Part_Serial_Catalog___ to
--                   method Reverse_Transaction for SUNREC and RPSREC transactions.
--  020904  LEPESE   Created new method Manage_Condition_Code___ to be called from method New.
--  020813  LEPESE   Added 'INVREVAL+', 'INVREVAL-', 'CO-INVREV+', 'CO-INVREV-', 'INVREVTR+'
--                   and 'INVREVTR-' to Call_Part_Serial_Catalog___  and CAll_Lot_BAtch_Master___
--                   to make it possible to perform revaluation transactions on a
--                   specific individual or a specific lot_batch when changing condition_code.
--  020812  LEPESE   Modification in method New to avoid sending condition_code to Lot_Batch_Master
--                   for a serial_tracked part. Also implemented a set of rules to decide which
--                   condition_code to use on the transaction in different situations.
--  020808  LEPESE   Added condition_code as new parameter to methods New, Call_Part_Serial_Catalog___
--                   and Call_Lot_Batch_Master___. Added code to store condition_code when
--                   creating new records, and to send condition_code in calls to method
--                   New_In_Inventory in Part_Serial_Catalog_API and Lot_Batch_Master_API.
--  020806  JoAnSe   Added new method Check_Serial_Part_Exist.
--  020805  ChFoLk   Added new In parameter, Lot_batch_no into the PROCEDURE, Call_Part_Serial_Catalog___.  Modified the Procedure, New to add lot_batch_no into Part_Serial_Catalog_Tab.
--  020717  BEHAUS   Merged Lot Batch Mod functionality.
--  020703  PEKR     Modifications in Call_Part_Serial_Catalog___ and New
--                   to handle Serial Number Change (transactions SERREN-,SERREN+,CO-SERREN- and CO-SERREN+).
--  020627  PEKR     Added Operational_Status in some calls from Call_Part_Serial_Catalog___ (PROJISS,PROJREC,SOISS,BACKFLUSH,UNISS)
--  020620  LEPESE   Added call to Condition_Code_Manager_API.Get_Condition_Code in method New.
--  020619  LEPESE   Replaced calls to Inventory_Part_Config_API.Get_Inventory_Value_By_Method
--                   with calls to Inventory_Part_Unit_Cost_API.Get_Inventory_Value_By_Method.
--  020617  LEPESE   Redirected calls Inventory_Part_Unit_Cost_API.Init_Inventory_Value.
--  020612  JoAnSe   Changed serial messages created for RMA related transaction codes in
--                   Call_Part_Serial_Catalog___. Added handling for 'OERET-SPNC' and 'OERET-NC'.
--  020611  CHJALK   Added public attribute CONDITION_CODE to INVENTORY_TRANSACTION_HIST_TAB.
--  020607  JoAnSe   Allowed Unissue for Issued Serial Parts on Repair Order (order code '6') in
--                   Call_Part_Serial_Catalog___
--  020605  JoAnSe   Added parameter transaction_id_ in method Call_Part_Serial_Catalog___.
--                   Moved the call to the method from the beginning to the end of the New-method.
--                   Also added the parameter transaction_id_ and removed parameter latest_transaction
--                   in calls made to Part_Serial_Catalog.
--  020524  NASALK   Extended the serial_no  definitions from VARCHAR(15) to VARCHAR(50) in view comments
--                   and  in procedure Cancel_Order_Receipt.
--  020517  JoAnSe   Removed parameter current_position_ in calls to Part_Serial_Catalog_API.Scrap
--                   and Unscrap.
--                   Replaced call to Is_Pending and Pending in the same LU with calls
--                   to Is_Returned_To_Supplier and Return_To_Supplier.
--                   Replaced calls to Transport with Move_To_Transport.
--  020516  NASALK   Extended the serial_no variable definitions from VARCHAR(15) to VARCHAR(50).
--  ----------------------------- AD - Baseline -------------------------------
--  020227  LEPESE   Reversed all modifications made by THAJLK.
--  020210  THAJLK   Modified the procedure Transfer_Invtran_Impl___ to handle GL postings of Non-Inventory parts.
--  020122  CaSt     Bug 27475, Added ARRIVAL-DO to cursor get_cost in procedure Get_Arrival_Cost.
--  020117  THAJLK   Added new procedure Undo_Scrap_NonInv to handle scrap and undo scrap for Non-Inventory parts.
--  020117  THAJLK   Added new procedure Undo_Return_NonInv to handle Return for rework and Return for credit
--                   of Non-Inventory parts.
--  020116  THAJLK   Added new Procedure Cancel_Order_Receipt_NonInv to handle cancel rereipt of
--                   Non-Inventory parts.
--  020115  THAJLK   Added new Procedure Non_Inventory_Transaction to handle Non-Inventory parts.
--  020115  THAJLK   Added new public curser Get_Non_Inv_Tran_Hist to handle Non-Inventory parts.
--  011214  YOHE     Bug #25874, added method Get_Last_Trans_Id_Ord
--  011019  JOHESE   Bug fix 19495, Removed bug fix 24032.
--  011016  SuSalk   Bug 24658 fix,Extend the length of 'voucher_id_' to VARCHAR2(40).
--  011004  PEKR     Bug 19710. Project pre posting for WOISS. Set_Control_Type_Key___ modified.
--  011004  SuSalk   Bug 24658 fix,Extend the length of 'Company' to VARCHAR2(20).
--  010925  MAJE     Backing out change for bug 23714 done on 010831.
--  010919  AnHose   Bug 18007, Added Get_Arrival_Cost_And_Del_Oh.
--  010906  CaSt     Bug 24032, Added in-parameter location_no_ in procedure Reverse_Transaction.
--  010831  MGUO     Bug 23714, cost should not include charges for FIFO inventory valuation method in procedure New.
--                   Added Added dynamic call to Purchase_Order_Charge_API.Get_Charge_Amount.
--  010525  JSAnse   Bug fix 21463, Added General_SYS.Init_Method to Set_Cost, Set_Original_Transaction_Id, Set_Associated_Transaction_Id,
--                   Get_Last_Transaction_For_Part and Project_Postings_Transferred.
--  010515  LeIsse   Bug fix 20868, Changed INVREVAL+ to RINVREVAL- and INVREVAL- to RINVREVAL+
--                   in Cancel_Order_Receipt.
--  010510  LeIsse   Bug fix 21627, Added transaction code SHIPDIR to Call_Part_Serial_Catalog___.
--  010507  JOHESE   Bug Fix 21697, Optimized cursor get_transaction in procedure Transfer_Invtran_Impl___
--  010503  JeLise   Bug fix 21326, Added dynamic call to Purchase_Order_Line_Part_API.Get_Order_Code
--                   also added check on order_code_ in Call_Part_Serial_Catalog___.
--  010424  LeIsse   Bug fix 19202 (again), Corrected previous correction of 19202.
--                   Changed from material_overhead to admin_overhead on one place in Do_Booking_Impl___.
--  010411  DaJoLK   Bug fix 20598, Declared Global LU Constants to replace calls to TRANSACTION_SYS.Package_Is_Installed and
--                   TRANSACTION_SYS.Logical_Unit_Is_Installed in methods.
--  010405  JSAnse   Bug 20313. Added the functions calls User_Group_Period_API.Is_Period_Open and
--                   User_Group_Member_Finance_API.Get_User_Group and comment
--                   User_Group_Period_API.Check_If_Closed in PROCEDURE Modify_Date_Applied.
--  010321  MAJO     Bug 19202. Added shop order no info in call to Cost_Int_API.Get_Material_Oh_Cost
--                   to support Fixed Material OH per Batch calculation.
--  010302  ANLASE   Bug fix 19177, added new public attribute associated_transaction_id.
--  010212  LeIsse   Bug fix 19786, Several changes regarding accounting value and
--                   consignment event in Do_Booking_Impl___.
--  001219  SHVE     Changed exception handling in Redo_Transaction_Postings__ to handle
--                   sqlcode >= -20000.
--  001219  LEPE     Changes in Cancel_Order_Receipt to correct the check used to
--                   ensure that the quantity received on a CO-ARRIVAL still is
--                   in consignment stock when cancelling the CO-ARRIVAL. Cancel should
--                   not be allowed if the ownership of the quantity has been changed.
--  001215  LEPE     Made attributes date_applied, direction, valuestat_flag,
--                   partstat_flag, order_type public.
--  001214  LEPE     Performance improvement in Get_Wip_Cost_Sum. New parameter cost
--                   in call to Inventory_Part_In_Stock_API.Issue_Part from Reverse_Transaction.
--  001212  JOHW     Performance improvement in Get_Wip_Cost.
--  001212  SHVE     Corrected deduction of delivery overheads from cost when using weighted average.
--  001212  LEPE     Changed cursors in methods Get_Actual_Cost_Receipts and
--                   Update_Cost_For_Parts to achieve better performance.
--  001206  SHVE     Added parameters in call to Cost_Int_API.Get_Delivery_Oh_Cost.
--  001124  ANLASE   Added public method Check_Part_Exist.
--  001123  LEPE     Corrected bad spelling of transaction_code CO-DELV-OU.
--  001122  LEPE     Change in method Get_Actual_Cost_Receipts to include also
--                   purchase receipts when calculating receipts in period for manuf.
--  001116  JOHW     Added 'INVM-TRISS' to the procedure New where it calls
--                   Inventory_Part_Cost_Fifo_API.Issue_Cost.
--  001110  LEPE     Added check on cost_source.
--  001110  JOHW     Added method Project_Postings_Transferred.
--  001103  LEPE     Made use of new attribute cost_source in MpccomTransactionCode.
--  001101  LEPE     Added transaction code to method Update_Cost_For_Part.
--  001031  LEPE     Removed public attribute actual_cost_calculated.
--  001027  JOKE     Removed sodiff and podiff from the calculation in update_cost_for_part.
--  001027  LEPE     Added hard coded check for PODIFF+ and PODIFF- in method New.
--  001024  LEPE     Added transaction code INTPODIRSH to method Call_Part_Serial_Catalog___.
--  001023  JOKE     Added order_type_ to method Get_Actual_Cost_Receipts.
--  001019  JOKE     Added public method Get_Last_Transaction_For_Part.
--  001010  PEADSE   Added configuration_id in the select of CURSOR Get_Inv_Tran_Hist
--  001010  JOKE     Added NVL command to Get_Last_Non_Updatable_Day.
--  001009  JOKE     Added new public method set_original_transaction_id.
--  001005  JOKE     Added new public attribute original_transaction_id.
--  001004  JOKE     Added public method Update_Cost_For_Part, Set_Cost.
--  001002  SHVE     Added configuration_id in VIEW6(INVENTORY_TRANSACTION_TRACING).
--                   Changed VIEW comment PROMPTS for configuration_id.
--  001002  JOKE     Added method Get_Current_Transaction_Id.
--  001002  JOKE     Added method Get_Actual_Cost_Receipts.
--  000927  JOKE     Changed method Get_Last_Non_Updatable_Trans into
--                   Get_Last_Non_Updatable_Day.
--  000925  JOKE     Added method Get_Last_Non_Updatable_Trans.
--  000925  PERK     Removed checks to see if a part was manufactured and using weighted average as valuation method
--  000919  SHVE     Added IN parameter configuration_id in call to Receipt_Inventory_Location_API.Get_Qty_In_Store.
--                   Corrected a bug in Cancel_Order_Receipt by adding a Nvl in comparisions of InventoryPartInStock keys.
--  000918  JOKE     Added default values for actual_cost_calculated.
--  000918  JOKE     Added actual_cost_calculated which is a flag that shows
--                   which transactions that has been calculated within the
--                   actual cost method or not.
--  000911  SHVE     Added IN parameter configuration_id_ in calls to Cost_Int_API.Get_Material_Oh_Cost and
--                   Cost_Int_API.Get_Delivery_Oh_Cost.
--  000810  LEPE     Added new attribute configuration_id.
--  000619  LEPE     Adaptions in method Call_Part_Serial_Catalog___ to make it possible
--                   to received parts delivered on internal purchase order.
--  000616  SHVE     Added exist check for transaction ARRTRAN in method Call_Part_Serial_Catalog___.
--  000615  LEPE     Added state check and error handlingfor transaction codes
--                   OERET-SCP and OERET-SPNO in method Call_Part_Serial_Catalog___.
--  000607  NISOSE   Corrected the order of the parameters in calls to Inventory_Part_Location_API.Get_Qty_Onhand
--                   and Inventory_Part_Location_API.Get_Qty_Reserved.
--  000518  ANHO     Added check on Part_Serial_Catalog_API.Check_Exist for COUNT-IN.
--  000518  LEPE     Corrected parameter value in call to Inventory_Part_Location_API.Unreceive_Part.
--  000516  SHVE     Added setting of Mpccom_Accounting_API.Control_Type_Key_Rec.so_line_item_no_ in
--                   Set_Control_Type_Key___.
--  000505  ANHO     Replaced call to USER_DEFAULT_API.Get_Contract with USER_ALLOWED_SITE_API.Get_Default_Site.
--  000417  NISOSE   Added General_SYS.Init_Method in Check_Remove__.
--  000413  SHVE     Removed obsolete method Do_Cost_Move_Trans.
--  000407  SHVE     Increased length of sequence_no from 4 to 30.
--  000321  LEPE     Added EXCEPTION to close cursor in Call_Part_Serial_Catalog___.
--  000307  JOHW     Remarked the code for check_exist for part_no in
--                   Unpack_Check_Insert and Unpack_Check_Update.
--  000303  JOHW     Added Reference to Inventory Part and procedure Check_Remove__
--  000301  ROOD     Added method Redo_Transaction_Postings___. This made it possible to
--                   rewrite Modify_Date_Applied and Redo_Error_Bookings_Impl___.
--  000227  ROOD     Changes in Redo_Error_Booking_Impl___ to handle pre accounting for reversed transactions correct.
--  000221  ROOD     Changed length of local variable order_type_to_use_.
--  000218  LEPE     Added transaction codes OERET-NO and OERET-SPNO to Call_Part_Serial_Catalog___.
--  000217  JOHW     Changed to new User_Allowed_Site functionality.
--  000216  LEPE     Changes in method Transfer_Invtran_Impl___ to find the correct
--                   voucher_type based on transaction_date, user and company.
--  000215  ROOD     Added functionality for RMA in Set_Control_Type_Key___.
--  000209  LEPE     Remove call to obsolete package Pallet_Transport_Task_API.
--  000203  LEPE     Removed test on Fnd_User from method Prepare_Transfer_Priv__ since
--                   the view USER_ALLOWED_SITE_PUB is now only returning users sites.
--  000201  LEPE     Made attribute source public.
--  000201  LEPE     Added transactions for move between different companies to approproiate
--                   places. COMPM-OUT, COMPM-IN, COMPM-TRIN.
--  000117  ANHO     Replaced calls to get freeze_code from InventoryPart to get freeze_flag_db from
--                   InventoryPartLocation in method Inventory_Transaction.
--  000113  SHVE     Replaced calls to Site_API.Get_Inventory_Value_Method_Db with
--                   Inventory_Part_API.Get_Invent_Valuation_Method_Db.
--  000112  LEPE     Replaced obsolete transaction codes INVENT-IN, INVPART-IN,
--                   INVENT-OUT, INVPART-OU with COUNT-IN and COUNT-OUT in Call_Part_Serial_Catalog___.
--  000104  LEPE     Replaced use of obsolete ACCRUL methods in Modify_Date_Applied.
--  991110  LEPE     Bug fix 12434. Changes in method Inventory_Transaction to initiate
--                   the recalculation of Weighted Average Purchase price when receiving
--                   parts from another site into transit.
--  991108  ROOD     Bug fix 12481, Changes in Prepare_Transfer, Prepare_Transfer_Priv__
--                   and Transfer_Invtran_Impl___. Concerning handling of contract and company.
--  991102  LEPE     Bug fix 12420. Changes in method Call_Part_Serial_Catalog___
--                   thus making it possible to handle serials when using
--                   internal order flow (transactions SHIPTRAN and ARRTRAN).
--  991029  SHVE     Reorganised VIEW4, 5 and 6.
--  991025  FRDI     Bug fix 11253, Added NVL to Calculate_Days().
--  990924  SHVE     Corrected method Check_Created_Lot_Batch_No.
--  990919  ROOD     Replaced Utility_SYS.Get_User with Fnd_Session_API.Get_Fnd_User.
--  990917  SHVE     Added method Check_Created_Lot_Batch
--  990907  SHVE     Added VIEW4 and VIEW5, VIEW6.
--  990616  LEPE     Redesign of method Transfer_Invtran_Impl___.
--  990616  LEPE     Removed transaction_code SHIPOE from method Call_Part_Serial_Catalog___.
--  990604  DAZA     CID 9901, added date_ to methods Redo_Error_Booking_Impl___ and Redo_Error_Booking so
--                   Prepare_Transfer_Priv__ now can use date when calling to Redo_Error_Booking.
--  990602  LEPE     Improvements of public cursor Get_Inv_Tran_Hist for PROSCH.
--  990528  LEPE     Removed unused check for transaction_code CO-PSBKFL in Call_Part_Serial_Catalog___.
--  990527  LEPE     Correction for consignment customer orders in Get_Sum_Value_Order_Line.
--  990526  LEPE     Removed obsolete transaction codes LOT_B-OUT and LOT_B-IN.
--  990512  ROOD     Performance improvements in Modify_Status_Code_Impl___ and Modify_Status_Code_Acc.
--                   Added method Get_Sum_Value_Prod_Sched_Mtrl. Minor changes in Transfer_Invtran_Impl___.
--  990511  DAZA     Cleaned up some old obsolete cursor handling in Transfer_Invtran_Impl___ and changed the lock.
--  990507  LEPE     Adding transaction_code UNRCPT+ in method Call_Part_Serial_Catalog___.
--  990506  ANHO     Gets the expiration_date from InventoryPartLocation in Reverse_Transaction.
--  990506  SHVE     Performance improvements in Redo_Error_Booking_Impl__.
--                   Replaced calls to Inventory_Part_API.Get_Inventory_Value with Get_Inventory_Value_By_Method.
--  990505  DAZA     Changed select count(*) to select 1 in Check_Work_Order_Transaction. Fixed so db values
--                   are used as inparams in Check_And_Complete_Booking___ and Modify_Status_Code_Impl___.
--  990429  DAZA     General performance improvements. Changes in methods Do_Modify__, Do_Booking_Impl___
--                   and Transfer_Invtran_Impl___.
--  990426  JOKE     Added call to Set_Control_Type_Key___ in Do_Booking_Impl___.
--  990422  JOKE     Bug fix 9839: Rewrote Redo_Error_Booking so that it does the same accountings
--                   again, instead of finding out which events that has occured for this transaction
--                   and try to rerun those as new events (which isn't possible when you have used
--                   reverse_transaction because that method will not change the event_code for the
--                   reversed accounting... only the direction.).
--  990419  ROOD     Changed an incorrect IID-value in Inventory_Transaction.
--  990416  DAZA     Upgraded to performance optimized template.
--  990404  JOKE     Changed iid-value for Consignment to Vendor Consignment in calls to ConsignmentStockTrans.
--  990402  JOKE     Added handlig of Consignment Stock Unreceipt.
--  990330  ANHO     Added check in PROCEDURE Prepare_Transfer to allow multiple site transfers.
--  990330  LEPE     Removed check for supply_flag in method Inventory_Transaction.
--  990326  LEPE     Restructuring of method Call_Part_Serial_Catalog___ for consignment stock.
--  990322  JOKE     Added projrec and projiss to Call_Part_Serial_Catalog.
--  990319  JOKE     Assign variable cost_ with price_ when canceling a issue in Inventory_transaction.
--  990318  SHVE     Corrected method Get_Arrival_Cost to reduce the delivery overheads from cost.
--  990310  JOKE     Corrected my validation that only standard cost may be used with consignment
--                   stock in Inventory_transaction (Dishonor).
--  990309  JOKE     Added Get_Inventory_Value if unissue after revalue (Allowed for Standard Cost
--                   and Manufactured Weighted Average) In Inventory_Transaction.
--  990304  JOKE     Modified Where-Clause for cursor wip_cost in Get_Wip_Cost.
--  990302  JOKE     Updated calls to Consignment_Stock_Event_API with new DB-values.
--  990226  RaKu     Added old function Get_Wip_Cost (from 10.4).
--  990226  RaKu     Removed ACC_PERIOD from view/table/LU.
--  990224  SHVE     Removed obsolete methods Modify_Inventory_Statistic and Modify_Invent_Stat_Priv__.
--                   Corrections in Do_booking_Impl for delivery_overheads.
--  990219  JOKE     Changed where ActivitySeq is stored: prj_activity_seq_ := line_item_no_.
--  990213  JOKE     Added public methods: Set_Valuestat_Flag, Reset_Valuestat_Flag,
--                   Set_Partstat_Flag, Reset_Partstat_Flag.
--  990208  SHVE     Added validations of the value method used and calculation of accounting_value_
--                   in do_booking_impl__.
--  990208  JOKE     Removed order code from Get_Arrival_Cost.
--  990207  JOKE     Added handling of Consignment Stock in reverse_transaction.
--  990207  JOKE     Added Get_Consignment_Vendor_No.
--  990206  JOKE     Changed the IID values for Consignment_Stock_Event.
--  990205  SHVE     Modified Do_Booking_Impl___ to handle delivery overheads.
--  990203  JOKE     Modified Do_Booking_Impl___ so that it can handle consignment transactions.
--  990203  JOKE     Changed Call from Do_Booking in Do_Cost_Move_Trans to Do_Transaction_Booking.
--  990128  JOKE     Added transaction_code and consignment_vendor_no plus the
--                   methods Get_Transaction_Code and Do_Transaction_Booking.
--  980126  FRDI     Canged Var purchase_value_method_ to inventory_value_method_db_ (Site_API.Get_Inventory_Value_Method_Db);
--                   and added check in Modify_Date_Applied so no transaction can be done in advance.
--  980124  FRDI     Canged System parameter 'PURCHASE_VALUE_METHOD' to Site_API.Get_Inventory_Value_Method_Db (contract)
--  990121  JOKE     Added order_type 'PROJECT' to Do_Booking_Impl___.
--  990118  JOKE     Changed default values from 0 to NULL in Voucher Transfer interface.
--  990116  JOKE     Changed voucher transfer interface to use newer methods in accrul.
--  990113  FRDI     Added contract as an parameter to Do_Str_Event_Acc
--  981229  FRDI     Changed Sysdate to site dependent 'sysdate' - Site_API.Get_Site_Date(contract)
--                   and added contract to invariables in Do_Str_Event_Acc_Impl___ ()
--  981213  JOKE     Modified call to Consignment_Stock_Manager_API.
--  981212  JOKE     Removed default parameter consignment_stock_ to inventory_transaction.
--  981209  JOKE     Added default parameter consignment_stock_ to inventory_transaction.
--  981206  JOKE     Added default parameter vendor_no to inventory_transaction.
--  981124  JOKE     Added call to Inventory_Part_Loc_Pallet_API.Remove_Instance__ in
--                   Cancel_Order_Receipt.
--  981122  FRDI     Full precision for UOM, change comments in tab.
--  981118  SHVE     Corrected bug in dynamic call.
--  981106  SHVE     Added dynamic calls to CostInt to fetch overhead costs in Do_Booking_Impl__.
--  981101  JOKE     Added default parameter pallet_list_ to cancel_order_receipt and
--                   code to remove pallets connected to the cancelled purchase_order.
--  981027  SHVE     Replaced calls to InventoryPartCost with calls to methods in InventoryPart.
--  981022  JOKE     Rewritten Cancel_Order_Receipt and corrected removal of
--                   individuals in Call_Part_Serial_Catalog___. Removed
--                   obsolete transactions in get_arrival_cost. Corrected
--                   FIFO/LIFO handling in inventory_transaction.
--  981019  SHVE     Removed calls to InventoryPart get_serialization_flag and
--                   get_lot_tracking_code.
--  980921  JOKE     Added temporary variable for out parameter in Reverse_Transaction.
--  980909  LEPE     Removed obsolete method Porecept_Inventory_Transaction.
--  980904  LEPE     Made attribute part_no public. Added method Get_Transaction_Contract.
--  980903  LEPE     Made attributes lot_batch_no, eng_chg_level, serial_no and waiv_dev_rej_no public.
--  980828  SHVE     Removed splitting of location no in  VIEW2.
--  980819  RaKu     Changed return type to VARCHAR2 and attribute to LOCATION_NO in Get_Location_No.
--  980819  JOHW     Changed Inventory_Part_API.Get_Mrp_Order_Code to Inventory_Part_Planning_API.Get...
--  980819  GOPE     New methods for handling Unissue and Unreceive in Invnetory
--  980814  GOPE     Added method Get_Quantity
--  980807  GOPE     Added the corection transactions for srapping, return that is used in purchase.
--                   Used when receiving serials
--  980623  GOPE     Added method CancelOrderReceipt to cancel a receipt for a order
--  980518  GOPE     Added CallPartSerialCatalog, gather all calls to PartSerialCatalog
--  980423  LEPE     Added PROCEDURE Get_Accting_Value_Latest_Trans. Remove two arguments
--                   from function Check_Work_Order_Transaction. Added argument in call to
--                   Invent_Event_Creation_API.Invtran_Hist_Events.
--                   Added FUNCTION Get_Sum_Value_Order_Line.
--  980422  SHVE     SID 3982: Added a decode statement for status_code in VIEW2
--  980422  GOPE     Correction in Porecept_Inventory_Transaction when making several unreceipt
--  980421  JoAn     Added parameter order_code to Get_Arrival_Cost
--  980420  GOPE     Changed text for PICK-IN, PICK-OUT in inventory_transaction
--  980417  FRDI     Added description in patch pocesses.
--  980415  GOPE     Added FAC2INV in inventory_transaction
--  980408  JoAn     SID 3086 Added handling for transaction_code 'ARRTRAN' and
--                   'ARRTRAN-DO' in Inventory_Transaction and Get_Arrival_Cost.
--  980406  NAVE     Added generic call to Event server (for registering count result)
--                   in method: Inventory_Transaction.
--  980402  GOPE     Forgot a NULL when making serial text
--  980402  GOPE     Added check in InventoryTransaction that quantity = 1 when using individuals
--  980401  GOPE     Added order_no,.., order_type to calls to part serial catalog in
--                   method inventory_transaction
--  980326  GOPE     Correction of part serial catalog messages
--  980326  LEPE     Added argument order_type to function Get_Sum_Value.
--  980317  GOPE     Added ps_ varables in Do_Booking_Impl___
--  980317  GOPE     Added Get_Transaction_Id_For_Accting, Bug 2774
--  980306  LEPE     Removed unnecessary function calls in Insert___ and Update___.
--  980305  JICE     Bug 3651, JOHNIs 10.3.1 changes: Major changes in inventory
--                   statistics batch. Procedure Modify_Invent_Stat_Priv__ rewritten.
--  980304  GOPE     Added checks in method inventory_transaction on code POQA-IN
--  980227  GOPE     Added checks in method inventory_transaction on code POINV
--  980223  JOHO     Remove rounding on price/cost objects.
--  980217  LEPE     Added rounding of OUT parameter value in method Inventory_Transaction.
--  980212  FRDI     Format on Amount Columns.
--  980213  GOPE     Added PartSerialCatalog interface in method InventoryTransaction
--  980127  GOPE     Added check for zero cost only in Inventory_Transaction
--  980123  GOPE     Added 'PSDIFF+', 'PSDIFF-' in method Inventory_Transaction
--  980114  GOPE     Added public cursor Get_Inv_Tran_Hist for repetitive production
--  971128  GOPE     Upgrade to fnd 2.0
--  971106  JICE     Corrected Get_Arrival_Cost; now searches for ARRIVAL-DO
--                   transactions as well as ARRIVAL.
--  971006  GOPE     Change in method Redo_Error_Booking_Impl___ added exeption handling
--                   to concatenate error msg.
--  971003  GOPE     Corrected the cursor in method Get_Wip_Cost_Sum
--  970825  JICE     Created a view, Inventory_Transaction_Values, which is the view used
--                   in the public cursor Get_Transaction_Value_Sum.
--  970822  JICE     Removed check on valuestat_flag on Get_Transaction_Value_Sum.
--  970808  JICE     Added public cursor Get_Transaction_Value_Sum - used in
--                   inventory value report.
--  970618  PEKR     Corrected Get_Sum_Value_Shop_Order_Mtrl.
--  970617  JOED     Beautified parts of the code. Added _db columns in the view.
--  970612  JICE     Added transaction for WIP in Porecept_Inventory_Transaction.
--  970611  FRMA     Correction: No fifo operations for internal inventory move.
--  970606  GOPE     corrections for voucher connetions
--  970529  MAGN     Modified public Get-functions according to Foundation 2.0.0. Support_id 230.
--  970516  FRMA     Modified cursor in Modify_Date_Applied.
--  970516  FRMA     Added contract_ as inparameter to Modify_Inventory_Statistic.
--  970516  FRMA     Bug 97-0052
--  970515  PEKR     Added contract_ as inparameter to Redo_Error_Booking.
--  970515  FRMA     Replaced function Currency_Rate_API.Get_Currency_Rate with
--                   procedure Currency_Rate_API.Get_Currency_Rate_Defaults.
--  970506  PAKA     Added Get_Reject_Code_When_Qty and Get_Accounting_Id_When_Qty.
--  970507  TOWI     Added function Get_Contract.
--  970505  FRMA     Replaced Mpccom_Company_API with Company_Finance_API.
--  970429  PEKR     Replaced Get_Home_Company with Site_API.Get_Company.
--  970429  FRMA     Replaced Mpccom_Currency_Rate with Currency_Rate.
--  970425  FRMA     Added parameters in call to Unreceive_Part,
--                   from Porecept_Inventory_Transaction.
--  960821  MAOR     Changed datatype of inparameter to date in prepare_transfer
--                   and datatype of inparameter to date in transfer_invtran__.
--                   Also changed handle of tran_date_ in transfer_invtran__.
--  960820  MAOR     Added procedure Update_Inventory_Statistic.
--  960816  MAOR     Added procedure Prepare_Transfer, Transfer_Invtran__.
--  960814  JICE     Modified Get_Arrival_Cost to return NULL if record not found.
--  960808  JICE     Added procedure Get_Arrival_Cost.
--  960805  AnAr     Added Function Calculate_Total_Quantity and
--                         Function Calculate_Days.
--  960805  AnAr     Added Function Calculate_Qty_Onhand_Date.
--  960705  HARH     Added procedure Do_Cost_Move_Trans.
--  960704  JICE     Changed number of arguments for bind on numeric columns.
--  960619  SHVE     Replaced call to module PURCHASE with dynamic sql in the
--                   procedure
--                   in call to Unreceipt_Part (Incorrect use of conv_factor).
--  970425  CHAN     Added call to Inventory_Part_Loc_Pallet, in Porecept_Inventory_Transaction.
--  970424  FRMA     Replaced procedure get_cost with function get_cost. Added
--                   get_acconting_id, get_qty_reversed.
--  970422  NAVE     Removed unnecessary exceptions associated with serial no checks.
--  970418  NAVE     Moved validation of lot_batch/serial_no to PARTLOC.APY.
--  970417  FRMA     Changed Client_Value to Db_Value in cursor for
--                   Porecept_Inventory_Transaction.
--  970416  FRMA     Changed call to Issue_Cost in procedure Inventory_Transaction.
--  970408  FRMA     Modified Inventory_Transaction and Porecept_Inventory_Transaction
--                   for FIFO/LIFO. Added procedure Get_Sum_Value_Shop_Order_Mtrl.
--  970317  MAGN     Changed tablename mpc_invtran to invetory_transaction_hist_tab.
--  970220  JOKE     Uses column rowversion as objversion (timestamp).
--  970212  GOPE     Correction in Porecept_Inventory_Transaction check against
--                   Inventory_Flag_API
--  970124  FRMA     Added check for statistic periods in Modify_Date_Applied.
--  970114  MAOR     Added parameter to Modify_Invent_Stat_Priv__.
--  970113  FRMA     Changed order of parameters in call to Do_Booking. (Modify_Date_Applied).
--  970113  AnAr     Added procedure Modify_Qty_Reversed.
--  960113  AnAr     Fixed Do_Booking_Impl___.
--  961223  PEKR     Changed Gen_Yes_No_API to Material_Addition_API and
--                   Administration_Overhead_API in Do_Booking_Impl___.
--  961219  JICE     Corrected handling of OrderType.
--  961216  MAOR     Added function Check_Work_Order_Transaction.
--  961214  MAOR     Removed user_ in call to Inventory_Value_API.Modify_Inventory_Value
--                   and Inventory_Part_Period_Hist_API.Update_Part_History.
--                   Changed Get_Db_Value to Get_Client_Value.
--  961211  JICE     Changed parameters on Modify_Invent_Stat_Priv__ and
--                   Modify_Inventory_Statistic.
--  961211  MAOR     Changed file to new template.
--  961204  MAOR     Changed parmeters in call to Inventory_Part_Location.Unreceive_Part.
--                   Changed name on Modify_Invent_Stat_Impl___ to
--                   Modify_Invent_Stat_Priv__ and Prepare_Transfer_Impl___ to
--                   Prepare_Transfer_Priv__.
--  961204  MAOR     Changed order of parameters in call to Inventory_Part_Cost_API.
--  961204  JOBI     Changed parameter new_date_applied in procedure Modify_Date_Applied to date format.
--  961204  MAOR     Changed to Rational Rose Model and Workbench standard.
--  961129  JOBI     Replaced call to function Mpccom_Accounting_API.Get_Accounting_Id
--                   to Mpccom_Accounting_API.Check_Voucher_Accounting(Accounting_id)
--  961125  JOBI     Replaced call to function Get_Flags in LU Accounting_Event_API
--                   with calls to Get_Material_Addition_Flag, Get_Ms_Addition_Flag,
--                   Get_Oh1_Burden_Flag, Get_Oh2_Burden_Flag, Get_Online_Flag
--  961125  JOBI     Replaced call Mpccom_Company_API.Get_Home_Company_Currency
--                   with Mpccom_Company_API.Get_Curr_Code(Mpccom_Company_API.
--                   Get_Home_Company).
--  961120  JOBI     Added procedure Modify_Date_Applied.
--  961119  MAOR     Replaced call to Inventory_Part_API.Get_Partdesc_Flags
--                   with function calls.
--  961118  JOBE     Changed function call Mpccom_System_Parameter_API.Get_Value to
--                   Mpccom_System_Parameter_API.Get_Parameter_Value1.
--  961114  MAOR     Changed order of part_no and contract in call to LU
--                   Inventory_Part_API. Changed call to get_lead_time_code to use
--                   function.
--  961114  JOBE     Changed function name Get_Transaction to Check_Valid_Transaction_Code.
--                   Removed call to Get_Transaction_Info and added call to 3 public functions.
--  961110  GOPE     Change call to Get_Conv_Factor in Purchase Order Line
--  961015  MAOR     Removed check if contract is authorized for this user in
--                   Unpack_Check_Insert__.
--  961015  MAOR     Added Batch_User in deferred_call. Changed use of
--                   User_Allowed_Site_API.Authorize to be Authorize_Batch_User.
--                   This in procedure: Prepare_Transfer__, Update_Inventory_Statistics__.
--  961011  JICE     Qty_Unissue stored in temporary variable in
--                   Make_Workorder_Unissue and Make_Intorder_Unissue
--                   to bypass Oracle bug when using global variables.
--  961010  PEKR     Add Get_Sum_Value.
--  960930  SHVE     Used column order_type_desc in onhdevel.apl also.
--  960927  GOPE     Added column order_type_desc to the views, order_type is DB value
--                   This fix should be removed during bug fix. changes in invtran.apl,
--                   transum.apl
--  960925  PEKR     Move PKG2 specification to APY file.
--  960920  PEKR     Add Get_Reject_code.
--  960920  PEKR     Do_Str_Event_Acc placed as public due to SHPORD usage.
--  960918  SHVE     Fixed bug in Transfer_Invtran.
--  960918  LEPE     Added exception handling for dynamic SQL.
--  960917  SHVE     Added deferred calls to procedures Prepare_Transfer and
--                   Update_Inventory_Statistic__.
--  960916  PEKR     Change &PKG2 to &PKG in Modify_Status_Code_Acc.
--  960916  PEKR     Add Modify_Status_Code_Acc.
--  960911  PEKR     Remove Do_Str_Event_Acc___ and Modify_Status_Code___ as
--                   public procedures.
--                   Change Mpc_Accounting_Pkg ==> Inventory_Transaction_Hist_API
--                   when calling Do_Booking.
--                   Reverse_Accounting and Complete_Check_Acc_Batch is called
--                   from Mpccom_Acconting_API.
--                   Add Redo_Error_Booking.
--  960904  JICE     Added handling of PURCHASE_VALUE_METHOD in
--                   Make_Workorder_Unissue__, added procedure
--                   Make_Intorder_Unissue__.
--  960902  SHVE     Replaced call to Voucher_Type_API with call to
--                   Mpccom_Voucher_Type_API.
--  960828  PEKR     Create Inventory_Transaction_His2_API
--                   Add Do_Booking, Do_Booking___, Do_Str_Event_Acc___.
--  960826  MAOR     Changed procedure Update_Inventory_Statistic added call to
--                   INVENTORY_PART_PERIOD_HIST_API.Update_Part_History.
--                   Added call to INVENTORY_VALUE_API.Update_Inventory_Value.
--  960822  HARH     Changed call to Do_Booking and rcode handling
--                   in procedure Do_Cost_Move_Trans
--  960822  MAOS     Added 'For update' clause in Porecept_Inventory_Transaction.
--  960821  MAOR     Changed datatype of inparameter to date in prepare_transfer
--                   and datatype of inparameter to date in transfer_invtran__.
--                   Also changed handle of tran_date_ in transfer_invtran__.
--  960820  MAOR     Added procedure Update_Inventory_Statistic.
--  960816  MAOR     Added procedure Prepare_Transfer, Transfer_Invtran__.
--  960814  JICE     Modified Get_Arrival_Cost to return NULL if record not found.
--  960808  JICE     Added procedure Get_Arrival_Cost.
--  960805  AnAr     Added Function Calculate_Total_Quantity and
--                         Function Calculate_Days.
--  960805  AnAr     Added Function Calculate_Qty_Onhand_Date.
--  960705  HARH     Added procedure Do_Cost_Move_Trans.
--  960704  JICE     Changed number of arguments for bind on numeric columns.
--  960619  SHVE     Replaced call to module PURCHASE with dynamic sql in the
--                   procedure Porecept_Inventory_Transaction.
--  960607  JOBE     Added functionality to CONTRACT.
--  960606  SHVE     Replaced call to Mpc_Sysparam_Pkg with call to
--                   Mpccom_System_Parameter_Api.
--  960524  SHVE     Replaced table reference to transaction_codes with call to
--                   MPCCOM_TRANSACTION_CODE_API.
--  960522  MAOS     Replaced reference to part_loc in Porecept_Inventory_Transaction with procedure
--                   Inventory_Part_Loc.Modify_Qty_Onhand and functions
--                   Inventory_Part_Loc.Get_Qty_Onhand and
--                   Inventory_Part_Loc.Get_Qty_Reserved.
--  960521  SHVE     Moved the procedure Inventory_transaction__ from
--                   PURCHASE_ORDER_RECEPTION_API and renamed it
--                   Porecept_Inventory_Transaction.
--  960514  SHVE     Replaced join cursor to part_description and part_status_code
--                   with a call to Inventory_Part_api.Get_Partdesc_Flags.
--  960502  MAOS     Created procedure New_Invtran. Replaced insert statement in
--                   procedure Inventory_transaction with New_Invtran.
--  960325  SHVE     Added procedure Get_Cost.
--  960321  SHVE     Cleaning up the file.
--  960307  JICE     Renamed from InvTransactionHistory
--  960215  SHVE     Changed LU name,Pkg_name,view_name(InvTransactionHistory).
--                   Moved procedure Calc_Total to Gen_Accounting_Api(Accting.ap*).
--                   Copied VIEW2, PROCEDURE ENUMERATE_TRANACTION_ID from GenInvtran.
--  960206  LEPE     Bug 96-0006. Changed parameter type for parameter newrec_
--                   in procedures Make_Wo_Unissue__ and Update___.
--  951204  STOL     Corrected error messages in proc. Inventory_Transaction.
--  951204  OYME     Added public function Get_Pre_Accoutning_Id. It fetches the
--                   pre_accounting_id used on an transaction_id.
--  951204  JICE     Corrected error messages
--  951121  LEPE     Added public function Check_Work_Order_Transaction.
--  951017  STOL     Base Table to Logical Unit Generator 1.
-----------------------------------------------------------------------------

layer Core;

-------------------- PUBLIC DECLARATIONS ------------------------------------

TYPE Purch_Receipt_Pallet_Rec IS RECORD (  
--   pallet_id       VARCHAR2(10),  -- LIM-NOTREADY
   contract         INVENTORY_TRANSACTION_HIST_TAB.contract%TYPE,
   part_no          INVENTORY_TRANSACTION_HIST_TAB.part_no%TYPE,
   location_no      INVENTORY_TRANSACTION_HIST_TAB.location_no%TYPE,
   lot_batch_no     INVENTORY_TRANSACTION_HIST_TAB.lot_batch_no%TYPE,
   serial_no        INVENTORY_TRANSACTION_HIST_TAB.serial_no%TYPE,
   eng_chg_level    INVENTORY_TRANSACTION_HIST_TAB.eng_chg_level%TYPE,
   waiv_dev_rej_no  INVENTORY_TRANSACTION_HIST_TAB.waiv_dev_rej_no%TYPE,
   handling_unit_id INVENTORY_TRANSACTION_HIST_TAB.handling_unit_id%TYPE );

TYPE Transaction_Id_Tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;

TYPE Lot_Batch_Rec IS RECORD (
   part_no         INVENTORY_TRANSACTION_HIST_TAB.part_no%TYPE,
   lot_batch_no    INVENTORY_TRANSACTION_HIST_TAB.lot_batch_no%TYPE,
   quantity        INVENTORY_TRANSACTION_HIST_TAB.quantity%TYPE);

TYPE Lot_Batch_Tab IS TABLE OF Lot_Batch_Rec INDEX BY PLS_INTEGER;


-------------------- PRIVATE DECLARATIONS -----------------------------------

TYPE Source_Ref4_Tab IS TABLE OF INVENTORY_TRANSACTION_HIST_TAB.source_ref4%TYPE
   INDEX BY PLS_INTEGER;

true_  CONSTANT VARCHAR2(4) := Fnd_Boolean_API.db_true;

false_ CONSTANT VARCHAR2(5) := Fnd_Boolean_API.db_false;

micro_cache_onh_dev_contract_   VARCHAR2(5);

micro_cache_onh_dev_part_no_    VARCHAR2(25);

micro_cache_onh_dev_config_id_  VARCHAR2(50);

micro_cache_onh_dev_filled_     BOOLEAN := FALSE;

micro_cache_onh_dev_time_       NUMBER := 0;

TYPE number_array               IS TABLE OF NUMBER INDEX BY VARCHAR2(20);

micro_cache_onh_dev_acc_qty_    number_array;


-------------------- LU SPECIFIC IMPLEMENTATION METHODS ---------------------

-- Call_Shop_Order_Receipt___
--   Handle Section for original transaction code = 'OOREC' in
--   CallPartSerialCatalog method.
PROCEDURE Call_Shop_Order_Receipt___ (
   part_no_                  IN VARCHAR2,
   location_no_              IN VARCHAR2,
   serial_no_                IN VARCHAR2,
   source_ref1_              IN VARCHAR2,
   source_ref2_              IN VARCHAR2,
   source_ref3_              IN VARCHAR2,
   source_ref4_              IN VARCHAR2,
   source_ref_type_          IN VARCHAR2,
   transaction_id_           IN NUMBER,
   lot_batch_no_             IN VARCHAR2,
   condition_code_           IN VARCHAR2,
   part_ownership_           IN VARCHAR2,
   owning_vendor_no_         IN VARCHAR2,
   owning_customer_no_       IN VARCHAR2,
   configuration_id_         IN VARCHAR2,
   contract_                 IN VARCHAR2,
   eng_chg_level_            IN VARCHAR2,
   manufactured_date_        IN DATE,
   operational_condition_db_ IN VARCHAR2 )
IS
   serial_message_          VARCHAR2(2000);
   serial_exists_           VARCHAR2(5);
   eng_part_revision_       VARCHAR2(6);
   stmt_                    VARCHAR2(2000);
   so_manufactured_date_    DATE;
BEGIN
   IF serial_no_ != '*' THEN
      serial_exists_  := Part_Serial_Catalog_API.Check_Exist(part_no_, serial_no_);
      serial_message_ := Get_Serial_Message___('PSCOOREC', LTRIM(RTRIM(location_no_)), source_ref1_, source_ref2_, source_ref3_);     
      
      stmt_ := 'BEGIN'                                                                                                 ||
                  ':eng_part_revision_ := Part_Revision_Api.Get_Eng_Revision(:contract_, :part_no_, :eng_chg_level_);' ||
               'END;';
      @ApproveDynamicStatement(2009-05-16,suthlk)
      EXECUTE IMMEDIATE stmt_
        USING
           OUT eng_part_revision_,
           IN  contract_,
           IN  part_no_,
           IN  eng_chg_level_;

      IF serial_exists_ = true_ THEN
         Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,serial_no_,part_ownership_,owning_vendor_no_,owning_customer_no_,'FALSE','TRUE',TRUE);
         Part_Serial_Catalog_API.Unissue(part_no_,
                                         serial_no_,
                                         serial_message_,
                                         source_ref1_,
                                         source_ref2_,
                                         source_ref3_,
                                         NULL,
                                         Order_Type_API.Decode('SHOP ORDER'),
                                         transaction_id_,
                                         lot_batch_no_,
                                         configuration_id_,
                                         NULL,
                                         operational_condition_db_,
                                         eng_part_revision_);
      ELSE
         $IF Component_Shpord_SYS.INSTALLED $THEN
            so_manufactured_date_ := Shop_Ord_API.Get_Manufactured_Date(source_ref1_, source_ref2_, source_ref3_); 
         $END            
         Part_Serial_Catalog_API.New_In_Inventory(part_no_,
                                                  serial_no_,
                                                  serial_message_,
                                                  NULL,
                                                  source_ref1_,
                                                  source_ref2_,
                                                  source_ref3_,
                                                  source_ref4_,
                                                  source_ref_type_,
                                                  transaction_id_,
                                                  NULL,
                                                  NULL,
                                                  configuration_id_,
                                                  'NOT_APPLICABLE',
                                                  lot_batch_no_,
                                                  condition_code_,
                                                  part_ownership_,
                                                  owning_vendor_no_,
                                                  owning_customer_no_,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  eng_part_revision_,
                                                  NVL(so_manufactured_date_, manufactured_date_),
                                                  operational_condition_db_);
      END IF;
   END IF;
END Call_Shop_Order_Receipt___;

-- Get_Transaction_Curr_Info___
--    This method returns the effective transaction currency information based on the event_code.
PROCEDURE Get_Transaction_Curr_Info___ (
   trans_curr_code_         OUT VARCHAR2,
   trans_curr_rate_         OUT NUMBER,
   trans_curr_conv_factor_  OUT NUMBER,
   trans_curr_rounding_     OUT NUMBER,
   trans_hist_rec_          IN  INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   company_                 IN  VARCHAR2,
   event_code_              IN  VARCHAR2,
   transaction_revaluation_ IN  BOOLEAN )
IS
   str_code_                      VARCHAR2(10);
   arrival_account_id_            NUMBER;
   pur_order_no_                  VARCHAR2(12);
   pur_line_no_                   VARCHAR2(4);
   pur_release_no_                VARCHAR2(4);
   pur_receipt_no_                NUMBER;
   arrival_trans_code_            VARCHAR2(10);
   calculate_curr_rate_           BOOLEAN := FALSE;
   
   transaction_code_tab_         Mpccom_Transaction_Code_API.Transaction_Code_Tab;
   accounting_id_tab_            Mpccom_Accounting_API.Accounting_Id_Tab;
   curr_rate_calc_trans_tab_     Mpccom_Transaction_Code_API.Transaction_Code_Tab;
   use_source_ref_               BOOLEAN := FALSE;
   use_alt_source_ref_           BOOLEAN := FALSE;
   ignore_transaction_code_      VARCHAR2(5) := 'FALSE';
  
   
   -- Get arrival transaction's currency related details for return transaction
   CURSOR get_arr_acc_id_from_source_ref  IS
      SELECT accounting_id, transaction_code
      FROM inventory_transaction_hist_tab ith
      WHERE source_ref1 = trans_hist_rec_.source_ref1
      AND source_ref2   = trans_hist_rec_.source_ref2
      AND source_ref3   = trans_hist_rec_.source_ref3
      AND (source_ref4   = trans_hist_rec_.source_ref4 OR trans_hist_rec_.source_ref4 IS NULL)
      AND source_ref_type  = Order_Type_API.DB_PURCHASE_ORDER      
      AND transaction_code IN (SELECT * FROM TABLE (curr_rate_calc_trans_tab_))
      AND EXISTS (SELECT 1 
                    FROM Mpccom_Accounting_Pub map 
                   WHERE map.accounting_id = ith.accounting_id
                     AND (map.event_code    = ith.transaction_code OR ignore_transaction_code_ = 'TRUE')
                     AND map.str_code      = str_code_)
      ORDER BY transaction_id DESC;
   
   CURSOR get_arr_acc_id_for_exchange  IS
      SELECT accounting_id
      FROM inventory_transaction_hist_tab ith
      WHERE source_ref1 = trans_hist_rec_.source_ref1
      AND source_ref2   = trans_hist_rec_.source_ref2
      AND source_ref3   = trans_hist_rec_.source_ref3
      AND source_ref_type = Order_Type_API.DB_PURCHASE_ORDER
      AND transaction_code = 'EXCH-SHIP'
      AND EXISTS (SELECT 1 
                    FROM Mpccom_Accounting_Pub map 
                    WHERE map.accounting_id = ith.accounting_id);
   
   CURSOR get_acc_id_from_alt_source_ref  IS
      SELECT accounting_id, transaction_code
      FROM inventory_transaction_hist_tab ith
      WHERE alt_source_ref1 = trans_hist_rec_.alt_source_ref1
      AND alt_source_ref2   = trans_hist_rec_.alt_source_ref2
      AND alt_source_ref3   = trans_hist_rec_.alt_source_ref3
      AND alt_source_ref4   = trans_hist_rec_.alt_source_ref4
      AND alt_source_ref_type   = Order_Type_API.DB_CUSTOMER_ORDER_DIRECT
      AND transaction_code IN ('PODIRSH', 'PODIRINTEM')
      AND EXISTS (SELECT 1 
                    FROM Mpccom_Accounting_Pub map 
                   WHERE map.accounting_id = ith.accounting_id
                     AND (map.event_code    = ith.transaction_code OR ignore_transaction_code_ = 'TRUE')
                     AND map.str_code      = str_code_);
 
BEGIN
   IF (transaction_revaluation_) THEN
      ignore_transaction_code_ := 'FALSE';
      str_code_ := 'M10';
      IF (event_code_ IN ('EXCH-SHIP', 'PO-EXCH')) THEN
         -- when cascade posting is done we need to use the current rate.
         use_source_ref_     := TRUE;
         use_alt_source_ref_ := FALSE;
      ELSIF (event_code_ IN ('ARRCHG-DIR', 'PODIRSH', 'RETPODIRSH', 'ARRCHGIDIR', 'PODIRINTEM')) THEN         
         OPEN get_acc_id_from_alt_source_ref;
         FETCH get_acc_id_from_alt_source_ref INTO arrival_account_id_, arrival_trans_code_;
         IF (get_acc_id_from_alt_source_ref%NOTFOUND) THEN
            use_source_ref_     := FALSE;
            use_alt_source_ref_ := TRUE;   
         END IF;   
         CLOSE get_acc_id_from_alt_source_ref;         
      ELSE         
         curr_rate_calc_trans_tab_ := Mpccom_Transaction_Code_API.Get_Cur_Rate_Calc_Trans_By_Src;
         OPEN get_arr_acc_id_from_source_ref;
         FETCH get_arr_acc_id_from_source_ref INTO arrival_account_id_, arrival_trans_code_;
         IF (get_arr_acc_id_from_source_ref%NOTFOUND) THEN
            use_source_ref_     := TRUE;
            use_alt_source_ref_ := FALSE;   
         END IF;         
         CLOSE get_arr_acc_id_from_source_ref;         
      END IF;
      IF (arrival_account_id_ IS NOT NULL) THEN
         -- for cascade postings we need to revers the immediate previous transaction. Hence Get_Currency_Code_From_Latest is used to get the latest curr code
         trans_curr_code_ := Mpccom_Accounting_API.Get_Currency_Code_From_Latest(arrival_account_id_, arrival_trans_code_, str_code_);
         trans_curr_rate_ := 0;
         trans_curr_conv_factor_ := 1;        
         trans_curr_rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, trans_curr_code_);         
      END IF;

   ELSE 
      IF (event_code_ IN ('RETWORK', 'RETCREDIT', 'INVSCRAP', 'SCPCREDIT', 'RET-CHARGE', 'RETPODIRSH', 'RETPODSINT', 'PO-EXCH', 'BALRETSP', 'EXCH-SHIP', 'RETREVAL-', 'RETREVAL+')) THEN
         ignore_transaction_code_ := 'TRUE';
         IF (event_code_ IN ('EXCH-SHIP', 'PO-EXCH')) THEN
            str_code_ := 'M142';
         ELSE
            str_code_ := 'M10';
         END IF;   
         -- Need to get the arrival transaction curr info for return and scrap transactions
         IF (event_code_ IN ('RETWORK', 'RETCREDIT', 'INVSCRAP', 'SCPCREDIT', 'RET-CHARGE', 'BALRETSP', 'EXCH-SHIP', 'RETREVAL-', 'RETREVAL+')) THEN
            curr_rate_calc_trans_tab_ := Mpccom_Transaction_Code_API.Get_Cur_Rate_Calc_Trans_By_Src;
            
            OPEN get_arr_acc_id_from_source_ref;
            FETCH get_arr_acc_id_from_source_ref BULK COLLECT INTO accounting_id_tab_, transaction_code_tab_;
            IF (get_arr_acc_id_from_source_ref%NOTFOUND) THEN
               use_source_ref_     := TRUE;
               use_alt_source_ref_ := FALSE;   
            END IF;
            CLOSE get_arr_acc_id_from_source_ref;
            
            IF (accounting_id_tab_.COUNT > 0) THEN               
               arrival_account_id_ := accounting_id_tab_(1);
               IF (accounting_id_tab_.COUNT > 1) THEN
                  -- Calculate an average value for currency rate when multiple postings are found
                  calculate_curr_rate_ := TRUE;                  
               END IF;               
            END IF;            

         ELSIF (event_code_ = 'PO-EXCH') THEN
            OPEN get_arr_acc_id_for_exchange;
            FETCH get_arr_acc_id_for_exchange INTO arrival_account_id_;
            IF (get_arr_acc_id_for_exchange%NOTFOUND) THEN
               use_source_ref_     := TRUE;
               use_alt_source_ref_ := FALSE;   
            END IF;
            CLOSE get_arr_acc_id_for_exchange;
         ELSE
            OPEN get_acc_id_from_alt_source_ref;
            FETCH get_acc_id_from_alt_source_ref INTO arrival_account_id_, arrival_trans_code_;
            IF (get_acc_id_from_alt_source_ref%NOTFOUND) THEN
               use_source_ref_     := FALSE;
               use_alt_source_ref_ := TRUE;   
            END IF;            
            CLOSE get_acc_id_from_alt_source_ref;
         END IF;
         IF (arrival_account_id_ IS NOT NULL) THEN
            IF (calculate_curr_rate_) THEN
               Mpccom_Accounting_API.Get_Currency_Info(trans_curr_rate_,
                                                       trans_curr_code_,
                                                       trans_curr_conv_factor_,
                                                       accounting_id_tab_,
                                                       str_code_);          
            ELSE                                              
               Mpccom_Accounting_API.Get_Trans_Currency_Info(trans_curr_rate_,
                                                             trans_curr_code_,
                                                             trans_curr_conv_factor_,
                                                             arrival_account_id_,
                                                             str_code_);                                                       
            END IF;                                                          
            trans_curr_rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, trans_curr_code_);             
         END IF;
      ELSE
         IF (trans_hist_rec_.source_ref_type IN (Order_Type_API.DB_PURCHASE_ORDER, Order_Type_API.DB_STAGE_PAYMENT )) THEN
            use_source_ref_     := TRUE;
            use_alt_source_ref_ := FALSE;
         ELSIF(trans_hist_rec_.alt_source_ref_type = Order_Type_API.DB_CUSTOMER_ORDER_DIRECT) THEN
            use_source_ref_     := FALSE;
            use_alt_source_ref_ := TRUE;
         END IF;
      END IF;
   END IF;
   
   -- If we fail to get the currency information from mpccom accountings then we get the information from purchasing either by using source_ref values or by
   -- alt_source_ref_values
   IF (use_source_ref_) THEN
      pur_order_no_     := trans_hist_rec_.source_ref1;
      pur_line_no_      := trans_hist_rec_.source_ref2;
      pur_release_no_   := trans_hist_rec_.source_ref3;
      pur_receipt_no_   := TO_NUMBER(trans_hist_rec_.source_ref4);
   ELSIF (use_alt_source_ref_) THEN
      pur_order_no_     := trans_hist_rec_.alt_source_ref1;
      pur_line_no_      := trans_hist_rec_.alt_source_ref2;
      pur_release_no_   := trans_hist_rec_.alt_source_ref3;
      pur_receipt_no_   := TO_NUMBER(trans_hist_rec_.alt_source_ref4);
   END IF;   
  
   IF (pur_order_no_ IS NOT NULL) THEN
      $IF Component_Purch_SYS.INSTALLED $THEN
         Receive_Purchase_Order_API.Get_Transaction_Currency_Info(trans_curr_code_,
                                                                  trans_curr_rate_,
                                                                  trans_curr_conv_factor_,
                                                                  pur_order_no_,
                                                                  pur_line_no_,
                                                                  pur_release_no_,
                                                                  pur_receipt_no_,
                                                                  company_);
         trans_curr_rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, trans_curr_code_);
      $ELSE
         Error_SYS.Component_Not_Exist('PURCH');
      $END
   END IF;

END Get_Transaction_Curr_Info___;

-- Do_Str_Event_Acc_Impl___
--   Implementation method for DoStrEventAcc
PROCEDURE Do_Str_Event_Acc_Impl___ (
   rcode_                      IN OUT VARCHAR2,
   company_                    IN     VARCHAR2,
   event_code_                 IN     VARCHAR2,
   accounting_id_              IN     NUMBER,
   booking_source_             IN     VARCHAR2,
   value_                      IN     NUMBER,
   accounting_date_            IN     DATE,
   contract_                   IN     VARCHAR2,
   value_adjustment_           IN     BOOLEAN,
   userid_                     IN     VARCHAR2,
   cost_source_id_             IN     VARCHAR2,
   bucket_posting_group_id_    IN     VARCHAR2,
   per_oh_adjustment_id_       IN     NUMBER,
   control_type_key_rec_       IN     Mpccom_Accounting_API.Control_Type_Key,
   trans_reval_event_id_       IN     NUMBER,
   base_curr_code_             IN     VARCHAR2,
   base_curr_rate_             IN     NUMBER,
   base_curr_conv_factor_      IN     NUMBER,
   base_curr_rate_is_inverted_ IN     VARCHAR2,
   trans_curr_code_            IN     VARCHAR2,
   trans_curr_rate_            IN     NUMBER,
   trans_curr_conv_factor_     IN     NUMBER,
   trans_curr_rounding_        IN     NUMBER,
   trans_curr_amount_          IN     NUMBER )
IS
   i_                      PLS_INTEGER := 1;
   local_curr_code_        VARCHAR2(3);
   local_curr_rate_        NUMBER;
   local_curr_amount_      NUMBER;
   old_booking_            NUMBER := -1;
   local_conv_factor_      NUMBER;
   ac_error_flag_          BOOLEAN := FALSE;
   
   CURSOR get_str_event_acc IS
      SELECT str_code, booking, pre_accounting_flag_db, debit_credit_db, project_accounting_flag_db
      FROM acc_event_posting_type_pub
      WHERE  event_code = event_code_;
      
BEGIN
   FOR eventrec_ IN get_str_event_acc LOOP
      IF (Acc_Event_Posting_Type_API.Posting_Type_Needs_Trans_Curr(eventrec_.str_code ) AND
          Validate_SYS.Is_Different(trans_curr_code_, base_curr_code_)) THEN        
         IF (trans_curr_code_ IS NULL OR trans_curr_rate_ IS NULL OR trans_curr_conv_factor_ IS NULL OR trans_curr_rounding_ IS NULL) THEN
            Error_SYS.Record_General(lu_name_, 'TRANS_CURR_CODE_NOT_FOUND: Transaction currency info is not found.');
         END IF;
         IF (value_adjustment_ AND trans_reval_event_id_ IS NOT NULL) THEN
            -- Transaction Based Invoice Revaluation
            local_curr_amount_ := 0;
         ELSE
            IF (trans_curr_amount_ IS NULL) THEN
               IF (base_curr_rate_is_inverted_ = 'FALSE') THEN
                  local_curr_amount_ := ROUND(((value_ * trans_curr_conv_factor_)/trans_curr_rate_), trans_curr_rounding_);                    
               ELSE
                  local_curr_amount_ := ROUND(((value_ * trans_curr_rate_)/trans_curr_conv_factor_), trans_curr_rounding_);
               END IF;
            ELSE
               local_curr_amount_ := trans_curr_amount_;
            END IF;
         END IF;
         local_curr_code_ := trans_curr_code_;
         local_curr_rate_ := trans_curr_rate_;
         local_conv_factor_ := trans_curr_conv_factor_;
      ELSE
         local_curr_rate_ := base_curr_rate_;
         local_curr_code_ := base_curr_code_;
         local_curr_amount_ := value_;
         local_conv_factor_ := base_curr_conv_factor_;
      END IF;
      Mpccom_Accounting_API.Do_Accounting(
                             rcode_                       =>  rcode_,
                             company_                     =>  company_,
                             event_code_                  =>  event_code_,
                             str_code_                    =>  eventrec_.str_code,
                             pre_accounting_flag_db_      =>  eventrec_.pre_accounting_flag_db,
                             accounting_id_               =>  accounting_id_,
                             debit_credit_db_             =>  eventrec_.debit_credit_db,
                             value_                       =>  value_,
                             booking_source_              =>  booking_source_,
                             currency_code_               =>  local_curr_code_,
                             currency_rate_               =>  local_curr_rate_,
                             curr_amount_                 =>  local_curr_amount_,
                             accounting_date_             =>  accounting_date_,
                             project_accounting_flag_db_  =>  eventrec_.project_accounting_flag_db,
                             contract_                    =>  contract_,
                             userid_                      =>  userid_,
                             conversion_factor_           =>  local_conv_factor_,
                             control_type_key_rec_        =>  control_type_key_rec_,
                             cost_source_id_              =>  cost_source_id_,
                             bucket_posting_group_id_     =>  bucket_posting_group_id_,
                             value_adjustment_            =>  value_adjustment_,
                             per_oh_adjustment_id_        =>  per_oh_adjustment_id_,
                             trans_reval_event_id_        =>  trans_reval_event_id_ );

      IF (rcode_ = 'ERROR') THEN
         ac_error_flag_ := TRUE;
      END IF;

      i_ := i_ + 1;
      old_booking_ := eventrec_.booking;
   END LOOP;
   IF (ac_error_flag_ = TRUE) THEN
      rcode_ := 'ERROR';
   ELSE
      rcode_ := 'SUCCESS';
   END IF;
END Do_Str_Event_Acc_Impl___;


-- Redo_Transaction_Postings___
--   Removes postings for a transaction and recreates them under the original
--   circumstances or under modified circumstances.
PROCEDURE Redo_Transaction_Postings___ (
   transaction_id_    IN NUMBER,
   accounting_id_     IN NUMBER,
   contract_          IN VARCHAR2,
   part_no_           IN VARCHAR2,
   activity_seq_      IN NUMBER,
   source_ref1_       IN VARCHAR2,
   source_ref2_       IN VARCHAR2,
   source_ref3_       IN VARCHAR2,
   source_ref4_       IN VARCHAR2,
   pre_accounting_id_ IN NUMBER,
   date_applied_      IN DATE,
   source_ref_type_   IN VARCHAR2,
   company_           IN VARCHAR2)
IS
   CURSOR get_old_postings (accounting_id_ IN NUMBER) IS
      SELECT seq, event_code, str_code, debit_credit, value, status_code,
             booking_source, inventory_value_status, date_of_origin, date_applied, userid,
             bucket_posting_group_id, cost_source_id, per_oh_adjustment_id, currency_rate,
             currency_code, conversion_factor, trans_reval_event_id, curr_amount
        FROM mpccom_accounting_pub
       WHERE accounting_id = accounting_id_
         AND status_code IN ('1','2','99')
         AND original_accounting_id IS NULL
    ORDER BY accounting_id, seq;

   TYPE Old_Posting_Tab_Type IS TABLE OF get_old_postings%ROWTYPE
     INDEX BY PLS_INTEGER;

   CURSOR get_cancel_transactions (original_transaction_id_ IN NUMBER) IS
      SELECT transaction_id, accounting_id, contract, part_no,
             location_no, activity_seq, project_id, source_ref1, 
             source_ref2, source_ref3, source_ref4, pre_accounting_id, source_ref_type
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE original_transaction_id = original_transaction_id_;

   old_posting_tab_            Old_Posting_Tab_Type;
   sqlerrm_                    VARCHAR2(2000);
   dummy_                      VARCHAR2(80);
   debit_credit_db_            VARCHAR2(1);
   pre_acc_flag_db_            VARCHAR2(1);
   project_accounting_flag_db_ VARCHAR2(200);
   date_applied_to_use_        DATE;
   appl_general                EXCEPTION;
   record_general              EXCEPTION;
   PRAGMA                      exception_init(appl_general,-20105);
   PRAGMA                      exception_init(record_general,-20110);
   control_type_key_rec_       Mpccom_Accounting_API.Control_Type_Key;
   
BEGIN

   Mpccom_Accounting_API.Redo_Reverse_Accounting(accounting_id_, date_applied_);

   OPEN  get_old_postings (accounting_id_);
   FETCH get_old_postings BULK COLLECT INTO old_posting_tab_;
   CLOSE get_old_postings;

   IF (old_posting_tab_.COUNT > 0 ) THEN
      FOR i IN old_posting_tab_.FIRST..old_posting_tab_.LAST LOOP
         Mpccom_Accounting_API.Remove(accounting_id_, old_posting_tab_(i).seq);
      END LOOP;

      -- Set Control_Type_Key_Rec with the transaction data that will be used
      -- to create the accountings.
      control_type_key_rec_ := Mpccom_Accounting_API.Set_Control_Type_Key(part_no_,
                                                                          contract_,
                                                                          transaction_id_,
                                                                          pre_accounting_id_,
                                                                          activity_seq_,
                                                                          source_ref_type_,
                                                                          source_ref1_,
                                                                          source_ref2_,
                                                                          source_ref3_,
                                                                          source_ref4_ );

      FOR i IN old_posting_tab_.FIRST..old_posting_tab_.LAST LOOP
         -- Fetch accounting data.
         debit_credit_db_ := old_posting_tab_(i).debit_credit; --Stored as Db in the public view...
         pre_acc_flag_db_ := Acc_Event_Posting_Type_API.Get_Pre_Accounting_Flag_Db( old_posting_tab_(i).event_code,
                                                                                    old_posting_tab_(i).str_code,
                                                                                    debit_credit_db_ );

         project_accounting_flag_db_ := Acc_Event_Posting_Type_API.Get_Project_Accounting_Flag_Db(
                                                                         old_posting_tab_(i).event_code,
                                                                         old_posting_tab_(i).str_code,
                                                                         debit_credit_db_ );
         
         -- Recreate the removed accountings.
         date_applied_to_use_ := NVL(date_applied_,old_posting_tab_(i).date_applied);
         
         Mpccom_Accounting_API.Do_Accounting(
                        rcode_                       =>  dummy_,
                        company_                     =>  company_,
                        event_code_                  =>  old_posting_tab_(i).event_code,
                        str_code_                    =>  old_posting_tab_(i).str_code,
                        pre_accounting_flag_db_      =>  pre_acc_flag_db_,
                        accounting_id_               =>  accounting_id_,
                        debit_credit_db_             =>  debit_credit_db_,
                        value_                       =>  old_posting_tab_(i).value,
                        booking_source_              =>  old_posting_tab_(i).booking_source,
                        currency_code_               =>  old_posting_tab_(i).currency_code,
                        currency_rate_               =>  old_posting_tab_(i).currency_rate,
                        curr_amount_                 =>  old_posting_tab_(i).curr_amount,
                        accounting_date_             =>  date_applied_to_use_,
                        project_accounting_flag_db_  =>  project_accounting_flag_db_,
                        contract_                    =>  contract_,
                        userid_                      =>  old_posting_tab_(i).userid,
                        conversion_factor_           =>  old_posting_tab_(i).conversion_factor,
                        control_type_key_rec_        =>  control_type_key_rec_,
                        date_of_origin_              =>  old_posting_tab_(i).date_of_origin,
                        cost_source_id_              =>  old_posting_tab_(i).cost_source_id,
                        bucket_posting_group_id_     =>  old_posting_tab_(i).bucket_posting_group_id,
                        inventory_value_status_db_   =>  old_posting_tab_(i).inventory_value_status,
                        per_oh_adjustment_id_        =>  old_posting_tab_(i).per_oh_adjustment_id,
                        trans_reval_event_id_        =>  old_posting_tab_(i).trans_reval_event_id );
      END LOOP;

      -- Check and Complete the entire accounting_id.      
      Mpccom_Accounting_API.Complete_Check_Accounting(dummy_,
                                                      company_,
                                                      date_applied_to_use_,
                                                      accounting_id_);
   END IF;

   FOR cancel_trans_rec_ IN get_cancel_transactions(transaction_id_) LOOP
      Redo_Transaction_Postings___(cancel_trans_rec_.transaction_id,
                                   cancel_trans_rec_.accounting_id,
                                   cancel_trans_rec_.contract,
                                   cancel_trans_rec_.part_no,
                                   cancel_trans_rec_.activity_seq,
                                   cancel_trans_rec_.source_ref1,
                                   cancel_trans_rec_.source_ref2,
                                   cancel_trans_rec_.source_ref3,
                                   cancel_trans_rec_.source_ref4,
                                   cancel_trans_rec_.pre_accounting_id,
                                   NULL,
                                   cancel_trans_rec_.source_ref_type,
                                   company_);
   END LOOP;

   IF (Mpccom_Accounting_API.Project_Activity_Posting(accounting_id_)) THEN
      Project_Refresh_Accounting_API.New(accounting_id_, contract_, 'INVENTORY');
   END IF;

EXCEPTION
   WHEN appl_general OR record_general THEN
      sqlerrm_ := SUBSTR(sqlerrm,INSTR(sqlerrm,':')+2,2000);
      sqlerrm_ := sqlerrm_ || ' ' || Language_SYS.Translate_Constant(lu_name_, 'TRANSID: and transaction id :P1', NULL, transaction_id_);
      Error_SYS.Record_General(lu_name_, sqlerrm_);
END Redo_Transaction_Postings___;


-- Call_Part_Serial_Catalog___
--   Gather all the calls to PartSerialCatalog in one method.
PROCEDURE Call_Part_Serial_Catalog___ (
   transaction_code_         IN VARCHAR2,
   contract_                 IN VARCHAR2,
   part_no_                  IN VARCHAR2,
   location_no_              IN VARCHAR2,
   serial_no_                IN VARCHAR2,
   source_ref1_              IN VARCHAR2,
   source_ref2_              IN VARCHAR2,
   source_ref3_              IN VARCHAR2,
   source_ref4_              IN VARCHAR2,
   reject_code_              IN VARCHAR2,
   source_ref_type_          IN VARCHAR2,
   transaction_id_           IN NUMBER,
   lot_batch_no_             IN VARCHAR2,
   condition_code_           IN VARCHAR2,
   part_ownership_           IN VARCHAR2,
   owning_vendor_no_         IN VARCHAR2,
   owning_customer_no_       IN VARCHAR2,
   acquisition_cost_         IN NUMBER,
   purchased_date_           IN DATE,
   configuration_id_         IN VARCHAR2,
   eng_chg_level_            IN VARCHAR2,
   alt_source_ref1_          IN VARCHAR2,
   operational_condition_db_ IN VARCHAR2,
   handling_unit_id_         IN NUMBER,
   old_transaction_id_       IN NUMBER,
   original_transaction_id_  IN NUMBER)
IS
   original_trans_code_          INVENTORY_TRANSACTION_HIST.transaction_code%TYPE;
   serial_message_               VARCHAR2(2000);
   stmt_                         VARCHAR2(2000);
   vendor_no_                    Supplier_Info_Public.supplier_id%TYPE;
   co_ord_no_                    VARCHAR2(12);
   order_code_                   VARCHAR2(20);   
   operational_status_           Part_Serial_Catalog.operational_status%TYPE;
   current_position_             VARCHAR2(30) := NULL;
   part_serial_rec_              Part_Serial_Catalog_API.Public_Rec;
   created_now_                  BOOLEAN := FALSE;
   serial_state_                 VARCHAR2(30);
   customer_is_internal_         VARCHAR2(5);
   supplier_is_internal_         VARCHAR2(5);
   manufacturer_no_              VARCHAR2(20);
   manufacturer_part_no_         VARCHAR2(80);
   scrap_at_supplier_            BOOLEAN := FALSE;
   buyer_code_                   VARCHAR2(20);
   currency_code_                VARCHAR2(3);
   $IF Component_Purch_SYS.INSTALLED $THEN
      pur_ord_line_rec_           Purchase_Order_Line_Part_API.Public_Rec;         
      pur_order_rec_              Purchase_Order_API.Public_Rec;         
   $END
   return_to_deliv_sup_           BOOLEAN := FALSE;
   pre_accounting_id_             NUMBER; 
   latest_transaction_id_         NUMBER;
   eng_part_revision_             VARCHAR2(6);
   new_in_inventory_              VARCHAR2(5) := 'FALSE';
   new_in_issued_                 VARCHAR2(5) := 'FALSE';   
BEGIN

   original_trans_code_ := Mpccom_Transaction_Code_API.Get_Original_Transaction_Code(transaction_code_);
   IF (original_trans_code_ IS NULL) THEN
      original_trans_code_ := transaction_code_;
   END IF;

   IF (original_trans_code_ IN ('OERET-INT','OERET-SINT', 'RETSHIPDIR', 'RETDIR-SCP')) THEN
      $IF Component_Order_SYS.INSTALLED $THEN
         co_ord_no_ := Return_Material_Line_API.Get_Order_No(source_ref1_, source_ref4_);           
      $ELSE
         NULL;    
      $END
   END IF;
   
   $IF Component_Mfgstd_SYS.INSTALLED $THEN
      eng_part_revision_ := Part_Revision_API.Get_Eng_Revision(contract_, part_no_, eng_chg_level_);
   $END

   IF original_trans_code_ = 'NREC' THEN
      serial_message_ := Get_Serial_Message___('PSCNREC', LTRIM(RTRIM(location_no_)), null, null, null);
      
      IF (Part_Serial_Catalog_API.Is_Issued(part_no_, serial_no_) = true_) THEN
         Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                      serial_no_,
                                                      part_ownership_,
                                                      owning_vendor_no_,
                                                      owning_customer_no_,
                                                      true_,
                                                      false_,
                                                      TRUE);
         Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                         serial_no_                  => serial_no_,
                                         transaction_description_    => serial_message_,
                                         order_no_                   => source_ref1_,
                                         line_no_                    => source_ref2_,
                                         release_no_                 => source_ref3_,
                                         line_item_no_               => source_ref4_,
                                         order_type_                 => source_ref_type_,
                                         inv_transaction_id_         => transaction_id_,
                                         lot_batch_no_               => lot_batch_no_,
                                         configuration_id_           => configuration_id_,
                                         operational_condition_db_   => operational_condition_db_,
                                         eng_part_revision_          => eng_part_revision_ );
 
      ELSE
         Part_Serial_Catalog_API.New_In_Inventory(part_no_                    => part_no_,
                                                  serial_no_                  => serial_no_,
                                                  transaction_description_    => serial_message_,
                                                  note_text_                  => NULL,
                                                  order_no_                   => source_ref1_,
                                                  line_no_                    => source_ref2_,
                                                  release_no_                 => source_ref3_,
                                                  line_item_no_               => source_ref4_,
                                                  order_type_                 => source_ref_type_,
                                                  inv_transaction_id_         => transaction_id_,
                                                  supplier_no_                => NULL,
                                                  manufacturer_no_            => NULL,
                                                  configuration_id_           => configuration_id_,
                                                  operational_status_db_      => 'NOT_APPLICABLE',
                                                  lot_batch_no_               => lot_batch_no_,
                                                  condition_code_             => condition_code_,
                                                  part_ownership_             => part_ownership_,
                                                  owning_vendor_no_           => owning_vendor_no_,
                                                  owning_customer_no_         => owning_customer_no_,
                                                  eng_part_revision_          => eng_part_revision_,
                                                  operational_condition_db_   => operational_condition_db_);
 
      END IF;

   ELSIF original_trans_code_ = 'NISS' THEN
      serial_message_ := Get_Serial_Message___('PSCNISS', LTRIM(RTRIM(location_no_)), null, null, null);
      Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ IN ('INVSCRAP','SCPCREDIT') THEN
      serial_message_ := Get_Serial_Message___('PSCINVSCRAP', Scrapping_Cause_API.Get_Reject_Message(reject_code_), null, null, null);
      Part_Serial_Catalog_API.Scrap(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ IN ('OPFEED-SCP', 'SODSPSCP') THEN
      serial_message_ := Get_Serial_Message___('PSCINVSCRAP', Scrapping_Cause_API.Get_Reject_Message(reject_code_), null, null, null);      
      Part_Serial_Catalog_API.Scrap(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ IN ('INVSCPCOR','SCPCREDCOR') THEN
      serial_message_ := Get_Serial_Message___('PSCINVSCPCOR', LTRIM(RTRIM(location_no_)), null, null, null);
      Part_Serial_Catalog_API.Unscrap(part_no_, serial_no_, serial_message_,
                                      source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                      source_ref_type_, transaction_id_, lot_batch_no_);
   ELSIF original_trans_code_ IN ('INVM-IN', 'CO-CONS-IN', 'CO-INVM-IN', 'INVM-COIN', 'COMPM-IN', 'WDR-IN', 'HANDLUNIT+', 'LOT-IN', 'CO-LOT-IN') THEN
      Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                   serial_no_,
                                                   part_ownership_,
                                                   owning_vendor_no_,
                                                   owning_customer_no_,
                                                   true_,
                                                   false_,
                                                   TRUE);
      IF (original_trans_code_ = 'HANDLUNIT+') THEN
         serial_message_ := Get_Serial_Message___('PSCHANDLUNIT', handling_unit_id_, null, null, null);
      ELSE
         serial_message_ := Get_Serial_Message___('PSCINVMIN', LTRIM(RTRIM(location_no_)), contract_, null, null); 
      END IF;

      Part_Serial_Catalog_API.Move_In_Inventory(part_no_                 => part_no_,
                                                serial_no_               => serial_no_,
                                                transaction_description_ => serial_message_,
                                                order_no_                => source_ref1_,
                                                line_no_                 => source_ref2_,
                                                release_no_              => source_ref3_,
                                                line_item_no_            => source_ref4_,
                                                order_type_              => source_ref_type_,
                                                inv_transaction_id_      => transaction_id_,
                                                lot_batch_no_            => lot_batch_no_);
   ELSIF original_trans_code_ = 'CRO-EXR-IN' THEN
      serial_message_ := Get_Serial_Message___('PSCCROEXRIN', LTRIM(RTRIM(location_no_)), contract_);
      Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                      serial_no_                  => serial_no_,
                                      transaction_description_    => serial_message_,
                                      order_no_                   => source_ref1_,
                                      line_no_                    => source_ref2_,
                                      release_no_                 => source_ref3_,
                                      line_item_no_               => source_ref4_,
                                      order_type_                 => source_ref_type_,
                                      inv_transaction_id_         => transaction_id_,
                                      lot_batch_no_               => lot_batch_no_,
                                      configuration_id_           => configuration_id_,
                                      operational_condition_db_   => operational_condition_db_,
                                      eng_part_revision_          => eng_part_revision_ );
   ELSIF original_trans_code_ = 'PICK-IN' THEN
      IF (Order_Type_API.Encode(source_ref_type_) = Order_Type_API.DB_SHIPMENT_ORDER) THEN 
         serial_message_ := Get_Serial_Message___('SHIPODPSCPICKIN', LTRIM(RTRIM(location_no_)), contract_, source_ref1_, source_ref2_, source_ref3_);
      ELSE 
         serial_message_ := Get_Serial_Message___('PSCPICKIN', LTRIM(RTRIM(location_no_)), contract_, source_ref1_, source_ref2_, source_ref3_);
      END IF;
      Part_Serial_Catalog_API.Move_In_Inventory(part_no_                 => part_no_,
                                                serial_no_               => serial_no_,
                                                transaction_description_ => serial_message_,
                                                order_no_                => source_ref1_,
                                                line_no_                 => source_ref2_,
                                                release_no_              => source_ref3_,
                                                line_item_no_            => source_ref4_,
                                                order_type_              => source_ref_type_,
                                                inv_transaction_id_      => transaction_id_,
                                                lot_batch_no_            => lot_batch_no_);
   ELSIF original_trans_code_ IN ('INVM-TRIN','COMPM-TRIN') THEN
      serial_message_ := Get_Serial_Message___('PSCINVMTRIN', LTRIM(RTRIM(location_no_)), contract_);
      Part_Serial_Catalog_API.Move_To_Transport(part_no_, serial_no_, serial_message_,
                                                source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                                source_ref_type_, transaction_id_);
   ELSIF (original_trans_code_ IN ('INVM-TRISS', 'SHIPODWHS-')) THEN
      IF (original_trans_code_ = 'INVM-TRISS') THEN 
         serial_message_ := Get_Serial_Message___('PSCINVMTRISS', LTRIM(RTRIM(location_no_)), contract_);
      ELSE 
         serial_message_ := Get_Serial_Message___('PCSSHIPODSITWHS', source_ref1_, source_ref2_);
      END IF;
      Part_Serial_Catalog_API.Move_To_Transport(part_no_, serial_no_, serial_message_,
                                                source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                                source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ = 'INVREC' THEN
      serial_message_ := Get_Serial_Message___('PSCINVREC', LTRIM(RTRIM(location_no_)), contract_);
      Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                serial_no_               => serial_no_,
                                                transaction_description_ => serial_message_,
                                                order_no_                => source_ref1_,
                                                line_no_                 => source_ref2_,
                                                release_no_              => source_ref3_,
                                                line_item_no_            => source_ref4_,
                                                order_type_              => source_ref_type_,
                                                inv_transaction_id_      => transaction_id_,
                                                lot_batch_no_            => lot_batch_no_,
                                                configuration_id_        => configuration_id_,
                                                operational_condition_db_=> operational_condition_db_,
                                                eng_part_revision_       => eng_part_revision_ );
   ELSIF original_trans_code_ IN ('WOISS', 'WTISS') THEN
      serial_message_ := Get_Serial_Message___('PSCWOISS', source_ref_type_, source_ref1_);
      Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ IN ('WOREPISS', 'WTREPISS') THEN
      serial_message_ := Get_Serial_Message___('PSCWOREPISS', source_ref_type_, source_ref1_);
      Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ IN ('WOUNISS', 'WTUNISS') THEN
      Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                   serial_no_,
                                                   part_ownership_,
                                                   owning_vendor_no_,
                                                   owning_customer_no_,
                                                   true_,
                                                   false_,
                                                   TRUE);    
      serial_message_ := Get_Serial_Message___('PSCWOUNISS', LTRIM(RTRIM(location_no_)), source_ref_type_, source_ref1_, source_ref2_, source_ref3_);                                             
      Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                      serial_no_                  => serial_no_,
                                      transaction_description_    => serial_message_,
                                      order_no_                   => source_ref1_,
                                      line_no_                    => source_ref2_,
                                      release_no_                 => source_ref3_,
                                      line_item_no_               => source_ref4_,
                                      order_type_                 => source_ref_type_,
                                      inv_transaction_id_         => transaction_id_,
                                      lot_batch_no_               => lot_batch_no_,
                                      configuration_id_           => configuration_id_,
                                      operational_condition_db_   => operational_condition_db_,
                                      eng_part_revision_          => eng_part_revision_ );
   ELSIF original_trans_code_ IN ('WORECEIPT', 'WTRECEIPT') THEN
      IF (Part_Serial_Catalog_API.Check_Exist(part_no_, serial_no_) = true_) THEN
         Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                      serial_no_,
                                                      part_ownership_,
                                                      owning_vendor_no_,
                                                      owning_customer_no_);
         current_position_ := Part_Serial_Catalog_API.Get_Objstate(part_no_, serial_no_);
         IF (current_position_ = 'InFacility') THEN
            serial_message_ := Get_Serial_Message___('LMBFAC2INV', LTRIM(RTRIM(location_no_)));
            --
            operational_status_ := Part_Serial_Catalog_API.Get_Operational_Status_Db(part_no_, serial_no_);
            Part_Serial_Catalog_API.Move_To_Inventory(part_no_                   => part_no_,
                                                      serial_no_                 => serial_no_,
                                                      transaction_description_   => serial_message_,
                                                      order_no_                  => source_ref1_,
                                                      line_no_                   => source_ref2_,
                                                      release_no_                => source_ref3_,
                                                      line_item_no_              => source_ref4_,
                                                      order_type_                => source_ref_type_,
                                                      inv_transaction_id_        => transaction_id_,
                                                      lot_batch_no_              => lot_batch_no_,
                                                      configuration_id_          => configuration_id_,
                                                      operational_condition_db_  => operational_condition_db_,
                                                      eng_part_revision_         => eng_part_revision_ );
         ELSIF (current_position_ = 'ReturnedToSupplier') THEN
            serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'WORECEIPTRETURN: Return into location :P1', NULL, LTRIM(RTRIM(location_no_)));
            Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                      serial_no_               => serial_no_,
                                                      transaction_description_ => serial_message_,
                                                      order_no_                => source_ref1_,
                                                      line_no_                 => source_ref2_,
                                                      release_no_              => source_ref3_,
                                                      line_item_no_            => source_ref4_,
                                                      order_type_              => source_ref_type_,
                                                      inv_transaction_id_      => transaction_id_,
                                                      lot_batch_no_            => lot_batch_no_,
                                                      configuration_id_        => configuration_id_,
                                                      operational_condition_db_=> operational_condition_db_,
                                                      eng_part_revision_       => eng_part_revision_ );
         ELSIF (current_position_ = 'Issued') THEN
            serial_message_ := Get_Serial_Message___('PSCWOUNISS', LTRIM(RTRIM(location_no_)), source_ref_type_, source_ref1_, source_ref2_, source_ref3_);
            Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                            serial_no_                  => serial_no_,
                                            transaction_description_    => serial_message_,
                                            order_no_                   => source_ref1_,
                                            line_no_                    => source_ref2_,
                                            release_no_                 => source_ref3_,
                                            line_item_no_               => source_ref4_,
                                            order_type_                 => source_ref_type_,
                                            inv_transaction_id_         => transaction_id_,
                                            lot_batch_no_               => lot_batch_no_,
                                            configuration_id_           => configuration_id_,
                                            operational_condition_db_   => operational_condition_db_,
                                            eng_part_revision_          => eng_part_revision_ );
         ELSIF (current_position_ = 'Contained') THEN
            serial_message_  := Language_SYS.Translate_Constant(lu_name_, 'WORECEIPTCONTTOINV: Moved into location :P1 from structure', NULL, LTRIM(RTRIM(location_no_)));
            part_serial_rec_ := Part_Serial_Catalog_API.Get(part_no_, serial_no_);

            Part_Serial_Catalog_API.Move_To_Facility(part_no_,
                                                     serial_no_,
                                                     part_serial_rec_.latest_transaction,
                                                     serial_message_,
                                                     'OUT_OF_OPERATION');

            Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                      serial_no_               => serial_no_,
                                                      transaction_description_ => serial_message_,
                                                      order_no_                => source_ref1_,
                                                      line_no_                 => source_ref2_,
                                                      release_no_              => source_ref3_,
                                                      line_item_no_            => source_ref4_,
                                                      order_type_              => source_ref_type_,
                                                      inv_transaction_id_      => transaction_id_,
                                                      lot_batch_no_            => lot_batch_no_,
                                                      configuration_id_        => configuration_id_,
                                                      operational_condition_db_=> operational_condition_db_,
                                                      eng_part_revision_       => eng_part_revision_ ); 
         END IF;
      ELSE
         serial_message_ := Get_Serial_Message___('PSCNREC', LTRIM(RTRIM(location_no_)), null, null, null);
         Part_Serial_Catalog_API.New_In_Inventory(part_no_                    => part_no_,
                                                  serial_no_                  => serial_no_,
                                                  transaction_description_    => serial_message_,
                                                  note_text_                  => NULL,
                                                  order_no_                   => source_ref1_,
                                                  line_no_                    => source_ref2_,
                                                  release_no_                 => source_ref3_,
                                                  line_item_no_               => source_ref4_,
                                                  order_type_                 => source_ref_type_,
                                                  inv_transaction_id_         => transaction_id_,
                                                  supplier_no_                => vendor_no_,
                                                  manufacturer_no_            => NULL,
                                                  configuration_id_           => configuration_id_,
                                                  operational_status_db_      => 'NOT_APPLICABLE',
                                                  lot_batch_no_               => lot_batch_no_,
                                                  condition_code_             => condition_code_,
                                                  part_ownership_             => part_ownership_,
                                                  owning_vendor_no_           => owning_vendor_no_,
                                                  owning_customer_no_         => owning_customer_no_,
                                                  eng_part_revision_          => eng_part_revision_,
                                                  operational_condition_db_   => operational_condition_db_);
      END IF;
   ELSIF original_trans_code_ IN ('WOREPREC', 'WTREPREC') THEN
      Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                   serial_no_,
                                                   part_ownership_,
                                                   owning_vendor_no_,
                                                   owning_customer_no_);
      current_position_ := Part_Serial_Catalog_API.Get_Objstate(part_no_, serial_no_);                                             
      IF (current_position_ IN ('InRepairWorkshop',  'InFacility') ) THEN
         IF (current_position_ = 'InRepairWorkshop') THEN
            serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'WOREPRECMOVE: Moved into location :P1 from Repair Workshop', NULL, LTRIM(RTRIM(location_no_)));
         ELSE
            serial_message_ := Get_Serial_Message___('LMBFAC2INV', LTRIM(RTRIM(location_no_))); 
         END IF;      
         Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                   serial_no_               => serial_no_,
                                                   transaction_description_ => serial_message_,
                                                   order_no_                => source_ref1_,
                                                   line_no_                 => source_ref2_,
                                                   release_no_              => source_ref3_,
                                                   line_item_no_            => source_ref4_,
                                                   order_type_              => source_ref_type_,
                                                   inv_transaction_id_      => transaction_id_,
                                                   lot_batch_no_            => lot_batch_no_,
                                                   configuration_id_        => configuration_id_,
                                                   operational_condition_db_=> operational_condition_db_,
                                                   eng_part_revision_ => eng_part_revision_ ); 
      ELSE
         serial_message_ := Get_Serial_Message___('PSCWOREPREC', LTRIM(RTRIM(location_no_)), source_ref_type_, source_ref1_, source_ref2_, source_ref3_);

         Part_Serial_Catalog_API.Unissue(part_no_,
                                         serial_no_,
                                         serial_message_,
                                         source_ref1_,
                                         source_ref2_,
                                         source_ref3_,
                                         source_ref4_,
                                         source_ref_type_,
                                         transaction_id_,
                                         lot_batch_no_,
                                         configuration_id_,
                                         eng_part_revision_ => eng_part_revision_ );
      END IF;                                   
   ELSIF original_trans_code_ = 'INTSHIP' THEN
      serial_message_ := Get_Serial_Message___('PSCINTSHIP', source_ref1_, source_ref2_, source_ref3_);
      Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ = 'INTUNISS' THEN
      IF (original_transaction_id_ = Part_Serial_History_API.Get_Latest_Inv_Transaction_Id(part_no_, serial_no_)) THEN
         serial_message_ := Get_Serial_Message___('PSCINTUNISS', LTRIM(RTRIM(location_no_)), source_ref1_, source_ref2_, source_ref3_);
         Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                         serial_no_                  => serial_no_,
                                         transaction_description_    => serial_message_,
                                         order_no_                   => source_ref1_,
                                         line_no_                    => source_ref2_,
                                         release_no_                 => source_ref3_,
                                         line_item_no_               => source_ref4_,
                                         order_type_                 => source_ref_type_,
                                         inv_transaction_id_         => transaction_id_,
                                         lot_batch_no_               => lot_batch_no_,
                                         configuration_id_           => configuration_id_,
                                         operational_condition_db_   => operational_condition_db_,
                                         eng_part_revision_          => eng_part_revision_ );
      ELSE 
         Error_SYS.Record_General(lu_name_, 'REVLATETRANS: It is only possible to reverse the latest transaction performed on this serial number.');
      END IF;       
   ELSIF original_trans_code_ = 'PROJISS' THEN
      serial_message_ := Get_Serial_Message___('PSCPROJISS', source_ref1_, source_ref4_);
      Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ = 'PROJREC' THEN
      serial_message_ := Get_Serial_Message___('PSCPROJREC', location_no_, source_ref1_, source_ref4_);
      Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                      serial_no_                  => serial_no_,
                                      transaction_description_    => serial_message_,
                                      order_no_                   => source_ref1_,
                                      line_no_                    => source_ref2_,
                                      release_no_                 => source_ref3_,
                                      line_item_no_               => source_ref4_,
                                      order_type_                 => source_ref_type_,
                                      inv_transaction_id_         => transaction_id_,
                                      lot_batch_no_               => lot_batch_no_,
                                      configuration_id_           => configuration_id_,
                                      operational_condition_db_   => operational_condition_db_,
                                      eng_part_revision_          => eng_part_revision_ );
   ELSIF original_trans_code_ IN ('UN-PURSHIP','UN-PURBKFL','PD-UNSHIP') THEN
      IF (original_trans_code_ = 'PD-UNSHIP') THEN
         serial_message_ := Get_Serial_Message___('PSSPDUNSHIP', location_no_, source_ref1_, source_ref2_, source_ref3_);
      ELSE
         serial_message_ := Get_Serial_Message___('PSCUNPURSHIP', LTRIM(RTRIM(location_no_)), source_ref1_, source_ref2_, source_ref3_);
      END IF;
      Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                      serial_no_                  => serial_no_,
                                      transaction_description_    => serial_message_,
                                      order_no_                   => source_ref1_,
                                      line_no_                    => source_ref2_,
                                      release_no_                 => source_ref3_,
                                      line_item_no_               => source_ref4_,
                                      order_type_                 => source_ref_type_,
                                      inv_transaction_id_         => transaction_id_,
                                      lot_batch_no_               => lot_batch_no_,
                                      configuration_id_           => configuration_id_,
                                      operational_condition_db_   => operational_condition_db_,
                                      eng_part_revision_          => eng_part_revision_ );
   ELSIF original_trans_code_ = 'COUNT-OUT' THEN
      serial_message_ := Get_Serial_Message___('PSCINVENTOUT', LTRIM(RTRIM(location_no_)));
      Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ = 'COUNT-IN' THEN
      serial_message_ := Get_Serial_Message___('PSCINVENTIN', LTRIM(RTRIM(location_no_)));
      IF Part_Serial_Catalog_API.Check_Exist(part_no_, serial_no_) = true_ THEN
         Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                      serial_no_,
                                                      part_ownership_,
                                                      owning_vendor_no_,
                                                      owning_customer_no_,
                                                      true_,
                                                      false_,
                                                       TRUE);
         Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                         serial_no_                  => serial_no_,
                                         transaction_description_    => serial_message_,
                                         order_no_                   => source_ref1_,
                                         line_no_                    => source_ref2_,
                                         release_no_                 => source_ref3_,
                                         line_item_no_               => source_ref4_,
                                         order_type_                 => source_ref_type_,
                                         inv_transaction_id_         => transaction_id_,
                                         lot_batch_no_               => lot_batch_no_,
                                         configuration_id_           => configuration_id_,
                                         operational_condition_db_   => operational_condition_db_,
                                         eng_part_revision_          => eng_part_revision_ );
      ELSE
         Part_Serial_Catalog_API.New_In_Inventory(part_no_                    => part_no_,
                                                  serial_no_                  => serial_no_,
                                                  transaction_description_    => serial_message_,
                                                  note_text_                  => NULL,
                                                  order_no_                   => source_ref1_,
                                                  line_no_                    => source_ref2_,
                                                  release_no_                 => source_ref3_,
                                                  line_item_no_               => source_ref4_,
                                                  order_type_                 => source_ref_type_,
                                                  inv_transaction_id_         => transaction_id_,
                                                  supplier_no_                => NULL,
                                                  manufacturer_no_            => NULL,
                                                  configuration_id_           => configuration_id_,
                                                  operational_status_db_      => 'NOT_APPLICABLE',
                                                  lot_batch_no_               => lot_batch_no_,
                                                  condition_code_             => condition_code_,
                                                  part_ownership_             => part_ownership_,
                                                  owning_vendor_no_           => owning_vendor_no_,
                                                  owning_customer_no_         => owning_customer_no_,
                                                  eng_part_revision_          => eng_part_revision_,
                                                  operational_condition_db_   => operational_condition_db_);
 
      END IF;
   ELSIF original_trans_code_ IN ('ARRIVAL', 'CO-ARRIVAL', 'SERIAL-IN') THEN

      -- Following two if conditions are used to perform the MRO functionality.
      -- IF the demand code is MRO, current position, operational status and operational condition
      -- Purchase_Order_Line_Part_API and vendor_no, buyer_code and currency_code_ from Purchase_Order_API
      -- using Conditional Compilation.       
      $IF Component_Purch_SYS.INSTALLED $THEN
         pur_order_rec_        := Purchase_Order_API.Get(source_ref1_);
         vendor_no_            := pur_order_rec_.vendor_no;
         buyer_code_           := pur_order_rec_.buyer_code;
         currency_code_        := pur_order_rec_.currency_code; 
         pur_ord_line_rec_     := Purchase_Order_Line_Part_API.Get(source_ref1_, source_ref2_, source_ref3_);            
         order_code_           := pur_ord_line_rec_.order_code;
         manufacturer_no_      := pur_ord_line_rec_.manufacturer_id;                                        
         manufacturer_part_no_ := pur_ord_line_rec_.manufacturer_part_no;
         pre_accounting_id_    := pur_ord_line_rec_.pre_accounting_id;
      $END

      IF (original_trans_code_ = 'SERIAL-IN') THEN
         IF (Part_Serial_Catalog_API.Check_Exist(part_no_, serial_no_))= true_ THEN
            serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCREGISTER: Registered on location :P1 at site :P2', NULL, LTRIM(RTRIM(location_no_)), contract_);
         ELSE
           serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCSERIALIN: Created individual :P1 on location :P2', NULL, serial_no_, LTRIM(RTRIM(location_no_)));
         END IF;
      ELSE
         serial_message_ := Get_Serial_Message___('PSCARRIVAL', location_no_, contract_);
      END IF;

      Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                   serial_no_,
                                                   part_ownership_,
                                                   owning_vendor_no_,
                                                   owning_customer_no_);
      IF (Part_Serial_Catalog_API.Is_In_Facility(part_no_, serial_no_) = true_) THEN  
         Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                   serial_no_               => serial_no_,
                                                   transaction_description_ => serial_message_,
                                                   order_no_                => source_ref1_,
                                                   line_no_                 => source_ref2_,
                                                   release_no_              => source_ref3_,
                                                   line_item_no_            => source_ref4_,
                                                   order_type_              => source_ref_type_,
                                                   inv_transaction_id_      => transaction_id_,
                                                   lot_batch_no_            => lot_batch_no_,
                                                   configuration_id_        => configuration_id_,
                                                   operational_condition_db_=> operational_condition_db_,
                                                   eng_part_revision_       => eng_part_revision_ );  
      ELSIF (Part_Serial_Catalog_API.Is_Issued(part_no_, serial_no_) = true_) THEN
         Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                         serial_no_                  => serial_no_,
                                         transaction_description_    => serial_message_,
                                         order_no_                   => source_ref1_,
                                         line_no_                    => source_ref2_,
                                         release_no_                 => source_ref3_,
                                         line_item_no_               => source_ref4_,
                                         order_type_                 => source_ref_type_,
                                         inv_transaction_id_         => transaction_id_,
                                         lot_batch_no_               => lot_batch_no_,
                                         configuration_id_           => configuration_id_,
                                         operational_condition_db_   => operational_condition_db_,
                                         eng_part_revision_          => eng_part_revision_); 
      ELSIF (Part_Serial_Catalog_API.Is_Returned_To_Supplier(part_no_, serial_no_) = true_) THEN
         Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                   serial_no_               => serial_no_,
                                                   transaction_description_ => serial_message_,
                                                   order_no_                => source_ref1_,
                                                   line_no_                 => source_ref2_,
                                                   release_no_              => source_ref3_,
                                                   line_item_no_            => source_ref4_,
                                                   order_type_              => source_ref_type_,
                                                   inv_transaction_id_      => transaction_id_,
                                                   lot_batch_no_            => lot_batch_no_,
                                                   configuration_id_        => configuration_id_,
                                                   operational_condition_db_=> operational_condition_db_,
                                                   eng_part_revision_       => eng_part_revision_); 
      ELSIF ((order_code_ = '4') AND (original_trans_code_ IN ('SERIAL-IN', 'ARRIVAL')) AND
             (Part_Serial_Catalog_API.Is_Under_Transportation(part_no_, serial_no_) = true_)) THEN
            -- Split into serials for an internal PO with transit delivery
            Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                      serial_no_               => serial_no_,
                                                      transaction_description_ => serial_message_,
                                                      order_no_                => source_ref1_,
                                                      line_no_                 => source_ref2_,
                                                      release_no_              => source_ref3_,
                                                      line_item_no_            => source_ref4_,
                                                      order_type_              => source_ref_type_,
                                                      inv_transaction_id_      => transaction_id_,
                                                      lot_batch_no_            => lot_batch_no_,
                                                      configuration_id_        => configuration_id_,
                                                      operational_condition_db_=> operational_condition_db_,
                                                      eng_part_revision_       => eng_part_revision_);
      ELSE
         Part_Serial_Catalog_API.New_In_Inventory(part_no_                    => part_no_,
                                                  serial_no_                  => serial_no_,
                                                  transaction_description_    => serial_message_,
                                                  note_text_                  => NULL,
                                                  order_no_                   => source_ref1_,
                                                  line_no_                    => source_ref2_,
                                                  release_no_                 => source_ref3_,
                                                  line_item_no_               => source_ref4_,
                                                  order_type_                 => source_ref_type_,
                                                  inv_transaction_id_         => transaction_id_,
                                                  supplier_no_                => vendor_no_,
                                                  manufacturer_no_            => manufacturer_no_,
                                                  configuration_id_           => configuration_id_,
                                                  operational_status_db_      => 'NOT_APPLICABLE',
                                                  lot_batch_no_               => lot_batch_no_,
                                                  condition_code_             => condition_code_,
                                                  part_ownership_             => part_ownership_,
                                                  owning_vendor_no_           => owning_vendor_no_,
                                                  owning_customer_no_         => owning_customer_no_,
                                                  acquisition_cost_           => acquisition_cost_,
                                                  purchased_date_             => purchased_date_,
                                                  manu_part_no_               => manufacturer_part_no_,
                                                  operational_condition_db_   => operational_condition_db_,
                                                  buyer_code_                 => buyer_code_,
                                                  currency_code_              => currency_code_,
                                                  eng_part_revision_          => eng_part_revision_);
      END IF;
      Set_Fa_Object_Ref_On_Serial___(contract_, part_no_, serial_no_, part_ownership_, pre_accounting_id_);
   ELSIF original_trans_code_ IN ('PURSHIP','PURBKFL') THEN
      vendor_no_      := Get_Purchase_Order_Vendor___(source_ref1_ );
      serial_message_ := Get_Serial_Message___('PSCPURSHIP', vendor_no_, source_ref1_, source_ref2_, source_ref3_);
      Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ = 'PURDIR' THEN
      vendor_no_      := Get_Purchase_Order_Vendor___(source_ref1_ );
      serial_message_ := Get_Serial_Message___('PSCPURDIR', vendor_no_, source_ref1_, source_ref2_, source_ref3_);
         stmt_ := 'BEGIN
                     :customer_is_internal := Customer_Order_Line_API.Customer_Is_Internal(:source_ref1, :source_ref2, :source_ref3, :source_ref4);
                     :supplier_is_internal := Purchase_Order_API.Supplier_Is_Internal(:alt_source_ref1);
                   END;';
         @ApproveDynamicStatement(2012-10-09,maeelk)
         EXECUTE IMMEDIATE stmt_
            USING OUT customer_is_internal_,
                  IN  source_ref1_,
                  IN  source_ref2_,
                  IN  source_ref3_,
                  IN  source_ref4_,
                  OUT supplier_is_internal_,
                  IN  alt_source_ref1_;

      IF (Part_Serial_Catalog_API.Check_Exist(part_no_, serial_no_) = true_) THEN
         serial_state_ := Part_Serial_Catalog_API.Get_Objstate(part_no_, serial_no_);
         IF (supplier_is_internal_ = true_) THEN
            IF (serial_state_ NOT IN ('Issued', 'UnderTransportation')) THEN
               Error_SYS.Record_General(lu_name_, 'SERIALINUSE: Serial number :P1 is already in use.', serial_no_);
            END IF;
         ELSE
            IF (serial_state_ NOT IN ('Issued', 'ReturnedToSupplier')) THEN
               Error_SYS.Record_General(lu_name_, 'SERIALINUSE: Serial number :P1 is already in use.', serial_no_);
            END IF;
         END IF;
      ELSE
         Part_Serial_Catalog_API.New_In_Issued (part_no_, serial_no_, serial_message_, serial_message_,
                                                NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'NOT_APPLICABLE',
                                                configuration_id_, lot_batch_no_, source_ref1_, source_ref2_,
                                                source_ref3_, source_ref4_, source_ref_type_, condition_code_,transaction_id_);
         serial_state_ := 'Issued';
         created_now_  := TRUE;
      END IF;

      IF (customer_is_internal_ = true_) THEN
         serial_message_     := Language_SYS.Translate_Constant(lu_name_, 'PSCPODIRSHINTCUST: Under Transport from customer order :P1', NULL, source_ref1_||' '||source_ref2_||' '|| source_ref3_);

         IF (serial_state_ = 'UnderTransportation') THEN
            -- Update the latest transaction attribute and create a record in PartSerialHistory
            Part_Serial_Catalog_API.Modify_Latest_Transaction(part_no_, serial_no_, serial_message_, serial_message_,
                                                              'INFO', source_ref_type_, source_ref1_, source_ref2_,
                                                              source_ref3_, source_ref4_, transaction_id_);
         ELSE
            Part_Serial_Catalog_API.Move_To_Transport(part_no_, serial_no_, serial_message_,
                                                      source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                                      source_ref_type_, transaction_id_);
         END IF;
      ELSE
         IF (serial_state_ = 'Issued') THEN
            IF (NOT created_now_) THEN
               -- Update the latest transaction attribute and create a record in PartSerialHistory
               Part_Serial_Catalog_API.Modify_Latest_Transaction(part_no_, serial_no_, serial_message_,
                                                                 serial_message_, 'INFO', source_ref_type_, source_ref1_,
                                                                 source_ref2_, source_ref3_, source_ref4_, transaction_id_);
            END IF;
         ELSE
            Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                          source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                          source_ref_type_, transaction_id_);
         END IF;
      END IF;
   ELSIF original_trans_code_ = 'INTPURDIR' THEN
      vendor_no_      := Get_Purchase_Order_Vendor___(source_ref1_ );
      serial_message_ := Get_Serial_Message___('PSCPURDIR', vendor_no_, source_ref1_, source_ref2_, source_ref3_);
      Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);


   ELSIF original_trans_code_ = 'EXCH-SHIP' THEN
      vendor_no_      := Get_Purchase_Order_Vendor___(source_ref1_ );
      serial_message_ := Get_Serial_Message___('PSCEXCHSHIP', vendor_no_, source_ref1_, source_ref2_, source_ref3_);
      Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);

   ELSIF (original_trans_code_ = 'ARR-COMP') THEN
      Part_Serial_Catalog_API.Exist(part_no_, serial_no_);
      Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                   serial_no_,
                                                   part_ownership_,
                                                   owning_vendor_no_,
                                                   owning_customer_no_);
                                                   
      serial_message_ := Get_Serial_Message___('PSCARRIVAL', LTRIM(RTRIM(location_no_)), contract_);
      
      IF (Part_Serial_Catalog_API.Is_Issued(part_no_, serial_no_) = true_) THEN
         Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                         serial_no_                  => serial_no_,
                                         transaction_description_    => serial_message_,
                                         order_no_                   => source_ref1_,
                                         line_no_                    => source_ref2_,
                                         release_no_                 => source_ref3_,
                                         line_item_no_               => source_ref4_,
                                         order_type_                 => source_ref_type_,
                                         inv_transaction_id_         => transaction_id_,
                                         lot_batch_no_               => lot_batch_no_,
                                         configuration_id_           => configuration_id_,
                                         operational_condition_db_   => operational_condition_db_,
                                         eng_part_revision_          => eng_part_revision_ );
      ELSIF (Part_Serial_Catalog_API.Is_In_Facility(part_no_, serial_no_) = true_) THEN
         Part_Serial_Catalog_API.Set_Out_Of_Operation(part_no_, serial_no_, TRUE);
         Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                   serial_no_               => serial_no_,
                                                   transaction_description_ => serial_message_,
                                                   order_no_                => source_ref1_,
                                                   line_no_                 => source_ref2_,
                                                   release_no_              => source_ref3_,
                                                   line_item_no_            => source_ref4_,
                                                   order_type_              => source_ref_type_,
                                                   inv_transaction_id_      => transaction_id_,
                                                   lot_batch_no_            => lot_batch_no_,
                                                   configuration_id_        => configuration_id_,
                                                   operational_condition_db_=> operational_condition_db_,
                                                   eng_part_revision_       => eng_part_revision_ );
      ELSE
         Error_SYS.Record_General('InventoryTransactionHist', 'ARRCOMPERR: Part no :P1 serial no :P2 may not be received on an external repair order because it is in state :P3.',part_no_, serial_no_,Part_Serial_Catalog_API.Get_Objstate(part_no_,serial_no_));
      END IF;
   ELSIF (original_trans_code_ IN ('SERLOTSWAP','PARTSWAP')) THEN
         serial_message_ := Get_Serial_Message___('PSCARRIVAL', LTRIM(RTRIM(location_no_)), contract_);
         Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                      serial_no_,
                                                      part_ownership_,
                                                      owning_vendor_no_,
                                                      owning_customer_no_);         
         IF (Part_Serial_Catalog_API.Is_In_Facility(part_no_, serial_no_) = true_) THEN
            Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                      serial_no_               => serial_no_,
                                                      transaction_description_ => serial_message_,
                                                      order_no_                => source_ref1_,
                                                      line_no_                 => source_ref2_,
                                                      release_no_              => source_ref3_,
                                                      line_item_no_            => source_ref4_,
                                                      order_type_              => source_ref_type_,
                                                      inv_transaction_id_      => transaction_id_,
                                                      lot_batch_no_            => lot_batch_no_,
                                                      configuration_id_        => configuration_id_,
                                                      operational_condition_db_=> operational_condition_db_,
                                                      eng_part_revision_       => eng_part_revision_ );         
         ELSIF (Part_Serial_Catalog_API.Is_Issued(part_no_, serial_no_) = true_) THEN         
            Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                            serial_no_                  => serial_no_,
                                            transaction_description_    => serial_message_,
                                            order_no_                   => source_ref1_,
                                            line_no_                    => source_ref2_,
                                            release_no_                 => source_ref3_,
                                            line_item_no_               => source_ref4_,
                                            order_type_                 => source_ref_type_,
                                            inv_transaction_id_         => transaction_id_,
                                            lot_batch_no_               => lot_batch_no_,
                                            configuration_id_           => configuration_id_,
                                            operational_condition_db_   => operational_condition_db_,
                                            eng_part_revision_          => eng_part_revision_ );
 
         ELSIF Part_Serial_Catalog_API.Is_Returned_To_Supplier(part_no_, serial_no_) = true_ THEN
            Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                      serial_no_               => serial_no_,
                                                      transaction_description_ => serial_message_,
                                                      order_no_                => source_ref1_,
                                                      line_no_                 => source_ref2_,
                                                      release_no_              => source_ref3_,
                                                      line_item_no_            => source_ref4_,
                                                      order_type_              => source_ref_type_,
                                                      inv_transaction_id_      => transaction_id_,
                                                      lot_batch_no_            => lot_batch_no_,
                                                      configuration_id_        => configuration_id_,
                                                      operational_condition_db_=> operational_condition_db_,
                                                      eng_part_revision_       => eng_part_revision_ );
         ELSE
            vendor_no_ := Get_Purchase_Order_Vendor___(source_ref1_ );
            Part_Serial_Catalog_API.New_In_Inventory(part_no_                    => part_no_,
                                                     serial_no_                  => serial_no_,
                                                     transaction_description_    => serial_message_,
                                                     note_text_                  => NULL,
                                                     order_no_                   => source_ref1_,
                                                     line_no_                    => source_ref2_,
                                                     release_no_                 => source_ref3_,
                                                     line_item_no_               => source_ref4_,
                                                     order_type_                 => source_ref_type_,
                                                     inv_transaction_id_         => transaction_id_,
                                                     supplier_no_                => vendor_no_,
                                                     manufacturer_no_            => NULL,
                                                     configuration_id_           => configuration_id_,
                                                     operational_status_db_      => 'NOT_APPLICABLE',
                                                     lot_batch_no_               => lot_batch_no_,
                                                     condition_code_             => condition_code_,
                                                     part_ownership_             => part_ownership_,
                                                     owning_vendor_no_           => owning_vendor_no_,
                                                     owning_customer_no_         => owning_customer_no_,
                                                     eng_part_revision_          => eng_part_revision_,
                                                     operational_condition_db_   => operational_condition_db_);
         END IF;
      ELSIF original_trans_code_ = 'RETCREDIT' THEN
         serial_message_ := Get_Serial_Message___('PSCINVRETC');
      Part_Serial_Catalog_API.Return_To_Supplier(part_no_, serial_no_, serial_message_,
                                                 source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                                 source_ref_type_, transaction_id_);
      ELSIF original_trans_code_ IN ('RETWORK','RETWORKINT') THEN
         serial_message_ := Get_Serial_Message___('PSCINVRETR');
      Part_Serial_Catalog_API.Return_To_Supplier(part_no_, serial_no_, serial_message_,
                                                 source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                                 source_ref_type_, transaction_id_);
      ELSIF original_trans_code_ IN ('RETCORWORK','RETCORWINT') THEN
         serial_message_ := Get_Serial_Message___('PSCINVRETCCOR', LTRIM(RTRIM(location_no_)));
      Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                serial_no_               => serial_no_,
                                                transaction_description_ => serial_message_,
                                                order_no_                => source_ref1_,
                                                line_no_                 => source_ref2_,
                                                release_no_              => source_ref3_,
                                                line_item_no_            => source_ref4_,
                                                order_type_              => source_ref_type_,
                                                inv_transaction_id_      => transaction_id_,
                                                lot_batch_no_            => lot_batch_no_,
                                                configuration_id_        => configuration_id_,
                                                operational_condition_db_=> operational_condition_db_,
                                                eng_part_revision_       => eng_part_revision_ );
      ELSIF original_trans_code_ = 'RETCORCRE' THEN
         serial_message_ := Get_Serial_Message___('PSCINVRETRCOR', LTRIM(RTRIM(location_no_)));
      Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                serial_no_               => serial_no_,
                                                transaction_description_ => serial_message_,
                                                order_no_                => source_ref1_,
                                                line_no_                 => source_ref2_,
                                                release_no_              => source_ref3_,
                                                line_item_no_            => source_ref4_,
                                                order_type_              => source_ref_type_,
                                                inv_transaction_id_      => transaction_id_,
                                                lot_batch_no_            => lot_batch_no_,
                                                configuration_id_        => configuration_id_,
                                                operational_condition_db_=> operational_condition_db_,
                                                eng_part_revision_       => eng_part_revision_ );
      ELSIF original_trans_code_ = 'PODIRSH' THEN
         serial_message_ := Get_Serial_Message___('PSCPODIRCH', source_ref1_, source_ref2_, source_ref3_);
      
         stmt_ := 'BEGIN
                     :customer_is_internal := Customer_Order_Line_API.Customer_Is_Internal(:source_ref1, :source_ref2, :source_ref3, :source_ref4);
                     :supplier_is_internal := Purchase_Order_API.Supplier_Is_Internal(:alt_source_ref1);
                END;';

         @ApproveDynamicStatement(2012-10-09,maeelk)
         EXECUTE IMMEDIATE stmt_
            USING OUT customer_is_internal_,
                  IN  source_ref1_,
                  IN  source_ref2_,
                  IN  source_ref3_,
                  IN  source_ref4_,
                  OUT supplier_is_internal_,
                  IN  alt_source_ref1_;

      IF (Part_Serial_Catalog_API.Check_Exist(part_no_, serial_no_) = true_) THEN
         serial_state_ := Part_Serial_Catalog_API.Get_Objstate(part_no_, serial_no_);
         IF (supplier_is_internal_ = true_) THEN
            IF (serial_state_ NOT IN ('Issued', 'UnderTransportation')) THEN
               Error_SYS.Record_General(lu_name_, 'SERIALINUSE: Serial number :P1 is already in use.', serial_no_);
            END IF;
         ELSE
            IF (serial_state_ NOT IN ('Issued', 'ReturnedToSupplier')) THEN
               Error_SYS.Record_General(lu_name_, 'SERIALINUSE: Serial number :P1 is already in use.', serial_no_);
            END IF;
         END IF;
      ELSE
         vendor_no_ := Get_Purchase_Order_Vendor___(alt_source_ref1_ );
         Part_Serial_Catalog_API.New_In_Issued (part_no_, serial_no_, serial_message_, serial_message_,
                                                NULL, NULL, NULL, NULL, NULL, vendor_no_, NULL, 'NOT_APPLICABLE',
                                                configuration_id_, lot_batch_no_, source_ref1_, source_ref2_,
                                                source_ref3_, source_ref4_, source_ref_type_, condition_code_);
         serial_state_ := 'Issued';
         created_now_  := TRUE;
      END IF;

      IF (customer_is_internal_ = true_) THEN
         serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCPODIRSHINTCUST: Under Transport from customer order :P1', NULL, source_ref1_||' '||source_ref2_||' '|| source_ref3_);

         IF (serial_state_ = 'UnderTransportation') THEN
            -- Update the latest transaction attribute and create a record in PartSerialHistory
            Part_Serial_Catalog_API.Modify_Latest_Transaction(part_no_, serial_no_, serial_message_, serial_message_,
                                                              'INFO', source_ref_type_, source_ref1_, source_ref2_,
                                                              source_ref3_, source_ref4_, transaction_id_);         
         END IF;
      ELSE
         IF (serial_state_ = 'Issued') THEN
            IF (NOT created_now_) THEN
               -- Update the latest transaction attribute and create a record in PartSerialHistory
               Part_Serial_Catalog_API.Modify_Latest_Transaction(part_no_, serial_no_, serial_message_,
                                                                 serial_message_, 'INFO', source_ref_type_, source_ref1_,
                                                                 source_ref2_, source_ref3_, source_ref4_, transaction_id_);
            END IF;
         ELSE
            Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                          source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                          source_ref_type_, transaction_id_);
         END IF;
      END IF;
   ELSIF (original_trans_code_ IN ('POUNDIRSH')) THEN      
      Undo_Ord_Direct_Del_Serials___(original_trans_code_, transaction_id_, old_transaction_id_, part_no_, serial_no_,
                                     source_ref1_, source_ref2_, source_ref3_, source_ref4_, source_ref_type_);
   ELSIF original_trans_code_ = 'INTPODIRSH' THEN
      serial_message_ := Get_Serial_Message___('PSCPODIRCH', source_ref1_, source_ref2_, source_ref3_);
      Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ = 'UNINTPODIR' THEN
      serial_message_ := Get_Serial_Message___('PSCPODIRCH', source_ref1_, source_ref2_, source_ref3_);
      Part_Serial_Catalog_API.Move_To_Transport(part_no_, serial_no_,
                                                serial_message_,
                                                source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                                source_ref_type_, transaction_id_);                                 
   ELSIF original_trans_code_ = 'PODIRINTEM' THEN
      IF (Part_Serial_Catalog_API.Check_Exist(part_no_, serial_no_) = true_) THEN
         serial_state_ := Part_Serial_Catalog_API.Get_Objstate(part_no_, serial_no_);
         IF (serial_state_ NOT IN ('Issued', 'ReturnedToSupplier', 'UnderTransportation')) THEN
            Error_SYS.Record_General(lu_name_, 'SERIALINUSE: Serial number :P1 is already in use.', serial_no_);
         END IF;
      ELSE
         serial_message_ := Get_Serial_Message___('PSCPODIRINTEM', source_ref1_, source_ref2_, source_ref3_);
         Part_Serial_Catalog_API.New_In_Issued (part_no_, serial_no_, serial_message_, serial_message_,
                                                NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'NOT_APPLICABLE',
                                                configuration_id_, lot_batch_no_, source_ref1_, source_ref2_,
                                                source_ref3_, source_ref4_, source_ref_type_, condition_code_);
      END IF;

      serial_message_     := Language_SYS.Translate_Constant(lu_name_, 'PSCPODIRINTEMUT: Under Transport from internal customer order :P1', NULL, source_ref1_||' '||source_ref2_||' '|| source_ref3_);
      IF (serial_state_ = 'UnderTransportation') THEN
         -- Update the latest transaction attribute and create a record in PartSerialHistory
         Part_Serial_Catalog_API.Modify_Latest_Transaction(part_no_, serial_no_, serial_message_, serial_message_,
                                                           'INFO', source_ref_type_, source_ref1_, source_ref2_,
                                                           source_ref3_, source_ref4_, transaction_id_);
      ELSE
         Part_Serial_Catalog_API.Move_To_Transport(part_no_, serial_no_, serial_message_,
                                                   source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                                   source_ref_type_, transaction_id_);
      END IF;
   ELSIF original_trans_code_ = 'UNPODRINEM' THEN      
      Undo_Ord_Direct_Del_Serials___(original_trans_code_, transaction_id_, old_transaction_id_, part_no_, serial_no_,
                                     source_ref1_, source_ref2_, source_ref3_, source_ref4_, source_ref_type_);      
   ELSIF original_trans_code_ = 'INTPODIRIM' THEN
      serial_message_ := Get_Serial_Message___('PSCPODIRINTEM', source_ref1_, source_ref2_, source_ref3_);
      -- Update the latest transaction attribute and create a record in PartSerialHistory
      Part_Serial_Catalog_API.Modify_Latest_Transaction(part_no_, serial_no_, serial_message_, serial_message_,
                                                        'INFO', source_ref_type_, source_ref1_, source_ref2_, source_ref3_,
                                                        source_ref4_, transaction_id_);
   ELSIF original_trans_code_ = 'UNINPODRIM' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCUNINPODRIM: Cancelled delivery for internal customer order :P1', NULL, source_ref1_||' '||source_ref2_||' '|| source_ref3_);
      -- Update the latest transaction attribute and create a record in PartSerialHistory
      Part_Serial_Catalog_API.Modify_Latest_Transaction(part_no_, serial_no_, serial_message_, serial_message_,
                                                        'INFO', source_ref_type_, source_ref1_, source_ref2_, source_ref3_,
                                                        source_ref4_, transaction_id_);                                                     
   ELSIF original_trans_code_ = 'CO-DELV-OU' THEN
      serial_message_ := Get_Serial_Message___('PSSHIPCOE', source_ref1_, source_ref2_, source_ref3_);
      Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_, set_ownership_ => FALSE);

   ELSIF original_trans_code_ = 'CO-CONSUME' THEN
      Part_Serial_Catalog_API.Consume_Customer_Consignment(contract_, part_no_, serial_no_, source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                                           source_ref_type_, transaction_id_);
                                                           
   -- EBALL, Added CRO-EXD-OU transaction code to the conditions.
   ELSIF original_trans_code_ IN ('OESHIP', 'DELCONF-OU', 'CRO-EXD-OU', 'PD-SHIP') THEN
      IF original_trans_code_ IN ('OESHIP', 'CRO-EXD-OU') THEN
         serial_message_ := Get_Serial_Message___('PSSHIPOE', source_ref1_, source_ref2_, source_ref3_);
      ELSIF (original_trans_code_ = 'PD-SHIP') THEN
         serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSSPD-SHIP: Delivered on project deliverables :P1', NULL, source_ref1_||' '||source_ref2_||' '|| source_ref3_);
      ELSE
         serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCDELCONF: Delivered not confirmed on customer order :P1', NULL, source_ref1_ || ' ' || source_ref2_ || ' ' || source_ref3_);
      END IF;
      Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ IN ('SHIPTRAN','SHIPDIR', 'SHIPODSIT-') THEN
      IF (original_trans_code_ = 'SHIPODSIT-') THEN
         serial_message_ := Get_Serial_Message___('PCSSHIPODSITWHS', source_ref1_, source_ref2_);
      ELSE
         serial_message_ := Get_Serial_Message___('PSCPODIRINTEM', source_ref1_, source_ref2_, source_ref3_);
      END IF;     
      Part_Serial_Catalog_API.Move_To_Transport(part_no_, serial_no_, serial_message_,
                                                source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                                source_ref_type_, transaction_id_); 
   ELSIF original_trans_code_ IN ('UNSHIPTRAN','UNSHIPDIR','UND-SHPODS','UND-SHPODW') THEN
      IF (original_trans_code_ IN ('UND-SHPODS', 'UND-SHPODW')) THEN
         serial_message_ := Get_Serial_Message___('PCSUNSHIPODSITWHS', location_no_, source_ref1_, source_ref2_);
      ELSE         
         serial_message_ := Get_Serial_Message___('PSCUNSHIPTRAN', source_ref1_, source_ref2_, source_ref3_);
      END IF;
      Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                serial_no_               => serial_no_,
                                                transaction_description_ => serial_message_,
                                                order_no_                => source_ref1_,
                                                line_no_                 => source_ref2_,
                                                release_no_              => source_ref3_,
                                                line_item_no_            => source_ref4_,
                                                order_type_              => source_ref_type_,
                                                inv_transaction_id_      => transaction_id_,
                                                lot_batch_no_            => lot_batch_no_,
                                                configuration_id_        => configuration_id_,
                                                operational_condition_db_=> operational_condition_db_,
                                                eng_part_revision_       => eng_part_revision_ );
   ELSIF original_trans_code_ IN ('PURTRAN') THEN
      vendor_no_      := Get_Purchase_Order_Vendor___(source_ref1_ );
      serial_message_ := Get_Serial_Message___('PSCPURSHIP', vendor_no_, source_ref1_, source_ref2_, source_ref3_);
      Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);                                             
   ELSIF original_trans_code_ IN ('ARRTRAN', 'SHIPODSIT+', 'SHIPODWHS+') THEN
      IF (original_trans_code_ = 'ARRTRAN') THEN
         serial_message_ := Get_Serial_Message___('PSCARRTRAN', LTRIM(RTRIM(location_no_)), contract_, source_ref1_, source_ref2_, source_ref3_);
      ELSIF (original_trans_code_ = 'SHIPODSIT+') THEN
         serial_message_ := Get_Serial_Message___('PSCSHIPODSIT+', LTRIM(RTRIM(location_no_)), contract_, source_ref1_, source_ref2_);
      ELSE 
         serial_message_ := Get_Serial_Message___('PSCSHIPODWHS+', LTRIM(RTRIM(location_no_)), contract_, source_ref1_, source_ref2_);
      END IF;
      
      Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                   serial_no_,
                                                   part_ownership_,
                                                   owning_vendor_no_,
                                                   owning_customer_no_ ); 
      IF (Part_Serial_Catalog_API.Check_Exist(part_no_, serial_no_) = true_) THEN
         Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                   serial_no_               => serial_no_,
                                                   transaction_description_ => serial_message_,
                                                   order_no_                => source_ref1_,
                                                   line_no_                 => source_ref2_,
                                                   release_no_              => source_ref3_,
                                                   line_item_no_            => source_ref4_,
                                                   order_type_              => source_ref_type_,
                                                   inv_transaction_id_      => transaction_id_,
                                                   lot_batch_no_            => lot_batch_no_,
                                                   configuration_id_        => configuration_id_,
                                                   operational_condition_db_=> operational_condition_db_,
                                                   eng_part_revision_       => eng_part_revision_ );
      ELSE
         vendor_no_ := Get_Purchase_Order_Vendor___(source_ref1_ );
         Part_Serial_Catalog_API.New_In_Inventory(part_no_                    => part_no_,
                                                  serial_no_                  => serial_no_,
                                                  transaction_description_    => serial_message_,
                                                  note_text_                  => NULL,
                                                  order_no_                   => source_ref1_,
                                                  line_no_                    => source_ref2_,
                                                  release_no_                 => source_ref3_,
                                                  line_item_no_               => source_ref4_,
                                                  order_type_                 => source_ref_type_,
                                                  inv_transaction_id_         => transaction_id_,
                                                  supplier_no_                => vendor_no_,
                                                  manufacturer_no_            => NULL,
                                                  configuration_id_           => configuration_id_,
                                                  operational_status_db_      => 'NOT_APPLICABLE',
                                                  lot_batch_no_               => lot_batch_no_,
                                                  condition_code_             => condition_code_,
                                                  part_ownership_             => part_ownership_,
                                                  owning_vendor_no_           => owning_vendor_no_,
                                                  owning_customer_no_         => owning_customer_no_,
                                                  eng_part_revision_          => eng_part_revision_,
                                                  operational_condition_db_   => operational_condition_db_);
      END IF;
   
   ELSIF original_trans_code_ IN ('OERET-NO', 'OERET-NC', 'OERET-EX', 'RETDIFSREC') THEN
      serial_message_ := Get_Serial_Message___('PSCOERETURN', LTRIM(RTRIM(location_no_)), source_ref1_, source_ref4_);

      IF (Part_Serial_Catalog_API.Check_Exist(part_no_, serial_no_) = true_) THEN
         Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                      serial_no_,
                                                      part_ownership_,
                                                      owning_vendor_no_,
                                                      owning_customer_no_);
   
         IF ((Part_Serial_Catalog_API.Is_Returned_To_Supplier(part_no_, serial_no_) = true_) OR
            ((Part_Serial_Catalog_API.Is_In_Facility(part_no_, serial_no_) = true_) AND (original_trans_code_ = 'OERET-NO' ))) THEN
            Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                      serial_no_               => serial_no_,
                                                      transaction_description_ => serial_message_,
                                                      order_no_                => source_ref1_,
                                                      line_no_                 => source_ref2_,
                                                      release_no_              => source_ref3_,
                                                      line_item_no_            => source_ref4_,
                                                      order_type_              => source_ref_type_,
                                                      inv_transaction_id_      => transaction_id_,
                                                      lot_batch_no_            => lot_batch_no_,
                                                      configuration_id_        => configuration_id_,
                                                      operational_condition_db_=> operational_condition_db_,
                                                      eng_part_revision_       => eng_part_revision_ );
         ELSE
            Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                            serial_no_                  => serial_no_,
                                            transaction_description_    => serial_message_,
                                            order_no_                   => source_ref1_,
                                            line_no_                    => source_ref2_,
                                            release_no_                 => source_ref3_,
                                            line_item_no_               => source_ref4_,
                                            order_type_                 => source_ref_type_,
                                            inv_transaction_id_         => transaction_id_,
                                            lot_batch_no_               => lot_batch_no_,
                                            configuration_id_           => configuration_id_,
                                            operational_condition_db_   => operational_condition_db_,
                                            eng_part_revision_          => eng_part_revision_ );
         END IF;
      ELSE
         Part_Serial_Catalog_API.New_In_Inventory(part_no_                    => part_no_,
                                                  serial_no_                  => serial_no_,
                                                  transaction_description_    => serial_message_,
                                                  note_text_                  => NULL,
                                                  order_no_                   => source_ref1_,
                                                  line_no_                    => source_ref2_,
                                                  release_no_                 => source_ref3_,
                                                  line_item_no_               => source_ref4_,
                                                  order_type_                 => source_ref_type_,
                                                  inv_transaction_id_         => transaction_id_,
                                                  supplier_no_                => NULL,
                                                  manufacturer_no_            => NULL,
                                                  configuration_id_           => configuration_id_,
                                                  operational_status_db_      => 'NOT_APPLICABLE',
                                                  lot_batch_no_               => lot_batch_no_,
                                                  condition_code_             => condition_code_,
                                                  part_ownership_             => part_ownership_,
                                                  owning_vendor_no_           => owning_vendor_no_,
                                                  owning_customer_no_         => owning_customer_no_,
                                                  eng_part_revision_          => eng_part_revision_,
                                                  operational_condition_db_   => operational_condition_db_);
      END IF;
   ELSIF (original_trans_code_ = 'OERETURN') THEN
      serial_message_ := Get_Serial_Message___('PSCOERETURN', LTRIM(RTRIM(location_no_)), source_ref1_, source_ref4_);
      Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                   serial_no_,
                                                   part_ownership_,
                                                   owning_vendor_no_,
                                                   owning_customer_no_);

      IF ((Part_Serial_Catalog_API.Is_Returned_To_Supplier(part_no_, serial_no_) = true_) OR
          (Part_Serial_Catalog_API.Is_Under_Transportation(part_no_, serial_no_) = true_)) THEN
         Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                   serial_no_               => serial_no_,
                                                   transaction_description_ => serial_message_,
                                                   order_no_                => source_ref1_,
                                                   line_no_                 => source_ref2_,
                                                   release_no_              => source_ref3_,
                                                   line_item_no_            => source_ref4_,
                                                   order_type_              => source_ref_type_,
                                                   inv_transaction_id_      => transaction_id_,
                                                   lot_batch_no_            => lot_batch_no_,
                                                   configuration_id_        => configuration_id_,
                                                   operational_condition_db_=> operational_condition_db_,
                                                   eng_part_revision_       => eng_part_revision_ );  
      ELSE
         IF (Dir_Del_Non_Serial_On_RMA___(source_ref1_, source_ref4_, part_no_) AND 
            Part_Catalog_API.Get_Stop_New_Serial_In_Rma_Db(part_no_) = false_ AND 
            Part_Serial_Catalog_API.Check_Exist(part_no_, serial_no_) = false_) THEN
            new_in_inventory_ := 'TRUE';
         END IF;
         IF (new_in_inventory_ = 'FALSE') THEN
            Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                            serial_no_                  => serial_no_,
                                            transaction_description_    => serial_message_,
                                            order_no_                   => source_ref1_,
                                            line_no_                    => source_ref2_,
                                            release_no_                 => source_ref3_,
                                            line_item_no_               => source_ref4_,
                                            order_type_                 => source_ref_type_,
                                            inv_transaction_id_         => transaction_id_,
                                            lot_batch_no_               => lot_batch_no_,
                                            configuration_id_           => configuration_id_,
                                            operational_condition_db_   => operational_condition_db_,
                                            eng_part_revision_          => eng_part_revision_ );
         ELSE
            Part_Serial_Catalog_API.New_In_Inventory(part_no_                    => part_no_,
                                                     serial_no_                  => serial_no_,
                                                     transaction_description_    => serial_message_,
                                                     note_text_                  => NULL,
                                                     order_no_                   => source_ref1_,
                                                     line_no_                    => source_ref2_,
                                                     release_no_                 => source_ref3_,
                                                     line_item_no_               => source_ref4_,
                                                     order_type_                 => source_ref_type_,
                                                     inv_transaction_id_         => transaction_id_,
                                                     supplier_no_                => NULL,
                                                     manufacturer_no_            => NULL,
                                                     configuration_id_           => configuration_id_,
                                                     operational_status_db_      => 'NOT_APPLICABLE',
                                                     lot_batch_no_               => lot_batch_no_,
                                                     condition_code_             => condition_code_,
                                                     part_ownership_             => part_ownership_,
                                                     owning_vendor_no_           => owning_vendor_no_,
                                                     owning_customer_no_         => owning_customer_no_,
                                                     eng_part_revision_          => eng_part_revision_,
                                                     operational_condition_db_   => operational_condition_db_);
            END IF;
      END IF;
   ELSIF (original_trans_code_ = 'OERET-SCP') THEN
      IF (Dir_Del_Non_Serial_On_RMA___(source_ref1_, source_ref4_, part_no_) AND 
          Part_Catalog_API.Get_Stop_New_Serial_In_Rma_Db(part_no_) = false_ AND 
          Part_Serial_Catalog_API.Check_Exist(part_no_, serial_no_) = false_) THEN
         new_in_issued_ := 'TRUE';
      END IF;
      IF ((Part_Serial_Catalog_API.Check_Exist(part_no_, serial_no_) = false_) AND new_in_issued_ = 'TRUE') THEN
         serial_message_ := Get_Return_Scrap_Serial_Msg___(source_ref1_,
                                                           source_ref4_,
                                                           reject_code_);
         Part_Serial_Catalog_API.New_In_Issued (part_no_                 => part_no_,                                            
                                                serial_no_               => serial_no_,                                          
                                                latest_transaction_      => serial_message_,                                 
                                                transaction_description_ => serial_message_,                                     
                                                serial_revision_         => NULL,                                                
                                                note_text_               => NULL,                                                
                                                warranty_expires_        => NULL,                                                
                                                superior_part_no_        => NULL,                                                
                                                superior_serial_no_      => NULL,                                                
                                                supplier_no_             => NULL,                                                
                                                manufacturer_no_         => NULL,                                                
                                                configuration_id_        => configuration_id_,        
                                                lot_batch_no_            => lot_batch_no_,            
                                                order_no_                => source_ref1_,                
                                                line_no_                 => source_ref2_,              
                                                release_no_              => source_ref3_,             
                                                line_item_no_            => source_ref4_,            
                                                order_type_              => source_ref_type_,              
                                                condition_code_          => condition_code_,          
                                                inv_transsaction_id_     => transaction_id_);
      END IF;
      
      IF ((Part_Serial_Catalog_API.Is_Issued(part_no_, serial_no_) = true_) OR
          (Part_Serial_Catalog_API.Is_Returned_To_Supplier(part_no_, serial_no_) = true_) OR
          (Part_Serial_Catalog_API.Is_Under_Transportation(part_no_, serial_no_) = true_)) THEN
          serial_message_ := Get_Return_Scrap_Serial_Msg___(source_ref1_,
                                                            source_ref4_,
                                                            reject_code_);
            Part_Serial_Catalog_API.Scrap(part_no_,
                                          serial_no_,
                                          serial_message_,
                                          source_ref1_,
                                          source_ref2_,
                                          source_ref3_,
                                          source_ref4_,
                                          source_ref_type_,
                                          transaction_id_);
       ELSE
          Error_SYS.Record_General('InventoryTransactionHist', 'NORMARETSCP: Part no :P1 serial no :P2 may not be returned and scrapped because it is not in state Issued or Returned To Supplier or Under Transportation.',part_no_, serial_no_);
       END IF;
   ELSIF original_trans_code_ IN ('OERET-SPNO', 'OERET-SPNC', 'OERET-SPEX', 'RETDIFSSCP') THEN
      serial_message_ := Get_Return_Scrap_Serial_Msg___(source_ref1_, source_ref4_, reject_code_);

      IF (Part_Serial_Catalog_API.Check_Exist(part_no_, serial_no_) = false_) THEN
         Part_Serial_Catalog_API.New_In_Issued (part_no_                 => part_no_,                                            
                                                serial_no_               => serial_no_,                                          
                                                latest_transaction_      => serial_message_,                                 
                                                transaction_description_ => serial_message_,                                     
                                                serial_revision_         => NULL,                                                
                                                note_text_               => NULL,                                                
                                                warranty_expires_        => NULL,                                                
                                                superior_part_no_        => NULL,                                                
                                                superior_serial_no_      => NULL,                                                
                                                supplier_no_             => NULL,                                                
                                                manufacturer_no_         => NULL,                                                
                                                configuration_id_        => configuration_id_,        
                                                lot_batch_no_            => lot_batch_no_,            
                                                order_no_                => source_ref1_,                
                                                line_no_                 => source_ref2_,              
                                                release_no_              => source_ref3_,             
                                                line_item_no_            => source_ref4_,            
                                                order_type_              => source_ref_type_,              
                                                condition_code_          => condition_code_,          
                                                inv_transsaction_id_     => transaction_id_);         
      END IF;

      IF ((Part_Serial_Catalog_API.Is_Issued(part_no_, serial_no_) = true_) OR
          (Part_Serial_Catalog_API.Is_Returned_To_Supplier(part_no_, serial_no_) = true_)) THEN
         IF original_trans_code_ IN ('OERET-SPNC', 'OERET-SPEX') THEN
            scrap_at_supplier_ := TRUE;
         END IF;
         Part_Serial_Catalog_API.Scrap(part_no_, serial_no_, serial_message_,
                                       source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                       source_ref_type_, transaction_id_, scrap_at_supplier_);
      ELSE
         Error_SYS.Record_General('InventoryTransactionHist', 'RMARETSCPERR: Part no :P1 serial no :P2 may not be returned and scrapped because it is not in state Issued or Returned To Supplier.',part_no_, serial_no_);
      END IF;
   ELSIF original_trans_code_ IN ('OERET-INT', 'RETSHIPDIR') THEN
      serial_message_ := Get_Serial_Message___('PSCOERETINT', LTRIM(RTRIM(location_no_)), source_ref1_, source_ref4_, co_ord_no_);
      Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                serial_no_               => serial_no_,
                                                transaction_description_ => serial_message_,
                                                order_no_                => source_ref1_,
                                                line_no_                 => source_ref2_,
                                                release_no_              => source_ref3_,
                                                line_item_no_            => source_ref4_,
                                                order_type_              => source_ref_type_,
                                                inv_transaction_id_      => transaction_id_,
                                                lot_batch_no_            => lot_batch_no_,
                                                configuration_id_        => configuration_id_,
                                                operational_condition_db_=> operational_condition_db_,
                                                eng_part_revision_       => eng_part_revision_ );

   ELSIF original_trans_code_ IN ('OERET-SINT', 'RETDIR-SCP') THEN
      serial_message_ := Get_Serial_Message___('PSCOERETINT', source_ref1_, source_ref4_, co_ord_no_, Scrapping_Cause_API.Get_Reject_Message(reject_code_));
      Part_Serial_Catalog_API.Scrap(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ = 'PICKSCRAP' THEN
      serial_message_ := Get_Serial_Message___('PSCPICKSCRAP', LTRIM(RTRIM(location_no_)), Scrapping_Cause_API.Get_Reject_Message(reject_code_));
      Part_Serial_Catalog_API.Scrap(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ IN ('SOISS', 'BACFLUSH') THEN
      serial_message_ := Get_Serial_Message___('PSCSOISS', source_ref1_, source_ref2_, source_ref3_);
      Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ = 'UNISS' THEN
      serial_message_ := Get_Serial_Message___('PSCUNISS', LTRIM(RTRIM(location_no_)), source_ref1_, source_ref2_, source_ref3_);
      Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                      serial_no_                  => serial_no_,
                                      transaction_description_    => serial_message_,
                                      order_no_                   => source_ref1_,
                                      line_no_                    => source_ref2_,
                                      release_no_                 => source_ref3_,
                                      line_item_no_               => source_ref4_,
                                      order_type_                 => source_ref_type_,
                                      inv_transaction_id_         => transaction_id_,
                                      lot_batch_no_               => lot_batch_no_,
                                      configuration_id_           => configuration_id_,
                                      operational_condition_db_   => operational_condition_db_,
                                      eng_part_revision_          => eng_part_revision_ );
   ELSIF original_trans_code_ = 'OOREC' THEN
      Call_Shop_Order_Receipt___(part_no_,
                                 location_no_,
                                 serial_no_,
                                 source_ref1_,
                                 source_ref2_,
                                 source_ref3_,
                                 source_ref4_,
                                 source_ref_type_,
                                 transaction_id_,
                                 lot_batch_no_,
                                 condition_code_,
                                 part_ownership_,
                                 owning_vendor_no_,
                                 owning_customer_no_,
                                 configuration_id_,
                                 contract_,
                                 eng_chg_level_,
                                 purchased_date_,
                                 operational_condition_db_);
   ELSIF original_trans_code_ = 'PSBKFL' THEN
      serial_message_ := Get_Serial_Message___('PSCBKFL', source_ref1_, source_ref2_, source_ref3_);
      Part_Serial_Catalog_API.Issue(part_no_, serial_no_, serial_message_,
                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                    source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ IN ('RPSBKFL','CO-RPSBKFL') THEN
      serial_message_ := Get_Serial_Message___('PSCRPSBKFL', LTRIM(RTRIM(location_no_)), source_ref1_, source_ref2_, source_ref3_);
      Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                      serial_no_                  => serial_no_,
                                      transaction_description_    => serial_message_,
                                      order_no_                   => source_ref1_,
                                      line_no_                    => source_ref2_,
                                      release_no_                 => source_ref3_,
                                      line_item_no_               => source_ref4_,
                                      order_type_                 => source_ref_type_,
                                      inv_transaction_id_         => transaction_id_,
                                      lot_batch_no_               => lot_batch_no_,
                                      configuration_id_           => configuration_id_,
                                      operational_condition_db_   => operational_condition_db_,
                                      eng_part_revision_          => eng_part_revision_ );
   ELSIF original_trans_code_ = 'PSRECEIVE' THEN
      serial_message_ := Get_Serial_Message___('PSCPSRECEIVE', LTRIM(RTRIM(location_no_)), source_ref1_, source_ref2_, source_ref3_);
      Part_Serial_Catalog_API.New_In_Inventory(part_no_                    => part_no_,
                                               serial_no_                  => serial_no_,
                                               transaction_description_    => serial_message_,
                                               note_text_                  => NULL,
                                               order_no_                   => source_ref1_,
                                               line_no_                    => source_ref2_,
                                               release_no_                 => source_ref3_,
                                               line_item_no_               => source_ref4_,
                                               order_type_                 => source_ref_type_,
                                               inv_transaction_id_         => transaction_id_,
                                               supplier_no_                => NULL,
                                               manufacturer_no_            => NULL,
                                               configuration_id_           => configuration_id_,
                                               operational_status_db_      => 'NOT_APPLICABLE',
                                               lot_batch_no_               => lot_batch_no_,
                                               condition_code_             => condition_code_,
                                               part_ownership_             => part_ownership_,
                                               owning_vendor_no_           => owning_vendor_no_,
                                               owning_customer_no_         => owning_customer_no_,
                                               eng_part_revision_          => eng_part_revision_,
                                               operational_condition_db_   => operational_condition_db_);
   ELSIF original_trans_code_ = 'FAC2INV' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'FAC2INV: Moved into location :P1 from repairshop', NULL, LTRIM(RTRIM(location_no_)));
      Part_Serial_Catalog_API.Move_To_Inventory(part_no_                 => part_no_,
                                                serial_no_               => serial_no_,
                                                transaction_description_ => serial_message_,
                                                order_no_                => source_ref1_,
                                                line_no_                 => source_ref2_,
                                                release_no_              => source_ref3_,
                                                line_item_no_            => source_ref4_,
                                                order_type_              => source_ref_type_,
                                                inv_transaction_id_      => transaction_id_,
                                                lot_batch_no_            => lot_batch_no_,
                                                configuration_id_        => configuration_id_,
                                                operational_condition_db_=> operational_condition_db_,
                                                eng_part_revision_       => eng_part_revision_ );
   -- EBALL, Added CRO-EX-ARR   
   ELSIF original_trans_code_ IN ('XO-TR-IN','XO-ARRIVAL', 'CRO-EX-ARR', 'COTOCRA+', 'CRATOCO+') THEN
      Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                   serial_no_,
                                                   part_ownership_,
                                                   owning_vendor_no_,
                                                   owning_customer_no_,
                                                   true_,
                                                   false_,
                                                   TRUE);
      IF (original_trans_code_ = 'COTOCRA+') THEN
         latest_transaction_id_ := Get_Last_Serial_Trans_Of_Type(contract_, part_no_, serial_no_, NULL, NULL, NULL, NULL, NULL, 'COTOCRA-');
         pre_accounting_id_ := Inventory_Transaction_Hist_API.Get_Pre_Accounting_Id(latest_transaction_id_);                                                         
         Set_Fa_Object_Ref_On_Serial___(contract_, part_no_, serial_no_, part_ownership_, pre_accounting_id_);
      END IF;
   ELSIF original_trans_code_ = 'REP-SCRAP' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'SCRAPATSUPP: Scrapped at Supplier due :P1', NULL, Scrapping_Cause_API.Get_Reject_Message(reject_code_));
      Part_Serial_Catalog_API.Scrap(part_no_ ,
                                    serial_no_ ,
                                    serial_message_ ,
                                    source_ref1_ ,
                                    source_ref2_ ,
                                    source_ref3_ ,
                                    source_ref4_ ,
                                    source_ref_type_ ,
                                    transaction_id_ ,
                                    TRUE );
   ELSIF original_trans_code_ = 'UNREPSCRAP' THEN
      Part_Serial_Catalog_API.Unscrap_At_Supplier(part_no_ , serial_no_);
   ELSIF original_trans_code_ = 'CRO-EX-SCR' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCCROEXSCR: Scrapped at Customer due :P1', NULL, Scrapping_Cause_API.Get_Reject_Message(reject_code_));
      Part_Serial_Catalog_API.Scrap(part_no_ ,
                                    serial_no_ ,
                                    serial_message_ ,
                                    source_ref1_ ,
                                    source_ref2_ ,
                                    source_ref3_ ,
                                    source_ref4_ ,
                                    source_ref_type_ ,
                                    transaction_id_);
   ELSIF original_trans_code_ = 'OWNTRANOUT' THEN
      serial_message_ := Get_Serial_Message___('PSCNISS', LTRIM(RTRIM(location_no_)), null, null, null);
      Part_Serial_Catalog_API.Issue(part_no_,
                                    serial_no_,
                                    serial_message_,
                                    source_ref1_,
                                    source_ref2_,
                                    source_ref3_,
                                    source_ref4_,
                                    source_ref_type_,
                                    transaction_id_);
   ELSIF original_trans_code_ IN ('UNOPFDSCP', 'UNSODSPSCP') THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCUNOPFEED: Scrap correction during Disposition into location :P1', NULL, LTRIM(RTRIM(location_no_)));

      Part_Serial_Catalog_API.Unscrap_During_Disposition(part_no_, serial_no_, serial_message_);

   ELSIF (original_trans_code_ = 'CROREC') THEN
      current_position_ := Part_Serial_Catalog_API.Get_Objstate(part_no_, serial_no_);

      IF (current_position_ = 'InFacility') THEN
         serial_message_ := Get_Serial_Message___('LMBFAC2INV', LTRIM(RTRIM(location_no_)));
         Part_Serial_Catalog_API.Move_To_Inventory(part_no_                  =>  part_no_,
                                                   serial_no_                =>  serial_no_,
                                                   transaction_description_  =>  serial_message_,
                                                   order_no_                 =>  source_ref1_,
                                                   line_no_                  =>  source_ref2_,
                                                   release_no_               =>  source_ref3_,
                                                   line_item_no_             =>  source_ref4_,
                                                   order_type_               =>  source_ref_type_,
                                                   inv_transaction_id_       =>  transaction_id_,
                                                   lot_batch_no_             =>  lot_batch_no_,
                                                   configuration_id_         =>  configuration_id_,
                                                   operational_condition_db_ => operational_condition_db_,
                                                   eng_part_revision_        => eng_part_revision_ );
      ELSIF (current_position_ = 'Issued') THEN
         Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                      serial_no_,
                                                      part_ownership_,
                                                      owning_vendor_no_,
                                                      owning_customer_no_);

         serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'CRORECUNISS: Unissued into location :P1 from Component Repair Order :P2', NULL, LTRIM(RTRIM(location_no_)), source_ref1_||' '||source_ref2_);
         Part_Serial_Catalog_API.Unissue( part_no_                  =>  part_no_,
                                          serial_no_                =>  serial_no_,
                                          transaction_description_  =>  serial_message_,
                                          order_no_                 =>  source_ref1_,
                                          line_no_                  =>  source_ref2_,
                                          release_no_               =>  source_ref3_,
                                          line_item_no_             =>  source_ref4_,
                                          order_type_               =>  source_ref_type_,
                                          inv_transaction_id_       =>  transaction_id_,
                                          lot_batch_no_             =>  lot_batch_no_,
                                          configuration_id_         =>  configuration_id_,
                                          operational_condition_db_ =>  operational_condition_db_,
                                          eng_part_revision_        => eng_part_revision_ );
      ELSE
         serial_message_ := Get_Serial_Message___('PSCNREC', LTRIM(RTRIM(location_no_)), null, null, null);
         Part_Serial_Catalog_API.New_In_Inventory(part_no_                    => part_no_,
                                                  serial_no_                  => serial_no_,
                                                  transaction_description_    => serial_message_,
                                                  note_text_                  => NULL,
                                                  order_no_                   => source_ref1_,
                                                  line_no_                    => source_ref2_,
                                                  release_no_                 => source_ref3_,
                                                  line_item_no_               => source_ref4_,
                                                  order_type_                 => source_ref_type_,
                                                  inv_transaction_id_         => transaction_id_,
                                                  supplier_no_                => vendor_no_,
                                                  manufacturer_no_            => NULL,
                                                  configuration_id_           => configuration_id_,
                                                  operational_status_db_      => 'NOT_APPLICABLE',
                                                  lot_batch_no_               => lot_batch_no_,
                                                  condition_code_             => condition_code_,
                                                  part_ownership_             => part_ownership_,
                                                  owning_vendor_no_           => owning_vendor_no_,
                                                  owning_customer_no_         => owning_customer_no_,
                                                  eng_part_revision_          => eng_part_revision_,
                                                  operational_condition_db_   => operational_condition_db_);
      END IF;
   ELSIF original_trans_code_ IN ('PARTREN+', 'SERREN+') THEN
      Part_Serial_History_API.Set_Inv_Transaction_Id_On_Last(part_no_, serial_no_, transaction_id_);
   ELSIF original_trans_code_ = 'RENTRET' THEN
      serial_message_ := Get_Serial_Message___('PSCRENTRET', source_ref1_);
      Part_Serial_Catalog_API.Return_To_Supplier(part_no_, serial_no_, serial_message_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, source_ref_type_, transaction_id_);
   ELSIF original_trans_code_ IN ('RETPODIRSH', 'RETINTPODS') THEN
      $IF Component_Order_SYS.INSTALLED $THEN
         return_to_deliv_sup_ := Return_Material_Line_API.Check_Return_To_Delivered_Sup(source_ref1_, source_ref4_);
      $END
      IF (return_to_deliv_sup_) THEN
         IF original_trans_code_ = 'RETINTPODS' THEN
            Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                         serial_no_,
                                                         part_ownership_,
                                                         owning_vendor_no_,
                                                         owning_customer_no_); 
         END IF;
         serial_message_ := Get_Dirrettosup_Message___();
         Part_Serial_Catalog_API.Return_To_Supplier(part_no_, serial_no_, serial_message_,
                                                    source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                                    source_ref_type_, transaction_id_);
      END IF;
   ELSIF (original_trans_code_ = 'RETPODSINT') THEN
      IF (Part_Serial_Catalog_API.Is_Returned_To_Supplier(part_no_, serial_no_) = true_) THEN
         serial_message_ := Get_Serial_Message___('DIRRETEXTSUP');
         Part_Serial_Catalog_API.Modify_Latest_Transaction(part_no_,
                                                           serial_no_,
                                                           serial_message_,
                                                           serial_message_,
                                                           'INFO',
                                                           source_ref_type_,
                                                           source_ref1_,
                                                           source_ref2_,
                                                           source_ref3_,
                                                           source_ref4_,
                                                           transaction_id_);
      ELSE
         Error_SYS.Record_General(lu_name_, 'RETPODSINTERR: Part no :P1 serial no :P2 may not be processed on transaction RETPODSINT since it is in state :P3.',part_no_, serial_no_,Part_Serial_Catalog_API.Get_Objstate(part_no_,serial_no_));
      END IF;
   -- 151151 Added 'UNCODELVOU'
   ELSIF original_trans_code_ IN ('OEUNSHIP', 'UNDELCONOU', 'UNCODELVOU') THEN
      Part_Serial_Catalog_API.Set_Serial_Ownership(part_no_,
                                                   serial_no_,
                                                   part_ownership_,
                                                   owning_vendor_no_,
                                                   owning_customer_no_);
                                                   
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'CODELUNISS: Unissued into location :P1 from customer order :P2', NULL, LTRIM(RTRIM(location_no_)), source_ref1_ || ' ' || source_ref2_ || ' ' || source_ref3_);
      Part_Serial_Catalog_API.Unissue(part_no_                    => part_no_,
                                      serial_no_                  => serial_no_,
                                      transaction_description_    => serial_message_,
                                      order_no_                   => source_ref1_,
                                      line_no_                    => source_ref2_,
                                      release_no_                 => source_ref3_,
                                      line_item_no_               => source_ref4_,
                                      order_type_                 => source_ref_type_,
                                      inv_transaction_id_         => transaction_id_,
                                      lot_batch_no_               => lot_batch_no_,
                                      configuration_id_           => configuration_id_,
                                      operational_condition_db_   => operational_condition_db_,
                                      eng_part_revision_          => eng_part_revision_ );
   -- EBALL, Added 'CRO-EXD-IN', 'CRO-EX-DEL' and 'CRO-EXR-OU'.
   -- 151151 Added 'UNCODELVIN'
   ELSIF original_trans_code_ IN ('POINV-WIP',  'CO-DELV-IN', 'INVM-ISS',   'UNCODELVIN',
                                  'PICK-OUT',   'INVM-OUT',   'COMPM-OUT',  'WDR-OUT',
                                  'CO-WDR-OUT', 'UNRCPT-',    'UNRCPT+',    'SERREN-',
                                  'SUNREC',     'RPSREC',     'INVREVAL+',  'INVREVAL-',
                                  'CO-INVREV+', 'CO-INVREV-', 'INVREVTR+',  'INVREVTR-',
                                  'ARR-REPAIR', 'UNRCPT',     'ADDFAPOOL',  'SCRAPPOOL',
                                  'IMPFAPOOL',  'REMFAPOOL',  'REPFAPOOL',  'XO-TR-OUT',
                                  'XO-UNRCPT',  'UNRC-ARRTR', 'INTORDTR',   'UNINTORDTR',
                                  'RINTORDTR',  'RINTOTRCOR', 'TRANSIBAL+', 'TRANSIBAL-',
                                  'INTREV',     'INTREVR',    'INTCOS',     'INTCOSR',
                                  'INTREV+',    'INTREV-',    'INTREVR+',   'INTREVR-',
                                  'UNINTREV',   'UNINTREVR',  'UNINTCOS',   'UNINTCOSR',
                                  'PROJTRAN-',  'PROJTRAN+',  'CO-PRJTRN-', 'CO-PRJTRN+',
                                  'DELCONF-IN', 'DELIVCONF',  'CONDCHG-',   'CONDCHG+',
                                  'CONDCHGTR-', 'CONDCHGTR+', 'CO-CONDCH-', 'CO-CONDCH+',
                                  'ROUNDDIFF+', 'ROUNDDIFF-', 'CO-UNPSHIP', 'COSUPCONSM',
                                  'CO-RETURN',  'COUNSUCONS', 'PCGCHG-',    'PCGCHG+',
                                  'PCGCHGTR-',  'PCGCHGTR+',  'CO-PCGCHG-', 'CO-PCGCHG+',
                                  'LOCGRP-',    'LOCGRP+',    'LOCGRPTR-',  'LOCGRPTR+',
                                  'CO-LOCGRP-', 'CO-LOCGRP+', 'PARTREN-',
                                  'PSGENOH',    'UNPSGENOH',  'RETWOR-WIP', 'RETCRE-WIP',
                                  'CLEAR-WIP+', 'CLEAR-WIP-', 'CROUNREC',   'UNRET-WIP' ,
                                  'CRO-EXD-IN', 'CRO-EX-DEL', 'CRO-EXR-OU',
                                  'RINTORDTRX', 'RENTRET-NI', 'CONDCHGCU+', 'CONDCHGCU-',
                                  'COTOCRA-',   'CRATOCO-',   'HANDLUNIT-', 'LOT-OUT',
                                  'UNR-SHPODS', 'UNR-SHPODW', 'UNR-SHPOD-', 'UNR-SHPOD+') THEN
      NULL;   
   ELSE
      Error_SYS.Record_General('InventoryTransactionHist', 'INVALIDTRANS: Transaction code :P1 is not valid for PartSerialCatalog. Contact system support.',original_trans_code_);
   END IF;
END Call_Part_Serial_Catalog___;


-- Manage_Condition_Code___
--   This method contains all rules and validations needed to find the
--   correct condition_code to use on the transaction history record.
PROCEDURE Manage_Condition_Code___ (
   condition_code_to_use_ OUT VARCHAR2,
   condition_code_to_lot_ OUT VARCHAR2,
   part_no_               IN VARCHAR2,
   serial_no_             IN VARCHAR2,
   lot_batch_no_          IN VARCHAR2,
   condition_code_        IN VARCHAR2,
   source_application_    IN VARCHAR2,
   cost_source_           IN VARCHAR2,
   part_catalog_rec_      IN Part_Catalog_API.Public_Rec )
IS
   serial_condition_code_    part_serial_catalog_pub.condition_code%TYPE;
   lot_batch_condition_code_ lot_batch_master_pub.condition_code%TYPE;

   CURSOR get_serial_condition IS
      SELECT condition_code
      FROM part_serial_catalog_pub
      WHERE part_no = part_no_
      AND   serial_no = serial_no_;

   CURSOR get_lot_batch_condition IS
      SELECT condition_code
      FROM lot_batch_master_pub
      WHERE part_no = part_no_
      AND   lot_batch_no = lot_batch_no_;

BEGIN
   IF (NVL(serial_no_,'*') != '*') THEN
      -- This is a transaction for a specific individual.
      IF (cost_source_ = 'ROUNDING DIFFERENCE') THEN
         condition_code_to_use_ := condition_code_;
      ELSE
         -- Try to find the individual in PartSerialCatalog and get its condition_code.
         OPEN get_serial_condition;
         FETCH get_serial_condition INTO serial_condition_code_;
         IF (get_serial_condition%FOUND) THEN
            -- The individual existed in PartSerialCatalog, use its condition_code.
            -- IF the user has entered a condition_code different from that on the
            -- individual in PartSerialCatalog then raise an error.
            IF (condition_code_ IS NOT NULL) THEN
               IF (serial_condition_code_ IS NULL) THEN
                  CLOSE get_serial_condition;
                  Error_SYS.Record_General('InventoryTransactionHist', 'SERIALNOCOND: It is not allowed to enter a condition code for serial no :P1 of part :P2.',serial_no_, part_no_);
               ELSE
                  IF (condition_code_ != serial_condition_code_) THEN
                     CLOSE get_serial_condition;
                     Error_SYS.Record_General('InventoryTransactionHist', 'SERIALCHCOND: It is not allowed to change condition code for serial no :P1 of part :P2.',serial_no_, part_no_);
                  END IF;
               END IF;
            END IF;
            condition_code_to_use_ := serial_condition_code_;
         ELSE
            -- The individual did not exist in PartSerialCatalog, this is a transaction
            -- for a new individual. Use the condition_code entered by the user.
            -- A new record will be entered into PartSerialCatalog.
            condition_code_to_use_ := condition_code_;
            IF (condition_code_to_use_ IS NULL) THEN
               -- The user did not enter any condition_code, check if condition_code is
               -- needed on the part.
               IF (part_catalog_rec_.condition_code_usage = Condition_Code_Usage_API.db_allow_condition_code) THEN
                  -- We need to have a condition_code on the individual, use system default.
                  condition_code_to_use_ := Condition_Code_API.Get_Default_Condition_Code;
               END IF;
            END IF;
         END IF;
         CLOSE get_serial_condition;
      END IF;
   -- Since this is a transaction for a specific individual, we must not send any
   -- condition_code to LotBatchMaster.
      condition_code_to_lot_ := NULL;
   ELSIF (NVL(lot_batch_no_,'*') !='*') THEN
      -- This is a transaction for a specific Lot/Batch.
      IF (cost_source_ = 'ROUNDING DIFFERENCE') THEN
         condition_code_to_use_ := condition_code_;
         condition_code_to_lot_ := NULL;
      ELSE
         -- Try to find the Lot/Batch in LotBatchMaster and get its condition_code.
         OPEN get_lot_batch_condition;
         FETCH get_lot_batch_condition INTO lot_batch_condition_code_;
         IF (get_lot_batch_condition%FOUND) THEN
            -- The Lot/Batch existed in LotBatchMaster, use its condition_code.
            -- IF the user has entered a condition_code different from that on the
            -- Lot/Batch in LotBatchMaster then raise an error.
            IF (condition_code_ IS NULL) THEN
               condition_code_to_use_ := lot_batch_condition_code_;
               condition_code_to_lot_ := condition_code_to_use_;
            ELSE
               IF (lot_batch_condition_code_ IS NULL) THEN
                  IF (source_application_ != 'POSTCOSTGROUPCHANGE') THEN
                     CLOSE get_lot_batch_condition;
                     Error_SYS.Record_General('InventoryTransactionHist', 'LOTBATNOCOND: It is not allowed to enter a condition code for lot :P1 of part :P2.',lot_batch_no_, part_no_);
                  END IF;
                  condition_code_to_use_ := condition_code_;
                  condition_code_to_lot_ := NULL;
               ELSE
                  IF (condition_code_ != lot_batch_condition_code_) THEN
                     CLOSE get_lot_batch_condition;
                     Error_SYS.Record_General('InventoryTransactionHist', 'LOTBATCHCOND: It is not allowed to change condition code for lot :P1 of part :P2.',lot_batch_no_, part_no_);
                  END IF;
                  condition_code_to_use_ := lot_batch_condition_code_;
                  condition_code_to_lot_ := condition_code_to_use_;
               END IF;
            END IF;
         ELSE
            -- The Lot/Batch did not exist in LotBatchMaster, this is a transaction
            -- for a new Lot/Batch. Use the condition_code entered by the user.
            -- A new record will be entered into LotBatchMaster.
            condition_code_to_use_ := condition_code_;
            IF (condition_code_to_use_ IS NULL) THEN
               -- The user did not enter any condition_code, check if condition_code is
               -- needed on the part.
               IF (part_catalog_rec_.condition_code_usage = Condition_Code_Usage_API.db_allow_condition_code) THEN
                  -- We need to have a condition_code on the Lot/Batch, use system default.
                  condition_code_to_use_ := Condition_Code_API.Get_Default_Condition_Code;
               END IF;
            END IF;
            condition_code_to_lot_ := condition_code_to_use_;
         END IF;
         CLOSE get_lot_batch_condition;
      END IF;
   ELSE
      -- This is a transaction with star (*) in serial_no AND lot_batch_no.
      -- Condition_code is not applicable. Raise an error if the user has
      -- entered a condition_code for this transaction.
      IF (condition_code_ IS NOT NULL) THEN
         IF ((source_application_ != 'POSTCOSTGROUPCHANGE') AND
             (cost_source_ NOT IN ('STOCK REVALUATION','ROUNDING DIFFERENCE'))) THEN
            -- Transactions with source application like above are allowed to have a
            -- condition code although both the serial_no and lot_batch_no is NULL.
            -- This will happen for parts with cost level = Cost per Condition.
            IF (part_catalog_rec_.serial_tracking_code = 'SERIAL TRACKING') THEN
               Raise_Serial_No_Mandatory___;
            ELSIF (part_catalog_rec_.lot_tracking_code IN ('LOT TRACKING','ORDER BASED')) THEN
               Error_SYS.Record_General('InventoryTransactionHist', 'LOTBATMND: A lot/batch number must be used with this part.');
            ELSE
               Error_SYS.Record_General('InventoryTransactionHist', 'CCNOSERLOT: Condition code may only be used in combination with serial number and/or lot number.');
            END IF;
         END IF;
      END IF;
      condition_code_to_use_ := condition_code_;
      condition_code_to_lot_ := NULL;
   END IF;
END Manage_Condition_Code___;


FUNCTION Get_Pur_Order_Exchange_Cost___ (
   source_ref1_ IN VARCHAR2,
   source_ref2_ IN VARCHAR2,
   source_ref3_ IN VARCHAR2,
   event_code_  IN VARCHAR2 ) RETURN NUMBER
IS
   exchange_cost_ NUMBER;
   stmt_          VARCHAR2(2000);
BEGIN
   IF (event_code_ = 'ARRIVAL') THEN
      stmt_:= 'BEGIN
              :exchange_cost_ := Pur_Order_Exchange_Comp_API.Get_Exchange_Cost(:source_ref1,
                                                                               :source_ref2,
                                                                               :source_ref3);
              END;';
      @ApproveDynamicStatement(2006-01-26,nidalk)
      EXECUTE IMMEDIATE stmt_
               USING OUT exchange_cost_,
                     IN source_ref1_,
                     IN source_ref2_,
                     IN source_ref3_;

   ELSIF (event_code_ IN ('RETWORK','RETCREDIT','SCPCREDIT')) THEN
      stmt_:= 'BEGIN
                  :exchange_cost_ := Pur_Order_Exchange_Comp_API.Get_Po_Exch_Event_Value(:source_ref1,
                                                                                     :source_ref2,
                                                                                     :source_ref3,
                                                                                     :to_date_);
              END;';
         @ApproveDynamicStatement(2006-01-26,nidalk)
         EXECUTE IMMEDIATE stmt_
               USING OUT exchange_cost_,
                     IN source_ref1_,
                     IN source_ref2_,
                     IN source_ref3_,
                     IN TO_DATE(NULL);
   ELSE
      Error_SYS.Record_General(lu_name_, 'EVENTERROR: Purchase Order Exchange Cost can not be processed for posting event :P1. Contact System Support.', event_code_);
   END IF;

   RETURN (NVL(exchange_cost_,0));

END Get_Pur_Order_Exchange_Cost___;

-- Balance_Po_Exchange_Cost___
--   This method is used for Exchange Purchase Order Functionality. This
--   procedure balance off the M142 postings for exchange order.
PROCEDURE Balance_Po_Exchange_Cost___ (
   company_                    IN VARCHAR2,
   tran_hist_rec_              IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   date_applied_               IN DATE,
   value_adjustment_           IN BOOLEAN,
   per_oh_adjustment_id_       IN NUMBER,
   control_type_key_rec_       IN Mpccom_Accounting_API.Control_Type_Key,
   trans_reval_event_id_       IN NUMBER,
   base_curr_code_             IN VARCHAR2,
   base_curr_rate_             IN NUMBER,
   base_curr_conv_factor_      IN NUMBER,
   base_curr_rate_is_inverted_ IN VARCHAR2,
   trans_curr_code_            IN VARCHAR2,
   trans_curr_rate_            IN NUMBER,
   trans_curr_conv_factor_     IN NUMBER,
   trans_curr_rounding_        IN NUMBER )
IS
   exch_diff_event_code_     VARCHAR2(10);
   due_at_dock_              NUMBER;
   m142_value_diff_          NUMBER;
   core_deposit_db_          VARCHAR2(20);
   dummy_                    VARCHAR2(80);
   exit_procedure_           EXCEPTION;
   trans_value_              NUMBER;
   exch_diff_value_          NUMBER;

BEGIN

   $IF Component_Purch_SYS.INSTALLED $THEN
      due_at_dock_ := Purchase_Order_Line_API.Get_Due_At_Dock(tran_hist_rec_.source_ref1, 
                                                              tran_hist_rec_.source_ref2, 
                                                              tran_hist_rec_.source_ref3);   
   $ELSE
      RAISE exit_procedure_;    
   $END     

   IF (due_at_dock_ != 0) THEN
      RAISE exit_procedure_;
   END IF;

   m142_value_diff_ := Get_Sum_Value('PUR ORDER',
                                     tran_hist_rec_.source_ref1,
                                     tran_hist_rec_.source_ref2,
                                     tran_hist_rec_.source_ref3,
                                     'M142',
                                     TO_DATE(NULL));

   IF (m142_value_diff_ = 0) THEN
      RAISE exit_procedure_;
   END IF;
   
   trans_value_ := Mpccom_Accounting_API.Get_Sum_Value(tran_hist_rec_.accounting_id, 'M142'); 

   IF (m142_value_diff_ = trans_value_) THEN
      $IF Component_Purch_SYS.INSTALLED $THEN
         core_deposit_db_ := Pur_Order_Exchange_Comp_API.Get_Core_Deposit_Db(tran_hist_rec_.source_ref1,
                                                                             tran_hist_rec_.source_ref2,
                                                                             tran_hist_rec_.source_ref3);   
      $ELSE
         RAISE exit_procedure_;    
      $END         

      IF (core_deposit_db_ = 'CORE DEPOSIT') THEN
         RAISE exit_procedure_;
      END IF;
      exch_diff_event_code_ := 'EXCH-DIFF-';
      exch_diff_value_ := trans_value_;
   ELSE
      IF (m142_value_diff_ > 0) THEN
         exch_diff_event_code_ := 'EXCH-DIFF-';
      ELSE
         exch_diff_event_code_ := 'EXCH-DIFF+';
      END IF;
      exch_diff_value_ := ABS(m142_value_diff_);
   END IF;
   Do_Str_Event_Acc_Impl___(dummy_,
                            company_,
                            exch_diff_event_code_,
                            tran_hist_rec_.accounting_id,
                            'INVENTORY',
                            exch_diff_value_,
                            date_applied_,
                            tran_hist_rec_.contract,
                            value_adjustment_,
                            tran_hist_rec_.userid,
                            NULL,
                            NULL,
                            per_oh_adjustment_id_,
                            control_type_key_rec_,
                            trans_reval_event_id_,
                            base_curr_code_,
                            base_curr_rate_,
                            base_curr_conv_factor_,
                            base_curr_rate_is_inverted_,
                            trans_curr_code_,
                            trans_curr_rate_,
                            trans_curr_conv_factor_,
                            trans_curr_rounding_,
                            NULL);
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Balance_Po_Exchange_Cost___;


-- Calculate_Transaction_Cost___
--   Performs an inventory transaction calculations for company owned
--   and consignment stocks.
PROCEDURE Calculate_Transaction_Cost___ (
   fifo_action_                      OUT VARCHAR2,
   conn_transaction_id_              OUT NUMBER,
   pre_trans_level_qty_in_stock_     OUT NUMBER,
   pre_trans_level_qty_in_transi_    OUT NUMBER,
   pre_trans_avg_cost_detail_tab_    OUT Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   transaction_required_             OUT BOOLEAN,
   cost_detail_tab_               IN OUT Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   transaction_code_              IN     VARCHAR2,
   contract_                      IN     VARCHAR2,
   part_no_                       IN     VARCHAR2,
   part_rec_                      IN     Inventory_Part_API.Public_Rec,
   configuration_id_              IN     VARCHAR2,
   lot_batch_no_                  IN     VARCHAR2,
   serial_no_                     IN     VARCHAR2,
   trancode_rec_                  IN     Mpccom_Transaction_Code_API.Public_Rec,
   condition_code_                IN     VARCHAR2,
   unit_cost_                     IN     NUMBER,
   quantity_                      IN     NUMBER,
   qty_reversed_                  IN     NUMBER,
   source_ref1_                   IN     VARCHAR2,
   source_ref2_                   IN     VARCHAR2,
   source_ref3_                   IN     VARCHAR2,
   source_ref4_                   IN     VARCHAR2,
   source_ref_type_db_            IN     VARCHAR2,
   company_                       IN     VARCHAR2,
   issue_transaction_id_          IN     NUMBER )
IS
BEGIN

   transaction_required_ := TRUE;

   IF (trancode_rec_.direction = '+') THEN
      Calc_Plus_Dir_Trans_Cost___(fifo_action_,
                                  pre_trans_level_qty_in_stock_,
                                  pre_trans_level_qty_in_transi_,
                                  pre_trans_avg_cost_detail_tab_,
                                  cost_detail_tab_,
                                  transaction_code_,
                                  contract_,
                                  part_no_,
                                  part_rec_,
                                  configuration_id_,
                                  lot_batch_no_,
                                  serial_no_,
                                  condition_code_,
                                  unit_cost_,
                                  quantity_,
                                  qty_reversed_,
                                  source_ref1_,
                                  source_ref2_,
                                  source_ref3_,
                                  source_ref4_,
                                  source_ref_type_db_,
                                  company_,
                                  issue_transaction_id_);

   ELSIF (trancode_rec_.direction = '-') THEN
      Calc_Minus_Dir_Trans_Cost___(fifo_action_,
                                   conn_transaction_id_,
                                   pre_trans_level_qty_in_stock_,
                                   pre_trans_level_qty_in_transi_,
                                   pre_trans_avg_cost_detail_tab_,
                                   cost_detail_tab_,
                                   transaction_code_,
                                   contract_,
                                   part_no_,
                                   part_rec_,
                                   configuration_id_,
                                   lot_batch_no_,
                                   serial_no_,
                                   condition_code_,
                                   unit_cost_,
                                   quantity_,
                                   qty_reversed_,
                                   source_ref1_,
                                   source_ref2_,
                                   source_ref3_,
                                   source_ref4_,
                                   source_ref_type_db_,
                                   company_);

   ELSIF (trancode_rec_.direction = '0') THEN
      Calc_Zero_Dir_Trans_Cost___(fifo_action_,
                                  pre_trans_level_qty_in_stock_,
                                  pre_trans_level_qty_in_transi_,
                                  pre_trans_avg_cost_detail_tab_,
                                  transaction_required_,
                                  cost_detail_tab_,
                                  transaction_code_,
                                  contract_,
                                  part_no_,
                                  part_rec_,
                                  configuration_id_,
                                  lot_batch_no_,
                                  serial_no_,
                                  condition_code_,
                                  unit_cost_,
                                  quantity_,
                                  source_ref1_,
                                  source_ref2_,
                                  source_ref3_,
                                  source_ref4_,
                                  source_ref_type_db_,
                                  company_,
                                  issue_transaction_id_);
   ELSE
      Error_SYS.Record_General(lu_name_, 'TRANDIRERR: Transaction Direction :P1 is not supported.', NVL(trancode_rec_.direction, 'NULL'));
   END IF;
END Calculate_Transaction_Cost___;


PROCEDURE Calc_Plus_Dir_Trans_Cost___ (
   fifo_action_                      OUT VARCHAR2,
   pre_trans_level_qty_in_stock_     OUT NUMBER,
   pre_trans_level_qty_in_transi_    OUT NUMBER,
   pre_trans_avg_cost_detail_tab_    OUT Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   cost_detail_tab_               IN OUT Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   transaction_code_              IN     VARCHAR2,
   contract_                      IN     VARCHAR2,
   part_no_                       IN     VARCHAR2,
   part_rec_                      IN     Inventory_Part_API.Public_Rec,
   configuration_id_              IN     VARCHAR2,
   lot_batch_no_                  IN     VARCHAR2,
   serial_no_                     IN     VARCHAR2,
   condition_code_                IN     VARCHAR2,
   unit_cost_                     IN     NUMBER,
   quantity_                      IN     NUMBER,
   qty_reversed_                  IN     NUMBER,
   source_ref1_                   IN     VARCHAR2,
   source_ref2_                   IN     VARCHAR2,
   source_ref3_                   IN     VARCHAR2,
   source_ref4_                   IN     VARCHAR2,
   source_ref_type_db_            IN     VARCHAR2,
   company_                       IN     VARCHAR2,
   issue_transaction_id_          IN     NUMBER )
IS
   local_unit_cost_       NUMBER;
   issue_trans_contract_  VARCHAR2(5);
   from_cost_detail_tab_  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   
BEGIN
  
   IF (source_ref_type_db_ = 'RMA') THEN
      IF (issue_transaction_id_ IS NULL) THEN
         cost_detail_tab_ := Get_Customer_Return_Cost(contract_,
                                                      part_no_,
                                                      configuration_id_,
                                                      lot_batch_no_,
                                                      serial_no_,
                                                      condition_code_,
                                                      source_ref1_,
                                                      source_ref4_,
                                                      transaction_code_);
      ELSE
         IF (transaction_code_ IN ('RETSHIPDIR', 'RETDIFSREC')) AND (NOT(part_rec_.inventory_valuation_method = 'ST')) THEN
            from_cost_detail_tab_ := Get_Transaction_Cost_Details(issue_transaction_id_);

            issue_trans_contract_ := Get_Transaction_Contract(issue_transaction_id_);
            cost_detail_tab_ := Inventory_Part_In_Stock_API.Transform_Cost_Details(issue_trans_contract_,
                                                                                   from_cost_detail_tab_,
                                                                                   contract_,
                                                                                   part_rec_.inventory_valuation_method,
                                                                                   part_rec_.inventory_part_cost_level);
      
         END IF;
      END IF;
   END IF;
   IF (transaction_code_ = 'ARRIVAL') THEN
      local_unit_cost_ := unit_cost_;
      cost_detail_tab_ := Get_Consumed_Comp_Cost_Details(source_ref1_,
                                                         source_ref2_,
                                                         source_ref3_,
                                                         source_ref4_);
   ELSE
      IF (cost_detail_tab_.COUNT = 0) THEN
         local_unit_cost_ := unit_cost_;
      END IF;
   END IF;
   
   IF (qty_reversed_ > 0) THEN
      IF (part_rec_.inventory_valuation_method = 'ST') THEN
         IF (part_rec_.inventory_part_cost_level IN ('COST PER PART',
                                                     'COST PER CONFIGURATION')) THEN
            cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                                         contract_,
                                                                         part_no_,
                                                                         configuration_id_,
                                                                         lot_batch_no_,
                                                                         serial_no_);
         ELSE
            Inventory_Part_Unit_Cost_API.Manage_Standard_Cost(cost_detail_tab_,
                                                              local_unit_cost_,
                                                              contract_,
                                                              part_no_,
                                                              configuration_id_,
                                                              lot_batch_no_,
                                                              serial_no_,
                                                              condition_code_,
                                                              part_rec_,
                                                              source_ref1_,
                                                              source_ref2_,
                                                              source_ref3_,
                                                              source_ref4_,
                                                              source_ref_type_db_,
                                                              company_);
         END IF;
      ELSIF (part_rec_.inventory_valuation_method = 'AV') THEN
         Inventory_Part_Unit_Cost_API.Modify_Average_Cost(pre_trans_level_qty_in_stock_,
                                                          pre_trans_level_qty_in_transi_,
                                                          pre_trans_avg_cost_detail_tab_,
                                                          cost_detail_tab_,
                                                          local_unit_cost_,
                                                          quantity_,
                                                          contract_,
                                                          part_no_,
                                                          configuration_id_,
                                                          lot_batch_no_,
                                                          serial_no_,
                                                          condition_code_,
                                                          part_rec_,
                                                          source_ref1_,
                                                          source_ref2_,
                                                          source_ref3_,
                                                          source_ref4_,
                                                          source_ref_type_db_,
                                                          company_);
      ELSIF (part_rec_.inventory_valuation_method IN ('FIFO', 'LIFO')) THEN
         NULL;
      ELSE
         Raise_Unknown_Value_Method___(part_rec_.inventory_valuation_method);
      END IF;
   ELSE
      IF (part_rec_.inventory_valuation_method = 'ST') THEN
         Inventory_Part_Unit_Cost_API.Manage_Standard_Cost(cost_detail_tab_,
                                                           local_unit_cost_,
                                                           contract_,
                                                           part_no_,
                                                           configuration_id_,
                                                           lot_batch_no_,
                                                           serial_no_,
                                                           condition_code_,
                                                           part_rec_,
                                                           source_ref1_,
                                                           source_ref2_,
                                                           source_ref3_,
                                                           source_ref4_,
                                                           source_ref_type_db_,
                                                           company_);
      ELSIF (part_rec_.inventory_valuation_method = 'AV') THEN
         IF (transaction_code_ IN ('ARRTRAN'   , 'OERET-INT' ,
                                   'CONDCHG+'  , 'CO-CONDCH+',
                                   'LOCGRP+'   , 'CO-LOCGRP+',
                                   'SHIPODSIT+', 'SHIPODWHS+' )) THEN
         -- WA calculation not needed for these transactions.
            cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                                                 contract_,
                                                                                 part_no_,
                                                                                 configuration_id_,
                                                                                 lot_batch_no_,
                                                                                 serial_no_);
         ELSE
            Inventory_Part_Unit_Cost_API.Modify_Average_Cost(pre_trans_level_qty_in_stock_,
                                                             pre_trans_level_qty_in_transi_,
                                                             pre_trans_avg_cost_detail_tab_,
                                                             cost_detail_tab_,
                                                             local_unit_cost_,
                                                             quantity_,
                                                             contract_,
                                                             part_no_,
                                                             configuration_id_,
                                                             lot_batch_no_,
                                                             serial_no_,
                                                             condition_code_,
                                                             part_rec_,
                                                             source_ref1_,
                                                             source_ref2_,
                                                             source_ref3_,
                                                             source_ref4_,
                                                             source_ref_type_db_,
                                                             company_);
         END IF;
      ELSIF (part_rec_.inventory_valuation_method IN ('FIFO', 'LIFO')) THEN         
         IF (transaction_code_ IN ( 'CO-DELV-IN',  'INVREC',
                                    'INVM-IN'   ,  'CO-INVM-IN',
                                    'WDR-IN'    ,  'CO-WDR-IN',
                                    'PICK-IN'   ,  'CO-PICK-IN',
                                    'SERIAL-IN' ,  'CO-SERIAL+',
                                    'SERREN+'   ,  'CO-SERREN+',
                                    'OERET-INT' ,  'DELCONF-IN',
                                    'PROJTRAN+' ,  'CO-PRJTRN+',
                                    'HANDLUNIT+',  'CO-HANDLU+',
                                    'LOT-IN'    ,  'CO-LOT-IN')) THEN
            NULL;
         ELSIF (transaction_code_ IN ('ARRTRAN','CONDCHG+', 'CO-CONDCH+',
                                      'LOCGRP+' , 'CO-LOCGRP+', 'SHIPODSIT+', 'SHIPODWHS+')) THEN
            cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                                                 contract_,
                                                                                 part_no_,
                                                                                 configuration_id_,
                                                                                 lot_batch_no_,
                                                                                 serial_no_);
         ELSE
            fifo_action_     := 'INSERT';
            cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Generate_Cost_Details(
                                                                              cost_detail_tab_,
                                                                              local_unit_cost_,
                                                                              TRUE,
                                                                              company_,
                                                                              contract_,
                                                                              part_no_,
                                                                              configuration_id_,
                                                                              source_ref1_,
                                                                              source_ref2_,
                                                                              source_ref3_,
                                                                              source_ref4_,
                                                                              source_ref_type_db_);
         END IF;
      ELSE
         Raise_Unknown_Value_Method___(part_rec_.inventory_valuation_method);
      END IF;
   END IF;
END Calc_Plus_Dir_Trans_Cost___;


PROCEDURE Calc_Minus_Dir_Trans_Cost___ (
   fifo_action_                      OUT VARCHAR2,
   conn_transaction_id_              OUT NUMBER,
   pre_trans_level_qty_in_stock_     OUT NUMBER,
   pre_trans_level_qty_in_transi_    OUT NUMBER,
   pre_trans_avg_cost_detail_tab_    OUT Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   cost_detail_tab_               IN OUT Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   transaction_code_              IN     VARCHAR2,
   contract_                      IN     VARCHAR2,
   part_no_                       IN     VARCHAR2,
   part_rec_                      IN     Inventory_Part_API.Public_Rec,
   configuration_id_              IN     VARCHAR2,
   lot_batch_no_                  IN     VARCHAR2,
   serial_no_                     IN     VARCHAR2,
   condition_code_                IN     VARCHAR2,
   unit_cost_                     IN     NUMBER,
   quantity_                      IN     NUMBER,
   qty_reversed_                  IN     NUMBER,
   source_ref1_                   IN     VARCHAR2,
   source_ref2_                   IN     VARCHAR2,
   source_ref3_                   IN     VARCHAR2,
   source_ref4_                   IN     VARCHAR2,
   source_ref_type_db_            IN     VARCHAR2,
   company_                       IN     VARCHAR2 )
IS
   local_unit_cost_ NUMBER;
   local_quantity_  NUMBER;
BEGIN

   IF (cost_detail_tab_.COUNT = 0) THEN
      local_unit_cost_ := unit_cost_;
   END IF;
   
   IF (qty_reversed_ > 0) THEN
      IF (part_rec_.inventory_valuation_method = 'ST') THEN
         cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                                                 contract_,
                                                                                 part_no_,
                                                                                 configuration_id_,
                                                                                 lot_batch_no_,
                                                                                 serial_no_);
      ELSIF (part_rec_.inventory_valuation_method = 'AV') THEN
         IF (transaction_code_ != 'UNRC-ARRTR') THEN
            Inventory_Part_Unit_Cost_API.Modify_Average_Cost(pre_trans_level_qty_in_stock_,
                                                             pre_trans_level_qty_in_transi_,
                                                             pre_trans_avg_cost_detail_tab_,
                                                             cost_detail_tab_,
                                                             local_unit_cost_,
                                                             quantity_ * (-1),
                                                             contract_,
                                                             part_no_,
                                                             configuration_id_,
                                                             lot_batch_no_,
                                                             serial_no_,
                                                             condition_code_,
                                                             part_rec_,
                                                             source_ref1_,
                                                             source_ref2_,
                                                             source_ref3_,
                                                             source_ref4_,
                                                             source_ref_type_db_,
                                                             company_);
         ELSE
            -- For UNRC-ARRTR we want to retrieve the current inventory value into
            -- pre_trans_avg_cost_detail_tab_ so that the value can be used when
            -- creating revaluation postings for the UNRC-ARRTR transaction if needed.
            pre_trans_avg_cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                                                 contract_,
                                                                                 part_no_,
                                                                                 configuration_id_,
                                                                                 lot_batch_no_,
                                                                                 serial_no_);
         END IF;
      ELSIF (part_rec_.inventory_valuation_method IN ('FIFO', 'LIFO')) THEN
         fifo_action_ := 'REMOVE';
      ELSE
         Raise_Unknown_Value_Method___(part_rec_.inventory_valuation_method);
      END IF;
   ELSE
      IF (part_rec_.inventory_valuation_method = 'ST') THEN
         cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                                                 contract_,
                                                                                 part_no_,
                                                                                 configuration_id_,
                                                                                 lot_batch_no_,
                                                                                 serial_no_);
      ELSIF (part_rec_.inventory_valuation_method = 'AV') THEN
         cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                                                 contract_,
                                                                                 part_no_,
                                                                                 configuration_id_,
                                                                                 lot_batch_no_,
                                                                                 serial_no_);
         IF (transaction_code_ IN ('CO-PURSHIP' , 'PURSHIP'  ,
                                    'CO-EX-SHIP', 'EXCH-SHIP',
                                    'SHIPDIR'   , 'SHIPTRAN' ,
                                    'PURBKFL'   , 'CO-PURBKFL',
                                    'RETWORK'   , 'RETCREDIT',
                                    'SCPCREDIT' , 'PURTRAN',
                                    'SHIPODSIT-')) THEN
            local_quantity_ := quantity_;
            IF (transaction_code_ IN ('RETWORK', 'RETCREDIT', 'SCPCREDIT')) THEN
               local_quantity_ := quantity_ * (-1);
               Get_Supplier_Return_Cost(conn_transaction_id_,
                                        cost_detail_tab_,
                                        source_ref1_,
                                        source_ref2_,
                                        source_ref3_,
                                        source_ref4_);
            END IF;
            -- The only purpose with this method call is to get values for
            -- pre_trans_level_qty_in_stock  and pre_trans_level_qty_in_transit
            -- to store on the transaction.
            -- The weighted average calculation is meaningless since
            -- we send in the currect weighted average as price.
            -- But we still use this method since we need the values we
            -- get from the OUT parameters.
            Inventory_Part_Unit_Cost_API.Modify_Average_Cost(pre_trans_level_qty_in_stock_,
                                                             pre_trans_level_qty_in_transi_,
                                                             pre_trans_avg_cost_detail_tab_,
                                                             cost_detail_tab_,
                                                             local_unit_cost_,
                                                             local_quantity_,
                                                             contract_,
                                                             part_no_,
                                                             configuration_id_,
                                                             lot_batch_no_,
                                                             serial_no_,
                                                             condition_code_,
                                                             part_rec_,
                                                             source_ref1_,
                                                             source_ref2_,
                                                             source_ref3_,
                                                             source_ref4_,
                                                             source_ref_type_db_,
                                                             company_);
         END IF;
      ELSIF (part_rec_.inventory_valuation_method IN ('FIFO', 'LIFO')) THEN
         -- EBALL, Added transaction code CRO-EXD-OU to the condition.
         IF (transaction_code_ IN ('CO-DELV-OU', 'INVM-TRISS',
                                   'INVM-ISS'  , 'CO-INVM-IS',
                                   'WDR-OUT'   , 'CO-WDR-OUT',
                                   'PICK-OUT'  , 'CO-PICK-OU',
                                   'SERIAL-OUT', 'CO-SERIAL-',
                                   'PROJTRAN-' , 'CO-PRJTRN-',
                                   'SERREN-'   , 'CO-SERREN-',
                                   'DELCONF-OU', 'CONDCHG-'  ,
                                   'CO-CONDCH-', 'LOCGRP-'   ,
                                   'CO-LOCGRP-', 'CRO-EXD-OU',
                                   'HANDLUNIT-', 'CO-HANDLU-',
                                   'LOT-OUT',    'CO-LOT-OUT',
                                   'SHIPODWHS-' )) THEN

            cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                                                 contract_,
                                                                                 part_no_,
                                                                                 configuration_id_,
                                                                                 lot_batch_no_,
                                                                                 serial_no_);
         ELSIF (transaction_code_ IN ('RETWORK', 'RETCREDIT', 'SCPCREDIT')) THEN
            fifo_action_     := 'REMOVE';
            Get_Supplier_Return_Cost(conn_transaction_id_,
                                     cost_detail_tab_,
                                     source_ref1_,
                                     source_ref2_,
                                     source_ref3_,
                                     source_ref4_,
                                     contract_,
                                     part_no_,
                                     configuration_id_,
                                     lot_batch_no_,
                                     serial_no_);
         ELSE
            fifo_action_ := 'ISSUE';
         END IF;
      ELSE
         Raise_Unknown_Value_Method___(part_rec_.inventory_valuation_method);
      END IF;
   END IF;
END Calc_Minus_Dir_Trans_Cost___;


PROCEDURE Calc_Zero_Dir_Trans_Cost___ (
   fifo_action_                      OUT VARCHAR2,
   pre_trans_level_qty_in_stock_     OUT NUMBER,
   pre_trans_level_qty_in_transi_    OUT NUMBER,
   pre_trans_avg_cost_detail_tab_    OUT Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   transaction_required_             OUT BOOLEAN,
   cost_detail_tab_               IN OUT Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   transaction_code_              IN     VARCHAR2,
   contract_                      IN     VARCHAR2,
   part_no_                       IN     VARCHAR2,
   part_rec_                      IN     Inventory_Part_API.Public_Rec,
   configuration_id_              IN     VARCHAR2,
   lot_batch_no_                  IN     VARCHAR2,
   serial_no_                     IN     VARCHAR2,
   condition_code_                IN     VARCHAR2,
   unit_cost_                     IN     NUMBER,
   quantity_                      IN     NUMBER,
   source_ref1_                   IN     VARCHAR2,
   source_ref2_                   IN     VARCHAR2,
   source_ref3_                   IN     VARCHAR2,
   source_ref4_                   IN     VARCHAR2,
   source_ref_type_db_            IN     VARCHAR2,
   company_                       IN     VARCHAR2,
   issue_transaction_id_          IN     NUMBER )
IS
   local_unit_cost_ NUMBER;
   issue_trans_contract_  VARCHAR2(5);
   from_cost_detail_tab_  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;

BEGIN

   transaction_required_ := TRUE;

   IF (source_ref_type_db_ = 'RMA') THEN
      IF (issue_transaction_id_ IS NULL) THEN
         cost_detail_tab_ := Get_Customer_Return_Cost(contract_,
                                                      part_no_,
                                                      configuration_id_,
                                                      lot_batch_no_,
                                                      serial_no_,
                                                      condition_code_,
                                                      source_ref1_,
                                                      source_ref4_,
                                                      transaction_code_);
      ELSE
         IF (transaction_code_ IN ('RETDIR-SCP', 'RETDIFSSCP')) THEN
            from_cost_detail_tab_ := Get_Transaction_Cost_Details(issue_transaction_id_);
           
            issue_trans_contract_ := Get_Transaction_Contract(issue_transaction_id_);
            cost_detail_tab_ := Inventory_Part_In_Stock_API.Transform_Cost_Details(issue_trans_contract_,
                                                                                   from_cost_detail_tab_,
                                                                                   contract_,
                                                                                   part_rec_.inventory_valuation_method,
                                                                                   part_rec_.inventory_part_cost_level);
         ELSE
            cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(issue_transaction_id_);
         END IF;
         
      END IF;
   END IF;

   IF (cost_detail_tab_.COUNT = 0) THEN
      local_unit_cost_ := unit_cost_;
   END IF;

   IF (transaction_code_ IN ('INVM-TRIN','COMPM-TRIN','INTORDTR','RINTORDTR', 'RINTORDTRX')) THEN
      -- In order to take care of movements of parts between different sites via transit
      -- we have to catch this event to be able to calculate the correct new inventory value.
      IF (part_rec_.inventory_valuation_method = 'ST') THEN

         Inventory_Part_Unit_Cost_API.Manage_Standard_Cost(cost_detail_tab_,
                                                           local_unit_cost_,
                                                           contract_,
                                                           part_no_,
                                                           configuration_id_,
                                                           lot_batch_no_,
                                                           serial_no_,
                                                           condition_code_,
                                                           part_rec_,
                                                           source_ref1_,
                                                           source_ref2_,
                                                           source_ref3_,
                                                           source_ref4_,
                                                           source_ref_type_db_,
                                                           company_,
                                                           put_to_transit_ => (transaction_code_ = 'INTORDTR'));
      ELSIF (part_rec_.inventory_valuation_method = 'AV') THEN
         Inventory_Part_Unit_Cost_API.Modify_Average_Cost(pre_trans_level_qty_in_stock_,
                                                          pre_trans_level_qty_in_transi_,
                                                          pre_trans_avg_cost_detail_tab_,
                                                          cost_detail_tab_,
                                                          local_unit_cost_,
                                                          quantity_,
                                                          contract_,
                                                          part_no_,
                                                          configuration_id_,
                                                          lot_batch_no_,
                                                          serial_no_,
                                                          condition_code_,
                                                          part_rec_,
                                                          source_ref1_,
                                                          source_ref2_,
                                                          source_ref3_,
                                                          source_ref4_,
                                                          source_ref_type_db_,
                                                          company_);
      ELSIF (part_rec_.inventory_valuation_method IN ('FIFO', 'LIFO')) THEN
         fifo_action_     := 'INSERT';
         cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Generate_Cost_Details(
                                                                              cost_detail_tab_,
                                                                              local_unit_cost_,
                                                                              TRUE,
                                                                              company_,
                                                                              contract_,
                                                                              part_no_,
                                                                              configuration_id_,
                                                                              source_ref1_,
                                                                              source_ref2_,
                                                                              source_ref3_,
                                                                              source_ref4_,
                                                                              source_ref_type_db_);
      ELSE
         Raise_Unknown_Value_Method___(part_rec_.inventory_valuation_method);
      END IF;
   ELSIF (transaction_code_ IN ('RINTOTRCOR', 'UNINTORDTR')) THEN
      IF (part_rec_.inventory_valuation_method = 'ST') THEN
         cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                                              contract_,
                                                                              part_no_,
                                                                              configuration_id_,
                                                                              lot_batch_no_,
                                                                              serial_no_);
      ELSIF (part_rec_.inventory_valuation_method = 'AV') THEN
         Inventory_Part_Unit_Cost_API.Modify_Average_Cost(pre_trans_level_qty_in_stock_,
                                                          pre_trans_level_qty_in_transi_,
                                                          pre_trans_avg_cost_detail_tab_,
                                                          cost_detail_tab_,
                                                          local_unit_cost_,
                                                          quantity_ * (-1),
                                                          contract_,
                                                          part_no_,
                                                          configuration_id_,
                                                          lot_batch_no_,
                                                          serial_no_,
                                                          condition_code_,
                                                          part_rec_,
                                                          source_ref1_,
                                                          source_ref2_,
                                                          source_ref3_,
                                                          source_ref4_,
                                                          source_ref_type_db_,
                                                          company_);
      ELSIF (part_rec_.inventory_valuation_method IN ('FIFO', 'LIFO')) THEN
         fifo_action_ := 'ISSUE';
      ELSE
         Raise_Unknown_Value_Method___(part_rec_.inventory_valuation_method);
      END IF;
   ELSIF (transaction_code_ IN ('INTPODIRIM', 'INTPODIRSH',
                                'CO-CONSUME', 'DELIVCONF' ,
                                'INTPURDIR', 'CRO-EX-DEL', 'CRO-EX-SCR')) THEN                              
      IF (part_rec_.inventory_valuation_method IN ('FIFO', 'LIFO')) THEN
         fifo_action_ := 'ISSUE';
      ELSE
         IF (transaction_code_ IN ('CO-CONSUME', 'DELIVCONF', 'CRO-EX-DEL', 'CRO-EX-SCR')) THEN
            cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(contract_,
                                                                                        part_no_,
                                                                                        configuration_id_,
                                                                                        lot_batch_no_,
                                                                                        serial_no_);
         END IF;
      END IF;
   ELSIF (transaction_code_ = 'OERET-SINT') THEN
      IF (part_rec_.inventory_valuation_method = 'ST') THEN
         cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(contract_,
                                                                                     part_no_,
                                                                                     configuration_id_,
                                                                                     lot_batch_no_,
                                                                                     serial_no_);
      ELSIF (part_rec_.inventory_valuation_method IN ('FIFO', 'LIFO')) THEN
         fifo_action_ := 'ISSUE';
      END IF;   
   ELSIF (transaction_code_ = 'CRO-EXR-OU') THEN
      cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(contract_,
                                                                                  part_no_,
                                                                                  configuration_id_,
                                                                                  lot_batch_no_,
                                                                                  serial_no_);
   ELSIF (transaction_code_ IN ('CONDCHGTR+', 'CONDCHGTR-',
                                'LOCGRPTR+' , 'LOCGRPTR-',
                                'CONDCHGCU+', 'CONDCHGCU-' )) THEN
      IF ((part_rec_.inventory_valuation_method = 'ST') AND
          (transaction_code_ IN ('CONDCHGTR+', 'CONDCHGCU+'))) THEN
         Inventory_Part_Unit_Cost_API.Manage_Standard_Cost(cost_detail_tab_,
                                                           local_unit_cost_,
                                                           contract_,
                                                           part_no_,
                                                           configuration_id_,
                                                           lot_batch_no_,
                                                           serial_no_,
                                                           condition_code_,
                                                           part_rec_,
                                                           source_ref1_,
                                                           source_ref2_,
                                                           source_ref3_,
                                                           source_ref4_,
                                                           source_ref_type_db_,
                                                           company_);
      ELSE
         cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                                                 contract_,
                                                                                 part_no_,
                                                                                 configuration_id_,
                                                                                 lot_batch_no_,
                                                                                 serial_no_);
      END IF;
   ELSIF (transaction_code_ = 'POINV-WIP') THEN
      cost_detail_tab_ := Get_Poinv_Wip_Trans_Cost___(source_ref1_,
                                                      source_ref2_,
                                                      source_ref3_ );
      IF (cost_detail_tab_.COUNT = 0) THEN
         transaction_required_ := FALSE;
      END IF;
   ELSIF (transaction_code_ = 'REP-SCRAP') THEN
      cost_detail_tab_ := Get_Ext_Service_Comp_Cost___(source_ref1_,
                                                       source_ref2_,
                                                       source_ref3_);
   ELSE
      IF (cost_detail_tab_.COUNT = 0) THEN
         cost_detail_tab_(1).accounting_year := '*';
         cost_detail_tab_(1).contract        := contract_;
         cost_detail_tab_(1).cost_bucket_id  := '*';
         cost_detail_tab_(1).company         := company_;
         cost_detail_tab_(1).cost_source_id  := '*';
         cost_detail_tab_(1).unit_cost       := NVL(local_unit_cost_, 0);
      END IF;
   END IF;
END Calc_Zero_Dir_Trans_Cost___;


FUNCTION Get_Object_By_Accounting_Id___ (
   accounting_id_ IN NUMBER ) RETURN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE
IS
   lu_rec_ INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   CURSOR getrec IS
      SELECT *
      FROM  INVENTORY_TRANSACTION_HIST_TAB
      WHERE accounting_id = accounting_id_;
BEGIN
   OPEN getrec;
   FETCH getrec INTO lu_rec_;
   CLOSE getrec;
   RETURN(lu_rec_);
END Get_Object_By_Accounting_Id___;


-- Check_Invoice_Reval_Running___
--   This method calls Inventory_Part_Unit_Cost_API.Lock_By_Keys_No_Wait in online mode and
--   Inventory_Part_Unit_Cost_API.Lock_By_Keys_Wait in background mode. If locking fails in online mode
--   an error message is raised telling that the part is locked for a cost recalculation. In background
--   mode, the process waits to acquire the lock and then proceeds.
PROCEDURE Check_Invoice_Reval_Running___ (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 )
IS
   record_locked EXCEPTION;
   PRAGMA        exception_init(record_locked, -20113);
BEGIN
   IF (Transaction_SYS.Is_Session_Deferred()) THEN
      Inventory_Part_Unit_Cost_API.Lock_By_Keys_Wait(contract_, part_no_, '*', '*', '*');
   ELSE   
      Inventory_Part_Unit_Cost_API.Lock_By_Keys_No_Wait(contract_, part_no_, '*', '*', '*');
   END IF;   
EXCEPTION
   WHEN record_locked THEN
      Error_SYS.Record_General(lu_name_, 'TRABASINVREV: Part number :P1 on site :P2 is currently locked for a cost recalculation process. Wait a few seconds and then try again.',part_no_, contract_);
END Check_Invoice_Reval_Running___;


-- Purchase_Order_Receipt___
--   Checks if a transaction code is for purchase order receipt.
FUNCTION Purchase_Order_Receipt___ (
   transaction_code_             IN VARCHAR2,
   include_supplier_consignment_ IN BOOLEAN DEFAULT TRUE ) RETURN BOOLEAN
IS
   purchase_order_receipt_ BOOLEAN := FALSE;
BEGIN
   IF (transaction_code_ IN ('ARRTRAN', 'ARRIVAL', 'ARRIVAL-DO', 'ARR-REPAIR', 'XO-ARRIVAL')) OR
      (transaction_code_ = 'CO-ARRIVAL' AND include_supplier_consignment_)  THEN
      purchase_order_receipt_ := TRUE;
   END IF;
   RETURN (purchase_order_receipt_);
END Purchase_Order_Receipt___;


-- Direct_Ship_Customer_Order___
--   Checks if a transaction code is for direct ship on customer order.
FUNCTION Direct_Ship_Customer_Order___ (
   transaction_code_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   direct_ship_customer_order_ BOOLEAN := FALSE;
BEGIN
   IF (transaction_code_ IN ('PODIRSH','INTPODIRSH','PODIRINTEM','PURDIR','INTPURDIR')) THEN
       direct_ship_customer_order_ := TRUE;
   END IF;
   RETURN (direct_ship_customer_order_);
END Direct_Ship_Customer_Order___;


-- End_Do_Booking___
--   This method is used to end the DoBooking.
PROCEDURE End_Do_Booking___ (
   online_flag_   IN VARCHAR2,
   complete_flag_ IN VARCHAR2,
   company_       IN VARCHAR2,
   date_applied_  IN DATE,
   accounting_id_ IN NUMBER )
IS
   dummy_ VARCHAR2(80);
BEGIN  

   -- Complete and check the whole accounting.
   IF ((online_flag_ = 'Y') OR (complete_flag_ = 'Y')) THEN
      Mpccom_Accounting_API.Complete_Check_Accounting(dummy_,
                                                      company_,
                                                      date_applied_,
                                                      accounting_id_);
   END IF;
END End_Do_Booking___;


-- Create_Po_Return_Price_Diff___
--   To post price diff postings when returning goods to the supplier.
PROCEDURE Create_Po_Return_Price_Diff___ (
   company_                    IN VARCHAR2,
   tran_hist_rec_              IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   date_applied_               IN DATE,
   value_adjustment_           IN BOOLEAN,
   per_oh_adjustment_id_       IN NUMBER,
   control_type_key_rec_       IN Mpccom_Accounting_API.Control_Type_Key,
   trans_reval_event_id_       IN NUMBER,
   base_curr_code_             IN VARCHAR2,
   base_curr_rate_             IN NUMBER,
   base_curr_conv_factor_      IN NUMBER,
   base_curr_rate_is_inverted_ IN VARCHAR2,
   trans_curr_code_            IN VARCHAR2,
   trans_curr_rate_            IN NUMBER,
   trans_curr_conv_factor_     IN NUMBER,
   trans_curr_rounding_        IN NUMBER )
IS
   arrival_price_diff_       NUMBER;
   value_diff_               NUMBER;
   event_code_               VARCHAR2(10);
   dummy_                    VARCHAR2(80);
   exit_procedure_           EXCEPTION;
 
BEGIN

   arrival_price_diff_ := Get_Arrival_Price_Diff___(tran_hist_rec_.source_ref1,
                                                    tran_hist_rec_.source_ref2,
                                                    tran_hist_rec_.source_ref3,
                                                    tran_hist_rec_.source_ref4);

   value_diff_:= (arrival_price_diff_ * tran_hist_rec_.quantity);

   IF (value_diff_ > 0) THEN
      event_code_ := 'REVPRDIFF+';
   ELSIF (value_diff_ < 0) THEN
      event_code_ := 'REVPRDIFF-';
   ELSE
      RAISE exit_procedure_;
   END IF;
 
   Do_Str_Event_Acc_Impl___(dummy_,
                            company_,
                            event_code_,
                            tran_hist_rec_.accounting_id,
                            'INVENTORY',
                            ABS(value_diff_),
                            date_applied_,
                            tran_hist_rec_.contract,
                            value_adjustment_,
                            tran_hist_rec_.userid,
                            NULL,
                            NULL,
                            per_oh_adjustment_id_,
                            control_type_key_rec_,
                            trans_reval_event_id_,
                            base_curr_code_,
                            base_curr_rate_,
                            base_curr_conv_factor_,
                            base_curr_rate_is_inverted_,
                            trans_curr_code_,
                            trans_curr_rate_,
                            trans_curr_conv_factor_,
                            trans_curr_rounding_,
                            NULL);
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Create_Po_Return_Price_Diff___;

-- Create_Price_Diff_Postings___
--   To create price diff postings when returning goods to the supplier.
PROCEDURE Create_Price_Diff_Postings___ (
   company_                    IN VARCHAR2,
   tran_hist_rec_              IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   date_applied_               IN DATE,
   value_adjustment_           IN BOOLEAN,
   per_oh_adjustment_id_       IN NUMBER,
   control_type_key_rec_       IN Mpccom_Accounting_API.Control_Type_Key,
   trans_reval_event_id_       IN NUMBER,
   base_curr_code_             IN VARCHAR2,
   base_curr_rate_             IN NUMBER,
   base_curr_conv_factor_      IN NUMBER,
   base_curr_rate_is_inverted_ IN VARCHAR2,
   trans_curr_code_            IN VARCHAR2,
   trans_curr_rate_            IN NUMBER,
   trans_curr_conv_factor_     IN NUMBER,
   trans_curr_rounding_        IN NUMBER )
IS
   part_rec_                Inventory_Part_API.Public_Rec;
   receipt_price_           NUMBER;
   price_diff_              NUMBER := 0;
   price_diff_event_code_   VARCHAR2(10);
   post_price_diff_att_arr_ VARCHAR2(20);
   purch_order_ref1_        INVENTORY_TRANSACTION_HIST_TAB.source_ref1%TYPE;
   purch_order_ref2_        INVENTORY_TRANSACTION_HIST_TAB.source_ref2%TYPE;
   purch_order_ref3_        INVENTORY_TRANSACTION_HIST_TAB.source_ref3%TYPE;
   purch_order_ref4_        INVENTORY_TRANSACTION_HIST_TAB.source_ref4%TYPE;
   dummy_                   VARCHAR2(80);
   exit_procedure_          EXCEPTION;
   value_posted_on_m10_     NUMBER;
   total_component_cost_    NUMBER;
   pur_qty_arrived_         NUMBER;                                                 
   inv_qty_arrived_         NUMBER;  
 
BEGIN 
   Company_Invent_Info_API.Get_Post_Price_Diff_At_Arr_Db(post_price_diff_att_arr_, company_);

   IF (post_price_diff_att_arr_ = false_) THEN
      RAISE exit_procedure_;
   END IF;

   part_rec_ :=  Inventory_Part_API.Get(tran_hist_rec_.contract, tran_hist_rec_.part_no);

   IF (part_rec_.inventory_valuation_method != 'ST') THEN
      RAISE exit_procedure_;
   END IF;

   IF (part_rec_.invoice_consideration != 'IGNORE INVOICE PRICE') THEN
      RAISE exit_procedure_;
   END IF;

   Get_Purch_Order_Ref___(purch_order_ref1_,
                          purch_order_ref2_,
                          purch_order_ref3_,
                          purch_order_ref4_,
                          tran_hist_rec_);
   
   $IF Component_Purch_SYS.INSTALLED $THEN
      pur_qty_arrived_:= Receipt_Info_API.Get_Qty_Arrived_By_Source(purch_order_ref1_,
                                                                    purch_order_ref2_,
                                                                    purch_order_ref3_,
                                                                    NULL,
                                                                    Logistics_Source_Ref_Type_API.DB_PURCHASE_ORDER,
                                                                    purch_order_ref4_);
      inv_qty_arrived_ := Receipt_Info_API.Get_Inv_Qty_Arrived_By_Source(purch_order_ref1_,
                                                                         purch_order_ref2_,
                                                                         purch_order_ref3_,
                                                                         NULL,
                                                                         Logistics_Source_Ref_Type_API.DB_PURCHASE_ORDER,
                                                                         purch_order_ref4_);
      
      receipt_price_ := Receive_Purchase_Order_API.Get_Receipt_Price(tran_hist_rec_.contract,
                                                                     tran_hist_rec_.part_no, 
                                                                     purch_order_ref1_, 
                                                                     purch_order_ref2_, 
                                                                     purch_order_ref3_, 
                                                                     purch_order_ref4_, 
                                                                     inv_qty_arrived_,
                                                                     false_,
                                                                     tran_hist_rec_.part_ownership);           
   $ELSE
      Error_SYS.Record_General(lu_name_, 'RECPURCHNOTINST: The ReceivePurchaseOrder Logical Unit is not installed. Contact system support.' );   
   $END

   value_posted_on_m10_ := Mpccom_Accounting_API.Get_Sum_Value(tran_hist_rec_.accounting_id,'M10');

   total_component_cost_ := Get_Consumed_Component_Cost(purch_order_ref1_,
                                                        purch_order_ref2_,
                                                        purch_order_ref3_,
                                                        purch_order_ref4_);

   -- Note that the value_posted_on_M10_ is negative since it is based on credit postings.
   price_diff_ := ((receipt_price_ + total_component_cost_) * tran_hist_rec_.quantity) + value_posted_on_m10_;

   IF (price_diff_ = 0) THEN
      RAISE exit_procedure_;
   END IF;

   IF (price_diff_ > 0) THEN
      price_diff_event_code_ := 'PRICEDIFF+';
   ELSE
      price_diff_event_code_ := 'PRICEDIFF-';
   END IF;

   Do_Str_Event_Acc_Impl___(dummy_,
                            company_,
                            price_diff_event_code_,
                            tran_hist_rec_.accounting_id,
                            'INVENTORY',
                            ABS(price_diff_),
                            date_applied_,
                            tran_hist_rec_.contract,
                            value_adjustment_,
                            tran_hist_rec_.userid,
                            NULL,
                            NULL,
                            per_oh_adjustment_id_,
                            control_type_key_rec_,
                            trans_reval_event_id_,
                            base_curr_code_,
                            base_curr_rate_,
                            base_curr_conv_factor_,
                            base_curr_rate_is_inverted_,
                            trans_curr_code_,
                            trans_curr_rate_,
                            trans_curr_conv_factor_,
                            trans_curr_rounding_,
                            NULL);
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Create_Price_Diff_Postings___;

-- This method is used to post the currency diff postings when the return is done after cascade postings were created.
-- When the invoice is created the currency can be differed. Also The invoice can be created in different currency.
-- After such invoice, when the return is done the return transactions should be balance the new invoice currency and new invoice amount.
PROCEDURE Post_Curr_Diff_After_Reval___ (
   company_                    IN VARCHAR2,
   tran_hist_rec_              IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   receipt_curr_code_          IN VARCHAR2,
   date_applied_               IN DATE )
IS
   invoice_curr_code_         VARCHAR2(3);
   purch_order_ref1_          INVENTORY_TRANSACTION_HIST_TAB.source_ref1%TYPE;
   purch_order_ref2_          INVENTORY_TRANSACTION_HIST_TAB.source_ref2%TYPE;
   purch_order_ref3_          INVENTORY_TRANSACTION_HIST_TAB.source_ref3%TYPE;
   purch_order_ref4_          INVENTORY_TRANSACTION_HIST_TAB.source_ref4%TYPE;
   avg_inv_price_in_inv_curr_ NUMBER;
   unit_cost_in_receipt_curr_ NUMBER;
   posted_amount_in_base_     NUMBER;
   posted_amount_in_curr_     NUMBER;
   
BEGIN
   
   $IF Component_Purch_SYS.INSTALLED $THEN
      Get_Purch_Order_Ref___(purch_order_ref1_, purch_order_ref2_, purch_order_ref3_, purch_order_ref4_, tran_hist_rec_);
      Invoice_Purchase_Order_API.Get_Invoice_Curr_Info(invoice_curr_code_,
                                                       avg_inv_price_in_inv_curr_,
                                                       purch_order_ref1_,
                                                       purch_order_ref2_,
                                                       purch_order_ref3_,
                                                       to_number(purch_order_ref4_),
                                                       company_);
      IF (invoice_curr_code_ IS NOT NULL AND avg_inv_price_in_inv_curr_ IS NOT NULL) THEN
         -- currency diff postings for return transactions are only needed, if an invoice for parts exists only where we should get values for invoice_curr_code_ and avg_inv_price_in_inv_curr_.
         IF (receipt_curr_code_ != invoice_curr_code_ ) THEN
            Get_Sum_Amounts_For_Receipt(base_curr_amount_          => posted_amount_in_base_,
                                        trans_curr_amount_         => posted_amount_in_curr_,
                                        source_ref1_               => purch_order_ref1_,
                                        source_ref2_               => purch_order_ref2_,
                                        source_ref3_               => purch_order_ref3_,
                                        source_ref4_               => purch_order_ref4_,
                                        str_code_                  => 'M14',
                                        to_date_                   => NULL,
                                        currency_code_             => receipt_curr_code_,
                                        skip_trans_reval_postings_ => 'FALSE');
            
            unit_cost_in_receipt_curr_ := posted_amount_in_curr_ / tran_hist_rec_.quantity;
         ELSE
            unit_cost_in_receipt_curr_ := 0;
         END IF;
         -- avg_chg_value_in_inv_curr_ = NULL since we don't need to reverse the charge amounts in curr since it is not link with 2455 Account.
         -- trans_reval_event_id_ is also no need to added here as this is not triggered at invoicing.
         Mpccom_Accounting_API.Do_Curr_Amt_Balance_Posting(company_                   => company_,
                                                           accounting_id_             => tran_hist_rec_.accounting_id,
                                                           contract_                  => tran_hist_rec_.contract,
                                                           quantity_arrived_          => tran_hist_rec_.quantity,
                                                           trans_reval_event_id_      => NULL,
                                                           receipt_curr_code_         => receipt_curr_code_,
                                                           invoice_curr_code_         => invoice_curr_code_,
                                                           avg_inv_price_in_inv_curr_ => avg_inv_price_in_inv_curr_,
                                                           avg_chg_value_in_inv_curr_ => NULL,
                                                           unit_cost_in_receipt_curr_ => unit_cost_in_receipt_curr_,
                                                           date_posted_               => date_applied_);
         
      END IF;                                                           
   $ELSE
      Error_SYS.Component_Not_Exist('PURCH');
   $END
END Post_Curr_Diff_After_Reval___;


PROCEDURE Cancel_Material_Backflush___ (
   source_ref1_         IN VARCHAR2,
   source_ref2_         IN VARCHAR2,
   source_ref3_         IN VARCHAR2,
   source_ref4_         IN VARCHAR2,
   source_ref_type_db_  IN VARCHAR2 )
IS
   new_transaction_id_           NUMBER := 0;
   outermost_hu_id_              NUMBER;
   validate_hu_struct_position_  BOOLEAN;
   transactions_stock_tab_       Inv_Part_Stock_Snapshot_API.Inv_Part_Stock_Tab;
   handl_unit_in_snapshot_tab_   Handl_Unit_Stock_Snapshot_API.Handl_Unit_Stock_Tab;
   inv_part_in_snapshot_tab_     Inv_Part_Stock_Snapshot_API.Inv_Part_Stock_Tab;

   CURSOR get_backflush_transactions IS
      SELECT *
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  alt_source_ref1     = source_ref1_
      AND    alt_source_ref2     = source_ref2_
      AND    alt_source_ref3     = source_ref3_
      AND    alt_source_ref4     = source_ref4_
      AND    alt_source_ref_type = source_ref_type_db_
      AND    (quantity - qty_reversed) > 0
      AND    transaction_code IN ('PURBKFL','CO-PURBKFL')
      ORDER BY transaction_id DESC;
      
   TYPE Transactions_Tab IS TABLE OF get_backflush_transactions%ROWTYPE;
   transactions_tab_ Transactions_Tab;
BEGIN
   OPEN get_backflush_transactions;
   FETCH get_backflush_transactions BULK COLLECT INTO transactions_tab_;
   CLOSE get_backflush_transactions;
   
   IF (transactions_tab_.COUNT > 0) THEN
      Inventory_Event_Manager_API.Start_Session;
      -- Get the inventory part in stock information from the transactions in order to take a snapshot of which
      -- handling units they affect.
      FOR i IN transactions_tab_.FIRST .. transactions_tab_.LAST LOOP
         transactions_stock_tab_(i).contract          := transactions_tab_(i).contract;
         transactions_stock_tab_(i).part_no           := transactions_tab_(i).part_no;
         transactions_stock_tab_(i).configuration_id  := transactions_tab_(i).configuration_id;
         transactions_stock_tab_(i).location_no       := transactions_tab_(i).location_no;
         transactions_stock_tab_(i).lot_batch_no      := transactions_tab_(i).lot_batch_no;
         transactions_stock_tab_(i).serial_no         := transactions_tab_(i).serial_no;
         transactions_stock_tab_(i).eng_chg_level     := transactions_tab_(i).eng_chg_level;
         transactions_stock_tab_(i).waiv_dev_rej_no   := transactions_tab_(i).waiv_dev_rej_no;
         transactions_stock_tab_(i).activity_seq      := transactions_tab_(i).activity_seq;
         transactions_stock_tab_(i).handling_unit_id  := transactions_tab_(i).handling_unit_id;
         transactions_stock_tab_(i).quantity          := transactions_tab_(i).quantity;
      END LOOP;
      -- Trigger a snapshot to figure out which full Handling Units that will be covered by the transactions.
      Handl_Unit_Snapshot_Util_API.Generate_Snapshot(handl_unit_stock_result_tab_   => handl_unit_in_snapshot_tab_,
                                                     inv_part_stock_result_tab_     => inv_part_in_snapshot_tab_,
                                                     inv_part_stock_tab_            => transactions_stock_tab_,
                                                     index_by_handling_unit_id_     => TRUE);

      FOR i IN transactions_tab_.FIRST .. transactions_tab_.LAST LOOP
         -- If the handling unit exists in the snapshot we want to avoid to trigger the hu_struct_position validation since
         -- we know that the full handling unit is included in the transactions.
         IF (handl_unit_in_snapshot_tab_.EXISTS(transactions_tab_(i).handling_unit_id)) THEN
            -- If the outermost_hu is not the top parent we need to disconnect it from its parent.
            outermost_hu_id_ := handl_unit_in_snapshot_tab_(transactions_tab_(i).handling_unit_id).outermost_hu_id;
            IF (Handling_Unit_API.Get_Parent_Handling_Unit_Id(outermost_hu_id_) IS NOT NULL) THEN
               Handling_Unit_API.Modify_Parent_Handling_Unit_Id(outermost_hu_id_, NULL);
            END IF;
            validate_hu_struct_position_ := FALSE;
         ELSE
            validate_hu_struct_position_ := TRUE;
         END IF;

         Inventory_Part_In_Stock_API.Unissue_Part(transaction_id_                => new_transaction_id_,
                                                  unissue_transaction_           => 'UN-PURBKFL',
                                                  pos_diff_transaction_          => 'INVREVAL+',
                                                  neg_diff_transaction_          => 'INVREVAL-',
                                                  quantity_                      => transactions_tab_(i).quantity,
                                                  catch_quantity_                => transactions_tab_(i).catch_quantity,
                                                  transaction_id_issue_          => transactions_tab_(i).transaction_id,
                                                  source_                        => transactions_tab_(i).source,
                                                  validate_hu_struct_position_   => validate_hu_struct_position_);
      END LOOP;
      Inventory_Event_Manager_API.Finish_Session;
   END IF;
END Cancel_Material_Backflush___;


PROCEDURE Remove_Superior_Connection___(
   source_ref1_        IN VARCHAR2,
   source_ref2_        IN VARCHAR2,
   source_ref3_        IN VARCHAR2,
   source_ref4_        IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2 )
IS
   CURSOR get_backflush_transactions IS
      SELECT part_no, serial_no
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  alt_source_ref1     = source_ref1_
      AND    alt_source_ref2     = source_ref2_
      AND    alt_source_ref3     = source_ref3_
      AND    alt_source_ref4     = source_ref4_
      AND    alt_source_ref_type = source_ref_type_db_
      AND    serial_no          != '*'
      AND    (quantity - qty_reversed) > 0
      AND    transaction_code IN ('PURBKFL','CO-PURBKFL')
      ORDER BY transaction_id DESC;
BEGIN
   FOR transaction_ IN get_backflush_transactions LOOP
      Part_Serial_Catalog_API.Remove_Superior_Info( transaction_.part_no, transaction_.serial_no, 'Issued', NULL, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_ );
   END LOOP;
END Remove_Superior_Connection___;


-- Get_Activity_Transfer_Cost___
--   Calculates the total cost of all project transfer transaction not yet
--   transferred to finance for an activity
FUNCTION Get_Activity_Transfer_Cost___ (
   part_no_                IN VARCHAR2,
   contract_               IN VARCHAR2,
   activity_seq_           IN NUMBER,
   report_earned_value_db_ IN VARCHAR2 ) RETURN Mpccom_Accounting_API.Project_Cost_Element_Tab
IS
   CURSOR get_accounting_id_tab IS
      SELECT accounting_id
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE transaction_code IN ('PROJTRAN+','CO-PRJTRN+','PROJTRAN-','CO-PRJTRN-')
         AND activity_seq         = activity_seq_
         AND part_no              = part_no_
         AND contract             = contract_
         AND (report_earned_value = report_earned_value_db_ OR report_earned_value_db_ IS NULL);

   project_cost_element_tab_ Mpccom_Accounting_API.Project_Cost_Element_Tab;
   accounting_id_tab_        Mpccom_Accounting_API.Accounting_Id_Tab;
   accounting_status_        VARCHAR2(20);
BEGIN

   OPEN  get_accounting_id_tab;
   FETCH get_accounting_id_tab BULK COLLECT INTO accounting_id_tab_;
   CLOSE get_accounting_id_tab;

   IF (accounting_id_tab_.COUNT > 0) THEN
      IF (report_earned_value_db_ IS NULL) THEN
         accounting_status_ := 'NOT TRANSFERRED';
      END IF;

      project_cost_element_tab_ := Mpccom_Accounting_API.Get_Activity_Costs_By_Status(
                                                                                accounting_id_tab_,
                                                                                accounting_status_);
   END IF;

   RETURN (project_cost_element_tab_) ;
END Get_Activity_Transfer_Cost___;


-- Refresh_Activity_Trans_Cost___
--   Updates a project connection with the correct cost
PROCEDURE Refresh_Activity_Trans_Cost___ (
   part_no_          IN VARCHAR2,
   contract_         IN VARCHAR2,
   activity_seq_     IN NUMBER,
   refresh_old_data_ IN VARCHAR2 DEFAULT 'FALSE' )
IS
   activity_info_tab_            Public_Declarations_API.PROJ_Project_Conn_Cost_Tab;
   activity_revenue_info_tab_    Public_Declarations_API.PROJ_Project_Conn_Revenue_Tab;
   attributes_                   Public_Declarations_API.PROJ_Project_Conn_Attr_Type;
BEGIN
   Refresh_Project_Connection (activity_info_tab_         => activity_info_tab_,
                               activity_revenue_info_tab_ => activity_revenue_info_tab_,
                               attributes_                => attributes_,
                               activity_seq_              => activity_seq_,
                               keyref1_                   => part_no_,
                               keyref2_                   => contract_,
                               keyref3_                   => '*',
                               keyref4_                   => '*',
                               keyref5_                   => '*',
                               keyref6_                   => '*',
                               refresh_old_data_          => refresh_old_data_);
END Refresh_Activity_Trans_Cost___;


-- Handle_Activity_Transfer___
--   Creates a project connection if needed and updates it with the correct cost
PROCEDURE Handle_Activity_Transfer___ (
   part_no_       IN VARCHAR2,
   contract_      IN VARCHAR2,
   activity_seq_  IN NUMBER )
IS
   connection_exist_          VARCHAR2(10);
   exit_procedure_            EXCEPTION;
   proj_lu_name_db_           VARCHAR2(20) := 'PROJINVTRANS';
   empty_tab_                 Mpccom_Accounting_API.Project_Cost_Element_Tab;
   used_amount_tab_           Mpccom_Accounting_API.Project_Cost_Element_Tab;
   earned_value_amount_tab_   Mpccom_Accounting_API.Project_Cost_Element_Tab;
   
   index_                     NUMBER := 0;
   activity_info_tab_         Public_Declarations_API.PROJ_Project_Conn_Cost_Tab;
   activity_revenue_info_tab_ Public_Declarations_API.PROJ_Project_Conn_Revenue_Tab;
   attributes_                Public_Declarations_API.PROJ_Project_Conn_Attr_Type;
   CURSOR get_project_cost_elements IS
      SELECT project_cost_element, 
             SUM(used_amount)      used_amount, 
             SUM(committed_amount) earned_value_cost 
      FROM   project_cost_element_tmp
      GROUP BY project_cost_element;
   
BEGIN
   $IF (Component_Proj_SYS.INSTALLED) $THEN
      connection_exist_ := Project_Connection_Util_API.Exist_Project_Connection (activity_seq_ => activity_seq_,
                                                                                 keyref1_      => part_no_,
                                                                                 keyref2_      => contract_,
                                                                                 keyref3_      => NULL,
                                                                                 keyref4_      => NULL,
                                                                                 keyref5_      => NULL,
                                                                                 keyref6_      => NULL,
                                                                                 proj_lu_name_ => proj_lu_name_db_);    
      IF (connection_exist_ = true_) THEN
         Refresh_Activity_Trans_Cost___ (part_no_      => part_no_,
                                         contract_     => contract_,
                                         activity_seq_ => activity_seq_ );
      ELSE
         used_amount_tab_ := Get_Activity_Transfer_Cost___ (part_no_                => part_no_,
                                                            contract_               => contract_,
                                                            activity_seq_           => activity_seq_,
                                                            report_earned_value_db_ => NULL);

         earned_value_amount_tab_ := Get_Activity_Transfer_Cost___ (part_no_                => part_no_,
                                                                    contract_               => contract_,
                                                                    activity_seq_           => activity_seq_,
                                                                    report_earned_value_db_ => 'TRUE' );

         Invent_Proj_Cost_Manager_API.Fill_Project_Cost_Element_Tmp (empty_tab_,
                                                                     empty_tab_,
                                                                     earned_value_amount_tab_,
                                                                     used_amount_tab_);
         FOR rec_ IN get_project_cost_elements LOOP
            index_                                       := index_ + 1;
            activity_info_tab_(index_).control_category  := rec_.project_cost_element;
            activity_info_tab_(index_).used              := rec_.used_amount;
            activity_info_tab_(index_).earned_value_cost := rec_.earned_value_cost;
         END LOOP;
         attributes_.last_transaction_date               := SYSDATE;
         Project_Connection_Util_API.Create_Connection (proj_lu_name_              => proj_lu_name_db_,
                                                        activity_seq_              => activity_seq_,
                                                        system_ctrl_conn_          => 'FALSE',
                                                        keyref1_                   => part_no_,
                                                        keyref2_                   => contract_,
                                                        keyref3_                   => NULL,
                                                        keyref4_                   => NULL,
                                                        keyref5_                   => NULL,
                                                        keyref6_                   => NULL,
                                                        object_description_        => lu_name_,
                                                        activity_info_tab_         => activity_info_tab_,
                                                        activity_revenue_info_tab_ => activity_revenue_info_tab_,
                                                        attributes_                => attributes_);
      END IF;
   $ELSE
      NULL;
   $END
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Handle_Activity_Transfer___;


-- Get_Arrival_Price_Diff___
--   Fetch the transactions that match the purchase receipt reference.
FUNCTION Get_Arrival_Price_Diff___ (
   source_ref1_ IN VARCHAR2,
   source_ref2_ IN VARCHAR2,
   source_ref3_ IN VARCHAR2,
   source_ref4_ IN VARCHAR2 ) RETURN NUMBER
IS
   CURSOR get_value IS
      SELECT quantity, accounting_id
      FROM  INVENTORY_TRANSACTION_HIST_TAB
      WHERE source_ref1    = source_ref1_
      AND   source_ref2    = source_ref2_
      AND   source_ref3    = source_ref3_
      AND   source_ref4    = source_ref4_
      AND   transaction_code IN ('ARRIVAL','XO-ARRIVAL')
      AND   part_ownership IN ('COMPANY OWNED','CONSIGNMENT');

   sum_value_       NUMBER;
   total_sum_value_ NUMBER  := 0;
   avg_price_       NUMBER;
   total_qty_       NUMBER  := 0;
   record_found_    BOOLEAN := FALSE;
BEGIN
   FOR value_rec IN get_value LOOP
      sum_value_ := Mpccom_Accounting_API.Get_Sum_Event_And_Type_Value(value_rec.accounting_id, 'PRICEDIFF%', 'M10', TO_DATE(NULL));

      total_sum_value_ := total_sum_value_+ sum_value_;
      total_qty_ := total_qty_ + value_rec.quantity;

      record_found_ := TRUE;
   END LOOP;

   IF (record_found_) THEN
      IF (total_qty_ = 0) THEN
         total_qty_ := 1;
      END IF;
      avg_price_ := total_sum_value_ / total_qty_ ;
   END IF;

   RETURN NVL(avg_price_,0) ;
END Get_Arrival_Price_Diff___;

-- Get_Arrival_Cost_Value_Qty___
--   To fetch the receipt cost.
--   Note: This code was written for the transactions ARRIVAL,ARR-REPAIR,
--   XO-ARRIVAL, PODIRSH,PODIRINTEM with posting type M10 , ARRTRAN and
--   INTPODIRSH with posting type M3, and CO-ARRIVAL with M61.
--   If there is a transaction code without a posting type declared in
--   AccountingEventPostingtype, it will fetch the default M10 value.
PROCEDURE Get_Arrival_Cost_Value_Qty___ (
   curr_amount_detail_tab_        OUT Mpccom_Accounting_API.Curr_Amount_Detail_Tab,      
   cost_                          OUT NUMBER,
   value_                         OUT NUMBER,
   qty_                           OUT NUMBER,
   price_diff_                    OUT NUMBER,    
   source_ref1_                   IN  VARCHAR2,
   source_ref2_                   IN  VARCHAR2,
   source_ref3_                   IN  VARCHAR2,
   source_ref4_                   IN  VARCHAR2,
   alt_source_ref1_               IN  VARCHAR2,
   alt_source_ref2_               IN  VARCHAR2,
   alt_source_ref3_               IN  VARCHAR2,
   alt_source_ref4_               IN  VARCHAR2,
   to_date_                       IN  DATE,
   include_reversed_transactions_ IN  BOOLEAN,
   serial_no_                     IN  VARCHAR2,
   use_original_amounts_for_pwa_  IN  BOOLEAN,
   fetch_curr_amount_details_     IN  BOOLEAN,
   use_only_m10_postings_         IN  BOOLEAN)
IS
   sum_cost_detail_tab_  Mpccom_Accounting_API.Value_Detail_Tab;
   sum_value_detail_tab_ Mpccom_Accounting_API.Value_Detail_Tab;
BEGIN
   Get_Arrival_Cost_Value_Qty___(sum_cost_detail_tab_,
                                 sum_value_detail_tab_,
                                 curr_amount_detail_tab_,
                                 cost_,
                                 value_,
                                 qty_,
                                 price_diff_,                                 
                                 source_ref1_,
                                 source_ref2_,
                                 source_ref3_,
                                 source_ref4_,
                                 alt_source_ref1_,
                                 alt_source_ref2_,
                                 alt_source_ref3_,
                                 alt_source_ref4_,
                                 to_date_,
                                 include_reversed_transactions_,
                                 serial_no_,
                                 use_original_amounts_for_pwa_,
                                 fetch_curr_amount_details_,
                                 use_only_m10_postings_);
END Get_Arrival_Cost_Value_Qty___;

-- Get_Arrival_Cost_Value_Qty___
--   To fetch the receipt cost.
--   Note: This code was written for the transactions ARRIVAL,ARR-REPAIR,
--   XO-ARRIVAL, PODIRSH,PODIRINTEM with posting type M10 , ARRTRAN and
--   INTPODIRSH with posting type M3, and CO-ARRIVAL with M61.
--   If there is a transaction code without a posting type declared in
--   AccountingEventPostingtype, it will fetch the default M10 value.
PROCEDURE Get_Arrival_Cost_Value_Qty___ (
   cost_detail_tab_               OUT Mpccom_Accounting_API.Value_Detail_Tab,
   value_detail_tab_              OUT Mpccom_Accounting_API.Value_Detail_Tab,
   curr_amount_detail_tab_        OUT Mpccom_Accounting_API.Curr_Amount_Detail_Tab,   
   cost_                          OUT NUMBER,
   value_                         OUT NUMBER,
   qty_                           OUT NUMBER,
   price_diff_                    OUT NUMBER,   
   source_ref1_                   IN  VARCHAR2,
   source_ref2_                   IN  VARCHAR2,
   source_ref3_                   IN  VARCHAR2,
   source_ref4_                   IN  VARCHAR2,
   alt_source_ref1_               IN  VARCHAR2,
   alt_source_ref2_               IN  VARCHAR2,
   alt_source_ref3_               IN  VARCHAR2,
   alt_source_ref4_               IN  VARCHAR2,
   to_date_                       IN  DATE,
   include_reversed_transactions_ IN  BOOLEAN,
   serial_no_                     IN  VARCHAR2,
   use_original_amounts_for_pwa_  IN  BOOLEAN,
   fetch_curr_amount_details_     IN  BOOLEAN,
   use_only_m10_postings_         IN  BOOLEAN)
IS
   trans_value_detail_tab_ Mpccom_Accounting_API.Value_Detail_Tab;
   total_value_detail_tab_ Mpccom_Accounting_API.Value_Detail_Tab;
   total_cost_detail_tab_  Mpccom_Accounting_API.Value_Detail_Tab;
   total_cost_             NUMBER := 0;
   total_qty_              NUMBER := 0;
   found_                  BOOLEAN := FALSE;
   from_alt_source_        BOOLEAN := FALSE;
   include_reversed_       VARCHAR2(5);
   use_this_transaction_   BOOLEAN;
   
   total_price_diff_                NUMBER := 0;
   local_price_diff_                NUMBER := 0;   
   trans_curr_amount_detail_tab_    Mpccom_Accounting_API.Curr_Amount_Detail_Tab;
   total_curr_amount_detail_tab_    Mpccom_Accounting_API.Curr_Amount_Detail_Tab;
   
   CURSOR get_trans_info_primary_source IS
      SELECT *
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE (date_applied <= to_date_ OR to_date_ IS NULL)
         AND source_ref1    = source_ref1_
         AND source_ref2    = source_ref2_
         AND source_ref3    = source_ref3_
         AND source_ref4 LIKE NVL(TO_CHAR(source_ref4_), '%')
         AND part_ownership IN ('COMPANY OWNED', 'CONSIGNMENT')
         AND (quantity > qty_reversed OR include_reversed_ = true_)
         AND (serial_no = serial_no_ OR serial_no_ IS NULL);

   CURSOR get_trans_info_alt_source IS
      SELECT *
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE (date_applied  <= to_date_ OR to_date_ IS NULL)
         AND alt_source_ref1 = alt_source_ref1_
         AND alt_source_ref2 = alt_source_ref2_
         AND alt_source_ref3 = alt_source_ref3_
         AND alt_source_ref4 LIKE NVL(alt_source_ref4_, '%')
         AND part_ownership IN ('COMPANY OWNED', 'CONSIGNMENT')
         AND (quantity > qty_reversed OR include_reversed_ = true_)
         AND (serial_no = serial_no_ OR serial_no_ IS NULL);

   TYPE Inv_Trans_Hist_Tab IS TABLE OF INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE
      INDEX BY PLS_INTEGER;
   inv_trans_hist_tab_    Inv_Trans_Hist_Tab;
BEGIN

   IF (include_reversed_transactions_) THEN
      include_reversed_ := true_;
   ELSE
      include_reversed_ := false_;
   END IF;
   
   IF (source_ref1_ IS NOT NULL) THEN
      OPEN  get_trans_info_primary_source;
      FETCH get_trans_info_primary_source BULK COLLECT INTO inv_trans_hist_tab_;
      CLOSE get_trans_info_primary_source;
   ELSIF (alt_source_ref1_ IS NOT NULL) THEN
      OPEN  get_trans_info_alt_source;
      FETCH get_trans_info_alt_source BULK COLLECT INTO inv_trans_hist_tab_;
      CLOSE get_trans_info_alt_source;
      from_alt_source_ := TRUE;
   END IF;

   IF (inv_trans_hist_tab_.COUNT > 0) THEN
      FOR i IN inv_trans_hist_tab_.FIRST..inv_trans_hist_tab_.LAST LOOP
         -- Restructured the code by calling Get_Arrival_Trans_Amounts___() so that the transactions for periodic weighted average parts are handled separately.
         Get_Arrival_Trans_Amounts___(trans_value_detail_tab_,
                                      trans_curr_amount_detail_tab_,
                                      use_this_transaction_,                                      
                                      local_price_diff_,
                                      from_alt_source_,
                                      to_date_,
                                      use_original_amounts_for_pwa_,
                                      trans_rec_ => inv_trans_hist_tab_(i),
                                      fetch_curr_amount_details_ => fetch_curr_amount_details_,
                                      use_only_m10_postings_ => use_only_m10_postings_);

         IF (use_this_transaction_) THEN
            total_qty_ := total_qty_ + inv_trans_hist_tab_(i).quantity;
            found_          := TRUE;
         END IF;
         -- Only take the ABS values for summing up as per the previous correction.
         total_cost_             := total_cost_ + ABS(Mpccom_Accounting_API.Get_Total_Value(trans_value_detail_tab_));
         total_value_detail_tab_ := Mpccom_Accounting_API.Get_Merged_Value_Detail_Tab(total_value_detail_tab_, trans_value_detail_tab_);
         trans_value_detail_tab_.DELETE;

         total_curr_amount_detail_tab_ := Mpccom_Accounting_API.Get_Merged_Curr_Amount_Tab(total_curr_amount_detail_tab_, trans_curr_amount_detail_tab_);
         trans_curr_amount_detail_tab_.DELETE;
         total_price_diff_ := total_price_diff_ + NVL(local_price_diff_,0);           

      END LOOP;
   END IF;
   
   Validate_Curr_Amount_Detail___(total_curr_amount_detail_tab_);        
   
   
   IF (found_) THEN
      value_detail_tab_      := total_value_detail_tab_;
      cost_                  := total_cost_/total_qty_;
      value_                 := total_cost_;
      qty_                   := total_qty_;
      total_cost_detail_tab_ := total_value_detail_tab_;

      curr_amount_detail_tab_ := total_curr_amount_detail_tab_;
      price_diff_            := total_price_diff_;
      
      IF (total_cost_detail_tab_.COUNT > 0) THEN
         FOR i IN total_cost_detail_tab_.FIRST..total_cost_detail_tab_.LAST LOOP
            total_cost_detail_tab_(i).value := total_cost_detail_tab_(i).value / total_qty_;
         END LOOP;
      END IF;
      cost_detail_tab_ := total_cost_detail_tab_;
   ELSE
      cost_ := NULL;
   END IF;
END Get_Arrival_Cost_Value_Qty___;


-- Validate_Alt_Source_Ref___
--   This method is used to validate the alternative source reference values.
PROCEDURE Validate_Alt_Source_Ref___ (
   alt_source_ref1_        IN VARCHAR2,
   alt_source_ref2_        IN VARCHAR2,
   alt_source_ref3_        IN VARCHAR2,
   alt_source_ref4_        IN VARCHAR2,
   alt_source_ref_type_db_ IN VARCHAR2 )
IS
BEGIN
   IF (alt_source_ref1_ IS NOT NULL) AND (alt_source_ref_type_db_ IS NULL) THEN
      Error_SYS.Record_General('InventoryTransactionHist', 'ALTREFTYPEINVALID: Alternative Ref Type must have a value when there is an Alternative Ref value.');
   END IF;
   IF (alt_source_ref1_ IS NULL) AND (alt_source_ref_type_db_ IS NOT NULL) THEN
      Error_SYS.Record_General('InventoryTransactionHist', 'ALTREFINVALID: Alternative Ref must have a value when there is an Alternative Ref Type.');
   END IF;
   IF (alt_source_ref2_ IS NOT NULL) AND (alt_source_ref1_ IS NULL) THEN
      Error_SYS.Record_General('InventoryTransactionHist', 'ALTREF1INVALID: Alternative Ref1 must have a value.');
   END IF;
   IF (alt_source_ref3_ IS NOT NULL) AND (alt_source_ref2_ IS NULL) THEN
      Error_SYS.Record_General('InventoryTransactionHist', 'ALTREF2INVALID: Alternative Ref2 must have a value.');
   END IF;
   IF (alt_source_ref4_ IS NOT NULL) AND (alt_source_ref3_ IS NULL) THEN
      Error_SYS.Record_General('InventoryTransactionHist', 'ALTREF3INVALID: Alternative Ref3 must have a value.');
   END IF;
END Validate_Alt_Source_Ref___;


PROCEDURE Reval_Cancel_Order_Receipt___ (
   new_value_detail_tab_     IN Mpccom_Accounting_API.Value_Detail_Tab,
   receipt_value_detail_tab_ IN Mpccom_Accounting_API.Value_Detail_Tab,
   cancel_transaction_id_    IN NUMBER,
   transaction_code_         IN VARCHAR2,
   company_                  IN VARCHAR2,
   per_oh_adjustment_id_     IN NUMBER )
IS
   positive_value_diff_tab_    Mpccom_Accounting_API.Value_Detail_Tab;
   negative_value_diff_tab_    Mpccom_Accounting_API.Value_Detail_Tab;
   reval_trans_code_           INVENTORY_TRANSACTION_HIST_TAB.transaction_code%TYPE;
   vendor_consignment_arrival_ BOOLEAN;
   company_finance_rec_        Company_Finance_API.Public_Rec;
BEGIN

   vendor_consignment_arrival_ := Vendor_Consignment_Arrival___(transaction_code_);
   company_finance_rec_        := Company_Finance_API.Get(company_);

   Mpccom_Accounting_API.Create_Value_Diff_Tables(positive_value_diff_tab_,
                                                  negative_value_diff_tab_,
                                                  receipt_value_detail_tab_,
                                                  new_value_detail_tab_);
   IF (positive_value_diff_tab_.COUNT > 0) THEN
      IF (company_finance_rec_.correction_type = 'REVERSE') THEN
         IF (vendor_consignment_arrival_) THEN
            reval_trans_code_ := 'CO-INVREV-';
         ELSE
            reval_trans_code_ := 'RINVREVAL+';
         END IF;
      ELSE
         IF (vendor_consignment_arrival_) THEN
            reval_trans_code_ := 'CO-INVREV+';
         ELSE
            reval_trans_code_ := 'INVREVAL+';
         END IF;
         positive_value_diff_tab_ := Mpccom_Accounting_API.Get_Sign_Shifted_Value_Tab(
                                                                          positive_value_diff_tab_);
      END IF;

      Do_Booking(cancel_transaction_id_,
                 company_,
                 reval_trans_code_,
                 'N',
                 positive_value_diff_tab_,
                 per_oh_adjustment_id_ => per_oh_adjustment_id_);
   END IF;

   IF (negative_value_diff_tab_.COUNT > 0) THEN
      IF (company_finance_rec_.correction_type = 'REVERSE') THEN
         IF (vendor_consignment_arrival_) THEN
            reval_trans_code_ := 'CO-INVREV+';
         ELSE
            reval_trans_code_ := 'RINVREVAL-';
         END IF;
      ELSE
         IF (vendor_consignment_arrival_) THEN
            reval_trans_code_ := 'CO-INVREV-';
         ELSE
            reval_trans_code_ := 'INVREVAL-';
         END IF;
         negative_value_diff_tab_ := Mpccom_Accounting_API.Get_Sign_Shifted_Value_Tab(
                                                                         negative_value_diff_tab_);
      END IF;

      Do_Booking(cancel_transaction_id_,
                 company_,
                 reval_trans_code_,
                 'N',
                 negative_value_diff_tab_,
                 per_oh_adjustment_id_ => per_oh_adjustment_id_);
   END IF;
END Reval_Cancel_Order_Receipt___;


PROCEDURE Revalue_Reverse_Transaction___ (
   original_transaction_id_  IN NUMBER,
   reverse_transaction_id_   IN NUMBER,
   quantity_                 IN NUMBER,
   pos_diff_transaction_     IN VARCHAR2,
   neg_diff_transaction_     IN VARCHAR2,
   company_                  IN VARCHAR2 )
IS
   origin_trans_value_detail_tab_ Mpccom_Accounting_API.Value_Detail_Tab;
   revers_trans_value_detail_tab_ Mpccom_Accounting_API.Value_Detail_Tab;
   positive_value_diff_tab_       Mpccom_Accounting_API.Value_Detail_Tab;
   negative_value_diff_tab_       Mpccom_Accounting_API.Value_Detail_Tab;
BEGIN

   origin_trans_value_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Value_Details(original_transaction_id_, quantity_);
   revers_trans_value_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Value_Details(reverse_transaction_id_ , quantity_);

   Mpccom_Accounting_API.Create_Value_Diff_Tables(positive_value_diff_tab_,
                                                  negative_value_diff_tab_,
                                                  origin_trans_value_detail_tab_,
                                                  revers_trans_value_detail_tab_);
   IF (positive_value_diff_tab_.COUNT > 0) THEN

      Do_Booking(reverse_transaction_id_,
                 company_,
                 pos_diff_transaction_,
                 'N',
                 positive_value_diff_tab_);
   END IF;

   IF (negative_value_diff_tab_.COUNT > 0) THEN

      Do_Booking(reverse_transaction_id_,
                 company_,
                 neg_diff_transaction_,
                 'N',
                 negative_value_diff_tab_);
   END IF;
END Revalue_Reverse_Transaction___;


-- Reval_Canc_After_Oh_Adjust___
--   Overhead Adjustment and part cost level is 'Standard Cost'.
--   In this case when overhead cost details have been adjusted
--   there could be a need to recalculate the revaluation postings
--   that could have been added to the transaction if the standard cost
--   has changed between the original and the reversal transaction.
PROCEDURE Reval_Canc_After_Oh_Adjust___ (
   original_trans_id_    IN NUMBER,
   reverse_trans_id_     IN NUMBER,
   per_oh_adjustment_id_ IN NUMBER )
IS
   reverse_trans_rec_    INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   org_trans_rec_        INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   new_cost_detail_tab_  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   old_cost_detail_tab_  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   old_value_detail_tab_ Mpccom_Accounting_API.Value_Detail_Tab;
   new_value_detail_tab_ Mpccom_Accounting_API.Value_Detail_Tab;
   company_              VARCHAR2(20);
   pos_diff_event_code_  INVENTORY_TRANSACTION_HIST_TAB.transaction_code%TYPE;
   neg_diff_event_code_  INVENTORY_TRANSACTION_HIST_TAB.transaction_code%TYPE;
   exit_procedure_       EXCEPTION;
BEGIN

   reverse_trans_rec_ := Get_Object_By_Keys___(reverse_trans_id_);
   org_trans_rec_     := Get_Object_By_Keys___(original_trans_id_);

   IF ((reverse_trans_rec_.inventory_valuation_method != 'ST')  OR
       (reverse_trans_rec_.part_ownership NOT IN ('COMPANY OWNED', 'CONSIGNMENT'))) THEN
      RAISE exit_procedure_;
   END IF;

   company_             := Site_API.Get_Company(reverse_trans_rec_.contract);
   
   -- The new standard cost is assumed to be the current (updated) value of the
   -- cost details on the reversal transaction
   new_cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(reverse_trans_id_);
   old_cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(original_trans_id_);

   IF (org_trans_rec_.transaction_code IN ('ARRIVAL','CO-ARRIVAL', 'ARR-COMP',
                                           'SERLOTSWAP','PARTSWAP'))  THEN
      new_value_detail_tab_ := Create_Value_Detail_Tab(new_cost_detail_tab_,
                                                       reverse_trans_rec_.quantity,
                                                       reverse_trans_rec_.part_no);
      old_value_detail_tab_ := Mpccom_Accounting_API.Get_Sum_Value_Details(reverse_trans_rec_.accounting_id,
                                                                           'M1');
      old_value_detail_tab_ := Mpccom_Accounting_API.Get_Sign_Shifted_Value_Tab(old_value_detail_tab_);

      Reval_Cancel_Order_Receipt___(new_value_detail_tab_,
                                    old_value_detail_tab_,
                                    reverse_trans_id_,
                                    org_trans_rec_.transaction_code,
                                    company_,
                                    per_oh_adjustment_id_);
   ELSE
      IF (reverse_trans_rec_.transaction_code = 'UNRC-ARRTR') THEN
         -- This is handled in Reverse_Accounting since it is a case common to both
         -- OH adjustments and adjustments caused by Invoice Revaluation
         RAISE exit_procedure_;
      ELSIF (reverse_trans_rec_.transaction_code IN ('RINTOTRCOR', 'UNINTORDTR')) THEN
         pos_diff_event_code_ := 'INVREVTR+';
         neg_diff_event_code_ := 'INVREVTR-';
      ELSIF (reverse_trans_rec_.transaction_code IN ('RPSREC', 'SUNREC')) THEN
         pos_diff_event_code_ := 'RINVREVAL+';
         neg_diff_event_code_ := 'RINVREVAL-';
      ELSE
         pos_diff_event_code_ := 'INVREVAL+';
         neg_diff_event_code_ := 'INVREVAL-';
      END IF;

      Create_Revaluation_Postings___(new_cost_detail_tab_,
                                     old_cost_detail_tab_,
                                     pos_diff_event_code_,
                                     neg_diff_event_code_,
                                     reverse_trans_id_,
                                     reverse_trans_rec_.quantity,
                                     company_,
                                     value_adjustment_     => TRUE,
                                     per_oh_adjustment_id_ => per_oh_adjustment_id_,
                                     trans_reval_event_id_ => NULL,
                                     date_applied_         => NULL);
   END IF;
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Reval_Canc_After_Oh_Adjust___;


-- Reval_Wa_At_Empty_Inventory___
--   When inventory valuation method is Weighted Average: If a cancellation
--   of a receipt transaction results in that there is no quantity left in
--   inventory for the current part cost level then check if there is
--   a need to create extra postings on the cancel transaction to balance
--   out any possible values booked on the inventory account.
PROCEDURE Reval_Wa_At_Empty_Inventory___ (
   reverse_trans_rec_    IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   value_adjustment_     IN BOOLEAN,
   per_oh_adjustment_id_ IN NUMBER,
   trans_reval_event_id_ IN NUMBER,
   date_applied_         IN DATE )
IS
   pre_trans_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   trans_cost_detail_tab_     Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   company_                   VARCHAR2(20);
   trans_code_rec_            Mpccom_Transaction_Code_API.Public_Rec;
   pos_diff_event_code_       INVENTORY_TRANSACTION_HIST_TAB.transaction_code%TYPE;
   neg_diff_event_code_       INVENTORY_TRANSACTION_HIST_TAB.transaction_code%TYPE;
   exit_procedure_            EXCEPTION;
BEGIN

   -- Check to determine if a inventory revaluation could be needed.
   IF ((reverse_trans_rec_.inventory_valuation_method != 'AV') OR
       (reverse_trans_rec_.part_ownership != 'COMPANY OWNED')) THEN
      RAISE exit_procedure_;
   END IF;

   trans_code_rec_ := Mpccom_Transaction_Code_API.Get(reverse_trans_rec_.transaction_code);

   IF ((reverse_trans_rec_.direction = '+') OR
       ((reverse_trans_rec_.direction = '0') AND
        (trans_code_rec_.transit_qty_direction != 'DECREASE QUANTITY'))) THEN
      RAISE exit_procedure_;
   ELSIF ((reverse_trans_rec_.pre_trans_level_qty_in_stock +
           reverse_trans_rec_.pre_trans_level_qty_in_transit -
           reverse_trans_rec_.quantity != 0) OR
          ((reverse_trans_rec_.direction = '-') AND
           (trans_code_rec_.transit_qty_direction = 'INCREASE QUANTITY'))) THEN
      RAISE exit_procedure_;
   END IF;

   company_                   := Site_API.Get_Company(reverse_trans_rec_.contract);
   pre_trans_cost_detail_tab_ := Pre_Invent_Trans_Avg_Cost_API.Get_Cost_Details(
                                                       reverse_trans_rec_.transaction_id);
   trans_cost_detail_tab_     := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(reverse_trans_rec_.transaction_id);

   IF (reverse_trans_rec_.direction = '-') THEN
      -- Parts have been issued from inventory
      pos_diff_event_code_ := 'INVREVAL+';
      neg_diff_event_code_ := 'INVREVAL-';
   ELSE
      -- Parts have been issue from transit
      pos_diff_event_code_ := 'INVREVTR+';
      neg_diff_event_code_ := 'INVREVTR-';
   END IF;

   Create_Revaluation_Postings___(trans_cost_detail_tab_,
                                  pre_trans_cost_detail_tab_,
                                  pos_diff_event_code_,
                                  neg_diff_event_code_,
                                  reverse_trans_rec_.transaction_id,
                                  reverse_trans_rec_.quantity,
                                  company_,
                                  value_adjustment_,
                                  per_oh_adjustment_id_,
                                  trans_reval_event_id_,
                                  date_applied_ => date_applied_);
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Reval_Wa_At_Empty_Inventory___;


-- Balance_Transit_And_Invent___
--   Create revaluation postings to balance the inventory and transit
--   accounts when a transaction has changed the current inventory value
--   and valuation metod is Weighted Average, FIFO or LIFO
PROCEDURE Balance_Transit_And_Invent___ (
   inv_trans_rec_             IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   pre_trans_cost_detail_tab_ IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   current_cost_detail_tab_   IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   value_adjustment_          IN BOOLEAN,
   per_oh_adjustment_id_      IN NUMBER,
   trans_reval_event_id_      IN NUMBER,
   date_applied_              IN DATE )
IS
   pos_diff_event_code_ VARCHAR2(10);
   neg_diff_event_code_ VARCHAR2(10);
   revaluation_needed_  BOOLEAN := FALSE;
   revaluation_qty_     NUMBER;
   trans_code_rec_      Mpccom_Transaction_Code_API.Public_Rec;
   company_             VARCHAR2(20);
   exit_procedure_      EXCEPTION;
BEGIN

   company_            := Site_API.Get_Company(inv_trans_rec_.contract);

   -- Check to determine if a inventory/transit revaluation could be needed.
   IF ((Company_Invent_Info_API.Get_Use_Trans_Bal_Posting_Db(company_) = 'FALSE') OR
       (inv_trans_rec_.inventory_valuation_method NOT IN ('AV', 'FIFO', 'LIFO')) OR
       (pre_trans_cost_detail_tab_.COUNT = 0)) THEN
      RAISE exit_procedure_;
   END IF;

   trans_code_rec_ := Mpccom_Transaction_Code_API.Get(inv_trans_rec_.transaction_code);

   IF (trans_code_rec_.transit_qty_direction = 'UNAFFECTED QUANTITY') THEN
      revaluation_qty_ := inv_trans_rec_.pre_trans_level_qty_in_transit;
      IF (revaluation_qty_ != 0) THEN
         revaluation_needed_  := TRUE;
         pos_diff_event_code_ := 'TRANSIBAL+';
         neg_diff_event_code_ := 'TRANSIBAL-';
      END IF;
   ELSE
      -- 'INCREASE QUANTITY', 'DECREASE QUANTITY'
      -- Revaluation will only be needed when parts have been moved into
      -- or out of transit from an external source
      revaluation_qty_ := inv_trans_rec_.pre_trans_level_qty_in_stock;
      IF ((inv_trans_rec_.direction = '0') AND
          (revaluation_qty_ != 0)) THEN
         revaluation_needed_  := TRUE;
         pos_diff_event_code_ := 'TRANSIBAL-';
         neg_diff_event_code_ := 'TRANSIBAL+';
      END IF;
   END IF;

   IF NOT revaluation_needed_ THEN
      RAISE exit_procedure_;
   END IF;

   Create_Revaluation_Postings___(current_cost_detail_tab_,
                                  pre_trans_cost_detail_tab_,
                                  pos_diff_event_code_,
                                  neg_diff_event_code_,
                                  inv_trans_rec_.transaction_id,
                                  revaluation_qty_,
                                  company_,
                                  value_adjustment_,
                                  per_oh_adjustment_id_,
                                  trans_reval_event_id_,
                                  date_applied_);
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Balance_Transit_And_Invent___;


-- Create_Revaluation_Postings___
--   Create revaluation postings to balance accounts
PROCEDURE Create_Revaluation_Postings___ (
   new_cost_detail_tab_  IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   old_cost_detail_tab_  IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   pos_diff_event_code_  IN VARCHAR2,
   neg_diff_event_code_  IN VARCHAR2,
   transaction_id_       IN NUMBER,
   transaction_qty_      IN NUMBER,
   company_              IN VARCHAR2,
   value_adjustment_     IN BOOLEAN,
   per_oh_adjustment_id_ IN NUMBER,
   trans_reval_event_id_ IN NUMBER,
   date_applied_         IN DATE )
IS
   inv_trans_rec_              INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   pos_cost_diff_tab_          Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   neg_cost_diff_tab_          Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   pos_diff_value_detail_tab_  Mpccom_Accounting_API.Value_Detail_Tab;
   neg_diff_value_detail_tab_  Mpccom_Accounting_API.Value_Detail_Tab;
   old_value_detail_tab_       Mpccom_Accounting_API.Value_Detail_Tab;
   adjustment_date_            DATE;
BEGIN

   inv_trans_rec_ := Get_Object_By_Keys___(transaction_id_);

   -- Calculate the change in inventory value caused by this transaction
   Inventory_Part_Unit_Cost_API.Create_Cost_Diff_Tables(pos_cost_diff_tab_,
                                                        neg_cost_diff_tab_,
                                                        old_cost_detail_tab_,
                                                        new_cost_detail_tab_);

   IF (pos_cost_diff_tab_.COUNT > 0) THEN
      pos_diff_value_detail_tab_ := Create_Value_Detail_Tab(pos_cost_diff_tab_,
                                                            transaction_qty_,
                                                            inv_trans_rec_.part_no);
   END IF;

   IF (neg_cost_diff_tab_.COUNT > 0) THEN
      neg_diff_value_detail_tab_ := Create_Value_Detail_Tab(neg_cost_diff_tab_,
                                                            transaction_qty_,
                                                            inv_trans_rec_.part_no);
   END IF;

   -- For adjustments even if there is no difference found now
   -- the booking should be done to remove any possible diff previously
   -- booked when the transaction was created.
   IF value_adjustment_ THEN
      -- Retrive what was previously booked on the positive diff event
      old_value_detail_tab_ := Mpccom_Accounting_API.Get_Sum_Value_Details(
                                                               inv_trans_rec_.accounting_id,
                                                               'M1',
                                                               pos_diff_event_code_);
      -- Clear out the value previously booked
      IF (old_value_detail_tab_.COUNT > 0) THEN
         FOR i_ IN old_value_detail_tab_.FIRST..old_value_detail_tab_.LAST LOOP
            old_value_detail_tab_(i_).value := 0;
         END LOOP;
      END IF;

      -- This will merge the old and new details into pos_diff_value_detail_tab_
      pos_diff_value_detail_tab_ := Mpccom_Accounting_API.Get_Merged_Value_Detail_Tab(old_value_detail_tab_,
                                                                                      pos_diff_value_detail_tab_);

      -- Retrive what was previously booked on the negative diff event
      old_value_detail_tab_ := Mpccom_Accounting_API.Get_Sum_Value_Details(inv_trans_rec_.accounting_id,
                                                                           'M1',
                                                                           neg_diff_event_code_);
      -- Clear out the value previously booked
      IF (old_value_detail_tab_.COUNT > 0) THEN
         FOR i_ IN old_value_detail_tab_.FIRST..old_value_detail_tab_.LAST LOOP
            old_value_detail_tab_(i_).value := 0;
         END LOOP;
      END IF;

      -- This will merge the old and new details into neg_diff_value_detail_tab_
      neg_diff_value_detail_tab_ := Mpccom_Accounting_API.Get_Merged_Value_Detail_Tab(old_value_detail_tab_, neg_diff_value_detail_tab_);
      adjustment_date_           := NVL(date_applied_, TRUNC(Site_API.Get_Site_Date(inv_trans_rec_.contract)));
   END IF;

   -- Book the difference on the transaction.
   IF (pos_diff_value_detail_tab_.COUNT > 0) THEN
      Do_Booking(transaction_id_,
                 company_,
                 pos_diff_event_code_,
                 'N',
                 pos_diff_value_detail_tab_,
                 per_oh_adjustment_id_    => per_oh_adjustment_id_,
                 value_adjustment_        => TRUE,
                 adjustment_date_         => adjustment_date_,
                 do_post_booking_actions_ => FALSE,
                 trans_reval_event_id_    => trans_reval_event_id_);
   END IF;

   IF (neg_diff_value_detail_tab_.COUNT > 0) THEN
      Do_Booking(inv_trans_rec_.transaction_id,
                 company_,
                 neg_diff_event_code_,
                 'N',
                 neg_diff_value_detail_tab_,
                 per_oh_adjustment_id_    => per_oh_adjustment_id_,
                 value_adjustment_        => TRUE,
                 adjustment_date_         => adjustment_date_,
                 do_post_booking_actions_ => FALSE,
                 trans_reval_event_id_    => trans_reval_event_id_);
   END IF;
END Create_Revaluation_Postings___;


-- Revalue_Ret_Rework_Or_Cred___
--   Create revaluation postings to balance accounts when processing
--   a RETWORK or RETCREDIT transaction.
PROCEDURE Revalue_Ret_Rework_Or_Cred___ (
   inv_trans_rec_        IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   value_adjustment_     IN BOOLEAN,
   per_oh_adjustment_id_ IN NUMBER,
   trans_reval_event_id_ IN NUMBER,
   date_applied_         IN DATE )
IS
   company_                  VARCHAR2(20);
   part_rec_                 Inventory_Part_API.Public_Rec;
   transaction_              INVENTORY_TRANSACTION_HIST_TAB.transaction_code%TYPE;
   exit_procedure_           EXCEPTION;
   return_value_detail_tab_  Mpccom_Accounting_API.Value_Detail_Tab;
   arrival_cost_detail_tab_  Mpccom_Accounting_API.Value_Detail_Tab;
   arrival_value_detail_tab_ Mpccom_Accounting_API.Value_Detail_Tab;
   positive_value_diff_tab_  Mpccom_Accounting_API.Value_Detail_Tab;
   negative_value_diff_tab_  Mpccom_Accounting_API.Value_Detail_Tab;
   dummy_number_             NUMBER;
   source_ref1_              INVENTORY_TRANSACTION_HIST_TAB.source_ref1%TYPE;
   source_ref2_              INVENTORY_TRANSACTION_HIST_TAB.source_ref2%TYPE; 
   source_ref3_              INVENTORY_TRANSACTION_HIST_TAB.source_ref3%TYPE; 
   source_ref4_              INVENTORY_TRANSACTION_HIST_TAB.source_ref4%TYPE;
   alt_source_ref1_          INVENTORY_TRANSACTION_HIST_TAB.alt_source_ref1%TYPE; 
   alt_source_ref2_          INVENTORY_TRANSACTION_HIST_TAB.alt_source_ref2%TYPE; 
   alt_source_ref3_          INVENTORY_TRANSACTION_HIST_TAB.alt_source_ref3%TYPE; 
   alt_source_ref4_          INVENTORY_TRANSACTION_HIST_TAB.alt_source_ref4%TYPE;
   serial_no_local_          INVENTORY_TRANSACTION_HIST_TAB.serial_no%TYPE;
   use_original_amounts_for_pwa_  BOOLEAN := FALSE;
   update_accumulated_purch_diff_ BOOLEAN := FALSE;
   arrival_cost_                  INVENTORY_TRANSACTION_HIST_TAB.original_amount%TYPE;
   purchase_diff_                 NUMBER;
   dummy_curr_amount_detail_tab_  Mpccom_Accounting_API.Curr_Amount_Detail_Tab;
BEGIN

   part_rec_ := Inventory_Part_API.Get(inv_trans_rec_.contract, inv_trans_rec_.part_no);

   IF (Inventory_Part_In_Stock_API.Get_Part_Ownership_Db(inv_trans_rec_.contract,
                                                         inv_trans_rec_.part_no,
                                                         inv_trans_rec_.configuration_id,
                                                         inv_trans_rec_.location_no,
                                                         inv_trans_rec_.lot_batch_no,
                                                         inv_trans_rec_.serial_no,
                                                         inv_trans_rec_.eng_chg_level,
                                                         inv_trans_rec_.waiv_dev_rej_no,
                                                         inv_trans_rec_.activity_seq,
                                                         NVL(inv_trans_rec_.handling_unit_id, 0)) =
                                                         Part_Ownership_API.DB_CONSIGNMENT) THEN
      RAISE exit_procedure_;
   END IF;
   
   IF (inv_trans_rec_.transaction_code = 'RETPODSINT') THEN
      alt_source_ref1_ := inv_trans_rec_.alt_source_ref1;
      alt_source_ref2_ := inv_trans_rec_.alt_source_ref2; 
      alt_source_ref3_ := inv_trans_rec_.alt_source_ref3; 
      alt_source_ref4_ := inv_trans_rec_.alt_source_ref4;
      source_ref1_ := NULL;
      source_ref2_ := NULL; 
      source_ref3_ := NULL; 
      source_ref4_ := NULL;      
   ELSE      
      source_ref1_ := inv_trans_rec_.source_ref1;
      source_ref2_ := inv_trans_rec_.source_ref2; 
      source_ref3_ := inv_trans_rec_.source_ref3; 
      source_ref4_ := inv_trans_rec_.source_ref4;  
      alt_source_ref1_ := NULL;
      alt_source_ref2_ := NULL; 
      alt_source_ref3_ := NULL; 
      alt_source_ref4_ := NULL;
   END IF;
    
   -- It is needed to pass the correct serial_no to Get_Arrival_Cost_Value_Qty___ when the cost level is 'COST PER SERIAL' to retrieve the correct values
   -- when revaluation is in progress.
   IF ((value_adjustment_) AND (inv_trans_rec_.inventory_part_cost_level = 'COST PER SERIAL')) THEN
      serial_no_local_ := inv_trans_rec_.serial_no; 
   END IF;   
   
   IF ((inv_trans_rec_.inventory_valuation_method = 'ST') AND
      (part_rec_.invoice_consideration = 'PERIODIC WEIGHTED AVERAGE')) THEN
         use_original_amounts_for_pwa_  := TRUE;
         update_accumulated_purch_diff_ := TRUE;
   END IF;
   
   Get_Arrival_Cost_Value_Qty___(cost_detail_tab_            => arrival_cost_detail_tab_,
                              value_detail_tab_              => arrival_value_detail_tab_,
                              curr_amount_detail_tab_        => dummy_curr_amount_detail_tab_,
                              cost_                          => arrival_cost_,
                              value_                         => dummy_number_,
                              qty_                           => dummy_number_,
                              price_diff_                    => dummy_number_,                                
                              source_ref1_                   => source_ref1_,
                              source_ref2_                   => source_ref2_,
                              source_ref3_                   => source_ref3_,
                              source_ref4_                   => source_ref4_,
                              alt_source_ref1_               => alt_source_ref1_,
                              alt_source_ref2_               => alt_source_ref2_,
                              alt_source_ref3_               => alt_source_ref3_,
                              alt_source_ref4_               => alt_source_ref4_,
                              to_date_                       => NULL,
                              include_reversed_transactions_ => TRUE,
                              serial_no_                     => serial_no_local_,
                              use_original_amounts_for_pwa_  => use_original_amounts_for_pwa_,
                              fetch_curr_amount_details_     => FALSE,
                              use_only_m10_postings_         => FALSE);    
   
   -- Added a condition to add the price diff to ACCUMULATED_PURCHASE_DIFF when the part is periodic weighted average and construct the code.   
   IF update_accumulated_purch_diff_ THEN      
      purchase_diff_ := Mpccom_Accounting_API.Get_Sum_Value(inv_trans_rec_.accounting_id, 'M14')  - (arrival_cost_ * inv_trans_rec_.quantity);
      IF purchase_diff_ != 0 THEN
         Inventory_Part_Config_API.Add_To_Purchase_Diff(inv_trans_rec_.contract,
                                                        inv_trans_rec_.part_no,
                                                        inv_trans_rec_.configuration_id,
                                                        purchase_diff_);
      END IF;      
   ELSE

      IF (arrival_cost_detail_tab_.COUNT > 0) THEN
         FOR i IN arrival_cost_detail_tab_.FIRST..arrival_cost_detail_tab_.LAST LOOP
            arrival_cost_detail_tab_(i).value := arrival_cost_detail_tab_(i).value * inv_trans_rec_.quantity;
         END LOOP;
      END IF;
      
      arrival_cost_detail_tab_ := Mpccom_Accounting_API.Get_Sign_Shifted_Value_Tab(arrival_cost_detail_tab_);
      return_value_detail_tab_ := Mpccom_Accounting_API.Get_Sum_Value_Details(inv_trans_rec_.accounting_id, 'M14');

      Mpccom_Accounting_API.Create_Value_Diff_Tables(positive_value_diff_tab_,
                                                     negative_value_diff_tab_,
                                                     arrival_cost_detail_tab_,
                                                     return_value_detail_tab_);

      -- Make the following calls only if there are any records in either diff value tabs.
      IF (positive_value_diff_tab_.COUNT > 0) OR (negative_value_diff_tab_.COUNT > 0) THEN
         company_ := Site_API.Get_Company(inv_trans_rec_.contract);
      END IF;

      IF (positive_value_diff_tab_.COUNT > 0) THEN
         transaction_ := 'RETREVAL-';
         Do_Booking(inv_trans_rec_.transaction_id,
                    company_,
                    transaction_,
                    'N',
                    positive_value_diff_tab_,
                    per_oh_adjustment_id_    => per_oh_adjustment_id_,
                    value_adjustment_        => value_adjustment_,
                    adjustment_date_         => date_applied_,
                    do_post_booking_actions_ => FALSE,
                    trans_reval_event_id_    => trans_reval_event_id_);
      END IF;
   
      IF (negative_value_diff_tab_.COUNT > 0) THEN
         transaction_ := 'RETREVAL+';
         Do_Booking(inv_trans_rec_.transaction_id,
                    company_,
                    transaction_,
                    'N',
                    negative_value_diff_tab_,
                    per_oh_adjustment_id_    => per_oh_adjustment_id_,
                    value_adjustment_        => value_adjustment_,
                    adjustment_date_         => date_applied_,
                    do_post_booking_actions_ => FALSE,
                    trans_reval_event_id_    => trans_reval_event_id_);
      END IF;

      IF ((inv_trans_rec_.inventory_valuation_method = 'AV') AND
          (inv_trans_rec_.pre_trans_level_qty_in_stock IS NOT NULL)) THEN
         Reval_Wa_At_Empty_Inventory___(inv_trans_rec_,
                                        value_adjustment_,
                                        per_oh_adjustment_id_,
                                        trans_reval_event_id_,
                                        date_applied_);
      END IF;
   END IF;      
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Revalue_Ret_Rework_Or_Cred___;


-- Create_Trans_Cost_Details___
--   Create new record(s) for cost details in InventoryTransactionCost.
PROCEDURE Create_Trans_Cost_Details___ (
   transaction_id_            IN NUMBER,
   cost_detail_tab_           IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   added_to_this_transaction_ IN VARCHAR2,
   tran_hist_rec_             IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE )
IS
   purch_order_ref1_ INVENTORY_TRANSACTION_HIST_TAB.source_ref1%TYPE;
   purch_order_ref2_ INVENTORY_TRANSACTION_HIST_TAB.source_ref2%TYPE;
   purch_order_ref3_ INVENTORY_TRANSACTION_HIST_TAB.source_ref3%TYPE;
   purch_order_ref4_ INVENTORY_TRANSACTION_HIST_TAB.source_ref4%TYPE;
BEGIN

   IF (cost_detail_tab_.COUNT > 0)  THEN
      Get_Purch_Order_Ref___(purch_order_ref1_,
                             purch_order_ref2_,
                             purch_order_ref3_,
                             purch_order_ref4_,
                             tran_hist_rec_);
      FOR i_ IN cost_detail_tab_.FIRST..cost_detail_tab_.LAST LOOP
         Inventory_Transaction_Cost_API.New( transaction_id_,
                                             cost_detail_tab_(i_).contract,
                                             cost_detail_tab_(i_).cost_bucket_id,
                                             cost_detail_tab_(i_).company,
                                             cost_detail_tab_(i_).cost_source_id,
                                             cost_detail_tab_(i_).accounting_year,
                                             added_to_this_transaction_,
                                             cost_detail_tab_(i_).unit_cost,
                                             tran_hist_rec_.transaction_code,
                                             tran_hist_rec_.part_no,
                                             tran_hist_rec_.configuration_id,
                                             tran_hist_rec_.quantity,
                                             tran_hist_rec_.inventory_valuation_method,
                                             tran_hist_rec_.inventory_part_cost_level,
                                             purch_order_ref1_,
                                             purch_order_ref2_,
                                             purch_order_ref3_,
                                             purch_order_ref4_);
      END LOOP;
   END IF;
END Create_Trans_Cost_Details___;


PROCEDURE Check_Zero_Cost_Flag___ (
   unit_cost_        IN NUMBER,
   part_rec_         IN Inventory_Part_API.Public_Rec,
   part_no_          IN VARCHAR2,
   contract_         IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   part_catalog_rec_ IN Part_Catalog_API.Public_Rec )
IS
BEGIN

   IF (unit_cost_ = 0) THEN
      IF (part_rec_.zero_cost_flag = 'N') THEN
         -- Zero Cost is not allowed
         IF (part_rec_.inventory_part_cost_level NOT IN ('COST PER PART',
                                                         'COST PER CONFIGURATION')) THEN
            IF ((part_catalog_rec_.serial_tracking_code = 'SERIAL TRACKING') AND
                (serial_no_ = '*')) THEN
               Raise_Serial_No_Mandatory___;
            END IF;
            IF ((part_catalog_rec_.lot_tracking_code IN ('LOT TRACKING','ORDER BASED')) AND
                (lot_batch_no_ = '*')) THEN
               Error_SYS.Record_General(lu_name_, 'LOTBATMND: A lot/batch number must be used with this part.');
            END IF;
         END IF;
         Error_SYS.Record_General(lu_name_, '1226: The value of the inventory transaction may not be 0 for part :P1 on site :P2.', part_no_, contract_);
      END IF;
   ELSE
      IF (part_rec_.zero_cost_flag = 'O') THEN
         -- a cost greater than zero is not allowed
         Error_SYS.Record_General(lu_name_, 'PARTZEROCOSTONLY: The value of the inventory transaction may only be 0 for part :P1 on site :P2.', part_no_, contract_);
      END IF;
   END IF;

END Check_Zero_Cost_Flag___;


PROCEDURE Raise_Serial_No_Mandatory___
IS
BEGIN

   Error_SYS.Record_General(lu_name_, 'SERIALMND: A serial number must be used with this part.');
END Raise_Serial_No_Mandatory___;


PROCEDURE Raise_Unknown_Value_Method___ (
   inventory_valuation_method_db_ IN VARCHAR2 )
IS
BEGIN

   Error_SYS.Record_General(lu_name_, 'INVVALMETERR: Inventory Valuation Method :P1 is not supported in this operation.', Inventory_Value_Method_API.Decode(inventory_valuation_method_db_));
END Raise_Unknown_Value_Method___;


PROCEDURE Get_Deliv_Overhead_Settings___ (
   basic_event_deliv_oh_      OUT BOOLEAN,
   basic_deliv_oh_event_code_ OUT VARCHAR2,
   basic_event_code_          IN  VARCHAR2,
   basic_event_rec_           IN  Accounting_Event_API.Public_Rec )
IS
BEGIN

   basic_event_deliv_oh_ := FALSE;

   IF (basic_event_rec_.delivery_overhead_flag = 'Y') THEN

      basic_event_deliv_oh_ := TRUE;
      IF (basic_event_code_ = 'PODIRSH') THEN
         -- Specific delivery overhead event to be used for Customer Order Direct Ship.
         basic_deliv_oh_event_code_ := 'DS-DELIVOH';
      ELSIF (basic_event_code_ = 'PURDIR') THEN
         -- Specific delivery overhead event to be used for Direct Ship Material to Supplier.
         basic_deliv_oh_event_code_ := 'PC-DELIVOH';
      ELSIF (basic_event_code_ = 'COSUPCONSM') THEN
         -- Specific delivery overhead event to be used for Consignment Consumption Transactions.
         basic_deliv_oh_event_code_ := 'CO-DELIVOH';
      ELSIF (basic_event_code_ = 'PODIRINTEM') THEN
         -- Specific delivery overhead event to be used for Customer Order Direct Ship Internal Transit.
         basic_deliv_oh_event_code_ := 'IDS-DELOH';
      ELSIF (basic_event_code_ IN ('RETCREDIT','RETWORK','SCPCREDIT')) THEN
         -- Specific delivery overhead event to be used for variants of Return To Supplier.
         basic_deliv_oh_event_code_ := 'RET-DEL-OH';
      ELSIF (basic_event_code_ = 'RETPODIRSH') THEN
         -- Specific delivery overhead event to be used for Direct Delivery Return.
         basic_deliv_oh_event_code_ := 'RETDSDELOH';
      ELSE
         -- Normal delivery overhead for non-consignment stock arrivals.
         basic_deliv_oh_event_code_ := 'DELIV-OH';
      END IF;
   END IF;

END Get_Deliv_Overhead_Settings___;


PROCEDURE Get_Mtrl_Overhead_Settings___ (
   material_overhead_       OUT BOOLEAN,
   administration_addition_ OUT BOOLEAN,
   basic_event_rec_         IN  Accounting_Event_API.Public_Rec )
IS
BEGIN

   material_overhead_       := FALSE;
   administration_addition_ := FALSE;

   IF (basic_event_rec_.material_addition_flag = 'Y') THEN
      material_overhead_ := TRUE;
   ELSIF (basic_event_rec_.ms_addition_flag = 'Y') THEN
      administration_addition_ := TRUE;
   END IF;
END Get_Mtrl_Overhead_Settings___;


FUNCTION Get_Mtrl_Overhead_Details___ (
   tran_hist_rec_      IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   inventory_part_rec_ IN Inventory_Part_API.Public_Rec,
   company_            IN VARCHAR2,
   unit_cost_          IN NUMBER ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   accounting_event_code_ VARCHAR2(10);
   accounting_event_rec_  Accounting_Event_API.Public_Rec;
   cost_detail_tab_       Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;   
BEGIN
   $IF Component_Cost_SYS.INSTALLED $THEN
      accounting_event_code_ := tran_hist_rec_.transaction_code;
      accounting_event_rec_  := Accounting_Event_API.Get(accounting_event_code_);

      IF ((NVL(accounting_event_rec_.material_addition_flag,'N') = 'Y')  OR
          (NVL(accounting_event_rec_.ms_addition_flag,      'N') = 'Y')) THEN 
         Standard_Cost_Bucket_API.Issue_Material_Overhead_Cost(cost_detail_tab_,
                                                               tran_hist_rec_.contract,        
                                                               tran_hist_rec_.part_no,          
                                                               tran_hist_rec_.configuration_id, 
                                                               tran_hist_rec_.lot_batch_no,    
                                                               tran_hist_rec_.serial_no,       
                                                               tran_hist_rec_.condition_code,  
                                                               tran_hist_rec_.source_ref1,        
                                                               tran_hist_rec_.source_ref2,      
                                                               tran_hist_rec_.source_ref3,    
                                                               tran_hist_rec_.source_ref_type,   
                                                               tran_hist_rec_.quantity,  
                                                               tran_hist_rec_.inventory_valuation_method,
                                                               tran_hist_rec_.inventory_part_cost_level,   
                                                               unit_cost_); 
         Inventory_Part_Unit_Cost_API.Fill_Temporary_Table__(cost_detail_tab_); 
         
         cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_From_Temporary_Table__;

         cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Merge_And_Complete_Details(cost_detail_tab_,
                                                                                     inventory_part_rec_,
                                                                                     tran_hist_rec_.contract,
                                                                                     tran_hist_rec_.part_no,
                                                                                     company_,
                                                                                     '*',
                                                                                     tran_hist_rec_.source_ref1,
                                                                                     tran_hist_rec_.source_ref2,
                                                                                     tran_hist_rec_.source_ref3,
                                                                                     tran_hist_rec_.source_ref4,
                                                                                     tran_hist_rec_.source_ref_type,
                                                                                     trunc(tran_hist_rec_.date_created));         
      END IF;   
   $END
   RETURN (cost_detail_tab_);
END Get_Mtrl_Overhead_Details___;


FUNCTION Vendor_Consignment_Arrival___ (
 transaction_code_ IN VARCHAR2 ) RETURN BOOLEAN
IS
 vendor_consignment_arrival_ BOOLEAN := FALSE;
BEGIN
   IF (transaction_code_ = 'CO-ARRIVAL') THEN
      vendor_consignment_arrival_ := TRUE;
   END IF;

   RETURN (vendor_consignment_arrival_);
END Vendor_Consignment_Arrival___;


PROCEDURE Undo_Move_To_Order_Transit___ (
   transaction_id_tmp_        IN OUT NUMBER,
   transaction_code_          IN     VARCHAR2,
   quantity_                  IN     NUMBER,
   catch_qty_                 IN     NUMBER,
   source_                    IN     VARCHAR2,
   pos_diff_event_code_       IN     VARCHAR2,
   neg_diff_event_code_       IN     VARCHAR2,
   old_transaction_           IN     INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   old_trans_cost_detail_tab_ IN     Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   part_rec_                  IN     Inventory_Part_API.Public_Rec,
   company_                   IN     VARCHAR2 )
IS
   dummy_number_             NUMBER;
   home_contract_            INVENTORY_TRANSACTION_HIST_TAB.contract%TYPE;
   new_cost_detail_tab_      Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   old_cost_detail_tab_      Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   connected_transaction_id_ NUMBER;
   connected_transaction_    INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   dest_contract_            INVENTORY_PART_IN_STOCK_TAB.contract%TYPE;
   dest_warehouse_id_        INVENTORY_PART_IN_STOCK_TAB.warehouse%TYPE;
   delivering_warehouse_id_  INVENTORY_PART_IN_STOCK_TAB.warehouse%TYPE;
BEGIN

   -- Retrieve current cost before the new transaction is being created since
   -- the transaction could trigger a removal of the Inventory_Part_Unit_Cost record
   new_cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                              old_transaction_.contract,
                                                              old_transaction_.part_no,
                                                              old_transaction_.configuration_id,
                                                              old_transaction_.lot_batch_no,
                                                              old_transaction_.serial_no);
   NEW(transaction_id_         => transaction_id_tmp_,
       accounting_id_          => dummy_number_,
       value_                  => dummy_number_,
       transaction_code_       => transaction_code_,
       contract_               => old_transaction_.contract,
       part_no_                => old_transaction_.part_no,
       configuration_id_       => old_transaction_.configuration_id,
       location_no_            => old_transaction_.location_no,
       lot_batch_no_           => old_transaction_.lot_batch_no,
       serial_no_              => old_transaction_.serial_no,
       waiv_dev_rej_no_        => old_transaction_.waiv_dev_rej_no,
       eng_chg_level_          => old_transaction_.eng_chg_level,
       activity_seq_           => old_transaction_.activity_seq,
       handling_unit_id_       => old_transaction_.handling_unit_id,
       project_id_             => old_transaction_.project_id,
       source_ref1_            => old_transaction_.source_ref1,
       source_ref2_            => old_transaction_.source_ref2,
       source_ref3_            => old_transaction_.source_ref3,
       source_ref4_            => old_transaction_.source_ref4,
       source_ref5_            => old_transaction_.source_ref5,
       reject_code_            => old_transaction_.reject_code,
       cost_detail_tab_        => old_trans_cost_detail_tab_,
       unit_cost_              => NULL,
       quantity_               => quantity_,
       qty_reversed_           => quantity_,
       catch_quantity_         => catch_qty_,
       source_                 => source_,
       source_ref_type_        => Order_Type_API.Decode(old_transaction_.source_ref_type),
       owning_vendor_no_       => old_transaction_.owning_vendor_no,
       condition_code_         => NULL,
       location_group_         => old_transaction_.location_group,
       part_ownership_db_      => old_transaction_.part_ownership,
       owning_customer_no_     => old_transaction_.owning_customer_no,
       expiration_date_        => NULL,
       transit_location_group_ => old_transaction_.transit_location_group);

   connected_transaction_id_ := Invent_Trans_Interconnect_API.Get_Connected_Transaction_Id(old_transaction_.transaction_id,
                                                                                           'INTERSITE TRANSFER');
   connected_transaction_    := Get_Object_By_Keys___(connected_transaction_id_);
   home_contract_            := connected_transaction_.contract;
   
   IF (connected_transaction_.source_ref_type = Order_Type_API.DB_SHIPMENT_ORDER) THEN
      $IF (Component_Shpmnt_SYS.INSTALLED) $THEN
         Shipment_API.Get_Sender_Rece_Contract_Whse(dest_contract_, dest_warehouse_id_, delivering_warehouse_id_, connected_transaction_.source_ref5);
      $ELSE
         Error_SYS.Component_Not_Exist('SHPMNT');
      $END
   ELSE
      dest_contract_             := old_transaction_.contract;
      dest_warehouse_id_         := '*';
      delivering_warehouse_id_   := '*';      
   END IF;   

   Inventory_Part_In_Transit_API.Remove_From_Order_Transit(delivering_contract_     => home_contract_ ,
                                                           contract_                => dest_contract_,
                                                           part_no_                 => old_transaction_.part_no,
                                                           configuration_id_        => old_transaction_.configuration_id,
                                                           lot_batch_no_            => old_transaction_.lot_batch_no,
                                                           serial_no_               => old_transaction_.serial_no,
                                                           eng_chg_level_           => old_transaction_.eng_chg_level,
                                                           waiv_dev_rej_no_         => old_transaction_.waiv_dev_rej_no,
                                                           handling_unit_id_        => old_transaction_.handling_unit_id,
                                                           expiration_date_         => old_transaction_.expiration_date,
                                                           delivering_warehouse_id_ => delivering_warehouse_id_,
                                                           receiving_warehouse_id_  => dest_warehouse_id_,
                                                           activity_seq_            => old_transaction_.activity_seq,
                                                           part_ownership_db_       => old_transaction_.part_ownership,
                                                           owning_customer_no_      => NVL(old_transaction_.owning_customer_no, '*'),
                                                           owning_vendor_no_        => NVL(old_transaction_.owning_vendor_no, '*'),
                                                           deliv_no_                => 0,
                                                           shipment_id_             => 0,
                                                           shipment_line_no_        => 0,
                                                           qty_to_remove_           => quantity_ ,
                                                           catch_qty_to_remove_     => catch_qty_);
   IF (part_rec_.inventory_valuation_method = 'ST') THEN
      IF (old_transaction_.part_ownership IN ('COMPANY OWNED', 'CONSIGNMENT')) THEN
         old_cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(old_transaction_.transaction_id);

         Create_Revaluation_Postings___(new_cost_detail_tab_,
                                        old_cost_detail_tab_,
                                        pos_diff_event_code_,
                                        neg_diff_event_code_,
                                        transaction_id_tmp_,
                                        quantity_,
                                        company_,
                                        value_adjustment_     => NULL,
                                        per_oh_adjustment_id_ => NULL,
                                        trans_reval_event_id_ => NULL,
                                        date_applied_         => NULL);
      END IF;
   END IF;
END Undo_Move_To_Order_Transit___;


-- Post_Booking_Actions___
--   Execute additional actions needed as a consequence of creating or updating
--   inventory transactions.
--   value_adjustment_ =   TRUE indicates that changes are being done to an existing
--   transaction either by the Period OH Adjustments as a
--   result of a cascade update of transactions
--   cascade_adjustment_ = TRUE indicates that a value adjustment is being done
--   as a result of a cascade update of transactions
PROCEDURE Post_Booking_Actions___(
   inv_trans_rec_              IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   value_adjustment_           IN BOOLEAN,
   cascade_adjustment_         IN BOOLEAN,
   periodic_weighted_avg_calc_ IN BOOLEAN,
   per_oh_adjustment_id_       IN NUMBER,
   trans_reval_event_id_       IN NUMBER,
   date_applied_               IN DATE )
IS
   order_related_move_        BOOLEAN;
   connected_trans_id_        NUMBER;
   connected_trans_rec_       INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   pre_trans_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   current_cost_detail_tab_   Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
BEGIN

   -- Check if revaluations will be needed when moving parts between two sites
   IF (value_adjustment_ OR periodic_weighted_avg_calc_) THEN
      -- When adjusting the value for an issue transaction related to an intersite transfer
      -- value adjustments may be needed for the receipt transaction created on the
      -- destination site
      IF (inv_trans_rec_.transaction_code IN ('INVM-OUT', 'COMPM-OUT',
                                              'INTPODIRIM', 'SHIPTRAN',
                                              'CO-SHIPTRN', 'SHIPDIR',
                                              'CO-SHIPDIR', 'RETWORKINT',
                                              'PODIRINTEM', 'SHIPODSIT-')) THEN
         IF (inv_trans_rec_.transaction_code IN ('INVM-OUT', 'COMPM-OUT')) THEN
            order_related_move_ := FALSE;
         ELSE
            order_related_move_ := TRUE;
         END IF;
         connected_trans_id_  := Invent_Trans_Interconnect_API.Get_Connected_Transaction_Id(inv_trans_rec_.transaction_id,
                                                                                            'INTERSITE TRANSFER');
         connected_trans_rec_ := Get_Object_By_Keys___(connected_trans_id_);

         Intersite_Move_Revaluation___(inv_trans_rec_, connected_trans_rec_, order_related_move_,
                                       value_adjustment_, cascade_adjustment_, per_oh_adjustment_id_, periodic_weighted_avg_calc_, trans_reval_event_id_);
      END IF;
      
      IF (inv_trans_rec_.transaction_code IN ('SHIPDIR',    'SHIPTRAN',
                                              'CO-DELV-OU', 'DELCONF-OU',
                                              'OESHIP',     'CO-OESHIP',
                                              'INTPODIRIM', 'PODIRINTEM',
                                              'INTPODIRSH', 'PODIRSH',
                                              'EXCH-SHIP',  'CO-EX-SHIP',
                                              'CO-SHIPTRN', 'CO-SHIPDIR',
                                              'PURSHIP',    'CO-PURSHIP',
                                              'CRO-EXD-OU')) THEN
         Modify_Cust_Ord_Deliv_Cost___(inv_trans_rec_);
      END IF;

      IF (inv_trans_rec_.transaction_code IN ('SHIPTRAN', 'CO-SHIPTRN',
                                              'SHIPDIR',  'CO-SHIPDIR' )) THEN
         Intersite_Profit_Reval___(inv_trans_rec_, per_oh_adjustment_id_, periodic_weighted_avg_calc_);
      END IF;
   END IF;

   IF (inv_trans_rec_.transaction_code IN ('CONDCHG-', 'CONDCHGTR-', 'CO-CONDCH-', 'CONDCHGCU-',
                                           'CONDCHG+', 'CONDCHGTR+', 'CO-CONDCH+', 'CONDCHGCU+')) THEN
      Condition_Code_Change_Reval___(inv_trans_rec_, value_adjustment_, per_oh_adjustment_id_, trans_reval_event_id_, date_applied_);
   END IF;

   IF NOT value_adjustment_ THEN
      -- The booking was not caused by a value adjustment.
      -- Revaluations may be needed when bookings have been created for the transaction
      -- at the destination site.
      IF (inv_trans_rec_.transaction_code IN ('INVM-COIN', 'INVM-TRIN',
                                              'COMPM-IN',  'COMPM-TRIN',
                                              'INTORDTR',  'RINTORDTR', 'RINTORDTRX')) THEN
         IF (inv_trans_rec_.transaction_code IN ('INTORDTR', 'RINTORDTR', 'RINTORDTRX')) THEN
            order_related_move_ := TRUE;
         ELSE
            order_related_move_ := FALSE;
         END IF;
         connected_trans_id_  := Invent_Trans_Interconnect_API.Get_Connected_Transaction_Id(inv_trans_rec_.transaction_id,
                                                                                            'INTERSITE TRANSFER');
         connected_trans_rec_ := Get_Object_By_Keys___(connected_trans_id_);
         Intersite_Move_Revaluation___(connected_trans_rec_, inv_trans_rec_, order_related_move_,
                                       value_adjustment_, cascade_adjustment_, per_oh_adjustment_id_, periodic_weighted_avg_calc_, trans_reval_event_id_);
      END IF;
   END IF;

   IF NOT value_adjustment_ THEN
      -- This code cannot be executed when processing adjustments since
      -- the correct inventory part unit cost after the transaction cannot be retrieved
      -- in that case.
      IF (inv_trans_rec_.inventory_valuation_method IN ('AV', 'FIFO', 'LIFO')) THEN
         -- Retrieve the inventory value prior to the transaction
         pre_trans_cost_detail_tab_  := Pre_Invent_Trans_Avg_Cost_API.Get_Cost_Details(
                                                             inv_trans_rec_.transaction_id);
         IF (pre_trans_cost_detail_tab_.COUNT > 0) THEN
            -- Retrieve the inventory value after the transaction
            current_cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                                       inv_trans_rec_.contract,
                                                                       inv_trans_rec_.part_no,
                                                                       inv_trans_rec_.configuration_id,
                                                                       inv_trans_rec_.lot_batch_no,
                                                                       inv_trans_rec_.serial_no);
            Balance_Transit_And_Invent___(inv_trans_rec_,
                                          pre_trans_cost_detail_tab_,
                                          current_cost_detail_tab_,
                                          value_adjustment_     => FALSE,
                                          per_oh_adjustment_id_ => NULL,
                                          trans_reval_event_id_ => trans_reval_event_id_,
                                          date_applied_         => date_applied_);
         END IF;
      END IF;
   END IF;
   
   -- Create revaluation for supplier returns if needed
   IF (inv_trans_rec_.transaction_code IN ('RETWORK', 'RETCREDIT','SCPCREDIT', 'RETPODSINT')) THEN
   -- Added a condition not to call Revalue_Ret_Rework_Or_Cred___() when calculating PWA.
      IF NOT(periodic_weighted_avg_calc_) THEN
         Revalue_Ret_Rework_Or_Cred___(inv_trans_rec_,
                                       value_adjustment_,
                                       per_oh_adjustment_id_,
                                       trans_reval_event_id_,
                                       date_applied_);
      END IF;
   END IF;

   -- create revaluation for multi site return in same company
   IF ((inv_trans_rec_.transaction_code IN ('RETSHIPDIR', 'RETDIFSREC')) AND (inv_trans_rec_.inventory_valuation_method = 'ST')) THEN
      order_related_move_ := FALSE;
      connected_trans_id_  := Invent_Trans_Interconnect_API.Get_Connected_Transaction_Id(inv_trans_rec_.transaction_id, Invent_Trans_Conn_Reason_API.DB_INTERSITE_TRANSFER);
      
      connected_trans_rec_ := Get_Object_By_Keys___(connected_trans_id_);
      Intersite_Move_Revaluation___(connected_trans_rec_,
                                    inv_trans_rec_,
                                    order_related_move_,
                                    value_adjustment_,
                                    cascade_adjustment_,
                                    per_oh_adjustment_id_,
                                    periodic_weighted_avg_calc_,
                                    trans_reval_event_id_);
   END IF;

   -- Create revaluation postings if needed when a part id has been changes
   IF (inv_trans_rec_.transaction_code IN ('PARTREN-', 'PARTREN+')) THEN
      IF value_adjustment_ THEN
         -- When adjusting the value for an issue transaction related to a part id change
         -- value adjustments may be needed for the corresponding receipt transaction created
         -- for the new part
         IF (inv_trans_rec_.transaction_code = 'PARTREN-') THEN
            connected_trans_id_  := Invent_Trans_Interconnect_API.Get_Connected_Transaction_Id(inv_trans_rec_.transaction_id,
                                                                                               'RENAME SERIAL');
            connected_trans_rec_ := Get_Object_By_Keys___(connected_trans_id_);
            Part_Id_Change_Revaluation___(inv_trans_rec_, connected_trans_rec_, value_adjustment_,
                                          cascade_adjustment_, per_oh_adjustment_id_, trans_reval_event_id_, date_applied_);
         END IF;
      ELSE
         -- The booking was not caused by a value adjustment.
         -- Revaluations may be needed when bookings have been created for the renamed-to part.
         IF (inv_trans_rec_.transaction_code = 'PARTREN+') THEN
            connected_trans_id_  := Invent_Trans_Interconnect_API.Get_Connected_Transaction_Id(inv_trans_rec_.transaction_id,
                                                                                               'RENAME SERIAL');
            connected_trans_rec_ := Get_Object_By_Keys___(connected_trans_id_);
            Part_Id_Change_Revaluation___(connected_trans_rec_, inv_trans_rec_, value_adjustment_,
                                          cascade_adjustment_, per_oh_adjustment_id_, trans_reval_event_id_, date_applied_);
         END IF;
      END IF;
   END IF;
END Post_Booking_Actions___;


-- Intersite_Move_Revaluation___
--   Creates additional postings for intersite transactions when needed to
--   balance the m4/m88/m89 accounts when parts are moved between sites
PROCEDURE Intersite_Move_Revaluation___ (
   src_inv_trans_rec_          IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   dst_inv_trans_rec_          IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   order_related_move_         IN BOOLEAN,
   value_adjustment_           IN BOOLEAN,
   cascade_adjustment_         IN BOOLEAN,
   per_oh_adjustment_id_       IN NUMBER,
   periodic_weighted_avg_calc_ IN BOOLEAN,
   trans_reval_event_id_       IN NUMBER )
IS
   date_applied_              DATE;
   period_start_day_          DATE;
   first_viable_posting_date_ DATE;
   m89_value_                 NUMBER;
   m90_value_diff_            NUMBER;
   transaction_code_          VARCHAR2(10);
   m88_value_                 NUMBER;
   m88_curr_value_            NUMBER;
   src_m4_details_            Mpccom_Accounting_API.Value_Detail_Tab;
   dst_m4_details_            Mpccom_Accounting_API.Value_Detail_Tab;
   m4_pos_diff_details_       Mpccom_Accounting_API.Value_Detail_Tab;
   m4_neg_diff_details_       Mpccom_Accounting_API.Value_Detail_Tab;
   value_detail_tab_          Mpccom_Accounting_API.Value_Detail_Tab;
   src_company_               VARCHAR2(20);
   dst_company_               VARCHAR2(20);
   exit_procedure             EXCEPTION;
BEGIN

   src_company_ := Site_API.Get_Company(src_inv_trans_rec_.contract);
   dst_company_ := Site_API.Get_Company(dst_inv_trans_rec_.contract);

   IF (src_inv_trans_rec_.contract = dst_inv_trans_rec_.contract) THEN
      RAISE exit_procedure;
   END IF;

   IF (NOT value_adjustment_ AND NOT periodic_weighted_avg_calc_) THEN
      -- When the transaction is created for the first time a revaluation will
      -- be needed if a part has been transferred between two sites and and the valuation method on the
      -- receiving site is 'non-actual'.
      IF ((dst_inv_trans_rec_.inventory_valuation_method IN ('AV', 'FIFO', 'LIFO')) OR
          (dst_inv_trans_rec_.inventory_part_cost_level = 'COST PER SERIAL')) THEN
         RAISE exit_procedure;
      END IF;
   ELSE
      -- In this case we are adjusting the value of existing transactions either running the
      -- Periodic OH Adjustment process, Cascade Update process or Periodic Weighted Average calculation
      -- When running Periodic Weighted Average recalculation it does not matter what the valuation method
      -- on the receiving site is. In that case revaluation postings should always be booked on the 
      -- receiving transaction.
      -- For others note that it is the part cost level and valuation method at the time when the transaction was
      -- initially created that we need to check here.
      IF cascade_adjustment_ THEN
         -- Cascade update of transactions is being executed.
         -- IF moving parts between two sites within the same company we need revaluation postings
         -- for the cases when it will not be possible to proceed with the cascade update
         -- on the receiving site (all except Weighted Average or cost level Cost Per Serial).
         IF ((src_company_ = dst_company_) AND
             ((dst_inv_trans_rec_.inventory_valuation_method = 'AV') OR
              (dst_inv_trans_rec_.inventory_part_cost_level = 'COST PER SERIAL'))) THEN
            RAISE exit_procedure;
         END IF;         
      ELSIF value_adjustment_ THEN
         -- Periodic OH adjustments are being made.
         -- Only transactions in one company will be updated, so if we have two different
         -- companies or a 'non-actual' valuation method on the receiving site
         -- revaluation will be needed.
         IF ((src_company_ = dst_company_) AND
             ((dst_inv_trans_rec_.inventory_valuation_method IN ('AV', 'FIFO', 'LIFO')) OR
              (dst_inv_trans_rec_.inventory_part_cost_level = 'COST PER SERIAL'))) THEN
            RAISE exit_procedure;
         END IF;
      END IF;
   END IF;

   date_applied_ := TRUNC(Site_API.Get_Site_Date(dst_inv_trans_rec_.contract));

   -- When running the Periodic Weighted Average calculation create the additional postings on the 
   -- original date applied if possible.
   IF (periodic_weighted_avg_calc_) THEN
      period_start_day_ := Inventory_Transaction_Hist_API.Get_Last_Non_Updatable_Day(dst_inv_trans_rec_.contract);
      IF (dst_inv_trans_rec_.date_applied > period_start_day_) THEN
         -- The original date_applied can be used
         date_applied_ := dst_inv_trans_rec_.date_applied;
      END IF;
   END IF;

   IF (cascade_adjustment_) THEN
      first_viable_posting_date_ := Site_Invent_Info_API.Get_First_Viable_Posting_Date(dst_inv_trans_rec_.contract);
      date_applied_              := GREATEST(dst_inv_trans_rec_.date_applied, first_viable_posting_date_);
   END IF;

   -- The revaluation, if any, due to the move is booked here.
   IF (src_company_ = dst_company_) THEN
      -- Movement between sites within the same company.
      src_m4_details_ := Mpccom_Accounting_API.Get_Sum_Value_Details(src_inv_trans_rec_.accounting_id, 'M4');
      dst_m4_details_ := Mpccom_Accounting_API.Get_Sum_Value_Details(dst_inv_trans_rec_.accounting_id, 'M4');

      -- Postings on 'M4' will be created with an inverted sign on the receiving site
      -- compared to the sending site
      dst_m4_details_ := Mpccom_Accounting_API.Get_Sign_Shifted_Value_Tab(dst_m4_details_);

      Mpccom_Accounting_API.Create_Value_Diff_Tables(m4_pos_diff_details_,
                                                     m4_neg_diff_details_,
                                                     src_m4_details_,
                                                     dst_m4_details_);

      IF (m4_neg_diff_details_.COUNT > 0) THEN
         IF order_related_move_ THEN
            transaction_code_ := 'ORDTREVAL-';
         ELSE
            transaction_code_ := 'MOVEREVAL-';
         END IF;

         -- In this case new postings should be added, we are not trying to adjust
         -- existing values, so value_adjustment_ should be FALSE
         -- The date for the new postings still needs to be passed adjustment_date_.
         Do_Booking(dst_inv_trans_rec_.transaction_id, dst_company_,
                    transaction_code_, 'N',
                    m4_neg_diff_details_,
                    value_adjustment_        => FALSE,
                    adjustment_date_         => date_applied_,
                    per_oh_adjustment_id_    => per_oh_adjustment_id_,
                    do_post_booking_actions_ => FALSE,
                    trans_reval_event_id_    => trans_reval_event_id_);

      END IF;
      IF (m4_pos_diff_details_.COUNT > 0) THEN
         IF order_related_move_ THEN
            transaction_code_ := 'ORDTREVAL+';
         ELSE
            transaction_code_ := 'MOVEREVAL+';
         END IF;

         Do_Booking(dst_inv_trans_rec_.transaction_id, dst_company_,
                    transaction_code_, 'N',
                    m4_pos_diff_details_,
                    value_adjustment_        => FALSE,
                    adjustment_date_         => date_applied_,
                    per_oh_adjustment_id_    => per_oh_adjustment_id_,
                    do_post_booking_actions_ => FALSE,
                    trans_reval_event_id_    => trans_reval_event_id_);
      END IF;

   ELSE
      -- Movement between sites in different companies.
      m88_value_      := Mpccom_Accounting_API.Get_Sum_Value(src_inv_trans_rec_.accounting_id, 'M88');
      m88_curr_value_ := Site_API.Get_Currency_Converted_Amount(src_inv_trans_rec_.contract,
                                                                dst_inv_trans_rec_.contract,
                                                                m88_value_);
      m89_value_      := Mpccom_Accounting_API.Get_Sum_Value(dst_inv_trans_rec_.accounting_id, 'M89');
      m90_value_diff_ := m88_curr_value_ + m89_value_;

      IF (m90_value_diff_ != 0) THEN
         IF (m90_value_diff_ < 0) THEN
            transaction_code_ := 'COMPMDIFF+';
         ELSE
            transaction_code_ := 'COMPMDIFF-';
         END IF;

         value_detail_tab_(1).bucket_posting_group_id := NULL;
         value_detail_tab_(1).cost_source_id          := NULL;
         value_detail_tab_(1).value                   := ABS(m90_value_diff_);

         -- In this case set per_oh_adjustment_id to NULL as the updated posting
         -- is in another company.
         Do_Booking(dst_inv_trans_rec_.transaction_id, dst_company_,
                    transaction_code_, 'N',
                    value_detail_tab_,
                    value_adjustment_        => FALSE,
                    adjustment_date_         => date_applied_,
                    per_oh_adjustment_id_    => NULL,
                    do_post_booking_actions_ => FALSE,
                    trans_reval_event_id_    => trans_reval_event_id_);
      END IF;
   END IF;
EXCEPTION
   WHEN exit_procedure THEN
      NULL;
END Intersite_Move_Revaluation___;


-- Part_Id_Change_Revaluation___
--   Creates additional postings needed to balance the m1/m191 accounts
--   when a part id has been changed for a part in inventory
PROCEDURE Part_Id_Change_Revaluation___ (
   src_inv_trans_rec_    IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   dst_inv_trans_rec_    IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   value_adjustment_     IN BOOLEAN,
   cascade_adjustment_   IN BOOLEAN,
   per_oh_adjustment_id_ IN NUMBER,
   trans_reval_event_id_ IN NUMBER,
   date_applied_         IN DATE )
IS
   transaction_code_      VARCHAR2(10);
   src_m191_details_      Mpccom_Accounting_API.Value_Detail_Tab;
   dst_m191_details_      Mpccom_Accounting_API.Value_Detail_Tab;
   m191_pos_diff_details_ Mpccom_Accounting_API.Value_Detail_Tab;
   m191_neg_diff_details_ Mpccom_Accounting_API.Value_Detail_Tab;
   dst_company_           VARCHAR2(20);
   exit_procedure         EXCEPTION;
BEGIN

   dst_company_ := Site_API.Get_Company(dst_inv_trans_rec_.contract);

   IF (NOT value_adjustment_) THEN
      -- When the transaction is created for the first time a revaluation will
      -- be needed if the renamed-to part has a 'non-actual' valuation method.
      IF ((dst_inv_trans_rec_.inventory_valuation_method IN ('AV', 'FIFO', 'LIFO')) OR
          (dst_inv_trans_rec_.inventory_part_cost_level = 'COST PER SERIAL')) THEN
         RAISE exit_procedure;
      END IF;
   ELSE
      -- In this case we are adjusting the value of existing transactions either running the
      -- Periodic OH Adjustment process or a Cascade Update process.
      IF cascade_adjustment_ THEN
         -- Cascade update of transactions is being executed.
         -- We need revaluation postings for the cases when it will not be possible to proceed with
         -- the cascade update for the renamed-to part
         -- (all except Weighted Average or cost level Cost Per Serial).
         IF ((dst_inv_trans_rec_.inventory_valuation_method = 'AV') OR
             (dst_inv_trans_rec_.inventory_part_cost_level = 'COST PER SERIAL')) THEN
            RAISE exit_procedure;
         END IF;
      ELSE
         -- Periodic OH adjustments are being made.
         -- IF we have a 'non-actual' valuation method setup for the renamed-to part
         -- revaluation will be needed.
         IF ((dst_inv_trans_rec_.inventory_valuation_method IN ('AV', 'FIFO', 'LIFO')) OR
             (dst_inv_trans_rec_.inventory_part_cost_level = 'COST PER SERIAL')) THEN
            RAISE exit_procedure;
         END IF;
      END IF;
   END IF;

   -- The revaluation, if any, due to the part id change is booked here.
   src_m191_details_ := Mpccom_Accounting_API.Get_Sum_Value_Details(src_inv_trans_rec_.accounting_id, 'M191');
   dst_m191_details_ := Mpccom_Accounting_API.Get_Sum_Value_Details(dst_inv_trans_rec_.accounting_id, 'M191');

   -- Postings on 'M191' will be created with an inverted sign for the PARTREN+ transaction compared
   -- to the PARTREN- transaction
   dst_m191_details_ := Mpccom_Accounting_API.Get_Sign_Shifted_Value_Tab(dst_m191_details_);

   Mpccom_Accounting_API.Create_Value_Diff_Tables(m191_pos_diff_details_,
                                                  m191_neg_diff_details_,
                                                  src_m191_details_,
                                                  dst_m191_details_);

   IF (m191_neg_diff_details_.COUNT > 0) THEN
      transaction_code_ := 'PRENREVAL-';

      -- In this case new postings should be added, we are not trying to adjust
      -- existing values, so value_adjustment_ should be FALSE
      -- The date for the new postings still needs to be passed adjustment_date_.
      Do_Booking(dst_inv_trans_rec_.transaction_id, dst_company_,
                 transaction_code_, 'N',
                 m191_neg_diff_details_,
                 value_adjustment_        => FALSE,
                 adjustment_date_         => date_applied_,
                 per_oh_adjustment_id_    => per_oh_adjustment_id_,
                 do_post_booking_actions_ => FALSE,
                 trans_reval_event_id_    => trans_reval_event_id_);
   END IF;
   IF (m191_pos_diff_details_.COUNT > 0) THEN
      transaction_code_ := 'PRENREVAL+';

      Do_Booking(dst_inv_trans_rec_.transaction_id, dst_company_,
                 transaction_code_, 'N',
                 m191_pos_diff_details_,
                 value_adjustment_        => FALSE,
                 adjustment_date_         => date_applied_,
                 per_oh_adjustment_id_    => per_oh_adjustment_id_,
                 do_post_booking_actions_ => FALSE,
                 trans_reval_event_id_    => trans_reval_event_id_);
   END IF;
EXCEPTION
   WHEN exit_procedure THEN
      NULL;
END Part_Id_Change_Revaluation___;


-- Modify_Cust_Ord_Deliv_Cost___
--   Modify the cost of delivery for a customer order when the cost of a
--   transaction related to a customer order delivery has been updated
PROCEDURE Modify_Cust_Ord_Deliv_Cost___ (
   inv_trans_rec_ IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE )
IS
   stmt_ VARCHAR2(2000);
BEGIN
   -- The keys for the customer order connected to the delivery transaction can
   -- be found either in order_no, release_no, sequence_no, line_item_no or in
   -- alt_source_ref1 .. 4 depending on the type of transaction.
   stmt_ := 'BEGIN
                Deliver_Customer_Order_API.Modify_Cost_Of_Delivery(:source_ref1,
                                                                   :source_ref2,
                                                                   :source_ref3,
                                                                   :source_ref4,
                                                                   :transaction_code);
             END;';
   IF (inv_trans_rec_.source_ref_type = 'CUST ORDER') THEN
      @ApproveDynamicStatement(2006-03-20,JoAnSe)
      EXECUTE IMMEDIATE stmt_ USING IN inv_trans_rec_.source_ref1,
                                    IN inv_trans_rec_.source_ref2,
                                    IN inv_trans_rec_.source_ref3,
                                    IN inv_trans_rec_.source_ref4,
                                    IN inv_trans_rec_.transaction_code;
   ELSIF (inv_trans_rec_.alt_source_ref_type = 'CUST ORDER') THEN
      @ApproveDynamicStatement(2006-03-20,JoAnSe)
      EXECUTE IMMEDIATE stmt_ USING IN inv_trans_rec_.alt_source_ref1,
                                    IN inv_trans_rec_.alt_source_ref2,
                                    IN inv_trans_rec_.alt_source_ref3,
                                    IN inv_trans_rec_.alt_source_ref4,
                                    IN inv_trans_rec_.transaction_code;
   END IF;
END Modify_Cust_Ord_Deliv_Cost___;


-- Intersite_Profit_Reval___
--   Revaluation of intersite profitability transactions when the cost of
--   the delivery transaction has been updated.
PROCEDURE Intersite_Profit_Reval___ (
   inv_trans_rec_              IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   per_oh_adjustment_id_       IN NUMBER,
   periodic_weighted_avg_calc_ IN BOOLEAN )
IS
   new_trans_cost_            NUMBER;
   new_trans_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   connected_trans_id_        NUMBER;
   dst_connected_trans_id_    NUMBER;
   dst_trans_rec_             INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   company_                   VARCHAR2(20);
   empty_value_detail_tab_    Mpccom_Accounting_API.Value_Detail_Tab;
   date_applied_              INVENTORY_TRANSACTION_HIST_TAB.date_applied%TYPE;   
   period_start_day_          DATE;
BEGIN

   company_        := Site_API.Get_Company(inv_trans_rec_.contract);
   new_trans_cost_ := Get_Cost(inv_trans_rec_.transaction_id);

   new_trans_cost_detail_tab_(1).accounting_year := '*';
   new_trans_cost_detail_tab_(1).contract        := inv_trans_rec_.contract;
   new_trans_cost_detail_tab_(1).cost_bucket_id  := '*';
   new_trans_cost_detail_tab_(1).company         := company_;
   new_trans_cost_detail_tab_(1).cost_source_id  := '*';
   new_trans_cost_detail_tab_(1).unit_cost       := new_trans_cost_;

   -- Find the connected INTCOS transaction if any
   connected_trans_id_ := Invent_Trans_Interconnect_API.Get_Connected_Transaction_Id(inv_trans_rec_.transaction_id, 'INTERSITE COST');

   -- Find the connected INTCOSR transaction if any
   dst_connected_trans_id_ := Invent_Trans_Interconnect_API.Get_Connected_Transaction_Id(connected_trans_id_, 'INTERSITE COST REC');

   date_applied_ := TRUNC(Site_API.Get_Site_Date(inv_trans_rec_.contract));

   IF (dst_connected_trans_id_ IS NOT NULL) THEN
      dst_trans_rec_ := Get_Object_By_Keys___(dst_connected_trans_id_);
   
      -- When running the Periodic Weighted Average calculation create the additional postings on the 
      -- original date applied if possible.
      IF (periodic_weighted_avg_calc_) THEN
         period_start_day_ := Inventory_Transaction_Hist_API.Get_Last_Non_Updatable_Day(dst_trans_rec_.contract);
         IF (dst_trans_rec_.date_applied > period_start_day_) THEN
            -- The original date_applied can be used
            date_applied_ := dst_trans_rec_.date_applied;
         END IF;
      END IF;
   END IF;

   IF (connected_trans_id_ IS NOT NULL) THEN
      Set_Cost(connected_trans_id_, new_trans_cost_detail_tab_);
      
      Do_Booking(connected_trans_id_,
                 company_,
                 event_code_              => NULL,
                 complete_flag_           => 'N',
                 external_value_tab_      => empty_value_detail_tab_,
                 value_adjustment_        => TRUE,
                 adjustment_date_         => date_applied_,
                 per_oh_adjustment_id_    => per_oh_adjustment_id_,
                 do_post_booking_actions_ => FALSE);
   END IF;

   IF (dst_connected_trans_id_ IS NOT NULL) THEN
      -- Only the site in the cost details needs to be changed
      new_trans_cost_detail_tab_(1).contract := dst_trans_rec_.contract;

      -- Unit cost needs to be converted.
      new_trans_cost_detail_tab_(1).unit_cost := ((new_trans_cost_detail_tab_(1).unit_cost * inv_trans_rec_.quantity) / dst_trans_rec_.quantity);         
      
      Set_Cost(dst_connected_trans_id_, new_trans_cost_detail_tab_);

      Do_Booking(dst_connected_trans_id_,
                 company_,
                 event_code_              => NULL,
                 complete_flag_           => 'N',
                 external_value_tab_      => empty_value_detail_tab_,
                 value_adjustment_        => TRUE,
                 adjustment_date_         => date_applied_,
                 per_oh_adjustment_id_    => per_oh_adjustment_id_,
                 do_post_booking_actions_ => FALSE);
   END IF;
END Intersite_Profit_Reval___;


PROCEDURE Condition_Code_Change_Reval___ (
   inv_trans_rec_        IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   value_adjustment_     IN BOOLEAN,
   per_oh_adjustment_id_ IN NUMBER,
   trans_reval_event_id_ IN NUMBER,
   date_applied_         IN DATE )
IS
   connected_transaction_id_   INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;
   connected_trans_rec_        INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   issue_trans_rec_            INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   receipt_trans_rec_          INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   issue_m178_details_         Mpccom_Accounting_API.Value_Detail_Tab;
   receipt_m178_details_       Mpccom_Accounting_API.Value_Detail_Tab;
   m178_pos_diff_details_      Mpccom_Accounting_API.Value_Detail_Tab;
   m178_neg_diff_details_      Mpccom_Accounting_API.Value_Detail_Tab;
   receipt_transaction_        BOOLEAN := FALSE;
   supplier_consignment_stock_ BOOLEAN := FALSE;
   exit_procedure_             EXCEPTION;
   event_code_                 VARCHAR2(10);
BEGIN

   IF (inv_trans_rec_.inventory_part_cost_level != 'COST PER CONDITION') THEN
      RAISE exit_procedure_;
   END IF;
   IF (inv_trans_rec_.transaction_code IN ('CONDCHG+', 'CONDCHGTR+', 'CO-CONDCH+', 'CONDCHGCU+')) THEN
      receipt_transaction_ := TRUE;
   END IF;

   IF NOT (value_adjustment_) THEN
      IF NOT (receipt_transaction_) THEN
         RAISE exit_procedure_;
      END IF;
   END IF;

   IF (inv_trans_rec_.transaction_code IN ('CO-CONDCH-', 'CO-CONDCH+')) THEN
      supplier_consignment_stock_ := TRUE;
   END IF;

   connected_transaction_id_ := Invent_Trans_Interconnect_API.Get_Connected_Transaction_Id(
                                                                     inv_trans_rec_.transaction_id,
                                                                     'CONDITION CODE CHANGE');
   connected_trans_rec_      := Get_Object_By_Keys___(connected_transaction_id_);

   IF (receipt_transaction_) THEN
      issue_trans_rec_   := connected_trans_rec_;
      receipt_trans_rec_ := inv_trans_rec_;
   ELSE
      receipt_trans_rec_ := connected_trans_rec_;
      issue_trans_rec_   := inv_trans_rec_;
   END IF;

   issue_m178_details_   := Mpccom_Accounting_API.Get_Sum_Value_Details(
                                                              issue_trans_rec_.accounting_id,
                                                              'M178');
   receipt_m178_details_ := Mpccom_Accounting_API.Get_Sum_Value_Details(
                                                              receipt_trans_rec_.accounting_id,
                                                              'M178');
   receipt_m178_details_ := Mpccom_Accounting_API.Get_Sign_Shifted_Value_Tab(
                                                              receipt_m178_details_);

   Mpccom_Accounting_API.Create_Value_Diff_Tables(m178_pos_diff_details_,
                                                  m178_neg_diff_details_,
                                                  issue_m178_details_,
                                                  receipt_m178_details_);

   IF (m178_neg_diff_details_.COUNT > 0) THEN

      IF (supplier_consignment_stock_) THEN
         event_code_ := 'CO-CCREV-';
      ELSE
         event_code_ := 'CONDREVAL-';
      END IF;

      Do_Booking(transaction_id_          => receipt_trans_rec_.transaction_id,
                 company_                 => NULL,
                 event_code_              => event_code_,
                 complete_flag_           => 'N',
                 external_value_tab_      => m178_neg_diff_details_,
                 value_adjustment_        => FALSE,
                 adjustment_date_         => date_applied_,
                 per_oh_adjustment_id_    => per_oh_adjustment_id_,
                 do_post_booking_actions_ => FALSE,
                 trans_reval_event_id_    => trans_reval_event_id_);
   END IF;

   IF (m178_pos_diff_details_.COUNT > 0) THEN

      IF (supplier_consignment_stock_) THEN
         event_code_ := 'CO-CCREV+';
      ELSE
         event_code_ := 'CONDREVAL+';
      END IF;

      Do_Booking(transaction_id_          => receipt_trans_rec_.transaction_id,
                 company_                 => NULL,
                 event_code_              => event_code_,
                 complete_flag_           => 'N',
                 external_value_tab_      => m178_pos_diff_details_,
                 value_adjustment_        => FALSE,
                 adjustment_date_         => date_applied_,
                 per_oh_adjustment_id_    => per_oh_adjustment_id_,
                 do_post_booking_actions_ => FALSE,
                 trans_reval_event_id_    => trans_reval_event_id_);
   END IF;

EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Condition_Code_Change_Reval___;


-- Map_Receipt_Direct_Ship___
--   Checks if a transaction code is for direct ship on customer order or
--   receipt for MAP localized transactions.
FUNCTION Map_Receipt_Direct_Ship___ (
   transaction_code_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   map_receipt_direct_ship_ BOOLEAN := FALSE;
BEGIN
--In order to allow matching of MAP supplier invoices after the upgrade to App7 we have included the
--MAP localized transactions here. These transactions are only present in 2001-3 MAP.
--These transactions can be removed after a period of time when one is sure that the purchase
--receipts are only created using the App7 functionality.
   IF (transaction_code_ IN ('J-ARRIVAL','JP-ARRIVAL','J-PODIRSH','JP-PODIRSH','JS-PODIRSH')) THEN
       map_receipt_direct_ship_ := TRUE;
   END IF;
   RETURN (map_receipt_direct_ship_);
END Map_Receipt_Direct_Ship___;


-- Map_Receipt_Move_To_Inv___
--   Checks if a transaction code is a MAP localized transactions.
--   This is a specific move into inventory transaction.
FUNCTION Map_Receipt_Move_To_Inv___ (
   transaction_code_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   map_receipt_move_to_inv_ BOOLEAN := FALSE;
BEGIN
--In order to allow matching of MAP supplier invoices after the upgrade to App7 we have included the
--MAP localized transactions here. These transactions are only present in 2001-3 MAP.
--These transactions can be removed after a period of time when one is sure that the purchase
--receipts are only created using the App7 functionality.
--The qty and cost will be fetched from the J-ARRIVAL transaction. Only the price diff needs to be
-- fetched from the JM-INVM-IN transaction.
   IF (transaction_code_ IN ('JM-INVM-IN')) THEN
       map_receipt_move_to_inv_ := TRUE;
   END IF;
   RETURN (map_receipt_move_to_inv_);
END Map_Receipt_Move_To_Inv___;


-- Set_Reject_Code___
--   This method updates the reject code after a new, undo scrap transaction.
PROCEDURE Set_Reject_Code___ (
   transaction_id_ IN NUMBER,
   reject_code_    IN VARCHAR2 )
IS
   record_ inventory_transaction_hist_tab%ROWTYPE;
BEGIN
   record_             := Lock_By_Keys___(transaction_id_);
   record_.reject_code := reject_code_;
   Modify___(record_);
END Set_Reject_Code___;


-----------------------------------------------------------------------------------------------------
-- Set_Original_Amount___
--    Set the original amount of arrival transactions for periodic weighted averages parts.
-----------------------------------------------------------------------------------------------------
PROCEDURE Set_Original_Amount___ (
   trans_rec_ IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE )
IS
   exit_procedure_         EXCEPTION;
   trans_value_detail_tab_ Mpccom_Accounting_API.Value_Detail_Tab;
   use_this_transaction_   BOOLEAN;
   from_alt_source_        BOOLEAN := FALSE;
   original_amount_        INVENTORY_TRANSACTION_HIST_TAB.original_amount%TYPE;
   record_                 INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   
   dummy_curr_amount_detail_tab_    Mpccom_Accounting_API.Curr_Amount_Detail_Tab;           
   dummy_number_                    NUMBER;
BEGIN
   IF (trans_rec_.inventory_valuation_method != Inventory_Value_Method_API.DB_STANDARD_COST) THEN
      -- Only valid for standard cost parts
      RAISE exit_procedure_;
   END IF;

   IF (trans_rec_.original_amount IS NOT NULL) THEN
      -- If an amount is already set then we should leave it untouched. This method might
      -- have been called during an update of the cost of a transaction, and then we should
      -- not touch the original amounts.
      RAISE exit_procedure_;
   END IF;

   IF (Inventory_Part_API.Get_Invoice_Consideration_Db(trans_rec_.contract, trans_rec_.part_no) !=
       Invoice_Consideration_API.DB_PERIODIC_WEIGHTED_AVERAGE) THEN
      -- Only needed for supporting invoice matching when using Periodic Weighted Average
      RAISE exit_procedure_;
   END IF;

   IF ((trans_rec_.source_ref1 IS NULL) AND (trans_rec_.alt_source_ref1 IS NOT NULL)) THEN
      from_alt_source_ := TRUE;
   END IF;

   -- We go directly on to the method call below since this method will not do any additional
   -- database reads unless the transaction code is indicating that this is some sort of arrival
   -- transaction. So this has no negative performance impact for other transactions.
   Get_Arrival_Trans_Amounts___(trans_value_detail_tab_,
                                dummy_curr_amount_detail_tab_,
                                use_this_transaction_,                                
                                dummy_number_,
                                from_alt_source_,
                                to_date_                     => NULL,
                                use_original_amount_for_pwa_ => FALSE,
                                trans_rec_ => trans_rec_,
                                fetch_curr_amount_details_  => FALSE,
                                use_only_m10_postings_ => FALSE);

   IF (use_this_transaction_) THEN
      -- This is an arrival transaction of some kind (see inside Get_Arrival_Trans_Amounts___
      -- for details on how this has been determined).
      IF (trans_value_detail_tab_.COUNT = 0) THEN
         -- If the cost on the transaction was zero then the collection will be empty. But for us to
         -- indicate that we have an original cost which is zero then we enter a zero amount record
         -- into the new table.
         original_amount_  := 0;
      ELSE
         -- Since Get_Arrival_Trans_Amounts___ searches for Credit postings the resulting amounts will be negative.
         trans_value_detail_tab_ := Mpccom_Accounting_API.Get_Sign_Shifted_Value_Tab(trans_value_detail_tab_);
         original_amount_        := Mpccom_Accounting_API.Get_Total_Value(trans_value_detail_tab_);
      END IF;

      -- Set the original amount for a given transaction.
      record_ := Lock_By_Keys___(trans_rec_.transaction_id);
      record_.original_amount := original_amount_;
      Modify___(record_);
   END IF;

EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Set_Original_Amount___;


-- Get_Pur_Order_Charge_Cost___
--   This methods determines if receipt transactions needs to be splitted to
--   reflect charge value.
FUNCTION Get_Pur_Order_Charge_Cost___ (
   inv_trans_rec_ IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   event_code_    IN VARCHAR2 ) RETURN NUMBER
IS
   po_receipt_charge_price_ NUMBER := 0;
   inv_part_rec_            Inventory_Part_API.Public_Rec;
   split_arrival_postings_  BOOLEAN := FALSE;
   include_service_cost_    BOOLEAN := FALSE;
   order_no_                VARCHAR2(50);
   line_no_                 VARCHAR2(50);
   release_no_              VARCHAR2(50);
   receipt_no_              VARCHAR2(50);
   first_receipt_in_lot_    BOOLEAN := FALSE;
   qty_onhand_              NUMBER := 0;
   qty_in_transit_          NUMBER := 0;
   po_receipt_charge_cost_  NUMBER := 0;
   accounting_id_tab_       Mpccom_Accounting_API.Accounting_Id_Tab;
BEGIN
   inv_part_rec_ :=  Inventory_Part_API.Get(inv_trans_rec_.contract, inv_trans_rec_.part_no);

   IF (inv_part_rec_.inventory_valuation_method = 'ST') AND
      (inv_part_rec_.inventory_part_cost_level = 'COST PER LOT BATCH') THEN

      -- Check how many records there are in inventory_transaction_hist_tab for the record currently about to create postings for
      accounting_id_tab_ := Get_Accounting_Id_Tab___(inv_trans_rec_.source_ref1,
                                                     inv_trans_rec_.source_ref2,
                                                     inv_trans_rec_.source_ref3,
                                                     inv_trans_rec_.source_ref4,
                                                     inv_trans_rec_.source_ref_type,
                                                     inv_trans_rec_.alt_source_ref1,
                                                     inv_trans_rec_.alt_source_ref2,
                                                     inv_trans_rec_.alt_source_ref3,
                                                     inv_trans_rec_.alt_source_ref4,
                                                     inv_trans_rec_.alt_source_ref_type,
                                                     inv_trans_rec_.transaction_code );

      IF (accounting_id_tab_.COUNT = 1) THEN
         -- this is the first inventory transaction for this receipt
         Inventory_Part_In_Stock_API.Get_Company_Owned_Inventory(qty_onhand_         => qty_onhand_,                                                            
                                                                    qty_in_transit_     => qty_in_transit_,
                                                                    contract_           => inv_trans_rec_.contract,
                                                                    part_no_            => inv_trans_rec_.part_no,
                                                                    configuration_id_   => inv_trans_rec_.configuration_id,
                                                                    lot_batch_no_       => inv_trans_rec_.lot_batch_no);         

         IF (inv_trans_rec_.transaction_code IN ('PODIRSH', 'PODIRINTEM')) THEN
            IF ((qty_onhand_ + qty_in_transit_) = 0) THEN
               first_receipt_in_lot_ := TRUE;
            END IF;
         ELSE
            IF ((qty_onhand_ + qty_in_transit_) = inv_trans_rec_.quantity) THEN
               first_receipt_in_lot_ := TRUE;
            END IF;
         END IF;
      ELSE
         -- there is more than one inventory transaction history record for this specific PO receipt
         IF (accounting_id_tab_.COUNT > 0) THEN
            FOR i IN accounting_id_tab_.FIRST..accounting_id_tab_.LAST LOOP
               IF (Mpccom_Accounting_API.Check_Accounting_Exist(accounting_id_tab_(i), 'M189', NULL)) THEN
                  -- Copy the charge value from the preceding transaction to this transaction
                  po_receipt_charge_cost_ := ABS(Mpccom_Accounting_API.Get_Sum_Value(accounting_id_tab_(i), 'M189'));
                  EXIT;
               END IF;
            END LOOP;
         END IF;
      END IF;
   END IF;

   -- fetch the Order refernce of the Purchase Order
   IF (event_code_ IN ('PODIRSH', 'PODIRINTEM', 'PURDIR')) THEN
      order_no_   := inv_trans_rec_.alt_source_ref1;
      line_no_    := inv_trans_rec_.alt_source_ref2;
      release_no_ := inv_trans_rec_.alt_source_ref3;
      receipt_no_ := inv_trans_rec_.alt_source_ref4;
   ELSE
      order_no_   := inv_trans_rec_.source_ref1;
      line_no_    := inv_trans_rec_.source_ref2;
      release_no_ := inv_trans_rec_.source_ref3;
      receipt_no_ := inv_trans_rec_.source_ref4;
   END IF;

   IF (inv_part_rec_.ext_service_cost_method = 'INCLUDE SERVICE COST' AND event_code_ = 'ARR-REPAIR') THEN
      include_service_cost_ := TRUE;
   END IF;

   IF (include_service_cost_ OR (event_code_ IN ('ARRIVAL', 'PODIRSH','PODIRINTEM', 'PURDIR'))) THEN
      split_arrival_postings_ := TRUE;
   END IF;

   -- fetch PO charge value to be posted on M189
   IF split_arrival_postings_ THEN
      IF (inv_part_rec_.inventory_valuation_method IN ('AV','FIFO', 'LIFO')) OR
         ((inv_part_rec_.inventory_valuation_method = 'ST') AND
         (first_receipt_in_lot_ OR inv_part_rec_.inventory_part_cost_level = 'COST PER SERIAL')) THEN

         $IF Component_Purch_SYS.INSTALLED $THEN
            po_receipt_charge_price_ := Purchase_Receipt_Charge_API.Get_Charge_For_Inventory_Trans(order_no_,
                                                                                                   line_no_,
                                                                                                   release_no_,
                                                                                                   receipt_no_,
                                                                                                   inv_trans_rec_.quantity);                     
            po_receipt_charge_cost_ := po_receipt_charge_price_ * inv_trans_rec_.quantity;              
         $ELSE
            Error_SYS.Component_Not_Exist('PURCH');    
         $END
      END IF;
   END IF;

   RETURN NVL(po_receipt_charge_cost_, 0);
END Get_Pur_Order_Charge_Cost___;


FUNCTION Get_Sales_Overhead_Details___ (
   tran_hist_rec_      IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   inventory_part_rec_ IN Inventory_Part_API.Public_Rec,
   company_            IN VARCHAR2,
   unit_cost_          IN NUMBER ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   cost_detail_tab_   Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   event_rec_         Accounting_Event_API.Public_Rec;
   net_weight_        NUMBER;
   order_qty_         NUMBER;
BEGIN
   $IF ((Component_Cost_SYS.INSTALLED) AND (Component_Order_SYS.INSTALLED)) $THEN 
      event_rec_ := Accounting_Event_API.Get(tran_hist_rec_.transaction_code);

      IF (event_rec_.sales_overhead_flag = true_) THEN
         -- The value returned to net_weight_ from below method is Part catalog's net weight.
         -- Under IID DI011 the net weight of inventory part gets moved to the part calalog level.
         net_weight_ := Inventory_Part_API.Get_Weight_Net(tran_hist_rec_.contract,tran_hist_rec_.part_no);
         order_qty_ := Customer_Order_Line_API.Get_Revised_Qty_Due(tran_hist_rec_.source_ref1, tran_hist_rec_.source_ref2, tran_hist_rec_.source_ref3, tran_hist_rec_.source_ref4);
         Standard_Cost_Bucket_API.Get_Sales_Overhead_Cost(cost_detail_tab_,
                                                          tran_hist_rec_.contract,
                                                          tran_hist_rec_.part_no,
                                                          unit_cost_,
                                                          order_qty_,
                                                          net_weight_);

         Inventory_Part_Unit_Cost_API.Fill_Temporary_Table__(cost_detail_tab_);
         
         cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_From_Temporary_Table__;

         cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Merge_And_Complete_Details(cost_detail_tab_,
                                                                                     inventory_part_rec_,
                                                                                     tran_hist_rec_.contract,
                                                                                     tran_hist_rec_.part_no,
                                                                                     company_,
                                                                                     '*',
                                                                                     tran_hist_rec_.source_ref1,
                                                                                     tran_hist_rec_.source_ref2,
                                                                                     tran_hist_rec_.source_ref3,
                                                                                     tran_hist_rec_.source_ref4,
                                                                                     tran_hist_rec_.source_ref_type,
                                                                                     trunc(tran_hist_rec_.date_created));
                                                               
      END IF;           
   $END
   
   RETURN cost_detail_tab_;
   END Get_Sales_Overhead_Details___;
   


-- Create_Stage_Pay_Postings___
--   Create additional postings for the approval of the last stage payment.
PROCEDURE Create_Stage_Pay_Postings___ (
   company_                    IN VARCHAR2,
   tran_hist_rec_              IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   date_applied_               IN DATE,
   value_adjustment_           IN BOOLEAN,
   per_oh_adjustment_id_       IN NUMBER,
   control_type_key_rec_       IN Mpccom_Accounting_API.Control_Type_Key,
   trans_reval_event_id_       IN NUMBER,
   base_curr_code_             IN VARCHAR2,
   base_curr_rate_             IN NUMBER,
   base_curr_conv_factor_      IN NUMBER,
   base_curr_rate_is_inverted_ IN VARCHAR2 )
IS
   receipt_cost_                  NUMBER := 0;
   dummy_                         VARCHAR2(80);
   receipt_value_                 NUMBER := 0;
   receipt_qty_                   NUMBER := 0;
   m197_value_diff_               NUMBER := 0;
   m14_value_diff_                NUMBER := 0;
   price_diff_event_code_         VARCHAR2(10);
   last_stage_payment_            VARCHAR2(10);
   order_code_                    VARCHAR2(3);
   exit_procedure_                EXCEPTION;
   wip_value_                     NUMBER;
   consumed_total_comp_value_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   curr_amount_detail_tab_        Mpccom_Accounting_API.Curr_Amount_Detail_Tab;
   dummy_number_                  NUMBER;
   trans_curr_code_               VARCHAR2(3);
   trans_curr_rate_               NUMBER;
   trans_curr_conv_factor_        NUMBER;
   trans_curr_rounding_           NUMBER;
   trans_curr_amount_             NUMBER;
   curr_rate_rounding_factor_     NUMBER;
   m14_curr_amt_detail_tab_       Mpccom_Accounting_API.Curr_Amount_Detail_Tab;
   currency_code_rec_             Currency_Code_API.Public_Rec;   
BEGIN

   $IF Component_Purch_SYS.INSTALLED $THEN
      last_stage_payment_ := Purchase_Order_Milestone_API.Get_Last_Stage_Payment_Db(tran_hist_rec_.source_ref1,
                                                                                    tran_hist_rec_.source_ref2,
                                                                                    tran_hist_rec_.source_ref3,
                                                                                    tran_hist_rec_.source_ref4);   
   $ELSE
      RAISE exit_procedure_;    
   $END   
               
   IF (last_stage_payment_ = false_) THEN
      RAISE exit_procedure_;
   END IF;

   $IF Component_Purch_SYS.INSTALLED $THEN
      order_code_ :=  Purchase_Order_Line_Part_API.Get_Order_Code(tran_hist_rec_.source_ref1, 
                                                                  tran_hist_rec_.source_ref2,  
                                                                  tran_hist_rec_.source_ref3); 
   $END

   IF (order_code_ = '2') THEN
      Get_Arrival_Cost_Value_Qty___(curr_amount_detail_tab_        => curr_amount_detail_tab_,
                                    cost_                          => receipt_cost_,
                                    value_                         => receipt_value_,
                                    qty_                           => receipt_qty_,
                                    price_diff_                    => dummy_number_,                                       
                                    source_ref1_                   => NULL,
                                    source_ref2_                   => NULL,
                                    source_ref3_                   => NULL,
                                    source_ref4_                   => NULL,
                                    alt_source_ref1_               => tran_hist_rec_.source_ref1,
                                    alt_source_ref2_               => tran_hist_rec_.source_ref2,
                                    alt_source_ref3_               => tran_hist_rec_.source_ref3,
                                    alt_source_ref4_               => NULL,
                                    to_date_                       => TO_DATE(NULL),
                                    include_reversed_transactions_ => FALSE,
                                    serial_no_                     => NULL,
                                    use_original_amounts_for_pwa_  => FALSE,
                                    fetch_curr_amount_details_     => TRUE,
                                    use_only_m10_postings_         => FALSE);
   ELSE
      Get_Arrival_Cost_Value_Qty___(curr_amount_detail_tab_        => curr_amount_detail_tab_,
                                    cost_                          => receipt_cost_,
                                    value_                         => receipt_value_,
                                    qty_                           => receipt_qty_,
                                    price_diff_                    => dummy_number_,                                       
                                    source_ref1_                   => tran_hist_rec_.source_ref1,
                                    source_ref2_                   => tran_hist_rec_.source_ref2,
                                    source_ref3_                   => tran_hist_rec_.source_ref3,
                                    source_ref4_                   => NULL,
                                    alt_source_ref1_               => NULL,
                                    alt_source_ref2_               => NULL,
                                    alt_source_ref3_               => NULL,
                                    alt_source_ref4_               => NULL,
                                    to_date_                       => TO_DATE(NULL),
                                    include_reversed_transactions_ => FALSE,
                                    serial_no_                     => NULL,
                                    use_original_amounts_for_pwa_  => FALSE,
                                    fetch_curr_amount_details_     => TRUE,
                                    use_only_m10_postings_         => FALSE);
   END IF;
   consumed_total_comp_value_tab_ := Get_Consumed_Tot_Comp_Value(tran_hist_rec_.source_ref1,
                                                                 tran_hist_rec_.source_ref2,
                                                                 tran_hist_rec_.source_ref3);

   wip_value_     := Inventory_Part_Unit_Cost_API.Get_Total_Unit_Cost(consumed_total_comp_value_tab_);
   receipt_value_ := receipt_value_ - wip_value_;
   IF (receipt_value_ > 0) THEN
      IF (curr_amount_detail_tab_.COUNT > 0) THEN
         trans_curr_code_ := curr_amount_detail_tab_(1).currency_code;
         IF (trans_curr_code_ != base_curr_code_) THEN
            trans_curr_conv_factor_    := curr_amount_detail_tab_(1).conversion_factor;
            trans_curr_amount_         := ABS(Mpccom_Accounting_API.Get_Total_Curr_Amount(curr_amount_detail_tab_, trans_curr_code_));
            currency_code_rec_         := Currency_Code_API.Get(company_, trans_curr_code_);
            trans_curr_rounding_       := currency_code_rec_.currency_rounding;
            curr_rate_rounding_factor_ := currency_code_rec_.decimals_in_rate;
            IF (base_curr_rate_is_inverted_ = 'FALSE') THEN
               trans_curr_rate_ := ROUND(((receipt_value_ * trans_curr_conv_factor_)/trans_curr_amount_), curr_rate_rounding_factor_);
            ELSE
               trans_curr_rate_ := ROUND(((trans_curr_amount_ * trans_curr_conv_factor_)/receipt_value_), curr_rate_rounding_factor_);
            END IF;
         END IF;
      END IF;
      Do_Str_Event_Acc_Impl___(dummy_,
                               company_,
                               'BALRECSP',
                               tran_hist_rec_.accounting_id,
                               'INVENTORY',
                               receipt_value_,
                               date_applied_,
                               tran_hist_rec_.contract,
                               value_adjustment_,
                               tran_hist_rec_.userid,
                               NULL,
                               NULL,
                               per_oh_adjustment_id_,
                               control_type_key_rec_,
                               trans_reval_event_id_,
                               base_curr_code_,
                               base_curr_rate_,
                               base_curr_conv_factor_,
                               base_curr_rate_is_inverted_,
                               trans_curr_code_,
                               trans_curr_rate_,
                               trans_curr_conv_factor_,
                               trans_curr_rounding_,
                               trans_curr_amount_);
   END IF;

   m14_value_diff_ := Get_Sum_Value('PUR ORDER',
                                     tran_hist_rec_.source_ref1,
                                     tran_hist_rec_.source_ref2,
                                     tran_hist_rec_.source_ref3,
                                     'M14',
                                     TO_DATE(NULL));

   IF (m14_value_diff_ != 0) THEN
      m14_curr_amt_detail_tab_:= Get_Sum_Curr_Amount_Details(Order_Type_API.DB_PURCHASE_ORDER,
                                                            tran_hist_rec_.source_ref1,
                                                            tran_hist_rec_.source_ref2,
                                                            tran_hist_rec_.source_ref3,
                                                            NULL,
                                                            'M14',
                                                            TO_DATE(NULL));
      IF (m14_curr_amt_detail_tab_.COUNT > 0) THEN
         trans_curr_code_ := m14_curr_amt_detail_tab_(1).currency_code;
         IF (trans_curr_code_ != base_curr_code_) THEN
            trans_curr_conv_factor_    := m14_curr_amt_detail_tab_(1).conversion_factor;
            trans_curr_amount_         := ABS(Mpccom_Accounting_API.Get_Total_Curr_Amount(m14_curr_amt_detail_tab_, trans_curr_code_));
            currency_code_rec_         := Currency_Code_API.Get(company_, trans_curr_code_);
            trans_curr_rounding_       := currency_code_rec_.currency_rounding;
            curr_rate_rounding_factor_ := currency_code_rec_.decimals_in_rate;
            IF (base_curr_rate_is_inverted_ = 'FALSE') THEN
               trans_curr_rate_ := ROUND(((m14_value_diff_ * trans_curr_conv_factor_)/trans_curr_amount_), curr_rate_rounding_factor_);
            ELSE
               trans_curr_rate_ := ROUND(((trans_curr_amount_ * trans_curr_conv_factor_)/m14_value_diff_), curr_rate_rounding_factor_);
            END IF;
         END IF;
      END IF;
      Do_Str_Event_Acc_Impl___(dummy_,
                               company_,
                               'BALRETSP',
                               tran_hist_rec_.accounting_id,
                               'INVENTORY',
                               ABS(m14_value_diff_),
                               date_applied_,
                               tran_hist_rec_.contract,
                               value_adjustment_,
                               tran_hist_rec_.userid,
                               NULL,
                               NULL,
                               per_oh_adjustment_id_,
                               control_type_key_rec_,
                               trans_reval_event_id_,
                               base_curr_code_,
                               base_curr_rate_,
                               base_curr_conv_factor_,
                               base_curr_rate_is_inverted_,
                               trans_curr_code_,
                               trans_curr_rate_,
                               trans_curr_conv_factor_,
                               trans_curr_rounding_,
                               trans_curr_amount_);
   END IF;

   m197_value_diff_ := Get_Sum_Value('STAGE PAYMENT',
                                     tran_hist_rec_.source_ref1,
                                     tran_hist_rec_.source_ref2,
                                     tran_hist_rec_.source_ref3,
                                     'M197',
                                     TO_DATE(NULL));

   IF (m197_value_diff_ = 0) THEN
      RAISE exit_procedure_;
   END IF;

   IF (m197_value_diff_ > 0) THEN
      price_diff_event_code_ := 'PRDIFFSP+';
   ELSE
      price_diff_event_code_ := 'PRDIFFSP-';
   END IF;
      
   Do_Str_Event_Acc_Impl___(dummy_,
                            company_,
                            price_diff_event_code_,
                            tran_hist_rec_.accounting_id,
                            'INVENTORY',
                            ABS(m197_value_diff_),
                            date_applied_,
                            tran_hist_rec_.contract,
                            value_adjustment_,
                            tran_hist_rec_.userid,
                            NULL,
                            NULL,
                            per_oh_adjustment_id_,
                            control_type_key_rec_,
                            trans_reval_event_id_,
                            base_curr_code_,
                            base_curr_rate_,
                            base_curr_conv_factor_,
                            base_curr_rate_is_inverted_,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL);

EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Create_Stage_Pay_Postings___;


-- Get_Accounting_Id_Tab___
--   Returns a PLSQL table of accounting_id's for the given order reference.
FUNCTION Get_Accounting_Id_Tab___ (
   source_ref1_            IN VARCHAR2,
   source_ref2_            IN VARCHAR2,
   source_ref3_            IN VARCHAR2,
   source_ref4_            IN VARCHAR2,
   source_ref_type_db_     IN VARCHAR2,
   alt_source_ref1_        IN VARCHAR2,
   alt_source_ref2_        IN VARCHAR2,
   alt_source_ref3_        IN VARCHAR2,
   alt_source_ref4_        IN VARCHAR2,
   alt_source_ref_type_db_ IN VARCHAR2,
   transaction_code_       IN VARCHAR2 ) RETURN Mpccom_Accounting_API.Accounting_Id_Tab
IS
   accounting_id_tab_  Mpccom_Accounting_API.Accounting_Id_Tab;

   CURSOR get_number_of_transactions IS
      SELECT accounting_id
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE source_ref1              = source_ref1_
         AND source_ref2              = source_ref2_
         AND source_ref3              = source_ref3_
         AND source_ref4              = source_ref4_
         AND source_ref_type          = source_ref_type_db_
         AND (alt_source_ref1         = alt_source_ref1_        OR alt_source_ref1_        IS NULL)
         AND (alt_source_ref2         = alt_source_ref2_        OR alt_source_ref2_        IS NULL)
         AND (alt_source_ref3         = alt_source_ref3_        OR alt_source_ref3_        IS NULL)
         AND (alt_source_ref4         = alt_source_ref4_        OR alt_source_ref4_        IS NULL)
         AND (alt_source_ref_type     = alt_source_ref_type_db_ OR alt_source_ref_type_db_ IS NULL)
         AND transaction_code         = transaction_code_
         AND (quantity - qty_reversed) > 0
         AND part_ownership = 'COMPANY OWNED';
BEGIN
   OPEN  get_number_of_transactions;
   FETCH get_number_of_transactions BULK COLLECT INTO accounting_id_tab_;
   CLOSE get_number_of_transactions;
   RETURN (accounting_id_tab_);
END Get_Accounting_Id_Tab___;


-- Get_Return_Scrap_Serial_Msg___
--   This method will create the error message when return for scrap.
FUNCTION Get_Return_Scrap_Serial_Msg___ (
   source_ref1_  IN VARCHAR2,
   source_ref4_  IN VARCHAR2,
   reject_code_  IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN Language_SYS.Translate_Constant(lu_name_, 'PSCOERETSCP: Returned and scrapped on return material authorization id :P1 due to :P2',
                                          NULL, source_ref1_||' '|| source_ref4_, Scrapping_Cause_API.Get_Reject_Message(reject_code_));
END Get_Return_Scrap_Serial_Msg___;


-- Get_Return_Stock_Serial_Msg___
--   This method will create the error message when return to the stock.
FUNCTION Get_Return_Stock_Serial_Msg___ (
   source_ref1_     IN VARCHAR2,
   source_ref4_ IN VARCHAR2,
   location_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
BEGIN
   RETURN Get_Serial_Message___('PSCOERETURN', LTRIM(RTRIM(location_no_)), source_ref1_, source_ref4_);
END Get_Return_Stock_Serial_Msg___;


FUNCTION Get_Po_Line_Qty_Ordered___ (
   source_ref_1_ IN VARCHAR2,
   source_ref_2_ IN VARCHAR2,
   source_ref_3_ IN VARCHAR2 ) RETURN NUMBER
IS
   stmt_        VARCHAR2(200);
   qty_ordered_ NUMBER;
BEGIN

   stmt_ := 'BEGIN '                                                                             ||
               ':qty_ordered := Purchase_Order_Line_Part_API.Get_Buy_Qty_Due_In_Invent_Um( '     ||
                                                                               ':source_ref_1, ' ||
                                                                               ':source_ref_2, ' ||
                                                                               ':source_ref_3); '||
            'END;';

   @ApproveDynamicStatement(2007-01-22,LEPESE)
   EXECUTE IMMEDIATE stmt_ USING
      OUT qty_ordered_,
       IN source_ref_1_,
       IN source_ref_2_,
       IN source_ref_3_;

   RETURN (qty_ordered_);
END Get_Po_Line_Qty_Ordered___;


FUNCTION Get_Poinv_Wip_Trans_Cost___ (
   source_ref_1_ IN VARCHAR2,
   source_ref_2_ IN VARCHAR2,
   source_ref_3_ IN VARCHAR2 ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   expected_total_comp_value_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   consumed_total_comp_value_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   expected_remaining_comp_value_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   expected_remaining_comp_cost_  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   po_line_qty_ordered_           NUMBER;
   po_line_qty_received_          NUMBER;
   po_line_qty_not_yet_received_  NUMBER;
BEGIN

   po_line_qty_ordered_           := Get_Po_Line_Qty_Ordered___(source_ref_1_,
                                                                source_ref_2_,
                                                                source_ref_3_);
   expected_total_comp_value_tab_ := Get_Expect_Total_Comp_Value___(source_ref_1_,
                                                                    source_ref_2_,
                                                                    source_ref_3_,
                                                                    po_line_qty_ordered_);
   consumed_total_comp_value_tab_ := Get_Consumed_Tot_Comp_Value(source_ref_1_,
                                                                 source_ref_2_,
                                                                 source_ref_3_);
   expected_remaining_comp_value_ := Get_Deducted_Cost_Details___(expected_total_comp_value_tab_,
                                                                  consumed_total_comp_value_tab_);
   po_line_qty_received_          := Get_Po_Line_Qty_Received___(source_ref_1_,
                                                                 source_ref_2_,
                                                                 source_ref_3_);
                                                                 
   po_line_qty_not_yet_received_  := po_line_qty_ordered_ - po_line_qty_received_;
   expected_remaining_comp_cost_  := Inventory_Part_Unit_Cost_API.Value_To_Cost_Details(
                                                                    expected_remaining_comp_value_,
                                                                    po_line_qty_not_yet_received_);
   RETURN (expected_remaining_comp_cost_);
END Get_Poinv_Wip_Trans_Cost___;


FUNCTION Return_To_Vendor_For_Rework___ (
   transaction_code_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   return_to_vendor_for_rework_ BOOLEAN := FALSE;
BEGIN
   IF (transaction_code_ IN ('RETWORK','CO-REWORK','RETWORKINT')) THEN
       return_to_vendor_for_rework_ := TRUE;
   END IF;
   RETURN (return_to_vendor_for_rework_);
END Return_To_Vendor_For_Rework___;


FUNCTION Return_To_Vendor_For_Credit___ (
   transaction_code_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   return_to_vendor_for_credit_ BOOLEAN := FALSE;
BEGIN
   IF (transaction_code_ IN ('RETCREDIT','CO-RCREDIT')) THEN
       return_to_vendor_for_credit_ := TRUE;
   END IF;
   RETURN (return_to_vendor_for_credit_);
END Return_To_Vendor_For_Credit___;


FUNCTION Scrap_For_Credit___ (
   transaction_code_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   scrap_for_credit_ BOOLEAN := FALSE;
BEGIN
   IF (transaction_code_ IN ('SCPCREDIT','CO-SCPCRED')) THEN
       scrap_for_credit_ := TRUE;
   END IF;
   RETURN (scrap_for_credit_);
END Scrap_For_Credit___;


PROCEDURE Create_Return_Wip_Trans___ (
   return_trans_rec_ IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE )
IS
   return_wip_transaction_id_ INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;
   exit_procedure_            EXCEPTION;
   dummy_number_              NUMBER;
   poinv_wip_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   wip_transaction_code_      INVENTORY_TRANSACTION_HIST_TAB.transaction_code%TYPE;
BEGIN

   IF (Return_To_Vendor_For_Rework___(return_trans_rec_.transaction_code)) THEN
      wip_transaction_code_ := 'RETWOR-WIP';
   ELSE
      wip_transaction_code_ := 'RETCRE-WIP';
   END IF;

   poinv_wip_cost_detail_tab_ := Get_Consumed_Comp_Cost_Details(return_trans_rec_.source_ref1,
                                                                return_trans_rec_.source_ref2,
                                                                return_trans_rec_.source_ref3,
                                                                return_trans_rec_.source_ref4);
   IF (poinv_wip_cost_detail_tab_.COUNT = 0) THEN
      RAISE exit_procedure_;
   END IF;

   Create_And_Account(transaction_id_     =>  return_wip_transaction_id_,
                      accounting_id_      =>  dummy_number_,
                      value_              =>  dummy_number_,
                      transaction_code_   =>  wip_transaction_code_,
                      contract_           =>  return_trans_rec_.contract,
                      part_no_            =>  return_trans_rec_.part_no,
                      configuration_id_   =>  return_trans_rec_.configuration_id,
                      location_no_        =>  return_trans_rec_.location_no,
                      lot_batch_no_       =>  return_trans_rec_.lot_batch_no,
                      serial_no_          =>  return_trans_rec_.serial_no,
                      waiv_dev_rej_no_    =>  return_trans_rec_.waiv_dev_rej_no,
                      eng_chg_level_      =>  return_trans_rec_.eng_chg_level,
                      activity_seq_       =>  return_trans_rec_.activity_seq,
                      handling_unit_id_   =>  return_trans_rec_.handling_unit_id,
                      project_id_         =>  return_trans_rec_.project_id,
                      source_ref1_        =>  return_trans_rec_.source_ref1,
                      source_ref2_        =>  return_trans_rec_.source_ref2,
                      source_ref3_        =>  return_trans_rec_.source_ref3,
                      source_ref4_        =>  return_trans_rec_.source_ref4,
                      source_ref5_        =>  return_trans_rec_.source_ref5,
                      reject_code_        =>  return_trans_rec_.reject_code,
                      cost_detail_tab_    =>  poinv_wip_cost_detail_tab_,
                      unit_cost_          =>  NULL,
                      quantity_           =>  return_trans_rec_.quantity,
                      qty_reversed_       =>  0,
                      catch_quantity_     =>  return_trans_rec_.catch_quantity,
                      source_             =>  return_trans_rec_.source,
                      source_ref_type_    =>  Order_Type_API.Decode(return_trans_rec_.source_ref_type),
                      owning_vendor_no_   =>  return_trans_rec_.owning_vendor_no,
                      condition_code_     =>  return_trans_rec_.condition_code,
                      location_group_     =>  return_trans_rec_.location_group,
                      part_ownership_db_  =>  return_trans_rec_.part_ownership,
                      owning_customer_no_ =>  return_trans_rec_.owning_customer_no,
                      expiration_date_    =>  return_trans_rec_.expiration_date);

   Invent_Trans_Interconnect_API.Connect_Transactions(return_trans_rec_.transaction_id,
                                                      return_wip_transaction_id_,
                                                      'RETURN TO SUPPLIER');
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Create_Return_Wip_Trans___;


FUNCTION Get_Ext_Service_Comp_Cost___ (
   source_ref_1_ IN VARCHAR2,
   source_ref_2_ IN VARCHAR2,
   source_ref_3_ IN VARCHAR2 ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   cost_detail_tab_           Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   value_detail_tab_          Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   transaction_id_tab_        Transaction_Id_Tab;
   transaction_quantity_      NUMBER;
   total_quantity_            NUMBER := 0;
BEGIN

   transaction_id_tab_ := Get_Ext_Service_Comp_Trans___(source_ref_1_,
                                                        source_ref_2_,
                                                        source_ref_3_);
   
   IF (transaction_id_tab_.COUNT > 0) THEN
      FOR i IN transaction_id_tab_.FIRST..transaction_id_tab_.LAST LOOP 
         transaction_quantity_ := Inventory_Transaction_Hist_API.Get_Quantity(transaction_id_tab_(i)); 
         cost_detail_tab_      := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(transaction_id_           => transaction_id_tab_(i),
                                                                                              include_added_details_    => FALSE,
                                                                                              include_normal_details_   => TRUE,
                                                                                              replace_star_cost_bucket_ => TRUE);
         
         value_detail_tab_     := Inventory_Part_Unit_Cost_API.Add_To_Value_Detail_Tab (value_detail_tab_,
                                                                                        cost_detail_tab_,
                                                                                        transaction_quantity_);                                                                                     
         total_quantity_ := total_quantity_ + transaction_quantity_;                                                                                     
      END LOOP;                                                                                  
   END IF;
   
   IF (total_quantity_ != 0) THEN  
      IF (value_detail_tab_.COUNT > 0) THEN
         FOR i IN value_detail_tab_.FIRST..value_detail_tab_.LAST LOOP
            value_detail_tab_(i).unit_cost := value_detail_tab_(i).unit_cost/ total_quantity_;   
         END LOOP;
      END IF;
   END IF;

   RETURN(value_detail_tab_);
END Get_Ext_Service_Comp_Cost___;


FUNCTION Get_Ext_Service_Comp_Trans___ (
   source_ref_1_ IN VARCHAR2,
   source_ref_2_ IN VARCHAR2,
   source_ref_3_ IN VARCHAR2 ) RETURN Transaction_Id_Tab
IS
   transaction_id_tab_  Transaction_Id_Tab;

   CURSOR get_transaction_id IS
   SELECT transaction_id
     FROM INVENTORY_TRANSACTION_HIST_TAB
    WHERE source_ref1        = source_ref_1_
      AND source_ref2        = source_ref_2_
      AND source_ref3        = source_ref_3_
      AND source_ref_type    = 'PUR ORDER'
      AND transaction_code IN ('PURSHIP','CO-PURSHIP')
      AND quantity - qty_reversed > 0;
BEGIN

   OPEN  get_transaction_id;
   FETCH get_transaction_id BULK COLLECT INTO transaction_id_tab_;
   CLOSE get_transaction_id;

   RETURN(transaction_id_tab_);
END Get_Ext_Service_Comp_Trans___;


PROCEDURE Get_Purch_Order_Ref___ (
   purch_order_ref1_ OUT VARCHAR2,
   purch_order_ref2_ OUT VARCHAR2,
   purch_order_ref3_ OUT VARCHAR2,
   purch_order_ref4_ OUT VARCHAR2,
   inv_trans_rec_    IN  INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE )
IS
BEGIN

   IF (inv_trans_rec_.source_ref_type = 'PUR ORDER') THEN
      purch_order_ref1_ := inv_trans_rec_.source_ref1;
      purch_order_ref2_ := inv_trans_rec_.source_ref2;
      purch_order_ref3_ := inv_trans_rec_.source_ref3;
      purch_order_ref4_ := inv_trans_rec_.source_ref4;
   ELSIF (inv_trans_rec_.alt_source_ref_type IN ('PUR ORDER','CUSTOMER ORDER DIRECT')) THEN
      purch_order_ref1_ := inv_trans_rec_.alt_source_ref1;
      purch_order_ref2_ := inv_trans_rec_.alt_source_ref2;
      purch_order_ref3_ := inv_trans_rec_.alt_source_ref3;
      purch_order_ref4_ := inv_trans_rec_.alt_source_ref4;
   END IF;
END Get_Purch_Order_Ref___;


PROCEDURE Check_Modify_Date_Applied___ (
   newrec_           IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   old_date_applied_ IN DATE )
IS
   company_                     VARCHAR2(20);
   stat_period_new_             NUMBER;
   stat_year_new_               NUMBER;
   latest_stat_year_no_         NUMBER;
   latest_stat_period_no_       NUMBER;
   cancel_transaction_id_       INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;
   original_trans_date_applied_ INVENTORY_TRANSACTION_HIST_TAB.date_applied%TYPE;
   cancel_trans_date_applied_   INVENTORY_TRANSACTION_HIST_TAB.date_applied%TYPE;
   latest_stat_period_end_date_ DATE;
   new_stat_period_end_date_    DATE;
   
   CURSOR get_earlier_cancel_transaction (original_transaction_id_ IN NUMBER, date_applied_ IN DATE) IS
      SELECT transaction_id, date_applied
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE original_transaction_id = original_transaction_id_
         AND date_applied  < date_applied_
      ORDER BY date_applied;
BEGIN

   IF (Mpccom_Accounting_API.Transferred_Posting_Exists(newrec_.accounting_id)) THEN
      Error_SYS.Record_General('InventoryTransactionHist', 'TRANSPOST: This transaction has postings that are already transferred to Finance. Date can not be modified.');
   END IF;

   IF (TRUNC(Site_API.Get_Site_Date(newrec_.contract)) < newrec_.date_applied) THEN
      Error_SYS.Record_General('InventoryTransactionHist', 'FUTURETRAN: The new date of the transaction can not be a future date.');
   END IF;

   -- Transaction should not have been processed by statistics.
   IF (newrec_.valuestat_flag = 'Y') OR (newrec_.partstat_flag = 'Y') THEN
      Error_SYS.Record_General('InventoryTransactionHist', 'ROWSTAT: This transaction is processed by inventory statistics update. Date can not be modified.');
   END IF;

   IF (newrec_.transaction_code NOT IN ('ROUNDDIFF+','ROUNDDIFF-')) THEN

      Inventory_Value_API.Get_Max_Year_Period(latest_stat_year_no_,
                                              latest_stat_period_no_,
                                              newrec_.contract);

      Statistic_Period_API.Get_Statistic_Period(stat_year_new_,
                                                stat_period_new_,
                                                newrec_.date_applied);

      latest_stat_period_end_date_ := Statistic_Period_API.Get_End_Date(latest_stat_year_no_, latest_stat_period_no_);
      new_stat_period_end_date_    := Statistic_Period_API.Get_End_Date(stat_year_new_, stat_period_new_);

      IF (new_stat_period_end_date_ < latest_stat_period_end_date_) THEN
         Error_SYS.Record_General('InventoryTransactionHist', 'ILLEGALPERIOD: The new date must be equal to or greater than the start date of the latest period in the inventory value statistics.');
      END IF;
   END IF;

   company_ := Site_API.Get_Company(newrec_.contract);
   Mpccom_Accounting_API.Check_Date_Applied(company_, newrec_.date_applied);

   IF (newrec_.date_applied > old_date_applied_) THEN
      -- The date is moved forward in time. Investigate if this transaction has been reversed and if this update places
      -- the original transaction after the reverse-transactions in time.
      OPEN get_earlier_cancel_transaction(newrec_.transaction_id,newrec_.date_applied);
      FETCH get_earlier_cancel_transaction INTO cancel_transaction_id_, cancel_trans_date_applied_;
      IF (get_earlier_cancel_transaction%FOUND) THEN
         CLOSE get_earlier_cancel_transaction;
         Error_SYS.Record_General('InventoryTransactionHist', 'ORGDAYAPPLIEDERR: The date applied for transaction :P1 may not be later than the date applied for transaction :P2 which is :P3.', newrec_.transaction_id, cancel_transaction_id_, cancel_trans_date_applied_);
      END IF;
      CLOSE get_earlier_cancel_transaction;

   ELSIF (newrec_.date_applied < old_date_applied_) THEN
      -- The date is moved backwards in time
      IF (newrec_.original_transaction_id IS NOT NULL) THEN
         -- This transaction reverses another transaction.
         original_trans_date_applied_ := Get_Date_Applied(newrec_.original_transaction_id);
         IF (newrec_.date_applied < original_trans_date_applied_) THEN
            -- The reverse-transaction cannot be placed before the original transaction in time.
            Error_SYS.Record_General('InventoryTransactionHist', 'REVDAYAPPLIEDERR: The date applied for transaction :P1 may not be earlier than the date applied for transaction :P2 which is :P3.', newrec_.transaction_id, newrec_.original_transaction_id, original_trans_date_applied_);
         END IF;
      END IF;
   END IF;
END Check_Modify_Date_Applied___;


PROCEDURE Handle_Modify_Date_Applied___ (
   newrec_ IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE )
IS
   company_       VARCHAR2(20);
   stmt_          VARCHAR2(2000);
BEGIN

   company_ := Site_API.Get_Company(newrec_.contract); 

   Redo_Transaction_Postings___(newrec_.transaction_id,
                                newrec_.accounting_id,
                                newrec_.contract,
                                newrec_.part_no,
                                newrec_.activity_seq,
                                newrec_.source_ref1,
                                newrec_.source_ref2,
                                newrec_.source_ref3,
                                newrec_.source_ref4,
                                newrec_.pre_accounting_id,
                                newrec_.date_applied,
                                newrec_.source_ref_type,
                                company_);

   IF (newrec_.original_transaction_id IS NOT NULL) THEN
      IF (newrec_.source_ref_type = 'PUR ORDER') THEN
         IF (Mpccom_Accounting_API.Check_Accounting_Exist(newrec_.accounting_id, 'M10', NULL)) THEN
               stmt_ := 'BEGIN ' ||
                           'Purchase_Receipt_API.Handle_Modify_Date_Applied(:source_ref1, :source_ref2, :source_ref3, :source_ref4, :date_applied); ' ||
                        'END;';
               @ApproveDynamicStatement(2008-09-01,nibalk)
               EXECUTE IMMEDIATE stmt_
                 USING
                    IN    newrec_.source_ref1,
                    IN    newrec_.source_ref2,
                    IN    newrec_.source_ref3,
                    IN    newrec_.source_ref4,
                    IN    newrec_.date_applied;
         END IF;
      END IF;
   END IF;
   Refresh_Activity_Info(newrec_.contract, newrec_.accounting_id);

   Modify_Connected_Trans_Date___(newrec_.transaction_id,
                                  newrec_.transaction_code,
                                  newrec_.date_applied);
END Handle_Modify_Date_Applied___;


PROCEDURE Modify_Connected_Trans_Date___ (
   transaction_id_   IN NUMBER,
   transaction_code_ IN VARCHAR2,
   date_applied_     IN DATE )
IS
   connect_reason_db_        VARCHAR2(23);
   connected_transaction_id_tab_ Invent_Trans_Interconnect_API.Connected_Transaction_Id_Tab;
   rec_                      Public_Rec;
BEGIN
   IF (transaction_code_ IN ('ARRIVAL', 'POINV-WIP', 'PURBKFL')) THEN
      connect_reason_db_ := 'PURCH COMPONENT COST';
   ELSIF (transaction_code_ IN ('RETWORK', 'RETWOR-WIP', 'RETCREDIT', 'RETCRE-WIP', 'SCPCREDIT')) THEN
      connect_reason_db_ := 'RETURN TO SUPPLIER';
   ELSIF (transaction_code_ IN ('RETCORCRE', 'RETCORWORK', 'RETCORWINT',  'UNRET-WIP', 'SCPCREDCOR')) THEN
      connect_reason_db_ := 'UNDO RETURN TO SUPPLIER';
   -- gelr:modify_date_applied Begin   
   ELSIF (transaction_code_ IN ('INVM-COIN', 'INVM-TRIN', 'COMPM-IN')) THEN
      connect_reason_db_ := 'INTERSITE TRANSFER';
   ELSIF (transaction_code_ IN ('INVM-IN')) THEN
      connect_reason_db_ := 'INVENTORY_MOVE';   
   -- gelr:modify_date_applied End
   END IF;

   IF (connect_reason_db_ IS NOT NULL) THEN
      connected_transaction_id_tab_ := Invent_Trans_Interconnect_API.Get_All_Connected_Trans_id_Tab(transaction_id_, connect_reason_db_);
      IF (connected_transaction_id_tab_.COUNT > 0) THEN 
         FOR i IN connected_transaction_id_tab_.FIRST..connected_transaction_id_tab_.LAST LOOP
            IF (connected_transaction_id_tab_(i) IS NOT NULL) THEN
               rec_ := Get(connected_transaction_id_tab_(i));
               -- Added condition to make sure the information message is not added twice.
               IF (rec_.date_applied != date_applied_ ) THEN
                  Client_SYS.Add_Info(lu_name_, 'MODIFYDATEAPPLIED: The new date applied for the :P1 transaction will also apply to the connected :P2 transaction.', transaction_code_, rec_.transaction_code);
                  Modify_Date_Applied___(connected_transaction_id_tab_(i), date_applied_);
               END IF;
            END IF;
         END LOOP;
      END IF;
   END IF;
END Modify_Connected_Trans_Date___;


PROCEDURE Modify_Date_Applied___ (
   transaction_id_   IN NUMBER,
   new_date_applied_ IN DATE )
IS
   objid_                        INVENTORY_TRANSACTION_HIST.objid%TYPE;
   objversion_                   INVENTORY_TRANSACTION_HIST.objversion%TYPE;
   oldrec_                       INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   newrec_                       INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   attr_                         VARCHAR2(2000);
   indrec_                       Indicator_Rec;
   reapply_old_date_applied_     BOOLEAN := FALSE;
BEGIN
   oldrec_ := Lock_By_Keys___(transaction_id_);
   newrec_ := oldrec_;
   Client_SYS.Clear_Attr(attr_);
   IF (oldrec_.date_applied = TRUNC(new_date_applied_)) THEN
      reapply_old_date_applied_ := TRUE;   
   ELSE
      reapply_old_date_applied_ := FALSE;
      newrec_.date_applied := TRUNC(new_date_applied_);
   END IF;
  -- Modify the date_applied on the transaction.
   indrec_ := Get_Indicator_Rec___(oldrec_, newrec_);
   Check_Update___(oldrec_, newrec_, indrec_, attr_, reapply_old_date_applied_ => reapply_old_date_applied_);
   Update___(objid_, oldrec_, newrec_, attr_, objversion_, by_keys_ => TRUE, reapply_old_date_applied_ => reapply_old_date_applied_); -- Update by keys.
END Modify_Date_Applied___;


FUNCTION Reversing_Issue_Transaction___ (
   transaction_code_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   reversing_issue_transaction_ BOOLEAN := FALSE;
BEGIN
   IF (transaction_code_ IN ('INTUNISS'  , 'CO-INTUNIS' ,
                             'UNISS'     , 'CO-UNISS'   ,
                             'WOUNISS'   , 'CO-WOUNISS' ,
                             'WTUNISS'   , 'CO-WTUNISS' ,
                             'UN-PURBKFL', 'CO-UNPBKFL' ,
                             'UN-PURSHIP', 'CO-UNPSHIP' ,
                             'RPSBKFL'   , 'CO-RPSBKFL')) THEN
      reversing_issue_transaction_ := TRUE;
   END IF;
   RETURN (reversing_issue_transaction_);
END Reversing_Issue_Transaction___;


FUNCTION Get_Source_Abnormal_Demand___ (
   source_ref1_                 IN VARCHAR2,
   source_ref2_                 IN VARCHAR2, 
   source_ref3_                 IN VARCHAR2, 
   source_ref4_                 IN NUMBER,
   source_ref_type_db_          IN VARCHAR2,
   inventory_stat_direction_db_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   abnormal_demand_db_ INVENTORY_TRANSACTION_HIST_TAB.abnormal_demand%TYPE;
BEGIN
   IF (inventory_stat_direction_db_ = 'ISSUE' AND source_ref_type_db_ = 'CUST ORDER') THEN
      $IF (Component_Order_SYS.INSTALLED)$THEN
         abnormal_demand_db_ := Customer_Order_Line_API.Get_Abnormal_Demand_Db(source_ref1_, source_ref2_, source_ref3_, source_ref4_);
      $ELSE 
         NULL;
      $END
   ELSIF (inventory_stat_direction_db_ = 'REVERSED ISSUE' AND source_ref_type_db_ = 'RMA') THEN
       $IF (Component_Order_SYS.INSTALLED)$THEN
            DECLARE
               return_material_line_rec_    Return_Material_Line_API.Public_rec;
            BEGIN
               return_material_line_rec_ := Return_Material_Line_API.Get(source_ref1_, to_char(source_ref4_));
               abnormal_demand_db_       := Customer_Order_Line_API.Get_Abnormal_Demand_Db(return_material_line_rec_.order_no,
                                                                                           return_material_line_rec_.line_no,
                                                                                           return_material_line_rec_.rel_no,
                                                                                           return_material_line_rec_.line_item_no);
            END;
       $ELSE 
            NULL;
       $END
   END IF;

   RETURN abnormal_demand_db_;
END Get_Source_Abnormal_Demand___;

-----------------------------------------------------------------------------------------------------
-- Get_Arrival_Trans_Amounts___
--    Return original transaction amounts for a specific transaction_id_ if the transaction part is 
--    periodic weighted average and the original amounts need to be fetched. Else return value_detail_tab_
--    created for the specified accounting_id and str_code.
-----------------------------------------------------------------------------------------------------
PROCEDURE Get_Arrival_Trans_Amounts___ (
   trans_value_detail_tab_       OUT Mpccom_Accounting_API.Value_Detail_Tab,
   curr_amount_detail_tab_       OUT Mpccom_Accounting_API.Curr_Amount_Detail_Tab,
   use_this_transaction_         OUT BOOLEAN,
   price_diff_                   OUT NUMBER,
   from_alt_source_              IN  BOOLEAN,
   to_date_                      IN  DATE,
   use_original_amount_for_pwa_  IN  BOOLEAN,
   trans_rec_                    IN  INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   fetch_curr_amount_details_    IN  BOOLEAN,
   use_only_m10_postings_        IN  BOOLEAN)
IS
   posting_type_     VARCHAR2(30);
   part_rec_         Inventory_Part_API.Public_Rec;
BEGIN
   use_this_transaction_ := FALSE;

   IF ((Suppl_Consignment_Consumpt___(trans_rec_.transaction_code)                                        ) OR
       (Unconsumed_Consign_Receipt___(trans_rec_)                                                         ) OR
       (Purchase_Order_Receipt___    (trans_rec_.transaction_code, include_supplier_consignment_ => FALSE)) OR
       (Direct_Ship_Customer_Order___(trans_rec_.transaction_code) AND from_alt_source_                   ) OR
       (Map_Receipt_Direct_Ship___   (trans_rec_.transaction_code)                                        ) OR
       (Map_Receipt_Move_to_Inv___   (trans_rec_.transaction_code)                                        )) THEN

      use_this_transaction_ := TRUE;

      IF ((use_original_amount_for_pwa_) AND (trans_rec_.original_amount IS NOT NULL)) THEN
         part_rec_             := Inventory_Part_API.Get(trans_rec_.contract, trans_rec_.part_no);
         
         IF ((part_rec_.inventory_valuation_method = Inventory_Value_Method_API.DB_STANDARD_COST) AND
             (part_rec_.invoice_consideration      = Invoice_Consideration_API.DB_PERIODIC_WEIGHTED_AVERAGE)) THEN

               trans_value_detail_tab_(1).value                   := trans_rec_.original_amount;
               trans_value_detail_tab_(1).bucket_posting_group_id := '*';
               trans_value_detail_tab_(1).cost_source_id          := '*';
               
            IF (fetch_curr_amount_details_) THEN
               curr_amount_detail_tab_ := Mpccom_Accounting_API.Get_Curr_Amount_Details(accounting_id_ => trans_rec_.accounting_id,
                                                                                        str_code_      => NVL(posting_type_,'M10'),
                                                                                        to_date_       => to_date_);

               price_diff_ := Mpccom_Accounting_API.Get_Sum_Event_And_Type_Value(trans_rec_.accounting_id, 'PRICEDIFF%', 'M10', to_date_);
            END IF;
         END IF;
      END IF;

      IF (trans_value_detail_tab_.COUNT = 0) THEN
         IF (use_only_m10_postings_) THEN
            posting_type_ := 'M10';
         ELSE
            -- Either there were no original trans amounts or we did not bother to fetch because
            -- we are not running Periodic Weighted Average. So we need the current amounts.
            IF NOT (Map_Receipt_Move_to_Inv___(trans_rec_.transaction_code)) THEN
               Acc_Event_Posting_Type_API.Get_Str_Code(posting_type_, trans_rec_.transaction_code, 'C');
            END IF;
         END IF;

         trans_value_detail_tab_ := Mpccom_Accounting_API.Get_Sum_Value_Details(accounting_id_ => trans_rec_.accounting_id,
                                                                                str_code_      => NVL(posting_type_,'M10'),
                                                                                to_date_       => to_date_);                                                                                         
         
         IF (fetch_curr_amount_details_) THEN
            curr_amount_detail_tab_ := Mpccom_Accounting_API.Get_Curr_Amount_Details(accounting_id_ => trans_rec_.accounting_id,
                                                                                     str_code_      => NVL(posting_type_,'M10'),
                                                                                     to_date_       => to_date_);                                                        

            price_diff_ := Mpccom_Accounting_API.Get_Sum_Event_And_Type_Value(trans_rec_.accounting_id, 'PRICEDIFF%', 'M10', to_date_);         
         END IF;
                                                        
      END IF;
   END IF;

END Get_Arrival_Trans_Amounts___;   

PROCEDURE Modify_Abnormal_Demand___ (
   source_ref1_        IN VARCHAR2,
   source_ref2_        IN VARCHAR2,
   source_ref3_        IN VARCHAR2,
   source_ref4_        IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2,
   abnormal_demand_db_ IN VARCHAR2 )
IS
   record_                      INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   inventory_stat_direction_db_ VARCHAR2(50);
 
   CURSOR get_transaction_details IS
      SELECT transaction_id, transaction_code, partstat_flag 
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE  source_ref1  = source_ref1_
         AND (source_ref2  = source_ref2_ OR source_ref2_ IS NULL)
         AND (source_ref3  = source_ref3_ OR source_ref3_ IS NULL)
         AND (source_ref4  = source_ref4_ OR source_ref4_ IS NULL)
         AND  source_ref_type   = source_ref_type_db_;
BEGIN
   FOR rec_ IN get_transaction_details LOOP
      inventory_stat_direction_db_ := Mpccom_Transaction_Code_API.Get_Invent_Stat_Direction_Db(rec_.transaction_code);

      IF (inventory_stat_direction_db_ IN ('ISSUE', 'REVERSED ISSUE')) THEN
         IF rec_.partstat_flag = 'Y' THEN
            Error_SYS.Record_General(lu_name_, 'TRANSAGGREGATED: Abnormal Demand cannot be modified since Inventory Transaction ID :P1 created for this order line has already been included in the Periodic Aggregation.', rec_.transaction_id);
         END IF;   
         record_ := Lock_By_Keys___(rec_.transaction_id);
         record_.abnormal_demand := abnormal_demand_db_;
         Modify___(record_);
      END IF;
   END LOOP;
END Modify_Abnormal_Demand___;


FUNCTION Get_Purchase_Order_Vendor___  (
   purchase_order_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   vendor_no_ INVENTORY_TRANSACTION_HIST_TAB.owning_vendor_no%TYPE;
   stmt_      VARCHAR2(2000);
BEGIN
   stmt_ := 'BEGIN
                :vendor_no := Purchase_Order_API.Get_Vendor_No(:order_no); 
             END;';

   @ApproveDynamicStatement(2010-03-23,cpeilk)
   EXECUTE IMMEDIATE stmt_
      USING OUT vendor_no_,
            IN  purchase_order_no_;
            
   RETURN vendor_no_;
END Get_Purchase_Order_Vendor___;


PROCEDURE Check_Owning_Customer_No___ (
   owning_customer_no_ IN INVENTORY_TRANSACTION_HIST_TAB.owning_customer_no%TYPE )
IS   
BEGIN
   $IF Component_Order_SYS.INSTALLED $THEN
      Cust_Ord_Customer_API.Exist(owning_customer_no_);            
   $ELSE
      Error_SYS.Record_General(lu_name_, 'NOCUSTOMER: A Customer may not be specified as Owner when Customer Order is not installed.');    
   $END
END Check_Owning_Customer_No___;


PROCEDURE Check_Owning_Vendor_No___ (
   owning_vendor_no_ IN INVENTORY_TRANSACTION_HIST_TAB.owning_vendor_no%TYPE )
IS  
BEGIN
   $IF Component_Purch_SYS.INSTALLED $THEN
      Supplier_API.Exist(owning_vendor_no_);            
   $ELSE
      Error_SYS.Record_General(lu_name_, 'NOSUPPLIER: A Supplier may not be specified as Owner when Purchasing is not installed.');   
   $END
END Check_Owning_Vendor_No___;


PROCEDURE Check_Part_Ownership___ (
   transaction_code_       IN VARCHAR2,
   part_ownership_db_      IN VARCHAR2,
   owning_vendor_no_       IN VARCHAR2,
   owning_customer_no_     IN VARCHAR2 )
IS
BEGIN

   IF (part_ownership_db_ = Part_Ownership_API.DB_CUSTOMER_OWNED) THEN
      IF (owning_customer_no_ IS NULL) THEN
         Error_SYS.Record_General(lu_name_, 'CUSTOMERNEEDSVALUE: Owning Customer No needs to have a value for :P1 stock.', Part_Ownership_API.Decode(part_ownership_db_));
      END IF;
   ELSIF (part_ownership_db_ IN (Part_Ownership_API.DB_SUPPLIER_LOANED, 
                                 Part_Ownership_API.DB_SUPPLIER_OWNED,
                                 Part_Ownership_API.DB_CONSIGNMENT,
                                 Part_Ownership_API.DB_SUPPLIER_RENTED)) THEN
      IF (owning_vendor_no_ IS NULL) AND transaction_code_ NOT IN ('CO-CONDCH-', 'CO-CONDCH+', 
                                                                   'CO-PCGCHG-', 'CO-PCGCHG+', 
                                                                   'CO-INVREV+', 'CO-INVREV-',
                                                                   'CO-LOCGRP-', 'CO-LOCGRP+')THEN
         Error_SYS.Record_General(lu_name_, 'VENDORNEEDSVALUE: Owning Vendor No needs to have a value for :P1 stock.', Part_Ownership_API.Decode(part_ownership_db_));
      END IF;
   ELSIF (part_ownership_db_ NOT IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                     Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)) THEN
      Error_SYS.Record_General(lu_name_, 'OWNERSHIPERR: Part Ownership :P1 is not supported in this operation.', Part_Ownership_API.Decode(part_ownership_db_));
   END IF;
END Check_Part_Ownership___;

PROCEDURE Check_Part_Ownership_Transfer___ (
   contract_                     IN VARCHAR2,
   transaction_code_             IN VARCHAR2,
   ownership_transfer_reason_id_ IN VARCHAR2)
IS   
BEGIN   
   IF (ownership_transfer_reason_id_ IS NULL) AND transaction_code_ IN ('CO-PRJTRN-', 'CO-PRJTRN+', 
                                                                        'COTOCRA-', 'COTOCRA+', 
                                                                        'CRATOCO-', 'CRATOCO+',
                                                                        'PROJTRAN-', 'PROJTRAN+',
                                                                        'XO-TR-IN', 'XO-TR-OUT',
                                                                        'XO-ARRIVAL', 'OWNTRANOUT') THEN
      IF (Company_Invent_Info_API.Get_Ownrshp_Trans_Reason_Ma_Db(Site_API.Get_Company(contract_)) = Fnd_Boolean_API.DB_TRUE) THEN
         Error_SYS.Record_General(lu_name_, 'OWNRSHPTRANSREASONMAND: Ownership Transfer Reason must have a value.');
      END IF;
   END IF;   
END Check_Part_Ownership_Transfer___;

PROCEDURE Reverse_Cro_Serial_Receipt___ (
   old_transaction_    IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   new_transaction_id_ IN INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE )
IS
   prev_current_pos_ VARCHAR2(30);
   serial_message_   VARCHAR2(2000);
BEGIN

   IF (Part_Serial_History_API.Current_Position_Is_Changed(old_transaction_.part_no,
                                                           old_transaction_.serial_no,
                                                           old_transaction_.transaction_id)) THEN
      Error_SYS.Record_General(lu_name_, 'UNDOCRORECEIPT: Subsequent transactions on the serial part :P1 prevent the reversal of this receipt.', old_transaction_.serial_no );
   END IF;

   prev_current_pos_ := Part_Serial_Catalog_API.Get_Previous_Current_Position(old_transaction_.part_no,
                                                                              old_transaction_.serial_no);
   serial_message_   := Language_SYS.Translate_Constant(lu_name_, 'CROSERIALCANCEL: Direct Receipt to CRO repair line cancelled');

   IF (prev_current_pos_ IS NULL) THEN
      Part_Serial_Catalog_API.Remove(old_transaction_.part_no,
                                     old_transaction_.serial_no);
   ELSIF (prev_current_pos_ = 'InFacility') THEN
      Part_Serial_Catalog_API.Move_To_Facility(old_transaction_.part_no,
                                               old_transaction_.serial_no,
                                               new_transaction_id_,
                                               serial_message_);
   ELSIF (prev_current_pos_ = 'Issued') THEN
      Part_Serial_Catalog_API.Issue(old_transaction_.part_no,
                                    old_transaction_.serial_no,
                                    serial_message_,
                                    old_transaction_.source_ref1,
                                    old_transaction_.source_ref2,
                                    old_transaction_.source_ref3,
                                    old_transaction_.source_ref4,
                                    Order_Type_API.Decode(old_transaction_.source_ref_type),
                                    new_transaction_id_);
   ELSE
      Error_SYS.Record_General(lu_name_, 'REVCRORECNOTALLOWED: Reversal of CRO Receipt cannot be performed on a serial with previous position :P1.', prev_current_pos_ );
   END IF;
END Reverse_Cro_Serial_Receipt___;


PROCEDURE Check_Serial_Tracking___ (
   newrec_           IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   trancode_rec_     IN Mpccom_Transaction_Code_API.Public_Rec,
   part_catalog_rec_ IN Part_Catalog_API.Public_Rec )
IS
   receipt_issue_serial_track_    EXCEPTION;
   scrap_or_return_of_po_receipt_ BOOLEAN := FALSE;
   renamed_from_serial_tab_       Part_Serial_History_API.Part_Serial_Tab;
   serial_processed_on_order_     BOOLEAN;
BEGIN
   IF ((newrec_.serial_no != '*') AND 
       (part_catalog_rec_.stop_new_serial_in_rma = true_) AND
       (newrec_.source_ref_type = Order_Type_API.DB_RETURN_MTRL_AUTHORIZATION)) THEN
      IF (Part_Serial_Catalog_API.Check_Exist(newrec_.part_no, newrec_.serial_no) = false_) THEN
         Error_SYS.Record_General(lu_name_, 'NEWSERIALRMA: Only existing serials of part :P1 can be returned through RMA.', newrec_.part_no);
      END IF;
   END IF;

   IF (newrec_.source_ref_type = Order_Type_API.DB_PURCHASE_ORDER) THEN
      IF ((Return_To_Vendor_For_Rework___(newrec_.transaction_code))  OR
          (Return_To_Vendor_For_Credit___(newrec_.transaction_code))  OR
          (Scrap_For_Credit___           (newrec_.transaction_code))  OR
          (Scrap_In_Inventory___         (newrec_.transaction_code))) THEN
         -- This is a return or scrap transaction performed on a Purcase Order Line Receipt
         scrap_or_return_of_po_receipt_ := TRUE;
      END IF;
   END IF;

   IF (NVL(newrec_.serial_no, '*') = '*') THEN
      -- No specific serial number has been entered for the transaction
      IF ((part_catalog_rec_.receipt_issue_serial_track = true_) AND
          (trancode_rec_.receipt_issue_tracking         = true_)) THEN
         -- The part is configured for Receipt And Issue Serial Tracking. This transaction code requires a serial number
         -- for a part that is configured in that way. But still there is no specific serial number on the transaction.
         IF (scrap_or_return_of_po_receipt_) THEN
            IF (Part_Serial_History_API.Check_Exist(newrec_.part_no,
                                                    newrec_.source_ref1,
                                                    newrec_.source_ref2,
                                                    newrec_.source_ref3,
                                                    newrec_.source_ref4,
                                                    newrec_.source_ref_type)) THEN
               -- At least one serial has been identified for this PO Line Receipt.
               -- Then we require serial information on the return or scrap.
               RAISE receipt_issue_serial_track_;
            END IF;
         ELSE
            RAISE receipt_issue_serial_track_;
         END IF;
      END IF;
   ELSE
      -- A specific serial number (!= '*') has been entered for the transaction
      IF (part_catalog_rec_.receipt_issue_serial_track = false_) THEN
         -- The part is not configured for Receipt And Issue Serial Tracking.
         -- But still there is a specific serial number on the transaction.
         Error_SYS.Record_General(lu_name_, 'RECISSNOTRACK: Part :P1 is not configured to use unique serial number identification.', newrec_.part_no);
      END IF;
      IF (scrap_or_return_of_po_receipt_) THEN
         IF NOT (Serial_Processed_On_Order(newrec_.source_ref1,
                                           newrec_.source_ref2,
                                           newrec_.source_ref3,
                                           newrec_.source_ref4,
                                           newrec_.source_ref_type,
                                           newrec_.part_no,
                                           newrec_.serial_no)) THEN
            serial_processed_on_order_ := FALSE;
            -- Retrieved the part and serial no's previously renamed from this part_no, serial_no combination. 
            renamed_from_serial_tab_   := Part_Serial_History_API.Get_Renamed_From_Serials(newrec_.part_no, newrec_.serial_no);

            IF (renamed_from_serial_tab_.COUNT > 0) THEN
               FOR i IN renamed_from_serial_tab_.FIRST..renamed_from_serial_tab_.LAST LOOP
                  IF (Serial_Processed_On_Order(newrec_.source_ref1,
                                                newrec_.source_ref2,
                                                newrec_.source_ref3,
                                                newrec_.source_ref4,
                                                newrec_.source_ref_type,
                                                renamed_from_serial_tab_(i).part_no,
                                                renamed_from_serial_tab_(i).serial_no)) THEN
                     serial_processed_on_order_ := TRUE;
                     EXIT;
                  END IF;
               END LOOP;
            END IF;
            IF NOT (serial_processed_on_order_) THEN
               Error_SYS.Record_General(lu_name_, 'SERIALORDERERR: Serial :P1 has not been received on Purchase Receipt :P2.', newrec_.part_no||' '||newrec_.serial_no, newrec_.source_ref1||' '||newrec_.source_ref2||' '||newrec_.source_ref3||' '||newrec_.source_ref4);
            END IF;
         END IF;
      END IF;
   END IF;
EXCEPTION
   WHEN receipt_issue_serial_track_ THEN
      Error_SYS.Record_General(lu_name_, 'RECISSERTRACK: Transaction :P1 :P2 requires unique serial number identification for Part :P3.', newrec_.transaction_code, '('||mpccom_system_event_api.get_description(newrec_.transaction_code)||')', newrec_.part_no);
END Check_Serial_Tracking___;

PROCEDURE Copy_Fifo_Lifo_Issues___(
   old_issue_cancel_trans_id_ IN NUMBER,
   new_issue_transaction_id_  IN NUMBER,
   contract_                  IN VARCHAR2,
   part_no_                   IN VARCHAR2 )
 IS
   pre_trans_level_qty_in_stock_  NUMBER;
   pre_trans_level_qty_in_transi_ NUMBER;
   pre_trans_avg_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
BEGIN
   Inventory_Part_Cost_Fifo_API.Copy_From_Cancelled_Issue(pre_trans_level_qty_in_stock_,
                                                          pre_trans_level_qty_in_transi_,
                                                          pre_trans_avg_cost_detail_tab_,
                                                          contract_,
                                                          part_no_,
                                                          old_issue_cancel_trans_id_,
                                                          new_issue_transaction_id_);
   Set_Pre_Trans_Level_Qty___(new_issue_transaction_id_,
                              pre_trans_level_qty_in_stock_,
                              pre_trans_level_qty_in_transi_);

   Pre_Invent_Trans_Avg_Cost_API.Add_Cost_Details(new_issue_transaction_id_,
                                                  pre_trans_avg_cost_detail_tab_);
END Copy_Fifo_Lifo_Issues___;


FUNCTION Get_Dirrettosup_Message___ RETURN VARCHAR2
IS
   message_     VARCHAR2(2000);
BEGIN
   message_ := Language_SYS.Translate_Constant(lu_name_, 'DIRRETTOSUP: Direct Return to supplier for credit');
   RETURN (message_);
END Get_Dirrettosup_Message___;


PROCEDURE Check_Activity_Seq___ (
   activity_seq_     IN NUMBER,
   action_           IN VARCHAR2 )
IS
BEGIN
   IF (activity_seq_ != 0) THEN
      $IF (Component_Proj_SYS.INSTALLED) $THEN
          Activity_API.Validate_Activity_State(activity_seq_, action_);
      $ELSE
         NULL;
      $END
   END IF;
END Check_Activity_Seq___;


-- Check_Contract___
--   Contract will be validated to check whether the user is allowed to work in the particular site.
PROCEDURE Check_Contract___ (
   newrec_ IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE )      
IS
   check_user_allowed_site_ VARCHAR2(5) := true_;
BEGIN
                     
   IF (newrec_.transaction_code IN ('INTORDTR', 'UNINTORDTR', 'RINTORDTR', 'RINTOTRCOR', 'RINTORDTRX', 'INTREVR', 'INTCOSR', 'UNINTREVR', 'UNINTCOSR', 'RETINTPODS', 'RETPODIRSH', 'INVM-TRIN')) THEN
      check_user_allowed_site_ := false_;
   ELSIF (newrec_.transaction_code = 'ARRTRAN') THEN
      $IF (Component_Purch_SYS.INSTALLED) $THEN
         check_user_allowed_site_ := Purchase_Order_Line_Part_API.Check_Allowed_Site_On_Receipt(newrec_.source_ref1,
                                                                                                newrec_.source_ref2,
                                                                                                newrec_.source_ref3);
      $ELSE
         NULL;
      $END
   END IF;

   IF (check_user_allowed_site_ = true_) THEN
      User_Allowed_Site_API.Exist(Fnd_Session_API.Get_Fnd_User, newrec_.contract);
   END IF;

END Check_Contract___;


@Override
PROCEDURE Prepare_Insert___ (
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   super(attr_);
   Client_SYS.Add_To_Attr('CONTRACT',USER_ALLOWED_SITE_API.Get_Default_Site,attr_);
END Prepare_Insert___;


-- Insert___
--   Insert a new LU-instance into the database and return the values
--   for OBJID and OBJVERSION.
@Override
PROCEDURE Insert___ (
   objid_               OUT VARCHAR2,
   objversion_          OUT VARCHAR2,
   newrec_           IN OUT INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   attr_             IN OUT VARCHAR2,
   part_catalog_rec_ IN     Part_Catalog_API.Public_Rec DEFAULT NULL )
IS
   catch_unit_enabled_db_ VARCHAR2(5); 
BEGIN
   $IF Component_Proj_SYS.INSTALLED $THEN
      IF (newrec_.activity_seq != 0 AND newrec_.project_id IS NULL) THEN 
         newrec_.project_id := Activity_API.Get_Project_Id(newrec_.activity_seq);   
      END IF;   
   $END

   IF (newrec_.catch_quantity IS NOT NULL)  THEN
      IF (part_catalog_rec_.part_no IS NULL ) THEN 
         catch_unit_enabled_db_ := Part_Catalog_API.Get_Catch_Unit_Enabled_Db(newrec_.part_no);
      ELSE
         catch_unit_enabled_db_ := part_catalog_rec_.catch_unit_enabled;
      END IF;
      IF (catch_unit_enabled_db_ = false_) THEN
         newrec_.catch_quantity := NULL;
      END IF;
   END IF;

   IF (newrec_.catch_quantity IS NOT NULL)  THEN
      IF (newrec_.catch_quantity < 0) THEN
         CASE newrec_.direction
            WHEN '+' THEN newrec_.catch_direction  := '-';
            WHEN '-' THEN newrec_.catch_direction  := '+';
            ELSE newrec_.catch_direction           := '0';
         END CASE;
         newrec_.catch_quantity  :=  abs(newrec_.catch_quantity);
      ELSE
         newrec_.catch_direction := newrec_.direction;
      END IF;
   END IF;

   IF (newrec_.transit_location_group IS NULL) THEN
      newrec_.transit_location_group := newrec_.location_group;
   END IF;

   IF (newrec_.transaction_code IN ('OERET-INT','ARRTRAN','UNRC-ARRTR', 'SHIPODSIT+', 'SHIPODWHS+', 'UNR-SHPODW', 'UNR-SHPODS')) THEN
      newrec_.transit_location_group := 'INT ORDER TRANSIT';
   END IF;
   -- Sets the owning_customer_no columns null when part_ownership is not customer owned.
   -- Sets the owning_vendor_no null when part_ownership is not consignment, supplier loaned, supplier owned and supplier rented.
   IF (newrec_.part_ownership != Part_Ownership_API.DB_CUSTOMER_OWNED) THEN
      newrec_.owning_customer_no := NULL;
   END IF;

   IF (newrec_.part_ownership NOT IN (Part_Ownership_API.DB_CONSIGNMENT,
                                      Part_Ownership_API.DB_SUPPLIER_LOANED,
                                      Part_Ownership_API.DB_SUPPLIER_OWNED,
                                      Part_Ownership_API.DB_SUPPLIER_RENTED)) THEN
      newrec_.owning_vendor_no := NULL;
   END IF;

   IF (newrec_.part_ownership = Part_Ownership_API.DB_CONSIGNMENT) THEN
      newrec_.transaction_code := Mpccom_Transaction_Code_API.Get_Vendor_Consignment_Trans(newrec_.transaction_code);
   END IF;
   
   newrec_.expiration_date := TRUNC(newrec_.expiration_date);
   newrec_.date_created    := TRUNC(newrec_.date_time_created);
   newrec_.date_applied    := TRUNC(newrec_.date_time_created);
   
   Super(objid_, objversion_, newrec_, attr_);
   
   IF (((NVL(newrec_.source_ref_type,'COUNTING') = 'COUNTING') OR (newrec_.source_ref_type = Order_Type_API.DB_SHIPMENT_ORDER)) AND
       (NVL(newrec_.activity_seq,0) != 0)) THEN
      Pre_Accounting_API.Set_Project_Code_Part(newrec_.pre_accounting_id,
                                               Site_API.Get_Company(newrec_.contract),
                                               newrec_.contract,
                                               NULL,
                                               newrec_.project_id,
                                               newrec_.activity_seq,
                                               TRUE);
   END IF;

   IF ((Return_To_Vendor_For_Rework___(newrec_.transaction_code))  OR
       (Return_To_Vendor_For_Credit___(newrec_.transaction_code))  OR
       (Scrap_For_Credit___           (newrec_.transaction_code))) THEN
      Create_Return_Wip_Trans___(newrec_);
   END IF;
   
EXCEPTION
   WHEN dup_val_on_index THEN
      Error_SYS.Record_Exist(lu_name_);
END Insert___;


@Override
PROCEDURE Update___ (
   objid_                        IN     VARCHAR2,
   oldrec_                       IN     INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   newrec_                       IN OUT INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   attr_                         IN OUT VARCHAR2,
   objversion_                   IN OUT VARCHAR2,
   by_keys_                      IN     BOOLEAN DEFAULT FALSE,
   reapply_old_date_applied_     IN     BOOLEAN DEFAULT FALSE)
IS
   string_null_ VARCHAR2(12) := Database_Sys.string_null_;

BEGIN
   
   newrec_.expiration_date := TRUNC(newrec_.expiration_date);
   newrec_.date_applied    := TRUNC(newrec_.date_applied);

   IF ((newrec_.date_applied != oldrec_.date_applied) OR reapply_old_date_applied_) THEN
      newrec_.modify_date_applied_date := Site_API.Get_Site_Date(newrec_.contract);
      newrec_.modify_date_applied_user := Fnd_Session_API.Get_Fnd_User();
   END IF;

   -- Sets the owning_customer_no columns null when previous_part_ownership is not customer owned.
   -- Sets the owning_vendor_no null when previous_part_ownership is not consignment, supplier loaned, supplier owned and supplier rented.
   IF (NVL(newrec_.previous_part_ownership,string_null_) != Part_Ownership_API.DB_CUSTOMER_OWNED) THEN
      newrec_.previous_owning_customer_no := NULL;
   END IF;

   IF (NVL(newrec_.previous_part_ownership,string_null_) NOT IN (Part_Ownership_API.DB_CONSIGNMENT,
                                                                 Part_Ownership_API.DB_SUPPLIER_LOANED,
                                                                 Part_Ownership_API.DB_SUPPLIER_OWNED,
                                                                 Part_Ownership_API.DB_SUPPLIER_RENTED)) THEN
      newrec_.previous_owning_vendor_no := NULL;
   END IF;
   super(objid_, oldrec_, newrec_, attr_, objversion_, by_keys_);
   IF ((newrec_.date_applied != oldrec_.date_applied) OR reapply_old_date_applied_) THEN
      Handle_Modify_Date_Applied___(newrec_);
   END IF;
EXCEPTION
   WHEN dup_val_on_index THEN
      Error_SYS.Record_Exist(lu_name_);
END Update___;


FUNCTION Get_Cost_Group_Chg_Cleaned___ (
   transaction_id_      IN NUMBER,
   new_cost_detail_tab_ IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab )
                                                RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   old_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   match_found_         BOOLEAN;
BEGIN
   old_cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(
                                                                                  transaction_id_);
   IF (old_cost_detail_tab_.COUNT > 0) THEN
      FOR i_ IN old_cost_detail_tab_.FIRST..old_cost_detail_tab_.LAST LOOP
         match_found_ := FALSE;
         IF (new_cost_detail_tab_.COUNT > 0) THEN
            FOR j_ IN new_cost_detail_tab_.FIRST..new_cost_detail_tab_.LAST LOOP
               IF ((old_cost_detail_tab_(i_).accounting_year =
                                                      new_cost_detail_tab_(j_).accounting_year) AND
                   (old_cost_detail_tab_(i_).contract = new_cost_detail_tab_(j_).contract)      AND
                   (old_cost_detail_tab_(i_).cost_bucket_id =
                                                      new_cost_detail_tab_(j_).cost_bucket_id)  AND
                   (old_cost_detail_tab_(i_).company = new_cost_detail_tab_(j_).company)        AND
                   (old_cost_detail_tab_(i_).cost_source_id  =
                                                   new_cost_detail_tab_(j_).cost_source_id))   THEN
                  -- IF the same detail already exist in the transaction cost details then
                  -- update unit cost with the new value
                  old_cost_detail_tab_(i_).unit_cost := new_cost_detail_tab_(j_).unit_cost;
                  match_found_ := TRUE;
                  EXIT;
               END IF;
            END LOOP;
         END IF;
         IF (NOT match_found_) THEN
            -- The old cost details did not exist in the new details
            old_cost_detail_tab_(i_).unit_cost := 0;
         END IF;
      END LOOP;
   END IF;

   RETURN (old_cost_detail_tab_);
END Get_Cost_Group_Chg_Cleaned___;


PROCEDURE Set_Pre_Trans_Level_Qty___ (
   transaction_id_                IN NUMBER,
   pre_trans_level_qty_in_stock_  IN NUMBER,
   pre_trans_level_qty_in_transi_ IN NUMBER )
IS
   record_ inventory_transaction_hist_tab%ROWTYPE;
BEGIN
   record_                                := Lock_By_Keys___(transaction_id_);
   record_.pre_trans_level_qty_in_stock   := pre_trans_level_qty_in_stock_;
   record_.pre_trans_level_qty_in_transit := pre_trans_level_qty_in_transi_;
   Modify___(record_);
END Set_Pre_Trans_Level_Qty___;


PROCEDURE Add_To_Temporary_Table___ (
   transaction_id_ IN NUMBER )
IS
BEGIN

   INSERT INTO inventory_trans_hist_id_tmp
      (transaction_id)
   VALUES
      (transaction_id_);
END Add_To_Temporary_Table___;


PROCEDURE Load_Purch_Comp_Ship_Trans___ (
   source_ref_1_ IN VARCHAR2,
   source_ref_2_ IN VARCHAR2,
   source_ref_3_ IN VARCHAR2 )
IS
   CURSOR get_comp_shipment_transactions IS
      SELECT transaction_id
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE source_ref1        = source_ref_1_
         AND source_ref2        = source_ref_2_
         AND source_ref3        = source_ref_3_
         AND source_ref_type    = 'PUR ORDER'
         AND transaction_code IN ('PURSHIP', 'CO-PURSHIP',
                                  'PURBKFL', 'CO-PURBKFL',
                                  'PURDIR' , 'INTPURDIR')
         AND quantity - qty_reversed > 0
       UNION ALL
      SELECT transaction_id
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE alt_source_ref1      = source_ref_1_
         AND alt_source_ref2      = source_ref_2_
         AND alt_source_ref3      = source_ref_3_
         AND alt_source_ref_type  = 'PUR ORDER'
         AND transaction_code    IN ('OERET-NC','OERET-SPNC')
         AND quantity - qty_reversed > 0;
BEGIN

   FOR rec_ IN get_comp_shipment_transactions LOOP
      Add_To_Temporary_Table___(rec_.transaction_id);
   END LOOP;
END Load_Purch_Comp_Ship_Trans___;


FUNCTION Get_Purch_Component_Lines___ RETURN Source_Ref4_Tab
IS
   CURSOR get_purch_comp_lines IS
      SELECT DISTINCT source_ref4
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE transaction_code NOT IN ('OERET-NC','OERET-SPNC')
         AND transaction_id       IN (SELECT transaction_id
                                        FROM inventory_trans_hist_id_tmp);

   purch_comp_line_tab_ Source_Ref4_Tab;
BEGIN

   OPEN  get_purch_comp_lines;
   FETCH get_purch_comp_lines BULK COLLECT INTO purch_comp_line_tab_;
   CLOSE get_purch_comp_lines;

   RETURN (purch_comp_line_tab_);
END Get_Purch_Component_Lines___;


FUNCTION Get_Comp_Line_Wa_Cost_Tab___ (
  source_ref4_ IN NUMBER ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   CURSOR get_comp_line_value_details IS
      SELECT accounting_year, itc.contract, cost_bucket_id, company, cost_source_id,
             SUM((quantity - qty_reversed) * CASE transaction_code
                                                WHEN 'OERET-NC'   THEN unit_cost * -1
                                                WHEN 'OERET-SPNC' THEN unit_cost * -1
                                                ELSE unit_cost END) value
        FROM INVENTORY_TRANSACTION_HIST_TAB ith,
             inventory_transaction_cost_tab itc
       WHERE itc.transaction_id  = ith.transaction_id
         AND ith.transaction_id IN (SELECT transaction_id FROM inventory_trans_hist_id_tmp)
         AND (((transaction_code IN ('OERET-NC','OERET-SPNC')) AND
               (ith.alt_source_ref4 = source_ref4_)) OR
              (ith.source_ref4 = source_ref4_))
       GROUP BY accounting_year, itc.contract, cost_bucket_id, company, cost_source_id;

   CURSOR get_comp_line_shipped_quantity IS
      SELECT SUM(CASE transaction_code
                    WHEN 'OERET-NC'   THEN (quantity - qty_reversed) * -1
                    WHEN 'OERET-SPNC' THEN (quantity - qty_reversed) * -1
                    ELSE (quantity - qty_reversed) END) quantity
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE transaction_id IN (SELECT transaction_id FROM inventory_trans_hist_id_tmp)
         AND (((transaction_code IN ('OERET-NC','OERET-SPNC')) AND
               (alt_source_ref4 = source_ref4_)) OR
              (source_ref4 = source_ref4_));

   value_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   cost_detail_tab_  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   shipped_quantity_ INVENTORY_TRANSACTION_HIST_TAB.quantity%TYPE;
BEGIN

   OPEN  get_comp_line_shipped_quantity;
   FETCH get_comp_line_shipped_quantity INTO shipped_quantity_;
   CLOSE get_comp_line_shipped_quantity;

   IF (shipped_quantity_ > 0) THEN
      OPEN  get_comp_line_value_details;
      FETCH get_comp_line_value_details BULK COLLECT INTO value_detail_tab_;
      CLOSE get_comp_line_value_details;

      cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Value_To_Cost_Details(value_detail_tab_,
                                                                             shipped_quantity_);
   END IF;
   
   RETURN (cost_detail_tab_);
END Get_Comp_Line_Wa_Cost_Tab___;


FUNCTION Get_Purch_Comp_Qty_Required___ (
   source_ref_1_ IN VARCHAR2,
   source_ref_2_ IN VARCHAR2,
   source_ref_3_ IN VARCHAR2,
   source_ref_4_ IN NUMBER ) RETURN NUMBER
IS
   stmt_         VARCHAR2(200);
   qty_required_ NUMBER;
BEGIN

   stmt_ := 'BEGIN '                                                                             ||
               ':qty_required := Purchase_Component_Manager_API.Get_Qty_Required_In_Invent_Um( ' ||
                                                                               ':source_ref_1, ' ||
                                                                               ':source_ref_2, ' ||
                                                                               ':source_ref_3, ' ||
                                                                               ':source_ref_4); '||
            'END;';

   @ApproveDynamicStatement(2007-01-23,LEPESE)
   EXECUTE IMMEDIATE stmt_ USING
      OUT qty_required_,
       IN source_ref_1_,
       IN source_ref_2_,
       IN source_ref_3_,
       IN source_ref_4_;

   RETURN (qty_required_);
END Get_Purch_Comp_Qty_Required___;


PROCEDURE Clear_Temporary_Table___
IS
BEGIN

   DELETE FROM inventory_trans_hist_id_tmp;
END Clear_Temporary_Table___;


FUNCTION Get_Expect_Total_Comp_Value___ (
   source_ref_1_        IN VARCHAR2,
   source_ref_2_        IN VARCHAR2,
   source_ref_3_        IN VARCHAR2,
   po_line_qty_ordered_ IN NUMBER ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   comp_line_wa_unit_cost_tab_    Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   expected_total_comp_cost_tab_  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   expected_total_comp_value_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   comp_line_qty_per_assembly_    NUMBER;
   comp_line_qty_required_        NUMBER;
   purch_comp_line_tab_           Source_Ref4_Tab;
BEGIN

   Load_Purch_Comp_Ship_Trans___(source_ref_1_, source_ref_2_, source_ref_3_);

   purch_comp_line_tab_ := Get_Purch_Component_Lines___;

   IF (purch_comp_line_tab_.COUNT > 0) THEN
      FOR i IN purch_comp_line_tab_.FIRST..purch_comp_line_tab_.LAST LOOP
         comp_line_wa_unit_cost_tab_   := Get_Comp_Line_Wa_Cost_Tab___(
                                                             purch_comp_line_tab_(i));
         comp_line_qty_required_       := Get_Purch_Comp_Qty_Required___(
                                                             source_ref_1_,
                                                             source_ref_2_,
                                                             source_ref_3_,
                                                             purch_comp_line_tab_(i));
         comp_line_qty_per_assembly_   := comp_line_qty_required_ / po_line_qty_ordered_;
         expected_total_comp_cost_tab_ := Inventory_Part_Unit_Cost_API.Add_To_Value_Detail_Tab(
                                                                     expected_total_comp_cost_tab_,
                                                                     comp_line_wa_unit_cost_tab_,
                                                                     comp_line_qty_per_assembly_);
      END LOOP;
      expected_total_comp_value_tab_ := Inventory_Part_Unit_Cost_API.Cost_To_Value_Details(
                                                                     expected_total_comp_cost_tab_,
                                                                     po_line_qty_ordered_);
   END IF;

   Clear_Temporary_Table___;

   RETURN (expected_total_comp_value_tab_);
END Get_Expect_Total_Comp_Value___;


FUNCTION Get_Po_Line_Qty_Received___ (
   source_ref_1_ IN VARCHAR2,
   source_ref_2_ IN VARCHAR2,
   source_ref_3_ IN VARCHAR2 ) RETURN NUMBER
IS
   qty_received_  NUMBER := 0;   
   
   CURSOR get_qty_received IS
      SELECT NVL(SUM(quantity * (DECODE(transaction_code,'ARRIVAL', 1, 
                                                         'RETCORWORK',1,'PODIRSH', 1, -1))),0)
      FROM INVENTORY_TRANSACTION_HIST_TAB 
      WHERE (source_ref1    = source_ref_1_
         AND source_ref2     = source_ref_2_
         AND source_ref3     = source_ref_3_
         AND source_ref_type = 'PUR ORDER'
         AND part_ownership  = 'COMPANY OWNED'
         AND transaction_code IN ('ARRIVAL', 'RETWORK', 'RETCORWORK', 'UNRCPT-'))
         OR  (alt_source_ref1        = source_ref_1_
            AND alt_source_ref2     = source_ref_2_
            AND alt_source_ref3     = source_ref_3_
            AND source_ref_type     = 'CUST ORDER'
            AND alt_source_ref_type = 'CUSTOMER ORDER DIRECT'
            AND part_ownership      = 'COMPANY OWNED'
            AND transaction_code IN ('PODIRSH'));
            
BEGIN
   OPEN get_qty_received;
   FETCH get_qty_received INTO qty_received_; 
   CLOSE get_qty_received;

   RETURN (qty_received_);
END Get_Po_Line_Qty_Received___;


FUNCTION Get_Deducted_Cost_Details___ (
   cost_tab_to_be_deducted_ IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   cost_tab_to_deduct_      IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab )
                                                RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   deducted_cost_tab_           Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   total_value_to_deduct_       NUMBER;
   total_value_to_be_deducted_  NUMBER;
   deduction_factor_            NUMBER;
   positive_cost_diff_tab_      Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;       
   negative_cost_diff_tab_      Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
BEGIN

   IF ((Inventory_Part_Unit_Cost_API.Non_Star_Cost_Bucket_Exist(cost_tab_to_be_deducted_)) AND
       (cost_tab_to_deduct_.COUNT > 0)  AND
       (NOT Inventory_Part_Unit_Cost_API.Non_Star_Cost_Bucket_Exist(cost_tab_to_deduct_))) THEN

      total_value_to_deduct_      := Inventory_Part_Unit_Cost_API.Get_Total_Unit_Cost(
                                                                     cost_tab_to_deduct_);
      total_value_to_be_deducted_ := Inventory_Part_Unit_Cost_API.Get_Total_Unit_Cost(
                                                                     cost_tab_to_be_deducted_);
      deduction_factor_           := (total_value_to_be_deducted_ - total_value_to_deduct_) /
                                                         total_value_to_be_deducted_;
      deducted_cost_tab_          := cost_tab_to_be_deducted_;

      IF (deducted_cost_tab_.COUNT > 0) THEN
         FOR i IN deducted_cost_tab_.FIRST..deducted_cost_tab_.LAST LOOP
            deducted_cost_tab_(i).unit_cost := deducted_cost_tab_(i).unit_cost * deduction_factor_;
         END LOOP;
      END IF;
   ELSE
      Inventory_Part_Unit_Cost_API.Create_Cost_Diff_Tables(positive_cost_diff_tab_,
                                                           negative_cost_diff_tab_,
                                                           cost_tab_to_deduct_,
                                                           cost_tab_to_be_deducted_);
      deducted_cost_tab_ := Inventory_Part_Unit_Cost_API.Add_To_Value_Detail_Tab(positive_cost_diff_tab_,
                                                                                 negative_cost_diff_tab_,
                                                                                 (-1));
   END IF;

   IF (Inventory_Part_Unit_Cost_API.Get_Total_Unit_Cost(deducted_cost_tab_) < 0 ) THEN
      deducted_cost_tab_.DELETE;
   END IF;

   RETURN (deducted_cost_tab_);
END Get_Deducted_Cost_Details___;


PROCEDURE Reverse_Return_Wip_Trans___(
   return_transaction_id_         IN NUMBER,
   reverse_return_transaction_id_ IN NUMBER,
   quantity_                      IN NUMBER,
   catch_quantity_                IN NUMBER,
   source_                        IN VARCHAR2 )
IS
   unret_wip_transaction_id_  INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;
   return_wip_transaction_id_ INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;
BEGIN

   return_wip_transaction_id_ := Invent_Trans_Interconnect_API.Get_Connected_Transaction_Id(
                                                                             return_transaction_id_,
                                                                             'RETURN TO SUPPLIER');
   IF (return_wip_transaction_id_ IS NOT NULL) THEN
      Reverse_Transaction(unret_wip_transaction_id_,
                          'UNRET-WIP',
                          NULL,
                          NULL,
                          quantity_,
                          catch_quantity_,
                          return_wip_transaction_id_,
                          source_);

      Set_Original_Transaction_Id (unret_wip_transaction_id_,
                                                                  return_wip_transaction_id_);

      IF (reverse_return_transaction_id_ IS NOT NULL) THEN
         Invent_Trans_Interconnect_API.Connect_Transactions( reverse_return_transaction_id_,
                                                             unret_wip_transaction_id_,
                                                             'UNDO RETURN TO SUPPLIER');
      END IF;
   END IF;
END Reverse_Return_Wip_Trans___;


FUNCTION Scrap_In_Inventory___ (
   transaction_code_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   scrap_in_inventory_ BOOLEAN := FALSE;
BEGIN
   IF (transaction_code_ IN ('INVSCRAP','CO-SCRAP')) THEN
       scrap_in_inventory_ := TRUE;
   END IF;
   RETURN (scrap_in_inventory_);
END Scrap_In_Inventory___;


FUNCTION Get_Latest_Cancel_Trans_Id___ (
   original_transaction_id_ IN NUMBER ) RETURN NUMBER
IS
   latest_cancel_trans_id_ NUMBER;

   CURSOR get_latest_cancel_trans_id IS
      SELECT max(transaction_id)
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE original_transaction_id = original_transaction_id_;
BEGIN

   OPEN get_latest_cancel_trans_id;
   FETCH get_latest_cancel_trans_id INTO latest_cancel_trans_id_;
   CLOSE get_latest_cancel_trans_id;

   RETURN(latest_cancel_trans_id_);
END Get_Latest_Cancel_Trans_Id___;


PROCEDURE Set_Earlier_Date_Applied___ (
   transaction_id_       IN NUMBER, 
   earlier_date_applied_ IN DATE )
IS
   lu_rec_                   INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   old_date_applied_         INVENTORY_TRANSACTION_HIST_TAB.date_applied%TYPE;
   latest_failure_date_      INVENTORY_TRANSACTION_HIST_TAB.date_applied%TYPE;
   latest_success_date_      INVENTORY_TRANSACTION_HIST_TAB.date_applied%TYPE;
   dummy_string_             VARCHAR2(2000);
   date_applied_is_modified_ BOOLEAN := FALSE;
BEGIN

   lu_rec_              := Get_Object_By_Keys___(transaction_id_);
   old_date_applied_    := lu_rec_.date_applied;
   latest_success_date_ := lu_rec_.date_applied;
   lu_rec_.date_applied := earlier_date_applied_;
   latest_failure_date_ := earlier_date_applied_ - 1;

   LOOP
      EXIT WHEN lu_rec_.date_applied >= old_date_applied_;
      EXIT WHEN date_applied_is_modified_;

      BEGIN
         Check_Modify_Date_Applied___(lu_rec_, old_date_applied_);
         latest_success_date_ := lu_rec_.date_applied;

         IF (lu_rec_.date_applied = latest_failure_date_ + 1) THEN
            Modify_Date_Applied(dummy_string_, transaction_id_, lu_rec_.date_applied);
            date_applied_is_modified_ := TRUE;
         ELSE
            lu_rec_.date_applied := lu_rec_.date_applied - TRUNC(((lu_rec_.date_applied - latest_failure_date_) / 2));
         END IF;
      EXCEPTION
         WHEN OTHERS THEN
            latest_failure_date_ := lu_rec_.date_applied;
            IF (latest_success_date_ = lu_rec_.date_applied + 1) THEN
               lu_rec_.date_applied := lu_rec_.date_applied + 1;
            ELSE
               lu_rec_.date_applied := lu_rec_.date_applied + TRUNC(((latest_success_date_ - lu_rec_.date_applied) / 2));
            END IF;
      END;
   END LOOP;
END Set_Earlier_Date_Applied___;


PROCEDURE Reverse_Transaction___ (
   transaction_id_              OUT NUMBER,
   transaction_                 IN  VARCHAR2,
   pos_diff_transaction_        IN  VARCHAR2,
   neg_diff_transaction_        IN  VARCHAR2,
   quantity_                    IN  NUMBER,
   catch_quantity_              IN  NUMBER,
   old_transaction_id_          IN  NUMBER,
   source_                      IN  VARCHAR2,
   issue_mtrl_shop_order_split_ IN  BOOLEAN,
   new_issue_order_no_          IN  VARCHAR2,
   new_issue_release_no_        IN  VARCHAR2,
   new_issue_sequence_no_       IN  VARCHAR2,
   new_issue_line_item_no_      IN  NUMBER,
   validate_hu_struct_position_ IN  BOOLEAN DEFAULT TRUE )
IS
   transaction_id_tmp_            NUMBER;
   old_transaction_               INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   new_trans_rec_                 INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   part_rec_                      Inventory_Part_API.Public_Rec;
   transaction_code_              VARCHAR2(10);
   accounting_id_                 NUMBER;
   component_cost_                NUMBER;
   serial_message_                VARCHAR2(200);
   company_                       VARCHAR2(20);
   local_catch_quantity_          NUMBER;
   local_quantity_                NUMBER;
   old_trans_cost_detail_tab_     Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   old_trans_added_detail_tab_    Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   new_trans_cost_detail_tab_     Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   reject_code_                   VARCHAR2(8);
   prevent_fifo_action_           BOOLEAN := FALSE;
   allow_exceeding_available_qty_ BOOLEAN := FALSE;
   replace_star_cost_bucket_      BOOLEAN := TRUE;
   acquisition_site_              VARCHAR2(5);
BEGIN

   transaction_code_ := transaction_;
   old_transaction_  := Lock_By_Keys___(old_transaction_id_);

   IF (issue_mtrl_shop_order_split_) THEN
      old_transaction_.source_ref1  := new_issue_order_no_;
      old_transaction_.source_ref2  := new_issue_release_no_;
      old_transaction_.source_ref3  := new_issue_sequence_no_;
      old_transaction_.source_ref4  := new_issue_line_item_no_;
      local_quantity_               := old_transaction_.quantity;
      local_catch_quantity_         := old_transaction_.catch_quantity;
      prevent_fifo_action_ := TRUE;
      allow_exceeding_available_qty_ := TRUE;
   ELSE
      local_quantity_       := quantity_;
      local_catch_quantity_ := catch_quantity_;

      IF ((local_catch_quantity_ IS NULL) AND (local_quantity_ = old_transaction_.quantity)) THEN
         -- The complete transaction is reversed so we can use catch qty from the old transaction
         local_catch_quantity_ := old_transaction_.catch_quantity;
      END IF;
   END IF;

   company_  := Site_API.Get_Company(old_transaction_.contract);
   part_rec_ := Inventory_Part_API.Get(old_transaction_.contract, old_transaction_.part_no);
   
   -- Replacing '*' cost bucket with '110' (Estimated Material Cost) is valid only for inventory parts. 
   IF (part_rec_.part_no IS NULL) THEN
      replace_star_cost_bucket_ := FALSE;
   END IF;

   old_trans_cost_detail_tab_  := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(
                                                    transaction_id_           => old_transaction_id_,
                                                    include_added_details_    => FALSE,
                                                    include_normal_details_   => TRUE,
                                                    replace_star_cost_bucket_ => replace_star_cost_bucket_);
   
   old_trans_added_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(
                                                    transaction_id_           => old_transaction_id_,
                                                    include_added_details_    => TRUE,
                                                    include_normal_details_   => FALSE,
                                                    replace_star_cost_bucket_ => replace_star_cost_bucket_);

   IF (old_transaction_.direction = '-') THEN
      Validate_Subsequent_Trans___(old_transaction_.part_no, 
                                   old_transaction_.serial_no, 
                                   old_transaction_id_);
      Inventory_Part_In_Stock_API.Receive_Part(
                         transaction_id_              => transaction_id_tmp_,
                         contract_                    => old_transaction_.contract,
                         part_no_                     => old_transaction_.part_no,
                         configuration_id_            => old_transaction_.configuration_id,
                         location_no_                 => old_transaction_.location_no,
                         lot_batch_no_                => old_transaction_.lot_batch_no,
                         serial_no_                   => old_transaction_.serial_no,
                         eng_chg_level_               => old_transaction_.eng_chg_level,
                         waiv_dev_rej_no_             => old_transaction_.waiv_dev_rej_no,
                         activity_seq_                => NVL(old_transaction_.activity_seq, 0),
                         handling_unit_id_            => NVL(old_transaction_.handling_unit_id, 0),
                         transaction_                 => transaction_code_,
                         expiration_date_             => old_transaction_.expiration_date,
                         quantity_                    => local_quantity_,
                         catch_quantity_              => local_catch_quantity_,
                         quantity_reserved_           => 0,
                         order_no_                    => old_transaction_.source_ref1,
                         line_no_                     => old_transaction_.source_ref2,
                         release_no_                  => old_transaction_.source_ref3,
                         line_item_no_                => old_transaction_.source_ref4,
                         source_                      => source_,
                         value_                       => NULL,
                         cost_detail_tab_             => old_trans_cost_detail_tab_,
                         order_type_                  => Order_Type_API.Decode(old_transaction_.source_ref_type),
                         receive_correction_          => 'YES',
                         owning_vendor_no_            => old_transaction_.owning_vendor_no,
                         condition_code_              => NULL,
                         part_ownership_              => old_transaction_.part_ownership,
                         owning_customer_no_          => old_transaction_.owning_customer_no,
                         receipt_date_                => old_transaction_.receipt_date,
                         issue_transaction_id_        => old_transaction_id_,
                         availability_control_id_     => old_transaction_.availability_control_id,
                         deliv_no_                    => old_transaction_.source_ref5,
                         validate_hu_struct_position_ => validate_hu_struct_position_);

      reject_code_ := Get_Reject_Code(old_transaction_id_);
      IF transaction_ IN ('INVSCPCOR', 'SCPCREDCOR', 'RETCORWORK', 'RETCORWINT', 'RETCORCRE') THEN
         Set_Reject_Code___ (transaction_id_tmp_, reject_code_);
      END IF;

      IF (old_transaction_.part_ownership IN ('COMPANY OWNED', 'CONSIGNMENT')) THEN

         Revalue_Reverse_Transaction___(old_transaction_id_,
                                        transaction_id_tmp_,
                                        local_quantity_,
                                        pos_diff_transaction_,
                                        neg_diff_transaction_,
                                        company_);
      END IF;
   ELSIF (old_transaction_.direction = '+') THEN
      Validate_Subsequent_Trans___(old_transaction_.part_no, 
                                   old_transaction_.serial_no, 
                                   old_transaction_id_);
      IF ((part_rec_.inventory_valuation_method = 'ST') AND
          (old_transaction_.part_ownership IN ('COMPANY OWNED', 'CONSIGNMENT'))) THEN
         -- Retrive the current cost before the parts are issued as the issue might result
         -- in that the inventory part unit cost record is removed
         new_trans_cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                                         old_transaction_.contract,
                                                                         old_transaction_.part_no,
                                                                         old_transaction_.configuration_id,
                                                                         old_transaction_.lot_batch_no,
                                                                         old_transaction_.serial_no);

      END IF;
      Inventory_Part_In_Stock_API.Issue_Part(
               transaction_id_                =>  transaction_id_tmp_,
               catch_quantity_                =>  local_catch_quantity_,
               issue_correction_              =>  'YES',
               issue_corr_cost_detail_tab_    =>  old_trans_cost_detail_tab_,
               contract_                      =>  old_transaction_.contract,
               part_no_                       =>  old_transaction_.part_no,
               configuration_id_              =>  old_transaction_.configuration_id,
               location_no_                   =>  old_transaction_.location_no,
               lot_batch_no_                  =>  old_transaction_.lot_batch_no,
               serial_no_                     =>  old_transaction_.serial_no,
               eng_chg_level_                 =>  old_transaction_.eng_chg_level,
               waiv_dev_rej_no_               =>  old_transaction_.waiv_dev_rej_no,
               activity_seq_                  =>  NVL(old_transaction_.activity_seq, 0),
               handling_unit_id_              =>  NVL(old_transaction_.handling_unit_id, 0),
               transaction_                   =>  transaction_code_,
               quantity_                      =>  local_quantity_,
               quantity_reserved_             =>  0,
               source_ref1_                   =>  old_transaction_.source_ref1,
               source_ref2_                   =>  old_transaction_.source_ref2,
               source_ref3_                   =>  old_transaction_.source_ref3,
               source_ref4_                   =>  old_transaction_.source_ref4,
               source_ref5_                   =>  old_transaction_.source_ref5,
               source_                        =>  source_,
               source_ref_type_               =>  Order_Type_API.Decode(old_transaction_.source_ref_type),
               dest_contract_                 =>  NULL,
               destination_warehouse_id_      =>  NULL,
               original_transaction_id_       =>  old_transaction_id_,
               prevent_fifo_action_           =>  prevent_fifo_action_,
               allow_exceeding_available_qty_ =>  allow_exceeding_available_qty_ );

      IF (old_transaction_.part_ownership IN ('COMPANY OWNED', 'CONSIGNMENT')) THEN

         Revalue_Reverse_Transaction___(old_transaction_id_,
                                        transaction_id_tmp_,
                                        local_quantity_,
                                        pos_diff_transaction_,
                                        neg_diff_transaction_,
                                        company_);
      END IF;
      
      -- excluding externally owned stock
      IF ((old_transaction_.part_ownership IN ('COMPANY OWNED', 'CONSIGNMENT')) AND
          (part_rec_.inventory_valuation_method IN ('FIFO','LIFO'))) THEN

         IF (issue_mtrl_shop_order_split_) THEN
            Copy_Fifo_Lifo_Issues___(old_transaction_id_,
                                     transaction_id_tmp_,
                                     old_transaction_.contract,
                                     old_transaction_.part_no);
         END IF;
      END IF;
   ELSIF (old_transaction_.direction = '0') THEN
      IF (transaction_code_ IN ('RINTOTRCOR', 'UNINTORDTR')) THEN
         Undo_Move_To_Order_Transit___(transaction_id_tmp_,
                                       transaction_code_,
                                       local_quantity_,
                                       local_catch_quantity_,
                                       source_,
                                       pos_diff_transaction_,
                                       neg_diff_transaction_,
                                       old_transaction_,
                                       old_trans_cost_detail_tab_,
                                       part_rec_,
                                       company_);
      ELSE
         NEW(transaction_id_           => transaction_id_tmp_,
             accounting_id_            => accounting_id_,
             value_                    => component_cost_,
             transaction_code_         => transaction_code_,
             contract_                 => old_transaction_.contract,
             part_no_                  => old_transaction_.part_no,
             configuration_id_         => old_transaction_.configuration_id,
             location_no_              => old_transaction_.location_no,
             lot_batch_no_             => old_transaction_.lot_batch_no,
             serial_no_                => old_transaction_.serial_no,
             waiv_dev_rej_no_          => old_transaction_.waiv_dev_rej_no,
             eng_chg_level_            => old_transaction_.eng_chg_level,
             activity_seq_             => NVL(old_transaction_.activity_seq, 0),
             handling_unit_id_         => NVL(old_transaction_.handling_unit_id, 0),
             project_id_               => old_transaction_.project_id,
             source_ref1_              => old_transaction_.source_ref1,
             source_ref2_              => old_transaction_.source_ref2,
             source_ref3_              => old_transaction_.source_ref3,
             source_ref4_              => old_transaction_.source_ref4,
             source_ref5_              => old_transaction_.source_ref5,
             reject_code_              => old_transaction_.reject_code,
             cost_detail_tab_          => old_trans_cost_detail_tab_,
             unit_cost_                => NULL,
             quantity_                 => local_quantity_,
             qty_reversed_             => 0,
             catch_quantity_           => local_catch_quantity_,
             source_                   => source_,
             source_ref_type_          => Order_Type_API.Decode(old_transaction_.source_ref_type),
             owning_vendor_no_         => NULL,
             condition_code_           => old_transaction_.condition_code,
             location_group_           => old_transaction_.location_group,
             part_ownership_db_        => old_transaction_.part_ownership,
             owning_customer_no_       => old_transaction_.owning_customer_no,
             expiration_date_          => NULL,
             alt_source_ref1_          => old_transaction_.alt_source_ref1,
             alt_source_ref2_          => old_transaction_.alt_source_ref2,
             alt_source_ref3_          => old_transaction_.alt_source_ref3,
             alt_source_ref4_          => old_transaction_.alt_source_ref4,
             alt_source_ref_type_db_   => old_transaction_.alt_source_ref_type,
             old_transaction_id_       => old_transaction_id_);
         
         -- When undo direct delivery related transactions moving the goods back into transit will be done here.
         IF (transaction_code_ IN ('UNINTPODIR', 'UNINPODRIM')) THEN
            -- Update the transit object with the reversed quantity
            $IF Component_Purch_SYS.INSTALLED $THEN
               acquisition_site_ := Supplier_API.Get_Acquisition_Site(Purchase_Order_API.Get_Vendor_No(old_transaction_.alt_source_ref1)); 
            $END
            Inventory_Part_In_Transit_API.Unreceive_Part_To_Transit(delivering_contract_           => acquisition_site_,
                                                                    contract_                      => old_transaction_.contract,
                                                                    part_no_                       => old_transaction_.part_no,
                                                                    configuration_id_              => old_transaction_.configuration_id,
                                                                    lot_batch_no_                  => old_transaction_.lot_batch_no,
                                                                    serial_no_                     => old_transaction_.serial_no,
                                                                    eng_chg_level_                 => old_transaction_.eng_chg_level,
                                                                    waiv_dev_rej_no_               => old_transaction_.waiv_dev_rej_no,
                                                                    handling_unit_id_              => NVL(old_transaction_.handling_unit_id,0),
                                                                    expiration_date_               => old_transaction_.expiration_date,
                                                                    delivering_warehouse_id_       => '*',
                                                                    receiving_warehouse_id_        => '*',
                                                                    activity_seq_                  => 0 ,
                                                                    part_ownership_db_             => Part_Ownership_API.DB_COMPANY_OWNED,
                                                                    owning_customer_no_            => '*',
                                                                    owning_vendor_no_              => '*',
                                                                    deliv_no_                      => 0,
                                                                    shipment_id_                   => 0,
                                                                    shipment_line_no_              => 0,
                                                                    qty_to_unreceive_              => old_transaction_.quantity,
                                                                    catch_qty_to_unreceive_        => old_transaction_.catch_quantity,
                                                                    validate_hu_struct_position_   => FALSE);
         END IF;
      END IF;
   ELSE
      Error_SYS.Record_General('InventoryTransactionHist', 'ERRORDIRECTION: The given transaction :P1 can not be reversed due to error in direction (:P2).', old_transaction_.transaction_id, old_transaction_.direction );
   END IF;

   Reverse_Accounting(transaction_id_tmp_, old_transaction_id_);

   IF (issue_mtrl_shop_order_split_) THEN
      -- When we are creating an SOISS or a BACFLUSH because of a Shop Order Split
      -- then we should reset qty_reversed on the new transaction since
      -- it must be possible to reverse it later. We should also not try to update
      -- qty_reversed on the UNISS transaction either, because it is already indicated
      -- as fully reversed. Shop Order Split is an exception where we actually create
      -- the new issue transaction by reversing the previous unissue transaction.
      Modify_Qty_Reversed(transaction_id_tmp_, 0);
   ELSE
      Modify_Qty_Reversed(transaction_id_tmp_, local_quantity_);
      Modify_Qty_Reversed(old_transaction_id_, old_transaction_.qty_reversed + local_quantity_);
   END IF;

   new_trans_rec_ := Get_Object_By_keys___(transaction_id_tmp_);

   Create_Trans_Cost_Details___(transaction_id_tmp_,
                                old_trans_added_detail_tab_,
                                true_,
                                new_trans_rec_);

   transaction_id_ := transaction_id_tmp_;
   Trace_SYS.Message('Reverse_Transaction done');

   IF ((transaction_ IN ('SUNREC','RPSREC')) AND (old_transaction_.serial_no != '*')) THEN
      IF (Part_Serial_Catalog_API.Created_By(old_transaction_.part_no,
                                             old_transaction_.serial_no,
                                             old_transaction_.source_ref1,
                                             old_transaction_.source_ref2,
                                             old_transaction_.source_ref3,
                                             old_transaction_.source_ref4,
                                             old_transaction_.source_ref_type)) THEN
         Part_Serial_Catalog_API.Remove(old_transaction_.part_no,
                                        old_transaction_.serial_no);
      ELSE
         serial_message_ := substr(Get_Serial_Message___('PSCUNRCPTC'), 1, 200);
         Part_Serial_Catalog_API.Issue(old_transaction_.part_no,
                                       old_transaction_.serial_no,
                                       serial_message_,
                                       old_transaction_.source_ref1,
                                       old_transaction_.source_ref2,
                                       old_transaction_.source_ref3,
                                       old_transaction_.source_ref4,
                                       Order_Type_API.Decode(old_transaction_.source_ref_type),
                                       transaction_id_);
      END IF;
   END IF;
   IF transaction_ IN ('RETCORWORK', 'RETCORWINT', 'RETCORCRE', 'SCPCREDCOR') THEN
      Reverse_Return_Wip_Trans___(old_transaction_id_,
                                  transaction_id_,
                                  local_quantity_,
                                  catch_quantity_,
                                  source_);
      Add_Reverse_Return_Pwa_Diff___( part_rec_, old_transaction_, new_trans_rec_);                            
   END IF;
   IF ((transaction_ = 'CROUNREC') AND (old_transaction_.serial_no != '*')) THEN
      Reverse_Cro_Serial_Receipt___(old_transaction_, new_trans_rec_.transaction_id);
   END IF;
END Reverse_Transaction___;


FUNCTION Get_Order_Receipt_Serials___ (
   source_ref1_      IN VARCHAR2,
   source_ref2_      IN VARCHAR2,
   source_ref3_      IN VARCHAR2,
   source_ref4_      IN VARCHAR2,
   source_ref_type_  IN VARCHAR2,
   part_no_          IN VARCHAR2,
   serial_no_        IN VARCHAR2 ) RETURN Part_Serial_Catalog_API.Serial_No_Tab
IS
   purch_receipt_serial_tab_ Part_Serial_Catalog_API.Serial_No_Tab;

   CURSOR get_purch_receipt_serials IS
      SELECT serial_no
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE source_ref1              =  source_ref1_
         AND source_ref2              =  source_ref2_
         AND source_ref3              =  source_ref3_
         AND source_ref4              =  source_ref4_
         AND source_ref_type          =  source_ref_type_
         AND (quantity - qty_reversed) >  0
         AND serial_no                 != '*'
         AND (part_no                  =  part_no_   OR part_no_   IS NULL)
         AND (serial_no                =  serial_no_ OR serial_no_ IS NULL)
         AND transaction_code          IN ('ARRIVAL', 'ARRTRAN', 'CO-ARRIVAL', 'ARR-COMP',
                                           'SERLOTSWAP','PARTSWAP', 'SERIAL-IN', 'CO-SERIAL+',
                                           'SHIPODSIT+', 'SHIPODWHS+');
BEGIN
   OPEN  get_purch_receipt_serials;
   FETCH get_purch_receipt_serials BULK COLLECT INTO purch_receipt_serial_tab_;
   CLOSE get_purch_receipt_serials;

   RETURN (purch_receipt_serial_tab_);
END Get_Order_Receipt_Serials___;


FUNCTION Get_Order_Rec_Serial_Count___ (
   source_ref1_      IN VARCHAR2,
   source_ref2_      IN VARCHAR2,
   source_ref3_      IN VARCHAR2,
   source_ref4_      IN VARCHAR2,
   source_ref_type_  IN VARCHAR2,
   part_no_          IN VARCHAR2,
   serial_no_        IN VARCHAR2 ) RETURN NUMBER
IS
   receipt_serial_tab_ Part_Serial_Catalog_API.Serial_No_Tab;
BEGIN
   receipt_serial_tab_ := Get_Order_Receipt_Serials___(source_ref1_,
                                                       source_ref2_,
                                                       source_ref3_,
                                                       source_ref4_,
                                                       source_ref_type_,
                                                       part_no_,
                                                       serial_no_);
   RETURN (receipt_serial_tab_.COUNT);
END Get_Order_Rec_Serial_Count___;

-----------------------------------------------------------------------------------------------------
-- Add_Reverse_Return_Pwa_Diff___
--    Calculate the price diff and absorbed it into Cum Price Diff when cancelling the returns
--    of periodic weighted averages parts.
-----------------------------------------------------------------------------------------------------
PROCEDURE Add_Reverse_Return_Pwa_Diff___ (
   inventory_part_rec_       IN Inventory_Part_API.Public_Rec,
   original_trans_rec_       IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE,
   reversal_trans_rec_       IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE )
IS
   arrival_cost_  INVENTORY_TRANSACTION_HIST_TAB.original_amount%TYPE;
   dummy_number_  NUMBER;
   purchase_diff_ NUMBER;
   
   dummy_curr_amount_detail_tab_    Mpccom_Accounting_API.Curr_Amount_Detail_Tab;       
BEGIN
   IF ((original_trans_rec_.inventory_valuation_method = 'ST') AND
       (inventory_part_rec_.invoice_consideration      = 'PERIODIC WEIGHTED AVERAGE') AND
       (original_trans_rec_.transaction_code           IN ('RETWORK', 'RETCREDIT','SCPCREDIT'))) THEN

      Get_Arrival_Cost_Value_Qty___ (curr_amount_detail_tab_        => dummy_curr_amount_detail_tab_,
                                     cost_                          => arrival_cost_,
                                     value_                         => dummy_number_,
                                     qty_                           => dummy_number_,
                                     price_diff_                    => dummy_number_,                                        
                                     source_ref1_                   => original_trans_rec_.source_ref1,
                                     source_ref2_                   => original_trans_rec_.source_ref2,
                                     source_ref3_                   => original_trans_rec_.source_ref3,
                                     source_ref4_                   => original_trans_rec_.source_ref4,
                                     alt_source_ref1_               => NULL,
                                     alt_source_ref2_               => NULL,
                                     alt_source_ref3_               => NULL,
                                     alt_source_ref4_               => NULL,
                                     to_date_                       => TO_DATE(NULL),
                                     include_reversed_transactions_ => TRUE,
                                     serial_no_                     => NULL, 
                                     use_original_amounts_for_pwa_  => TRUE,
                                     fetch_curr_amount_details_     => FALSE,
                                     use_only_m10_postings_         => FALSE);

      purchase_diff_ := (arrival_cost_ * reversal_trans_rec_.quantity) -
                        ((Mpccom_Accounting_API.Get_Sum_Value(reversal_trans_rec_.accounting_id, 'M14') * -1) +
                         (Mpccom_Accounting_API.Get_Sum_Value(reversal_trans_rec_.accounting_id, 'M8') * -1) -
                          Mpccom_Accounting_API.Get_Sum_Value(reversal_trans_rec_.accounting_id, 'M9'));

      IF (purchase_diff_ != 0) THEN
         Inventory_Part_Config_API.Add_To_Purchase_Diff(reversal_trans_rec_.contract,
                                                        reversal_trans_rec_.part_no,
                                                        reversal_trans_rec_.configuration_id,
                                                        purchase_diff_);
      END IF;
   END IF;

END Add_Reverse_Return_Pwa_Diff___;

-- Consign_Consump_Trans_Exist___
--    Returns TRUE if there exists a Consignment Consumption transaction.
FUNCTION Consign_Consump_Trans_Exist___ (
   purch_order_ref1_ IN VARCHAR2,
   purch_order_ref2_ IN VARCHAR2,
   purch_order_ref3_ IN VARCHAR2,
   purch_order_ref4_ IN NUMBER ) RETURN BOOLEAN
IS
   dummy_                       NUMBER;
   consign_consump_trans_exist_ BOOLEAN := FALSE;

   CURSOR exist_control IS
      SELECT 1 
      FROM  INVENTORY_TRANSACTION_HIST_TAB
      WHERE source_ref1      = purch_order_ref1_
      AND   source_ref2      = purch_order_ref2_
      AND   source_ref3      = purch_order_ref3_
      AND   source_ref4      = purch_order_ref4_
      AND   transaction_code = 'COSUPCONSM'
      AND   source_ref_type  = 'PUR ORDER';
BEGIN
   Log_SYS.Stack_Trace_(Log_SYS.info_, 'Inventory_Transaction_Hist_API.Consign_Consump_Trans_Exist___');
   OPEN  exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      consign_consump_trans_exist_ := TRUE;
   END IF;
   CLOSE exist_control;
   RETURN (consign_consump_trans_exist_);
END Consign_Consump_Trans_Exist___;

-- Suppl_Consignment_Consumpt___
--    Returns TRUE if the transaction_code_ is supplier consignment consumption.
FUNCTION Suppl_Consignment_Consumpt___ (
   transaction_code_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   suppl_consignment_consumpt_ BOOLEAN := FALSE;
BEGIN
   Log_SYS.Stack_Trace_(Log_SYS.info_, 'Inventory_Transaction_Hist_API.Suppl_Consignment_Consumpt___');
   IF (transaction_code_ = 'COSUPCONSM') THEN
      suppl_consignment_consumpt_ := TRUE;
   END IF;
   RETURN (suppl_consignment_consumpt_);
END Suppl_Consignment_Consumpt___;
   
-- Unconsumed_Consign_Receipt___
--    When the transaction code is CO-ARRIVAL, this method will return TRUE if there does not exist 
--    any consignment consumption transaction.
FUNCTION Unconsumed_Consign_Receipt___ (
   trans_rec_ IN INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE ) RETURN BOOLEAN
IS
   unconsumed_consign_receipt_ BOOLEAN := FALSE;
   purch_order_ref1_           INVENTORY_TRANSACTION_HIST_TAB.source_ref1%TYPE;
   purch_order_ref2_           INVENTORY_TRANSACTION_HIST_TAB.source_ref2%TYPE;
   purch_order_ref3_           INVENTORY_TRANSACTION_HIST_TAB.source_ref3%TYPE;
   purch_order_ref4_           INVENTORY_TRANSACTION_HIST_TAB.source_ref4%TYPE;
BEGIN
   Log_SYS.Stack_Trace_(Log_SYS.info_, 'Inventory_Transaction_Hist_API.Unconsumed_Consign_Receipt___');
   IF (trans_rec_.transaction_code = 'CO-ARRIVAL') THEN
      Get_Purch_Order_Ref___(purch_order_ref1_,
                             purch_order_ref2_,
                             purch_order_ref3_,
                             purch_order_ref4_,
                             trans_rec_);
      IF NOT (Consign_Consump_Trans_Exist___(purch_order_ref1_, 
                                             purch_order_ref2_, 
                                             purch_order_ref3_, 
                                             purch_order_ref4_)) THEN
         unconsumed_consign_receipt_ := TRUE;
      END IF;
  END IF;
  RETURN (unconsumed_consign_receipt_);
END Unconsumed_Consign_Receipt___;

@Override
PROCEDURE Check_Insert___ (
   newrec_           IN OUT inventory_transaction_hist_tab%ROWTYPE,
   indrec_           IN OUT Indicator_Rec,
   attr_             IN OUT VARCHAR2,
   trancode_rec_     IN     Mpccom_Transaction_Code_API.Public_Rec DEFAULT NULL,
   part_catalog_rec_ IN     Part_Catalog_API.Public_Rec DEFAULT NULL,
   warehouse_id_     IN     VARCHAR2 DEFAULT NULL)
IS
BEGIN     
   IF (indrec_.transit_location_group AND newrec_.transit_location_group IS NOT NULL) THEN
      Inventory_Location_Group2_API.Exist(newrec_.transit_location_group);
   END IF;
   
   IF (newrec_.abnormal_demand IS NULL) THEN
      newrec_.abnormal_demand := false_;
   END IF; 
   
   super(newrec_, indrec_, attr_);

   Check_Contract___(newrec_);
   -- gelr: access_ctrl_for_inv_trans, start
   Check_Warehouse_Access___ (newrec_.userid, newrec_.contract, warehouse_id_, newrec_.transaction_code);
   -- gelr: access_ctrl_for_inv_trans, end

   Mpccom_Transaction_Code_API.Check_Part_Ownership_Db(newrec_.transaction_code,
                                                       newrec_.part_ownership);
   
   Check_Part_Ownership___(newrec_.transaction_code,
                           newrec_.part_ownership,
                           newrec_.owning_vendor_no,
                           newrec_.owning_customer_no);
                           
   Check_Part_Ownership_Transfer___(newrec_.contract, newrec_.transaction_code, newrec_.ownership_transfer_reason_id);

   IF (newrec_.report_earned_value IS NOT NULL) THEN
      IF (newrec_.activity_seq IS NULL) THEN
         Error_SYS.Record_General(lu_name_, 'EVACTIVITYSEQERROR: Activity Seq must be specified if reporting earned value');
      END IF;
      IF (newrec_.transaction_code NOT IN ('PROJTRAN+', 'CO-PRJTRN+', 'PROJTRAN-', 'CO-PRJTRN-')) THEN
         Error_SYS.Record_General(lu_name_, 'EVTRANSACTIONCODEERROR: Earned value cannot be reported for this type of Transaction code');
      END IF;
   END IF;

   Validate_Alt_Source_Ref___(newrec_.alt_source_ref1,
                              newrec_.alt_source_ref2,
                              newrec_.alt_source_ref3,
                              newrec_.alt_source_ref4,
                              newrec_.alt_source_ref_type);
   IF ((newrec_.transaction_code = 'OERET-NI') AND (NVL(newrec_.activity_seq,0) > 0))THEN
      Check_Activity_Seq___(newrec_.activity_seq, 'PROCESS_CO_RMA'); 
   END IF;

   Check_Serial_Tracking___(newrec_, trancode_rec_, part_catalog_rec_);

END Check_Insert___;


@Override
PROCEDURE Check_Update___ (
   oldrec_                       IN     inventory_transaction_hist_tab%ROWTYPE,
   newrec_                       IN OUT inventory_transaction_hist_tab%ROWTYPE,
   indrec_                       IN OUT Indicator_Rec,
   attr_                         IN OUT VARCHAR2,
   reapply_old_date_applied_     IN     BOOLEAN DEFAULT FALSE)
IS
   string_null_ VARCHAR2(12) := Database_Sys.string_null_;

BEGIN     
   IF (indrec_.previous_owning_vendor_no AND newrec_.previous_owning_vendor_no IS NOT NULL) THEN
      Check_Owning_Vendor_No___(newrec_.previous_owning_vendor_no);
   END IF;
          
   IF (indrec_.previous_owning_customer_no AND newrec_.previous_owning_customer_no IS NOT NULL) THEN
      Check_Owning_Customer_No___(newrec_.previous_owning_customer_no);
   END IF;
   super(oldrec_, newrec_, indrec_, attr_);
   Error_SYS.Check_Not_Null(lu_name_, 'DATE_APPLIED', newrec_.date_applied);
   Error_SYS.Check_Not_Null(lu_name_, 'PART_OWNERSHIP', newrec_.part_ownership);

   IF ((newrec_.qty_reversed != oldrec_.qty_reversed) OR (newrec_.quantity != oldrec_.quantity))THEN
      IF (newrec_.qty_reversed > newrec_.quantity) THEN
         Error_SYS.Record_General(lu_name_, 'REVQTYNOTALLOWED: Quantity reversed cannot be greater than original inventory transaction quantity. Transaction ID is :P1.', newrec_.transaction_id);
      END IF;
   END IF;

   IF ((oldrec_.transaction_code != newrec_.transaction_code) OR
       (oldrec_.contract         != newrec_.contract)         OR   
       NVL(oldrec_.source_ref1, string_null_)  != NVL(newrec_.source_ref1,    string_null_) OR
       NVL(oldrec_.source_ref2, string_null_)  != NVL(newrec_.source_ref2,  string_null_) OR
       NVL(oldrec_.source_ref3, string_null_)  != NVL(newrec_.source_ref3, string_null_)) THEN
      
      Check_Contract___(newrec_);
   END IF;
   
   IF (NVL(newrec_.previous_part_ownership,     string_null_)   != NVL(oldrec_.previous_part_ownership,     string_null_)) OR
      (NVL(newrec_.previous_owning_vendor_no,   string_null_)   != NVL(oldrec_.previous_owning_vendor_no,   string_null_)) OR
      (NVL(newrec_.previous_owning_customer_no, string_null_)   != NVL(oldrec_.previous_owning_customer_no, string_null_)) THEN
      Check_Part_Ownership___(newrec_.transaction_code,
                              newrec_.previous_part_ownership,
                              newrec_.previous_owning_vendor_no,
                              newrec_.previous_owning_customer_no);
   END IF;
   Validate_Alt_Source_Ref___(newrec_.alt_source_ref1,
                              newrec_.alt_source_ref2,
                              newrec_.alt_source_ref3,
                              newrec_.alt_source_ref4,
                              newrec_.alt_source_ref_type);

   IF (((oldrec_.alt_source_ref1 IS NOT NULL) AND (oldrec_.alt_source_ref1 != newrec_.alt_source_ref1)) OR
       ((oldrec_.alt_source_ref2 IS NOT NULL) AND (oldrec_.alt_source_ref2 != newrec_.alt_source_ref2)) OR
       ((oldrec_.alt_source_ref3 IS NOT NULL) AND (oldrec_.alt_source_ref3 != newrec_.alt_source_ref3)) OR
       ((oldrec_.alt_source_ref4 IS NOT NULL) AND (oldrec_.alt_source_ref4 != newrec_.alt_source_ref4)) OR
       ((oldrec_.alt_source_ref_type IS NOT NULL) AND (oldrec_.alt_source_ref_type != newrec_.alt_source_ref_type))) THEN
      Error_SYS.Record_General(lu_name_, 'ALTREFMODNOTALLOWED: Modification of Alternative Ref information is not allowed.' );
   END IF;

   IF (((oldrec_.alt_source_ref1 IS NOT NULL) AND (newrec_.alt_source_ref1 IS NULL)) OR
       ((oldrec_.alt_source_ref2 IS NOT NULL) AND (newrec_.alt_source_ref2 IS NULL)) OR
       ((oldrec_.alt_source_ref3 IS NOT NULL) AND (newrec_.alt_source_ref3 IS NULL)) OR
       ((oldrec_.alt_source_ref4 IS NOT NULL) AND (newrec_.alt_source_ref4 IS NULL)) OR
       ((oldrec_.alt_source_ref_type IS NOT NULL) AND (newrec_.alt_source_ref_type IS NULL)))  THEN
      Error_SYS.Record_General(lu_name_, 'ALTREFDELNOTALLOWED: Deletion of Alternative Ref information is not allowed.' );
   END IF;
   IF ((newrec_.date_applied != oldrec_.date_applied) OR reapply_old_date_applied_) THEN
      Check_Modify_Date_Applied___(newrec_, oldrec_.date_applied);
   END IF;
END Check_Update___;

PROCEDURE Check_Location_Group_Ref___ (
   newrec_ IN OUT inventory_transaction_hist_tab%ROWTYPE )
IS
BEGIN
  Inventory_Location_Group2_API.Exist(newrec_.location_group);
END Check_Location_Group_Ref___;

PROCEDURE Check_Owning_Vendor_No_Ref___ (
   newrec_ IN OUT inventory_transaction_hist_tab%ROWTYPE )
IS
BEGIN
  Check_Owning_Vendor_No___(newrec_.owning_vendor_no);
END Check_Owning_Vendor_No_Ref___;

PROCEDURE Check_Owning_Cust_No_Ref___ (
   newrec_ IN OUT inventory_transaction_hist_tab%ROWTYPE )
IS
BEGIN
  Check_Owning_Customer_No___(newrec_.owning_customer_no);
END Check_Owning_Cust_No_Ref___;

PROCEDURE Set_Fa_Object_Ref_On_Serial___ (
   contract_          IN VARCHAR2,                                          
   part_no_           IN VARCHAR2,
   serial_no_         IN VARCHAR2,
   part_ownership_db_ IN VARCHAR2,
   pre_accounting_id_ IN NUMBER )
IS
   fa_object_id_ VARCHAR2(10);
   company_      VARCHAR2(20);
BEGIN
   IF ((pre_accounting_id_ IS NOT NULL) AND (part_ownership_db_ = Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)) THEN
      company_      := Site_API.Get_Company(contract_);
      fa_object_id_ := Pre_Accounting_API.Get_Fa_Object_Id(company_, pre_accounting_id_);
      IF (fa_object_id_ IS NOT NULL) THEN 
         Part_Serial_Catalog_API.Set_Fa_Object_Reference(part_no_                     => part_no_,
                                                         serial_no_                   => serial_no_,
                                                         fa_object_company_           => company_,
                                                         fa_object_id_                => fa_object_id_,
                                                         fa_object_system_defined_db_ => Fnd_Boolean_API.DB_TRUE );
      END IF;                                                   
   END IF;
END Set_Fa_Object_Ref_On_Serial___;

-- Validate_Curr_Amount_Detail___
--   This method is used to validate the instances where unhandled currency rate information is stored in the curr_amount_detail_tab_ passed into the method.
PROCEDURE Validate_Curr_Amount_Detail___ (
      total_curr_amount_detail_tab_    Mpccom_Accounting_API.Curr_Amount_Detail_Tab)
IS

BEGIN
   IF (total_curr_amount_detail_tab_.COUNT > 0) THEN
      FOR i IN total_curr_amount_detail_tab_.FIRST..total_curr_amount_detail_tab_.LAST LOOP         
         IF total_curr_amount_detail_tab_(i).currency_code IS NULL THEN
            Error_SYS.Record_General(lu_name_, 'CURCINFMISM: Currency code information is missing on M10 postings in transaction');
         END IF;                           
      END LOOP;      
   END IF;
END Validate_Curr_Amount_Detail___;

PROCEDURE Get_Pwa_Curr_Info___ (
   trans_curr_amount_           OUT NUMBER,
   trans_curr_rate_             OUT NUMBER,
   company_                     IN  VARCHAR2,
   trans_currency_code_         IN  VARCHAR2,
   trans_curr_conv_factor_      IN  NUMBER,
   pwa_curr_amount_posting_tab_ IN  Mpccom_Accounting_API.Curr_Amount_Posting_Tab,
   bucket_posting_group_id_     IN  VARCHAR2,
   event_code_                  IN  VARCHAR2,
   base_curr_rate_is_inverted_  IN  VARCHAR2,
   value_                       IN  NUMBER,
   post_accum_curr_amt_for_pwa_ IN  BOOLEAN )
IS
   curr_rate_rounding_factor_    NUMBER;
   
BEGIN
   IF (post_accum_curr_amt_for_pwa_) THEN
      -- when the cost structure is changed between the invoice creation and running period weighted average
      -- the accumulative curr_amount must be posted in first posting line and rest of the posting lines must
      -- be created with curr_amount = 0
      trans_curr_amount_ := 0;
      FOR i IN pwa_curr_amount_posting_tab_.FIRST..pwa_curr_amount_posting_tab_.LAST LOOP
         trans_curr_amount_ := trans_curr_amount_ + pwa_curr_amount_posting_tab_(i).curr_amount;
      END LOOP;
   ELSE
      -- when there is no change in cost structure then the new posting lines must be created with old curr_amount(curr_amount at arrival)
      -- as the curr_amount differnce is posted at invoice.
      FOR i IN pwa_curr_amount_posting_tab_.FIRST..pwa_curr_amount_posting_tab_.LAST LOOP
         IF (trans_currency_code_ = pwa_curr_amount_posting_tab_(i).currency_code AND
            NVL(bucket_posting_group_id_, '*') = NVL(pwa_curr_amount_posting_tab_(i).bucket_posting_group_id, '*') AND
            event_code_ = pwa_curr_amount_posting_tab_(i).event_code) THEN
            trans_curr_amount_ := pwa_curr_amount_posting_tab_(i).curr_amount;
            EXIT;  
         END IF;   
      END LOOP;
   END IF;   
   IF (trans_curr_amount_ IS NOT NULL) THEN
      curr_rate_rounding_factor_ := Currency_Code_API.Get_Decimals_In_Rate(company_, trans_currency_code_);
      IF (base_curr_rate_is_inverted_ = 'FALSE') THEN
         trans_curr_rate_ := ROUND(((value_ * trans_curr_conv_factor_)/trans_curr_amount_), curr_rate_rounding_factor_);                    
      ELSE
         trans_curr_rate_ := ROUND(((trans_curr_amount_ * trans_curr_conv_factor_)/value_), curr_rate_rounding_factor_);
      END IF;
   END IF;   
END Get_Pwa_Curr_Info___;

-- This method checks whether the cost group postings are changed. This is used when creating currency amount postings
-- for Periodic Weighted Average parts.
FUNCTION Cost_Group_Changes_Exists___ (
   contract_                     IN VARCHAR2,
   part_no_                      IN VARCHAR2,
   pwa_curr_amount_posting_tab_  IN Mpccom_Accounting_API.Curr_Amount_Posting_Tab,
   new_cost_detail_tab_          IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab ) RETURN BOOLEAN
IS
   cost_group_changed_       BOOLEAN := FALSE;
   bucket_posting_group_id_  VARCHAR2(20);
   cost_bucket_public_type_  VARCHAR2(20);
   bucket_posting_grp_found_ BOOLEAN := FALSE;
   curr_amt_post_grp_count_  NUMBER := 0;
   
BEGIN
   IF (new_cost_detail_tab_.COUNT() > 0) THEN
      FOR i IN new_cost_detail_tab_.FIRST..new_cost_detail_tab_.LAST LOOP
         bucket_posting_grp_found_ := FALSE;
         curr_amt_post_grp_count_ := 0;
         Inventory_Transaction_Cost_API.Get_Cost_Bucket_Group_And_Type(bucket_posting_group_id_,
                                                                       cost_bucket_public_type_,
                                                                       contract_,
                                                                       new_cost_detail_tab_(i).cost_bucket_id,
                                                                       part_no_);
         IF (cost_bucket_public_type_ IS NULL OR cost_bucket_public_type_ = 'MATERIAL') THEN
            IF (pwa_curr_amount_posting_tab_.COUNT() > 0) THEN
               FOR j IN pwa_curr_amount_posting_tab_.FIRST..pwa_curr_amount_posting_tab_.LAST LOOP
                  IF (NVL(bucket_posting_group_id_, '*') = NVL(pwa_curr_amount_posting_tab_(j).bucket_posting_group_id, '*')) THEN
                     bucket_posting_grp_found_ := TRUE;
                     EXIT;
                  END IF;
               END LOOP;
            END IF;   
            IF (NOT bucket_posting_grp_found_) THEN
               cost_group_changed_ := TRUE;
               EXIT;
            END IF;
            curr_amt_post_grp_count_ := curr_amt_post_grp_count_ + 1;
         END IF;                                                                   
      END LOOP;
   END IF;   
   IF (bucket_posting_grp_found_ AND NOT cost_group_changed_) THEN
      -- when old cost group table contains all records same as new table + some more additional posting records are also exit.
      IF (curr_amt_post_grp_count_ != pwa_curr_amount_posting_tab_.COUNT()) THEN
         cost_group_changed_ := TRUE;
      END IF;   
   END IF;   
   RETURN cost_group_changed_;
END Cost_Group_Changes_Exists___;


PROCEDURE Do_Booking___ (
   transaction_id_              IN NUMBER,
   company_                     IN VARCHAR2,
   event_code_                  IN VARCHAR2,
   complete_flag_               IN VARCHAR2,
   external_value_tab_          IN Mpccom_Accounting_API.Value_Detail_Tab,
   value_adjustment_            IN BOOLEAN,
   adjustment_date_             IN DATE,
   per_oh_adjustment_id_        IN NUMBER,
   do_post_booking_actions_     IN BOOLEAN,
   periodic_weighted_avg_calc_  IN BOOLEAN,
   trans_reval_event_id_        IN NUMBER,
   pwa_curr_amount_posting_tab_ IN Mpccom_Accounting_API.Curr_Amount_Posting_Tab, 
   post_accum_curr_amt_for_pwa_ IN BOOLEAN )
IS
   basic_event_accounting_value_  NUMBER;
   po_exchange_event_acc_value_   NUMBER;
   dummy_                         VARCHAR2(80);
   basic_event_code_              VARCHAR2(10);
   basic_event_rec_               Accounting_Event_API.Public_Rec;
   tran_hist_rec_                 INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   date_applied_                  INVENTORY_TRANSACTION_HIST_TAB.date_applied%TYPE;
   no_postings                    EXCEPTION;
   separate_deliv_oh_             VARCHAR2(5) := false_;
   basic_event_deliv_oh_          BOOLEAN;
   material_overhead_             BOOLEAN;
   administration_addition_       BOOLEAN;
   pur_order_exchange_cost_exist_ BOOLEAN := FALSE;
   basic_deliv_oh_event_code_     VARCHAR2(10);
   row_no_                        PLS_INTEGER := 1;
   local_company_                 VARCHAR2(20);
   receipt_price_                 NUMBER;
   exchange_cost_                 NUMBER;
   other_                         CONSTANT VARCHAR2(5) := 'OTHER';
   delivery_overhead_type_        CONSTANT VARCHAR2(5) := 'DELOH';
   material_overhead_type_        CONSTANT VARCHAR2(5) := 'MATOH';
   sales_overhead_type_           CONSTANT VARCHAR2(7) := 'SALESOH';
   cascade_adjustment_            BOOLEAN;
   pur_order_charge_cost_exist_   BOOLEAN := FALSE;
   po_charge_event_acc_value_     NUMBER := 0;
   po_return_charge_value_        NUMBER := 0;
   po_return_charge_exist_        BOOLEAN := FALSE;
   detail_found_                  BOOLEAN;
   char_null_                     CONSTANT VARCHAR2(12) := 'VARCHAR2NULL';   
   control_type_key_rec_          Mpccom_Accounting_API.Control_Type_Key;   
   base_curr_rate_is_inverted_    VARCHAR2(5);
   base_curr_code_                VARCHAR2(3);
   base_curr_rate_                NUMBER;
   base_curr_conv_factor_         NUMBER;
   base_curr_type_                VARCHAR2(10);
   receipt_curr_code_             VARCHAR2(3);
   trans_curr_amount_             NUMBER;
   trans_curr_rate_               NUMBER;
   accum_curr_posted_for_pwa_     BOOLEAN := FALSE;

   TYPE Posting_Event_Rec IS RECORD (
      event_code VARCHAR2(10),
      value      NUMBER);

   TYPE Posting_Event_Tab IS TABLE OF Posting_Event_Rec INDEX BY PLS_INTEGER;
   posting_event_tab_ Posting_Event_Tab;

   CURSOR get_transaction_values IS
      SELECT   NVL(level_unit_cost,unit_cost) * quantity value,
               CASE cost_source_id WHEN '*' THEN NULL ELSE cost_source_id END cost_source_id,
               bucket_posting_group_id,
               CASE cost_bucket_public_type
                  WHEN delivery_overhead_type_ THEN
                     CASE separate_deliv_oh_ WHEN true_ THEN cost_bucket_public_type
                                                                                 ELSE other_ END
                  WHEN material_overhead_type_ THEN
                     CASE added_to_this_transaction WHEN true_ THEN cost_bucket_public_type
                                                                                 ELSE other_ END
                  WHEN sales_overhead_type_    THEN cost_bucket_public_type
                  ELSE other_ END cost_bucket_public_type
      FROM     inventory_transaction_cost_tab itc, INVENTORY_TRANSACTION_HIST_TAB ith
      WHERE    itc.transaction_id = ith.transaction_id
        AND    ith.transaction_id = transaction_id_
      UNION ALL
      SELECT   (unit_cost - level_unit_cost) * quantity value,
               CASE cost_source_id WHEN '*' THEN NULL ELSE cost_source_id END cost_source_id,
               bucket_posting_group_id,
               other_  cost_bucket_public_type
      FROM     inventory_transaction_cost_tab itc, inventory_transaction_HIST_tab ith
      WHERE    itc.transaction_id = ith.transaction_id
        AND    ith.transaction_id = transaction_id_
        AND    level_unit_cost IS NOT NULL;

   TYPE Posting_Value_Tab IS TABLE OF get_transaction_values%ROWTYPE
      INDEX BY PLS_INTEGER;
   posting_value_tab_      Posting_Value_Tab;
   temp_posting_value_tab_ Posting_Value_Tab;

   TYPE Transaction_Currency_Rec IS RECORD (  
      trans_currency_code     VARCHAR2(3),
      trans_currency_rate     NUMBER,
      trans_curr_conv_factor  NUMBER,
      trans_currency_rounding NUMBER );

   TYPE Transaction_Currency_Tab IS TABLE OF Transaction_Currency_Rec INDEX BY VARCHAR2(10);
   trans_curr_tab_  Transaction_Currency_Tab;

BEGIN
   tran_hist_rec_ := Lock_By_Keys___(transaction_id_);

   IF (event_code_ IS NULL) THEN
      basic_event_code_ := tran_hist_rec_.transaction_code;
   ELSE
      basic_event_code_ := event_code_;
      IF (tran_hist_rec_.part_ownership = Part_Ownership_API.DB_CONSIGNMENT) THEN
         -- This is a Consignment transaction that we make the bookings on so get the new
         -- event codes..
         basic_event_code_ := Mpccom_Transaction_Code_API.Get_Vendor_Consignment_Trans(basic_event_code_);
      END IF;
   END IF;

   IF (company_ IS NULL) THEN
      local_company_ := Site_API.Get_Company(tran_hist_rec_.contract);
   ELSE
      local_company_ := company_;
   END IF;
   IF (tran_hist_rec_.part_ownership IN (Part_Ownership_API.DB_SUPPLIER_LOANED, 
                                         Part_Ownership_API.DB_SUPPLIER_OWNED, 
                                         Part_Ownership_API.DB_CUSTOMER_OWNED, 
                                         Part_Ownership_API.DB_SUPPLIER_RENTED, 
                                         Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)) THEN
      RAISE no_postings;
   END IF;

   IF (adjustment_date_ IS NULL) THEN
      date_applied_ := tran_hist_rec_.date_applied;
   ELSE
      date_applied_ := adjustment_date_;
   END IF;

   IF (value_adjustment_ AND (per_oh_adjustment_id_ IS NULL)) THEN
      cascade_adjustment_ := TRUE;
   ELSE
      cascade_adjustment_:= FALSE;
   END IF;

   control_type_key_rec_ := Mpccom_Accounting_API.Set_Control_Type_Key(tran_hist_rec_.part_no,
                                                                       tran_hist_rec_.contract,
                                                                       transaction_id_,
                                                                       tran_hist_rec_.pre_accounting_id,
                                                                       tran_hist_rec_.activity_seq,
                                                                       tran_hist_rec_.source_ref_type,
                                                                       tran_hist_rec_.source_ref1,
                                                                       tran_hist_rec_.source_ref2,
                                                                       tran_hist_rec_.source_ref3,
                                                                       tran_hist_rec_.source_ref4 );

   basic_event_rec_ := Accounting_Event_API.Get(basic_event_code_);

   Get_Deliv_Overhead_Settings___(basic_event_deliv_oh_,
                                  basic_deliv_oh_event_code_,
                                  basic_event_code_,
                                  basic_event_rec_);

   IF (basic_event_deliv_oh_) THEN
      separate_deliv_oh_ := true_;
   END IF;

   IF (external_value_tab_.COUNT > 0) THEN
      FOR i IN external_value_tab_.FIRST..external_value_tab_.LAST LOOP
         temp_posting_value_tab_(i).value                   := external_value_tab_(i).value;
         temp_posting_value_tab_(i).cost_source_id          := external_value_tab_(i).cost_source_id;
         temp_posting_value_tab_(i).cost_bucket_public_type := other_;
         temp_posting_value_tab_(i).bucket_posting_group_id :=
                                                    external_value_tab_(i).bucket_posting_group_id;

         IF (temp_posting_value_tab_(i).cost_source_id = '*') THEN
            temp_posting_value_tab_(i).cost_source_id := NULL;
         END IF;
         IF (temp_posting_value_tab_(i).bucket_posting_group_id = '*') THEN
            temp_posting_value_tab_(i).bucket_posting_group_id := NULL;
         END IF;
      END LOOP;
   ELSE
      OPEN  get_transaction_values;
      FETCH get_transaction_values BULK COLLECT INTO temp_posting_value_tab_;
      CLOSE get_transaction_values;
   END IF;

   IF (temp_posting_value_tab_.COUNT = 0) THEN
      RAISE no_postings;
   END IF;

   base_curr_code_ :=  Company_Finance_API.Get_Currency_Code(local_company_);
   base_curr_rate_is_inverted_ := Currency_Code_API.Get_Inverted(local_company_, base_curr_code_);
   Currency_Rate_API.Get_Currency_Rate_Defaults(base_curr_type_,
                                                base_curr_conv_factor_,
                                                base_curr_rate_,
                                                local_company_,
                                                base_curr_code_,
                                                Site_API.Get_Site_Date(tran_hist_rec_.contract));
   -- merge temp_posting_value_tab_ into posting_value_tab_ this replaces cursor GROUP BY
   FOR i IN temp_posting_value_tab_.FIRST..temp_posting_value_tab_.LAST LOOP
      detail_found_ := FALSE;
      IF (posting_value_tab_.COUNT > 0) THEN
         FOR j IN posting_value_tab_.FIRST..posting_value_tab_.LAST LOOP
            IF ((NVL(temp_posting_value_tab_(i).bucket_posting_group_id,char_null_) =
                          NVL(posting_value_tab_(j).bucket_posting_group_id,char_null_)) AND
                (NVL(temp_posting_value_tab_(i).cost_bucket_public_type,char_null_) =
                          NVL(posting_value_tab_(j).cost_bucket_public_type,char_null_)) AND
                (NVL(temp_posting_value_tab_(i).cost_source_id,char_null_) =
                          NVL(posting_value_tab_(j).cost_source_id,char_null_))) THEN
               posting_value_tab_(j).value := posting_value_tab_(j).value +
                                                  temp_posting_value_tab_(i).value;
               detail_found_ := TRUE;
               EXIT;
            END IF;
         END LOOP;
      END IF;
      IF NOT (detail_found_) THEN
         posting_value_tab_(row_no_) := temp_posting_value_tab_(i);
         row_no_ := row_no_ + 1;
      END IF;
   END LOOP;

   temp_posting_value_tab_.DELETE;

   Get_Mtrl_Overhead_Settings___(material_overhead_, administration_addition_, basic_event_rec_);

   IF (basic_event_code_ IN ('ARRIVAL','RETWORK','RETCREDIT','SCPCREDIT')) THEN
      exchange_cost_ := Get_Pur_Order_Exchange_Cost___(tran_hist_rec_.source_ref1,
                                                       tran_hist_rec_.source_ref2,
                                                       tran_hist_rec_.source_ref3,
                                                       basic_event_code_);
      IF (exchange_cost_ > 0) THEN
         pur_order_exchange_cost_exist_ := TRUE;
         receipt_price_ := Inventory_Transaction_Cost_API.Get_Cost_Minus_Deliv_Overhead(
                                                                                  transaction_id_);
      END IF;
   END IF;

   IF (basic_event_code_ IN ('ARRIVAL', 'PODIRSH', 'PODIRINTEM', 'PURDIR', 'ARR-REPAIR')) THEN
      po_charge_event_acc_value_ := Get_Pur_Order_Charge_Cost___(tran_hist_rec_, basic_event_code_);
      IF ((po_charge_event_acc_value_ != 0) OR (value_adjustment_)) THEN
         pur_order_charge_cost_exist_ := TRUE;
      END IF;
   END IF;

   IF (basic_event_code_ IN ('RETWORK','RETCREDIT','SCPCREDIT', 'RETPODIRSH', 'RETPODSINT')) THEN
      IF (basic_event_code_ = 'RETPODIRSH') THEN
         po_return_charge_value_ := Get_Avg_Charge_On_Receipt(NULL,
                                                              NULL,
                                                              NULL,
                                                              NULL,
                                                              tran_hist_rec_.alt_source_ref1,
                                                              tran_hist_rec_.alt_source_ref2,
                                                              tran_hist_rec_.alt_source_ref3,
                                                              tran_hist_rec_.alt_source_ref4) * tran_hist_rec_.quantity;
      ELSE
         po_return_charge_value_ := Get_Avg_Charge_On_Receipt(tran_hist_rec_.source_ref1,
                                                              tran_hist_rec_.source_ref2,
                                                              tran_hist_rec_.source_ref3,
                                                              tran_hist_rec_.source_ref4,
                                                              NULL,
                                                              NULL,
                                                              NULL,
                                                              NULL) * tran_hist_rec_.quantity;
      END IF;

      IF ((po_return_charge_value_ != 0) OR (value_adjustment_)) THEN
         po_return_charge_exist_ := TRUE;
      END IF;
   END IF;

   FOR i IN posting_value_tab_.FIRST..posting_value_tab_.LAST  LOOP
      posting_event_tab_.DELETE;
      row_no_ := 1;

      IF (posting_value_tab_(i).cost_bucket_public_type = delivery_overhead_type_) THEN
         IF (basic_event_deliv_oh_) THEN
            posting_event_tab_(row_no_).event_code := basic_deliv_oh_event_code_;
            posting_event_tab_(row_no_).value      := posting_value_tab_(i).value;
            row_no_                                := row_no_ + 1;
         END IF;
      ELSIF (posting_value_tab_(i).cost_bucket_public_type = material_overhead_type_) THEN
         IF (material_overhead_) THEN
            posting_event_tab_(row_no_).event_code := 'MTRL-ADD';
         ELSIF (administration_addition_) THEN
            posting_event_tab_(row_no_).event_code := 'MS-ADD';
         ELSE
            Error_SYS.Record_General('InventoryTransactionHist', 'MATOHERR: An added material overhead cost detail exist on transaction :P1 although the posting event :P2 is not configured for material overhead or administration addition. Contact System Support.', transaction_id_, basic_event_code_);
         END IF;
         posting_event_tab_(row_no_).value := posting_value_tab_(i).value;
         row_no_                           := row_no_ + 1;
      ELSIF (posting_value_tab_(i).cost_bucket_public_type = sales_overhead_type_) THEN
         IF (basic_event_rec_.sales_overhead_flag = true_) THEN
            posting_event_tab_(row_no_).event_code := 'SALES-OH';
            posting_event_tab_(row_no_).value      := posting_value_tab_(i).value;
            row_no_                                := row_no_ + 1;
         END IF;
      ELSE
         basic_event_accounting_value_ := posting_value_tab_(i).value;

         IF (pur_order_exchange_cost_exist_) THEN
            IF (basic_event_code_ = 'ARRIVAL') THEN
               posting_event_tab_(row_no_).event_code := 'PO-EXCH';
            ELSIF (basic_event_code_ = 'RETWORK') THEN
               posting_event_tab_(row_no_).event_code := 'RETWOR-EX';
            ELSIF (basic_event_code_ IN ('RETCREDIT','SCPCREDIT')) THEN
               posting_event_tab_(row_no_).event_code := 'RETCRE-EX';
            ELSE
               Error_SYS.Record_General('InventoryTransactionHist', 'POEXCHERR: There is no posting event defined for booking the purchase exchange cost on transaction :P1. Contact System Support.', basic_event_code_);
            END IF;
            po_exchange_event_acc_value_      := (exchange_cost_ / receipt_price_) *
                                                                       posting_value_tab_(i).value;
            posting_event_tab_(row_no_).value := po_exchange_event_acc_value_;
            basic_event_accounting_value_     := basic_event_accounting_value_ -
                                                                      po_exchange_event_acc_value_;
            row_no_                           := row_no_ + 1;
         END IF;

         IF (pur_order_charge_cost_exist_) THEN
            IF (basic_event_code_ = 'ARRIVAL') THEN
               posting_event_tab_(row_no_).event_code := 'ARRCHG';
            ELSIF (basic_event_code_ = 'PODIRSH') THEN
               posting_event_tab_(row_no_).event_code := 'ARRCHG-DIR';
            ELSIF (basic_event_code_ = 'PODIRINTEM') THEN
               posting_event_tab_(row_no_).event_code := 'ARRCHGIDIR';
            ELSIF (basic_event_code_ = 'PURDIR') THEN
               posting_event_tab_(row_no_).event_code := 'PURDIR-CHG';
            ELSIF (basic_event_code_ = 'ARR-REPAIR') THEN
               posting_event_tab_(row_no_).event_code := 'ARRCHG-REP';
            END IF;
            posting_event_tab_(row_no_).value := po_charge_event_acc_value_;
            basic_event_accounting_value_     := basic_event_accounting_value_ - po_charge_event_acc_value_;
            row_no_                           := row_no_ + 1;
            pur_order_charge_cost_exist_      := FALSE;
         END IF;

         IF (po_return_charge_exist_) THEN
            IF (basic_event_code_ = 'RETPODIRSH') THEN
               posting_event_tab_(row_no_).event_code := 'RETARCHGDS';
            ELSE
               posting_event_tab_(row_no_).event_code := 'RET-CHARGE';
            END IF;
            posting_event_tab_(row_no_).value := po_return_charge_value_;
            basic_event_accounting_value_     := basic_event_accounting_value_ - po_return_charge_value_;
            row_no_                           := row_no_ + 1;
            po_return_charge_exist_           := FALSE;
         END IF;

         posting_event_tab_(row_no_).event_code := basic_event_code_;
         posting_event_tab_(row_no_).value      := basic_event_accounting_value_;
         row_no_                                := row_no_ + 1;
      END IF;

      FOR j IN posting_event_tab_.FIRST..posting_event_tab_.LAST LOOP
         IF NOT (trans_curr_tab_.EXISTS(posting_event_tab_(j).event_code)) THEN
            IF (Acc_Event_Posting_Type_API.Event_Code_Needs_Trans_Curr(posting_event_tab_(j).event_code)) THEN
               Get_Transaction_Curr_Info___(trans_curr_tab_(posting_event_tab_(j).event_code).trans_currency_code,
                                            trans_curr_tab_(posting_event_tab_(j).event_code).trans_currency_rate,
                                            trans_curr_tab_(posting_event_tab_(j).event_code).trans_curr_conv_factor,
                                            trans_curr_tab_(posting_event_tab_(j).event_code).trans_currency_rounding,
                                            tran_hist_rec_,
                                            local_company_,
                                            posting_event_tab_(j).event_code,
                                            (trans_reval_event_id_ IS NOT NULL));
               receipt_curr_code_ := trans_curr_tab_(posting_event_tab_(j).event_code).trans_currency_code;
            ELSE
               trans_curr_tab_(posting_event_tab_(j).event_code).trans_currency_code := NULL;
               trans_curr_tab_(posting_event_tab_(j).event_code).trans_currency_rate := NULL;
               trans_curr_tab_(posting_event_tab_(j).event_code).trans_curr_conv_factor := NULL;
               trans_curr_tab_(posting_event_tab_(j).event_code).trans_currency_rounding := NULL;           
            END IF;
         END IF;
         -- when pwa posting lines are created, if the posting control is linked with RNYI account the transaction curr amount should
         -- be stored with the same curr_amount as arrival since the diff in transaction currency is posted at invoice itself. But if
         -- the cost group postings are changed after arrival, when pwa postings are created the accumulated curr_amount must be posted
         -- in first posting line while the rest of the posting lines are created with curr_amount = 0.
         IF (periodic_weighted_avg_calc_ AND pwa_curr_amount_posting_tab_.COUNT() > 0) THEN
            IF (NOT accum_curr_posted_for_pwa_) THEN
               Get_Pwa_Curr_Info___(trans_curr_amount_,
                                    trans_curr_rate_,
                                    local_company_,
                                    trans_curr_tab_(posting_event_tab_(j).event_code).trans_currency_code,
                                    trans_curr_tab_(posting_event_tab_(j).event_code).trans_curr_conv_factor ,
                                    pwa_curr_amount_posting_tab_,
                                    posting_value_tab_(i).bucket_posting_group_id,
                                    posting_event_tab_(j).event_code,
                                    base_curr_rate_is_inverted_,
                                    posting_event_tab_(j).value,
                                    post_accum_curr_amt_for_pwa_);
               IF (post_accum_curr_amt_for_pwa_) THEN
                  accum_curr_posted_for_pwa_ := TRUE;
               END IF;   
               trans_curr_tab_(posting_event_tab_(j).event_code).trans_currency_rate := trans_curr_rate_;
            ELSE
               trans_curr_amount_ := 0;
               trans_curr_tab_(posting_event_tab_(j).event_code).trans_currency_rate := 0;
            END IF;   
         ELSE
            trans_curr_amount_ := NULL;
         END IF;   

         Do_Str_Event_Acc_Impl___(dummy_,
                                  local_company_,
                                  posting_event_tab_(j).event_code,
                                  tran_hist_rec_.accounting_id,
                                  'INVENTORY',
                                  posting_event_tab_(j).value,
                                  date_applied_,
                                  tran_hist_rec_.contract,
                                  value_adjustment_,
                                  tran_hist_rec_.userid,
                                  posting_value_tab_(i).cost_source_id,
                                  posting_value_tab_(i).bucket_posting_group_id,
                                  per_oh_adjustment_id_,
                                  control_type_key_rec_,
                                  trans_reval_event_id_,
                                  base_curr_code_,
                                  base_curr_rate_,
                                  base_curr_conv_factor_,
                                  base_curr_rate_is_inverted_,
                                  trans_curr_tab_(posting_event_tab_(j).event_code).trans_currency_code,
                                  trans_curr_tab_(posting_event_tab_(j).event_code).trans_currency_rate,
                                  trans_curr_tab_(posting_event_tab_(j).event_code).trans_curr_conv_factor,
                                  trans_curr_tab_(posting_event_tab_(j).event_code).trans_currency_rounding,
                                  trans_curr_amount_);
      END LOOP;
   END LOOP;

   IF (basic_event_code_ IN ('RETWORK', 'RETCREDIT', 'SCPCREDIT', 'RETPODIRSH')) THEN
      Post_Curr_Diff_After_Reval___(local_company_, tran_hist_rec_, receipt_curr_code_, date_applied_);
   END IF;

   IF (basic_event_code_ IN ('EXCH-SHIP','CO-EX-SHIP')) THEN
      Balance_Po_Exchange_Cost___(local_company_,
                                  tran_hist_rec_,
                                  date_applied_,
                                  value_adjustment_,
                                  per_oh_adjustment_id_,
                                  control_type_key_rec_,
                                  trans_reval_event_id_,
                                  base_curr_code_,
                                  base_curr_rate_,
                                  base_curr_conv_factor_,
                                  base_curr_rate_is_inverted_,
                                  trans_curr_tab_(basic_event_code_).trans_currency_code,
                                  trans_curr_tab_(basic_event_code_).trans_currency_rate,
                                  trans_curr_tab_(basic_event_code_).trans_curr_conv_factor,
                                  trans_curr_tab_(basic_event_code_).trans_currency_rounding);

   END IF;

   IF (basic_event_code_ IN ('ARRIVAL', 'XO-ARRIVAL', 'PODIRSH', 'PODIRINTEM')) THEN      
      Create_Price_Diff_Postings___(local_company_,
                                    tran_hist_rec_,
                                    date_applied_,
                                    value_adjustment_,
                                    per_oh_adjustment_id_,
                                    control_type_key_rec_,
                                    trans_reval_event_id_,
                                    base_curr_code_,
                                    base_curr_rate_,
                                    base_curr_conv_factor_,
                                    base_curr_rate_is_inverted_,
                                    trans_curr_tab_(basic_event_code_).trans_currency_code,
                                    trans_curr_tab_(basic_event_code_).trans_currency_rate,
                                    trans_curr_tab_(basic_event_code_).trans_curr_conv_factor,
                                    trans_curr_tab_(basic_event_code_).trans_currency_rounding);
   END IF;

   IF (basic_event_code_ IN ('RETWORK', 'RETCREDIT','SCPCREDIT')) THEN
      Create_Po_Return_Price_Diff___ (local_company_ ,
                                      tran_hist_rec_,
                                      date_applied_,
                                      value_adjustment_,
                                      per_oh_adjustment_id_,
                                      control_type_key_rec_,
                                      trans_reval_event_id_,
                                      base_curr_code_,
                                      base_curr_rate_,
                                      base_curr_conv_factor_,
                                      base_curr_rate_is_inverted_,
                                      trans_curr_tab_(basic_event_code_).trans_currency_code,
                                      trans_curr_tab_(basic_event_code_).trans_currency_rate,
                                      trans_curr_tab_(basic_event_code_).trans_curr_conv_factor,
                                      trans_curr_tab_(basic_event_code_).trans_currency_rounding);
   END IF;

   IF (basic_event_code_ = 'APPRINVSP') THEN      
      Create_Stage_Pay_Postings___(local_company_ ,
                                   tran_hist_rec_,
                                   date_applied_,
                                   value_adjustment_,
                                   per_oh_adjustment_id_,
                                   control_type_key_rec_,
                                   trans_reval_event_id_,
                                   base_curr_code_,
                                   base_curr_rate_,
                                   base_curr_conv_factor_,
                                   base_curr_rate_is_inverted_);
   END IF;

   End_Do_Booking___(basic_event_rec_.online_flag,
                     complete_flag_,
                     local_company_,
                     date_applied_,
                     tran_hist_rec_.accounting_id);

   IF ((basic_event_code_ IN ('PROJTRAN+','CO-PRJTRN+','PROJTRAN-','CO-PRJTRN-')) AND
       (NVL(tran_hist_rec_.activity_seq, 0) != 0)) THEN
      Handle_Activity_Transfer___(tran_hist_rec_.part_no,
                                  tran_hist_rec_.contract,
                                  tran_hist_rec_.activity_seq);
   END IF;

   IF do_post_booking_actions_ THEN
      -- Execute post booking actions if any
      Post_Booking_Actions___(tran_hist_rec_,
                              value_adjustment_,
                              cascade_adjustment_,
                              periodic_weighted_avg_calc_,
                              per_oh_adjustment_id_,
                              trans_reval_event_id_,
                              date_applied_);
   END IF;
EXCEPTION
   WHEN no_postings THEN
      End_Do_Booking___(basic_event_rec_.online_flag,
                        complete_flag_,
                        local_company_,
                        date_applied_,
                        tran_hist_rec_.accounting_id);

      IF do_post_booking_actions_ THEN
         -- Execute post booking actions if any
         Post_Booking_Actions___(tran_hist_rec_,
                                 value_adjustment_,
                                 cascade_adjustment_,
                                 periodic_weighted_avg_calc_,
                                 per_oh_adjustment_id_,
                                 trans_reval_event_id_,
                                 date_applied_);
      END IF;
   END Do_Booking___;   

   
PROCEDURE Undo_Ord_Direct_Del_Serials___ (
   transaction_code_       IN VARCHAR2,
   transaction_id_         IN NUMBER,
   old_transaction_id_     IN NUMBER,
   part_no_                IN VARCHAR2,
   serial_no_              IN VARCHAR2,
   source_ref1_            IN VARCHAR2,
   source_ref2_            IN VARCHAR2,
   source_ref3_            IN VARCHAR2,
   source_ref4_            IN VARCHAR2,
   source_ref_type_        IN VARCHAR2 )
IS
   serial_created_by_this_receip_   BOOLEAN := FALSE;   
   curr_operational_condition_db_   VARCHAR2(20);
   prev_operational_condition_db_   VARCHAR2(20);
   dummy_string_                    VARCHAR2(2000);
   prev_current_pos_                VARCHAR2(30); 
   serial_message_                  VARCHAR2(2000);
   serial_state_                    VARCHAR2(30);
BEGIN   
   IF (Part_Serial_Catalog_API.Exists(part_no_, serial_no_)) THEN            
         -- Find the previous state (current position) in Part Serial Catalog and restore this state.
         -- IF no previous state exists the individual did not exist before the register direct delivery,
         -- in this case the record should be removed
         IF (Part_Serial_History_API.Current_Position_Is_Changed(part_no_, serial_no_, old_transaction_id_)) THEN
            Error_SYS.Record_General(lu_name_, 'UNDOSERIALDIRDEL: Subsequent transactions on the serial part :P1 prevent the undo delivery.', serial_no_ );
         END IF;

         serial_created_by_this_receip_ := Part_Serial_Catalog_API.Created_By(part_no_,
                                                                              serial_no_,
                                                                              source_ref1_,
                                                                              source_ref2_,
                                                                              source_ref3_,
                                                                              source_ref4_,
                                                                              Order_Type_API.Encode(source_ref_type_));
         -- If this Serial no combination was originated from the same order delete the serials
         IF (serial_created_by_this_receip_) THEN              
            -- The serial did not exist before the PODIRSH transaction. Remove the record
            $IF Component_Vim_SYS.INSTALLED $THEN
               Vim_Serial_API.Remove_Serial(part_no_, serial_no_); 
            $END
            Part_Serial_Catalog_API.Remove(part_no_, serial_no_,  force_removal_ => TRUE );
         ELSE              
            curr_operational_condition_db_ := Part_Serial_Catalog_API.Get_Operational_Condition_Db(part_no_, serial_no_);
            prev_operational_condition_db_ := Part_Serial_History_API.Get_Operational_Condition_Db(old_transaction_id_);

            IF (curr_operational_condition_db_ != prev_operational_condition_db_) THEN
               Part_Serial_Catalog_API.Set_Operational_Condition(info_                     => dummy_string_,
                                                                 part_no_                  => part_no_,
                                                                 serial_no_                => serial_no_,
                                                                 operational_condition_db_ => prev_operational_condition_db_,
                                                                 update_structure_         => false_,
                                                                 validate_structure_       => true_,
                                                                 reversing_earlier_update_ => TRUE);
            END IF;
            serial_message_ := Get_Serial_Message___('PSCPODIRCH', source_ref1_, source_ref2_, source_ref3_);
            IF transaction_code_ = 'POUNDIRSH' THEN
               serial_state_ := Part_Serial_Catalog_API.Get_Objstate(part_no_, serial_no_);
               IF serial_state_ = 'Issued' THEN
                     Part_Serial_Catalog_API.Modify_Latest_Transaction(part_no_, serial_no_, serial_message_,
                                                                       serial_message_, 'INFO', source_ref_type_, source_ref1_,
                                                                       source_ref2_, source_ref3_, source_ref4_, transaction_id_);
               ELSE
                  prev_current_pos_ := Part_Serial_Catalog_API.Get_Previous_Current_Position(part_no_, serial_no_);               
                  IF prev_current_pos_ = 'ReturnedToSupplier' THEN
                     Part_Serial_Catalog_API.Return_To_Supplier(part_no_, serial_no_,
                                                             serial_message_,
                                                             source_ref1_,
                                                             source_ref2_,
                                                             source_ref3_,
                                                             source_ref4_,
                                                             source_ref_type_, transaction_id_); 
                  END IF;
               END IF;
            ELSE
               -- code for UNPODRINEM
               prev_current_pos_ := Part_Serial_Catalog_API.Get_Previous_Current_Position(part_no_, serial_no_);               
               CASE prev_current_pos_                              
                  WHEN 'UnderTransportation' THEN
                     Part_Serial_Catalog_API.Modify_Latest_Transaction(part_no_, serial_no_, serial_message_,
                                                                       serial_message_, 'INFO', source_ref_type_, source_ref1_,
                                                                       source_ref2_, source_ref3_, source_ref4_, transaction_id_);
                  WHEN 'Issued' THEN                  
                     Part_Serial_Catalog_API.Issue(part_no_, serial_no_,
                                                   serial_message_,
                                                   source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                                   source_ref_type_, transaction_id_);
                  WHEN 'ReturnedToSupplier' THEN
                     Part_Serial_Catalog_API.Return_To_Supplier(part_no_, serial_no_,
                                                                serial_message_,
                                                                source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                                                source_ref_type_, transaction_id_);
               END CASE;
            END IF;
         END IF;
      END IF;
   END Undo_Ord_Direct_Del_Serials___;
   
   PROCEDURE Get_Val_Qty_Bal_Invoice_Rnd___(
      curr_amount_detail_tab_    OUT Mpccom_Accounting_API.Curr_Amount_Detail_Tab,
      value_                     OUT NUMBER,
      qty_                       OUT NUMBER,
      price_diff_                OUT NUMBER,
      source_ref1_               IN  VARCHAR2,
      source_ref2_               IN  VARCHAR2,
      source_ref3_               IN  VARCHAR2,
      source_ref4_               IN  VARCHAR2,
      to_date_                   IN  DATE)
   IS
      cost_ NUMBER;
   BEGIN
      
      Get_Arrival_Cost_Value_Qty___ (curr_amount_detail_tab_        => curr_amount_detail_tab_,
                                     cost_                          => cost_,
                                     value_                         => value_,
                                     qty_                           => qty_,
                                     price_diff_                    => price_diff_,                                  
                                     source_ref1_                   => source_ref1_,
                                     source_ref2_                   => source_ref2_,
                                     source_ref3_                   => source_ref3_,
                                     source_ref4_                   => source_ref4_,
                                     alt_source_ref1_               => NULL,
                                     alt_source_ref2_               => NULL,
                                     alt_source_ref3_               => NULL,
                                     alt_source_ref4_               => NULL,
                                     to_date_                       => to_date_,
                                     include_reversed_transactions_ => TRUE,
                                     serial_no_                     => NULL, 
                                     use_original_amounts_for_pwa_  => TRUE,
                                     fetch_curr_amount_details_     => TRUE,
                                     use_only_m10_postings_         => TRUE);

   END Get_Val_Qty_Bal_Invoice_Rnd___;

PROCEDURE Validate_Subsequent_Trans___(part_no_         IN VARCHAR2,
                                       serial_no_       IN VARCHAR2,
                                       transaction_id_  IN NUMBER)
IS
BEGIN
   IF serial_no_ != '*' THEN
      IF (Part_Serial_History_API.Current_Position_Is_Changed (part_no_, 
                                                               serial_no_, 
                                                               transaction_id_)) THEN     
         Error_SYS.Record_General(lu_name_, 'UNDO_SERIAL_TRANSACTION: Subsequent transactions on this serial part prevent the reversal of this transaction.');
      END IF;
   END IF;   
END Validate_Subsequent_Trans___;

-- gelr:warehouse_journal, begin
PROCEDURE Modify_Delivery_Info___ (
   transaction_id_     IN NUMBER,
   alt_del_note_no_    IN VARCHAR2,
   delivery_reason_id_ IN VARCHAR2,
   del_note_date_      IN DATE,
   remove_del_info_    IN BOOLEAN DEFAULT FALSE)
IS
   oldrec_                       INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   newrec_                       INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
BEGIN
   oldrec_ := Lock_By_Keys___(transaction_id_);
   newrec_ := oldrec_;
   IF (alt_del_note_no_ IS NOT NULL OR remove_del_info_ = TRUE) THEN
      newrec_.alt_del_note_no    := alt_del_note_no_;
   END IF;
   IF (delivery_reason_id_ IS NOT NULL OR remove_del_info_ = TRUE) THEN
      newrec_.delivery_reason_id := delivery_reason_id_;
   END IF;
   IF (del_note_date_ IS NOT NULL OR remove_del_info_ = TRUE) THEN
      newrec_.del_note_date      := del_note_date_;
   END IF;  
   Modify___(newrec_);
END Modify_Delivery_Info___;
-- gelr:warehouse_journal, end
   
-------------------- LU SPECIFIC PRIVATE METHODS ----------------------------

-- Call_Lot_Batch_Master__
--   This method have chain of if checks, based on transaction that is being
--   recorded in transaction history which will call one of Lot Batch Master methods.
--   Private modify called from other LU:s. This to pass security-check.
PROCEDURE Call_Lot_Batch_Master__ (
   transaction_code_          IN VARCHAR2,
   contract_                  IN VARCHAR2,
   part_no_                   IN VARCHAR2,
   location_no_               IN VARCHAR2,
   lot_batch_no_              IN VARCHAR2,
   source_ref1_               IN VARCHAR2,
   source_ref2_               IN VARCHAR2,
   source_ref3_               IN VARCHAR2,
   source_ref4_               IN VARCHAR2,
   source_ref5_               IN VARCHAR2,
   reject_code_               IN VARCHAR2,
   source_ref_type_           IN VARCHAR2,
   dated_                     IN DATE,
   quantity_                  IN NUMBER,
   condition_code_            IN VARCHAR2,
   expiration_date_           IN DATE,
   handling_unit_id_          IN NUMBER,
   original_transaction_id_   IN NUMBER)
IS
   message_             VARCHAR2(2000);
   original_trans_code_ INVENTORY_TRANSACTION_HIST.transaction_code%TYPE;
   source_ref_type_db_  VARCHAR2(50);
   vendor_no_           Supplier_Info_Public.supplier_id%TYPE;
   co_ord_no_           VARCHAR2(12);
   order_type_mro_      VARCHAR2(5);
   durability_day_      NUMBER;
   potency_             NUMBER := 0;
   return_to_deliv_sup_ BOOLEAN := FALSE;
BEGIN

   original_trans_code_ := Mpccom_Transaction_Code_API.Get_Original_Transaction_Code(transaction_code_);
   source_ref_type_db_  := Order_Type_API.Encode(source_ref_type_);

   IF (original_trans_code_ IN ('OERET-INT','OERET-SINT', 'RETSHIPDIR', 'RETDIR-SCP')) THEN
      $IF Component_Order_SYS.INSTALLED $THEN
         co_ord_no_ := Return_Material_Line_API.Get_Order_No(source_ref1_, to_char(source_ref4_));            
      $ELSE
         NULL;    
      $END
   END IF;

   IF (original_trans_code_ IS NULL) THEN
      original_trans_code_ := transaction_code_;
   END IF;
      Trace_SYS.Field('transaction_code_',transaction_code_);
      Trace_SYS.Field('quantity_',quantity_);
   IF original_trans_code_ = 'NREC' THEN
      message_ := Get_Serial_Message___('PSCNREC', location_no_, null, null, null);
      Lot_Batch_Master_API.New_In_Inventory(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_, expiration_date_);
   ELSIF original_trans_code_ = 'NISS' THEN
      message_ := Get_Serial_Message___('PSCNISS', location_no_, null, null, null);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('INVSCRAP','SCPCREDIT') THEN
      message_ := Get_Serial_Message___('PSCINVSCRAP', Scrapping_Cause_API.Get_Reject_Message(reject_code_), null, null, null);
      Lot_Batch_Master_API.Scrap(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('INVSCPCOR','SCPCREDCOR') THEN
      message_ := Get_Serial_Message___('PSCINVSCPCOR', location_no_, null, null, null);
      Lot_Batch_Master_API.Unscrap(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('INVM-IN','CO-CONS-IN','CO-INVM-IN','INVM-COIN','COMPM-IN', 'WDR-IN', 'HANDLUNIT+', 'LOT-IN', 'CO-LOT-IN') THEN
      IF (original_trans_code_ = 'HANDLUNIT+') THEN
         message_ := Get_Serial_Message___('PSCHANDLUNIT', handling_unit_id_, null, null, null);
      ELSE
         message_ := Get_Serial_Message___('PSCINVMIN', location_no_, contract_, null, null);
      END IF;
      Lot_Batch_Master_API.Move_In_Inventory(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ = 'PICK-IN' THEN
      IF (source_ref_type_db_ = Order_Type_API.DB_SHIPMENT_ORDER) THEN
         message_ := Get_Serial_Message___('SHIPODPSCPICKIN', location_no_, contract_, source_ref1_, source_ref2_, source_ref3_);
      ELSE 
         message_ := Get_Serial_Message___('PSCPICKIN', location_no_, contract_, source_ref1_, source_ref2_, source_ref3_);
      END IF;
      Lot_Batch_Master_API.Move_In_Inventory(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('CRO-EXR-IN') THEN
      message_ := Get_Serial_Message___('PSCCROEXRIN', location_no_, contract_);     
      Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_, transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('INVM-TRIN','COMPM-TRIN') THEN
      message_ := Get_Serial_Message___('PSCINVMTRIN', location_no_, contract_);
      Lot_Batch_Master_API.Transport(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF (original_trans_code_ IN ('INVM-TRISS', 'SHIPODWHS-')) THEN
      IF (original_trans_code_ = 'INVM-TRISS') THEN
         message_ := Get_Serial_Message___('PSCINVMTRISS', location_no_, contract_);
      ELSE
         message_ := Get_Serial_Message___('PCSSHIPODSITWHS', source_ref1_, source_ref2_);
      END IF;   
      Lot_Batch_Master_API.Transport(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ = 'INVREC' THEN
      message_ := Get_Serial_Message___('PSCINVREC', location_no_, contract_);
      Lot_Batch_Master_API.Move_To_Inventory(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('WOISS', 'WTISS') THEN
      message_ := Get_Serial_Message___('PSCWOISS', source_ref_type_, source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('WOREPISS', 'WTREPISS') THEN
      message_ := Get_Serial_Message___('PSCWOREPISS', source_ref_type_, source_ref1_ || ' ' || source_ref2_ || ' ' || source_ref3_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('WOUNISS', 'WTUNISS') THEN
      message_ := Get_Serial_Message___('PSCWOUNISS', location_no_, source_ref_type_, source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_, transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('WORECEIPT', 'WTRECEIPT') THEN
      message_ := Get_Serial_Message___('LBMWORECEIPT', location_no_, source_ref_type_, source_ref1_, source_ref2_, source_ref3_);
      IF Lot_Batch_Master_API.Check_Exist(part_no_, lot_batch_no_) = true_ THEN
         Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
      ELSE
         Lot_Batch_Master_API.New_In_Inventory(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_, expiration_date_);
      END IF;  
   ELSIF original_trans_code_ = 'INTSHIP' THEN
      message_ := Get_Serial_Message___('PSCINTSHIP', source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ = 'INTUNISS' THEN
      message_ := Get_Serial_Message___('PSCINTUNISS', location_no_, source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ = 'PROJISS' THEN
      message_ := Get_Serial_Message___('PSCPROJISS', source_ref1_, source_ref4_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ = 'PROJREC' THEN
      message_ := Get_Serial_Message___('PSCPROJREC', location_no_, source_ref1_, source_ref4_);
      Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ = 'COUNT-OUT' THEN
      message_ := Get_Serial_Message___('PSCINVENTOUT', LTRIM(RTRIM(location_no_)));
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ = 'COUNT-IN' THEN
      message_ := Get_Serial_Message___('PSCINVENTIN', location_no_);
      IF Lot_Batch_Master_API.Check_Exist(part_no_, lot_batch_no_) = true_ THEN
         Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
      ELSE
         Lot_Batch_Master_API.New_In_Inventory(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_, expiration_date_);
      END IF;
   ELSIF original_trans_code_ IN ('ARRIVAL', 'CO-ARRIVAL','ARR-COMP','SERLOTSWAP','PARTSWAP') THEN
      message_ := Get_Serial_Message___('PSCARRIVAL', LTRIM(RTRIM(location_no_)), contract_);
      Lot_Batch_Master_API.New_In_Inventory(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_, expiration_date_);
   ELSIF original_trans_code_ IN  ('PURSHIP','PURBKFL') THEN
      vendor_no_ := Get_Purchase_Order_Vendor___(source_ref1_ );
      message_ := Get_Serial_Message___('PSCPURSHIP', vendor_no_, source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('UN-PURSHIP','UN-PURBKFL','PD-UNSHIP') THEN
      IF (original_trans_code_ = 'PD-UNSHIP') THEN
         message_ := Get_Serial_Message___('PSSPDUNSHIP', location_no_, source_ref1_, source_ref2_, source_ref3_);
      ELSE
         message_ := Get_Serial_Message___('PSCUNPURSHIP', location_no_, source_ref1_, source_ref2_, source_ref3_);
      END IF;
      Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('PURDIR', 'INTPURDIR') THEN
      vendor_no_ := Get_Purchase_Order_Vendor___(source_ref1_ );
      message_ := Get_Serial_Message___('PSCPURDIR', vendor_no_, source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_);
   ELSIF original_trans_code_ = 'EXCH-SHIP' THEN
      vendor_no_ := Get_Purchase_Order_Vendor___(source_ref1_ );
      message_ := Get_Serial_Message___('PSCEXCHSHIP', vendor_no_, source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('UNRCPT-') THEN
      IF Lot_Batch_Master_API.Check_Exist(part_no_, lot_batch_no_) = true_ THEN
         message_ := Language_SYS.Translate_Constant(lu_name_, 'LBMUNRCPT: Removed from location :P1 due to receipt reversal', NULL, location_no_);
         Lot_Batch_Master_API.Remove(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, original_transaction_id_ => original_transaction_id_);
      END IF;
   ELSIF original_trans_code_ IN ('UNRC-ARRTR') THEN
      message_ := Language_SYS.Translate_Constant(lu_name_, 'LBMUNRCARR: Removed from location :P1 due to receipt reversal of internal purchase order :P2', NULL, location_no_, source_ref1_ || ' ' || source_ref2_ || ' ' || source_ref3_);
      Lot_Batch_Master_API.Transport(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('UNR-SHPODS', 'UNR-SHPODW') THEN
      message_ := Language_SYS.Translate_Constant(lu_name_, 'LBMUNRSHPOD: Removed from location :P1 due to receipt reversal of shipment order :P2', NULL, location_no_, source_ref1_ || ' ' || source_ref2_ || ' ' || source_ref3_);
      Lot_Batch_Master_API.Transport(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('OERET-INT', 'RETSHIPDIR') THEN
      message_ := Get_Serial_Message___('PSCOERETINT', LTRIM(RTRIM(location_no_)), source_ref1_, source_ref4_, co_ord_no_);
      Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_);
   ELSIF original_trans_code_ IN ('OERET-SINT', 'RETDIR-SCP') THEN
      message_ := Get_Serial_Message___('PSCOERETINT', source_ref1_, source_ref4_, co_ord_no_, Scrapping_Cause_API.Get_Reject_Message(reject_code_));
      Lot_Batch_Master_API.Scrap(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_);
   ELSIF original_trans_code_ = 'RETCREDIT' THEN
      message_ := Get_Serial_Message___('PSCINVRETC');
      Lot_Batch_Master_API.Pending(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('RETWORK','RETWORKINT') THEN
      message_ := Get_Serial_Message___('PSCINVRETR');
      Lot_Batch_Master_API.Pending(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('RETCORWORK','RETCORWINT') THEN
      message_ := Get_Serial_Message___('PSCINVRETCCOR', location_no_);
      Lot_Batch_Master_API.Move_To_Inventory(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ = 'RETCORCRE' THEN
      message_ := Get_Serial_Message___('PSCINVRETRCOR', location_no_);
      Lot_Batch_Master_API.Move_To_Inventory(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('PODIRSH','INTPODIRSH') THEN
      message_ := Get_Serial_Message___('PSCPODIRCH', source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_);
   ELSIF original_trans_code_ IN ('POUNDIRSH','UNINTPODIR') THEN
      IF Lot_Batch_Master_API.Check_Exist(part_no_, lot_batch_no_) = true_ THEN
         message_ := Get_Serial_Message___('PSCPODIRCH', source_ref1_, source_ref2_, source_ref3_);
         Lot_Batch_Master_API.Remove(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, original_transaction_id_ => original_transaction_id_);
      END IF;
   ELSIF original_trans_code_ IN ('PODIRINTEM','INTPODIRIM') THEN
      message_ := Language_SYS.Translate_Constant(lu_name_, 'LBMPODIRINTEM: Issued on customer order :P1', NULL, source_ref1_ || ' ' || source_ref2_ || ' '|| source_ref3_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_);
   ELSIF original_trans_code_ IN ('UNPODRINEM','UNINPODRIM') THEN
      message_ := Language_SYS.Translate_Constant(lu_name_, 'LBMUNPODRINEM: Cancelled delivery on customer order :P1', NULL, source_ref1_ || ' ' || source_ref2_ || ' '|| source_ref3_);
      Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_);      
   -- EBALL, Added CRO-EXD-OU transaction code to the condition.
   ELSIF original_trans_code_ IN ('CO-DELV-OU') THEN
      message_ := Get_Serial_Message___('PSSHIPCOE', source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('CO-CONSUME') THEN
      Lot_Batch_Master_API.Consume_Customer_Consignment(lot_batch_no_, part_no_, contract_, dated_, quantity_, source_ref_type_db_,
                                                        source_ref1_, source_ref2_, source_ref3_, source_ref4_, potency_, condition_code_);
   ELSIF original_trans_code_ IN ('OESHIP','SHIPDIR','DELCONF-OU', 'CRO-EXD-OU') THEN
      message_ := Get_Serial_Message___('PSSHIPOE', source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ = 'UNSHIPDIR' THEN
      message_ := Get_Serial_Message___('PSCUNSHIPTRAN', source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('SHIPTRAN', 'SHIPODSIT-') THEN
      IF (original_trans_code_ = 'SHIPODSIT-') THEN
         message_ := Get_Serial_Message___('PCSSHIPODSITWHS', source_ref1_, source_ref2_);
      ELSE
         message_ := Get_Serial_Message___('PSCPODIRINTEM', source_ref1_, source_ref2_, source_ref3_);
      END IF;
      Lot_Batch_Master_API.Transport(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF (original_trans_code_ IN ('UNSHIPTRAN','UND-SHPODS','UND-SHPODW')) THEN
      IF (original_trans_code_ IN ('UND-SHPODS', 'UND-SHPODW')) THEN
         message_ := Get_Serial_Message___('PCSUNSHIPODSITWHS', location_no_, source_ref1_, source_ref2_);
      ELSE
         message_ := Get_Serial_Message___('PSCUNSHIPTRAN', source_ref1_, source_ref2_, source_ref3_);
      END IF;
      Lot_Batch_Master_API.Transport(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);   
   ELSIF original_trans_code_ = 'PURTRAN' THEN
      vendor_no_ := Get_Purchase_Order_Vendor___(source_ref1_ );
      message_ := Get_Serial_Message___('PSCPURSHIP', vendor_no_, source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);      
   ELSIF original_trans_code_ IN ('ARRTRAN', 'SHIPODSIT+', 'SHIPODWHS+') THEN
      IF (original_trans_code_ = 'ARRTRAN') THEN
         message_ := Get_Serial_Message___('PSCARRTRAN', LTRIM(RTRIM(location_no_)), contract_, source_ref1_, source_ref2_, source_ref3_);
      ELSIF (original_trans_code_ = 'SHIPODSIT+') THEN
         message_ := Get_Serial_Message___('PSCSHIPODSIT+', LTRIM(RTRIM(location_no_)), contract_, source_ref1_, source_ref2_);
      ELSE
         message_ := Get_Serial_Message___('PSCSHIPODWHS+', LTRIM(RTRIM(location_no_)), contract_, source_ref1_, source_ref2_);
      END IF;
      Lot_Batch_Master_API.Move_To_Inventory(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_);
   ELSIF original_trans_code_ IN ('OERETURN', 'OERET-EX', 'OERET-NC') THEN
      message_ := Get_Serial_Message___('PSCOERETURN', LTRIM(RTRIM(location_no_)), source_ref1_, source_ref4_);
      Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_);
   ELSIF (original_trans_code_ IN ('OERET-NO', 'RETDIFSREC')) THEN
      message_ := Get_Serial_Message___('PSCOERETURN', location_no_, source_ref1_, source_ref4_);
      Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_);
   ELSIF original_trans_code_ IN ('OERET-SCP', 'OERET-SPEX', 'OERET-SPNC') THEN
      message_ := Get_Serial_Message___('PSCINVSCRAP', Scrapping_Cause_API.Get_Reject_Message(reject_code_), null, null, null);    
      Lot_Batch_Master_API.Scrap(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_);
   ELSIF original_trans_code_ = 'OERET-SPNO' THEN
      -- to be implemented by Customer Order team
      NULL;
   ELSIF original_trans_code_ = 'RETDIFSSCP' THEN
      message_ := Language_SYS.Translate_Constant(lu_name_, 'RMASCP: Scrapped on return material authorization id :P1 due to :P2', NULL, source_ref1_ || ' ' || source_ref4_, Scrapping_Cause_API.Get_Reject_Message(reject_code_));
      Lot_Batch_Master_API.Scrap(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_);
   ELSIF original_trans_code_ = 'PICKSCRAP' THEN
      message_ := Get_Serial_Message___('PSCPICKSCRAP', location_no_, Scrapping_Cause_API.Get_Reject_Message(reject_code_));
      Lot_Batch_Master_API.Scrap(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('SOISS', 'BACFLUSH') THEN
      message_ := Get_Serial_Message___('PSCSOISS', source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_);
   ELSIF original_trans_code_ = 'UNISS' THEN
      message_ := Get_Serial_Message___('PSCUNISS', location_no_, source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ = 'OOREC' THEN
      message_ := Get_Serial_Message___('PSCOOREC', location_no_, source_ref1_, source_ref2_, source_ref3_);
      $IF Component_Shpord_SYS.INSTALLED $THEN
         order_type_mro_ := Shop_Ord_API.Is_Mro_Shop_Order(source_ref1_, source_ref2_, source_ref3_);
      $END
      IF (order_type_mro_ = true_) THEN
         durability_day_ := Inventory_Part_API.Get_Durability_Day(contract_, part_no_);
         Lot_Batch_Master_API.Receive_Mro_Shop_Order(part_no_, lot_batch_no_, contract_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_, potency_, durability_day_, condition_code_);
      ELSE
         Lot_Batch_Master_API.New_In_Inventory(part_no_,
                                               lot_batch_no_,
                                               contract_,
                                               source_ref_type_db_,
                                               source_ref1_, 
                                               source_ref2_, 
                                               source_ref3_, 
                                               source_ref4_,
                                               dated_,
                                               message_,
                                               quantity_,
                                               transaction_code_,
                                               potency_,
                                               condition_code_,
                                               expiration_date_);
      END IF;
   ELSIF original_trans_code_ = 'PSBKFL' THEN
      message_ := Get_Serial_Message___('PSCBKFL', source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('RPSBKFL','CO-RPSBKFL') THEN
      message_ := Get_Serial_Message___('PSCRPSBKFL', LTRIM(RTRIM(location_no_)), source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ = 'PSRECEIVE' THEN
      message_ := Get_Serial_Message___('PSCPSRECEIVE', LTRIM(RTRIM(location_no_)), source_ref1_, source_ref2_, source_ref3_);
      Lot_Batch_Master_API.New_In_Inventory(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_, expiration_date_);
   ELSIF original_trans_code_ = 'SUNREC' THEN
      message_ := Language_SYS.Translate_Constant(lu_name_, 'LBMSUNREC: Removed from location :P1 due to Shop Order receipt reversal', NULL, location_no_);
      $IF Component_Shpord_SYS.INSTALLED $THEN
         order_type_mro_ := Shop_Ord_API.Is_Mro_Shop_Order(source_ref1_, source_ref2_, source_ref2_);  
      $END
      IF (order_type_mro_ = true_) THEN
         Lot_Batch_Master_API.Unreceive_Mro_Shop_Order(part_no_, lot_batch_no_, contract_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_, potency_);
      ELSE
         Lot_Batch_Master_API.Remove(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
      END IF;
   ELSIF original_trans_code_ = 'RPSREC' THEN
      message_ := Language_SYS.Translate_Constant(lu_name_, 'LBMUNRCPT: Removed from location :P1 due to receipt reversal', NULL, location_no_);
      Lot_Batch_Master_API.Remove(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ = 'FAC2INV' THEN
      message_ := Get_Serial_Message___('LMBFAC2INV', location_no_);
      Lot_Batch_Master_API.Move_To_Inventory(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('WOREPREC', 'WTREPREC') THEN
      message_ := Get_Serial_Message___('LMBFAC2INV', location_no_);
      Lot_Batch_Master_API.Move_To_Inventory(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ = 'SERIAL-IN' THEN
      message_ := Language_SYS.Translate_Constant(lu_name_, 'LBMSERIALIN: Made individual :P1 on location :P2', NULL, lot_batch_no_, location_no_);
      Lot_Batch_Master_API.New_In_Inventory(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_, expiration_date_);
   ELSIF original_trans_code_ IN ('OPFEED-SCP','SODSPSCP') THEN
      message_ := Get_Serial_Message___('PSCINVSCRAP', Scrapping_Cause_API.Get_Reject_Message(reject_code_), null, null, null);
      Lot_Batch_Master_API.Scrap(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('UNOPFDSCP','UNSODSPSCP') THEN
      message_ := Get_Serial_Message___('PSCINVSCPCOR', Scrapping_Cause_API.Get_Reject_Message(reject_code_), null, null, null);
      Lot_Batch_Master_API.Unscrap(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF (original_trans_code_ = 'CROREC') THEN
      message_ := Language_SYS.Translate_Constant(lu_name_, 'LBMCROREC: Received into location :P1 from Component Repair Order :P2', NULL, location_no_, source_ref1_ || ' ' || source_ref2_);
      IF Lot_Batch_Master_API.Check_Exist(part_no_, lot_batch_no_) = true_ THEN
         Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
      ELSE
         Lot_Batch_Master_API.New_In_Inventory(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_, condition_code_, expiration_date_);
      END IF;
   ELSIF (original_trans_code_ = 'CROUNREC') THEN
      IF Lot_Batch_Master_API.Check_Exist(part_no_, lot_batch_no_) = true_ THEN
         message_ := Language_SYS.Translate_Constant(lu_name_, 'LBMCROUNREC: Removed from location :P1 due to receipt reversal of Component Repair Order :P2', NULL, location_no_, source_ref1_ || ' ' || source_ref2_);
         Lot_Batch_Master_API.Remove(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
      END IF;
   ELSIF original_trans_code_ = 'CRO-EX-SCR' THEN
      message_ := Language_SYS.Translate_Constant(lu_name_, 'LBMCROEXSCR: Scrapped at Customer due to :P1', NULL, Scrapping_Cause_API.Get_Reject_Message(reject_code_));
      Lot_Batch_Master_API.Scrap(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   -- EBALL, Added 'CRO-EXD-IN','CRO-EX-ARR', 'CRO-EX-DEL' and 'CRO-EXR-OU' .
   ELSIF (original_trans_code_ = 'RENTRET') THEN
      message_ := Get_Serial_Message___('PSCRENTRET', source_ref1_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('RETPODIRSH', 'RETINTPODS') THEN
      $IF Component_Order_SYS.INSTALLED $THEN
         return_to_deliv_sup_ := Return_Material_Line_API.Check_Return_To_Delivered_Sup(source_ref1_, source_ref4_);
      $END
      IF (return_to_deliv_sup_) THEN
         message_ := Get_Dirrettosup_Message___();
         Lot_Batch_Master_API.Pending(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
      END IF;
   ELSIF original_trans_code_ = 'RETPODSINT' THEN
      message_ := Get_Serial_Message___('DIRRETEXTSUP');    
      Lot_Batch_Master_API.Pending(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_, transaction_code_, potency_);   
    -- 151151 Added 'UNCODELVOU'
   ELSIF original_trans_code_ IN ('OEUNSHIP', 'UNDELCONOU','UNCODELVOU') THEN
      message_ := Language_SYS.Translate_Constant(lu_name_, 'CODELUNISS: Unissued into location :P1 from customer order :P2', NULL, location_no_, source_ref1_ || ' ' || source_ref2_ || ' ' || source_ref3_);
      Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ IN ('OWNTRANOUT') THEN
      message_ := Get_Serial_Message___('PSCNISS', location_no_, null, null, null);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   ELSIF original_trans_code_ = 'UNRCPT+' THEN
      Lot_Batch_Master_API.Unissue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_, transaction_code_, potency_, original_transaction_id_ => original_transaction_id_, create_lot_batch_history_ => FALSE);
   ELSIF original_trans_code_ = 'PD-SHIP' THEN
      message_ := Language_SYS.Translate_Constant(lu_name_, 'LBMPD-SHIP: Delivered on project_deliverables :P1', NULL, source_ref1_ || ' ' || source_ref2_ || ' ' || source_ref3_);
      Lot_Batch_Master_API.Issue(part_no_, lot_batch_no_, contract_, source_ref_type_db_, source_ref1_, source_ref2_, source_ref3_, source_ref4_, dated_, message_, quantity_,transaction_code_, potency_);
   -- 151151 Added 'UNCODELVIN'
   ELSIF original_trans_code_ IN ('INVREVAL+',  'INVREVAL-',  'CO-INVREV+', 'CO-INVREV-',
                                  'INVREVTR+',  'INVREVTR-',  'WDR-OUT',    'CO-WDR-OUT',
                                  'ARR-REPAIR', 'UNRCPT',     'ADDFAPOOL',  'SCRAPPOOL',
                                  'IMPFAPOOL',  'REMFAPOOL',  'REPFAPOOL',  'XO-TR-IN',
                                  'XO-TR-OUT',  'XO-ARRIVAL', 'XO-UNRCPT',  'REP-SCRAP',
                                  'UNREPSCRAP', 'SERIAL-OUT', 'INTORDTR',   'UNINTORDTR',
                                  'RINTORDTR',  'RINTOTRCOR', 'TRANSIBAL+', 'TRANSIBAL-', 
                                  'INTREV',     'INTREVR',    'INTCOS',     'INTCOSR',    
                                  'INTREV+',    'INTREV-',    'INTREVR+',   'INTREVR-',
                                  'UNINTREV',   'UNINTREVR',  'UNINTCOS',   'UNINTCOSR',
                                  'PROJTRAN-',  'PROJTRAN+',  'CO-PRJTRN-', 'CO-PRJTRN+',
                                  'POINV-WIP',  'CO-DELV-IN', 'OWNTRANOUT',
                                  'INVM-ISS',   'PICK-OUT',   'INVM-OUT',   'COMPM-OUT', 
                                  'OPFEED',     'DELIVCONF',  'DELCONF-IN', 'CONDCHG-',
                                  'CONDCHG+',   'CONDCHGTR-', 'CONDCHGTR+', 'CO-CONDCH-',
                                  'CO-CONDCH+', 'ROUNDDIFF+', 'ROUNDDIFF-', 'CO-UNPSHIP',
                                  'COSUPCONSM', 'CO-RETURN',  'COUNSUCONS', 'PCGCHG-',
                                  'PCGCHG+',    'PCGCHGTR-',  'PCGCHGTR+',  'CO-PCGCHG-',
                                  'CO-PCGCHG+', 'LOCGRP-',    'LOCGRP+',    'LOCGRPTR-',
                                  'PARTREN-',   'PARTREN+',   'SERREN-',    'SERREN+',
                                  'LOCGRPTR+',  'CO-LOCGRP-', 'CO-LOCGRP+', 'PSGENOH',
                                  'UNPSGENOH',  'RETWOR-WIP', 'RETCRE-WIP', 'CLEAR-WIP+',
                                  'CLEAR-WIP-', 'UNRET-WIP', 'RINTORDTRX' , 'CRO-EXD-IN', 'CRO-EX-ARR', 
                                  'CRO-EX-DEL', 'CRO-EXR-OU', 'CONDCHGCU+', 'CONDCHGCU-', 'COTOCRA+', 
                                  'COTOCRA-',   'CRATOCO+',   'CRATOCO-'  ,  'HANDLUNIT-',
                                  'UNR-SHPOD-', 'UNR-SHPOD+') THEN
      NULL;
   ELSE
      Error_SYS.Record_General('InventoryTransactionHist', 'INVLDLOTTRANS: Transaction code :P1 is not valid for Lot Batch Master. Contact system support', original_trans_code_);
   END IF;
END Call_Lot_Batch_Master__;


-- Check_Remove__
--   This method checks if a inventory part may be deleted.
PROCEDURE Check_Remove__ (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2 )
IS
   temp_ NUMBER;

   CURSOR check_exist IS
      SELECT 1 FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE (partstat_flag  = 'N' OR valuestat_flag = 'N')
      AND    configuration_id  = configuration_id_
      AND    contract          = contract_
      AND    part_no           = part_no_;
BEGIN
   OPEN check_exist;
   FETCH check_exist INTO temp_;
   IF (check_exist%FOUND) THEN
      CLOSE check_exist;
      Error_SYS.Record_General(lu_name_, 'TRANSACTION_EXISTS: References to inventory transactions exists. The record may not be removed.');
   END IF;
   CLOSE check_exist;
END Check_Remove__;


-- Check_Remove_Location_Group__
--   This method checks if a inventory location group may be deleted.
PROCEDURE Check_Remove_Location_Group__ (
   location_group_ IN VARCHAR2 )
IS
   temp_ NUMBER;

   CURSOR check_exist IS
      SELECT 1 FROM INVENTORY_TRANSACTION_HIST_TAB invtran, mpccom_accounting_pub accting
      WHERE invtran.location_group = location_group_
      AND   invtran.accounting_id  = accting.accounting_id
      AND   accting.status_code IN ('1','2','99');
BEGIN
   OPEN check_exist;
   FETCH check_exist INTO temp_;
   IF (check_exist%FOUND) THEN
      CLOSE check_exist;
      Error_SYS.Record_General(lu_name_, 'LOCGROPERR: The Inventory Location Group is used by at least one row in Inventory Transaction History. The record may not be removed.');
   END IF;
   CLOSE check_exist;
END Check_Remove_Location_Group__;


-- Check_Remove_Transit_Loc_Grp__
--   This method checks if a inventory location group may be deleted.
PROCEDURE Check_Remove_Transit_Loc_Grp__ (
   transit_location_group_ IN VARCHAR2 )
IS
   temp_ NUMBER;

   CURSOR check_exist IS
      SELECT 1 FROM INVENTORY_TRANSACTION_HIST_TAB invtran, mpccom_accounting_pub accting
      WHERE invtran.transit_location_group = transit_location_group_
      AND   invtran.accounting_id = accting.accounting_id
      AND   accting.status_code IN ('1','2','99');
BEGIN
   OPEN check_exist;
   FETCH check_exist INTO temp_;
   IF (check_exist%FOUND) THEN
      CLOSE check_exist;
      Error_SYS.Record_General(lu_name_, 'LOCGROPERR: The Inventory Location Group is used by at least one row in Inventory Transaction History. The record may not be removed.');
   END IF;
   CLOSE check_exist;
END Check_Remove_Transit_Loc_Grp__;

FUNCTION Get_Serial_Message___ (
   error_code_ VARCHAR2,
   param1_     VARCHAR2 DEFAULT NULL,
   param2_     VARCHAR2 DEFAULT NULL,
   param3_     VARCHAR2 DEFAULT NULL,
   param4_     VARCHAR2 DEFAULT NULL,
   param5_     VARCHAR2 DEFAULT NULL) RETURN VARCHAR2
IS
   serial_message_    VARCHAR2(2000);
BEGIN
   IF error_code_ = 'PSCOOREC' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCOOREC: Received into location :P1 from shop order :P2', NULL, param1_, param2_ || ' ' || param3_ || ' ' || param4_);
   ELSIF error_code_ = 'PSCNREC' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCNREC: Received into location :P1', NULL, param1_);
   ELSIF error_code_ = 'PSCNISS' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCNISS: Issued from location :P1', NULL, param1_);
   ELSIF error_code_ = 'PSCINVSCRAP' THEN    
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCINVSCRAP: Scrapped due to :P1', NULL, param1_);
   ELSIF error_code_ = 'PSCINVSCPCOR' THEN  
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCINVSCPCOR: Scrap correction into location :P1', NULL, param1_);
   ELSIF error_code_ = 'PSCHANDLUNIT' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCHANDLUNIT: Put into handling unit :P1', NULL, param1_);
   ELSIF error_code_ = 'PSCINVMIN' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCINVMIN: Moved to location :P1 at site :P2', NULL, param1_, param2_); 
   ELSIF error_code_ = 'PSCPICKIN' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCPICKIN: Moved to location :P1 at site :P2 for customer order :P3', NULL, param1_,param2_, param3_||' '||param4_||' '|| param5_);
   ELSIF error_code_ = 'SHIPODPSCPICKIN' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'SHIPODPSCPICKIN: Moved to location :P1 at site :P2 for shipment order :P3', NULL, param1_,param2_, param3_||' '||param4_||' '|| param5_);
   ELSIF error_code_ = 'PSCCROEXRIN' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCCROEXRIN: Returned from customer into location :P1 at site :P2', NULL, param1_, param2_);
   ELSIF error_code_ = 'PSCINVMTRIN' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCINVMTRIN: Under transport to location :P1 at site :P2', NULL, param1_, param2_);
   ELSIF error_code_ = 'PSCINVMTRISS' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCINVMTRISS: Moved to transport from location :P1 at site :P2', NULL, param1_, param2_);
   ELSIF error_code_ = 'PSCINVREC' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCINVREC: Received from transport into location :P1 at site :P2', NULL, param1_, param2_);
   ELSIF error_code_ IN ('PSCSHIPODSIT+', 'PSCSHIPODWHS+') THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCSHIPOD+: Received from transport into location :P1 at site :P2 for shipment order :P3', NULL, param1_, param2_, param3_||' '||param4_);
   ELSIF error_code_ = 'PSCWOISS' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCWOISS: Issued for :P1 :P2', NULL, param1_, param2_);
   ELSIF error_code_ = 'PSCWOISS2' THEN 
      -- PSCWOISS and PSCWOISS2 are same message but different parameters
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCWOISS: Issued for :P1 :P2', NULL, param1_, param2_ || ' ' || param3_ || ' ' || param4_);
   ELSIF error_code_ = 'PSCWOREPISS' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCWOREPISS: Issued for repair on :P1 :P2', NULL, param1_, param2_);
   ELSIF error_code_ = 'LMBFAC2INV' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'LMBFAC2INV: Moved into location :P1 from facility', NULL, param1_);  
   ELSIF error_code_ = 'PSCWOUNISS' THEN   
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCWOUNISS: Unissued into location :P1 from :P2 :P3', NULL, param1_, param2_, param3_||' '||param4_||' '|| param5_);  
   ELSIF error_code_ = 'PSCUNRCPTC' THEN    
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCUNRCPTC: Receipt Cancelled');  
   ELSIF error_code_ = 'PSCINTSHIP' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCINTSHIP: Issued for material requisition :P1', NULL, param1_||' '||param2_||' '|| param3_);
   ELSIF error_code_ = 'PSCINTUNISS' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCINTUNISS: Unissued into location :P1 from material requisition :P2', NULL, param1_, param2_||' '||param3_||' '|| param4_);
   ELSIF error_code_ = 'PSCPROJISS' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCPROJISS: Issued for project :P1', NULL, param1_||' '||param2_);
   ELSIF error_code_ = 'PSCPROJREC' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCPROJREC: Unissued into location :P1 from project :P2', NULL, param1_, param2_||' '||param3_);
   ELSIF error_code_ = 'PSCUNPURSHIP' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCUNPURSHIP: Returned to location :P1 on purchase order :P2', NULL, param1_, param2_||' '||param3_||' '|| param4_);
   ELSIF error_code_ = 'PSCINVENTOUT' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCINVENTOUT: Issued from location :P1 due to negative counting difference', NULL, param1_);
   ELSIF error_code_ = 'PSCINVENTIN' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCINVENTIN: Received into location :P1 due to positive counting difference', NULL, param1_);
   ELSIF error_code_ = 'PSCARRIVAL' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCARRIVAL: Received into location :P1 at site :P2', NULL, param1_, param2_);
   ELSIF error_code_ = 'PSCPURSHIP' THEN   
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCPURSHIP: Issued to supplier :P1 on purchase order :P2', NULL, param1_, param2_||' '||param3_||' '|| param4_);
   ELSIF error_code_ = 'PSCPURDIR' THEN  
      serial_message_     := Language_SYS.Translate_Constant(lu_name_, 'PSCPURDIR: Direct delivery to supplier :P1 on purchase order :P2', NULL, param1_, param2_||' '||param3_||' '|| param4_);
   ELSIF error_code_ = 'PSCEXCHSHIP' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCEXCHSHIP: Issued as exchange to supplier :P1 on purchase order :P2', NULL, param1_, param2_||' '||param3_||' '|| param4_);
   ELSIF error_code_ = 'PSCINVRETC' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCINVRETC: Returned to supplier for credit');
   ELSIF error_code_ = 'PSCINVRETR' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCINVRETR: Returned to supplier for rework');
   ELSIF error_code_ = 'DIRRETEXTSUP' THEN
      serial_message_     := Language_SYS.Translate_Constant(lu_name_, 'DIRRETEXTSUP: Direct Return to external supplier for credit');
   ELSIF error_code_ = 'PSCINVRETCCOR' THEN   
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCINVRETCCOR: Return from rework at supplier, into location :P1', NULL, param1_);
   ELSIF error_code_ = 'PSCINVRETRCOR' THEN    
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCINVRETRCOR: Return from credit at supplier, into location :P1', NULL, param1_);   
   ELSIF error_code_ = 'PSCPODIRCH' THEN    
      serial_message_     := Language_SYS.Translate_Constant(lu_name_, 'PSCPODIRCH: Direct Delivery for customer order :P1', NULL, param1_||' '||param2_||' '|| param3_);
   ELSIF error_code_ = 'PSCPODIRINTEM' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCPODIRINTEM: Issued for internal customer order :P1', NULL, param1_||' '||param2_||' '|| param3_);
   ELSIF error_code_ = 'PSSHIPCOE' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSSHIPCOE: Delivered on customer consignment stock order :P1', NULL, param1_||' '||param2_||' '|| param3_);
   ELSIF error_code_ = 'PSSHIPOE' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSSHIPOE: Delivered on customer order :P1', NULL, param1_||' '||param2_||' '|| param3_);
   ELSIF error_code_ = 'PSCUNSHIPTRAN' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCUNSHIPTRAN: Cancelled delivery on internal customer order :P1', NULL, param1_||' '||param2_||' '|| param3_);
   ELSIF error_code_ = 'PSCARRTRAN' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCARRTRAN: Received into location :P1 at site :P2 from internal purchase order :P3', NULL, param1_, param2_, param3_||' '||param4_||' '|| param5_);
   ELSIF error_code_ = 'PSCOERETINT' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCOERETINT: Returned to location :P1 from RMA :P2 and internal customer order :P3', NULL, LTRIM(RTRIM(param1_)), param2_||' '||param3_, param4_);
   ELSIF error_code_ = 'PSCOERETSINT' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCOERETSINT: Returned and scrapped from RMA :P1 and internal customer order :P2 due to :P3', NULL, param1_||' '||param2_,  param3_, param4_);
   ELSIF error_code_ = 'PSCPICKSCRAP' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCPICKSCRAP: Scrapped at shipment location :P1 due to :P2', NULL, param1_, param2_);
   ELSIF error_code_ = 'PSCSOISS' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCSOISS: Issued for shop order :P1', NULL, param1_||' '||param2_||' '|| param3_);
   ELSIF error_code_ = 'PSCUNISS' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCUNISS: Unissued into location :P1 from shop order :P2', NULL, param1_, param2_||' '||param3_||' '|| param4_);
   ELSIF error_code_ = 'PSCBKFL' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCBKFL: Issued for production schedule :P1', NULL, param1_||' '||param2_||' '|| param3_);
   ELSIF error_code_ = 'PSCRPSBKFL' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCRPSBKFL: Unissued into location :P1 from production schedule :P2', NULL, param1_, param2_||' '||param3_||' '|| param4_);
   ELSIF error_code_ = 'PSCPSRECEIVE' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCPSRECEIVE: Received into location :P1 from production schedule :P2', NULL, param1_, param2_||' '||param3_||' '|| param4_);
   ELSIF error_code_ = 'PSCRENTRET' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCRENTRET: Returned rental :P1 to supplier', NULL, param1_ );
   ELSIF error_code_ = 'PSCOERETURN' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSCOERETURN: Returned to location :P1 on return material authorization id :P2', NULL, param1_, param2_||' '|| param3_);
   ELSIF error_code_ = 'PSCWOREPREC' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'WOREPREC: Received into location :P1 from repair :P2 :P3', NULL, LTRIM(RTRIM(param1_)), param2_, param3_||' '||param4_||' '|| param5_);
   ELSIF error_code_ = 'LBMWORECEIPT' THEN
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'LBMWORECEIPT: Received into location :P1 from :P2 :P3', NULL, LTRIM(RTRIM(param1_)), param2_, param3_||' '||param4_||' '|| param5_);
   ELSIF error_code_ = 'PCSSHIPODSITWHS' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PCSSHIPODSITWHS: Issued for shipment order :P1', NULL, param1_||' '||param2_);   
   ELSIF error_code_ = 'PCSUNSHIPODSITWHS' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PCSUNSHIPODSITWHS: Returned to location :P1 on shipment order :P2', NULL, param1_, param2_||' '||param3_); 
   ELSIF error_code_ = 'PSSPDUNSHIP' THEN 
      serial_message_ := Language_SYS.Translate_Constant(lu_name_, 'PSSPDUNSHIP: Returned to location :P1 on project deliverables :P2', NULL, param1_, param2_||' '||param3_||' '||param4_);
   ELSE
      Error_SYS.Record_General(lu_name_, 'SERIALMESSAGEMISSING: Message Identifier :P1 not handled in method Get_Serial_Message___', error_code_);
   END IF;
   
RETURN serial_message_;
END Get_Serial_Message___;

-- gelr:warehouse_journal, begin
PROCEDURE Check_Deliv_Reason_Id_Ref___ (
   newrec_ IN OUT inventory_transaction_hist_tab%ROWTYPE )
IS
   company_  VARCHAR2(20);
BEGIN
   company_ := Site_API.Get_Company(newrec_.contract);
   Delivery_Reason_API.Exist(company_, newrec_.delivery_reason_id);
END Check_Deliv_Reason_Id_Ref___;
-- gelr:warehouse_journal, end

PROCEDURE Get_Site_And_Warehouse_Info___ (
   acquisition_site_        OUT VARCHAR2,
   delivering_warehouse_id_ OUT VARCHAR2,
   receiving_warehouse_id_  OUT VARCHAR2,
   source_ref1_             IN  VARCHAR2,
   source_ref_type_db_      IN  VARCHAR2)
IS
   $IF Component_Shipod_SYS.INSTALLED $THEN
      shipment_order_rec_  Shipment_Order_API.Public_Rec;
   $END
   warehouse_rec_  Warehouse_API.Public_Rec;
BEGIN
   IF (source_ref_type_db_ = Order_Type_API.DB_PURCHASE_ORDER) THEN
      $IF Component_Purch_SYS.INSTALLED $THEN
         acquisition_site_ := Supplier_API.Get_Acquisition_Site(Purchase_Order_API.Get_Vendor_No(source_ref1_));
         delivering_warehouse_id_ := '*';
         receiving_warehouse_id_  := '*'; 
      $ELSE
         Error_SYS.Component_Not_Exist('PURCH');
      $END
   ELSIF (source_ref_type_db_ = Order_Type_API.DB_SHIPMENT_ORDER) THEN 
      $IF Component_Shipod_SYS.INSTALLED $THEN
         shipment_order_rec_  := Shipment_Order_API.Get(source_ref1_);
         acquisition_site_    := shipment_order_rec_.sender_contract;

         IF (shipment_order_rec_.sender_type =  Sender_Receiver_Type_API.DB_REMOTE_WAREHOUSE)THEN 
            warehouse_rec_           := Warehouse_API.Get(shipment_order_rec_.sender_id);
            delivering_warehouse_id_ := warehouse_rec_.warehouse_id; 
         ELSE 
            delivering_warehouse_id_ := '*';
         END IF;

         IF (shipment_order_rec_.receiver_type =  Sender_Receiver_Type_API.DB_REMOTE_WAREHOUSE)THEN 
            warehouse_rec_          := Warehouse_API.Get(shipment_order_rec_.receiver_id);
            receiving_warehouse_id_ := warehouse_rec_.warehouse_id;  
         ELSE 
            receiving_warehouse_id_ := '*'; 
         END IF;
      $ELSE
         Error_SYS.Component_Not_Exist('SHIPOD');
      $END
   END IF;
END Get_Site_And_Warehouse_Info___;

-- gelr: access_ctrl_for_inv_trans, start
PROCEDURE Check_Warehouse_Access___ (
   user_id_          IN VARCHAR2,
   contract_         IN VARCHAR2,
   warehouse_id_     IN VARCHAR2,
   transaction_code_ IN VARCHAR2 )
IS
BEGIN
   IF ((warehouse_id_ IS NOT NULL) AND (transaction_code_ != 'INVM-TRIN')) THEN
      User_Warehouse_Access_API.Check_Invent_Trans_Allowed(user_id_, contract_, warehouse_id_);
   END IF;
END Check_Warehouse_Access___;
-- gelr: access_ctrl_for_inv_trans, end

-------------------- LU SPECIFIC PROTECTED METHODS --------------------------

-------------------- LU SPECIFIC PUBLIC METHODS -----------------------------

-- Get_Cost
--   Get the total cost of the transaction by adding up the cost for all
--   the details in Inventory_Transaction_Cost.
@UncheckedAccess
FUNCTION Get_Cost (
   transaction_id_ IN NUMBER ) RETURN NUMBER
IS
BEGIN
   RETURN (Inventory_Transaction_Cost_API.Get_Sum_Unit_Cost(transaction_id_));
END Get_Cost;


-- Get_Sum_Value_Per_Part
--   total value on periodic weigted average parts on 'M10' accounts.
@UncheckedAccess
FUNCTION Get_Sum_Value_Per_Part (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2,
   to_date_  IN DATE ) RETURN NUMBER
IS
   sum_value_per_part_ NUMBER;

   CURSOR get_sum_value_per_part IS
      SELECT NVL(SUM(CASE debit_credit WHEN 'D' THEN (value * -1) ELSE value END),0) value
        FROM INVENTORY_TRANSACTION_HIST_TAB ith, mpccom_accounting_pub ma
       WHERE  ith.contract      = contract_
         AND  ith.part_no       = part_no_
         AND (ith.date_applied <= to_date_ OR to_date_ IS NULL)
         AND  ith.accounting_id = ma.accounting_id
         AND (ma.date_applied  <= to_date_ OR to_date_ IS NULL)
         AND  ma.str_code      IN ('M10','M14','M18','M142','M155');
BEGIN
   OPEN  get_sum_value_per_part;
   FETCH get_sum_value_per_part INTO sum_value_per_part_;
   CLOSE get_sum_value_per_part;

   RETURN (sum_value_per_part_);

END Get_Sum_Value_Per_Part;


-- Clear_Onhand_Develop_Globals
--   Clear the cache of Calculate_Qty_Onhand_Date function
@UncheckedAccess
PROCEDURE Clear_Onhand_Develop_Globals
IS
BEGIN
   -- Clear global variables
   micro_cache_onh_dev_contract_    := NULL;
   micro_cache_onh_dev_part_no_     := NULL;
   micro_cache_onh_dev_config_id_   := NULL;
   micro_cache_onh_dev_filled_      := FALSE;
   micro_cache_onh_dev_time_        := 0;
   micro_cache_onh_dev_acc_qty_.DELETE;

END Clear_Onhand_Develop_Globals;


-- Refresh_Activity_Info
--   Used for calling calculate cost and progress information methods
--   in relevant modules.
PROCEDURE Refresh_Activity_Info (
   contract_                 IN VARCHAR2,
   accounting_id_            IN NUMBER  DEFAULT NULL,
   transfer_to_finance_      IN BOOLEAN DEFAULT FALSE,
   transfer_to_finance_date_ IN DATE    DEFAULT NULL)
IS  
  CURSOR get_source_ref IS
      SELECT DISTINCT source_ref1,
                      CASE source_ref_type
                         WHEN 'WORK ORDER' THEN '*'
                         WHEN 'WORK_TASK'  THEN '*'
                         WHEN 'PROJECT'    THEN '*'
                         ELSE source_ref2   END source_ref2,
                      CASE source_ref_type
                         WHEN 'WORK ORDER' THEN '*'
                         WHEN 'WORK_TASK'  THEN '*'
                         ELSE source_ref3  END source_ref3,
                      CASE source_ref_type
                         WHEN 'WORK ORDER' THEN '0'
                         WHEN 'WORK_TASK'  THEN '0'
                         WHEN 'PROJECT'    THEN '0'
                         WHEN 'SHOP ORDER' THEN '0'
                         WHEN 'PUR ORDER'  THEN '0'
                         ELSE source_ref4 END source_ref4,
                      source_ref_type
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE transaction_code NOT IN ('PROJTRAN+','CO-PRJTRN+','PROJTRAN-','CO-PRJTRN-')
         AND accounting_id IN ( SELECT accounting_id
                                  FROM mpccom_accounting_id_tmp);

  CURSOR get_projtrans_rec IS
      SELECT DISTINCT part_no, contract, activity_seq
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE transaction_code IN ('PROJTRAN+','CO-PRJTRN+','PROJTRAN-','CO-PRJTRN-')
         AND accounting_id IN (SELECT accounting_id
                                 FROM mpccom_accounting_id_tmp);

  TYPE Source_Ref_Tab IS TABLE OF get_source_ref%ROWTYPE
     INDEX BY PLS_INTEGER;
  source_ref_tab_               Source_Ref_Tab;

  TYPE Projtrans_Rec_Tab IS TABLE OF get_projtrans_rec%ROWTYPE
     INDEX BY PLS_INTEGER;
  projtrans_rec_tab_            Projtrans_Rec_Tab;
BEGIN

   Project_Refresh_Accounting_API.Fill_Temporary_Table(contract_, 'INVENTORY', accounting_id_);

   OPEN  get_source_ref;
   FETCH get_source_ref BULK COLLECT INTO source_ref_tab_;
   CLOSE get_source_ref;

   OPEN  get_projtrans_rec;
   FETCH get_projtrans_rec BULK COLLECT INTO projtrans_rec_tab_;
   CLOSE get_projtrans_rec;

   Project_Refresh_Accounting_API.Remove_Using_Temporary_Table;

   IF (source_ref_tab_.COUNT > 0) THEN
     FOR i IN source_ref_tab_.FIRST..source_ref_tab_.LAST LOOP
       IF (source_ref_tab_(i).source_ref_type = 'MTRL REQ') THEN
          Material_Requis_Line_API.Calculate_Cost_And_Progress(Material_Requis_Type_API.Decode('INT'),
                                                               source_ref_tab_(i).source_ref1,
                                                               source_ref_tab_(i).source_ref2,
                                                               source_ref_tab_(i).source_ref3,
                                                               source_ref_tab_(i).source_ref4);
       ELSIF (source_ref_tab_(i).source_ref_type = 'PUR ORDER') THEN
          $IF Component_Purch_SYS.INSTALLED $THEN
             Purchase_Order_Line_API.Calculate_Cost_And_Progress(source_ref_tab_(i).source_ref1,
                                                                 source_ref_tab_(i).source_ref2,
                                                                 source_ref_tab_(i).source_ref3,            
                                                                 transfer_to_finance_,
                                                                 transfer_to_finance_date_);            
          $ELSE
             NULL;    
          $END
       ELSIF (source_ref_tab_(i).source_ref_type = 'CUST ORDER') THEN
          $IF Component_Order_SYS.INSTALLED $THEN
             Customer_Order_Line_API.Calculate_Cost_And_Progress(source_ref_tab_(i).source_ref1,
                                                                 source_ref_tab_(i).source_ref2,
                                                                 source_ref_tab_(i).source_ref3,
                                                                 source_ref_tab_(i).source_ref4);            
          $ELSE
             NULL;    
          $END
       ELSIF (source_ref_tab_(i).source_ref_type IN (Order_Type_API.DB_WORK_ORDER, Order_Type_API.DB_WORK_TASK)) THEN
          $IF Component_Wo_SYS.INSTALLED $THEN
             IF (source_ref_tab_(i).source_ref_type = Order_Type_API.DB_WORK_ORDER) THEN
                -- For work order we have wo_no in source_ref1
                Work_Order_Utility_API.Refresh_Project_Connection(source_ref_tab_(i).source_ref1);
             ELSE
                -- For work task we have task_seq in source_ref1
                Jt_Task_API.Refresh_Project_Connection(source_ref_tab_(i).source_ref1);
             END IF;
          $ELSE
             Error_SYS.Component_Not_Exist('WO');
          $END
       ELSIF (source_ref_tab_(i).source_ref_type = 'SHOP ORDER') THEN
          $IF Component_Shpord_SYS.INSTALLED $THEN
             Shop_Ord_Services_API.Calculate_Cost_And_Progress(source_ref_tab_(i).source_ref1,
                                                               source_ref_tab_(i).source_ref2,
                                                               source_ref_tab_(i).source_ref3);            
          $ELSE
             NULL;    
          $END
       ELSIF (source_ref_tab_(i).source_ref_type = 'PROJECT') THEN
         $IF Component_Proj_SYS.INSTALLED $THEN
            Project_Misc_Procurement_API.Calculate_Cost_And_Progress(source_ref_tab_(i).source_ref3);            
         $ELSE
            NULL;    
         $END
       END IF;
     END LOOP;
   END IF;
   IF (projtrans_rec_tab_.COUNT > 0) THEN
      FOR i IN projtrans_rec_tab_.FIRST..projtrans_rec_tab_.LAST LOOP
         Refresh_Activity_Trans_Cost___(
                         part_no_                => projtrans_rec_tab_(i).part_no,
                         contract_               => projtrans_rec_tab_(i).contract,
                         activity_seq_           => projtrans_rec_tab_(i).activity_seq);
      END LOOP;
   END IF;
END Refresh_Activity_Info;


-- Check_Inv_Transaction
--   Checks if one order row has a transaction with quantity - qty_reversed > 0.
@UncheckedAccess
FUNCTION Check_Inv_Transaction (
   source_ref1_     IN VARCHAR2,
   source_ref2_     IN VARCHAR2,
   source_ref3_     IN VARCHAR2,
   source_ref4_     IN VARCHAR2,
   source_ref_type_ IN VARCHAR2,
   direction_       IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_         NUMBER;
   source_ref_type_db_ INVENTORY_TRANSACTION_HIST_TAB.source_ref_type%TYPE;
   CURSOR exist_control IS
      SELECT 1
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1  = source_ref1_
      AND    source_ref2  = source_ref2_
      AND    source_ref3  = source_ref3_
      AND    source_ref4  = source_ref4_
      AND    source_ref_type  = source_ref_type_db_
      AND    (quantity - qty_reversed) > 0
      AND    direction    = direction_;
BEGIN
   source_ref_type_db_ := Order_Type_API.Encode(source_ref_type_);
   OPEN   exist_control;
   FETCH  exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RETURN TRUE;
   END IF;
   CLOSE  exist_control;
   RETURN FALSE;
END Check_Inv_Transaction;


@UncheckedAccess
FUNCTION Trans_With_Ownership_Exist (
   contract_                      IN VARCHAR2,
   part_no_                       IN VARCHAR2,
   configuration_id_              IN VARCHAR2,
   lot_batch_no_                  IN VARCHAR2,
   serial_no_                     IN VARCHAR2,
   include_customer_owned_        IN BOOLEAN,
   include_supplier_loaned_       IN BOOLEAN,
   include_supplier_owned_        IN BOOLEAN,
   include_supplier_consignment_  IN BOOLEAN,
   include_company_owned_         IN BOOLEAN,
   include_supplier_rented_       IN BOOLEAN,
   include_company_rental_asset_  IN BOOLEAN,
   include_plus_direction_        IN BOOLEAN,
   include_minus_direction_       IN BOOLEAN,
   include_zero_direction_        IN BOOLEAN,
   include_reversed_transactions_ IN BOOLEAN ) RETURN BOOLEAN
IS
   dummy_                      NUMBER;
   trans_with_ownership_exist_ BOOLEAN := FALSE;
   incl_customer_owned_        VARCHAR2(5) := false_;
   incl_supplier_loaned_       VARCHAR2(5) := false_;
   incl_supplier_owned_        VARCHAR2(5) := false_;
   incl_supplier_consignment_  VARCHAR2(5) := false_;
   incl_company_owned_         VARCHAR2(5) := false_;
   incl_supplier_rented_       VARCHAR2(5) := false_;
   incl_company_rental_asset_  VARCHAR2(5) := false_;
   incl_plus_dir_              VARCHAR2(5) := false_;
   incl_minus_dir_             VARCHAR2(5) := false_;
   incl_zero_dir_              VARCHAR2(5) := false_;
   include_reversed_           VARCHAR2(5) := false_;

   CURSOR exist_control IS
      SELECT 1
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE contract           = contract_
         AND part_no            = part_no_
         AND (configuration_id  = configuration_id_ OR configuration_id_ IS NULL)
         AND (lot_batch_no      = lot_batch_no_     OR lot_batch_no_     IS NULL) 
         AND (serial_no         = serial_no_        OR serial_no_        IS NULL) 
         AND ((part_ownership = Part_Ownership_API.DB_CUSTOMER_OWNED       AND incl_customer_owned_       = true_)
           OR (part_ownership = Part_Ownership_API.DB_SUPPLIER_LOANED      AND incl_supplier_loaned_      = true_)
           OR (part_ownership = Part_Ownership_API.DB_SUPPLIER_OWNED       AND incl_supplier_owned_       = true_)
           OR (part_ownership = Part_Ownership_API.DB_CONSIGNMENT          AND incl_supplier_consignment_ = true_)
           OR (part_ownership = Part_Ownership_API.DB_COMPANY_OWNED        AND incl_company_owned_        = true_)
           OR (part_ownership = Part_Ownership_API.DB_SUPPLIER_RENTED      AND incl_supplier_rented_      = true_)
           OR (part_ownership = Part_Ownership_API.DB_COMPANY_RENTAL_ASSET AND incl_company_rental_asset_ = true_))
         AND (quantity > qty_reversed OR include_reversed_ = true_)
         AND ((direction = '+' AND incl_plus_dir_  = true_)
           OR (direction = '-' AND incl_minus_dir_ = true_)
           OR (direction = '0' AND incl_zero_dir_  = true_));
BEGIN
   IF (include_customer_owned_) THEN
      incl_customer_owned_ := true_;
   END IF;
   IF (include_supplier_loaned_) THEN
      incl_supplier_loaned_ := true_;
   END IF;
   IF (include_supplier_owned_) THEN
      incl_supplier_owned_ := true_;
   END IF;
   IF (include_supplier_consignment_) THEN
      incl_supplier_consignment_ := true_;
   END IF;
   IF (include_company_owned_) THEN
      incl_company_owned_ := true_;
   END IF;
   IF (include_supplier_rented_) THEN
      incl_supplier_rented_ := true_;
   END IF;
   IF (include_company_rental_asset_) THEN
      incl_company_rental_asset_ := true_;
   END IF;
   IF (include_plus_direction_) THEN
      incl_plus_dir_ := true_;
   END IF;
   IF (include_minus_direction_) THEN
      incl_minus_dir_ := true_;
   END IF;
   IF (include_zero_direction_) THEN
      incl_zero_dir_ := true_;
   END IF;
   IF (include_reversed_transactions_) THEN
      include_reversed_ := true_;
   END IF;

   OPEN  exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      trans_with_ownership_exist_ := TRUE;
   END IF;
   CLOSE exist_control;

   RETURN (trans_with_ownership_exist_);
END Trans_With_Ownership_Exist;

@UncheckedAccess
FUNCTION Trans_With_Ownership_Exist (
   source_ref1_          IN VARCHAR2,
   source_ref2_          IN VARCHAR2,
   source_ref3_          IN VARCHAR2,
   source_ref4_          IN VARCHAR2,
   source_ref5_          IN VARCHAR2,
   source_ref_type_db_   IN VARCHAR2,
   part_ownership_db_    IN VARCHAR2,
   owning_vendor_no_     IN VARCHAR2 ) RETURN VARCHAR2
IS
   dummy_                      NUMBER;
   trans_with_ownership_exist_ VARCHAR2(5) := Fnd_Boolean_API.DB_FALSE;

   CURSOR exist_control IS
      SELECT 1
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE source_ref1     = source_ref1_
         AND (source_ref2    = source_ref2_ OR source_ref2_ IS NULL)
         AND (source_ref3    = source_ref3_ OR source_ref3_ IS NULL)
         AND (source_ref4    = source_ref4_ OR source_ref4_ IS NULL)
         AND (source_ref5    = source_ref5_ OR source_ref5_ IS NULL)
         AND source_ref_type = source_ref_type_db_ 
         AND part_ownership  = part_ownership_db_
         AND NVL(owning_vendor_no, '*') = NVL(owning_vendor_no_, '*')
         and quantity> qty_reversed;           
BEGIN

   OPEN  exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      trans_with_ownership_exist_ := Fnd_Boolean_API.DB_TRUE;
   END IF;
   CLOSE exist_control;

   RETURN (trans_with_ownership_exist_);
END Trans_With_Ownership_Exist;

-- Get_Wip_Cost_Sum
--   Returns the sum of cost * quantity for one order and order_type.
PROCEDURE Get_Wip_Cost_Sum (
   wip_cost_sum_     OUT NUMBER,
   source_ref1_      IN  VARCHAR2,
   source_ref_type_  IN  VARCHAR2,
   transaction_code_ IN  VARCHAR2 )
IS
   source_ref_type_db_ INVENTORY_TRANSACTION_HIST_TAB.source_ref_type%TYPE;
   total_value_   NUMBER := 0;
   unit_cost_     NUMBER;

   CURSOR get_transaction IS
      SELECT transaction_id, quantity
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1      = source_ref1_
      AND    source_ref_type  = source_ref_type_db_
      AND    transaction_code = transaction_code_;
BEGIN

   source_ref_type_db_ := Order_Type_API.Encode(source_ref_type_);

   FOR trans_rec_ IN get_transaction LOOP
      unit_cost_   := Inventory_Transaction_Cost_API.Get_Sum_Unit_Cost(trans_rec_.transaction_id);
      total_value_ := total_value_ + (unit_cost_ * trans_rec_.quantity);
   END LOOP;

   wip_cost_sum_ := total_value_;
END Get_Wip_Cost_Sum;


@UncheckedAccess
FUNCTION Get_Wip_Cost (
   source_ref1_      IN VARCHAR2,
   source_ref2_      IN VARCHAR2,
   source_ref3_      IN VARCHAR2,
   source_ref4_      IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2,
   transaction_code_ IN VARCHAR2,
   part_no_          IN VARCHAR2,
   contract_         IN VARCHAR2 ) RETURN NUMBER
IS
   wip_cost_        NUMBER;
   cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
BEGIN
   cost_detail_tab_ := Get_Wip_Cost_Details(source_ref1_, 
                                            source_ref2_, 
                                            source_ref3_, 
                                            source_ref4_,
                                            source_ref_type_db_,
                                            transaction_code_,
                                            part_no_,
                                            contract_);

   wip_cost_ := Inventory_Part_Unit_Cost_API.Get_Total_Unit_Cost(cost_detail_tab_);

   RETURN(NVL(wip_cost_,0));
END Get_Wip_Cost;


-- Get_Wip_Cost_Details
--   Get the unit cost details for one order line and order_type and component_part.
@UncheckedAccess
FUNCTION Get_Wip_Cost_Details (
   source_ref1_      IN VARCHAR2,
   source_ref2_      IN VARCHAR2,
   source_ref3_      IN VARCHAR2,
   source_ref4_      IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2,
   transaction_code_ IN VARCHAR2,
   part_no_          IN VARCHAR2,
   contract_         IN VARCHAR2 ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   transaction_id_  INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;

   CURSOR get_transaction_id IS
      SELECT transaction_id
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1               = source_ref1_
        AND  NVL(source_ref2,'DUMMY')  = NVL(source_ref2_, NVL(source_ref2,'DUMMY'))
        AND  NVL(source_ref3,'DUMMY')  = NVL(source_ref3_, NVL(source_ref3,'DUMMY'))
        AND  NVL(source_ref4,'DUMMY')  = NVL(source_ref4_, NVL(source_ref4,'DUMMY'))
        AND  source_ref_type           = source_ref_type_db_
        AND  transaction_code          = transaction_code_
        AND  (part_no  = part_no_  OR part_no_ IS NULL)
        AND  (contract = contract_ OR contract_ IS NULL)
        AND  configuration_id          = '*';
BEGIN
   OPEN  get_transaction_id;
   FETCH get_transaction_id INTO transaction_id_;
   IF (get_transaction_id%FOUND) THEN
      cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(
                                                                                  transaction_id_);
   END IF;
   CLOSE get_transaction_id;

   RETURN(cost_detail_tab_);
END Get_Wip_Cost_Details;


-- Modify_Date_Applied
--   A method that sets a new date to a certain inventory transaction,
--   setting can only be done to a date in an open accounting period.
--   The method also deletes all accountings made for this transaction,
--   and creates them again for new date.
PROCEDURE Modify_Date_Applied (
   info_             OUT VARCHAR2,
   transaction_id_   IN  NUMBER,
   new_date_applied_ IN  DATE )
IS
BEGIN
   Modify_Date_Applied___(transaction_id_, new_date_applied_);
   info_ := Client_SYS.Get_All_Info;
END Modify_Date_Applied;



-- Modify_Date_Applied
--   A method that sets a new date to set of certain inventory transactions
--   which belongs to a certain source reference.
--   setting can only be done to a date in an open accounting period.
--   The method also deletes all accountings made for this transaction,
--   and creates them again for new date.
PROCEDURE Modify_Date_Applied (
   info_               OUT VARCHAR2,
   contract_           IN  VARCHAR2,
   source_ref1_        IN  VARCHAR2,
   source_ref2_        IN  VARCHAR2,
   source_ref3_        IN  VARCHAR2,
   source_ref4_        IN  VARCHAR2,
   source_ref5_        IN  VARCHAR2,
   source_ref_type_db_ IN  VARCHAR2,
   new_date_applied_   IN  DATE )
IS
      CURSOR get_transactions IS
      SELECT transaction_id,transaction_code 
      FROM   inventory_transaction_hist_tab 
      WHERE  source_ref1              = source_ref1_
      AND    NVL(source_ref2,'DUMMY') = NVL(source_ref2_,NVL(source_ref2,'DUMMY'))
      AND    NVL(source_ref3,'DUMMY') = NVL(source_ref3_,NVL(source_ref3,'DUMMY'))
      AND    NVL(source_ref4,'DUMMY') = NVL(source_ref4_,NVL(source_ref4,'DUMMY'))
      AND    NVL(source_ref5,'DUMMY') = NVL(source_ref5_,NVL(source_ref5,'DUMMY'))
      AND    source_ref_type          = source_ref_type_db_;
      
   BEGIN
      IF (source_ref1_ IS NOT NULL) THEN              
         -- gelr:modify_date_applied Begin
         IF (Company_Localization_Info_API.Get_Parameter_Val_From_Site_Db(contract_, 'MODIFY_DATE_APPLIED') = Fnd_Boolean_API.DB_TRUE) THEN
            FOR get_trans_ IN get_transactions LOOP
               IF (get_trans_.transaction_code IN ('INVM-ISS','INVM-OUT','INVM-TRISS','PICK-OUT','PICK-IN','COMPM-OUT','OESHIP', 'SHIPDIR', 'SHIPTRAN'))THEN
                  Modify_Date_Applied___(get_trans_.transaction_id, new_date_applied_);
               END IF;
            END LOOP;
         -- gelr:modify_date_applied End  
         -- gelr: date_applied_as_fne_issue_date, Begin
         ELSIF (Company_Localization_Info_API.Get_Parameter_Val_From_Site_Db(contract_, 'DATE_APPLIED_AS_FNE_ISSUE_DATE') = Fnd_Boolean_API.DB_TRUE) THEN
            FOR get_trans_ IN get_transactions LOOP 
               IF(get_trans_.transaction_code IN ('OESHIP')) THEN
                  Modify_Date_Applied___(get_trans_.transaction_id, new_date_applied_);
               END IF;
            END LOOP;
         -- gelr: date_applied_as_fne_issue_date, End      
         ELSE
            FOR get_trans_ IN get_transactions LOOP 
               Modify_Date_Applied___(get_trans_.transaction_id, new_date_applied_);
            END LOOP;
         END IF;      
      END IF;    
      info_ := Client_SYS.Get_All_Info;
END Modify_Date_Applied;

-- Calculate_Days
--   Calculate number of days from first dated within a year for one
--   part_no and contract.
@UncheckedAccess
FUNCTION Calculate_Days (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2 ) RETURN NUMBER

IS
   days_       NUMBER;
   site_date_  DATE;

   CURSOR get_days IS
      SELECT (site_date_ - MIN(date_created) + 1)
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE part_no          = part_no_
         AND configuration_id = configuration_id_
         AND contract         = contract_
         AND date_created     BETWEEN (site_date_ - 365) AND site_date_;
BEGIN
   site_date_ := TRUNC(Site_API.Get_Site_Date(contract_));

   OPEN  get_days;
   FETCH get_days INTO days_;
   CLOSE get_days;

   RETURN (NVL(days_,0));
END Calculate_Days;


@UncheckedAccess
FUNCTION Calculate_Qty_Onhand_Date (
   transaction_id_   IN NUMBER,
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2) RETURN NUMBER
IS
   time_    NUMBER;
   expired_ BOOLEAN;

   CURSOR get_transactions IS
      SELECT nvl(to_number(direction||to_char(quantity)),0) quantity, transaction_id, transaction_code
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE part_no        = part_no_
      AND contract         = contract_
      AND configuration_id = configuration_id_
      AND direction        IN ('-', '+')
      ORDER BY transaction_id;

   TYPE inventory_trans_Type IS TABLE OF get_transactions%ROWTYPE
      INDEX BY PLS_INTEGER;

   inventory_transaction_tab_ inventory_trans_Type;
BEGIN
   time_    := to_number(to_char(SYSDATE, 'JSSSSS')); -- Returns Julian timestamp in seconds
   expired_ := (time_ - micro_cache_onh_dev_time_) > 300;

   IF expired_                                           OR
      micro_cache_onh_dev_contract_    != contract_         OR
      micro_cache_onh_dev_part_no_     != part_no_          OR
      micro_cache_onh_dev_config_id_   != configuration_id_ OR
      NOT micro_cache_onh_dev_filled_                       THEN

      OPEN get_transactions;
      FETCH get_transactions BULK COLLECT INTO inventory_transaction_tab_;
      CLOSE get_transactions;

      -- Set global variables
      micro_cache_onh_dev_contract_    := contract_;
      micro_cache_onh_dev_part_no_     := part_no_;
      micro_cache_onh_dev_config_id_   := configuration_id_;
      micro_cache_onh_dev_filled_      := TRUE;
      micro_cache_onh_dev_time_        := time_;

      IF (inventory_transaction_tab_.COUNT > 0) THEN
         FOR i IN inventory_transaction_tab_.first..inventory_transaction_tab_.last LOOP
            IF i = 1 THEN
               micro_cache_onh_dev_acc_qty_(TO_CHAR(inventory_transaction_tab_(i).transaction_id)) := inventory_transaction_tab_(i).quantity;
            ELSIF (inventory_transaction_tab_(i).transaction_code = 'XO-ARRIVAL') THEN
               micro_cache_onh_dev_acc_qty_(TO_CHAR(inventory_transaction_tab_(i).transaction_id)) := micro_cache_onh_dev_acc_qty_(inventory_transaction_tab_(i-1).transaction_id);
            ELSE
               micro_cache_onh_dev_acc_qty_(TO_CHAR(inventory_transaction_tab_(i).transaction_id)) := micro_cache_onh_dev_acc_qty_(inventory_transaction_tab_(i-1).transaction_id) + inventory_transaction_tab_(i).quantity;
            END IF;
         END LOOP;
      END IF;

      inventory_transaction_tab_.DELETE;
   END IF;

   IF micro_cache_onh_dev_acc_qty_.count > 0 THEN
      IF micro_cache_onh_dev_acc_qty_.EXISTS(TO_CHAR(transaction_id_)) THEN
         RETURN micro_cache_onh_dev_acc_qty_(TO_CHAR(transaction_id_));
      ELSE
         RETURN 0;
      END IF;
   ELSE
      RETURN 0;
   END IF;
END Calculate_Qty_Onhand_Date;


-- Check_Part_Exist
--   Checks if any inventory transactions are made for this part on this site.
@UncheckedAccess
FUNCTION Check_Part_Exist (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   dummy_ NUMBER;
   CURSOR exist_control IS
      SELECT 1
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  part_no = part_no_
      AND    contract = contract_
      AND    (configuration_id = configuration_id_ OR configuration_id_ IS NULL);
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RETURN true_;
   END IF;
   CLOSE exist_control;
   RETURN false_;
END Check_Part_Exist;


-- Check_Serial_Part_Exist
--   Checks if any inventory transactions are made for this part and serial number.
--   Returns the string true_ if transactions exist false_ if not.
@UncheckedAccess
FUNCTION Check_Serial_Part_Exist (
   part_no_   IN VARCHAR2,
   serial_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   dummy_ NUMBER;
   CURSOR exist_control IS
      SELECT 1
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  part_no = part_no_
      AND    serial_no = serial_no_;
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RETURN true_;
   END IF;
   CLOSE exist_control;
   RETURN false_;
END Check_Serial_Part_Exist;


@UncheckedAccess
FUNCTION Check_Handling_Unit_Exist (
   handling_unit_id_ IN NUMBER ) RETURN BOOLEAN
IS
   dummy_ NUMBER;
   CURSOR exist_control IS
      SELECT 1
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  handling_unit_id = handling_unit_id_;
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RETURN TRUE;
   END IF;
   CLOSE exist_control;
   RETURN FALSE;
END Check_Handling_Unit_Exist;


@UncheckedAccess
FUNCTION Calculate_Total_Quantity (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2 ) RETURN NUMBER
IS
   site_date_      DATE;
   total_quantity_ NUMBER;

   CURSOR total_quantity IS
      SELECT nvl(sum(quantity),1)
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  part_no   = part_no_
      AND    configuration_id = configuration_id_
      AND    contract  = contract_
      AND    direction = '-'
      AND    date_created BETWEEN (site_date_ - 365) AND site_date_;
BEGIN
   site_date_ := TRUNC(Site_API.Get_Site_Date(contract_));
   OPEN   total_quantity;
   FETCH  total_quantity INTO total_quantity_ ;
   CLOSE  total_quantity;
   RETURN total_quantity_;
END Calculate_Total_Quantity;


-- Do_Booking
--   Make accounting for one transaction_id. Raise an error message when value_ is NULL.
PROCEDURE Do_Booking (
   transaction_id_   IN NUMBER,
   company_          IN VARCHAR2,
   event_code_       IN VARCHAR2,
   complete_flag_    IN VARCHAR2,
   value_            IN NUMBER,
   value_adjustment_ IN BOOLEAN DEFAULT FALSE,
   adjustment_date_  IN DATE    DEFAULT NULL )
IS
   external_value_tab_           Mpccom_Accounting_API.Value_Detail_Tab;
   empty_curr_amt_posting_tab_   Mpccom_Accounting_API.Curr_Amount_Posting_Tab;
BEGIN
   IF (value_ IS NOT NULL) THEN
      Error_SYS.Record_General('InventoryTransactionHist', 'DOBOOKINGERR: Implementation error. Invalid use of method Inventory_Transaction_Hist_API.Do_Booking. Contact System Support.');
   END IF;
   Do_Booking___(transaction_id_              => transaction_id_,
                 company_                     => company_,
                 event_code_                  => event_code_,
                 complete_flag_               => complete_flag_,
                 external_value_tab_          => external_value_tab_,
                 value_adjustment_            => value_adjustment_,
                 adjustment_date_             => adjustment_date_,
                 per_oh_adjustment_id_        => NULL,
                 do_post_booking_actions_     => TRUE,
                 periodic_weighted_avg_calc_  => FALSE,
                 trans_reval_event_id_        => NULL,
                 pwa_curr_amount_posting_tab_ => empty_curr_amt_posting_tab_,
                 post_accum_curr_amt_for_pwa_ => FALSE);   
END Do_Booking;


-- Do_Booking
--   Make accounting for one transaction_id.
PROCEDURE Do_Booking (
   transaction_id_             IN NUMBER,
   company_                    IN VARCHAR2,
   event_code_                 IN VARCHAR2,
   complete_flag_              IN VARCHAR2,
   external_value_tab_         IN Mpccom_Accounting_API.Value_Detail_Tab,
   value_adjustment_           IN BOOLEAN DEFAULT FALSE,
   adjustment_date_            IN DATE    DEFAULT NULL,
   per_oh_adjustment_id_       IN NUMBER  DEFAULT NULL,
   do_post_booking_actions_    IN BOOLEAN DEFAULT TRUE,
   periodic_weighted_avg_calc_ IN BOOLEAN DEFAULT FALSE,
   trans_reval_event_id_       IN NUMBER  DEFAULT NULL )

IS
   empty_curr_amt_posting_tab_   Mpccom_Accounting_API.Curr_Amount_Posting_Tab;
BEGIN
   Do_Booking___(transaction_id_              => transaction_id_,
                 company_                     => company_,
                 event_code_                  => event_code_,
                 complete_flag_               => complete_flag_,
                 external_value_tab_          => external_value_tab_,
                 value_adjustment_            => value_adjustment_,
                 adjustment_date_             => adjustment_date_,
                 per_oh_adjustment_id_        => per_oh_adjustment_id_,
                 do_post_booking_actions_     => do_post_booking_actions_,
                 periodic_weighted_avg_calc_  => periodic_weighted_avg_calc_,
                 trans_reval_event_id_        => trans_reval_event_id_,
                 pwa_curr_amount_posting_tab_ => empty_curr_amt_posting_tab_,
                 post_accum_curr_amt_for_pwa_ => FALSE);
   
END Do_Booking;


PROCEDURE Prepare_Transfer (
   date_     IN DATE,
   contract_ IN VARCHAR2 )
IS
   execution_offset_ NUMBER;
BEGIN
   
   Mpccom_Accounting_API.Transfer_To_Finance(contract_, date_, execution_offset_, 'INVENTORY');
END Prepare_Transfer;


-- Redo_Error_Booking
--   Tries to do wrongly booked transfers once again.
PROCEDURE Redo_Error_Booking (
   accounting_id_     IN NUMBER,
   company_           IN VARCHAR2)
IS
   trans_rec_ INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
BEGIN

   trans_rec_ := Get_Object_By_Accounting_Id___(accounting_id_);
   Redo_Transaction_Postings___(trans_rec_.transaction_id,
                                trans_rec_.accounting_id,
                                trans_rec_.contract,
                                trans_rec_.part_no,
                                trans_rec_.activity_seq,
                                trans_rec_.source_ref1,
                                trans_rec_.source_ref2,
                                trans_rec_.source_ref3,
                                trans_rec_.source_ref4,
                                trans_rec_.pre_accounting_id,
                                NULL,
                                trans_rec_.source_ref_type,
                                company_);
END Redo_Error_Booking;


-- Get_Arrival_Cost
--   Get cost for one order row that has a transaction that is ok.
PROCEDURE Get_Arrival_Cost (
   curr_amount_detail_tab_   OUT Mpccom_Accounting_API.Curr_Amount_Detail_Tab,
   cost_                     OUT NUMBER,
   arrival_qty_              OUT NUMBER,
   source_ref1_              IN  VARCHAR2,
   source_ref2_              IN  VARCHAR2,
   source_ref3_              IN  VARCHAR2,
   source_ref4_              IN  VARCHAR2,
   to_date_                  IN  DATE DEFAULT NULL )
IS
   value_         NUMBER;
   qty_           NUMBER;
   dummy_number_  NUMBER;
BEGIN

    Get_Arrival_Cost_Value_Qty___(curr_amount_detail_tab_       => curr_amount_detail_tab_,
                                 cost_                          => cost_,
                                 value_                         => value_,
                                 qty_                           => qty_,
                                 price_diff_                    => dummy_number_,                                 
                                 source_ref1_                   => source_ref1_,
                                 source_ref2_                   => source_ref2_,
                                 source_ref3_                   => source_ref3_,
                                 source_ref4_                   => source_ref4_,
                                 alt_source_ref1_               => NULL,
                                 alt_source_ref2_               => NULL,
                                 alt_source_ref3_               => NULL,
                                 alt_source_ref4_               => NULL,
                                 to_date_                       => to_date_,
                                 include_reversed_transactions_ => TRUE,
                                 serial_no_                     => NULL,
                                 use_original_amounts_for_pwa_  => TRUE,
                                 fetch_curr_amount_details_     => TRUE,
                                 use_only_m10_postings_         => FALSE);
END Get_Arrival_Cost;

@UncheckedAccess
FUNCTION Get_Sum_Value (
   source_ref_type_db_ IN VARCHAR2,
   source_ref1_   IN VARCHAR2,
   source_ref2_   IN VARCHAR2,
   source_ref3_   IN VARCHAR2,
   str_code_      IN VARCHAR2,
   to_date_       IN DATE ) RETURN NUMBER
IS
   value_ NUMBER;

   CURSOR get_acc IS
      SELECT accounting_id
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE source_ref1   = source_ref1_
         AND source_ref2   = source_ref2_
         AND source_ref3   = source_ref3_
         AND source_ref_type = source_ref_type_db_;
BEGIN
   value_         := 0;
   FOR invhist_rec IN get_acc LOOP
      value_ := value_ + Mpccom_Accounting_API.Get_Sum_Value(invhist_rec.accounting_id, str_code_, to_date_);
   END LOOP;
   RETURN value_;
END Get_Sum_Value;

-- Do_Str_Event_Acc
--   Performs accounting for inventory transaction.
--   Performs accounting for inventory transaction.
PROCEDURE Do_Str_Event_Acc (
   rcode_                   IN OUT VARCHAR2,
   company_                 IN     VARCHAR2,
   event_code_              IN     VARCHAR2,
   accounting_id_           IN     NUMBER,
   booking_source_          IN     VARCHAR2,
   value_                   IN     NUMBER,
   accounting_date_         IN     DATE,
   contract_                IN     VARCHAR2,
   userid_                  IN     VARCHAR2,
   cost_source_id_          IN     VARCHAR2,
   bucket_posting_group_id_ IN     VARCHAR2,
   control_type_key_rec_    IN     Mpccom_Accounting_API.Control_Type_Key,
   value_adjustment_        IN     BOOLEAN DEFAULT FALSE,
   per_oh_adjustment_id_    IN     NUMBER  DEFAULT NULL )
IS
   trans_currency_code_        VARCHAR2(3);
   trans_currency_rate_        NUMBER;
   trans_curr_conv_factor_     NUMBER;
   trans_curr_rounding_        NUMBER;
   tran_hist_rec_              INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;   
   base_curr_code_             VARCHAR2(3);
   base_curr_rate_             NUMBER;
   base_curr_conv_factor_      NUMBER;
   base_curr_type_             VARCHAR2(10);
   base_curr_rate_is_inverted_ VARCHAR2(5) := 'FALSE';
BEGIN
   base_curr_code_ :=  Company_Finance_API.Get_Currency_Code(company_);
   Currency_Rate_API.Get_Currency_Rate_Defaults(base_curr_type_,
                                                base_curr_conv_factor_,
                                                base_curr_rate_,
                                                company_,
                                                base_curr_code_,
                                                Site_API.Get_Site_Date(contract_));
   IF (Acc_Event_Posting_Type_API.Event_Code_Needs_Trans_Curr(event_code_)) THEN
      IF (booking_source_ = 'INVENTORY') THEN
         base_curr_rate_is_inverted_ := Currency_Code_API.Get_Inverted(company_, base_curr_code_);
         tran_hist_rec_ := Get_Object_By_Accounting_Id___(accounting_id_);
         Get_Transaction_Curr_Info___(trans_currency_code_,
                                      trans_currency_rate_,
                                      trans_curr_conv_factor_,
                                      trans_curr_rounding_,
                                      tran_hist_rec_,
                                      company_,
                                      event_code_,
                                      FALSE); 
      END IF;
   END IF;
   Do_Str_Event_Acc_Impl___(rcode_,
                            company_,
                            event_code_,
                            accounting_id_,
                            booking_source_,
                            value_,
                            accounting_date_,
                            contract_,
                            value_adjustment_,
                            userid_,
                            cost_source_id_,
                            bucket_posting_group_id_,
                            per_oh_adjustment_id_,
                            control_type_key_rec_,
                            NULL,
                            base_curr_code_,
                            base_curr_rate_,
                            base_curr_conv_factor_,
                            base_curr_rate_is_inverted_,
                            trans_currency_code_,
                            trans_currency_rate_,
                            trans_curr_conv_factor_,
                            trans_curr_rounding_,
                            NULL);
END Do_Str_Event_Acc;


-- Modify_Qty_Reversed
--   Modifies the attribute QtyReversed.
PROCEDURE Modify_Qty_Reversed (
   transaction_id_ IN NUMBER,
   qty_reversed_   IN NUMBER )
IS
   record_ inventory_transaction_hist_tab%ROWTYPE;
BEGIN
   record_              := Lock_By_Keys___(transaction_id_);
   record_.qty_reversed := qty_reversed_;
   Modify___(record_);
END Modify_Qty_Reversed;


-- Get_Sum_Value_Shop_Order_Mtrl
--   Gets accumulated value of material withdrawal transaction for shop
--   order matching in parameters.
@UncheckedAccess
FUNCTION Get_Sum_Value_Shop_Order_Mtrl (
   source_ref1_ IN VARCHAR2,
   source_ref2_ IN VARCHAR2,
   source_ref3_ IN VARCHAR2 ) RETURN NUMBER
IS
   value_     NUMBER;

   CURSOR get_acc IS
      SELECT accounting_id
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  transaction_code NOT IN ('OOREC', 'SUNREC')
      AND    source_ref_type = 'SHOP ORDER'
      AND    source_ref1 = source_ref1_
      AND    source_ref2 = source_ref2_
      AND    source_ref3 = source_ref3_;
BEGIN
   value_ := 0;
   FOR invhist_rec IN get_acc LOOP
      value_ := value_ + (-1 *(Mpccom_Accounting_API.Get_Sum_Value (invhist_rec.accounting_id, 'M1')));
   END LOOP;
   RETURN value_;
END Get_Sum_Value_Shop_Order_Mtrl;


-- Get_Sum_Value_Prod_Sched_Mtrl
--   Gets accumulated value of material withdrawal transaction for
--   production schedule matching in parameters.
@UncheckedAccess
FUNCTION Get_Sum_Value_Prod_Sched_Mtrl (
   source_ref1_ IN VARCHAR2,
   source_ref2_ IN VARCHAR2,
   source_ref3_ IN VARCHAR2 ) RETURN NUMBER
IS
   value_     NUMBER;

   CURSOR get_acc IS
      SELECT accounting_id
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  transaction_code NOT IN ('PSRECEIVE', 'RPSREC')
      AND    source_ref_type = 'PROD SCH'
      AND    source_ref1 = source_ref1_
      AND    source_ref2 = source_ref2_
      AND    source_ref3 = source_ref3_;
BEGIN
   value_ := 0;
   FOR invhist_rec IN get_acc LOOP
      value_ := value_ +  (-1 *(Mpccom_Accounting_API.Get_Sum_Value (invhist_rec.accounting_id, 'M1')));
   END LOOP;
   RETURN value_;
END Get_Sum_Value_Prod_Sched_Mtrl;


-- Get_Reject_Code_When_Qty
--   Returns the accounting id for the transaction with rejection
--   quantity > zero, otherwise it returns NULL.
@UncheckedAccess
FUNCTION Get_Reject_Code_When_Qty (
   transaction_id_ IN NUMBER,
   reject_qty_     IN NUMBER ) RETURN NUMBER
IS
   accounting_id_ NUMBER;
   CURSOR get_accounting_id IS
      SELECT accounting_id
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  transaction_id = transaction_id_;
BEGIN
   IF (reject_qty_ > 0) THEN
      OPEN get_accounting_id;
      FETCH get_accounting_id INTO accounting_id_;
      IF (get_accounting_id%NOTFOUND) THEN
         accounting_id_ := NULL;
      END IF;
      CLOSE get_accounting_id;
   ELSE
      accounting_id_ := NULL;
   END IF;
   RETURN(accounting_id_);
END Get_Reject_Code_When_Qty;


-- Get_Accounting_Id_When_Qty
--   Returns the rejection code for the transaction with rejection
--   quantity > zero, otherwise it returns NULL.
@UncheckedAccess
FUNCTION Get_Accounting_Id_When_Qty (
   transaction_id_ IN NUMBER,
   reject_qty_     IN NUMBER ) RETURN NUMBER
IS
   reject_code_ NUMBER;
   CURSOR get_reject_code IS
      SELECT reject_code
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  transaction_id = transaction_id_;
BEGIN
   IF (reject_qty_ > 0) THEN
      OPEN get_reject_code;
      FETCH get_reject_code INTO reject_code_;
      IF (get_reject_code%NOTFOUND) THEN
         reject_code_ := NULL;
      END IF;
      CLOSE get_reject_code;
   ELSE
      reject_code_ := NULL;
   END IF;
   RETURN(reject_code_);
END Get_Accounting_Id_When_Qty;


-- Get_Transaction_Id_For_Accting
--   The method returns the transaction id for the corresponding accounting id
@UncheckedAccess
FUNCTION Get_Transaction_Id_For_Accting (
   accounting_id_ IN NUMBER ) RETURN NUMBER
IS
   transaction_id_ NUMBER;
   CURSOR get_rec IS
      SELECT transaction_id
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE accounting_id = accounting_id_;
BEGIN
   OPEN get_rec;
   FETCH get_rec INTO transaction_id_;
   CLOSE get_rec;
   RETURN (transaction_id_);
END Get_Transaction_Id_For_Accting;


-- Get_Accting_Value_Latest_Trans
--   Returns value and accounting_id for latest inventory transaction history
--   record for specific order type and order line id.
PROCEDURE Get_Accting_Value_Latest_Trans (
   curr_amt_detail_tab_ OUT Mpccom_Accounting_API.Curr_Amount_Detail_Tab,
   accounting_id_       OUT NUMBER,
   source_ref_type_     IN  VARCHAR2,
   source_ref1_         IN  VARCHAR2,
   source_ref2_         IN  VARCHAR2,
   source_ref3_         IN  VARCHAR2,
   source_ref4_         IN  VARCHAR2,
   str_code_            IN  VARCHAR2 )
IS
   source_ref_type_db_ INVENTORY_TRANSACTION_HIST_TAB.source_ref_type%TYPE;
   accting_id_    INVENTORY_TRANSACTION_HIST_TAB.accounting_id%TYPE;

   CURSOR get_acc IS
      SELECT accounting_id
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  transaction_id = (SELECT MAX(transaction_id) from INVENTORY_TRANSACTION_HIST_TAB
                               WHERE  source_ref1   = source_ref1_
                               AND    NVL(source_ref2_,NVL(source_ref2, 'DUMMY')) = NVL(source_ref2, 'DUMMY')
                               AND    NVL(source_ref3_,NVL(source_ref3, 'DUMMY')) = NVL(source_ref3, 'DUMMY')
                               AND    NVL(source_ref4_,NVL(source_ref4, 'DUMMY')) = NVL(source_ref4, 'DUMMY')
                               AND    source_ref_type = source_ref_type_db_);
BEGIN
   source_ref_type_db_ := Order_Type_API.Encode(source_ref_type_);
   OPEN get_acc;
   FETCH get_acc INTO accting_id_;
   CLOSE get_acc;
   curr_amt_detail_tab_ := Mpccom_Accounting_API.Get_Curr_Amount_Details(accting_id_, str_code_);
   accounting_id_ := accting_id_;
END Get_Accting_Value_Latest_Trans;


-- Get_Sum_Value_Order_Line
--   Returns transaction value for specific order type and order line id and str_code.
@UncheckedAccess
FUNCTION Get_Sum_Value_Order_Line (
   source_ref_type_        IN VARCHAR2,
   source_ref1_            IN VARCHAR2,
   source_ref2_            IN VARCHAR2,
   source_ref3_            IN VARCHAR2,
   source_ref4_            IN VARCHAR2,
   str_code_               IN VARCHAR2,
   alt_source_ref1_        IN VARCHAR2,
   alt_source_ref2_        IN VARCHAR2,
   alt_source_ref3_        IN VARCHAR2,
   alt_source_ref4_        IN VARCHAR2,
   alt_source_ref_type_db_ IN VARCHAR2 ) RETURN NUMBER
IS
   value_         NUMBER;
   source_ref_type_db_ INVENTORY_TRANSACTION_HIST_TAB.source_ref_type%TYPE;

   CURSOR get_acc IS
      SELECT accounting_id, transaction_code
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1               = source_ref1_
      AND    source_ref2               = source_ref2_
      AND    NVL(source_ref3, 'DUMMY') = NVL(source_ref3_, NVL(source_ref3, 'DUMMY'))
      AND    NVL(source_ref4, 'DUMMY') = NVL(source_ref4_, NVL(source_ref4, 'DUMMY'))
      AND    source_ref_type           = source_ref_type_db_
      AND    (alt_source_ref1          = alt_source_ref1_        OR alt_source_ref1_ IS NULL)
      AND    (alt_source_ref2          = alt_source_ref2_        OR alt_source_ref2_ IS NULL)
      AND    (alt_source_ref3          = alt_source_ref3_        OR alt_source_ref3_ IS NULL)
      AND    (alt_source_ref4          = alt_source_ref4_        OR alt_source_ref4_ IS NULL)
      AND    (alt_source_ref_type      = alt_source_ref_type_db_ OR alt_source_ref_type_db_ IS NULL);
BEGIN
   value_         := 0;
   source_ref_type_db_ := Order_Type_API.Encode(source_ref_type_);
   FOR invhist_rec IN get_acc LOOP
      -- EBALL, Added 'CRO-EXD-IN'.
      IF ((source_ref_type_db_ = 'CUST ORDER') AND (str_code_ = 'M3') AND
          (invhist_rec.transaction_code IN ('CO-DELV-IN','DELCONF-IN','CRO-EXD-IN'))) THEN
--       When shipping material on a consignment customer order there are always
--       two transactions created. Transaction codes CO-DELV-OU and CO-DELV-IN.
--       In order to get a correct value for these order lines we have to exclude
--       the CO-DELV-IN transactions from the value sum. Otherwise this function
--       would always return a zero value for such customer orders.
--       Delivery confirmation is handled in a similar way with DELCONF-OU and DELCONF-IN.
--       Component Repair Exchange is handled in a similar way with CRO-EXD-OU and CRO-EXD-IN.
         NULL;
      ELSE
         value_ := value_ + Mpccom_Accounting_API.Get_Sum_Value(invhist_rec.accounting_id, str_code_);
      END IF;
   END LOOP;
   RETURN value_;
END Get_Sum_Value_Order_Line;


-- Cancel_Order_Receipt
--   The method gets all transactions made for the specified order and
--   reverse all of them.
--   An issue in inventory becomes a receive and vise versa.
--   A zero movement becomes a new zero movement.
--   There is a reverse accounting done for every new transaction.
--   The transaction used for every new transaction is UNRCPT.
PROCEDURE Cancel_Order_Receipt (
   source_ref1_      IN VARCHAR2,
   source_ref2_      IN VARCHAR2,
   source_ref3_      IN VARCHAR2,
   source_ref4_      IN VARCHAR2,
   source_ref_type_  IN VARCHAR2,
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2 )
IS
   source_ref_type_db_            INVENTORY_TRANSACTION_HIST_TAB.source_ref_type%TYPE;
   new_transaction_id_            NUMBER := 0;
   arrival_trans_                 NUMBER := 0;
   cancel_accounting_id_          NUMBER;
   fifo_lifo_                     BOOLEAN := FALSE;
   invepart_rec_                  Inventory_Part_API.Public_Rec;
   part_catalog_rec_              Part_Catalog_API.Public_Rec;
   home_company_                  VARCHAR2(20) := NULL;
   qty_reversed_                  NUMBER := 0;
   dummy_number_                  NUMBER;
   dummy_string_                  VARCHAR2(2000);
   co_arrival_                    BOOLEAN := FALSE;
   transaction_code_              VARCHAR2(10);
   location_type_db_              VARCHAR2(20);
   part_in_stock_rec_             Inventory_Part_In_Stock_API.Public_Rec;
   trancode_rec_                  Mpccom_Transaction_Code_API.Public_Rec;
   prev_current_pos_              VARCHAR2(30);
   serial_message_                VARCHAR2(2000);
   value_tab_rows_                PLS_INTEGER := 0;
   trans_cost_saved_              BOOLEAN;
   cost_lot_batch_no_             INVENTORY_TRANSACTION_HIST_TAB.lot_batch_no%TYPE;
   cost_serial_no_                INVENTORY_TRANSACTION_HIST_TAB.serial_no%TYPE;

   old_trans_cost_detail_tab_     Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   std_cost_detail_tab_           Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   curr_cost_detail_tab_          Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   receipt_value_detail_tab_      Mpccom_Accounting_API.Value_Detail_Tab;
   cancel_value_detail_tab_       Mpccom_Accounting_API.Value_Detail_Tab;
   acquisition_site_              VARCHAR2(5);
   remove_unit_cost_              BOOLEAN;
   reverse_trans_rec_             INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   serial_no_for_stock_           INVENTORY_TRANSACTION_HIST_TAB.serial_no%TYPE;
   curr_operational_condition_db_ VARCHAR2(20);
   prev_operational_condition_db_ VARCHAR2(20);
   prevent_fifo_action_           BOOLEAN := FALSE;
   serial_created_by_this_receip_ BOOLEAN := FALSE;
   transit_hu_tab_                Handling_Unit_API.Handling_Unit_Id_Tab;
   transit_handling_unit_         NUMBER;
   suppl_mtrl_issue_trans_tab_    Mpccom_Transaction_Code_API.Transaction_Code_Tab;
   suppl_mtrl_dir_del_trans_tab_  Mpccom_Transaction_Code_API.Transaction_Code_Tab;
   delivering_warehouse_id_       VARCHAR2(50) := '*';
   receiving_warehouse_id_        VARCHAR2(50) := '*';
   catch_qty_to_unreceive_        NUMBER := NULL;
   lot_batch_no_                  INVENTORY_TRANSACTION_HIST_TAB.lot_batch_no%TYPE := '*'; 
   serial_no_                     INVENTORY_TRANSACTION_HIST_TAB.serial_no%TYPE := '*';
   
   TYPE Cancel_Order_Receipt_Cost_Rec IS RECORD
      (configuration_id           INVENTORY_TRANSACTION_HIST_TAB.configuration_id%TYPE,
       lot_batch_no               INVENTORY_TRANSACTION_HIST_TAB.lot_batch_no%TYPE,
       serial_no                  INVENTORY_TRANSACTION_HIST_TAB.serial_no%TYPE,
       cost_detail_tab            Inventory_Part_Unit_Cost_API.Cost_Detail_Tab);

   TYPE Cancel_Order_Receipt_Cost_Tab IS TABLE OF Cancel_Order_Receipt_Cost_Rec
   INDEX BY PLS_INTEGER;

   cancel_cost_detail_tab_ Cancel_Order_Receipt_Cost_Tab;

   CURSOR Check_For_Consignment IS
      SELECT 1
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  (quantity - qty_reversed) > 0
      AND    transaction_code = 'CO-ARRIVAL'
      AND    source_ref_type  = source_ref_type_db_
      AND    source_ref1      = source_ref1_
      AND    source_ref2      = source_ref2_
      AND    source_ref3      = source_ref3_
      AND    source_ref4      = source_ref4_;

   CURSOR get_transactions IS
      SELECT *
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1   = source_ref1_
      AND    source_ref2   = source_ref2_
      AND    source_ref3   = source_ref3_
      AND    (source_ref4   = source_ref4_ OR source_ref_type = Order_Type_API.DB_SHIPMENT_ORDER)
      AND    source_ref_type = source_ref_type_db_
      AND    (quantity - qty_reversed) > 0
      AND    transaction_code NOT IN (SELECT * FROM TABLE (suppl_mtrl_issue_trans_tab_)) -- dont reverse shipping of material
      AND    transaction_code NOT IN (SELECT * FROM TABLE (suppl_mtrl_dir_del_trans_tab_)) -- Do not reverse the direct delivery of materials
      ORDER BY transaction_id DESC;
      
   TYPE Transactions_Tab IS TABLE OF get_transactions%ROWTYPE;
   transactions_tab_    Transactions_Tab;
BEGIN
   source_ref_type_db_ := Order_Type_API.Encode(source_ref_type_);
   suppl_mtrl_issue_trans_tab_ := Mpccom_Transaction_Code_API.Get_Suppl_Mtrl_Issue_Trans;
   suppl_mtrl_dir_del_trans_tab_ := Mpccom_Transaction_Code_API.Get_Suppl_Mtrl_Dir_Del_Trans;
   
   Transport_Task_API.Remove_Unexecuted_Tasks(source_ref1_, source_ref2_, source_ref3_, source_ref4_, NULL, NULL,  source_ref_type_db_, Fnd_Boolean_API.DB_FALSE);

   -- Is this a Consignment Stock Receipt ?
   IF (source_ref_type_db_ = Order_Type_API.DB_PURCHASE_ORDER)THEN
      OPEN Check_For_Consignment;
      FETCH Check_For_Consignment INTO dummy_number_;
      IF Check_For_Consignment%FOUND THEN
         co_arrival_ := TRUE;
      END IF;
      CLOSE Check_For_Consignment;
   END IF;
   
   value_tab_rows_ := 0;

   invepart_rec_     := Inventory_Part_API.Get(contract_, part_no_);
   part_catalog_rec_ := Part_Catalog_API.Get(part_no_);
   home_company_     := Site_API.Get_Company(contract_);

   IF (invepart_rec_.inventory_valuation_method IN ('FIFO','LIFO') ) THEN
      fifo_lifo_ := TRUE;
   END IF;
   
   Inventory_Event_Manager_API.Start_Session;
   
   -- This method removes the connection between the superior part and the component parts before reversing the connected transactions.
   -- This should be executed only when Backflush method enabled for "Supplier Material" in the site.
   IF (source_ref_type_db_ = Order_Type_API.DB_PURCHASE_ORDER) THEN
       Remove_Superior_Connection___( source_ref1_, 
                                  source_ref2_, 
                                  source_ref3_, 
                                  source_ref4_,
                                  source_ref_type_db_ );
   END IF;   
  
   OPEN get_transactions;
   FETCH get_transactions BULK COLLECT INTO transactions_tab_;
   CLOSE get_transactions;
   
   IF (transactions_tab_.COUNT > 0) THEN
      -- Get the inventory part in stock information from the + transactions in order to take a snapshot of which
      -- handling units they affect.
      FOR i IN transactions_tab_.FIRST .. transactions_tab_.LAST LOOP
         old_trans_cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(
                                                                         transaction_id_           => transactions_tab_(i).transaction_id,
                                                                         include_added_details_    => FALSE,
                                                                         include_normal_details_   => TRUE,
                                                                         replace_star_cost_bucket_ => TRUE);

         trancode_rec_        := Mpccom_Transaction_Code_API.Get(transactions_tab_(i).transaction_code);
         serial_no_for_stock_ := transactions_tab_(i).serial_no;
         location_type_db_    := Inventory_Location_API.Get_Location_Type_Db(transactions_tab_(i).contract, transactions_tab_(i).location_no);

         IF ((serial_no_for_stock_ != '*') AND (transactions_tab_(i).direction = '+')) THEN
            -- We will try to reverse this transaction by issuing the serial from stock
            IF NOT (Inventory_Part_In_Stock_API.Check_Exist(transactions_tab_(i).contract,          
                                                            transactions_tab_(i).part_no,           
                                                            transactions_tab_(i).configuration_id,  
                                                            transactions_tab_(i).location_no,       
                                                            transactions_tab_(i).lot_batch_no,      
                                                            serial_no_for_stock_,         
                                                            transactions_tab_(i).eng_chg_level,     
                                                            transactions_tab_(i).waiv_dev_rej_no,   
                                                            NVL(transactions_tab_(i).activity_seq,0),
                                                            NVL(transactions_tab_(i).handling_unit_id,0))) THEN
               -- The serial does not exist in Inventory on the given stock record
               serial_no_for_stock_ := Inventory_Part_In_Stock_API.Get_Serial_No_For_Stock(transactions_tab_(i).part_no,
                                                                                           serial_no_for_stock_,
                                                                                           part_catalog_rec_,
                                                                                           location_type_db_,
                                                                                           NVL(transactions_tab_(i).handling_unit_id,0));
               -- IF the part is Serial Tracked only during Receipt and Issue but not in Inventory and if this 
               -- transaction received the serial into a Picking, Floor stock or Production line location then the quantity
               -- was put on an Inventory Part In Stock record with serial_no = '*'. Method Get_Serial_No_For_Stock will then
               -- under these circumstances replace the real serial number with '*' and the call below will find the correct
               -- stock record. The same logic is then implemented in Issue_Part_Impl___ in InventoryPartInStock.apy so we can 
               -- still pass the original serial number to Inventory_Part_In_Stock_API.Unreceive_Part().
            END IF;
         END IF;

         part_in_stock_rec_ := Inventory_Part_In_Stock_API.Get(transactions_tab_(i).contract,
                                                               transactions_tab_(i).part_no,
                                                               transactions_tab_(i).configuration_id,
                                                               transactions_tab_(i).location_no,
                                                               transactions_tab_(i).lot_batch_no,
                                                               serial_no_for_stock_,
                                                               transactions_tab_(i).eng_chg_level,
                                                               transactions_tab_(i).waiv_dev_rej_no,
                                                               NVL(transactions_tab_(i).activity_seq,0),
                                                               NVL(transactions_tab_(i).handling_unit_id,0));

         IF (part_in_stock_rec_.part_ownership     != transactions_tab_(i).part_ownership)   OR
            (part_in_stock_rec_.owning_vendor_no   != transactions_tab_(i).owning_vendor_no) OR
            (part_in_stock_rec_.owning_customer_no != transactions_tab_(i).owning_customer_no) THEN
            Error_SYS.Record_General(lu_name_, 'DIFFERENTOWNERSHIP: Transaction cannot be reversed when current ownership info is different to that of the original transaction, Transaction Id :P1.', transactions_tab_(i).transaction_id);
         END IF;

         IF (invepart_rec_.inventory_valuation_method = 'ST') THEN
            -- When the first transaction for a specific cost level is found we need
            -- to retrive and save the current part unit cost. The reason is that
            -- part unit cost could be removed once we start reversing the receipt transactions.
            IF (invepart_rec_.inventory_part_cost_level IN ('COST PER PART',
                                                            'COST PER CONFIGURATION')) THEN
               cost_lot_batch_no_ := '*';
               cost_serial_no_    := '*';
            ELSE
               cost_lot_batch_no_ := transactions_tab_(i).lot_batch_no;
               cost_serial_no_    := transactions_tab_(i).serial_no;
            END IF;
            trans_cost_saved_ := FALSE;
            FOR i IN 1..value_tab_rows_ LOOP
               IF ((cancel_cost_detail_tab_(i).configuration_id = transactions_tab_(i).configuration_id) AND
                   (cancel_cost_detail_tab_(i).lot_batch_no     = cost_lot_batch_no_)            AND
                   (cancel_cost_detail_tab_(i).serial_no        = cost_serial_no_))              THEN
                  std_cost_detail_tab_  := cancel_cost_detail_tab_(value_tab_rows_).cost_detail_tab;
                  trans_cost_saved_ := TRUE;
                  EXIT;
               END IF;
            END LOOP;
            IF NOT (trans_cost_saved_) THEN
               std_cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                                  transactions_tab_(i).contract,
                                                                  transactions_tab_(i).part_no,
                                                                  transactions_tab_(i).configuration_id,
                                                                  cost_lot_batch_no_,
                                                                  cost_serial_no_);

               value_tab_rows_ := value_tab_rows_ + 1;
               cancel_cost_detail_tab_(value_tab_rows_).configuration_id := transactions_tab_(i).configuration_id;
               cancel_cost_detail_tab_(value_tab_rows_).lot_batch_no     := cost_lot_batch_no_;
               cancel_cost_detail_tab_(value_tab_rows_).serial_no        := cost_serial_no_;
               cancel_cost_detail_tab_(value_tab_rows_).cost_detail_tab  := std_cost_detail_tab_;
            END IF;
         END IF;

         IF (transactions_tab_(i).direction = '+') THEN
            IF co_arrival_ THEN -- This is a Consignment Stock Receipt.
               IF location_type_db_ NOT IN ('QA','ARRIVAL') THEN

                  -- Is location_no a consignment inventory ? IF so, owned by which vendor ?
                  IF part_in_stock_rec_.part_ownership = 'CONSIGNMENT' THEN
                     IF part_in_stock_rec_.owning_vendor_no != transactions_tab_(i).owning_vendor_no THEN
                        Error_SYS.Record_General(lu_name_,'DIFFCON: Parts at location :P1 is not owned by vendor :P2.', transactions_tab_(i).location_no, transactions_tab_(i).owning_vendor_no);
                     END IF;
                  ELSE
                     Error_SYS.Record_General(lu_name_,'REMCON: Parts at location :P1 is not in Consignment Stock.', transactions_tab_(i).location_no);
                  END IF;
               END IF;
            END IF;
            IF ((NVL(part_in_stock_rec_.qty_onhand,0) - nvl(part_in_stock_rec_.qty_reserved,0)) < transactions_tab_(i).quantity) THEN
               Error_SYS.Record_General('InventoryTransactionHist', 'MOVED: Received quantity is no longer available at :P1 in :P2. To cancel the receipt, the parts need to be available in the location where they were finally stored during the purchase receipt process.', transactions_tab_(i).location_no, transactions_tab_(i).contract);
            END IF;

            -- Check if this specific transaction modified a Consignment Location or not.
            IF (transactions_tab_(i).source_ref_type = Order_Type_API.DB_SHIPMENT_ORDER) THEN    
               transaction_code_ := 'UNR-SHPOD-'; 
            ELSE 
               transaction_code_ := 'UNRCPT-';
            END IF;

            IF (transactions_tab_(i).transaction_code IN ('ARRTRAN','SHIPODSIT+','SHIPODWHS+')) THEN
               IF (transactions_tab_(i).transaction_code = 'SHIPODSIT+')THEN 
                  transaction_code_ := 'UNR-SHPODS';
               ELSIF(transactions_tab_(i).transaction_code = 'SHIPODWHS+')THEN 
                  transaction_code_ := 'UNR-SHPODW';
               ELSE      
                  transaction_code_ := 'UNRC-ARRTR';
                  IF (Mpccom_Accounting_API.Check_Credit_Str_Code_Exist(transactions_tab_(i).accounting_id, 'M4') = 1) THEN
                     Error_SYS.Record_General(lu_name_, 'NOCANCM4: Cancel of Receipt for an Internal Purchase Receipt Line is not allowed when the credit type posting account is M4.');
                  END IF;
               END IF;
               remove_unit_cost_ := FALSE;         
            ELSE
               remove_unit_cost_ := TRUE;
            END IF;

            IF (trancode_rec_.consignment_stock = 'VENDOR CONSIGNMENT')THEN
               transaction_code_ := Mpccom_Transaction_Code_API.Get_Corresponding_Transaction(transaction_code_);
            END IF;

            IF (transactions_tab_(i).transaction_code IN ('INVM-IN', 'LOT-IN')) THEN
               prevent_fifo_action_ := TRUE;
            ELSE
               prevent_fifo_action_ := FALSE;
            END IF;

            Inventory_Part_In_Stock_API.Unreceive_Part(transaction_id_              => new_transaction_id_,
                                                       contract_                    => transactions_tab_(i).contract,
                                                       part_no_                     => transactions_tab_(i).part_no,
                                                       configuration_id_            => transactions_tab_(i).configuration_id,
                                                       location_no_                 => transactions_tab_(i).location_no,
                                                       lot_batch_no_                => transactions_tab_(i).lot_batch_no,
                                                       serial_no_                   => transactions_tab_(i).serial_no,
                                                       eng_chg_level_               => transactions_tab_(i).eng_chg_level,
                                                       waiv_dev_rej_no_             => transactions_tab_(i).waiv_dev_rej_no,
                                                       activity_seq_                => NVL(transactions_tab_(i).activity_seq,0),
                                                       handling_unit_id_            => NVL(transactions_tab_(i).handling_unit_id, 0),
                                                       org_transaction_id_          => transactions_tab_(i).transaction_id,
                                                       transaction_                 => transaction_code_,
                                                       quantity_                    => transactions_tab_(i).quantity,
                                                       old_quantity_                => transactions_tab_(i).quantity,
                                                       catch_quantity_              => transactions_tab_(i).catch_quantity,
                                                       order_no_                    => transactions_tab_(i).source_ref1,
                                                       line_no_                     => transactions_tab_(i).source_ref2,
                                                       release_no_                  => transactions_tab_(i).source_ref3,
                                                       line_item_no_                => transactions_tab_(i).source_ref4,
                                                       source_                      => transactions_tab_(i).source,
                                                       cost_detail_tab_             => old_trans_cost_detail_tab_,
                                                       order_type_                  => Order_Type_API.Decode(transactions_tab_(i).source_ref_type),
                                                       remove_unit_cost_            => remove_unit_cost_,
                                                       prevent_fifo_action_         => prevent_fifo_action_,
                                                       validate_hu_struct_position_ => FALSE);

            Modify_Qty_Reversed(transactions_tab_(i).transaction_id,
                                transactions_tab_(i).qty_reversed + transactions_tab_(i).quantity);

            reverse_trans_rec_ := Get_Object_By_Keys___(new_transaction_id_);

            IF ((transactions_tab_(i).transaction_code IN ('ARRIVAL','CO-ARRIVAL',
                                                   'ARR-COMP','SERLOTSWAP','PARTSWAP')) AND
                (transactions_tab_(i).part_ownership   IN ('COMPANY OWNED', 'CONSIGNMENT')))    THEN
               arrival_trans_ := new_transaction_id_;
               -- excluding externally owned stock

               IF (invepart_rec_.inventory_valuation_method IN ('FIFO', 'LIFO', 'AV')) THEN
                  -- Inventory Valuation Method is FIFO, LIFO or Weighted Average
                  IF (transactions_tab_(i).transaction_code = 'CO-ARRIVAL') THEN
                     Error_SYS.Record_General(lu_name_, 'CONSVALMET: The inventory value method must be standard cost when there are goods in Consignment Stock.');
                  END IF;
                  cancel_value_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Value_Details(new_transaction_id_,
                                                                                                           reverse_trans_rec_.quantity);
               ELSIF (invepart_rec_.inventory_valuation_method = 'ST') THEN
                  -- Inventory Valuation Method is Standard Cost.
                  cancel_value_detail_tab_ := Create_Value_Detail_Tab(std_cost_detail_tab_,
                                                                      transactions_tab_(i).quantity,
                                                                      transactions_tab_(i).part_no );
               ELSE
                  Error_SYS.Record_General(lu_name_, 'VALMETERR: There is no support for Inventory Valuation Method :P1 in method Cancel_Order_Receipt. Contact system support.',Inventory_Value_Method_API.Decode(invepart_rec_.inventory_valuation_method));
               END IF;
               receipt_value_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Value_Details(transactions_tab_(i).transaction_id,
                                                                                                         transactions_tab_(i).quantity);
               Reval_Cancel_Order_Receipt___(cancel_value_detail_tab_,
                                             receipt_value_detail_tab_,
                                             new_transaction_id_,
                                             transactions_tab_(i).transaction_code,
                                             home_company_,
                                             per_oh_adjustment_id_ => NULL);
            END IF;

            IF ((transactions_tab_(i).transaction_code IN ('ARRIVAL', 'SHIPODSIT+', 'SHIPODWHS+', 'ARRTRAN', 'CO-ARRIVAL', 'ARR-COMP',
                                                  'SERLOTSWAP','PARTSWAP', 'SERIAL-IN')) AND
                (transactions_tab_(i).serial_no != '*')) THEN
               IF (Part_Serial_Catalog_API.EXISTS(transactions_tab_(i).part_no, transactions_tab_(i).serial_no)) THEN
                   -- Receipt has been cancelled for an individual.
                  -- Find the previous state (current position) in Part Serial Catalog and restore this state.
                  -- IF no previous state exists the individual did not exist before the arrival was registered,
                  -- in this case the record should be removed
                  IF (Part_Serial_History_API.Current_Position_Is_Changed(transactions_tab_(i).part_no, transactions_tab_(i).serial_no, transactions_tab_(i).transaction_id)) THEN
                     Error_SYS.Record_General(lu_name_, 'UNDOCRORECEIPT: Subsequent transactions on the serial part :P1 prevent the reversal of this receipt.', transactions_tab_(i).serial_no );
                  END IF;

                  serial_created_by_this_receip_ := Part_Serial_Catalog_API.Created_By(transactions_tab_(i).part_no,
                                                                                       transactions_tab_(i).serial_no,
                                                                                       transactions_tab_(i).source_ref1,
                                                                                       transactions_tab_(i).source_ref2,
                                                                                       transactions_tab_(i).source_ref3,
                                                                                       transactions_tab_(i).source_ref4,
                                                                                       transactions_tab_(i).source_ref_type);
                  --if this Serial no combination was originated from the same order in the receipt delete the serials
                  IF (serial_created_by_this_receip_) THEN
                     -- The serial did not exist before the receipt. Remove the record
                     $IF Component_Vim_SYS.INSTALLED $THEN
                        Vim_Serial_API.Remove_Serial(transactions_tab_(i).part_no, transactions_tab_(i).serial_no); 
                     $END
                     Part_Serial_Catalog_API.Remove(transactions_tab_(i).part_no, transactions_tab_(i).serial_no,  force_removal_ => TRUE );
                  ELSE       
                     curr_operational_condition_db_ := Part_Serial_Catalog_API.Get_Operational_Condition_Db(transactions_tab_(i).part_no, transactions_tab_(i).serial_no);
                     prev_operational_condition_db_ := Part_Serial_History_API.Get_Operational_Condition_Db(transactions_tab_(i).transaction_id);

                     IF (curr_operational_condition_db_ != prev_operational_condition_db_) THEN
                        Part_Serial_Catalog_API.Set_Operational_Condition(info_                     => dummy_string_,
                                                                          part_no_                  => transactions_tab_(i).part_no,
                                                                          serial_no_                => transactions_tab_(i).serial_no,
                                                                          operational_condition_db_ => prev_operational_condition_db_,
                                                                          update_structure_         => false_,
                                                                          validate_structure_       => true_,
                                                                          reversing_earlier_update_ => TRUE);
                     END IF;
                     prev_current_pos_ := Part_Serial_Catalog_API.Get_Previous_Current_Position(transactions_tab_(i).part_no, transactions_tab_(i).serial_no);
                     serial_message_ := Get_Serial_Message___('PSCUNRCPTC');           

                     CASE prev_current_pos_
                     WHEN 'Issued' THEN
                        Part_Serial_Catalog_API.Issue(transactions_tab_(i).part_no, transactions_tab_(i).serial_no,
                                                   serial_message_,
                                                   source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                                   source_ref_type_, new_transaction_id_);
                     WHEN 'UnderTransportation' THEN
                        Part_Serial_Catalog_API.Move_To_Transport(transactions_tab_(i).part_no, transactions_tab_(i).serial_no,
                                                               serial_message_,
                                                               source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                                               source_ref_type_, new_transaction_id_);
                     WHEN 'ReturnedToSupplier' THEN
                        Part_Serial_Catalog_API.Return_To_Supplier(transactions_tab_(i).part_no, transactions_tab_(i).serial_no,
                                                                serial_message_,
                                                                source_ref1_, source_ref2_, source_ref3_, source_ref4_,
                                                                source_ref_type_, new_transaction_id_);
                     -- Note: Added this condition to change the current position to In Facility when the purchase receipt is calceled for MRO Flow.
                     WHEN 'InFacility' THEN
                        Part_Serial_Catalog_API.Move_To_Facility(transactions_tab_(i).part_no, transactions_tab_(i).serial_no,
                                                                 new_transaction_id_, serial_message_);
                     END CASE;
                  END IF;
              END IF;
            END IF;

            IF (transactions_tab_(i).transaction_code IN ('SHIPODSIT+', 'SHIPODWHS+') OR 
               (transactions_tab_(i).transaction_code = 'ARRTRAN' AND transactions_tab_(i).part_ownership = 'COMPANY OWNED')) THEN
               -- ARRTRAN is not allowed to be reversed for parts with valutaion method FIFO/LIFO
               IF (fifo_lifo_ = TRUE) THEN
                  Error_SYS.Record_General(lu_name_, 'TRANSFIFO: Cancel of Receipt for an Internal Purchase Receipt Line is not allowed when the inventory valuation method is FIFO/LIFO.');
               END IF;
               
               Get_Site_And_Warehouse_Info___(acquisition_site_,
                                              delivering_warehouse_id_,
                                              receiving_warehouse_id_,
                                              transactions_tab_(i).source_ref1,
                                              transactions_tab_(i).source_ref_type);
               
               IF (Part_Serial_Catalog_API.Check_Exist(transactions_tab_(i).part_no, transactions_tab_(i).serial_no) = true_) OR
                     (part_catalog_rec_.receipt_issue_serial_track = false_) THEN
                     lot_batch_no_           := transactions_tab_(i).lot_batch_no;
                     serial_no_              := transactions_tab_(i).serial_no;
                     catch_qty_to_unreceive_ := transactions_tab_(i).catch_quantity;
               END IF;      

               IF (acquisition_site_ IS NOT NULL) THEN
                  IF (NVL(transactions_tab_(i).handling_unit_id,0) != 0) THEN
                     transit_hu_tab_(transactions_tab_(i).handling_unit_id).handling_unit_id := transactions_tab_(i).handling_unit_id;
                  END IF;
                     Inventory_Part_In_Transit_API.Unreceive_Part_To_Transit(delivering_contract_           => acquisition_site_,
                                                                             contract_                      => transactions_tab_(i).contract,
                                                                             part_no_                       => transactions_tab_(i).part_no,
                                                                             configuration_id_              => transactions_tab_(i).configuration_id,
                                                                             lot_batch_no_                  => lot_batch_no_,
                                                                             serial_no_                     => serial_no_,
                                                                             eng_chg_level_                 => transactions_tab_(i).eng_chg_level,
                                                                             waiv_dev_rej_no_               => transactions_tab_(i).waiv_dev_rej_no,
                                                                             handling_unit_id_              => NVL(transactions_tab_(i).handling_unit_id,0),
                                                                             expiration_date_               => transactions_tab_(i).expiration_date,
                                                                             delivering_warehouse_id_       => delivering_warehouse_id_,
                                                                             receiving_warehouse_id_        => receiving_warehouse_id_,
                                                                             activity_seq_                  => NVL(transactions_tab_(i).activity_seq, 0),
                                                                             part_ownership_db_             => transactions_tab_(i).part_ownership,
                                                                             owning_customer_no_            => NVL(transactions_tab_(i).owning_customer_no, '*'),
                                                                             owning_vendor_no_              => NVL(transactions_tab_(i).owning_vendor_no, '*'),
                                                                             deliv_no_                      => 0,
                                                                             shipment_id_                   => 0,
                                                                             shipment_line_no_              => 0,
                                                                             qty_to_unreceive_              => transactions_tab_(i).quantity,
                                                                             catch_qty_to_unreceive_        => catch_qty_to_unreceive_,
                                                                             validate_hu_struct_position_   => FALSE);                  
               END IF;
            END IF;
         ELSIF (transactions_tab_(i).direction = '-') THEN
            -- Check if this specific transaction modified a Consignment Location or not.
            IF (transactions_tab_(i).source_ref_type = Order_Type_API.DB_SHIPMENT_ORDER) THEN
               transaction_code_ := 'UNR-SHPOD+';   
            ELSE 
               transaction_code_ := 'UNRCPT+';
            END IF;

            IF (trancode_rec_.consignment_stock = 'VENDOR CONSIGNMENT') THEN
               transaction_code_ := Mpccom_Transaction_Code_API.Get_Corresponding_Transaction(transaction_code_);
            END IF;

            IF (invepart_rec_.inventory_valuation_method = 'ST') THEN
               -- Pass the current standard cost for the part as the transaction cost.
               -- Since the record in InventoryPartUnitCost could have been removed while reversing
               -- the previous transaction in the receipt chain of transactions the current standard
               -- cost is kept in a variable.
               curr_cost_detail_tab_ := std_cost_detail_tab_;
            ELSE
               curr_cost_detail_tab_ := old_trans_cost_detail_tab_;
            END IF;

            Inventory_Part_In_Stock_API.Unissue_Part(transaction_id_                => new_transaction_id_,
                                                     contract_                      => transactions_tab_(i).contract,
                                                     part_no_                       => transactions_tab_(i).part_no,
                                                     configuration_id_              => transactions_tab_(i).configuration_id,
                                                     location_no_                   => transactions_tab_(i).location_no,
                                                     lot_batch_no_                  => transactions_tab_(i).lot_batch_no,
                                                     serial_no_                     => transactions_tab_(i).serial_no,
                                                     eng_chg_level_                 => transactions_tab_(i).eng_chg_level,
                                                     waiv_dev_rej_no_               => transactions_tab_(i).waiv_dev_rej_no,
                                                     activity_seq_                  => NVL(transactions_tab_(i).activity_seq,0),
                                                     handling_unit_id_              => NVL(transactions_tab_(i).handling_unit_id, 0),
                                                     transaction_                   => transaction_code_,
                                                     expiration_date_               => transactions_tab_(i).expiration_date,
                                                     accounting_id_issue_           => transactions_tab_(i).accounting_id,
                                                     quantity_issued_               => transactions_tab_(i).quantity,
                                                     quantity_                      => transactions_tab_(i).quantity,
                                                     catch_quantity_                => transactions_tab_(i).catch_quantity,
                                                     order_no_                      => transactions_tab_(i).source_ref1,
                                                     line_no_                       => transactions_tab_(i).source_ref2,
                                                     release_no_                    => transactions_tab_(i).source_ref3,
                                                     line_item_no_                  => transactions_tab_(i).source_ref4,
                                                     source_                        => transactions_tab_(i).source,
                                                     order_type_                    => Order_Type_API.Decode(transactions_tab_(i).source_ref_type),
                                                     transaction_id_issue_          => transactions_tab_(i).transaction_id,
                                                     cost_detail_tab_               => curr_cost_detail_tab_,
                                                     validate_hu_struct_position_   => FALSE);
                                                     
         ELSIF (transactions_tab_(i).direction = '0') THEN
            qty_reversed_ := transactions_tab_(i).qty_reversed + transactions_tab_(i).quantity;

            -- Check if this specific transaction modified a Consignment Location or not.
            transaction_code_ := 'UNRCPT';

            IF (trancode_rec_.consignment_stock = 'VENDOR CONSIGNMENT') THEN
               transaction_code_ := Mpccom_Transaction_Code_API.Get_Corresponding_Transaction(transaction_code_);
            END IF;

            New(transaction_id_         => new_transaction_id_,
                accounting_id_          => cancel_accounting_id_,
                value_                  => dummy_number_,
                transaction_code_       => transaction_code_,
                contract_               => transactions_tab_(i).contract,
                part_no_                => transactions_tab_(i).part_no,
                configuration_id_       => transactions_tab_(i).configuration_id,
                location_no_            => transactions_tab_(i).location_no,
                lot_batch_no_           => transactions_tab_(i).lot_batch_no,
                serial_no_              => transactions_tab_(i).serial_no,
                waiv_dev_rej_no_        => transactions_tab_(i).waiv_dev_rej_no,
                eng_chg_level_          => transactions_tab_(i).eng_chg_level,
                activity_seq_           => NVL(transactions_tab_(i).activity_seq,0),
                handling_unit_id_       => NVL(transactions_tab_(i).handling_unit_id, 0),
                project_id_             => transactions_tab_(i).project_id,
                source_ref1_            => transactions_tab_(i).source_ref1,
                source_ref2_            => transactions_tab_(i).source_ref2,
                source_ref3_            => transactions_tab_(i).source_ref3,
                source_ref4_            => transactions_tab_(i).source_ref4,
                source_ref5_            => transactions_tab_(i).source_ref5,
                reject_code_            => NULL,
                cost_detail_tab_        => old_trans_cost_detail_tab_,
                unit_cost_              => NULL,
                quantity_               => transactions_tab_(i).quantity,
                qty_reversed_           => qty_reversed_,
                catch_quantity_         => NULL,
                source_                 => transactions_tab_(i).source,
                source_ref_type_        => Order_Type_API.Decode(transactions_tab_(i).source_ref_type),
                owning_vendor_no_       => NULL,
                condition_code_         => NULL,
                location_group_         => NULL,
                part_ownership_db_      => 'COMPANY OWNED',
                owning_customer_no_     => NULL,
                expiration_date_        => NULL,
                transit_location_group_ => transactions_tab_(i).transit_location_group);

            Set_Original_Transaction_Id(new_transaction_id_, transactions_tab_(i).transaction_id);

            Reverse_Accounting(new_transaction_id_, transactions_tab_(i).transaction_id);

            Modify_Qty_Reversed(transactions_tab_(i).transaction_id, qty_reversed_);
         ELSE
            Error_SYS.Record_General('InventoryTransactionHist', 'CANCELDIRER: Direction error for transaction :P1', transactions_tab_(i).transaction_id);
         END IF;
      END LOOP;
   END IF;
   
   IF (transit_hu_tab_.COUNT > 0) THEN
      -- All handling units returned into transit must be validated since we skipped the structure validation while
      -- reversing the transactions
      transit_handling_unit_ := transit_hu_tab_.FIRST;
      WHILE transit_handling_unit_ IS NOT NULL LOOP
         DECLARE
            handling_unit_id_ NUMBER;
            outermost_hu_id_  NUMBER;
            structure_error   EXCEPTION;
            PRAGMA            EXCEPTION_INIT(structure_error,-20110);
            BEGIN
            -- If the validation fails we should try to move as much of the structure as possible back into transit.
            Handling_Unit_API.Validate_Structure_Position(transit_handling_unit_);
         EXCEPTION
            WHEN structure_error THEN
               handling_unit_id_ := transit_handling_unit_;
               -- Since the transactions have already been reversed into transit the handling units does not have 
               -- quantity in stock, therfore we try to disconnect as much of the empty structure as possible.
               WHILE Handling_Unit_API.Has_Quantity_In_Stock(handling_unit_id_) = 'FALSE' LOOP
                  outermost_hu_id_ := handling_unit_id_;
                  handling_unit_id_ := Handling_Unit_API.Get_Parent_Handling_Unit_Id(handling_unit_id_);
                  IF (handling_unit_id_ IS NULL) THEN
                     EXIT;
                  END IF;
               END LOOP;
               IF (outermost_hu_id_ IS NOT NULL) THEN 
                  Handling_Unit_API.Modify_Parent_Handling_Unit_Id(outermost_hu_id_, NULL);
               END IF;
               
               -- Try to once again validate the structure, if this fails it is due to that there are
               -- some content in the handling unit that does not belong to the receipt.
               Handling_Unit_API.Validate_Structure_Position(transit_handling_unit_);
         END;
         transit_handling_unit_ := transit_hu_tab_.NEXT(transit_handling_unit_);
      END LOOP;
   END IF;
   
   IF (source_ref_type_db_ = Order_Type_API.DB_PURCHASE_ORDER) THEN
      Cancel_Material_Backflush___(source_ref1_, 
                                   source_ref2_, 
                                   source_ref3_, 
                                   source_ref4_,
                                   source_ref_type_db_);
   END IF;                             
                                
   Inventory_Event_Manager_API.Finish_Session;
END Cancel_Order_Receipt;


-- Reverse_Transaction
--   Generic method to undo some issued or received quantity for a transaction.
PROCEDURE Reverse_Transaction (
   transaction_id_              OUT NUMBER,
   transaction_                 IN  VARCHAR2,
   pos_diff_transaction_        IN  VARCHAR2,
   neg_diff_transaction_        IN  VARCHAR2,
   quantity_                    IN  NUMBER,
   catch_quantity_              IN  NUMBER,
   old_transaction_id_          IN  NUMBER,
   source_                      IN  VARCHAR2,
   validate_hu_struct_position_ IN  BOOLEAN DEFAULT TRUE )
IS
BEGIN
   Reverse_Transaction___(transaction_id_,
                          transaction_,
                          pos_diff_transaction_,
                          neg_diff_transaction_,
                          quantity_,
                          catch_quantity_,
                          old_transaction_id_,
                          source_,
                          issue_mtrl_shop_order_split_ => FALSE,
                          new_issue_order_no_          => NULL,
                          new_issue_release_no_        => NULL,
                          new_issue_sequence_no_       => NULL,
                          new_issue_line_item_no_      => NULL,
                          validate_hu_struct_position_ => validate_hu_struct_position_);
END Reverse_Transaction;


-- Reverse_Accounting
--   Creates postings for a reversal transaction by reversing the postings
--   created for the original transaction. May also create additional postings
--   to balance out differences.
PROCEDURE Reverse_Accounting (
   reverse_transaction_id_  IN NUMBER,
   original_transaction_id_ IN NUMBER,
   value_adjustment_        IN BOOLEAN DEFAULT FALSE,
   per_oh_adjustment_id_    IN NUMBER  DEFAULT NULL,
   trans_reval_event_id_    IN NUMBER  DEFAULT NULL,
   date_applied_            IN DATE    DEFAULT NULL )
IS
   original_trans_rec_        INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   reverse_trans_rec_         INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   pre_trans_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   new_cost_detail_tab_       Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   old_cost_detail_tab_       Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   company_                   VARCHAR2(20);
BEGIN

   reverse_trans_rec_  := Get_Object_By_Keys___(reverse_transaction_id_);
   original_trans_rec_ := Get_Object_By_Keys___(original_transaction_id_);

   company_ := Site_API.Get_Company(reverse_trans_rec_.contract);

   -- Reverse the old accounting.
   Mpccom_Accounting_API.Reverse_Accounting(reverse_trans_rec_.accounting_id,
                                            original_trans_rec_.accounting_id,
                                            reverse_trans_rec_.quantity,
                                            original_trans_rec_.quantity,
                                            date_applied_      => date_applied_);

   -- IF the method has been called from the periodic oh adjustment process there
   -- could be a need to create extra postings to balance a difference in standard cost
   -- in some cases.
   IF (reverse_trans_rec_.inventory_valuation_method = 'ST') THEN
      IF (per_oh_adjustment_id_ IS NOT NULL) THEN
         Reval_Canc_After_Oh_Adjust___(original_transaction_id_,
                                       reverse_transaction_id_,
                                       per_oh_adjustment_id_);
      END IF;

   -- There could be a need to balance the inventory account if the WA has changed since
   -- original transaction occurred
   ELSIF (reverse_trans_rec_.inventory_valuation_method = 'AV') THEN
      Reval_WA_At_Empty_Inventory___(reverse_trans_rec_,
                                     value_adjustment_,
                                     per_oh_adjustment_id_,
                                     trans_reval_event_id_,
                                     date_applied_);

   END IF;

   -- Balance postings for cancel
   IF ((reverse_trans_rec_.transaction_code = 'UNRC-ARRTR') AND
       (reverse_trans_rec_.inventory_valuation_method IN ('AV', 'ST'))) THEN


      -- Check to determine if a inventory/transit revaluation could be needed.
      IF (Company_Invent_Info_API.Get_Use_Trans_Bal_Posting_Db(company_) = 'TRUE') THEN

         IF (reverse_trans_rec_.inventory_valuation_method = 'ST') THEN
            -- The current standard cost is stored on the transaction
            new_cost_detail_tab_ := Get_Transaction_Cost_Details(reverse_trans_rec_.transaction_id);
         ELSE
            -- Retrieve the inventory value prior to the transaction, this will be
            -- the average cost at the time the transaction was created
            new_cost_detail_tab_ := Pre_Invent_Trans_Avg_Cost_API.Get_Cost_Details(
                                                          reverse_trans_rec_.transaction_id);

         END IF;

         -- Retrieve the cost from the receipt transaction
         old_cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(original_transaction_id_);

         Create_Revaluation_Postings___(new_cost_detail_tab_,
                                        old_cost_detail_tab_,
                                        'UNRCPTBAL+',
                                        'UNRCPTBAL-',
                                        reverse_transaction_id_,
                                        reverse_trans_rec_.quantity,
                                        company_,
                                        value_adjustment_     => value_adjustment_,
                                        per_oh_adjustment_id_ => per_oh_adjustment_id_,
                                        trans_reval_event_id_ => trans_reval_event_id_,
                                        date_applied_         => date_applied_);
      END IF;
   END IF;

   IF NOT value_adjustment_ THEN
      -- This code cannot be executed when processing adjustments since
      -- the correct inventory part unit cost after the transaction cannot be retrieved
      -- in that case.
      IF (reverse_trans_rec_.inventory_valuation_method IN ('AV', 'FIFO', 'LIFO')) THEN
         -- Retrieve the inventory value prior to the transaction
         pre_trans_cost_detail_tab_  := Pre_Invent_Trans_Avg_Cost_API.Get_Cost_Details(
                                                          reverse_trans_rec_.transaction_id);
         IF (pre_trans_cost_detail_tab_.COUNT > 0) THEN
            -- Retrieve the inventory value after the transaction
            new_cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                                       reverse_trans_rec_.contract,
                                                                       reverse_trans_rec_.part_no,
                                                                       reverse_trans_rec_.configuration_id,
                                                                       reverse_trans_rec_.lot_batch_no,
                                                                       reverse_trans_rec_.serial_no);

            Balance_Transit_And_Invent___(reverse_trans_rec_,
                                          pre_trans_cost_detail_tab_,
                                          new_cost_detail_tab_,
                                          value_adjustment_     => FALSE,
                                          per_oh_adjustment_id_ => NULL,
                                          trans_reval_event_id_ => trans_reval_event_id_,
                                          date_applied_         => date_applied_);
         END IF;
      END IF;
   END IF;
END Reverse_Accounting;


-- Get_Transaction_Contract
--   Returns the contract for a specific inventory transaction id.
@UncheckedAccess
FUNCTION Get_Transaction_Contract (
   transaction_id_ IN NUMBER ) RETURN VARCHAR2
IS
   temp_ INVENTORY_TRANSACTION_HIST_TAB.contract%TYPE;
   CURSOR get_attr IS
      SELECT contract
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE transaction_id = transaction_id_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Transaction_Contract;


-- Do_Transaction_Booking
--   This procedure does the booking without need of knowing the transaction
--   code which is needed for a consignment stock location when the
--   transaction_code may have changed in the end of the InventoryTransaction procedure.
--   This procedure does the booking without need of knowing the transaction code
--   which is needed for a consignment stock location when the transaction_code
--   may have changed in the end of the InventoryTransaction procedure.
PROCEDURE Do_Transaction_Booking (
   transaction_id_   IN NUMBER,
   company_          IN VARCHAR2,
   complete_flag_    IN VARCHAR2,
   value_            IN NUMBER,
   value_adjustment_ IN BOOLEAN DEFAULT FALSE,
   adjustment_date_  IN DATE    DEFAULT NULL )
IS
   event_code_ VARCHAR2(10);
BEGIN
   event_code_ := Get_Transaction_Code( transaction_id_ );

   Do_Booking(transaction_id_,
              company_,
              event_code_,
              complete_flag_,
              value_,
              value_adjustment_,
              adjustment_date_ );
END Do_Transaction_Booking;


-- Do_Transaction_Booking
--   This procedure does the booking without need of knowing the transaction
--   code which is needed for a consignment stock location when the
--   transaction_code may have changed in the end of the InventoryTransaction procedure.
--   This procedure does the booking without need of knowing the transaction code
--   which is needed for a consignment stock location when the transaction_code
--   may have changed in the end of the InventoryTransaction procedure.
PROCEDURE Do_Transaction_Booking (
   transaction_id_       IN NUMBER,
   trans_reval_event_id_ IN NUMBER DEFAULT NULL,
   value_adjustment_     IN BOOLEAN DEFAULT FALSE )
IS
   empty_value_detail_tab_ Mpccom_Accounting_API.Value_Detail_Tab;
BEGIN
   Do_Booking(transaction_id_,
              NULL,
              NULL,
              'Y',
              empty_value_detail_tab_,
              trans_reval_event_id_ => trans_reval_event_id_,
              value_adjustment_ => value_adjustment_);
END Do_Transaction_Booking;


-- Reset_Partstat_Flag
--   Set Partstat_Flag to 'N'.
PROCEDURE Reset_Partstat_Flag (
   transaction_id_ IN NUMBER )
IS
   record_ inventory_transaction_hist_tab%ROWTYPE;
BEGIN
   record_               := Lock_By_Keys___(transaction_id_);
   record_.partstat_flag := 'N';
   Modify___(record_);
END Reset_Partstat_Flag;


-- Reset_Valuestat_Flag
--   Set Valuestat_Flag to 'N'.
PROCEDURE Reset_Valuestat_Flag (
   transaction_id_ IN NUMBER )
IS
   record_ inventory_transaction_hist_tab%ROWTYPE;
BEGIN
   record_                := Lock_By_Keys___(transaction_id_);
   record_.valuestat_flag := 'N';
   Modify___(record_);
END Reset_Valuestat_Flag;


-- Set_Partstat_Flag
--   Set Partstat_Flag to 'Y'.
PROCEDURE Set_Partstat_Flag (
   transaction_id_ IN NUMBER )
IS
   record_ inventory_transaction_hist_tab%ROWTYPE;
BEGIN
   record_               := Lock_By_Keys___(transaction_id_);
   record_.partstat_flag := 'Y';
   Modify___(record_);
END Set_Partstat_Flag;


-- Set_Valuestat_Flag
--   Sets Valuestat_Flag to 'Y'.
PROCEDURE Set_Valuestat_Flag (
   transaction_id_ IN NUMBER )
IS
   record_ inventory_transaction_hist_tab%ROWTYPE;
BEGIN
   record_                := Lock_By_Keys___(transaction_id_);
   record_.valuestat_flag := 'Y';
   Modify___(record_);
END Set_Valuestat_Flag;


-- Check_Created_Lot_Batch_No
--   Checks if the transaction handles creation of a lot batch no. Lot batch
--   no can be specified upon receipt of a purchase order, if it was not given
--   in the first place. This specific type of a transaction has to be displayed
--   in Part origin tracing.
--   Used in Part tracing to locate lot_batch_nos created during purchase order arrivals
@UncheckedAccess
FUNCTION Check_Created_Lot_Batch_No (
   contract_        IN VARCHAR2,
   part_no_         IN VARCHAR2,
   location_no_     IN VARCHAR2,
   lot_batch_no_    IN VARCHAR2,
   serial_no_       IN VARCHAR2,
   waiv_dev_rej_no_ IN VARCHAR2,
   source_ref1_     IN VARCHAR2,
   source_ref2_     IN VARCHAR2,
   source_ref3_     IN VARCHAR2,
   source_ref4_     IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ NUMBER;

   CURSOR get_attr IS
      SELECT SUM(DECODE(direction, '-',-quantity, '+',quantity))
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE ((lot_batch_no = lot_batch_no_ AND transaction_code IN ('LOT-IN','CO-LOT-IN')) OR
             (lot_batch_no = '*' AND transaction_code IN ('LOT-OUT','CO-LOT-OUT')))
        AND location_no = location_no_
        AND waiv_dev_rej_no = waiv_dev_rej_no_
        AND serial_no = serial_no_
        AND source_ref4 = source_ref4_
        AND source_ref3 = source_ref3_
        AND source_ref2 = source_ref2_
        AND source_ref1 = source_ref1_
        AND part_no = part_no_
        AND contract = contract_;
BEGIN
   IF lot_batch_no_ != '*' THEN
      OPEN get_attr;
      FETCH get_attr INTO temp_;
      IF (get_attr%FOUND) THEN
         IF (temp_ = 0) THEN
           CLOSE get_attr;
           RETURN 'LOT-BATCH-MOVE';
         END IF;
      END IF;
      CLOSE get_attr;
   END IF;
   RETURN 'NOT-LOT-BATCH-MOVE';
END Check_Created_Lot_Batch_No;


-- New
--   Creates a cost detail record using the price_ parameter passed in
--   and calls the overloaded New method to create the actual transaction.
PROCEDURE New (
   transaction_id_               OUT NUMBER,
   accounting_id_                OUT NUMBER,
   value_                        OUT NUMBER,
   transaction_code_             IN  VARCHAR2,
   contract_                     IN  VARCHAR2,
   part_no_                      IN  VARCHAR2,
   configuration_id_             IN  VARCHAR2,
   location_no_                  IN  VARCHAR2,
   lot_batch_no_                 IN  VARCHAR2,
   serial_no_                    IN  VARCHAR2,
   waiv_dev_rej_no_              IN  VARCHAR2,
   eng_chg_level_                IN  VARCHAR2,
   activity_seq_                 IN  NUMBER,
   project_id_                   IN  VARCHAR2,
   source_ref1_                  IN  VARCHAR2,
   source_ref2_                  IN  VARCHAR2,
   source_ref3_                  IN  VARCHAR2,
   source_ref4_                  IN  VARCHAR2,
   source_ref5_                  IN  VARCHAR2,
   reject_code_                  IN  VARCHAR2,
   price_                        IN  NUMBER,
   quantity_                     IN  NUMBER,
   qty_reversed_                 IN  NUMBER,
   catch_quantity_               IN  NUMBER,
   source_                       IN  VARCHAR2,
   source_ref_type_              IN  VARCHAR2 DEFAULT Null,
   owning_vendor_no_             IN  VARCHAR2 DEFAULT Null,
   condition_code_               IN  VARCHAR2 DEFAULT Null,
   location_group_               IN  VARCHAR2 DEFAULT Null,
   part_ownership_db_            IN  VARCHAR2 DEFAULT 'COMPANY OWNED',
   owning_customer_no_           IN  VARCHAR2 DEFAULT Null,
   expiration_date_              IN  DATE     DEFAULT Null ,
   operational_condition_db_     IN  VARCHAR2 DEFAULT Null,
   handling_unit_id_             IN  NUMBER   DEFAULT NULL,
   ownership_transfer_reason_id_ IN  VARCHAR2 DEFAULT NULL,
   delivery_reason_id_           IN  VARCHAR2 DEFAULT NULL, 
   del_note_no_                  IN  VARCHAR2  DEFAULT NULL,
   del_note_date_                IN  DATE      DEFAULT NULL,
   move_dest_contract_           IN  VARCHAR2  DEFAULT NULL,
   move_dest_location_no_        IN  VARCHAR2  DEFAULT NULL)
IS
   empty_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
BEGIN

   New(transaction_id_               => transaction_id_        ,
       accounting_id_                => accounting_id_         ,
       value_                        => value_                 ,
       transaction_code_             => transaction_code_      ,
       contract_                     => contract_              ,
       part_no_                      => part_no_               ,
       configuration_id_             => configuration_id_      ,
       location_no_                  => location_no_           ,
       lot_batch_no_                 => lot_batch_no_          ,
       serial_no_                    => serial_no_             ,
       waiv_dev_rej_no_              => waiv_dev_rej_no_       ,
       eng_chg_level_                => eng_chg_level_         ,
       activity_seq_                 => activity_seq_          ,
       project_id_                   => project_id_            ,
       source_ref1_                  => source_ref1_           ,
       source_ref2_                  => source_ref2_           ,
       source_ref3_                  => source_ref3_           ,
       source_ref4_                  => source_ref4_           ,
       source_ref5_                  => source_ref5_           ,
       reject_code_                  => reject_code_           ,
       cost_detail_tab_              => empty_cost_detail_tab_ ,
       unit_cost_                    => price_                 ,
       quantity_                     => quantity_              ,
       qty_reversed_                 => qty_reversed_          ,
       catch_quantity_               => catch_quantity_        ,
       source_                       => source_                ,
       source_ref_type_              => source_ref_type_       ,
       owning_vendor_no_             => owning_vendor_no_      ,
       condition_code_               => condition_code_        ,
       location_group_               => location_group_        ,
       part_ownership_db_            => part_ownership_db_     ,
       owning_customer_no_           => owning_customer_no_    ,
       expiration_date_              => expiration_date_       ,
       operational_condition_db_     => operational_condition_db_,
       handling_unit_id_        	    => handling_unit_id_       ,
       ownership_transfer_reason_id_ => ownership_transfer_reason_id_,
       delivery_reason_id_           => delivery_reason_id_,
       del_note_no_                  => del_note_no_,
       del_note_date_                => del_note_date_,
       move_dest_contract_           => move_dest_contract_,
       move_dest_location_no_        => move_dest_location_no_);
END New;


-- New
--   Creates a cost detail record using the price_ parameter passed in
--   and calls the overloaded New method to create the actual transaction.
PROCEDURE New (
   transaction_id_               OUT NUMBER,
   accounting_id_                OUT NUMBER,
   value_                        OUT NUMBER,
   transaction_code_             IN  VARCHAR2,
   contract_                     IN  VARCHAR2,
   part_no_                      IN  VARCHAR2,
   configuration_id_             IN  VARCHAR2,
   location_no_                  IN  VARCHAR2,
   lot_batch_no_                 IN  VARCHAR2,
   serial_no_                    IN  VARCHAR2,
   waiv_dev_rej_no_              IN  VARCHAR2,
   eng_chg_level_                IN  VARCHAR2,
   activity_seq_                 IN  NUMBER,
   project_id_                   IN  VARCHAR2,
   source_ref1_                  IN  VARCHAR2,
   source_ref2_                  IN  VARCHAR2,
   source_ref3_                  IN  VARCHAR2,
   source_ref4_                  IN  VARCHAR2,
   source_ref5_                  IN  VARCHAR2,
   reject_code_                  IN  VARCHAR2,
   cost_detail_tab_              IN  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   unit_cost_                    IN  NUMBER,
   quantity_                     IN  NUMBER,
   qty_reversed_                 IN  NUMBER,
   catch_quantity_               IN  NUMBER,
   source_                       IN  VARCHAR2,
   source_ref_type_              IN  VARCHAR2,
   owning_vendor_no_             IN  VARCHAR2,
   condition_code_               IN  VARCHAR2,
   location_group_               IN  VARCHAR2,
   part_ownership_db_            IN  VARCHAR2,
   owning_customer_no_           IN  VARCHAR2,
   expiration_date_              IN  DATE,
   receipt_date_                 IN  DATE     DEFAULT NULL,
   transit_location_group_       IN  VARCHAR2 DEFAULT NULL,
   alt_source_ref1_              IN  VARCHAR2 DEFAULT NULL,
   alt_source_ref2_              IN  VARCHAR2 DEFAULT NULL,
   alt_source_ref3_              IN  VARCHAR2 DEFAULT NULL,
   alt_source_ref4_              IN  VARCHAR2 DEFAULT NULL,
   alt_source_ref5_              IN  VARCHAR2 DEFAULT NULL,
   alt_source_ref_type_db_       IN  VARCHAR2 DEFAULT NULL,
   issue_transaction_id_         IN  NUMBER   DEFAULT NULL,
   report_earned_value_db_       IN  VARCHAR2 DEFAULT NULL,
   operational_condition_db_     IN  VARCHAR2 DEFAULT NULL,
   original_transaction_id_      IN  NUMBER   DEFAULT NULL,
   prevent_fifo_action_          IN  BOOLEAN  DEFAULT FALSE,
   availability_control_id_      IN  VARCHAR2 DEFAULT NULL,
   handling_unit_id_             IN  NUMBER   DEFAULT NULL,
   old_transaction_id_           IN  NUMBER   DEFAULT NULL,
   ownership_transfer_reason_id_ IN  VARCHAR2 DEFAULT NULL,
   delivery_reason_id_           IN  VARCHAR2 DEFAULT NULL, 
   del_note_no_                  IN  VARCHAR2  DEFAULT NULL,
   del_note_date_                IN  DATE      DEFAULT NULL,
   move_dest_contract_           IN  VARCHAR2  DEFAULT NULL,
   move_dest_location_no_        IN  VARCHAR2  DEFAULT NULL)
IS
   attr_                          VARCHAR2(32000);
   objid_                         VARCHAR2(2000);
   objversion_                    VARCHAR2(2000);
   newrec_                        inventory_transaction_hist_tab%ROWTYPE;
   pre_accounting_id_             NUMBER := 0;
   order_type_to_use_             VARCHAR2(200);
   order_type_to_use_db_          VARCHAR2(200);
   planning_method_               VARCHAR2(1);
   company_                       VARCHAR2(2000);
   currency_code_                 VARCHAR2(2000);
   condition_code_to_use_         INVENTORY_TRANSACTION_HIST_TAB.condition_code%TYPE;
   condition_code_to_lot_         INVENTORY_TRANSACTION_HIST_TAB.condition_code%TYPE;
   trancode_rec_                  Mpccom_Transaction_Code_API.Public_Rec;
   part_catalog_rec_              Part_Catalog_API.Public_Rec;
   current_time_today_            DATE;
   today_                         DATE;
   loc_group_to_save_             INVENTORY_TRANSACTION_HIST_TAB.location_group%TYPE;
   freeze_flag_db_                VARCHAR2(1);
   part_rec_                      Inventory_Part_API.Public_Rec;
   pre_trans_level_qty_in_stock_  NUMBER;
   pre_trans_level_qty_in_transi_ NUMBER;
   pre_trans_avg_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   local_cost_detail_tab_         Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   mtrl_overhead_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   sales_oh_cost_detail_tab_      Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   local_unit_cost_               NUMBER := 0;
   inventory_part_                BOOLEAN;
   qty_must_be_greater_than_zero_ BOOLEAN := TRUE;
   must_follow_zero_cost_flag_    BOOLEAN := TRUE;
   fifo_action_                   VARCHAR2(6) := 'NONE';
   conn_transaction_id_           NUMBER;   
   transaction_required_          BOOLEAN := TRUE;
   exit_procedure                 EXCEPTION;
   db_company_owned_              CONSTANT INVENTORY_TRANSACTION_HIST_TAB.part_ownership%TYPE := Part_Ownership_API.DB_COMPANY_OWNED;
   db_consignment_                CONSTANT INVENTORY_TRANSACTION_HIST_TAB.part_ownership%TYPE := Part_Ownership_API.DB_CONSIGNMENT;
   cost_successfully_removed_     BOOLEAN;
   indrec_                        Indicator_Rec;
   warehouse_id_                  warehouse_bay_bin_tab.warehouse_id%TYPE;
   bay_id_                        warehouse_bay_bin_tab.bay_id%TYPE;
   tier_id_                       warehouse_bay_bin_tab.tier_id%TYPE;
   row_id_                        warehouse_bay_bin_tab.row_id%TYPE;
   bin_id_                        warehouse_bay_bin_tab.bin_id%TYPE;
   
BEGIN

   trancode_rec_     := Mpccom_Transaction_Code_API.Get(transaction_code_);
   company_          := Site_API.Get_Company(contract_);
   part_catalog_rec_ := Part_Catalog_API.Get(part_no_);

   IF transaction_code_ IN ('PROJTRAN+', 'PROJTRAN-') THEN
      Check_Activity_Seq___(activity_seq_, 'INVENTORY_BALANCE_CHANGE');
   END IF;

   IF (source_ref_type_ IS NULL) THEN
      order_type_to_use_db_ := trancode_rec_.order_type;
      order_type_to_use_    := Order_Type_API.Decode(trancode_rec_.order_type);
   ELSE
      order_type_to_use_    := source_ref_type_;
      order_type_to_use_db_ := Order_Type_API.Encode(source_ref_type_);
   END IF;

   IF (trancode_rec_.cost_source IN ('PRICE DIFFERENCE',
                                     'COST VARIANCE',
                                     'ROUNDING DIFFERENCE',
                                     'STAGE PAYMENT',
                                     'SCRAP VARIANCE',
                                     'SUM OF COMPONENTS',
                                     'INTERNAL SALES PRICE',
                                     'INVOICE IMBALANCE')) THEN
      must_follow_zero_cost_flag_ := FALSE;
   END IF;
   
   IF (trancode_rec_.cost_source IN ('PRICE DIFFERENCE',
                                     'COST VARIANCE',
                                     'ROUNDING DIFFERENCE',
                                     'STAGE PAYMENT',
                                     'POST COST GROUP CHG',
                                     'INVOICE IMBALANCE')) THEN
      qty_must_be_greater_than_zero_ := FALSE;
   END IF;
   
   IF ((quantity_ <= 0) AND (qty_must_be_greater_than_zero_)) THEN
      Error_SYS.Record_General('InventoryTransactionHist', '1224: The quantity must be greater than 0.');
   END IF;

   IF ((part_no_ IS NULL) OR (transaction_code_ IN ('OESHIPNI','PODIRSH-NI','OERET-NI','OERET-NINO','OERETIN-NI','OERETIN-NO', 'RETDIFS-NI'))) THEN
      -- OESHIPNI has a part number but that is a sales part number, not inventory part.
      inventory_part_ := FALSE;
   ELSE
      inventory_part_ := TRUE;

      IF (transaction_code_ NOT IN ('ROUNDDIFF+','ROUNDDIFF-')) THEN
         planning_method_ := Inventory_Part_Planning_API.Get_Planning_Method(contract_, part_no_);
         IF (planning_method_ IN ('O','K','T')) THEN
            Error_SYS.Record_General(lu_name_, '1225: The Planning Method for the part does not permit inventory transactions.');
         END IF;
      END IF;

      part_rec_ := Inventory_Part_API.Get(contract_, part_no_);
      
      IF (Inventory_Part_API.Cascade_Trans_Cost_Update(part_rec_.invoice_consideration,
                                                       part_rec_.inventory_valuation_method,
                                                       part_rec_.inventory_part_cost_level)) THEN
         Check_Invoice_Reval_Running___(contract_,part_no_);
      END IF;
   END IF;

   Manage_Condition_Code___ (condition_code_to_use_,
                             condition_code_to_lot_,
                             part_no_,
                             serial_no_,
                             lot_batch_no_,
                             condition_code_,
                             trancode_rec_.source_application,
                             trancode_rec_.cost_source,
                             part_catalog_rec_);

   -----------------------------------------------------------------------
   -- Restrict changes in inventory quantity depending on freeze flag
   -----------------------------------------------------------------------
   IF (trancode_rec_.direction IN ('+','-')) THEN
      IF (inventory_part_) THEN
         freeze_flag_db_ := Inventory_Part_In_Stock_API.Get_Freeze_Flag_Db(contract_,
                                                                           part_no_,
                                                                           configuration_id_,
                                                                           location_no_,
                                                                           lot_batch_no_,
                                                                           serial_no_,
                                                                           eng_chg_level_,
                                                                           waiv_dev_rej_no_,
                                                                           activity_seq_,
                                                                           handling_unit_id_);
      END IF;
      IF (Nvl(order_type_to_use_db_,'XxX') != 'COUNTING') THEN
         IF (freeze_flag_db_ = 'Y') THEN
            Error_SYS.Record_General('InventoryTransactionHist', 'FREEZECODE: Inventory part :P1 is locked on location :P2 at site :P3 due to counting.',part_no_, location_no_, contract_);
         END IF;
      END IF;
   END IF;

   current_time_today_ := Site_API.Get_Site_Date(contract_);
   today_              := TRUNC(current_time_today_);

   ------------------------------------------------------------------------------------------------------
   -- Move necessary validations of Consignment and Company Owned stocks to Calculate_Transaction_Cost___
   ------------------------------------------------------------------------------------------------------
   IF part_ownership_db_ IN (db_company_owned_,db_consignment_) THEN
      local_cost_detail_tab_ := cost_detail_tab_;

      IF (inventory_part_) THEN
         Calculate_Transaction_Cost___ ( fifo_action_,
                                         conn_transaction_id_,
                                         pre_trans_level_qty_in_stock_,
                                         pre_trans_level_qty_in_transi_,
                                         pre_trans_avg_cost_detail_tab_,
                                         transaction_required_,
                                         local_cost_detail_tab_,
                                         transaction_code_,
                                         contract_,
                                         part_no_,
                                         part_rec_,
                                         configuration_id_,
                                         lot_batch_no_,
                                         serial_no_,
                                         trancode_rec_,
                                         condition_code_to_use_,
                                         unit_cost_,
                                         quantity_,
                                         qty_reversed_,
                                         source_ref1_,
                                         source_ref2_,
                                         source_ref3_,
                                         source_ref4_,
                                         order_type_to_use_db_,
                                         company_,
                                         issue_transaction_id_);

         -- Override fifo_action_ in order to allow Reverse_Transaction___() to handle the fifo_costs for Shop Order splits.
         IF (prevent_fifo_action_) THEN
            fifo_action_ := 'NONE';
         END IF;

         IF (trancode_rec_.inventory_stat_direction = 'ISSUE') THEN 
            IF (part_rec_.lifecycle_stage IN (Inv_Part_Lifecycle_Stage_API.DB_DECLINE, Inv_Part_Lifecycle_Stage_API.DB_EXPIRED)) THEN
               Inventory_Part_API.Add_Issue_For_Decline_Expired(contract_, part_no_);  
            END IF;
            IF (NVL(part_rec_.latest_stat_issue_date,Database_Sys.first_calendar_date_) != today_) THEN
               Inventory_Part_API.Modify_Latest_Stat_Issue_Date(contract_, part_no_, today_);
            END IF;         
         END IF;
      ELSE
         -- Transactions not having any inventory part number.
         local_unit_cost_ := unit_cost_;
         IF (local_cost_detail_tab_.COUNT = 0) THEN
            local_cost_detail_tab_(1).accounting_year := '*';
            local_cost_detail_tab_(1).contract        := contract_;
            local_cost_detail_tab_(1).cost_bucket_id  := '*';
            local_cost_detail_tab_(1).company         := company_;
            local_cost_detail_tab_(1).cost_source_id  := '*';
            local_cost_detail_tab_(1).unit_cost       := unit_cost_;
         END IF;
      END IF;
   END IF;

   IF NOT(transaction_required_) THEN
      RAISE exit_procedure;
   END IF;

   SELECT mpc_transaction_id.nextval,
          mpc_accounting_id.nextval,
          mpc_pre_accounting_id.nextval
   INTO   transaction_id_,
          accounting_id_,
          pre_accounting_id_
   FROM dual;

   loc_group_to_save_ := location_group_;

   IF (location_no_ IS NOT NULL) THEN
      Warehouse_Bay_Bin_API.Get_Location_Strings(warehouse_id_, bay_id_, tier_id_, row_id_, bin_id_, contract_, location_no_);

      IF (loc_group_to_save_ IS NULL) THEN
         loc_group_to_save_ := Warehouse_Bay_Bin_API.Get_Location_Group(contract_, warehouse_id_, bay_id_, tier_id_, row_id_, bin_id_);
      END IF;
   END IF;
   
   -- Transactions that needs to be included for IntraCompany cross border tax reporting will be initally marked as
   -- part_move_tax_id := 0. After running the tax reporting process, it will be modified to a number other than 0. 
   IF (trancode_rec_.part_move_tax_direction IS NOT NULL) THEN
      newrec_.part_move_tax_id := 0;                                              
   END IF;                                              

   newrec_.location_group                 := loc_group_to_save_;
   newrec_.transit_location_group         := transit_location_group_;
   newrec_.transaction_id                 := transaction_id_;
   newrec_.accounting_id                  := accounting_id_;
   newrec_.pre_accounting_id              := pre_accounting_id_;
   newrec_.part_no                        := part_no_;
   newrec_.configuration_id               := configuration_id_;
   newrec_.contract                       := contract_;
   newrec_.location_no                    := location_no_;
   newrec_.lot_batch_no                   := lot_batch_no_;
   newrec_.serial_no                      := serial_no_;
   newrec_.waiv_dev_rej_no                := waiv_dev_rej_no_;
   newrec_.eng_chg_level                  := eng_chg_level_;
   newrec_.reject_code                    := reject_code_;
   newrec_.transaction_code               := transaction_code_;
   newrec_.date_time_created              := current_time_today_;
   newrec_.direction                      := trancode_rec_.direction;
   newrec_.source_ref_type                := order_type_to_use_db_;
   newrec_.partstat_flag                  := 'N';
   newrec_.qty_reversed                   := qty_reversed_;
   newrec_.quantity                       := quantity_;
   newrec_.source                         := source_;
   newrec_.userid                         := Fnd_Session_API.Get_Fnd_User;
   newrec_.valuestat_flag                 := 'N';
   newrec_.catch_quantity                 := catch_quantity_;
   newrec_.source_ref1                    := source_ref1_;
   newrec_.source_ref2                    := source_ref2_;
   newrec_.source_ref3                    := source_ref3_;
   newrec_.source_ref4                    := source_ref4_;
   newrec_.source_ref5                    := source_ref5_;
   newrec_.activity_seq                   := activity_seq_;
   newrec_.handling_unit_id               := handling_unit_id_;
   newrec_.project_id                     := project_id_;
   newrec_.expiration_date                := expiration_date_;
   newrec_.owning_vendor_no               := owning_vendor_no_;
   newrec_.owning_customer_no             := owning_customer_no_;
   newrec_.part_ownership                 := part_ownership_db_;
   newrec_.condition_code                 := condition_code_to_use_;
   newrec_.pre_trans_level_qty_in_stock   := pre_trans_level_qty_in_stock_;
   newrec_.pre_trans_level_qty_in_transit := pre_trans_level_qty_in_transi_;
   newrec_.receipt_date                   := receipt_date_;
   newrec_.alt_source_ref1                := alt_source_ref1_;
   newrec_.alt_source_ref2                := alt_source_ref2_;
   newrec_.alt_source_ref3                := alt_source_ref3_;
   newrec_.alt_source_ref4                := alt_source_ref4_;
   newrec_.alt_source_ref5                := alt_source_ref5_;
   newrec_.alt_source_ref_type            := alt_source_ref_type_db_;
   newrec_.report_earned_value            := report_earned_value_db_;
   newrec_.original_transaction_id        := original_transaction_id_;
   newrec_.availability_control_id        := availability_control_id_;
   newrec_.ownership_transfer_reason_id   := ownership_transfer_reason_id_;
   -- gelr:warehouse_journal, begin
   newrec_.delivery_reason_id             := delivery_reason_id_;
   newrec_.alt_del_note_no                := del_note_no_;
   newrec_.del_note_date                  := del_note_date_;   
   -- gelr:warehouse_journal, end
   newrec_.move_dest_contract             := move_dest_contract_;
   newrec_.move_dest_location_no          := move_dest_location_no_;

   IF inventory_part_ THEN
      newrec_.inventory_part_cost_level  := part_rec_.inventory_part_cost_level;
      newrec_.inventory_valuation_method := part_rec_.inventory_valuation_method;
   END IF;

   newrec_.abnormal_demand := Get_Source_Abnormal_Demand___(source_ref1_,
                                                            source_ref2_, 
                                                            source_ref3_, 
                                                            source_ref4_,
                                                            order_type_to_use_db_,
                                                            trancode_rec_.inventory_stat_direction);
   indrec_ := Get_Indicator_Rec___(newrec_);
   Check_Insert___(newrec_, indrec_, attr_, trancode_rec_, part_catalog_rec_, warehouse_id_);
   Insert___(objid_, objversion_, newrec_, attr_, part_catalog_rec_);

   IF (fifo_action_ = 'INSERT') THEN
      -- Checks whether there is enough qty on the FIFO issue records that are still not unissued, to unissue using the existing FIFO issue records.  
      IF ((issue_transaction_id_ IS NULL) OR (Inventory_Part_Fifo_Issue_API.Get_Total_Issued_Quantity(issue_transaction_id_) < quantity_)) THEN
         Inventory_Part_Cost_Fifo_API.Receive_Cost(pre_trans_level_qty_in_stock_,
                                                   pre_trans_level_qty_in_transi_,
                                                   pre_trans_avg_cost_detail_tab_,
                                                   contract_,
                                                   part_no_,
                                                   quantity_,
                                                   local_cost_detail_tab_,
                                                   transaction_id_);
      ELSE
         Inventory_Part_Cost_Fifo_API.Unissue_Cost(pre_trans_level_qty_in_stock_,
                                                   pre_trans_level_qty_in_transi_,
                                                   pre_trans_avg_cost_detail_tab_,
                                                   local_cost_detail_tab_,
                                                   contract_,
                                                   part_no_,
                                                   quantity_,
                                                   issue_transaction_id_,
                                                   transaction_id_);
      END IF;
      Set_Pre_Trans_Level_Qty___(transaction_id_,
                                 pre_trans_level_qty_in_stock_,
                                 pre_trans_level_qty_in_transi_);
   ELSIF (fifo_action_ = 'ISSUE') THEN   
      Inventory_Part_Cost_Fifo_API.Issue_Cost(pre_trans_level_qty_in_stock_,
                                              pre_trans_level_qty_in_transi_,
                                              pre_trans_avg_cost_detail_tab_,
                                              local_cost_detail_tab_,
                                              contract_,
                                              part_no_,
                                              quantity_,
                                              transaction_id_);

      Set_Pre_Trans_Level_Qty___(transaction_id_,
                                 pre_trans_level_qty_in_stock_,
                                 pre_trans_level_qty_in_transi_);

   ELSIF (fifo_action_ = 'REMOVE') THEN
      Remove_Fifo_Lifo_Cost(cost_successfully_removed_ => cost_successfully_removed_,
                            original_transaction_id_   => NVL(conn_transaction_id_, original_transaction_id_),
                            qty_reversed_              => quantity_,
                            reverse_transaction_id_    => transaction_id_,
                            error_when_not_successful_ => FALSE);

      IF NOT (cost_successfully_removed_) THEN
         Inventory_Part_Cost_Fifo_API.Issue_Cost(pre_trans_level_qty_in_stock_,
                                                 pre_trans_level_qty_in_transi_,
                                                 pre_trans_avg_cost_detail_tab_,
                                                 local_cost_detail_tab_,
                                                 contract_,
                                                 part_no_,
                                                 quantity_,
                                                 transaction_id_);
         Set_Pre_Trans_Level_Qty___(transaction_id_,
                                    pre_trans_level_qty_in_stock_,
                                    pre_trans_level_qty_in_transi_);
      END IF;
   END IF;
   
   local_unit_cost_ := Inventory_Part_Unit_Cost_API.Get_Total_Unit_Cost(local_cost_detail_tab_);

   IF (local_unit_cost_ < 0) THEN
      IF ((NOT Reversing_Issue_Transaction___(transaction_code_)) AND
          (trancode_rec_.source_application != 'POSTCOSTGROUPCHANGE')) THEN
         Error_SYS.Record_General('InventoryTransactionHist', '1230: The inventory transaction value :P1 for the part no :P2 must be greater than 0.', local_unit_cost_, part_no_);
      END IF;
   END IF;
   
   IF ((inventory_part_) AND (part_ownership_db_ IN (db_company_owned_,db_consignment_))) THEN
      IF NOT ((trancode_rec_.direction = '+') AND (qty_reversed_ > 0)) THEN
         IF (must_follow_zero_cost_flag_) THEN
            Check_Zero_Cost_Flag___(local_unit_cost_,
                                    part_rec_,
                                    part_no_,
                                    contract_,
                                    lot_batch_no_,
                                    serial_no_,
                                    part_catalog_rec_);
         END IF;
      END IF;
   END IF;

   -- Create record(s) for cost details
   Pre_Invent_Trans_Avg_Cost_API.Add_Cost_Details(transaction_id_, pre_trans_avg_cost_detail_tab_);

   Create_Trans_Cost_Details___(transaction_id_,
                                local_cost_detail_tab_,
                                false_,
                                newrec_);

   IF (inventory_part_) THEN
      IF (qty_reversed_ = 0) THEN
         mtrl_overhead_cost_detail_tab_ := Get_Mtrl_Overhead_Details___(newrec_,
                                                                        part_rec_,
                                                                        company_,
                                                                        local_unit_cost_);
      
         Create_Trans_Cost_Details___(transaction_id_,
                                      mtrl_overhead_cost_detail_tab_,
                                      true_,
                                      newrec_);
      END IF;

      IF part_ownership_db_ IN (db_company_owned_,db_consignment_) THEN
         sales_oh_cost_detail_tab_ := Get_Sales_Overhead_Details___(newrec_,
                                                                    part_rec_,
                                                                    company_,
                                                                    local_unit_cost_);

         Create_Trans_Cost_Details___(transaction_id_,
                                      sales_oh_cost_detail_tab_,
                                      true_,
                                      newrec_);
      END IF;
   END IF;

   currency_code_ := Company_Finance_API.Get_Currency_Code(company_);
   value_         := local_unit_cost_* quantity_;
   value_         := round(value_, Currency_Code_API.Get_Currency_Rounding(company_,
                                                                           currency_code_));
   -- Make call to PartSerialCatalog LU
   IF (serial_no_ != '*') THEN
      IF (quantity_ != 1) THEN
         IF (trancode_rec_.cost_source != 'ROUNDING DIFFERENCE') THEN
            Error_SYS.Record_General('InventoryTransactionHist', 'INDJUSTONE: The quantity may only be one when working with serials.');
         END IF;
      END IF;
      -- Bud 88868, Passed alt_source_ref1_ parameter value
      Call_Part_Serial_Catalog___ (transaction_code_,
                                   contract_,
                                   part_no_,
                                   location_no_,
                                   serial_no_,
                                   source_ref1_,
                                   source_ref2_,
                                   source_ref3_,
                                   source_ref4_,
                                   reject_code_,
                                   order_type_to_use_,
                                   transaction_id_,
                                   nvl(lot_batch_no_,'*'),
                                   condition_code_to_use_,
                                   part_ownership_db_,
                                   newrec_.owning_vendor_no,
                                   newrec_.owning_customer_no,
                                   unit_cost_,
                                   current_time_today_,
                                   configuration_id_,
                                   eng_chg_level_,
                                   alt_source_ref1_,
                                   operational_condition_db_,
                                   handling_unit_id_,
                                   old_transaction_id_,
                                   NVL(original_transaction_id_, issue_transaction_id_));
   END IF;

   -- Register transaction to Lot Batch Master
   IF (lot_batch_no_ != '*') THEN
      Call_Lot_Batch_Master__(transaction_code_,
                              contract_,
                              part_no_,
                              location_no_,
                              lot_batch_no_,
                              source_ref1_,
                              source_ref2_,
                              source_ref3_,
                              source_ref4_,
                              source_ref5_,
                              reject_code_,
                              order_type_to_use_,
                              current_time_today_,
                              quantity_,
                              condition_code_to_lot_,
                              expiration_date_,
                              handling_unit_id_,
                              NVL(original_transaction_id_, issue_transaction_id_));
   END IF;

   -- Call to Event Server. Note: This is a generic call. The actual logic is implemented in the
   -- utility InventEventCreation LU. Adding new events should be done in the utility LU and not here.
   Invent_Event_Creation_API.Invtran_Hist_Events(transaction_id_, transaction_code_);
EXCEPTION
   WHEN exit_procedure THEN
      transaction_id_ := NULL;
END New;


-- Get_Last_Non_Updatable_Day
--   This method will return the highest date_applied that has been
--   calculated in the part statistics or been transferred to financials.
@UncheckedAccess
FUNCTION Get_Last_Non_Updatable_Day (
   contract_ IN VARCHAR2 ) RETURN DATE
IS
   max_date_accumulated_ DATE;
   max_date_transferred_ DATE;

   CURSOR get_max_date_accumulated IS
      SELECT MAX(date_applied)
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE (partstat_flag = 'Y' OR valuestat_flag = 'Y')
         AND contract = contract_;
BEGIN
   OPEN get_max_date_accumulated;
   FETCH get_max_date_accumulated INTO max_date_accumulated_;
   CLOSE get_max_date_accumulated;

   max_date_accumulated_ := NVL(max_date_accumulated_, Database_Sys.first_calendar_date_);
   max_date_transferred_ := Mpccom_Accounting_API.Get_Max_Date_Transferred(contract_);

   RETURN greatest(max_date_accumulated_, max_date_transferred_);
END Get_Last_Non_Updatable_Day;


-- Get_Actual_Cost_Receipts
--   This method returns the total received quantity for this actual cost period.
@UncheckedAccess
FUNCTION Get_Actual_Cost_Receipts (
   contract_          IN VARCHAR2,
   part_no_           IN VARCHAR2,
   configuration_id_  IN VARCHAR2,
   to_transaction_id_ IN NUMBER,
   source_ref_type_   IN VARCHAR2 ) RETURN NUMBER
IS
   total_received_qty_  NUMBER;
   actual_cost_receipt_ VARCHAR2(50);

   CURSOR get_actual_cost_receipts IS
      SELECT transaction_code, quantity, accounting_id,
             source_ref_type, source_ref1, source_ref2, source_ref3
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE contract         = contract_
         AND part_no          = part_no_
         AND configuration_id = configuration_id_
         AND valuestat_flag   = 'N'
         AND partstat_flag    = 'N'
         AND transaction_id  <= to_transaction_id_
         AND part_ownership IN ('COMPANY OWNED','CONSIGNMENT');
BEGIN
   -- Make sure to always return a number.
   total_received_qty_ := 0;

   -- Loop through transactions that are updatable and
   -- occured before (or on) to_transaction_id_.
   FOR trans_ IN get_actual_cost_receipts LOOP
      IF NOT (Mpccom_Accounting_API.Transferred_Posting_Exists(trans_.accounting_id)) THEN
         -- Verify if this transactions is a "real" receipt that should be used in the standard cost calculation.
         actual_cost_receipt_ := Mpccom_Transaction_Code_API.Get_Actual_Cost_Receipt_DB(trans_.transaction_code);
         IF (source_ref_type_ = 'PURCH') THEN
            IF (actual_cost_receipt_ = 'INCREASE PURCHASED QTY ARRIVED') THEN
               total_received_qty_ := total_received_qty_ + trans_.quantity;
            ELSIF (actual_cost_receipt_ = 'DECREASE PURCHASED QTY ARRIVED') THEN
               total_received_qty_ := total_received_qty_ - trans_.quantity;
            END IF;
         ELSIF (source_ref_type_ = 'MANUF') THEN
            IF (actual_cost_receipt_ = 'INCREASE RECEIVED MANUFACTURED QTY') THEN
               IF trans_.source_ref_type = 'SHOP ORDER' THEN
                  $IF Component_Shpord_SYS.INSTALLED $THEN
                     -- MONO404-Repair shop orders contributes with cost in PWA, but the receipt qty is just a circulation of material.
                     -- It is not a true receipt in this context.
                     IF (Shop_Ord_API.Get_Order_Code_Db(trans_.source_ref1, trans_.source_ref2, trans_.source_ref3) != Shop_Ord_Code_API.DB_REPAIR) AND
                        (Shop_Ord_API.Is_Closed(trans_.source_ref1, trans_.source_ref2, trans_.source_ref3) = Fnd_Boolean_API.DB_TRUE) THEN
                        total_received_qty_ := total_received_qty_ + trans_.quantity;
                     END IF;
                  $ELSE
                     NULL;
                  $END
               ELSE
                  total_received_qty_ := total_received_qty_ + trans_.quantity;              
               END IF;
            ELSIF (actual_cost_receipt_ = 'DECREASE RECEIVED MANUFACTURED QTY') THEN
               IF trans_.source_ref_type = 'SHOP ORDER' THEN
                  $IF Component_Shpord_SYS.INSTALLED $THEN
                     IF (Shop_Ord_API.Get_Order_Code_Db(trans_.source_ref1, trans_.source_ref2, trans_.source_ref3) != Shop_Ord_Code_API.DB_REPAIR) AND
                        (Shop_Ord_API.Is_Closed(trans_.source_ref1, trans_.source_ref2, trans_.source_ref3) = Fnd_Boolean_API.DB_TRUE) THEN
                        total_received_qty_ := total_received_qty_ - trans_.quantity;
                     END IF;
                  $ELSE
                     NULL;
                  $END
               ELSE
                  total_received_qty_ := total_received_qty_ - trans_.quantity;              
               END IF;
            ELSIF (actual_cost_receipt_ = 'INCREASE PURCHASED QTY ARRIVED') THEN
               total_received_qty_ := total_received_qty_ + trans_.quantity;
            ELSIF (actual_cost_receipt_ = 'DECREASE PURCHASED QTY ARRIVED') THEN
               total_received_qty_ := total_received_qty_ - trans_.quantity;
            END IF;
         END IF;
      END IF;
   END LOOP;

   RETURN total_received_qty_;
END Get_Actual_Cost_Receipts;


@UncheckedAccess
FUNCTION Get_Current_Transaction_Id RETURN NUMBER
IS
   CURSOR get_max_trans_id IS
      SELECT max(transaction_id)
        FROM INVENTORY_TRANSACTION_HIST_TAB;
   max_transaction_id_    NUMBER;
BEGIN
   OPEN get_max_trans_id;
   FETCH get_max_trans_id INTO max_transaction_id_;
   CLOSE get_max_trans_id;
   RETURN max_transaction_id_;
END Get_Current_Transaction_Id;


-- Update_Cost_For_Part
--   This method updates the cost and the postings for all the transactions
--   within the period from_date..to_transaction_id.
PROCEDURE Update_Cost_For_Part (
   contract_            IN VARCHAR2,
   part_no_             IN VARCHAR2,
   configuration_id_    IN VARCHAR2,
   from_date_           IN DATE,
   to_transaction_id_   IN NUMBER,
   new_cost_detail_tab_ IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab )
IS
   company_                    VARCHAR2(20);
   consignment_stock_          VARCHAR2(20);
   mpccom_trans_code_rec_      Mpccom_Transaction_Code_API.Public_Rec;
   pos_diff_transaction_       INVENTORY_TRANSACTION_HIST_TAB.transaction_code%TYPE;
   neg_diff_transaction_       INVENTORY_TRANSACTION_HIST_TAB.transaction_code%TYPE;
   new_value_detail_tab_       Mpccom_Accounting_API.Value_Detail_Tab;
   old_trans_value_detail_tab_ Mpccom_Accounting_API.Value_Detail_Tab;
   positive_value_diff_tab_    Mpccom_Accounting_API.Value_Detail_Tab;
   negative_value_diff_tab_    Mpccom_Accounting_API.Value_Detail_Tab;
   local_new_cost_detail_tab_  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   empty_value_detail_tab_     Mpccom_Accounting_API.Value_Detail_Tab;
   pwa_curr_amount_posting_tab_ Mpccom_Accounting_API.Curr_Amount_Posting_Tab;
   cost_group_changed_          BOOLEAN;
   base_curr_code_              VARCHAR2(3);
   
   CURSOR get_period_part_trans IS
      SELECT *
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE contract = contract_
         AND part_no  = part_no_
         AND configuration_id = configuration_id_
         AND date_applied > from_date_
         AND transaction_id <= to_transaction_id_
         AND part_ownership IN ('COMPANY OWNED','CONSIGNMENT')
      ORDER BY date_applied, transaction_id;

   CURSOR get_original_trans ( original_transaction_id_   NUMBER) IS
      SELECT transaction_code,
             accounting_id,
             quantity,
             direction
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE transaction_id = original_transaction_id_;

   old_trans_    get_original_trans%ROWTYPE;
BEGIN

   company_ := Site_API.Get_Company(contract_);
   base_curr_code_ := Company_Finance_API.Get_Currency_Code(company_);
   
   FOR trans_ IN get_period_part_trans LOOP
      mpccom_trans_code_rec_ := Mpccom_Transaction_Code_API.Get(trans_.transaction_code);
      -- Don't update actual cost revalue transactions.
      IF (mpccom_trans_code_rec_.cost_source NOT IN ('STOCK REVALUATION','PRICE DIFFERENCE',
                               'COST VARIANCE','SCRAP VARIANCE', 'ROUNDING DIFFERENCE', 'OVERHEAD',
                               'SUM OF COMPONENTS','COST OF SERVICE','INTERNAL SALES PRICE', 'STAGE PAYMENT', 'INVOICE IMBALANCE')) THEN         
         Set_Original_Amount___(trans_);
         IF (mpccom_trans_code_rec_.cost_source = 'POST COST GROUP CHG') THEN
            local_new_cost_detail_tab_ := Get_Cost_Group_Chg_Cleaned___(trans_.transaction_id,
                                                                        new_cost_detail_tab_);
         ELSE
            local_new_cost_detail_tab_ := new_cost_detail_tab_;
         END IF;

         -- Update cost on the transaction.
         Set_Cost(trans_.transaction_id, local_new_cost_detail_tab_);

         -- remove old bookings on certain types of bookings
         Mpccom_Accounting_API.Remove_Accounting(pwa_curr_amount_posting_tab_, trans_.accounting_id, base_curr_code_);

         -- Redo bookings according to new price.
         IF (trans_.original_transaction_id IS NULL) THEN
            cost_group_changed_ := Cost_Group_Changes_Exists___(contract_, part_no_, pwa_curr_amount_posting_tab_, local_new_cost_detail_tab_); 
            -- This is a standard transaction.
            Do_Booking___(transaction_id_              => trans_.transaction_id,
                          company_                     => company_,
                          event_code_                  => NULL,
                          complete_flag_               => 'N',
                          external_value_tab_          => empty_value_detail_tab_,
                          value_adjustment_            => FALSE,
                          adjustment_date_             => NULL,
                          per_oh_adjustment_id_        => NULL,
                          do_post_booking_actions_     => FALSE,
                          periodic_weighted_avg_calc_  => TRUE,
                          trans_reval_event_id_        => NULL,
                          pwa_curr_amount_posting_tab_ => pwa_curr_amount_posting_tab_, 
                          post_accum_curr_amt_for_pwa_ => cost_group_changed_);

         ELSE
            -- This is a reversing transaction. The original_transaction_id is pointing to the
            -- transaction that this transaction is reversing.
            old_trans_value_detail_tab_ :=
                                      Inventory_Transaction_Cost_API.Get_Transaction_Value_Details(
                                                                    trans_.original_transaction_id,
                                                                    trans_.quantity);

            OPEN get_original_trans(trans_.original_transaction_id);
            FETCH get_original_trans INTO old_trans_;
            CLOSE get_original_trans;


            -- Reverse the old accounting.
            Reverse_Accounting( reverse_transaction_id_  => trans_.transaction_id, 
                                original_transaction_id_ => trans_.original_transaction_id,
                                value_adjustment_        => FALSE,
                                per_oh_adjustment_id_    => NULL,
                                trans_reval_event_id_    => NULL,
                                date_applied_            => trans_.date_applied);

            new_value_detail_tab_ := Create_Value_Detail_Tab(local_new_cost_detail_tab_,
                                                              trans_.quantity,
                                                              part_no_);

            Mpccom_Accounting_API.Create_Value_Diff_Tables(positive_value_diff_tab_,
                                                           negative_value_diff_tab_,
                                                           old_trans_value_detail_tab_,
                                                           new_value_detail_tab_);

            -- IF actual cost was unable to update the cost of the original transaction then create a
            -- revalue transaction.
            IF (old_trans_.direction = '+') THEN
               pos_diff_transaction_ := 'RINVREVAL+';
               neg_diff_transaction_ := 'RINVREVAL-';
            ELSE
               pos_diff_transaction_ := 'RINVREVAL-';
               neg_diff_transaction_ := 'RINVREVAL+';
            END IF;

            consignment_stock_ := Mpccom_Transaction_code_API.Get_Consignment_Stock_Db(
                                                              old_trans_.transaction_code);

            IF (consignment_stock_ = 'VENDOR CONSIGNMENT') THEN
               IF (pos_diff_transaction_ = 'RINVREVAL-') THEN
                  pos_diff_transaction_ := 'CO-INVREV+';
               ELSE
                  pos_diff_transaction_ := 'CO-INVREV-';
               END IF;
               IF (neg_diff_transaction_ = 'RINVREVAL-') THEN
                  neg_diff_transaction_ := 'CO-INVREV+';
               ELSE
                  neg_diff_transaction_ := 'CO-INVREV-';
               END IF;
            ELSE
               IF (mpccom_trans_code_rec_.actual_cost_receipt != 'NOT AFFECTED') THEN
                  IF (pos_diff_transaction_ = 'RINVREVAL+') THEN
                     pos_diff_transaction_ := 'AC-INVREV-';
                  ELSE
                     pos_diff_transaction_ := 'AC-INVREV+';
                  END IF;
                  IF (neg_diff_transaction_ = 'RINVREVAL+') THEN
                     neg_diff_transaction_ := 'AC-INVREV-';
                  ELSE
                     neg_diff_transaction_ := 'AC-INVREV+';
                  END IF;
               END IF;
            END IF;

            IF (positive_value_diff_tab_.COUNT > 0) THEN
               Do_Booking(trans_.transaction_id,
                          company_,
                          pos_diff_transaction_,
                          'N',
                          positive_value_diff_tab_);
            END IF;

            IF (negative_value_diff_tab_.COUNT > 0) THEN
               Do_Booking(trans_.transaction_id,
                          company_,
                          neg_diff_transaction_,
                          'N',
                          negative_value_diff_tab_);
            END IF;
         END IF;
      END IF;
      IF (NVL(trans_.activity_seq,0) > 0) THEN
         Project_Refresh_Accounting_API.New(trans_.accounting_id, contract_, 'INVENTORY');
      END IF;
   END LOOP;
END Update_Cost_For_Part;


-- Check_Unissue_Allowed
--   This procedure will check that the issued serial no/lot batch no is the
--   one unreserved from Project/Procurement/Miscellaneous Tab. Used in Project
--   to check if it is allowed to do return parts for issued for a specific activity
@UncheckedAccess
FUNCTION Check_Unissue_Allowed (
   part_no_          IN VARCHAR2,
   contract_         IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   source_ref1_      IN VARCHAR2,
   source_ref3_      IN VARCHAR2,
   source_ref4_      IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   source_ref_type_   IN VARCHAR2) RETURN VARCHAR2
IS
   sum_moves_ NUMBER;

   CURSOR check_unissue IS
      SELECT (NVL(SUM(DECODE(direction,'+',quantity,'-',-quantity)),0)) FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE source_ref1 = source_ref1_
      AND source_ref3 = source_ref3_
      AND source_ref4 = source_ref4_
      AND serial_no = serial_no_
      AND lot_batch_no = lot_batch_no_
      AND source_ref_type = source_ref_type_
      AND configuration_id = configuration_id_
      AND part_no = part_no_
      AND contract = contract_
      AND direction != '0';
BEGIN
   OPEN check_unissue;
   FETCH check_unissue INTO sum_moves_;
   IF sum_moves_ = 0 THEN
      CLOSE check_unissue;
      RETURN false_;
   END IF;
   CLOSE check_unissue;
   RETURN true_;
END Check_Unissue_Allowed;


-- Set_Cost
--   This method changes the cost of the transaction.
PROCEDURE Set_Cost (
   transaction_id_  IN NUMBER,
   cost_detail_tab_ IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab )
IS
   inve_part_rec_                 Inventory_Part_API.Public_Rec;
   company_                       VARCHAR2(20);
   mtrl_overhead_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   sales_oh_cost_detail_tab_      Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   sales_oh_and_mtrl_oh_details_  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   trans_rec_                     INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   unit_cost_                     NUMBER;
   purch_order_ref1_              INVENTORY_TRANSACTION_HIST_TAB.source_ref1%TYPE;
   purch_order_ref2_              INVENTORY_TRANSACTION_HIST_TAB.source_ref2%TYPE;
   purch_order_ref3_              INVENTORY_TRANSACTION_HIST_TAB.source_ref3%TYPE;
   purch_order_ref4_              INVENTORY_TRANSACTION_HIST_TAB.source_ref4%TYPE;
BEGIN

   trans_rec_     := Get_Object_By_Keys___(transaction_id_);
   inve_part_rec_ := Inventory_Part_API.Get(trans_rec_.contract, trans_rec_.part_no);
   company_       := Site_API.Get_Company(trans_rec_.contract);

   Get_Purch_Order_Ref___(purch_order_ref1_,
                          purch_order_ref2_,
                          purch_order_ref3_,
                          purch_order_ref4_,
                          trans_rec_);
   
   Inventory_Transaction_Cost_API.Create_Or_Modify_Details(transaction_id_,
                                                           cost_detail_tab_,
                                                           false_,
                                                           FALSE,
                                                           trans_rec_.transaction_code,
                                                           trans_rec_.part_no,
                                                           trans_rec_.configuration_id,
                                                           trans_rec_.quantity,
                                                           trans_rec_.inventory_valuation_method,
                                                           trans_rec_.inventory_part_cost_level,
                                                           purch_order_ref1_,
                                                           purch_order_ref2_,
                                                           purch_order_ref3_,
                                                           purch_order_ref4_);
   
   IF (trans_rec_.original_transaction_id IS NULL) THEN
      unit_cost_ := Inventory_Part_Unit_Cost_API.Get_Total_Unit_Cost(cost_detail_tab_);

      mtrl_overhead_cost_detail_tab_ := Get_Mtrl_Overhead_Details___(trans_rec_,
                                                                  inve_part_rec_,
                                                                  company_,
                                                                  unit_cost_);

      Inventory_Transaction_Cost_API.Create_Or_Modify_Details(transaction_id_,
                                                           mtrl_overhead_cost_detail_tab_,
                                                           true_,
                                                           FALSE,
                                                           trans_rec_.transaction_code,
                                                           trans_rec_.part_no,
                                                           trans_rec_.configuration_id,
                                                           trans_rec_.quantity,
                                                           trans_rec_.inventory_valuation_method,
                                                           trans_rec_.inventory_part_cost_level,
                                                           purch_order_ref1_,
                                                           purch_order_ref2_,
                                                           purch_order_ref3_,
                                                           purch_order_ref4_);

      sales_oh_cost_detail_tab_ := Get_Sales_Overhead_Details___(trans_rec_,
                                                              inve_part_rec_,
                                                              company_,
                                                              unit_cost_);

      sales_oh_and_mtrl_oh_details_ := Inventory_Part_Unit_Cost_API.Add_To_Value_Detail_Tab(
                                                                    mtrl_overhead_cost_detail_tab_,
                                                                    sales_oh_cost_detail_tab_,
                                                                    1);
   ELSE
      sales_oh_and_mtrl_oh_details_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(
                                                         transaction_id_            => trans_rec_.original_transaction_id,
                                                         include_added_details_     => TRUE,
                                                         include_normal_details_    => FALSE,
                                                         replace_star_cost_Bucket_  => TRUE);
   END IF;

   Inventory_Transaction_Cost_API.Create_Or_Modify_Details(transaction_id_,
                                                           sales_oh_and_mtrl_oh_details_,
                                                           true_,
                                                           FALSE,
                                                           trans_rec_.transaction_code,
                                                           trans_rec_.part_no,
                                                           trans_rec_.configuration_id,
                                                           trans_rec_.quantity,
                                                           trans_rec_.inventory_valuation_method,
                                                           trans_rec_.inventory_part_cost_level,
                                                           purch_order_ref1_,
                                                           purch_order_ref2_,
                                                           purch_order_ref3_,
                                                           purch_order_ref4_);
END Set_Cost;


-- Set_Original_Transaction_Id
--   Set attribute Original Transaction Id to a given value.
PROCEDURE Set_Original_Transaction_Id (
   transaction_id_          IN NUMBER,
   original_transaction_id_ IN NUMBER )
IS
   record_ inventory_transaction_hist_tab%ROWTYPE;
BEGIN
   record_                         := Lock_By_Keys___(transaction_id_);
   record_.original_transaction_id := original_transaction_id_;
   Modify___(record_);
END Set_Original_Transaction_Id;


-- Get_Last_Transaction_For_Part
--   This method will return the highest date applied of the last transaction
--   for this part.
FUNCTION Get_Last_Transaction_For_Part (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN DATE
IS
   CURSOR get_last_Transaction_Day IS
      SELECT MAX(date_applied) "date_applied"
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE contract = contract_
         AND part_no  = part_no_;

   date_applied_    DATE;
BEGIN
   OPEN get_last_Transaction_Day;
   FETCH get_last_Transaction_Day INTO date_applied_;
   CLOSE get_last_Transaction_Day;

   RETURN NVL(date_applied_,Database_Sys.first_calendar_date_);
END Get_Last_Transaction_For_Part;


-- Project_Postings_Transferred
--   This method checks if all postings are transferred to finance.
FUNCTION Project_Postings_Transferred (
   contract_          IN VARCHAR2,
   project_id_        IN VARCHAR2,
   project_code_part_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   not_transferred_          BOOLEAN;
   all_postings_transferred_ VARCHAR2(5);
   company_                  VARCHAR2(20);

BEGIN

   company_         :=  Site_API.Get_Company(contract_);
   not_transferred_ := Mpccom_Accounting_API.Is_Code_Part_Value_In_Status(company_,
                                                                          project_code_part_,
                                                                          project_id_,
                                                                          'NOT TRANSFERRED');
   IF (not_transferred_) THEN
      all_postings_transferred_ := false_;
   ELSE
      all_postings_transferred_ := true_;
   END IF;

   RETURN (all_postings_transferred_);
END Project_Postings_Transferred;


-- Get_Arrival_Cost_And_Del_Oh
--   Get cost and delivery overhead per part for one order row that has
--   a transaction that is ok.
PROCEDURE Get_Arrival_Cost_And_Del_Oh (
   cost_       OUT NUMBER,
   del_oh_     OUT NUMBER,
   source_ref1_  IN VARCHAR2,
   source_ref2_  IN VARCHAR2,
   source_ref3_  IN VARCHAR2,
   source_ref4_  IN VARCHAR2 )
IS
   delivery_oh_  NUMBER;
   total_del_oh_ NUMBER  := 0;
   trans_cost_   NUMBER;
   total_cost_   NUMBER  := 0;
   total_qty_    NUMBER  := 0;
   found_        BOOLEAN := FALSE;

   CURSOR get_transaction IS
      SELECT quantity, transaction_id, accounting_id
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1  = source_ref1_
      AND    source_ref2  = source_ref2_
      AND    source_ref3  = source_ref3_
      AND    source_ref4  = source_ref4_
      AND    transaction_code IN ('ARRTRAN','ARRIVAL','CO-ARRIVAL','ARR-REPAIR')
      AND    part_ownership != 'SUPPLIER OWNED';

BEGIN

   FOR tran_rec IN get_transaction LOOP
      delivery_oh_  := abs(mpccom_accounting_api.get_sum_value(tran_rec.accounting_id,'M57'));
      total_del_oh_ := total_del_oh_ + delivery_oh_;
      trans_cost_   := Inventory_Transaction_Cost_API.Get_Sum_Unit_Cost(tran_rec.transaction_id);
      total_cost_   := total_cost_ + (trans_cost_ * tran_rec.quantity);
      total_qty_    := total_qty_ + tran_rec.quantity;
      found_        := TRUE;
   END LOOP;

   IF (found_) THEN
      cost_   := total_cost_/total_qty_;
      del_oh_ := total_del_oh_/total_qty_;
   ELSE
      cost_   := NULL;
      del_oh_ := NULL;
   END IF;

END Get_Arrival_Cost_And_Del_Oh;


-- Get_Last_Trans_Id_Ord
--   This will return the ID of the last transaction occurred to a particular
--   order no, release no and sequence no.
@UncheckedAccess
FUNCTION Get_Last_Trans_Id_Ord (
   source_ref1_  IN VARCHAR2,
   source_ref2_  IN VARCHAR2,
   source_ref3_  IN VARCHAR2,
   source_ref4_  IN VARCHAR2 DEFAULT NULL ) RETURN NUMBER
IS
   transaction_id_ INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;

   CURSOR get_info_ IS
      SELECT max(transaction_id)
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1 = source_ref1_
      AND    source_ref2 = source_ref2_
      AND    source_ref3 = source_ref3_
      AND    NVL(source_ref4, 'DUMMY') = NVL(source_ref4_, NVL(source_ref4, 'DUMMY'));
BEGIN
   OPEN get_info_;
   FETCH get_info_ INTO transaction_id_;
   CLOSE get_info_;
   RETURN transaction_id_;
END Get_Last_Trans_Id_Ord;


-- Get_Id_List_For_Order_Trans
--   Returns transaction ids for all records in the table that meets
--   the conditions sent in.
@UncheckedAccess
FUNCTION Get_Id_List_For_Order_Trans (
   source_ref_type_db_ IN VARCHAR2,
   source_ref1_      IN VARCHAR2,
   source_ref2_      IN VARCHAR2,
   source_ref3_      IN VARCHAR2,
   source_ref4_      IN VARCHAR2,
   transaction_code_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   transaction_id_list_ VARCHAR2(2000);

   CURSOR get_transaction_id_list IS
      SELECT transaction_id
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE source_ref_type          = source_ref_type_db_
      AND   source_ref1              = source_ref1_
      AND   NVL(source_ref2,'DUMMY') = NVL(source_ref2_,NVL(source_ref2,'DUMMY'))
      AND   NVL(source_ref3,'DUMMY') = NVL(source_ref3_,NVL(source_ref3,'DUMMY'))
      AND   NVL(source_ref4,'DUMMY') = NVL(source_ref4_,NVL(source_ref4,'DUMMY'))
      AND   transaction_code         = transaction_code_;
BEGIN
   FOR trans_rec_ IN  get_transaction_id_list LOOP
      transaction_id_list_ := transaction_id_list_ || trans_rec_.transaction_id || Client_SYS.Record_Separator_;
   END LOOP;
   RETURN transaction_id_list_;
END Get_Id_List_For_Order_Trans;


-- Check_Receipt_In_Place
--   Returns character string true_ if a Transfer of Ownership to Company
--   Exists for a give Purchase Order No, Line No and Release No Combination.
--   The Receipt No is set to a default value of 1 since all receipts of PO
--   Lines used for Transfer of Ownership have a default receipt no of value 1.
--   If no transfer is connected false_ is returned.
@UncheckedAccess
FUNCTION Check_Receipt_In_Place (
   source_ref1_  IN VARCHAR2,
   source_ref2_  IN VARCHAR2,
   source_ref3_  IN VARCHAR2,
   source_ref4_  IN VARCHAR2 DEFAULT NULL ) RETURN VARCHAR2
IS
   dummy_    NUMBER;
   CURSOR get_transfer_transaction IS
      SELECT 1
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE source_ref1     = source_ref1_
      AND   source_ref2   = source_ref2_
      AND   source_ref3  = source_ref3_
      AND   (source_ref4 = source_ref4_ OR source_ref4_ IS NULL)
      AND   transaction_code = 'XO-ARRIVAL'
      AND   part_ownership = 'COMPANY OWNED';

BEGIN
   OPEN  get_transfer_transaction ;
   FETCH get_transfer_transaction INTO dummy_;
   IF get_transfer_transaction%FOUND THEN
      CLOSE get_transfer_transaction;
      RETURN true_;
   END IF;
   CLOSE get_transfer_transaction;
   RETURN false_;
END Check_Receipt_In_Place;


-- Set_Previous_Ownership
--   The previous ownership details stored during a transfer of ownership.
PROCEDURE Set_Previous_Ownership (
   transaction_id_              IN NUMBER,
   previous_part_ownership_     IN VARCHAR2,
   previous_owning_customer_no_ IN VARCHAR2 DEFAULT NULL,
   previous_owning_vendor_no_   IN VARCHAR2 DEFAULT NULL )
IS
   record_ inventory_transaction_hist_tab%ROWTYPE;
BEGIN
   record_                             := Lock_By_Keys___(transaction_id_);
   record_.previous_part_ownership     := previous_part_ownership_;
   record_.previous_owning_customer_no := previous_owning_customer_no_ ;
   record_.previous_owning_vendor_no   := previous_owning_vendor_no_ ;
   Modify___(record_);
END Set_Previous_Ownership;


-- Get_Sum_Value_Imp_Fa_Object
--   Returns the accounting value for transaction for Inventory Part
--   transforming Inventory Part to Fixed Asset Object in Rotable Pool
--   with Import Allowed, matching object_id and contract on Fixed Asset Object.
--   It is never more than one transaction with transaction code IMPFAPOOL
--   per object_id and company.
@UncheckedAccess
FUNCTION Get_Sum_Value_Imp_Fa_Object (
   source_ref1_ IN VARCHAR2,
   source_ref3_ IN VARCHAR2 ) RETURN NUMBER
IS
   value_  NUMBER;
   acc_id_ NUMBER;

   CURSOR get_acc IS
      SELECT accounting_id
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  transaction_code = 'IMPFAPOOL'
      AND    source_ref1 = source_ref1_
      AND    source_ref3 = source_ref3_;
BEGIN
   -- It is never more than one transaction with transaction code IMPFAPOOL per object_id and company
   OPEN get_acc;
   FETCH get_acc INTO acc_id_;
   IF (get_acc%NOTFOUND) THEN
      value_ := NULL;
   ELSE
      value_ := Mpccom_Accounting_API.Get_Sum_Value (acc_id_, 'M141');
   END IF;
   CLOSE get_acc;
   RETURN value_;
END Get_Sum_Value_Imp_Fa_Object;


@UncheckedAccess
FUNCTION Get_Committed_And_Actual_Costs (
   source_ref1_   IN VARCHAR2,
   source_ref2_   IN VARCHAR2,
   source_ref3_   IN VARCHAR2,
   part_no_       IN VARCHAR2,
   contract_      IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2,
   cost_type_     IN VARCHAR2,
   source_ref4_   IN VARCHAR2 DEFAULT NULL ) RETURN NUMBER
IS
   total_cost_   NUMBER;
   company_      VARCHAR2(20);
   posting_type_ VARCHAR2(10);

   CURSOR get_accounting_id IS
      SELECT accounting_id
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1      = source_ref1_
      AND   (source_ref2      = source_ref2_  OR source_ref2_  IS NULL)
      AND   (source_ref4      = source_ref4_  OR source_ref4_  IS NULL)
      AND   (source_ref3      = source_ref3_  OR source_ref3_  IS NULL)
      AND    source_ref_type  = source_ref_type_db_
      AND    part_no          = part_no_
      AND    contract         = contract_
      AND    configuration_id = '*';
BEGIN
   IF (source_ref_type_db_ = 'SHOP ORDER') THEN
      posting_type_ := 'M40';
   ELSIF (source_ref_type_db_ = 'PUR ORDER') THEN
      posting_type_ := 'M1';
   ELSIF (source_ref_type_db_ = 'PROJECT') THEN
      posting_type_ := 'M62';
   END IF;

   total_cost_ := 0;
   company_    := Site_API.Get_Company(contract_);

   FOR rec_ IN get_accounting_id LOOP
      total_cost_ := total_cost_ + Mpccom_Accounting_API.Get_Committed_Or_Actual_Value(company_,
                                                                                       rec_.accounting_id,
                                                                                       posting_type_,
                                                                                       cost_type_);
   END LOOP;

   RETURN total_cost_;
END Get_Committed_And_Actual_Costs;


-- Get_Activity_Cost_By_Status
--   Returns the total cost for a given status and order type.
@UncheckedAccess
FUNCTION Get_Activity_Cost_By_Status (
   source_ref1_   IN VARCHAR2,
   source_ref2_   IN VARCHAR2,
   source_ref3_   IN VARCHAR2,
   source_ref4_   IN VARCHAR2,
   status_        IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2 ) RETURN NUMBER
IS
   CURSOR get_accounting_id IS
      SELECT accounting_id
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE source_ref1 = source_ref1_
      AND   (source_ref2 = source_ref2_ OR source_ref2_ IS NULL)
      AND   (source_ref3 = source_ref3_ OR source_ref3_ IS NULL)
      AND   (source_ref4 = source_ref4_ OR source_ref4_ IS NULL)
      AND   source_ref_type  = source_ref_type_db_ ;

   activity_cost_  NUMBER;
BEGIN
   activity_cost_ := 0;
   FOR transaction_rec IN get_accounting_id LOOP
      activity_cost_ := activity_cost_ + Mpccom_Accounting_API.Get_Activity_Cost_By_Status(transaction_rec.accounting_id, status_);
   END LOOP;
   RETURN (NVL(activity_cost_, 0)) ;
END Get_Activity_Cost_By_Status;


-- Get_Activity_Costs_By_Status
--   Returns activity costs for status.
FUNCTION Get_Activity_Costs_By_Status (
   source_ref1_   IN VARCHAR2,
   source_ref2_   IN VARCHAR2,
   source_ref3_   IN VARCHAR2,
   source_ref4_   IN VARCHAR2,
   status_        IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2,
   event_code_    IN VARCHAR2 DEFAULT NULL ) RETURN Mpccom_Accounting_API.Project_Cost_Element_Tab
IS
   CURSOR get_accounting_id_tab IS
      SELECT accounting_id
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE source_ref1 = source_ref1_
      AND   (source_ref2  = source_ref2_ OR source_ref2_ IS NULL)
      AND   (source_ref3  = source_ref3_ OR source_ref3_ IS NULL)
      AND   (source_ref4  = source_ref4_ OR source_ref4_ IS NULL)
      AND   source_ref_type = source_ref_type_db_ ;

   project_cost_element_tab_ Mpccom_Accounting_API.Project_Cost_Element_Tab;
   accounting_id_tab_        Mpccom_Accounting_API.Accounting_Id_Tab;
BEGIN

   OPEN  get_accounting_id_tab;
   FETCH get_accounting_id_tab BULK COLLECT INTO accounting_id_tab_;
   CLOSE get_accounting_id_tab;

   IF (accounting_id_tab_.COUNT > 0) THEN
      project_cost_element_tab_ := Mpccom_Accounting_API.Get_Activity_Costs_By_Status(
                                                                                accounting_id_tab_,
                                                                                status_,
                                                                                event_code_ );
   END IF;

   RETURN (project_cost_element_tab_) ;
END Get_Activity_Costs_By_Status;


-- Transaction_Has_Posting_Error
--   Checks if any transaction connected to the order reference has a posting error.
@UncheckedAccess
FUNCTION Transaction_Has_Posting_Error (
   source_ref1_           IN VARCHAR2,
   source_ref2_           IN VARCHAR2,
   source_ref3_           IN VARCHAR2,
   source_ref4_           IN VARCHAR2,
   source_ref_type_db_    IN VARCHAR2,
   check_pre_posted_only_ IN BOOLEAN DEFAULT FALSE ) RETURN BOOLEAN
IS
   posting_has_error_ BOOLEAN := FALSE;

   CURSOR get_accounting_id IS
      SELECT accounting_id
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1  = source_ref1_
      AND   (source_ref2  = source_ref2_ OR source_ref2_ IS NULL)
      AND   (source_ref3  = source_ref3_ OR source_ref3_ IS NULL)
      AND   (source_ref4  = source_ref4_ OR source_ref4_ IS NULL)
      AND    source_ref_type = source_ref_type_db_;
BEGIN
   FOR acc_id_rec_ IN get_accounting_id LOOP
      posting_has_error_ := Mpccom_Accounting_API.Accounting_Have_Errors(acc_id_rec_.accounting_id,
                                                                         check_pre_posted_only_);
      EXIT WHEN (posting_has_error_);
   END LOOP;

   RETURN (posting_has_error_);
END Transaction_Has_Posting_Error;


-- Repair_Cost_Added_On_Arrival
--   This method checks if there has been any ARR-REPAIR transaction on this receipt.
@UncheckedAccess
FUNCTION Repair_Cost_Added_On_Arrival (
   source_ref1_   IN VARCHAR2,
   source_ref2_   IN VARCHAR2,
   source_ref3_   IN VARCHAR2,
   source_ref4_   IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_             NUMBER;
   repair_cost_added_ BOOLEAN := FALSE;

   CURSOR exist_control IS
      SELECT 1
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1      = source_ref1_
      AND    source_ref2      = source_ref2_
      AND    source_ref3      = source_ref3_
      AND    source_ref4      = source_ref4_
      AND    transaction_code = 'ARR-REPAIR';
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      repair_cost_added_ := TRUE;
   END IF;
   CLOSE exist_control;

   RETURN (repair_cost_added_);
END Repair_Cost_Added_On_Arrival;


-- Recalc_Cost_On_Price_Update
--   Recalculate the cost and the delivery overhead for a transaction based
--   on a new price for a receipt transaction.
--   This method is used in the transaction based invoice revaluation process
--   when inventory valuation method is weighted average.
PROCEDURE Recalc_Cost_On_Price_Update (
   new_cost_detail_tab_ OUT Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   transaction_id_      IN  NUMBER,
   price_               IN  NUMBER )
IS
   tran_hist_rec_         INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   inve_part_rec_         Inventory_Part_API.Public_Rec;
   cost_detail_tab_       Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   company_               VARCHAR2(20);
   unit_cost_             NUMBER;
   purch_order_ref1_      INVENTORY_TRANSACTION_HIST_TAB.source_ref1%TYPE;
   purch_order_ref2_      INVENTORY_TRANSACTION_HIST_TAB.source_ref2%TYPE;
   purch_order_ref3_      INVENTORY_TRANSACTION_HIST_TAB.source_ref3%TYPE;
   purch_order_ref4_      INVENTORY_TRANSACTION_HIST_TAB.source_ref4%TYPE;
   dummy_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   local_price_           NUMBER;
BEGIN

   local_price_   := price_;
   tran_hist_rec_ := Get_Object_By_Keys___(transaction_id_);
   inve_part_rec_ := Inventory_Part_API.Get(tran_hist_rec_.contract, tran_hist_rec_.part_no);
   company_       := Site_API.Get_Company(tran_hist_rec_.contract);

   IF ((inve_part_rec_.inventory_valuation_method = 'ST') AND
       (inve_part_rec_.inventory_part_cost_level = 'COST PER SERIAL')) THEN
      -- This combination is OK
      NULL;
   ELSIF (inve_part_rec_.inventory_valuation_method = 'AV') THEN
      -- This combination is OK
      NULL;
   ELSE
      Error_SYS.Record_General('InventoryTransactionHist', 'DESINGERR: Design time error. This method may only be used when Inventory Valuation Method is Weighted Average');
   END IF;

   Get_Purch_Order_Ref___(purch_order_ref1_,
                          purch_order_ref2_,
                          purch_order_ref3_,
                          purch_order_ref4_,
                          tran_hist_rec_);

   IF (tran_hist_rec_.transaction_code IN ('ARRIVAL','PODIRSH','PODIRINTEM')) THEN
      cost_detail_tab_ := Get_Consumed_Comp_Cost_Details(purch_order_ref1_,
                                                         purch_order_ref2_,
                                                         purch_order_ref3_,
                                                         purch_order_ref4_);
   ELSIF (tran_hist_rec_.transaction_code IN ('ARR-COMP', 'SERLOTSWAP', 'PARTSWAP')) THEN
      Get_External_Service_Costs(comp_cost_detail_tab_    => cost_detail_tab_,
                                 service_cost_detail_tab_ => dummy_cost_detail_tab_,
                                 source_ref_1_            => purch_order_ref1_,
                                 source_ref_2_            => purch_order_ref2_,
                                 source_ref_3_            => purch_order_ref3_,
                                 service_cost_            => local_price_,
                                 include_service_cost_    => TRUE,
                                 contract_                => tran_hist_rec_.contract);
      local_price_ := NULL;
   END IF;
   cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Generate_Cost_Details(
                                                               cost_detail_tab_,
                                                               local_price_,
                                                               TRUE,
                                                               company_,
                                                               tran_hist_rec_.contract,
                                                               tran_hist_rec_.part_no,
                                                               tran_hist_rec_.configuration_id,
                                                               tran_hist_rec_.source_ref1,
                                                               tran_hist_rec_.source_ref2,
                                                               tran_hist_rec_.source_ref3,
                                                               tran_hist_rec_.source_ref4,
                                                               tran_hist_rec_.source_ref_type,
                                                               trunc(tran_hist_rec_.date_created));

   Inventory_Transaction_Cost_API.Create_Or_Modify_Details(transaction_id_,
                                                           cost_detail_tab_,
                                                           false_,
                                                           TRUE,
                                                           tran_hist_rec_.transaction_code,
                                                           tran_hist_rec_.part_no,
                                                           tran_hist_rec_.configuration_id,
                                                           tran_hist_rec_.quantity,
                                                           tran_hist_rec_.inventory_valuation_method,
                                                           tran_hist_rec_.inventory_part_cost_level,
                                                           purch_order_ref1_,
                                                           purch_order_ref2_,
                                                           purch_order_ref3_,
                                                           purch_order_ref4_);

   unit_cost_       := Inventory_Part_Unit_Cost_API.Get_Total_Unit_Cost(cost_detail_tab_);
   cost_detail_tab_ := Get_Mtrl_Overhead_Details___(tran_hist_rec_,
                                                    inve_part_rec_,
                                                    company_,
                                                    unit_cost_);

   Inventory_Transaction_Cost_API.Create_Or_Modify_Details(transaction_id_,
                                                           cost_detail_tab_,
                                                           true_,
                                                           TRUE,
                                                           tran_hist_rec_.transaction_code,
                                                           tran_hist_rec_.part_no,
                                                           tran_hist_rec_.configuration_id,
                                                           tran_hist_rec_.quantity,
                                                           tran_hist_rec_.inventory_valuation_method,
                                                           tran_hist_rec_.inventory_part_cost_level,
                                                           purch_order_ref1_,
                                                           purch_order_ref2_,
                                                           purch_order_ref3_,
                                                           purch_order_ref4_);

   cost_detail_tab_ := Get_Sales_Overhead_Details___(tran_hist_rec_,
                                                     inve_part_rec_,
                                                     company_,
                                                     unit_cost_);

   Inventory_Transaction_Cost_API.Create_Or_Modify_Details(transaction_id_,
                                                           cost_detail_tab_,
                                                           true_,
                                                           TRUE,
                                                           tran_hist_rec_.transaction_code,
                                                           tran_hist_rec_.part_no,
                                                           tran_hist_rec_.configuration_id,
                                                           tran_hist_rec_.quantity,
                                                           tran_hist_rec_.inventory_valuation_method,
                                                           tran_hist_rec_.inventory_part_cost_level,
                                                           purch_order_ref1_,
                                                           purch_order_ref2_,
                                                           purch_order_ref3_,
                                                           purch_order_ref4_);

   new_cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(
                                                                                  transaction_id_);
END Recalc_Cost_On_Price_Update;


@UncheckedAccess
FUNCTION Get_Average_Intersite_Cost (
   source_ref1_  IN VARCHAR2,
   source_ref2_  IN VARCHAR2,
   source_ref3_  IN VARCHAR2,
   source_ref4_  IN VARCHAR2 ) RETURN NUMBER
IS
   average_cost_   NUMBER;
   trans_value_    NUMBER;
   trans_cost_     NUMBER;
   total_value_    NUMBER  := 0;
   total_quantity_ NUMBER  := 0;
   found_          BOOLEAN := FALSE;

   CURSOR get_transaction IS
      SELECT (quantity - qty_reversed) quantity, transaction_id, transaction_code
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE source_ref1    = source_ref1_
      AND   (source_ref2   = source_ref2_ OR source_ref2_ IS NULL)
      AND   (source_ref3   = source_ref3_ OR source_ref3_ IS NULL)
      AND   (source_ref4   = source_ref4_ OR source_ref4_ IS NULL)
      AND   transaction_code IN ('INTREV','INTREV+','INTREV-');
BEGIN
   FOR trans_rec_ IN get_transaction LOOP
      trans_cost_  := Inventory_Transaction_Cost_API.Get_Sum_Unit_Cost(trans_rec_.transaction_id);
      trans_value_ := (trans_cost_ * trans_rec_.quantity);

      IF (trans_rec_.transaction_code = 'INTREV') THEN
         total_value_ := total_value_ + trans_value_;
         total_quantity_ := total_quantity_ + trans_rec_.quantity;
      ELSIF (trans_rec_.transaction_code = 'INTREV+') THEN
         total_value_ := total_value_ + trans_value_;
      ELSE
         total_value_ := total_value_ - trans_value_;
      END IF;
      found_ := TRUE;
   END LOOP;
   IF (found_) THEN
      average_cost_ := total_value_/total_quantity_;
   END IF;
   RETURN average_cost_;
END Get_Average_Intersite_Cost;


@UncheckedAccess
FUNCTION Check_Order_Transaction (
   source_ref1_      IN VARCHAR2,
   source_ref2_      IN VARCHAR2,
   source_ref3_      IN VARCHAR2,
   source_ref4_      IN VARCHAR2,
   source_ref5_      IN VARCHAR2,
   transaction_code_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   dummy_ NUMBER;
   CURSOR check_exist IS
      SELECT 1
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE source_ref1      = source_ref1_
      AND   (source_ref2     = source_ref2_  OR source_ref2_  IS NULL)
      AND   (source_ref3     = source_ref3_  OR source_ref3_  IS NULL)
      AND   (source_ref4     = source_ref4_  OR source_ref4_  IS NULL)
      AND   (source_ref5     = source_ref5_  OR source_ref5_  IS NULL)
      AND   transaction_code = transaction_code_;
BEGIN
   OPEN check_exist;
   FETCH check_exist INTO dummy_;
   IF (check_exist%FOUND) THEN
      CLOSE check_exist;
      RETURN true_;
   END IF;
   CLOSE check_exist;
   RETURN false_;
END Check_Order_Transaction;


-- Get_Sum_Qty_Received
--   Returns total received quantity per order and part
@UncheckedAccess
FUNCTION Get_Sum_Qty_Received (
   source_ref1_        IN VARCHAR2,
   source_ref2_        IN VARCHAR2,
   source_ref3_        IN VARCHAR2,
   source_ref4_        IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2,
   contract_           IN VARCHAR2,
   part_no_            IN VARCHAR2,
   configuration_id_   IN VARCHAR2 DEFAULT NULL,
   lot_batch_no_       IN VARCHAR2 DEFAULT NULL,
   serial_no_          IN VARCHAR2 DEFAULT NULL,
   waiv_dev_rej_no_    IN VARCHAR2 DEFAULT NULL,
   eng_chg_level_      IN VARCHAR2 DEFAULT NULL,
   activity_seq_       IN NUMBER   DEFAULT NULL,
   handling_unit_id_   IN NUMBER   DEFAULT NULL ) RETURN NUMBER
IS
   sum_qty_received_ NUMBER;
   CURSOR get_sum_qty_received IS
      SELECT SUM(quantity - qty_reversed)
      FROM  INVENTORY_TRANSACTION_HIST_TAB ith, mpccom_transaction_code_pub mtc
      WHERE  source_ref1               = source_ref1_
      AND  source_ref_type             = source_ref_type_db_
      AND  ith.transaction_code        = mtc.transaction_code
      AND  mtc.direction               = '+'
      AND  inventory_stat_direction_db = 'RECEIPT'
      AND (source_ref2                 = source_ref2_      OR  source_ref2_      IS NULL)
      AND (source_ref3                 = source_ref3_      OR  source_ref3_      IS NULL)
      AND (source_ref4                 = source_ref4_      OR  source_ref4_      IS NULL)
      AND (contract                    = contract_         OR  contract_         IS NULL)
      AND (part_no                     = part_no_          OR  part_no_          IS NULL)
      AND (configuration_id            = configuration_id_ OR  configuration_id_ IS NULL)
      AND (lot_batch_no                = lot_batch_no_     OR  lot_batch_no_     IS NULL)
      AND (serial_no                   = serial_no_        OR  serial_no_        IS NULL)
      AND (waiv_dev_rej_no             = waiv_dev_rej_no_  OR  waiv_dev_rej_no_  IS NULL)
      AND (eng_chg_level               = eng_chg_level_    OR  eng_chg_level_    IS NULL)
      AND (activity_seq                = activity_seq_     OR  activity_seq_     IS NULL)
      AND (handling_unit_id            = handling_unit_id_ OR  handling_unit_id_ IS NULL);
BEGIN
   OPEN   get_sum_qty_received;
   FETCH  get_sum_qty_received INTO sum_qty_received_;
   CLOSE  get_sum_qty_received;
   RETURN NVL(sum_qty_received_, 0);
END Get_Sum_Qty_Received;

-- Get_Sum_Qty_Received
--   Returns total received quantity per part, source ref type and time interval. Same logic as in aggregation of inventory statistics.
@UncheckedAccess
FUNCTION Get_Sum_Qty_Received (
   contract_           IN VARCHAR2,
   part_no_            IN VARCHAR2,
   from_applied_date_  IN DATE,
   to_applied_date_    IN DATE,
   source_ref_type_db_ IN VARCHAR2,
   configuration_id_   IN VARCHAR2 DEFAULT NULL,
   project_id_         IN VARCHAR2 DEFAULT NULL) RETURN NUMBER
IS
   sum_qty_received_ NUMBER;
   CURSOR get_sum_qty_received IS
      SELECT SUM(DECODE(mtc.inventory_stat_direction_db, 'RECEIPT', quantity, 'REVERSED RECEIPT', quantity * -1, 0))
      FROM  inventory_transaction_hist_tab ith, mpccom_transaction_code_pub mtc
      WHERE ith.transaction_code = mtc.transaction_code
      AND   contract             = contract_ 
      AND   part_no              = part_no_
      AND   source_ref_type      = source_ref_type_db_
      AND date_applied BETWEEN from_applied_date_ AND to_applied_date_ 
      AND (configuration_id           = configuration_id_ OR  configuration_id_ IS NULL)
      AND (project_id                 = project_id_       OR  project_id_       IS NULL);
BEGIN
   OPEN   get_sum_qty_received;
   FETCH  get_sum_qty_received INTO sum_qty_received_;
   CLOSE  get_sum_qty_received;
   RETURN NVL(sum_qty_received_, 0);
END Get_Sum_Qty_Received;


-- Get_Sum_Qty_Issued
--   Returns total issued quantity per part and time interval. Same logic as in aggregation of inventory statistics.
@UncheckedAccess
FUNCTION Get_Sum_Qty_Issued (
   contract_           IN VARCHAR2,
   part_no_            IN VARCHAR2,
   from_applied_date_  IN DATE,
   to_applied_date_    IN DATE,
   source_ref_type_db_ IN VARCHAR2,
   configuration_id_   IN VARCHAR2 DEFAULT NULL,
   project_id_         IN VARCHAR2 DEFAULT NULL) RETURN NUMBER
IS
   sum_qty_issued_ NUMBER;
   CURSOR get_sum_qty_issued IS
      SELECT SUM(DECODE(mtc.inventory_stat_direction_db, 'ISSUE', quantity, 'REVERSED ISSUE', quantity * -1, 0))
      FROM  inventory_transaction_hist_tab ith, mpccom_transaction_code_pub mtc
      WHERE ith.transaction_code = mtc.transaction_code
      AND   contract             = contract_ 
      AND   part_no              = part_no_
      AND   source_ref_type      = source_ref_type_db_
      AND  (configuration_id     = configuration_id_ OR  configuration_id_ IS NULL)
      AND  (project_id           = project_id_       OR  project_id_       IS NULL)
      AND   date_applied BETWEEN from_applied_date_ AND to_applied_date_;
BEGIN
   OPEN   get_sum_qty_issued;
   FETCH  get_sum_qty_issued INTO sum_qty_issued_;
   CLOSE  get_sum_qty_issued;
   RETURN NVL(sum_qty_issued_, 0);
END Get_Sum_Qty_Issued;


-- Get_Sum_Quantity
--   Returns total quantity for the parameters given.
@UncheckedAccess
FUNCTION Get_Sum_Quantity (
   source_ref1_                 IN VARCHAR2,
   source_ref2_                 IN VARCHAR2,
   source_ref3_                 IN VARCHAR2,
   source_ref4_                 IN VARCHAR2,
   source_ref_type_db_          IN VARCHAR2,
   lot_batch_no_                IN VARCHAR2,
   serial_no_                   IN VARCHAR2,
   eng_chg_level_               IN VARCHAR2,
   inventory_stat_direction_db_ IN VARCHAR2) RETURN NUMBER
IS
   sum_qty_ NUMBER := NULL;
   
   CURSOR get_sum_qty IS
      SELECT SUM(quantity - qty_reversed)
      FROM  INVENTORY_TRANSACTION_HIST_TAB ith, mpccom_transaction_code_pub mtc
      WHERE  source_ref1                   = source_ref1_ 
      AND  ith.transaction_code            = mtc.transaction_code
      AND  mtc.inventory_stat_direction_db = inventory_stat_direction_db_
      AND  source_ref_type                 = source_ref_type_db_
      AND (source_ref2                     = source_ref2_ OR source_ref2_ IS NULL)
      AND (source_ref3                     = source_ref3_ OR source_ref3_ IS NULL)
      AND (source_ref4                     = source_ref4_)
      AND (lot_batch_no                    = lot_batch_no_)
      AND  serial_no                       = serial_no_
      AND  eng_chg_level                   = eng_chg_level_;

   CURSOR get_sum_alt_ref_qty IS
      SELECT SUM(quantity - qty_reversed)
      FROM  INVENTORY_TRANSACTION_HIST_TAB ith, mpccom_transaction_code_pub mtc
      WHERE  alt_source_ref1               = source_ref1_
      AND  ith.transaction_code            = mtc.transaction_code
      AND  mtc.inventory_stat_direction_db = inventory_stat_direction_db_
      AND  alt_source_ref_type             = source_ref_type_db_
      AND (alt_source_ref2                 = source_ref2_ OR source_ref2_ IS NULL)
      AND (alt_source_ref3                 = source_ref3_ OR source_ref3_ IS NULL)
      AND (alt_source_ref4                 = source_ref4_)
      AND (lot_batch_no                    = lot_batch_no_)
      AND  serial_no                       = serial_no_
      AND  eng_chg_level                   = eng_chg_level_;

BEGIN
   OPEN  get_sum_qty;
   FETCH get_sum_qty INTO sum_qty_;
   CLOSE get_sum_qty;

   IF (sum_qty_ IS NULL) THEN
      OPEN  get_sum_alt_ref_qty;
      FETCH get_sum_alt_ref_qty INTO sum_qty_;
      CLOSE get_sum_alt_ref_qty;
   END IF;
   
   RETURN NVL(sum_qty_, 0);
END Get_Sum_Quantity;


-- Get_Sum_Quantity
--   Returns total quantity for the parameters given.
@UncheckedAccess
FUNCTION Get_Sum_Quantity (
   contract_                    IN VARCHAR2,
   source_ref1_                 IN VARCHAR2,
   source_ref2_                 IN VARCHAR2,
   source_ref3_                 IN VARCHAR2,
   source_ref4_                 IN VARCHAR2,
   source_ref5_                 IN VARCHAR2,
   source_ref_type_db_          IN VARCHAR2,
   part_no_                     IN VARCHAR2,
   configuration_id_            IN VARCHAR2,
   lot_batch_no_                IN VARCHAR2,
   serial_no_                   IN VARCHAR2,
   eng_chg_level_               IN VARCHAR2,
   waiv_dev_rej_no_             IN VARCHAR2,
   activity_seq_                IN NUMBER,
   handling_unit_id_            IN NUMBER,
   transaction_code_            IN VARCHAR2,
   expiration_date_             IN DATE DEFAULT NULL,
   ignore_expiration_date_      IN VARCHAR2 DEFAULT 'TRUE') RETURN NUMBER
IS
   sum_qty_             NUMBER := NULL;
   last_calendar_date_  DATE := Database_SYS.last_calendar_date_;
   
   CURSOR get_sum_qty IS
     SELECT  SUM(quantity)
       FROM  INVENTORY_TRANSACTION_HIST_TAB
      WHERE  contract          = contract_
        AND  part_no           = part_no_
        AND  source_ref1       = source_ref1_
        AND  source_ref2       = source_ref2_
        AND  source_ref3       = source_ref3_
        AND  source_ref4       = source_ref4_
        AND  (source_ref5      = source_ref5_ OR source_ref5_ IS NULL)
        AND  source_ref_type   = source_ref_type_db_
        AND  configuration_id  = configuration_id_
        AND  serial_no         = serial_no_
        AND  lot_batch_no      = lot_batch_no_
        AND  (handling_unit_id  = handling_unit_id_ OR handling_unit_id_ IS NULL)
        AND  waiv_dev_rej_no   = waiv_dev_rej_no_
        AND  eng_chg_level     = eng_chg_level_
        AND  activity_seq      = activity_seq_
        AND  transaction_code  = transaction_code_
        AND  (((ignore_expiration_date_ = 'FALSE') AND (NVL(expiration_date_, last_calendar_date_) = NVL(expiration_date, last_calendar_date_))) 
             OR (ignore_expiration_date_ = 'TRUE'));
BEGIN
   OPEN  get_sum_qty;
   FETCH get_sum_qty INTO sum_qty_;
   CLOSE get_sum_qty;

   RETURN NVL(sum_qty_, 0);
END Get_Sum_Quantity;

-- Get_Po_Rejected_Qty_And_Value
--   Returnes the Returned cost and Returned quantity of Copmany Owned
--   purchase order lines.
PROCEDURE Get_Po_Rejected_Qty_And_Value (
   returned_qty_   OUT NUMBER,
   returned_value_ OUT NUMBER,
   source_ref1_    IN VARCHAR2,
   source_ref2_    IN VARCHAR2,
   source_ref3_    IN VARCHAR2,
   source_ref4_    IN VARCHAR2,
   to_date_        IN  DATE )
IS
   CURSOR get_trans_info_1  IS
      SELECT (quantity - qty_reversed) returned_qty, accounting_id, transaction_code
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  (date_applied             <= to_date_ OR to_date_ IS NULL)
      AND    source_ref1                = source_ref1_
      AND    source_ref2                = source_ref2_
      AND    source_ref3                = source_ref3_
      AND    source_ref4 LIKE NVL(source_ref4_, '%')
      AND    (quantity - qty_reversed) > 0
      AND    source_ref_type            = Order_Type_API.DB_PURCHASE_ORDER
      AND    part_ownership             = Part_Ownership_API.DB_COMPANY_OWNED
      AND    transaction_code IN ('RETWORK' ,'RETCREDIT','SCPCREDIT');

   CURSOR get_trans_info_2  IS
      SELECT (quantity - qty_reversed) returned_qty, accounting_id, transaction_code
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  (date_applied             <= to_date_ OR to_date_ IS NULL)
      AND    alt_source_ref1            = source_ref1_
      AND    alt_source_ref2            = source_ref2_
      AND    alt_source_ref3            = source_ref3_
      AND    alt_source_ref4            = source_ref4_
      AND    (quantity - qty_reversed)  > 0
      AND    alt_source_ref_type        = Order_Type_API.DB_CUSTOMER_ORDER_DIRECT
      AND    part_ownership             = Part_Ownership_API.DB_COMPANY_OWNED
      AND    transaction_code           = 'RETPODIRSH';


   ret_value_    NUMBER;
   posting_type_ VARCHAR2(30);

BEGIN

   returned_qty_   := 0;
   returned_value_ := 0;
   FOR trans_rec_ IN get_trans_info_1 LOOP
      Acc_Event_Posting_Type_API.Get_Str_Code(posting_type_, trans_rec_.transaction_code, 'D');
      ret_value_      := ABS(Mpccom_Accounting_API.Get_Sum_Value(trans_rec_.accounting_id, NVL(posting_type_,'M14'), to_date_));
      returned_value_ := returned_value_ + ret_value_;
      returned_qty_   := returned_qty_ + trans_rec_.returned_qty;
   END LOOP;

   FOR trans_rec_ IN get_trans_info_2 LOOP
      Acc_Event_Posting_Type_API.Get_Str_Code(posting_type_, trans_rec_.transaction_code, 'D');
      ret_value_      := ABS(Mpccom_Accounting_API.Get_Sum_Value(trans_rec_.accounting_id, NVL(posting_type_,'M14'), to_date_));
      returned_value_ := returned_value_ + ret_value_;
      returned_qty_   := returned_qty_ + trans_rec_.returned_qty;
   END LOOP;

END Get_Po_Rejected_Qty_And_Value;


FUNCTION Get_Pre_Trans_Lvl_Qty_Stock (
   transaction_id_ IN NUMBER ) RETURN NUMBER
IS
   temp_ inventory_transaction_hist_tab.pre_trans_level_qty_in_stock%TYPE;

BEGIN
     IF (transaction_id_ IS NULL) THEN
        RETURN NULL;
     END IF;
     SELECT pre_trans_level_qty_in_stock
        INTO  temp_
        FROM  inventory_transaction_hist_tab
        WHERE transaction_id = transaction_id_;
     RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(transaction_id_, 'Get_Pre_Trans_Lvl_Qty_Stock');
END Get_Pre_Trans_Lvl_Qty_Stock;


FUNCTION Get_Pre_Trans_Lvl_Qty_Transit (
   transaction_id_ IN NUMBER ) RETURN NUMBER
IS
   temp_ inventory_transaction_hist_tab.pre_trans_level_qty_in_transit%TYPE;
BEGIN
     IF (transaction_id_ IS NULL) THEN
        RETURN NULL;
     END IF;
     SELECT pre_trans_level_qty_in_transit
        INTO  temp_
        FROM  inventory_transaction_hist_tab
        WHERE transaction_id = transaction_id_;
     RETURN temp_;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
   WHEN too_many_rows THEN
      Raise_Too_Many_Rows___(transaction_id_, 'Get_Pre_Trans_Lvl_Qty_Transit');
END Get_Pre_Trans_Lvl_Qty_Transit;


-- Get_Arrival_Value_And_Qty
--   To fetch the Value and quantity
PROCEDURE Get_Arrival_Value_And_Qty (
   curr_amount_detail_tab_    OUT Mpccom_Accounting_API.Curr_Amount_Detail_Tab,
   value_        OUT NUMBER,
   qty_          OUT NUMBER,
   price_diff_   OUT NUMBER,
   source_ref1_  IN VARCHAR2,
   source_ref2_  IN VARCHAR2,
   source_ref3_  IN VARCHAR2,
   source_ref4_  IN VARCHAR2,
   to_date_      IN  DATE )
IS
   cost_ NUMBER;      
BEGIN

   Get_Arrival_Cost_Value_Qty___ (curr_amount_detail_tab_        => curr_amount_detail_tab_,
                                  cost_                          => cost_,
                                  value_                         => value_,
                                  qty_                           => qty_,
                                  price_diff_                    => price_diff_,                                  
                                  source_ref1_                   => source_ref1_,
                                  source_ref2_                   => source_ref2_,
                                  source_ref3_                   => source_ref3_,
                                  source_ref4_                   => source_ref4_,
                                  alt_source_ref1_               => NULL,
                                  alt_source_ref2_               => NULL,
                                  alt_source_ref3_               => NULL,
                                  alt_source_ref4_               => NULL,
                                  to_date_                       => to_date_,
                                  include_reversed_transactions_ => TRUE,
                                  serial_no_                     => NULL, 
                                  use_original_amounts_for_pwa_  => TRUE,
                                  fetch_curr_amount_details_     => TRUE,
                                  use_only_m10_postings_         => FALSE);
END Get_Arrival_Value_And_Qty;


-- Get_Quantity_Not_Reversed
--   Returns the scrapped quntity of a receipet for a given part ownership type
@UncheckedAccess
FUNCTION Get_Quantity_Not_Reversed (
   source_ref1_       IN VARCHAR2,
   source_ref2_       IN VARCHAR2,
   source_ref3_       IN VARCHAR2,
   source_ref4_       IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2,
   part_ownership_db_ IN VARCHAR2,
   transaction_code_  IN VARCHAR2 ) RETURN NUMBER
IS
   quantity_not_reversed_ NUMBER;

   CURSOR get_quantity_not_reversed IS
      SELECT NVL(SUM(quantity - qty_reversed),0)
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE source_ref1   = source_ref1_
         AND source_ref2   = source_ref2_
         AND source_ref3   = source_ref3_
         AND source_ref4   = source_ref4_
         AND part_ownership = part_ownership_db_
         AND source_ref_type  = source_ref_type_db_
         AND transaction_code = transaction_code_;

BEGIN
   OPEN get_quantity_not_reversed;
   FETCH get_quantity_not_reversed INTO quantity_not_reversed_;
   CLOSE get_quantity_not_reversed;
   RETURN quantity_not_reversed_;

END Get_Quantity_Not_Reversed;


-- Check_Order_Exist
--   This function will return TRUE if a order existis for a given order_no, release_no, sequence_no,
--   line_item_no and order type.
@UncheckedAccess
FUNCTION Check_Order_Exist (
   source_ref1_       IN VARCHAR2,
   source_ref2_       IN VARCHAR2,
   source_ref3_       IN VARCHAR2,
   source_ref4_       IN VARCHAR2,
   source_ref5_       IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_ NUMBER;
   exist_ BOOLEAN := FALSE;

   CURSOR exist_control IS
      SELECT 1
      FROM  INVENTORY_TRANSACTION_HIST_TAB
      WHERE (source_ref1  = source_ref1_)
      AND   (source_ref2  = source_ref2_ OR source_ref2_ IS NULL)
      AND   (source_ref3  = source_ref3_ OR source_ref3_ IS NULL)
      AND   (source_ref4  = source_ref4_ OR source_ref4_ IS NULL)
      AND   (source_ref5  = source_ref5_ OR source_ref5_ IS NULL)
      AND   (source_ref_type = source_ref_type_db_);
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      exist_ := TRUE;
   END IF;
   CLOSE exist_control;
   RETURN exist_;
END Check_Order_Exist;


-- Set_Alt_Source_Ref
--   This method is used to store the alternative source reference values.
PROCEDURE Set_Alt_Source_Ref (
   transaction_id_         IN NUMBER,
   alt_source_ref1_        IN VARCHAR2,
   alt_source_ref2_        IN VARCHAR2,
   alt_source_ref3_        IN VARCHAR2,
   alt_source_ref4_        IN VARCHAR2,
   alt_source_ref5_        IN VARCHAR2,
   alt_source_ref_type_db_ IN VARCHAR2 )
IS
   record_ INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   exit_procedure_ EXCEPTION;
BEGIN
   IF (transaction_id_ IS NULL) THEN
      RAISE exit_procedure_;
   END IF;

   record_                     := Lock_By_Keys___(transaction_id_);
   record_.alt_source_ref1     := alt_source_ref1_;
   record_.alt_source_ref2     := alt_source_ref2_;
   record_.alt_source_ref3     := alt_source_ref3_;
   record_.alt_source_ref4     := alt_source_ref4_;
   record_.alt_source_ref5     := alt_source_ref5_;
   record_.alt_source_ref_type := alt_source_ref_type_db_;
   Modify___(record_);
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Set_Alt_Source_Ref;


-- Get_Latest_Transaction_Id
--   Returns the latest transaction id for a specific order reference.
--   A lot of other parameter values can be sent in to further specify
--   the search criteria.
--   Returns the latest transaction ID.
--   Returns greatest inventory transaction id for given InventoryPartInStock record.
@UncheckedAccess
FUNCTION Get_Latest_Transaction_Id (
   contract_                IN VARCHAR2,
   part_no_                 IN VARCHAR2,
   configuration_id_        IN VARCHAR2,
   lot_batch_no_            IN VARCHAR2,
   serial_no_               IN VARCHAR2,
   condition_code_          IN VARCHAR2,
   include_plus_direction_  IN BOOLEAN,
   include_minus_direction_ IN BOOLEAN,
   include_zero_direction_  IN BOOLEAN ) RETURN NUMBER
IS
   latest_transaction_id_ INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;
   incl_plus_dir_         VARCHAR2(5) := false_;
   incl_minus_dir_        VARCHAR2(5) := false_;
   incl_zero_dir_         VARCHAR2(5) := false_;

   CURSOR get_latest_trans_id IS
      SELECT MAX(transaction_id)
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE  contract         = contract_
        AND  part_no          = part_no_
        AND (configuration_id = configuration_id_ OR configuration_id_ IS NULL)
        AND (lot_batch_no     = lot_batch_no_     OR lot_batch_no_     IS NULL)
        AND (serial_no        = serial_no_        OR serial_no_        IS NULL)
        AND (condition_code   = condition_code_   OR condition_code_   IS NULL)
        AND ((direction = '+' AND incl_plus_dir_  = true_) OR
             (direction = '-' AND incl_minus_dir_ = true_) OR
             (direction = '0' AND incl_zero_dir_  = true_));
BEGIN
   IF (include_plus_direction_) THEN
      incl_plus_dir_ := true_;
   END IF;
   IF (include_minus_direction_) THEN
      incl_minus_dir_ := true_;
   END IF;
   IF (include_zero_direction_) THEN
      incl_zero_dir_ := true_;
   END IF;

   OPEN get_latest_trans_id;
   FETCH get_latest_trans_id INTO latest_transaction_id_;
   CLOSE get_latest_trans_id;

   RETURN (latest_transaction_id_);
END Get_Latest_Transaction_Id;


-- Get_Latest_Transaction_Id
--   Returns the latest transaction id for a specific order reference.
--   A lot of other parameter values can be sent in to further specify
--   the search criteria.
--   Returns the latest transaction ID.
--   Returns greatest inventory transaction id for given InventoryPartInStock record.
@UncheckedAccess
FUNCTION Get_Latest_Transaction_Id (
   source_ref_type_db_            IN VARCHAR2,
   source_ref1_                   IN VARCHAR2,
   source_ref2_                   IN VARCHAR2,
   source_ref3_                   IN VARCHAR2,
   source_ref4_                   IN VARCHAR2,
   contract_                      IN VARCHAR2,
   part_no_                       IN VARCHAR2,
   configuration_id_              IN VARCHAR2,
   lot_batch_no_                  IN VARCHAR2,
   serial_no_                     IN VARCHAR2,
   waiv_dev_rej_no_               IN VARCHAR2,
   eng_chg_level_                 IN VARCHAR2,
   transaction_code_              IN VARCHAR2,
   include_reversed_transactions_ IN BOOLEAN,
   part_ownership_db_             IN VARCHAR2 DEFAULT NULL,
   location_no_                   IN VARCHAR2 DEFAULT NULL,
   source_ref5_                   IN VARCHAR2 DEFAULT NULL) RETURN NUMBER
IS
   include_reversed_      VARCHAR2(5);
   latest_transaction_id_ INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;

   CURSOR get_latest_transaction_id IS
      SELECT MAX(transaction_id)
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE source_ref_type = source_ref_type_db_
      AND  source_ref1      = source_ref1_
      AND  transaction_code = transaction_code_
      AND (source_ref2      = source_ref2_       OR source_ref2_       IS NULL)
      AND (source_ref3      = source_ref3_       OR source_ref3_       IS NULL)
      AND (source_ref4      = source_ref4_       OR source_ref4_       IS NULL)
      AND (source_ref5      = source_ref5_       OR source_ref5_       IS NULL)
      AND (contract         = contract_          OR contract_          IS NULL)
      AND (part_no          = part_no_           OR part_no_           IS NULL)
      AND (configuration_id = configuration_id_  OR configuration_id_  IS NULL)
      AND (lot_batch_no     = lot_batch_no_      OR lot_batch_no_      IS NULL)
      AND (serial_no        = serial_no_         OR serial_no_         IS NULL)
      AND (waiv_dev_rej_no  = waiv_dev_rej_no_   OR waiv_dev_rej_no_   IS NULL)
      AND (eng_chg_level    = eng_chg_level_     OR eng_chg_level_     IS NULL)
      AND (part_ownership   = part_ownership_db_ OR part_ownership_db_ IS NULL)
      AND (location_no      = location_no_       OR location_no_       IS NULL)      
      AND (quantity > qty_reversed OR include_reversed_ = true_);
BEGIN
   IF (include_reversed_transactions_) THEN
      include_reversed_ := true_;
   ELSE
      include_reversed_ := false_;
   END IF;

   OPEN  get_latest_transaction_id;
   FETCH get_latest_transaction_id INTO latest_transaction_id_;
   CLOSE get_latest_transaction_id;

   RETURN(latest_transaction_id_);
END Get_Latest_Transaction_Id;


-- Get_Latest_Transaction_Id
--   Returns the latest transaction id for a specific order reference.
--   A lot of other parameter values can be sent in to further specify
--   the search criteria.
--   Returns the latest transaction ID.
--   Returns greatest inventory transaction id for given InventoryPartInStock record.
@UncheckedAccess
FUNCTION Get_Latest_Transaction_Id (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_no_      IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER ) RETURN NUMBER
IS
   CURSOR get_transaction_id IS
      SELECT MAX(transaction_id)
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE contract                 = contract_
         AND part_no                  = part_no_
         AND configuration_id         = configuration_id_
         AND location_no              = location_no_
         AND lot_batch_no             = lot_batch_no_
         AND serial_no                = serial_no_
         AND waiv_dev_rej_no          = waiv_dev_rej_no_
         AND eng_chg_level            = eng_chg_level_
         AND activity_seq             = activity_seq_
         AND NVL(handling_unit_id, 0) = NVL(handling_unit_id_, 0);
   
   transaction_id_   INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;
BEGIN
   OPEN  get_transaction_id;
   FETCH get_transaction_id INTO transaction_id_;
   CLOSE get_transaction_id;

   RETURN transaction_id_;
END Get_Latest_Transaction_Id;


-- Get_Latest_Trans_Id_For_Part
--   Returns the latest transaction_id for the specified part on the specified
@UncheckedAccess
FUNCTION Get_Latest_Trans_Id_For_Part (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   latest_transaction_id_ INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;

   CURSOR get_latest_transaction_id IS
      SELECT MAX(transaction_id)
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE contract = contract_
      AND   part_no = part_no_;
BEGIN
   OPEN  get_latest_transaction_id;
   FETCH get_latest_transaction_id INTO latest_transaction_id_;
   CLOSE get_latest_transaction_id;

   RETURN(latest_transaction_id_);
END Get_Latest_Trans_Id_For_Part;


-- Get_Last_Serial_Trans_Of_Type
--   Retrieve the transaction id for the last transaction of the specified
--   type for the serial object having the specified order reference.
@UncheckedAccess
FUNCTION Get_Last_Serial_Trans_Of_Type (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   source_ref1_      IN VARCHAR2,
   source_ref2_      IN VARCHAR2,
   source_ref3_      IN VARCHAR2,
   source_ref4_      IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2,
   transaction_code_ IN VARCHAR2 ) RETURN NUMBER
IS
   transaction_id_ INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;

   CURSOR get_last_serial_trans IS
      SELECT MAX(transaction_id)
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE (source_ref_type          = source_ref_type_db_ OR source_ref_type_db_ IS NULL)
      AND   (source_ref1              = source_ref1_ OR source_ref1_ IS NULL)
      AND   NVL(source_ref2,'DUMMY')  = NVL(source_ref2_, NVL(source_ref2,'DUMMY'))
      AND   NVL(source_ref3,'DUMMY') = NVL(source_ref3_, NVL(source_ref3,'DUMMY'))
      AND   NVL(source_ref4,'DUMMY')  = NVL(source_ref4_ ,NVL(source_ref4,'DUMMY'))
      AND   contract                 = contract_
      AND   part_no                  = part_no_
      AND   (serial_no               = serial_no_ OR serial_no_ IS NULL)
      AND   transaction_code         = transaction_code_;

BEGIN
   OPEN get_last_serial_trans;
   FETCH get_last_serial_trans INTO transaction_id_;
   CLOSE get_last_serial_trans;
   RETURN transaction_id_;
END Get_Last_Serial_Trans_Of_Type;


-- Get_Transaction_Cost_Details
--   Retrieve the cost details for the specified transaction
@UncheckedAccess
FUNCTION Get_Transaction_Cost_Details (
   transaction_id_ IN NUMBER ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
BEGIN
   RETURN Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(transaction_id_);
END Get_Transaction_Cost_Details;


-- Create_And_Account
--   Creates a new inventory transaction history record and also creates
--   the appropriate financial postings for this transaction.
PROCEDURE Create_And_Account (
   transaction_id_     OUT NUMBER,
   accounting_id_      OUT NUMBER,
   value_              OUT NUMBER,
   transaction_code_   IN  VARCHAR2,
   contract_           IN  VARCHAR2,
   part_no_            IN  VARCHAR2,
   configuration_id_   IN  VARCHAR2,
   location_no_        IN  VARCHAR2,
   lot_batch_no_       IN  VARCHAR2,
   serial_no_          IN  VARCHAR2,
   waiv_dev_rej_no_    IN  VARCHAR2,
   eng_chg_level_      IN  VARCHAR2,
   activity_seq_       IN  NUMBER,
   project_id_         IN  VARCHAR2,
   source_ref1_        IN VARCHAR2,
   source_ref2_        IN VARCHAR2,
   source_ref3_        IN VARCHAR2,
   source_ref4_        IN VARCHAR2,
   source_ref5_        IN  VARCHAR2,
   reject_code_        IN  VARCHAR2,
   cost_detail_tab_    IN  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   unit_cost_          IN  NUMBER,
   quantity_           IN  NUMBER,
   qty_reversed_       IN  NUMBER,
   catch_quantity_     IN  NUMBER,
   source_             IN  VARCHAR2,
   source_ref_type_    IN  VARCHAR2,
   owning_vendor_no_   IN  VARCHAR2,
   condition_code_     IN  VARCHAR2,
   location_group_     IN  VARCHAR2,
   part_ownership_db_  IN  VARCHAR2,
   owning_customer_no_ IN  VARCHAR2,
   expiration_date_    IN  DATE,
   trans_reval_event_id_ IN  NUMBER DEFAULT NULL ,
   handling_unit_id_     IN  NUMBER DEFAULT NULL,
   value_adjustment_     IN  BOOLEAN DEFAULT FALSE )
IS
BEGIN

   New(transaction_id_     => transaction_id_,
       accounting_id_      => accounting_id_,
       value_              => value_,
       transaction_code_   => transaction_code_,
       contract_           => contract_,
       part_no_            => part_no_,
       configuration_id_   => configuration_id_,
       location_no_        => location_no_,
       lot_batch_no_       => lot_batch_no_,
       serial_no_          => serial_no_,
       waiv_dev_rej_no_    => waiv_dev_rej_no_,
       eng_chg_level_      => eng_chg_level_,
       activity_seq_       => activity_seq_,
       project_id_         => project_id_,
       source_ref1_        => source_ref1_,
       source_ref2_        => source_ref2_,
       source_ref3_        => source_ref3_,
       source_ref4_        => source_ref4_,
       source_ref5_        => source_ref5_,
       reject_code_        => reject_code_,
       cost_detail_tab_    => cost_detail_tab_,
       unit_cost_          => unit_cost_,
       quantity_           => quantity_,
       qty_reversed_       => qty_reversed_,
       catch_quantity_     => catch_quantity_,
       source_             => source_,
       source_ref_type_    => source_ref_type_,
       owning_vendor_no_   => owning_vendor_no_,
       condition_code_     => condition_code_,
       location_group_     => location_group_,
       part_ownership_db_  => part_ownership_db_,
       owning_customer_no_ => owning_customer_no_,
       expiration_date_    => expiration_date_,
       handling_unit_id_   => handling_unit_id_);

   IF (transaction_id_ IS NOT NULL) THEN
      Do_Transaction_Booking(transaction_id_, trans_reval_event_id_, value_adjustment_);
   END IF;

END Create_And_Account;


-- Get_Arrival_Cost_For_Delivery
--   Get cost for one order row that has a transaction that is ok and that
--   has transaction code PODIRSH or PODIRINTEM using alt_source_ref columns.
FUNCTION Get_Arrival_Cost_For_Delivery (
   alt_source_ref1_  IN VARCHAR2,
   alt_source_ref2_  IN VARCHAR2,
   alt_source_ref3_  IN VARCHAR2,
   alt_source_ref4_  IN VARCHAR2,
   to_date_          IN DATE ) RETURN NUMBER
IS
   value_  NUMBER;
   qty_    NUMBER;
   cost_   NUMBER;
   
   dummy_curr_amount_detail_tab_    Mpccom_Accounting_API.Curr_Amount_Detail_Tab;                      
   dummy_number_                    NUMBER;
BEGIN
   Get_Arrival_Cost_Value_Qty___(curr_amount_detail_tab_        => dummy_curr_amount_detail_tab_,
                                 cost_                          => cost_,
                                 value_                         => value_,
                                 qty_                           => qty_,
                                 price_diff_                    => dummy_number_,                                 
                                 source_ref1_                   => NULL,
                                 source_ref2_                   => NULL,
                                 source_ref3_                   => NULL,
                                 source_ref4_                   => NULL,
                                 alt_source_ref1_               => alt_source_ref1_,
                                 alt_source_ref2_               => alt_source_ref2_,
                                 alt_source_ref3_               => alt_source_ref3_,
                                 alt_source_ref4_               => alt_source_ref4_,
                                 to_date_                       => to_date_,
                                 include_reversed_transactions_ => TRUE,
                                 serial_no_                     => NULL,
                                 use_original_amounts_for_pwa_  => TRUE,
                                 fetch_curr_amount_details_     => FALSE,
                                 use_only_m10_postings_         => FALSE);
  RETURN cost_;
END Get_Arrival_Cost_For_Delivery;

PROCEDURE Get_Arrival_Cost_For_Delivery (
   curr_amount_detail_tab_   OUT Mpccom_Accounting_API.Curr_Amount_Detail_Tab,
   arrival_cost_             OUT NUMBER,
   arrival_qty_              OUT NUMBER,
   alt_source_ref1_          IN  VARCHAR2,
   alt_source_ref2_          IN  VARCHAR2,
   alt_source_ref3_          IN  VARCHAR2,
   alt_source_ref4_          IN  VARCHAR2,
   to_date_                  IN  DATE )
IS
   value_          NUMBER;   
   dummy_number_   NUMBER;
BEGIN
  Get_Arrival_Cost_Value_Qty___(curr_amount_detail_tab_        => curr_amount_detail_tab_,
                                cost_                          => arrival_cost_,
                                value_                         => value_,
                                qty_                           => arrival_qty_,
                                price_diff_                    => dummy_number_,                                 
                                source_ref1_                   => NULL,
                                source_ref2_                   => NULL,
                                source_ref3_                   => NULL,
                                source_ref4_                   => NULL,
                                alt_source_ref1_               => alt_source_ref1_,
                                alt_source_ref2_               => alt_source_ref2_,
                                alt_source_ref3_               => alt_source_ref3_,
                                alt_source_ref4_               => alt_source_ref4_,
                                to_date_                       => to_date_,
                                include_reversed_transactions_ => TRUE,
                                serial_no_                     => NULL,
                                use_original_amounts_for_pwa_  => TRUE,
                                fetch_curr_amount_details_     => TRUE,
                                use_only_m10_postings_         => FALSE); 
 END Get_Arrival_Cost_For_Delivery;

-- Get_Consumed_Suppl_Consignment
--   Get cost for one receipt that  has transaction code COSUPCONSM,
 PROCEDURE Get_Consumed_Suppl_Consignment (
   curr_amount_detail_tab_ OUT Mpccom_Accounting_API.Curr_Amount_Detail_Tab, 
   consumed_value_         OUT NUMBER,
   consumed_qty_           OUT NUMBER,   
   source_ref1_            IN VARCHAR2,
   source_ref2_            IN VARCHAR2,
   source_ref3_            IN VARCHAR2,
   source_ref4_            IN VARCHAR2,
   to_date_                IN  DATE )

 IS
   sum_value_                     NUMBER   := 0;
   qty_                           NUMBER   := 0;
   posting_type_                  VARCHAR2(30);
   curr_amount_detail_temp_tab_   Mpccom_Accounting_API.Curr_Amount_Detail_Tab;

   CURSOR get_acc IS
      SELECT accounting_id, transaction_code,
             (DECODE(transaction_code,'COSUPCONSM',quantity,( (-1)* quantity))) total_consumed
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE (date_applied <= to_date_ OR to_date_ IS NULL)
         AND source_ref1  = source_ref1_
         AND source_ref2  = source_ref2_
         AND source_ref3  = source_ref3_
         AND source_ref4  = source_ref4_
         AND transaction_code IN ('COSUPCONSM','CO-RETURN','COUNSUCONS')
         AND source_ref_type = 'PUR ORDER';
BEGIN

   FOR invhist_rec_ IN get_acc LOOP
      IF invhist_rec_.transaction_code in  ('CO-RETURN','COUNSUCONS') then
          Acc_Event_Posting_Type_API.Get_Str_Code(posting_type_, invhist_rec_.transaction_code, 'D');
      ELSE
          Acc_Event_Posting_Type_API.Get_Str_Code(posting_type_, invhist_rec_.transaction_code, 'C');
      END IF;
      sum_value_  := sum_value_ + (Mpccom_Accounting_API.Get_Sum_Value(invhist_rec_.accounting_id,
                                                                   NVL(posting_type_,'M10'), to_date_));
      qty_   :=  qty_ + invhist_rec_.total_consumed;

      curr_amount_detail_temp_tab_ := Mpccom_Accounting_API.Get_Curr_Amount_Details(invhist_rec_.accounting_id,
                                                                                    NVL(posting_type_,'M10'),
                                                                                    to_date_);      
      curr_amount_detail_tab_ := Mpccom_Accounting_API.Get_Merged_Curr_Amount_Tab(curr_amount_detail_tab_, curr_amount_detail_temp_tab_);                                                                               
   END LOOP;

   consumed_value_:= ABS(sum_value_);
   consumed_qty_  := qty_;
END Get_Consumed_Suppl_Consignment;

-- Get_Returned_Suppl_Consignment
--   Get the total unissued and returned due to counting consignment quantity for a receipt.
@UncheckedAccess
FUNCTION Get_Returned_Suppl_Consignment (   
   source_ref1_    IN  VARCHAR2,
   source_ref2_    IN  VARCHAR2,
   source_ref3_    IN  VARCHAR2,
   source_ref4_    IN  VARCHAR2 ) RETURN NUMBER
IS
   total_returns_      NUMBER;
   
   CURSOR get_returns_to_stock IS
      SELECT SUM(quantity)
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE source_ref1  = source_ref1_
         AND source_ref2  = source_ref2_
         AND source_ref3  = source_ref3_
         AND source_ref4  = source_ref4_
         AND transaction_code IN ('COUNSUCONS', 'CO-RETURN')
         AND source_ref_type = 'PUR ORDER';
BEGIN   
   OPEN get_returns_to_stock;
   FETCH get_returns_to_stock INTO total_returns_;   
   CLOSE get_returns_to_stock;
   
   RETURN NVL(total_returns_, 0);   
END Get_Returned_Suppl_Consignment;

-- Serial_Processed_On_Order
--   This function is used to verify the connection between the serial numbers
--   of the delivered parts and the order line specified.
@UncheckedAccess
FUNCTION Serial_Processed_On_Order (
   source_ref1_               IN VARCHAR2,
   source_ref2_               IN VARCHAR2,
   source_ref3_               IN VARCHAR2,
   source_ref4_               IN VARCHAR2,
   source_ref_type_db_        IN VARCHAR2,
   part_no_                   IN VARCHAR2,
   serial_no_                 IN VARCHAR2,
   transaction_code_          IN VARCHAR2 DEFAULT NULL) RETURN BOOLEAN
IS
   dummy_                     NUMBER;
   serial_processed_on_order_ BOOLEAN := FALSE;

   CURSOR exist_control IS
      SELECT 1
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1   = source_ref1_
        AND  (source_ref2  = source_ref2_  OR source_ref2_  IS NULL)
        AND  (source_ref3  = source_ref3_  OR source_ref3_  IS NULL)
        AND  (source_ref4  = source_ref4_  OR source_ref4_  IS NULL)
        AND  source_ref_type = source_ref_type_db_
        AND  part_no      = part_no_
        AND  serial_no    = serial_no_
        AND  (transaction_code = transaction_code_ OR transaction_code_ IS NULL);

   CURSOR exist_control2 IS
      SELECT 1
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE  alt_source_ref1     = source_ref1_
        AND  (alt_source_ref2    = source_ref2_  OR source_ref2_  IS NULL)
        AND  (alt_source_ref3    = source_ref3_  OR source_ref3_  IS NULL)
        AND  (alt_source_ref4    = source_ref4_  OR source_ref4_  IS NULL)
        AND  alt_source_ref_type = source_ref_type_db_
        AND  part_no             = part_no_
        AND  serial_no           = serial_no_
        AND  (transaction_code   = transaction_code_ OR transaction_code_ IS NULL);
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      serial_processed_on_order_ := TRUE;
   ELSE
      OPEN exist_control2;
      FETCH exist_control2 INTO dummy_;
      IF (exist_control2%FOUND) THEN
         serial_processed_on_order_ := TRUE;
      END IF;
      CLOSE exist_control2;
   END IF;
   CLOSE exist_control;

   RETURN(serial_processed_on_order_);
END Serial_Processed_On_Order;


-- Reval_Cancel_Receipt_In_Place
--   Called when a 'Receipt in Place' transaction has been cancelled
--   and inventory valuation method is 'Standard Cost'
--   If the current inventory part unit cost is not the same as the
--   cost on receipt that is being reversed the method will add
--   revaluation postings to the reversal transaction.
PROCEDURE Reval_Cancel_Receipt_In_Place (
   receipt_trans_id_ IN NUMBER,
   cancel_trans_id_  IN NUMBER )
IS
   receipt_trans_rec_        INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   invepart_rec_             Inventory_Part_API.Public_Rec;
   cost_lot_batch_no_        INVENTORY_TRANSACTION_HIST_TAB.lot_batch_no%TYPE;
   cost_serial_no_           INVENTORY_TRANSACTION_HIST_TAB.serial_no%TYPE;
   std_cost_detail_tab_      Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   std_value_detail_tab_     Mpccom_Accounting_API.Value_Detail_Tab;
   receipt_value_detail_tab_ Mpccom_Accounting_API.Value_Detail_Tab;
   company_                  VARCHAR2(20);
BEGIN

   receipt_trans_rec_ := Get_Object_By_Keys___(receipt_trans_id_);
   invepart_rec_      := Inventory_Part_API.Get(receipt_trans_rec_.contract,
                                                receipt_trans_rec_.part_no);

   receipt_value_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Value_Details(
                                                                    receipt_trans_id_,
                                                                    receipt_trans_rec_.quantity);

   -- Retrive value details based on the current standard cost, the standard cost
   -- might have changed since the receipt was made
   IF (invepart_rec_.inventory_part_cost_level IN ('COST PER PART',
                                                   'COST PER CONFIGURATION')) THEN
      cost_lot_batch_no_ := '*';
      cost_serial_no_    := '*';
   ELSE
      cost_lot_batch_no_ := receipt_trans_rec_.lot_batch_no;
      cost_serial_no_    := receipt_trans_rec_.serial_no;
   END IF;

   std_cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                      receipt_trans_rec_.contract,
                                                      receipt_trans_rec_.part_no,
                                                      receipt_trans_rec_.configuration_id,
                                                      cost_lot_batch_no_,
                                                      cost_serial_no_);
  
   std_value_detail_tab_ := Create_Value_Detail_Tab(std_cost_detail_tab_,
                                                    receipt_trans_rec_.quantity,
                                                    receipt_trans_rec_.part_no);

   company_ := Site_API.Get_Company(receipt_trans_rec_.contract);
   
   Reval_Cancel_Order_Receipt___(std_value_detail_tab_,
                                 receipt_value_detail_tab_,
                                 cancel_trans_id_,
                                 receipt_trans_rec_.transaction_code,
                                 company_,
                                 per_oh_adjustment_id_ => NULL);

END Reval_Cancel_Receipt_In_Place;


-- Reval_WA_Supplier_Shipment
--   Should be called from the transaction revaluation process when
--   inventory valuation method is weighted average and a supplier
--   shipment has been made resulting in 'empty' inventory for the
--   current part cost level. When this happens extra postings may
--   have to be added to the shipment transaction to balance out
--   the inventory account.
PROCEDURE Reval_WA_Supplier_Shipment (
   transaction_id_       IN NUMBER,
   trans_reval_event_id_ IN NUMBER,
   date_applied_         IN DATE )
IS
   trans_rec_                 INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   company_                   VARCHAR2(20);
   pre_trans_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   trans_cost_detail_tab_     Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   exit_procedure_            EXCEPTION;

BEGIN

   trans_rec_ := Get_Object_By_Keys___(transaction_id_);

   IF ((trans_rec_.transaction_code NOT IN ('PURSHIP', 'PURBKFL')) OR       
       (trans_rec_.inventory_valuation_method != 'AV')) THEN
      RAISE exit_procedure_;
   END IF;

   company_                   := Site_API.Get_Company(trans_rec_.contract);
   pre_trans_cost_detail_tab_ := Pre_Invent_Trans_Avg_Cost_API.Get_Cost_Details(transaction_id_);
   trans_cost_detail_tab_     := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(transaction_id_);

   -- Although this is not a reverse transaction the same kind of revaluation postings
   -- should be created.
   Create_Revaluation_Postings___(trans_cost_detail_tab_,
                                  pre_trans_cost_detail_tab_,
                                  'INVREVAL+',
                                  'INVREVAL-',
                                  transaction_id_,
                                  trans_rec_.quantity,
                                  company_,
                                  value_adjustment_     => TRUE,
                                  per_oh_adjustment_id_ => NULL,
                                  trans_reval_event_id_ => trans_reval_event_id_,
                                  date_applied_         => date_applied_);
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Reval_WA_Supplier_Shipment;


-- Remove_Fifo_Lifo_Cost
--   Deletes the cost details in the FIFO/LIFO-stack for a specific
--   transaction code. Used during cancel of receipt transaction.
PROCEDURE Remove_Fifo_Lifo_Cost (
   cost_successfully_removed_ OUT BOOLEAN,
   original_transaction_id_   IN  NUMBER,
   qty_reversed_              IN  NUMBER,
   reverse_transaction_id_    IN  NUMBER,
   error_when_not_successful_ IN  BOOLEAN DEFAULT TRUE )
IS
   pre_trans_level_qty_in_stock_  NUMBER;
   pre_trans_level_qty_in_transi_ NUMBER;
   pre_trans_avg_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;

BEGIN
   
   Inventory_Part_Cost_Fifo_API.Remove_Cost(cost_successfully_removed_,
                                            pre_trans_level_qty_in_stock_,
                                            pre_trans_level_qty_in_transi_,
                                            pre_trans_avg_cost_detail_tab_,
                                            original_transaction_id_,
                                            qty_reversed_,
                                            reverse_transaction_id_,
                                            error_when_not_successful_);

   IF (cost_successfully_removed_) THEN
      Set_Pre_Trans_Level_Qty___(reverse_transaction_id_,
                                 pre_trans_level_qty_in_stock_,
                                 pre_trans_level_qty_in_transi_);

      Pre_Invent_Trans_Avg_Cost_API.Add_Cost_Details(reverse_transaction_id_,
                                                     pre_trans_avg_cost_detail_tab_);
   END IF;
END Remove_Fifo_Lifo_Cost;


-- Balance_Transit_And_Invent_Acc
--   Create revaluation postings to balance the inventory and transit
--   accounts when a transaction has changed the current inventory value
--   and valuation metod is Weighted Average, FIFO or LIFO
--   This is normally done from Post_Booking_Actions___ when a new transaction
--   is being created, this method is needed when existing transactions
--   have been adjusted by the revaluation jobs.
PROCEDURE Balance_Transit_And_Invent_Acc (
   transaction_id_            IN NUMBER,
   pre_trans_cost_detail_tab_ IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   current_cost_detail_tab_   IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   value_adjustment_          IN BOOLEAN,
   per_oh_adjustment_id_      IN NUMBER,
   trans_reval_event_id_      IN NUMBER DEFAULT NULL,
   date_applied_              IN DATE   DEFAULT NULL )
IS
   inv_trans_rec_ INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
BEGIN
   inv_trans_rec_ := Get_Object_By_Keys___(transaction_id_);

   IF inv_trans_rec_.inventory_valuation_method IN ('AV', 'FIFO', 'LIFO') THEN

      IF (pre_trans_cost_detail_tab_.COUNT > 0) THEN
         Balance_Transit_And_Invent___(inv_trans_rec_,
                                       pre_trans_cost_detail_tab_,
                                       current_cost_detail_tab_,
                                       value_adjustment_,
                                       per_oh_adjustment_id_,
                                       trans_reval_event_id_,
                                       date_applied_);
      END IF;
   END IF;
END Balance_Transit_And_Invent_Acc;


-- Transaction_In_Period_Exist
--   Checks if any transaction exist for a part, configuration, lot,
--   serial or condition code within a defined time period
@UncheckedAccess
FUNCTION Transaction_In_Period_Exist (
   contract_          IN VARCHAR2,
   part_no_           IN VARCHAR2,
   configuration_id_  IN VARCHAR2,
   lot_batch_no_      IN VARCHAR2,
   serial_no_         IN VARCHAR2,
   condition_code_    IN VARCHAR2,
   period_begin_date_ IN DATE,
   period_end_date_   IN DATE ) RETURN BOOLEAN
IS
   dummy_                       NUMBER;
   transaction_in_period_exist_ BOOLEAN := FALSE;

   CURSOR exist_control IS
      SELECT 1
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE  contract         = contract_
        AND  part_no          = part_no_
        AND (configuration_id = configuration_id_ OR configuration_id_ IS NULL)
        AND (lot_batch_no     = lot_batch_no_     OR lot_batch_no_     IS NULL)
        AND (serial_no        = serial_no_        OR serial_no_        IS NULL)
        AND (condition_code   = condition_code_   OR condition_code_   IS NULL)
        AND (date_applied BETWEEN period_begin_date_ AND period_end_date_);
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      transaction_in_period_exist_ := TRUE;
   END IF;
   CLOSE exist_control;

   RETURN (transaction_in_period_exist_);
END Transaction_In_Period_Exist;


-- Get_Sum_Reversed_Catch_Qty
--   Returns reversed catch quantity for an order.
@UncheckedAccess
FUNCTION Get_Sum_Reversed_Catch_Qty (
   transaction_id_ IN NUMBER ) RETURN NUMBER
IS
   CURSOR get_sum_reversed_catch_qty IS
      SELECT SUM(NVL(catch_quantity,0))
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE original_transaction_id = transaction_id_;

   sum_reversed_catch_qty_ NUMBER;
BEGIN
   OPEN get_sum_reversed_catch_qty;
   FETCH get_sum_reversed_catch_qty INTO sum_reversed_catch_qty_;
   CLOSE get_sum_reversed_catch_qty;

   RETURN (NVL(sum_reversed_catch_qty_,0));
END Get_Sum_Reversed_Catch_Qty;

-- Get_Purch_Order_Receipt_Date
--   This function will return the date_applied for a given purchase order
--   which the part_ownership is in ('COMPANY OWNED','CONSIGNMENT').
@UncheckedAccess
FUNCTION Get_Purch_Order_Receipt_Date (
   source_ref1_      IN VARCHAR2,
   source_ref2_      IN VARCHAR2,
   source_ref3_      IN VARCHAR2,
   source_ref4_      IN VARCHAR2,
   alt_source_ref1_  IN VARCHAR2,
   alt_source_ref2_  IN VARCHAR2,
   alt_source_ref3_  IN VARCHAR2,
   alt_source_ref4_  IN VARCHAR2) RETURN DATE
IS
   date_applied_ DATE;

   CURSOR get_transaction IS
      SELECT transaction_code, date_applied
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1 = source_ref1_
      AND    source_ref2 = source_ref2_
      AND    source_ref3 = source_ref3_
      AND    source_ref4 = source_ref4_
      AND    part_ownership IN ('COMPANY OWNED','CONSIGNMENT');
      
   CURSOR get_alt_transaction IS
      SELECT transaction_code, date_applied
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  alt_source_ref1 = alt_source_ref1_ 
      AND    alt_source_ref2 = alt_source_ref2_ 
      AND    alt_source_ref3 = alt_source_ref3_ 
      AND    alt_source_ref4 = alt_source_ref4_ 
      AND    part_ownership IN ('COMPANY OWNED','CONSIGNMENT');
BEGIN
   -- When changing same logic should be applied when transactions are fetched from source_ref and alt_source_ref
   IF source_ref1_ IS NOT NULL THEN
      FOR trans_rec IN get_transaction LOOP
         IF (Purchase_Order_Receipt___(trans_rec.transaction_code)) OR
            (Direct_Ship_Customer_Order___(trans_rec.transaction_code)) THEN
            date_applied_ := trans_rec.date_applied;
            EXIT;
         END IF;
      END LOOP;
   ELSE
      FOR trans_rec IN get_alt_transaction LOOP
         IF (Purchase_Order_Receipt___(trans_rec.transaction_code)) OR
            (Direct_Ship_Customer_Order___(trans_rec.transaction_code)) THEN
            date_applied_ := trans_rec.date_applied;
            EXIT;
         END IF;
      END LOOP;
   END IF;
   
   RETURN (date_applied_);
END Get_Purch_Order_Receipt_Date;


-- Is_Completely_Reversed
--   This function is used to check whether transaction is completely reversed.
@UncheckedAccess
FUNCTION Is_Completely_Reversed (
   transaction_id_ IN NUMBER ) RETURN BOOLEAN
IS
   trans_rec_           INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   completely_reversed_ BOOLEAN := FALSE;
BEGIN
   trans_rec_ := Get_Object_By_Keys___(transaction_id_);
   IF (trans_rec_.qty_reversed = trans_rec_.quantity) THEN
      completely_reversed_ := TRUE;
   END IF;
   RETURN (completely_reversed_);
END Is_Completely_Reversed;


PROCEDURE Set_Report_Id (
   transaction_id_        IN NUMBER,
   transaction_report_id_ IN VARCHAR2 )
IS
   record_ inventory_transaction_hist_tab%ROWTYPE;
BEGIN
   record_                       := Lock_By_Keys___(transaction_id_);
   record_.transaction_report_id := transaction_report_id_;
   Modify___(record_);
END Set_Report_Id;


PROCEDURE Reset_Report_Id (
   transaction_id_ IN NUMBER )
IS
   record_ inventory_transaction_hist_tab%ROWTYPE;
BEGIN
   record_                       := Lock_By_Keys___(transaction_id_);
   record_.transaction_report_id := TO_CHAR(NULL);
   Modify___(record_);
END Reset_Report_Id;


@UncheckedAccess
FUNCTION Check_Inv_Trans_Rep_Code_Exist (
   transaction_report_id_ IN VARCHAR2,
   transaction_code_      IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_ NUMBER;
   exist_ BOOLEAN := FALSE;

   CURSOR exist_control IS
      SELECT 1
      FROM  INVENTORY_TRANSACTION_HIST_TAB
      WHERE (transaction_report_id = transaction_report_id_)
      AND   (transaction_code   = transaction_code_);
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      exist_ := TRUE;
   END IF;
   CLOSE exist_control;
   RETURN exist_;
END Check_Inv_Trans_Rep_Code_Exist;


@UncheckedAccess
FUNCTION Connected_Lines_Exist (
   transaction_report_id_ IN VARCHAR2 ) RETURN NUMBER
IS
   dummy_      NUMBER;
   conn_lines_ NUMBER :=0;

   CURSOR get_connected_lines IS
      SELECT 1
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  transaction_report_id = transaction_report_id_;
BEGIN
   OPEN get_connected_lines;
   FETCH get_connected_lines INTO dummy_;
   IF (get_connected_lines%FOUND) THEN
      conn_lines_ := 1;
   END IF;
   CLOSE get_connected_lines;
   RETURN conn_lines_;
END Connected_Lines_Exist;


-- Get_Sum_Value_For_Receipt
--   Return the total value posted on the given posting type
--   for the given purchase order receipt
@UncheckedAccess
FUNCTION Get_Sum_Value_For_Receipt (
   source_ref1_  IN VARCHAR2,
   source_ref2_  IN VARCHAR2,
   source_ref3_  IN VARCHAR2,
   source_ref4_  IN VARCHAR2,
   str_code_   IN VARCHAR2,
   to_date_    IN DATE ) RETURN NUMBER
IS
   value_ NUMBER := 0;

   CURSOR get_accting_id IS
      SELECT accounting_id
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  (   (source_ref1         = source_ref1_
                  AND source_ref2     = source_ref2_
                  AND source_ref3     = source_ref3_
                  AND source_ref4     = source_ref4_
                  AND source_ref_type      = 'PUR ORDER')
              OR (alt_source_ref1     = source_ref1_
                  AND alt_source_ref2 = source_ref2_
                  AND alt_source_ref3 = source_ref3_
                  AND alt_source_ref4 = source_ref4_
                  AND alt_source_ref_type IN ('PUR ORDER','CUSTOMER ORDER DIRECT')));
BEGIN
   FOR rec_ IN get_accting_id LOOP
      value_ := value_ + Mpccom_Accounting_API.Get_Sum_Value(rec_.accounting_id, str_code_, to_date_);
   END LOOP;

   RETURN value_;
END Get_Sum_Value_For_Receipt;

-- Get_Sum_Amounts_For_Receipt
--   Return the total value posted on the given posting type
--   for the given purchase order receipt
@UncheckedAccess
PROCEDURE Get_Sum_Amounts_For_Receipt (
   base_curr_amount_           OUT NUMBER,
   trans_curr_amount_          OUT NUMBER,
   source_ref1_                IN  VARCHAR2,
   source_ref2_                IN  VARCHAR2,
   source_ref3_                IN  VARCHAR2,
   source_ref4_                IN  VARCHAR2,
   str_code_                   IN  VARCHAR2,
   to_date_                    IN  DATE,
   currency_code_              IN  VARCHAR2,
   skip_trans_reval_postings_  IN  VARCHAR2 )
IS
   local_base_currency_amount_  NUMBER := 0;
   local_trans_currency_amount_ NUMBER := 0;
   temp_base_currency_amount_   NUMBER := 0;
   temp_trans_currency_amount_  NUMBER := 0;
   suppl_mtrl_issue_trans_tab_  Mpccom_Transaction_Code_API.Transaction_Code_Tab; 
   
   CURSOR get_accting_id IS
      SELECT accounting_id
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  (   (source_ref1         = source_ref1_
                  AND source_ref2     = source_ref2_
                  AND source_ref3     = source_ref3_
                  AND source_ref4     = source_ref4_
                  AND source_ref_type = Order_Type_API.DB_PURCHASE_ORDER)
              OR (alt_source_ref1     = source_ref1_
                  AND alt_source_ref2 = source_ref2_
                  AND alt_source_ref3 = source_ref3_
                  AND alt_source_ref4 = source_ref4_
                  AND alt_source_ref_type IN (Order_Type_API.DB_PURCHASE_ORDER, Order_Type_API.DB_CUSTOMER_ORDER_DIRECT)))
      AND transaction_code NOT IN(SELECT * FROM TABLE (suppl_mtrl_issue_trans_tab_));
BEGIN
   suppl_mtrl_issue_trans_tab_ := Mpccom_Transaction_Code_API.Get_Suppl_Mtrl_Issue_Trans;
   FOR rec_ IN get_accting_id LOOP
      Mpccom_Accounting_API.Get_Sum_Amounts_Posted(temp_base_currency_amount_,
                                                   temp_trans_currency_amount_,
                                                   rec_.accounting_id,
                                                   str_code_,
                                                   currency_code_,
                                                   to_date_,
                                                   skip_trans_reval_postings_);
      local_base_currency_amount_ := local_base_currency_amount_ + NVL(temp_base_currency_amount_, 0);
      local_trans_currency_amount_ := local_trans_currency_amount_ + NVL(temp_trans_currency_amount_, 0);
   END LOOP;
   base_curr_amount_  := local_base_currency_amount_;
   trans_curr_amount_ := local_trans_currency_amount_;
  
END Get_Sum_Amounts_For_Receipt;

-- Revoke_Stage_Payment_Approval
--   This procedure will create a UNAPPINVSP transaction for the latest
--   APPRINVSP transaction with a given order no, release no, sequence no
--   and milestone id combination and reverse all the postings in the
--   original transaction.
PROCEDURE Revoke_Stage_Payment_Approval (
   source_ref1_  IN VARCHAR2,
   source_ref2_  IN VARCHAR2,
   source_ref3_  IN VARCHAR2,
   source_ref4_  IN VARCHAR2 )
IS
   qty_reversed_              NUMBER := 0;
   new_transaction_id_        NUMBER := 0;
   new_account_               NUMBER := 0;
   value_                     NUMBER := 0;
   transaction_code_          VARCHAR2(10);
   transaction_               INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   old_trans_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;

   CURSOR get_transaction IS
      SELECT *
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1  = source_ref1_
      AND    source_ref2  = source_ref2_
      AND    source_ref3  = source_ref3_
      AND    source_ref4  = source_ref4_
      AND    transaction_code    = 'APPRINVSP'
      ORDER BY transaction_id DESC;
BEGIN

   OPEN get_transaction;
   FETCH get_transaction INTO transaction_;
   IF get_transaction%NOTFOUND THEN
      Error_SYS.Record_General(lu_name_,'REVOKEINVALID: No approval transactions available, revoke is not allowed.');
      CLOSE get_transaction;
   END IF;
   CLOSE get_transaction;

   IF transaction_.direction = '0' THEN
      old_trans_cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(
                                                                      transaction_.transaction_id);
      transaction_code_ := 'UNAPPINVSP';

      NEW(transaction_id_     =>  new_transaction_id_,
          accounting_id_      =>  new_account_,
          value_              =>  value_,
          transaction_code_   =>  transaction_code_,
          contract_           =>  transaction_.contract,
          part_no_            =>  transaction_.part_no,
          configuration_id_   =>  transaction_.configuration_id,
          location_no_        =>  transaction_.location_no,
          lot_batch_no_       =>  transaction_.lot_batch_no,
          serial_no_          =>  transaction_.serial_no,
          waiv_dev_rej_no_    =>  transaction_.waiv_dev_rej_no,
          eng_chg_level_      =>  transaction_.eng_chg_level,
          activity_seq_       =>  NVL(transaction_.activity_seq,0),
          handling_unit_id_   =>  NVL(transaction_.handling_unit_id, 0),
          project_id_         =>  transaction_.project_id,
          source_ref1_        =>  transaction_.source_ref1,
          source_ref2_        =>  transaction_.source_ref2,
          source_ref3_        =>  transaction_.source_ref3,
          source_ref4_        =>  transaction_.source_ref4,
          source_ref5_        =>  transaction_.source_ref5,
          reject_code_        =>  NULL,
          cost_detail_tab_    =>  old_trans_cost_detail_tab_,
          unit_cost_          =>  NULL,
          quantity_           =>  transaction_.quantity,
          qty_reversed_       =>  qty_reversed_,
          catch_quantity_     =>  NULL,
          source_             =>  transaction_.source,
          source_ref_type_    =>  Order_Type_API.Decode(transaction_.source_ref_type),
          owning_vendor_no_   =>  NULL,
          condition_code_     =>  NULL,
          location_group_     =>  NULL,
          part_ownership_db_  =>  'COMPANY OWNED',
          owning_customer_no_ =>  NULL,
          expiration_date_    =>  NULL);

         Set_Original_Transaction_Id (new_transaction_id_, transaction_.transaction_id);

         Mpccom_Accounting_API.Reverse_Accounting(new_account_,
                                                  transaction_.accounting_id,
                                                  1,
                                                  1 );


   ELSE
      Error_SYS.Record_General(lu_name_, 'CANCELDIRER: Direction error for transaction :P1', transaction_.transaction_id);
   END IF;

END Revoke_Stage_Payment_Approval;


-- Lot_Received_On_Shop_Order
--   Returns TRUE when a Shop Order receipt(OOREC) is found for a given order
--   refernce and lot batch number.
@UncheckedAccess
FUNCTION Lot_Received_On_Shop_Order (
   source_ref1_  IN VARCHAR2,
   source_ref2_  IN VARCHAR2,
   source_ref3_  IN VARCHAR2,
   lot_batch_no_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_        NUMBER;
   lot_received_ BOOLEAN := FALSE;

    CURSOR exist_control IS
      SELECT 1
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE source_ref1      = source_ref1_
         AND source_ref2      = source_ref2_
         AND source_ref3      = source_ref3_
         AND transaction_code = 'OOREC'
         AND lot_batch_no     = lot_batch_no_
         AND quantity         > qty_reversed;
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      lot_received_ := TRUE;
   END IF;
   CLOSE exist_control;
   RETURN(lot_received_);
END Lot_Received_On_Shop_Order;


-- Get_Rejected_Purch_Receipt_Qty
--   This function will return the purchase order return and scrap credit qty for a given
--   purchase order and to-date.
@UncheckedAccess
FUNCTION Get_Rejected_Purch_Receipt_Qty (
   source_ref1_     IN VARCHAR2,
   source_ref2_     IN VARCHAR2,
   source_ref3_     IN VARCHAR2,
   source_ref4_     IN VARCHAR2,
   to_date_applied_ IN DATE ) RETURN NUMBER
IS
   qty_rejected_1_ NUMBER;
   qty_rejected_2_ NUMBER;

   CURSOR get_qty_rejected_1 IS
      SELECT SUM(CASE transaction_code
                    WHEN 'RETWORK'   THEN quantity
                    WHEN 'RETCREDIT' THEN quantity
                    WHEN 'SCPCREDIT' THEN quantity
                    ELSE  (quantity * -1) END)
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1      = source_ref1_
      AND    source_ref2      = source_ref2_
      AND    source_ref3      = source_ref3_
      AND    source_ref4      = source_ref4_ 
      AND    (date_applied    <= TRUNC(to_date_applied_) OR to_date_applied_ IS NULL)
      AND    source_ref_type  = Order_Type_API.DB_PURCHASE_ORDER
      AND    part_ownership   = Part_Ownership_API.DB_COMPANY_OWNED
      AND    transaction_code IN ('RETWORK', 'RETCREDIT', 'RETCORWORK', 'RETCORCRE', 'SCPCREDIT', 'SCPCREDCOR');

   CURSOR get_qty_rejected_2 IS
      SELECT SUM(quantity)
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  alt_source_ref1     = source_ref1_
      AND    alt_source_ref2     = source_ref2_
      AND    alt_source_ref3     = source_ref3_
      AND    alt_source_ref4     = source_ref4_
      AND    date_applied       <= TRUNC(to_date_applied_)
      AND    alt_source_ref_type = Order_Type_API.DB_CUSTOMER_ORDER_DIRECT
      AND    part_ownership      = Part_Ownership_API.DB_COMPANY_OWNED
      AND    transaction_code    = 'RETPODIRSH';


BEGIN
   OPEN get_qty_rejected_1;
   FETCH get_qty_rejected_1 INTO qty_rejected_1_;
   CLOSE get_qty_rejected_1;

   OPEN get_qty_rejected_2;
   FETCH get_qty_rejected_2 INTO qty_rejected_2_;
   CLOSE get_qty_rejected_2;

   RETURN (NVL(qty_rejected_1_, 0) + NVL(qty_rejected_2_, 0));

END Get_Rejected_Purch_Receipt_Qty;


-- Get_Transaction_Id_Tab
--   Returns a PLSQL table of transaction_id's for the given criteria.
@UncheckedAccess
FUNCTION Get_Transaction_Id_Tab (
   source_ref1_   IN VARCHAR2,
   source_ref4_   IN VARCHAR2,
   location_no_   IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2,
   direction_     IN VARCHAR2 ) RETURN Transaction_Id_Tab
IS
   transaction_id_tab_ Transaction_Id_Tab;

   CURSOR get_transactions IS
      SELECT transaction_id
      FROM  INVENTORY_TRANSACTION_HIST_TAB
      WHERE source_ref1  = source_ref1_
        AND source_ref4  = source_ref4_
        AND NVL(location_no,'NULL') = NVL(location_no_,NVL(location_no,'NULL'))
        AND source_ref_type  = source_ref_type_db_
        AND (quantity - qty_reversed) > 0
        AND direction = direction_;
BEGIN
   OPEN get_transactions;
   FETCH get_transactions BULK COLLECT INTO transaction_id_tab_;
   CLOSE get_transactions;

   RETURN (transaction_id_tab_);
END Get_Transaction_Id_Tab;


@UncheckedAccess
FUNCTION Get_Consumed_Comp_Cost_Details (
   source_ref1_ IN VARCHAR2,
   source_ref2_ IN VARCHAR2,
   source_ref3_ IN VARCHAR2,
   source_ref4_ IN VARCHAR2 ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   transaction_id_  INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;
BEGIN
   transaction_id_ := Get_Purch_Comp_Consume_Trans(source_ref1_,
                                                   source_ref2_,
                                                   source_ref3_,
                                                   source_ref4_);

   IF (transaction_id_ IS NOT NULL) THEN
      cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(transaction_id_           => transaction_id_,
                                                                                      include_added_details_    => FALSE,
                                                                                      include_normal_details_   => TRUE,
                                                                                      replace_star_cost_bucket_ => TRUE);
   END IF;

   RETURN (cost_detail_tab_);
END Get_Consumed_Comp_Cost_Details;


@UncheckedAccess
FUNCTION Get_Consumed_Component_Cost (
   source_ref1_ IN VARCHAR2,
   source_ref2_ IN VARCHAR2,
   source_ref3_ IN VARCHAR2,
   source_ref4_ IN VARCHAR2 ) RETURN NUMBER
IS
   transaction_id_      INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;
   trans_rec_           INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
   sum_value_           NUMBER := 0;
   unit_cost_           NUMBER := 0;
   
BEGIN
   transaction_id_ := Get_Purch_Comp_Consume_Trans(source_ref1_,
                                                   source_ref2_,
                                                   source_ref3_,
                                                   source_ref4_);

   IF (transaction_id_ IS NOT NULL) THEN
      trans_rec_ := Get_Object_By_Keys___(transaction_id_);
      sum_value_ := Mpccom_Accounting_API.Get_Sum_Value(trans_rec_.accounting_id, 'M10', NULL);
      unit_cost_ := sum_value_ / trans_rec_.quantity;
   END IF;

   RETURN  (unit_cost_);
END Get_Consumed_Component_Cost;

@UncheckedAccess
FUNCTION Get_Consumed_Comp_Curr_Details (
   source_ref1_ IN VARCHAR2,
   source_ref2_ IN VARCHAR2,
   source_ref3_ IN VARCHAR2,
   source_ref4_ IN VARCHAR2,
   to_date_     IN DATE     ) RETURN Mpccom_Accounting_API.Curr_Amount_Detail_Tab
IS
   curr_amount_detail_tab_       Mpccom_Accounting_API.Curr_Amount_Detail_Tab;
   transaction_id_tab_           Transaction_Id_Tab;
   accounting_id_                INVENTORY_TRANSACTION_HIST_TAB.accounting_id%TYPE;
   total_curr_amount_detail_tab_ Mpccom_Accounting_API.Curr_Amount_Detail_Tab;
BEGIN
   transaction_id_tab_ := Get_Purch_Comp_Consum_Tran_Tab(source_ref1_,
                                                         source_ref2_,
                                                         source_ref3_,
                                                         source_ref4_);
   IF (transaction_id_tab_.COUNT > 0) THEN
      FOR i_ IN transaction_id_tab_.FIRST..transaction_id_tab_.LAST LOOP
         accounting_id_ := Inventory_Transaction_Hist_API.Get_Accounting_Id(transaction_id_tab_(i_));
         curr_amount_detail_tab_ := Mpccom_Accounting_API.Get_Curr_Amount_Details(accounting_id_,
                                                                                  'M10',
                                                                                  to_date_);
         total_curr_amount_detail_tab_ := Mpccom_Accounting_API.Get_Merged_Curr_Amount_Tab(total_curr_amount_detail_tab_, curr_amount_detail_tab_);
      END LOOP;
   END IF;
   
   RETURN (total_curr_amount_detail_tab_);
END Get_Consumed_Comp_Curr_Details;

PROCEDURE Get_External_Service_Costs (
   comp_cost_detail_tab_    OUT Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   service_cost_detail_tab_ OUT Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   source_ref_1_            IN  VARCHAR2,
   source_ref_2_            IN  VARCHAR2,
   source_ref_3_            IN  VARCHAR2,
   service_cost_            IN  NUMBER,
   include_service_cost_    IN  BOOLEAN,
   contract_                IN  VARCHAR2 )
IS
   cost_bucket_type_db_ VARCHAR2(20);
BEGIN

   comp_cost_detail_tab_ := Get_Ext_Service_Comp_Cost___(source_ref_1_,
                                                         source_ref_2_,
                                                         source_ref_3_);
   IF (include_service_cost_) THEN
      -- The cost of the repair should be added to the first cost detail of type MATERIAL
      IF (comp_cost_detail_tab_.COUNT > 0) THEN
         FOR i IN comp_cost_detail_tab_.FIRST..comp_cost_detail_tab_.LAST LOOP
            cost_bucket_type_db_ := Invent_Cost_Bucket_Manager_API.Get_Cost_Bucket_Type_Db(
                                                          comp_cost_detail_tab_(i).contract,
                                                          comp_cost_detail_tab_(i).cost_bucket_id);
            IF (cost_bucket_type_db_ IN ('MATERIAL', 'DummyCostBucketType')) THEN
               comp_cost_detail_tab_(i).unit_cost    := comp_cost_detail_tab_(i).unit_cost + service_cost_;
               service_cost_detail_tab_(1)           := comp_cost_detail_tab_(i);
               service_cost_detail_tab_(1).unit_cost := service_cost_;
               EXIT;
            END IF;
         END LOOP;
      END IF;
   END IF;

   IF (service_cost_detail_tab_.COUNT = 0) THEN
      service_cost_detail_tab_(1).accounting_year := '*';
      service_cost_detail_tab_(1).contract        := contract_;
      service_cost_detail_tab_(1).cost_bucket_id  := '*';
      service_cost_detail_tab_(1).company         := Site_API.Get_Company(contract_);
      service_cost_detail_tab_(1).cost_source_id  := '*';
      service_cost_detail_tab_(1).unit_cost       := service_cost_;
   END IF;
END Get_External_Service_Costs;

@UncheckedAccess
FUNCTION Get_Purch_Comp_Consum_Tran_Tab (
   source_ref1_ IN VARCHAR2,
   source_ref2_ IN VARCHAR2,
   source_ref3_ IN VARCHAR2,
   source_ref4_ IN VARCHAR2) RETURN Transaction_Id_Tab
IS
   transaction_id_tab_  Transaction_Id_Tab;
   
   CURSOR get_purch_comp_consume_trans IS
      SELECT transaction_id
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE source_ref1      = source_ref1_
         AND source_ref2      = source_ref2_
         AND source_ref3      = source_ref3_
         AND (source_ref4      = source_ref4_ OR source_ref4_ IS NULL)
         AND source_ref_type  = 'PUR ORDER'
         AND transaction_code = 'POINV-WIP';
BEGIN
   OPEN  get_purch_comp_consume_trans;
   FETCH get_purch_comp_consume_trans BULK COLLECT INTO transaction_id_tab_;
   CLOSE get_purch_comp_consume_trans;

   RETURN (transaction_id_tab_);
END Get_Purch_Comp_Consum_Tran_Tab;

@UncheckedAccess
FUNCTION Get_Purch_Comp_Consume_Trans (
   source_ref1_ IN VARCHAR2,
   source_ref2_ IN VARCHAR2,
   source_ref3_ IN VARCHAR2,
   source_ref4_ IN VARCHAR2) RETURN NUMBER
IS
   transaction_id_tab_  Transaction_Id_Tab;
   transaction_id_      INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;   
BEGIN
   transaction_id_tab_ := Get_Purch_Comp_Consum_Tran_Tab(source_ref1_,
                                                         source_ref2_,
                                                         source_ref3_,
                                                         source_ref4_);
   IF (transaction_id_tab_.COUNT > 0) THEN
      transaction_id_ := transaction_id_tab_(1);
   END IF;

   RETURN (transaction_id_);
END Get_Purch_Comp_Consume_Trans;


PROCEDURE Handle_Purch_Order_Line_Close (
   po_line_ref1_ IN VARCHAR2,
   po_line_ref2_ IN VARCHAR2,
   po_line_ref3_ IN VARCHAR2 )
IS
   exit_procedure_       EXCEPTION;
   stmt_                 VARCHAR2(2000);   
   pos_ix_               PLS_INTEGER := 1;
   neg_ix_               PLS_INTEGER := 1;
   dummy_number_         NUMBER;
   contract_             INVENTORY_TRANSACTION_HIST_TAB.contract%TYPE;
   part_no_              INVENTORY_TRANSACTION_HIST_TAB.part_no%TYPE;
   configuration_id_     INVENTORY_TRANSACTION_HIST_TAB.configuration_id%TYPE;
   lot_batch_no_         INVENTORY_TRANSACTION_HIST_TAB.lot_batch_no%TYPE;
   serial_no_            INVENTORY_TRANSACTION_HIST_TAB.serial_no%TYPE;
   eng_chg_level_        INVENTORY_TRANSACTION_HIST_TAB.eng_chg_level%TYPE;
   activity_seq_         INVENTORY_TRANSACTION_HIST_TAB.activity_seq%TYPE;
   project_id_           INVENTORY_TRANSACTION_HIST_TAB.project_id%TYPE;
   vendor_no_            INVENTORY_TRANSACTION_HIST_TAB.owning_vendor_no%TYPE;
   part_ownership_       INVENTORY_TRANSACTION_HIST_TAB.part_ownership%TYPE;
   customer_no_          INVENTORY_TRANSACTION_HIST_TAB.owning_customer_no%TYPE;
   
   merged_value_detail_tab_       Mpccom_Accounting_API.Value_Detail_Tab;
   value_detail_tab_              Mpccom_Accounting_API.Value_Detail_Tab;
   pos_value_detail_tab_          Mpccom_Accounting_API.Value_Detail_Tab;
   neg_value_detail_tab_          Mpccom_Accounting_API.Value_Detail_Tab;
   empty_cost_detail_tab_         Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   transaction_id_                Inventory_Transaction_Hist_Tab.transaction_id%TYPE;

   CURSOR get_supplier_wip_acc_id IS
      SELECT accounting_id
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE ((source_ref_type = 'PUR ORDER' AND source_ref1 = po_line_ref1_
                                             AND source_ref2 = po_line_ref2_
                                             AND source_ref3 = po_line_ref3_
                                             AND transaction_code IN ('PURSHIP',    'CO-PURSHIP',
                                                                      'PURBKFL',    'CO-PURBKFL',
                                                                      'PURDIR',     'INTPURDIR',
                                                                      'RETWOR-WIP', 'POINV-WIP',
                                                                      'CLEAR-WIP+', 'CLEAR-WIP-',
                                                                      'ARR-COMP',   'PARTSWAP',
                                                                      'REP-SCRAP',  'SERLOTSWAP',
                                                                      'ARR-REPAIR',
                                                                      'UNREPSCRAP', 'UNRET-WIP',
                                                                      'UN-PURSHIP', 'CO-UNPSHIP',
                                                                      'UN-PURBKFL', 'CO-UNPBKFL', 
                                                                      'UNRCPT',     'UNRCPT-'))
                                OR
             (alt_source_ref_type = 'PUR ORDER' AND alt_source_ref1 = po_line_ref1_
                                                AND alt_source_ref2 = po_line_ref2_
                                                AND alt_source_ref3 = po_line_ref3_
                                                AND transaction_code IN ('OERET-NC','OERET-SPNC')));         
BEGIN

   -- Get the value details posted on M15 in relation to the PO line.
   FOR rec_ IN get_supplier_wip_acc_id LOOP
      value_detail_tab_ := Mpccom_Accounting_API.Get_Sum_Value_Details(rec_.accounting_id, 'M15');
      -- Merge the retrieved value details per bucket_posting_group_id and cost_source_id
      merged_value_detail_tab_ := Mpccom_Accounting_API.Get_Merged_Value_Detail_Tab (merged_value_detail_tab_, value_detail_tab_);
   END LOOP;

   -- Exit if no records found
   IF (merged_value_detail_tab_.COUNT = 0) THEN
      RAISE exit_procedure_;
   END IF;

   stmt_ := 'DECLARE '                                                              ||
               'po_line_ref1_ VARCHAR2(50); '                                       ||
               'po_line_ref2_ VARCHAR2(50); '                                       ||
               'po_line_ref3_ VARCHAR2(50); '                                       ||
               'po_line_rec_ Purchase_Order_Line_Part_API.Public_Rec; '             ||
               'po_rec_      Purchase_Order_API.Public_Rec; '                       ||
            'BEGIN '                                                                ||
               'po_line_ref1_ := :po_line_ref1; '                                   ||
               'po_line_ref2_ := :po_line_ref2; '                                   ||
               'po_line_ref3_ := :po_line_ref3; '                                   ||
               'po_rec_       := Purchase_Order_API.Get(po_line_ref1_); '           ||
               'po_line_rec_  := Purchase_Order_Line_Part_API.Get(po_line_ref1_, '  ||
                                                                 'po_line_ref2_, '  ||
                                                                 'po_line_ref3_); ' ||
               ':contract         := po_line_rec_.contract; '                       ||
               ':part_no          := po_line_rec_.part_no; '                        ||
               ':configuration_id := po_line_rec_.configuration_id; '               ||
               ':lot_batch_no     := po_line_rec_.lot_batch_no; '                   ||
               ':serial_no        := po_line_rec_.serial_no; '                      ||
               ':eng_chg_level    := po_line_rec_.eng_chg_level; '                  ||
               ':activity_seq     := po_line_rec_.activity_seq; '                   ||
               ':project_id       := po_line_rec_.project_id; '                     ||
               ':vendor_no        := po_rec_.vendor_no; '                           ||
               ':part_ownership   := po_line_rec_.part_ownership; '                 ||
               ':customer_no      := po_line_rec_.owning_customer_no; '             ||
            'END; ';

   @ApproveDynamicStatement(2007-11-30,LEPESE)
   EXECUTE IMMEDIATE stmt_
      USING IN  po_line_ref1_,
            IN  po_line_ref2_,
            IN  po_line_ref3_,
            OUT contract_,
            OUT part_no_,
            OUT configuration_id_,
            OUT lot_batch_no_,
            OUT serial_no_,
            OUT eng_chg_level_,
            OUT activity_seq_,
            OUT project_id_,
            OUT vendor_no_,
            OUT part_ownership_,
            OUT customer_no_;

   -- Create value details to be posted on 'CLEAR-WIP+' and/or 'CLEAR-WIP-'
   FOR i IN merged_value_detail_tab_.FIRST..merged_value_detail_tab_.LAST LOOP
      IF (merged_value_detail_tab_(i).value > 0) THEN
         pos_value_detail_tab_(pos_ix_).bucket_posting_group_id := merged_value_detail_tab_(i).bucket_posting_group_id;
         pos_value_detail_tab_(pos_ix_).cost_source_id          := merged_value_detail_tab_(i).cost_source_id;
         pos_value_detail_tab_(pos_ix_).value                   := merged_value_detail_tab_(i).value ;
         pos_ix_                                                := pos_ix_ + 1;
      ELSIF (merged_value_detail_tab_(i).value < 0) THEN
         neg_value_detail_tab_(neg_ix_).bucket_posting_group_id := merged_value_detail_tab_(i).bucket_posting_group_id;
         neg_value_detail_tab_(neg_ix_).cost_source_id          := merged_value_detail_tab_(i).cost_source_id;
         neg_value_detail_tab_(neg_ix_).value                   := merged_value_detail_tab_(i).value * -1;
         neg_ix_                                                := neg_ix_ + 1;
      END IF;
   END LOOP;

   IF (pos_value_detail_tab_.COUNT > 0 ) THEN
      Inventory_Transaction_Hist_API.New(transaction_id_     => transaction_id_,
                                         accounting_id_      => dummy_number_,
                                         value_              => dummy_number_,
                                         transaction_code_   => 'CLEAR-WIP+',
                                         contract_           => contract_,
                                         part_no_            => part_no_,
                                         configuration_id_   => configuration_id_,
                                         location_no_        => NULL,
                                         lot_batch_no_       => lot_batch_no_,
                                         serial_no_          => serial_no_,
                                         waiv_dev_rej_no_    => NULL,
                                         eng_chg_level_      => eng_chg_level_,
                                         activity_seq_       => activity_seq_,
                                         project_id_         => project_id_,
                                         source_ref1_        => po_line_ref1_,
                                         source_ref2_        => po_line_ref2_,
                                         source_ref3_        => po_line_ref3_,
                                         source_ref4_        => NULL,
                                         source_ref5_        => NULL,
                                         reject_code_        => NULL,
                                         cost_detail_tab_    => empty_cost_detail_tab_,
                                         unit_cost_          => NULL,
                                         quantity_           => 1,
                                         qty_reversed_       => 0,
                                         catch_quantity_     => NULL,
                                         source_             => NULL,
                                         source_ref_type_    => Order_Type_API.Decode(Order_Type_API.DB_PURCHASE_ORDER),
                                         owning_vendor_no_   => vendor_no_,
                                         condition_code_     => NULL,
                                         location_group_     => NULL,
                                         part_ownership_db_  => part_ownership_,
                                         owning_customer_no_ => customer_no_,
                                         expiration_date_    => NULL);
                                         
      Inventory_Transaction_Hist_API.Do_Booking(transaction_id_     => transaction_id_,
                                                company_            => NULL,
                                                event_code_         => NULL,
                                                complete_flag_      => 'Y',
                                                external_value_tab_ => pos_value_detail_tab_);                                  
   END IF;

   IF (neg_value_detail_tab_.COUNT > 0 ) THEN
      Inventory_Transaction_Hist_API.New(transaction_id_     => transaction_id_,
                                         accounting_id_      => dummy_number_,
                                         value_              => dummy_number_,
                                         transaction_code_   => 'CLEAR-WIP-',
                                         contract_           => contract_,
                                         part_no_            => part_no_,
                                         configuration_id_   => configuration_id_,
                                         location_no_        => NULL,
                                         lot_batch_no_       => lot_batch_no_,
                                         serial_no_          => serial_no_,
                                         waiv_dev_rej_no_    => NULL,
                                         eng_chg_level_      => eng_chg_level_,
                                         activity_seq_       => activity_seq_,
                                         project_id_         => project_id_,
                                         source_ref1_        => po_line_ref1_,
                                         source_ref2_        => po_line_ref2_,
                                         source_ref3_        => po_line_ref3_,
                                         source_ref4_        => NULL,
                                         source_ref5_        => NULL,
                                         reject_code_        => NULL,
                                         cost_detail_tab_    => empty_cost_detail_tab_,
                                         unit_cost_          => NULL,
                                         quantity_           => 1,
                                         qty_reversed_       => 0,
                                         catch_quantity_     => NULL,
                                         source_             => NULL,
                                         source_ref_type_    => Order_Type_API.Decode(Order_Type_API.DB_PURCHASE_ORDER),
                                         owning_vendor_no_   => vendor_no_,
                                         condition_code_     => NULL,
                                         location_group_     => NULL,
                                         part_ownership_db_  => part_ownership_,
                                         owning_customer_no_ => customer_no_,
                                         expiration_date_    => NULL);
                                         
      Inventory_Transaction_Hist_API.Do_Booking(transaction_id_     => transaction_id_,
                                                company_            => NULL,
                                                event_code_         => NULL,
                                                complete_flag_      => 'Y',
                                                external_value_tab_ => neg_value_detail_tab_);                                   
   END IF;
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Handle_Purch_Order_Line_Close;


FUNCTION Create_Value_Detail_Tab (
   cost_detail_tab_ IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   quantity_        IN NUMBER ,
   part_no_         IN VARCHAR2 ) RETURN Mpccom_Accounting_API.Value_Detail_Tab
IS
   value_detail_tab_        Mpccom_Accounting_API.Value_Detail_Tab;
   row_no_                  PLS_INTEGER := 0;
   bucket_posting_group_id_ VARCHAR2(20);
   dummy_                   VARCHAR2(20);
   value_detail_rec_exist_  BOOLEAN;
BEGIN
   IF (cost_detail_tab_.COUNT > 0) THEN
      FOR i IN cost_detail_tab_.FIRST..cost_detail_tab_.LAST LOOP
         Inventory_Transaction_Cost_API.Get_Cost_Bucket_Group_And_Type(
                                                               bucket_posting_group_id_,
                                                               dummy_,
                                                               cost_detail_tab_(i).contract,
                                                               cost_detail_tab_(i).cost_bucket_id,
                                                               part_no_);
         value_detail_rec_exist_ := FALSE;

         FOR j IN 1..row_no_ LOOP
            IF ((NVL(cost_detail_tab_(i).cost_source_id,'*') =
                                                           value_detail_tab_(j).cost_source_id) AND
                (NVL(bucket_posting_group_id_,'*') =
                                                value_detail_tab_(j).bucket_posting_group_id)) THEN

               value_detail_tab_(j).value := value_detail_tab_(j).value +
                                                       (cost_detail_tab_(i).unit_cost * quantity_);
               value_detail_rec_exist_ := TRUE;
               EXIT;
            END IF;
         END LOOP;

         IF NOT (value_detail_rec_exist_) THEN
            row_no_ := row_no_ + 1;
            value_detail_tab_(row_no_).bucket_posting_group_id :=
                                                                 NVL(bucket_posting_group_id_,'*');
            value_detail_tab_(row_no_).cost_source_id :=
                                                       NVL(cost_detail_tab_(i).cost_source_id,'*');
            value_detail_tab_(row_no_).value := (cost_detail_tab_(i).unit_cost * quantity_);
         END IF;
      END LOOP;
   END IF;

   RETURN (value_detail_tab_);
END Create_Value_Detail_Tab;


-- Cancel_Purch_Component_Issue
--   Returns true if the Unissue  transaction of a part is done due to
--   a Cancel of PO component backflush
@UncheckedAccess
FUNCTION Cancel_Purch_Component_Issue (
   transaction_id_ IN NUMBER ) RETURN BOOLEAN
IS
   cancel_purch_component_issue_ BOOLEAN := FALSE;
   transaction_code_             INVENTORY_TRANSACTION_HIST_TAB.transaction_code%TYPE;
BEGIN
   transaction_code_ := Get_Transaction_Code(transaction_id_);

   IF (transaction_code_ IN ('UN-PURSHIP','CO-UNPSHIP','UN-PURBKFL','CO-UNPBKFL')) THEN
      cancel_purch_component_issue_ := TRUE;
   END IF;

   RETURN (cancel_purch_component_issue_);
END Cancel_Purch_Component_Issue;


-- Get_Sales_Overhead_Details
--   Returns the sales overhead cost details for a order line.
FUNCTION Get_Sales_Overhead_Details (
   contract_        IN VARCHAR2,
   part_no_         IN VARCHAR2,
   source_ref1_     IN VARCHAR2,
   source_ref2_     IN VARCHAR2,
   source_ref3_     IN VARCHAR2,
   source_ref4_     IN VARCHAR2,
   unit_cost_       IN NUMBER ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   tran_hist_rec_      INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
BEGIN

   tran_hist_rec_.transaction_code := 'OESHIP';
   tran_hist_rec_.contract         := contract_;
   tran_hist_rec_.part_no          := part_no_;
   tran_hist_rec_.source_ref1      := source_ref1_;
   tran_hist_rec_.source_ref2      := source_ref2_;
   tran_hist_rec_.source_ref3      := source_ref3_;
   tran_hist_rec_.source_ref4      := source_ref4_;
   tran_hist_rec_.source_ref_type  := 'CUST ORDER';
   tran_hist_rec_.date_created     := Site_API.Get_Site_Date(contract_);

   RETURN (Get_Sales_Overhead_Details___(tran_hist_rec_,
                                        Inventory_Part_API.Get(contract_, part_no_),
                                        Site_API.Get_Company(contract_),
                                        unit_cost_));
END Get_Sales_Overhead_Details;


-- Get_Customer_Return_Cost
--   Returns the cost to be used for the customer return transaction.
FUNCTION Get_Customer_Return_Cost (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   condition_code_   IN VARCHAR2,
   rma_no_           IN VARCHAR2,
   rma_line_no_      IN NUMBER,
   transaction_code_ IN VARCHAR2 ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   transaction_id_tab_         Transaction_Id_Tab;
   cost_detail_tab_            Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   cost_bucket_public_type_db_ VARCHAR2(20);
   dummy_                      VARCHAR2(20);
BEGIN

   transaction_id_tab_ := Get_Cust_Shipment_Transactions(contract_,
                                                         part_no_,
                                                         configuration_id_,
                                                         lot_batch_no_,
                                                         serial_no_,
                                                         condition_code_,
                                                         rma_no_,
                                                         rma_line_no_,
                                                         transaction_code_);
   IF (transaction_id_tab_.COUNT = 0) THEN
      cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Default_Details(contract_,
                                                                           part_no_,
                                                                           configuration_id_,
                                                                           lot_batch_no_,
                                                                           serial_no_,
                                                                           condition_code_,
                                                                           'RETURN MATERIAL AUTHORIZATION');
   ELSE
      cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(
                                             transaction_id_           => transaction_id_tab_(transaction_id_tab_.FIRST),
                                             include_added_details_    => FALSE,
                                             include_normal_details_   => TRUE,
                                             replace_star_cost_bucket_ => TRUE);
      IF (cost_detail_tab_.COUNT > 0)  THEN
         FOR i_ IN cost_detail_tab_.FIRST..cost_detail_tab_.LAST LOOP
            IF (cost_detail_tab_(i_).cost_bucket_id != '*') THEN
               Inventory_Transaction_Cost_API.Get_Cost_Bucket_Group_And_Type(dummy_,
                                                                             cost_bucket_public_type_db_,
                                                                             contract_,
                                                                             cost_detail_tab_(i_).cost_bucket_id,
                                                                             part_no_);
               IF (cost_bucket_public_type_db_ = 'SALESOH') THEN
                  cost_detail_tab_.DELETE(i_);
               END IF;
            END IF;
         END LOOP;
      END IF;
   END IF;

   RETURN cost_detail_tab_;
END Get_Customer_Return_Cost;


@UncheckedAccess
FUNCTION Issue_Supplier_Owned_Stock (
   transaction_id_ IN NUMBER ) RETURN BOOLEAN
IS
   issue_supplier_owned_stock_ BOOLEAN := FALSE;
   transaction_code_           INVENTORY_TRANSACTION_HIST_TAB.transaction_code%TYPE;
BEGIN
   transaction_code_ := Get_Transaction_Code(transaction_id_);
   IF (transaction_code_ = 'OWNTRANOUT') THEN
      issue_supplier_owned_stock_ := TRUE;
   END IF;
   RETURN (issue_supplier_owned_stock_);
END Issue_Supplier_Owned_Stock;


PROCEDURE Get_Supplier_Return_Cost (
   transaction_id_                OUT NUMBER,
   cost_detail_tab_               OUT Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   source_ref1_                   IN  VARCHAR2,
   source_ref2_                   IN  VARCHAR2,
   source_ref3_                   IN  VARCHAR2,
   source_ref4_                   IN  VARCHAR2,
   contract_                      IN  VARCHAR2 DEFAULT NULL,
   part_no_                       IN  VARCHAR2 DEFAULT NULL,
   configuration_id_              IN  VARCHAR2 DEFAULT NULL,
   lot_batch_no_                  IN  VARCHAR2 DEFAULT NULL,
   serial_no_                     IN  VARCHAR2 DEFAULT NULL,
   include_reversed_transactions_ IN  BOOLEAN  DEFAULT FALSE )
IS
BEGIN
   transaction_id_ := Get_Latest_Transaction_Id(
                         source_ref_type_db_            => 'PUR ORDER',
                         source_ref1_                   => source_ref1_,
                         source_ref2_                   => source_ref2_,
                         source_ref3_                   => source_ref3_,
                         source_ref4_                   => source_ref4_,
                         contract_                      => contract_,
                         part_no_                       => part_no_,
                         configuration_id_              => configuration_id_,
                         lot_batch_no_                  => lot_batch_no_,
                         serial_no_                     => serial_no_,
                         waiv_dev_rej_no_               => NULL,
                         eng_chg_level_                 => NULL,
                         transaction_code_              => 'ARRIVAL',
                         include_reversed_transactions_ => include_reversed_transactions_);

   IF (transaction_id_ IS NULL) THEN
      transaction_id_ := Get_Latest_Transaction_Id(
                            source_ref_type_db_            => 'PUR ORDER',
                            source_ref1_                   => source_ref1_,
                            source_ref2_                   => source_ref2_,
                            source_ref3_                   => source_ref3_,
                            source_ref4_                   => source_ref4_,
                            contract_                      => contract_,
                            part_no_                       => part_no_,
                            configuration_id_              => configuration_id_,
                            lot_batch_no_                  => lot_batch_no_,
                            serial_no_                     => serial_no_,
                            waiv_dev_rej_no_               => NULL,
                            eng_chg_level_                 => NULL,
                            transaction_code_              => 'XO-ARRIVAL',
                            include_reversed_transactions_ => include_reversed_transactions_);
      IF (transaction_id_ IS NULL) THEN
         Error_SYS.Record_General(lu_name_, 'TRANSNOTEXIST: The Arrival transaction for the order does not exist.' );
      END IF;
   END IF;
   --Note: Retrieves cost_deatil_tab_ by replacing star cost bucket.
   cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(transaction_id_           => transaction_id_,
                                                                                   include_added_details_    => FALSE,
                                                                                   include_normal_details_   => TRUE,
                                                                                   replace_star_cost_bucket_ => TRUE);
END Get_Supplier_Return_Cost;


-- Actual_Cost_Transactions_Exist
--   Checks if the Shop Order has any transactions for Actual cost enabled parts
@UncheckedAccess
FUNCTION Actual_Cost_Transactions_Exist (
   source_ref1_       IN  VARCHAR2,
   source_ref2_       IN  VARCHAR2,
   source_ref3_       IN  VARCHAR2,
   source_ref4_       IN  VARCHAR2,
   order_ref_type_db_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   result_ BOOLEAN := FALSE;

   CURSOR get_inv_transactions IS
      SELECT DISTINCT contract, part_no
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE  source_ref1  = source_ref1_
         AND  source_ref2  = source_ref2_
         AND  source_ref3  = source_ref3_
         AND  part_ownership = 'COMPANY OWNED'
         AND (source_ref4_ IS NULL OR source_ref4 = source_ref4_)
         AND  source_ref_type = order_ref_type_db_;
BEGIN
   FOR invhist_rec IN get_inv_transactions LOOP
      IF Inventory_Part_API.Cascade_Trans_Cost_Update(invhist_rec.contract,
                                                      invhist_rec.part_no) THEN
         result_ := TRUE;
         EXIT;
      END IF;
   END LOOP;

   RETURN result_;
END Actual_Cost_Transactions_Exist;


@UncheckedAccess
FUNCTION Get_Shop_Ord_Mtrl_Value_Detail (
   source_ref1_  IN VARCHAR2,
   source_ref2_  IN VARCHAR2,
   source_ref3_  IN VARCHAR2,
   source_ref4_  IN VARCHAR2,
   part_no_      IN VARCHAR2 ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   cost_detail_tab_  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;   
   value_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;

   CURSOR get_transaction_id IS
      SELECT transaction_id, (quantity - qty_reversed) quantity
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1      = source_ref1_ 
        AND  source_ref2      = source_ref2_
        AND  source_ref3      = source_ref3_
        AND  source_ref4      = source_ref4_
        AND  source_ref_type  = 'SHOP ORDER'
        AND  transaction_code IN ('SOISS','BACFLUSH','CO-SOISS','CO-BACFLSH')
        AND  part_no          = part_no_;
BEGIN
   FOR transaction_rec_ IN  get_transaction_id LOOP
      cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(transaction_id_           => transaction_rec_.transaction_id,
                                                                                      include_added_details_    => TRUE,
                                                                                      include_normal_details_   => TRUE,
                                                                                      replace_star_cost_bucket_ => TRUE);
      value_detail_tab_ := Inventory_Part_Unit_Cost_API.Add_To_Value_Detail_Tab(value_detail_tab_,
                                                                                cost_detail_tab_,
                                                                                transaction_rec_.quantity);


   END LOOP;
   RETURN(value_detail_tab_);
END Get_Shop_Ord_Mtrl_Value_Detail;


@UncheckedAccess
FUNCTION Get_Shop_Ord_Receipt_Detail (
   source_ref1_  IN VARCHAR2,
   source_ref2_  IN VARCHAR2,
   source_ref3_  IN VARCHAR2,   
   part_no_      IN VARCHAR2 ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   cost_detail_tab_  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;   
   value_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   
   CURSOR get_transaction_id IS
      SELECT transaction_id, (quantity - qty_reversed) quantity
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1      = source_ref1_
        AND  source_ref2      = source_ref2_
        AND  source_ref3      = source_ref3_
        AND  source_ref_type  = 'SHOP ORDER'
        AND  transaction_code = 'OOREC'
        AND  part_no          = part_no_;
BEGIN
   FOR transaction_rec_ IN  get_transaction_id LOOP
      cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(transaction_id_           => transaction_rec_.transaction_id,
                                                                                      include_added_details_    => TRUE,
                                                                                      include_normal_details_   => TRUE,
                                                                                      replace_star_cost_bucket_ => TRUE);

      value_detail_tab_ := Inventory_Part_Unit_Cost_API.Add_To_Value_Detail_Tab(value_detail_tab_,
                                                                                cost_detail_tab_,
                                                                                transaction_rec_.quantity);
   END LOOP;
   RETURN(value_detail_tab_);
END Get_Shop_Ord_Receipt_Detail;

-- Get_Shop_Ord_Scrap_Detail
--    Calculates and returns the sum of all cost details for scrap and return to supplier transactions on a specified shop order
@UncheckedAccess
FUNCTION Get_Shop_Ord_Scrap_Detail (
   order_no_    IN VARCHAR2,
   release_no_  IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   cost_detail_tab_  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;   
   value_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   quantity_         NUMBER;

   CURSOR get_transaction_id IS
      SELECT transaction_id, transaction_code, quantity
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1      = order_no_
        AND  source_ref2      = release_no_
        AND  source_ref3      = sequence_no_
        AND  source_ref_type  = 'SHOP ORDER'
        AND  transaction_code IN ('OPFEED-SCP', 'UNOPFDSCP', 'OPFEED-RET', 'UNOPFD-RET')
        AND  reject_code IS NOT NULL;
BEGIN
   FOR transaction_rec_ IN  get_transaction_id LOOP
      cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(transaction_id_           => transaction_rec_.transaction_id,
                                                                                      include_added_details_    => TRUE,
                                                                                      include_normal_details_   => TRUE,
                                                                                      replace_star_cost_bucket_ => TRUE);
      IF (transaction_rec_.transaction_code IN ('OPFEED-SCP', 'OPFEED-RET')) THEN
         quantity_ := transaction_rec_.quantity;
      ELSE
         quantity_ := -1 * transaction_rec_.quantity;
      END IF;

      value_detail_tab_ := Inventory_Part_Unit_Cost_API.Add_To_Value_Detail_Tab(value_detail_tab_, cost_detail_tab_, quantity_);
   END LOOP;
   RETURN(value_detail_tab_);
END Get_Shop_Ord_Scrap_Detail;

-- Get_Shop_Ord_Variance_Detail
--    Calculates and returns the sum of all shop order variance cost details for a specified shop order
@UncheckedAccess
FUNCTION Get_Shop_Ord_Variance_Detail (
   order_no_    IN VARCHAR2,
   release_no_  IN VARCHAR2,
   sequence_no_ IN VARCHAR2 ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   cost_detail_tab_  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;   
   value_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   quantity_         NUMBER;

   CURSOR get_transaction_id IS
      SELECT transaction_id, transaction_code, quantity
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1      = order_no_
        AND  source_ref2      = release_no_
        AND  source_ref3      = sequence_no_
        AND  source_ref_type       = 'SHOP ORDER'
        AND  transaction_code IN ('SOMTRLV+', 'SOMTRLV-',
                                  'SOMTRLOHV+', 'SOMTRLOHV-',
                                  'SOLABV+', 'SOLABV-',
                                  'SOLABOHV+', 'SOLABOHV-',
                                  'SOMACHV+', 'SOMACHV-',
                                  'SOMACHOHV+', 'SOMACHOHV-',
                                  'SOSUBV+', 'SOSUBV-',
                                  'SOSUBOHV+', 'SOSUBOHV-',
                                  'SOGENOHV+', 'SOGENOHV-',
                                  'SODIFF+', 'SODIFF-',
                                  'SOASS+', 'SOASS-',
                                  'SODISS+', 'SODISS-',
                                  'SODISP+', 'SODISP-',
                                  'SOREP+', 'SOREP-')
        AND  original_transaction_id IS NULL
        AND  (quantity - qty_reversed) > 0;
BEGIN
   FOR transaction_rec_ IN  get_transaction_id LOOP
      cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(transaction_id_           => transaction_rec_.transaction_id,
                                                                                      include_added_details_    => TRUE,
                                                                                      include_normal_details_   => TRUE,
                                                                                      replace_star_cost_bucket_ => TRUE);
      IF (INSTR(transaction_rec_.transaction_code, '+' ) > 0) THEN
         quantity_ := transaction_rec_.quantity;
      ELSE
         quantity_ := -1 * transaction_rec_.quantity;
      END IF;

      value_detail_tab_ := Inventory_Part_Unit_Cost_API.Add_To_Value_Detail_Tab(value_detail_tab_, cost_detail_tab_, quantity_);
   END LOOP;
   RETURN(value_detail_tab_);
END Get_Shop_Ord_Variance_Detail;


PROCEDURE Enable_Abnormal_Demand (
   source_ref1_        IN VARCHAR2,
   source_ref2_        IN VARCHAR2,
   source_ref3_        IN VARCHAR2,
   source_ref4_        IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2 )
IS
BEGIN
   Modify_Abnormal_Demand___(source_ref1_,
                             source_ref2_,
                             source_ref3_,
                             source_ref4_,
                             source_ref_type_db_,
                             true_);
END Enable_Abnormal_Demand;


PROCEDURE Disable_Abnormal_Demand (
   source_ref1_        IN VARCHAR2,
   source_ref2_        IN VARCHAR2,
   source_ref3_        IN VARCHAR2,
   source_ref4_        IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2 )
IS
BEGIN
   Modify_Abnormal_Demand___(source_ref1_,
                             source_ref2_,
                             source_ref3_,
                             source_ref4_,
                             source_ref_type_db_,
                             false_);
END Disable_Abnormal_Demand;


PROCEDURE Issue_Mtrl_Shop_Order_Split (
   new_issue_transaction_id_ OUT NUMBER,
   old_issue_transaction_id_ IN  NUMBER,
   new_issue_order_no_       IN  VARCHAR2,
   new_issue_release_no_     IN  VARCHAR2,
   new_issue_sequence_no_    IN  VARCHAR2,
   new_issue_line_item_no_   IN  NUMBER )
IS
   old_issue_cancel_trans_id_ INVENTORY_TRANSACTION_HIST_TAB.transaction_id%TYPE;
   old_issue_transaction_     INVENTORY_TRANSACTION_HIST_TAB%ROWTYPE;
BEGIN

   old_issue_transaction_ := Get_Object_By_Keys___(old_issue_transaction_id_);

   IF (old_issue_transaction_.transaction_code NOT IN ('BACFLUSH'  , 'SOISS',
                                                       'CO-BACFLSH', 'CO-SOISS')) THEN
      Error_SYS.Record_General(lu_name_, 'NOTSOISS: Inventory transaction :P1 is not an issue of shop order material.', old_issue_transaction_id_);
   END IF;

   old_issue_cancel_trans_id_  := Get_Latest_Cancel_Trans_Id___(old_issue_transaction_id_);

   IF (old_issue_cancel_trans_id_ IS NULL) THEN
      Error_SYS.Record_General(lu_name_, 'NOSOUNISS: The material issued on inventory transaction :P1 is still issued to shop order :P2 and cannot be issued to shop order :P3', old_issue_transaction_id_, old_issue_transaction_.source_ref1, new_issue_order_no_);
   END IF;

   Set_Earlier_Date_Applied___(old_issue_cancel_trans_id_, old_issue_transaction_.date_applied);

   Reverse_Transaction___(transaction_id_               => new_issue_transaction_id_,
                          transaction_                  => old_issue_transaction_.transaction_code,
                          pos_diff_transaction_         => 'INVREVAL+',
                          neg_diff_transaction_         => 'INVREVAL-',
                          quantity_                     => NULL,
                          catch_quantity_               => NULL,
                          old_transaction_id_           => old_issue_cancel_trans_id_,
                          source_                       => old_issue_transaction_.source,
                          issue_mtrl_shop_order_split_  => TRUE,
                          new_issue_order_no_           => new_issue_order_no_,
                          new_issue_release_no_         => new_issue_release_no_,
                          new_issue_sequence_no_        => new_issue_sequence_no_,
                          new_issue_line_item_no_       => new_issue_line_item_no_);

   Set_Original_Transaction_Id(new_issue_transaction_id_, old_issue_cancel_trans_id_);

   Set_Earlier_Date_Applied___(new_issue_transaction_id_, old_issue_transaction_.date_applied);

END Issue_Mtrl_Shop_Order_Split;


@UncheckedAccess
FUNCTION Include_Event_In_Statistics (
   contract_                 IN VARCHAR2,
   part_no_                  IN VARCHAR2,
   configuration_id_         IN VARCHAR2,
   source_ref1_              IN VARCHAR2,
   source_ref2_              IN VARCHAR2,
   source_ref3_              IN VARCHAR2,
   source_ref4_              IN VARCHAR2,
   source_ref_type_db_       IN VARCHAR2,
   date_applied_             IN DATE,
   invent_stat_direction_db_ IN VARCHAR2,
   quantity_                 IN NUMBER,
   original_transaction_id_  IN NUMBER ) RETURN BOOLEAN
IS
   include_event_in_statistics_ BOOLEAN := TRUE;
   original_stat_direction_db_  VARCHAR2(50);
   original_date_applied_       DATE;
   original_event_quantity_     NUMBER := 0;
   reversed_event_quantity_     NUMBER := 0;
   sum_reverse_trans_quantity_  NUMBER;
   dummy_                       NUMBER;

   CURSOR check_exist IS
      SELECT 1
        FROM INVENTORY_TRANSACTION_HIST_TAB ith, mpccom_transaction_code_pub mtc
       WHERE  ith.transaction_code            = mtc.transaction_code
         AND  mtc.inventory_stat_direction_db = invent_stat_direction_db_
         AND  contract                        = contract_
         AND  part_no                         = part_no_
         AND  configuration_id                = configuration_id_
         AND  date_applied                    = date_applied_
         AND  partstat_flag                   = 'Y'
         AND  source_ref_type                 = source_ref_type_db_
         AND  source_ref1                     = source_ref1_
         AND (source_ref2                     = source_ref2_ OR source_ref2_ IS NULL)
         AND (source_ref3                     = source_ref3_ OR source_ref3_ IS NULL)
         AND (source_ref4                     = source_ref4_ OR source_ref4_ IS NULL);

   CURSOR get_orig_event_transactions IS
      SELECT transaction_id, quantity
        FROM INVENTORY_TRANSACTION_HIST_TAB ith, mpccom_transaction_code_pub mtc
       WHERE  ith.transaction_code            = mtc.transaction_code
         AND  mtc.inventory_stat_direction_db = original_stat_direction_db_
         AND  contract                        = contract_
         AND  part_no                         = part_no_
         AND  configuration_id                = configuration_id_
         AND  date_applied                    = original_date_applied_
         AND  source_ref_type                 = source_ref_type_db_
         AND  source_ref1                     = source_ref1_
         AND (source_ref2                     = source_ref2_ OR source_ref2_ IS NULL)
         AND (source_ref3                     = source_ref3_ OR source_ref3_ IS NULL)
         AND (source_ref4                     = source_ref4_ OR source_ref4_ IS NULL);

   CURSOR get_sum_reverse_trans_quantity (original_transaction_id_ IN NUMBER) IS
      SELECT NVL(SUM(quantity),0)
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE  original_transaction_id = original_transaction_id_
         AND  partstat_flag           = 'Y';
BEGIN

   IF ((invent_stat_direction_db_ IN ('REVERSED ISSUE', 'REVERSED RECEIPT')) AND 
       (original_transaction_id_ IS NOT NULL)) THEN
      -- This transaction is reversing an issue or a receipt
      IF (invent_stat_direction_db_ = 'REVERSED ISSUE') THEN
         original_stat_direction_db_ := 'ISSUE';
      ELSE
         original_stat_direction_db_ := 'RECEIPT';
      END IF;
      -- We need to find the date on which the original event was counted in mtd_issues or mtd_receipts.
      original_date_applied_ := Get_Date_Applied(original_transaction_id_);

      -- Find all original transactions that took place on the same date as the one cancelled
      -- By the current transaction that we are dealing with.
      FOR original_trans_rec_ IN get_orig_event_transactions  LOOP
         -- How much was original received or issued by the transactions that was counted as one unique issue or receipt
         -- during aggregation of statistics. They were seen as one single event since they have the same reference 
         -- and to place during the same day.
         original_event_quantity_ := original_event_quantity_ + original_trans_rec_.quantity;

         -- Take a look at all transacitons that has reversed the origininal receipt or issue that we
         -- are dealing with right now. One single receipt or issue might have been reversed in several steps
         -- so we need to look at all reverse transactions for each original transaction.
         OPEN  get_sum_reverse_trans_quantity (original_trans_rec_.transaction_id);
         FETCH get_sum_reverse_trans_quantity INTO sum_reverse_trans_quantity_;
         CLOSE get_sum_reverse_trans_quantity;

         -- All original transactions for one reference on one day is seen as one event. So in order to know
         -- if this event should be considered as completely reversed we need to summarize the quantity of 
         -- all reverse transactions for all original transactions that were seen as one original event.
         -- It's all about deciding whether we should reduce mtd_issues or mtd_receipts with 1 and thereby
         -- eliminate the effetc that the original event had on these columns.
         reversed_event_quantity_ := reversed_event_quantity_ + sum_reverse_trans_quantity_;
      END LOOP;

      reversed_event_quantity_ := reversed_event_quantity_ + quantity_;

      IF (original_event_quantity_ > reversed_event_quantity_) THEN
         -- The original event has not been completely reversed yet (by transactions included in the aggregation)
         -- so we should not reduce the mtd_issues or mtd_receipts because of this transaction. 
         include_event_in_statistics_ := FALSE;
      END IF;
   ELSE
      OPEN check_exist;
      FETCH check_exist INTO dummy_;
      IF (check_exist%FOUND) THEN
         include_event_in_statistics_ := FALSE;
      END IF;
      CLOSE check_exist;
   END IF;

   RETURN (include_event_in_statistics_);
END Include_Event_In_Statistics;


@UncheckedAccess
FUNCTION Source_Has_Posting_In_Status (
   source_ref1_        IN VARCHAR2,
   source_ref2_        IN VARCHAR2,
   source_ref3_        IN VARCHAR2,
   source_ref4_        IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2,
   status_             IN VARCHAR2 ) RETURN BOOLEAN
IS
   has_posting_in_status_ BOOLEAN := FALSE;

   CURSOR get_accounting_id IS
      SELECT accounting_id
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE  source_ref1  = source_ref1_
         AND (source_ref2  = source_ref2_ OR source_ref2_ IS NULL)
         AND (source_ref3  = source_ref3_ OR source_ref3_ IS NULL)
         AND (source_ref4  = source_ref4_ OR source_ref4_ IS NULL)
         AND  source_ref_type = source_ref_type_db_;
BEGIN
   FOR rec_ IN get_accounting_id LOOP
      has_posting_in_status_ := Mpccom_Accounting_API.Has_Posting_In_Status(rec_.accounting_id, status_);
      EXIT WHEN has_posting_in_status_;
   END LOOP;

   RETURN (has_posting_in_status_);

END Source_Has_Posting_In_Status;


-- Get_Pur_Receipt_Serial_Count
@UncheckedAccess
FUNCTION Get_Order_Receipt_Serial_Count (
   source_ref1_      IN VARCHAR2,
   source_ref2_      IN VARCHAR2,
   source_ref3_      IN VARCHAR2,
   source_ref4_      IN VARCHAR2,
   source_ref_type_  IN VARCHAR2 ) RETURN NUMBER
IS
   order_receipt_serial_count_ NUMBER;
BEGIN
   order_receipt_serial_count_ := Get_Order_Rec_Serial_Count___(source_ref1_,
                                                                source_ref2_,
                                                                source_ref3_,
                                                                source_ref4_,
                                                                source_ref_type_,
                                                                part_no_   => NULL,
                                                                serial_no_ => NULL);
   RETURN (order_receipt_serial_count_);
END Get_Order_Receipt_Serial_Count;


@UncheckedAccess
FUNCTION Get_Purchase_Receipt_Serials (
   source_ref1_ IN VARCHAR2,
   source_ref2_ IN VARCHAR2,
   source_ref3_ IN VARCHAR2,
   source_ref4_ IN VARCHAR2 ) RETURN Part_Serial_Catalog_API.Serial_No_Tab
IS
BEGIN
   RETURN (Get_Order_Receipt_Serials___(source_ref1_,
                                        source_ref2_,
                                        source_ref3_,
                                        source_ref4_,
                                        Order_Type_API.DB_PURCHASE_ORDER,
                                        part_no_   => NULL,
                                        serial_no_ => NULL));
END Get_Purchase_Receipt_Serials;


@UncheckedAccess
FUNCTION Serial_Is_On_Purchase_Receipt (
   part_no_     IN VARCHAR2,
   serial_no_   IN VARCHAR2,
   source_ref1_ IN VARCHAR2,
   source_ref2_ IN VARCHAR2,
   source_ref3_ IN VARCHAR2,
   source_ref4_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   pur_receipt_serial_count_ NUMBER;
BEGIN
   pur_receipt_serial_count_ := Get_Order_Rec_Serial_Count___(source_ref1_,
                                                              source_ref2_,
                                                              source_ref3_,
                                                              source_ref4_,
                                                              Order_Type_API.DB_PURCHASE_ORDER,
                                                              part_no_,
                                                              serial_no_);
   RETURN (pur_receipt_serial_count_ > 0);
END Serial_Is_On_Purchase_Receipt;


PROCEDURE Calculate_Cost_And_Progress (
   part_no_          IN VARCHAR2,
   contract_         IN VARCHAR2,
   activity_seq_     IN NUMBER,
   refresh_old_data_ IN VARCHAR2 DEFAULT 'FALSE' )
IS
BEGIN
   Refresh_Activity_Trans_Cost___(
                           part_no_          => part_no_,
                           contract_         => contract_,
                           activity_seq_     => activity_seq_,
                           refresh_old_data_ => refresh_old_data_);
END Calculate_Cost_And_Progress;


@UncheckedAccess
FUNCTION Get_Shop_Order_Lot_Batch_Tab(
   source_ref1_ IN VARCHAR2,
   source_ref2_ IN VARCHAR2,
   source_ref3_ IN VARCHAR2) RETURN Lot_Batch_Tab
IS
   shop_order_lot_batch_tab_ Lot_Batch_Tab;
   
   CURSOR get_shop_order_lot_batch_tab IS
      SELECT part_no, lot_batch_no, SUM(quantity - qty_reversed)
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE source_ref1      = source_ref1_
         AND source_ref2      = source_ref2_
         AND source_ref3      = source_ref3_
         AND transaction_code = 'OOREC'
         AND source_ref_type  = 'SHOP ORDER'
         AND lot_batch_no    != '*'
         AND quantity         > qty_reversed
    GROUP BY part_no, lot_batch_no;
BEGIN
   OPEN  get_shop_order_lot_batch_tab; 
   FETCH get_shop_order_lot_batch_tab BULK COLLECT INTO shop_order_lot_batch_tab_;
   CLOSE get_shop_order_lot_batch_tab;
   
   RETURN shop_order_lot_batch_tab_;
END Get_Shop_Order_Lot_Batch_Tab;


FUNCTION Get_Cust_Shipment_Transactions (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   condition_code_   IN VARCHAR2,
   rma_no_           IN VARCHAR2,
   rma_line_no_      IN NUMBER,
   transaction_code_ IN VARCHAR2 ) RETURN Transaction_Id_Tab
IS
   transaction_id_tab_           Transaction_Id_Tab;
   stmt_                         VARCHAR2(4000);
   source_ref1_                  INVENTORY_TRANSACTION_HIST_TAB.source_ref1%TYPE;
   source_ref2_                  INVENTORY_TRANSACTION_HIST_TAB.source_ref2%TYPE;
   source_ref3_                  INVENTORY_TRANSACTION_HIST_TAB.source_ref3%TYPE;
   source_ref4_                  INVENTORY_TRANSACTION_HIST_TAB.source_ref4%TYPE;
   inventory_part_cost_level_db_ INVENTORY_TRANSACTION_HIST_TAB.inventory_part_cost_level%TYPE;
   ignore_part_cost_level_       VARCHAR2(5) := false_;
   source_ref_type_                   INVENTORY_TRANSACTION_HIST_TAB.source_ref_type%TYPE;

   CURSOR get_source_ref_transactions IS
      SELECT transaction_id
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE source_ref_type           = source_ref_type_
      AND   source_ref1               = source_ref1_
      AND   source_ref2               = source_ref2_
      AND   source_ref3               = source_ref3_
      AND   NVL(source_ref4, 'DUMMY') = NVL(source_ref4_,NVL(source_ref4, 'DUMMY'))
      AND   contract                  = contract_
      AND   part_no                   = part_no_
      AND (inventory_part_cost_level_db_ = 'COST PER PART'
           OR (inventory_part_cost_level_db_ = 'COST PER CONFIGURATION' AND configuration_id = configuration_id_)
           OR (inventory_part_cost_level_db_ = 'COST PER SERIAL'        AND serial_no        = serial_no_ )
           OR (inventory_part_cost_level_db_ = 'COST PER LOT BATCH'     AND lot_batch_no     = lot_batch_no_)
           OR (inventory_part_cost_level_db_ = 'COST PER CONDITION'     AND condition_code   = condition_code_)
           OR ignore_part_cost_level_ = true_)
      ORDER BY transaction_id DESC;

BEGIN

   stmt_ := 'DECLARE
                rma_line_rec_  Return_Material_Line_API.Public_Rec;
                ord_line_rec_  Customer_Order_Line_API.Public_Rec;
             BEGIN
                rma_line_rec_ := Return_Material_Line_API.Get(:rma_no, :rma_line_no);
                ord_line_rec_ := Customer_Order_Line_API.Get(rma_line_rec_.order_no,
                                                             rma_line_rec_.line_no,
                                                             rma_line_rec_.rel_no,
                                                             rma_line_rec_.line_item_no);
                IF (ord_line_rec_.demand_code  = ''PO'') THEN
                   :order_no     := ord_line_rec_.demand_order_ref1;
                   :line_no      := ord_line_rec_.demand_order_ref2;
                   :rel_no       := ord_line_rec_.demand_order_ref3;
                   :line_item_no := ord_line_rec_.demand_order_ref4;
                   :source_ref_type  := ''PUR ORDER'';
                ELSE
                   :order_no     := rma_line_rec_.order_no;
                   :line_no      := rma_line_rec_.line_no;
                   :rel_no       := rma_line_rec_.rel_no;
                   :line_item_no := rma_line_rec_.line_item_no;
                   :source_ref_type  := ''CUST ORDER'';
                END IF;
             END;';
   @ApproveDynamicStatement(2008-09-08,MaEelk)
   EXECUTE IMMEDIATE stmt_
      USING IN  rma_no_,
            IN  rma_line_no_,
            OUT source_ref1_,
            OUT source_ref2_,
            OUT source_ref3_,
            OUT source_ref4_,
            OUT source_ref_type_;

   IF (source_ref1_ IS NOT NULL) THEN
      inventory_part_cost_level_db_ := Inventory_Part_API.Get_Invent_Part_Cost_Level_Db(contract_, part_no_);

      IF (transaction_code_ IN ('OERETURN', 'OERET-SCP', 'OERET-NI', 'OERETIN-NI', 'OERET-NC', 'OERET-SPNC', 'OERET-EX', 'OERET-SPEX')) THEN
         OPEN  get_source_ref_transactions;
         FETCH get_source_ref_transactions BULK COLLECT INTO transaction_id_tab_;
         CLOSE get_source_ref_transactions;
      END IF;

      IF ((transaction_id_tab_.COUNT = 0) AND (inventory_part_cost_level_db_ IN ('COST PER LOT BATCH',
                                                                                 'COST PER CONDITION'))) THEN
         ignore_part_cost_level_ := true_;
         OPEN  get_source_ref_transactions;
         FETCH get_source_ref_transactions BULK COLLECT INTO transaction_id_tab_;
         CLOSE get_source_ref_transactions;
      END IF;
   END IF;

   RETURN (transaction_id_tab_);
END Get_Cust_Shipment_Transactions;


PROCEDURE Get_Arrival_Info_For_Delivery (
   curr_amount_detail_tab_   OUT Mpccom_Accounting_API.Curr_Amount_Detail_Tab,
   cost_                     OUT NUMBER,
   value_                    OUT NUMBER,
   qty_                      OUT NUMBER,
   alt_source_ref1_          IN  VARCHAR2,
   alt_source_ref2_          IN  VARCHAR2,
   alt_source_ref3_          IN  VARCHAR2,
   alt_source_ref4_          IN  VARCHAR2,
   to_date_                  IN  DATE )
IS
   dummy_number_                  NUMBER;
BEGIN

   Get_Arrival_Cost_Value_Qty___(curr_amount_detail_tab_        => curr_amount_detail_tab_,
                                 cost_                          => cost_,
                                 value_                         => value_,
                                 qty_                           => qty_,
                                 price_diff_                    => dummy_number_,                                     
                                 source_ref1_                   => NULL,
                                 source_ref2_                   => NULL,
                                 source_ref3_                   => NULL,
                                 source_ref4_                   => NULL,
                                 alt_source_ref1_               => alt_source_ref1_,
                                 alt_source_ref2_               => alt_source_ref2_,
                                 alt_source_ref3_               => alt_source_ref3_,
                                 alt_source_ref4_               => alt_source_ref4_,
                                 to_date_                       => to_date_,
                                 include_reversed_transactions_ => TRUE,
                                 serial_no_                     => NULL,
                                 use_original_amounts_for_pwa_  => FALSE,
                                 fetch_curr_amount_details_     => TRUE,
                                 use_only_m10_postings_         => FALSE);
END Get_Arrival_Info_For_Delivery;


-- Get_Direct_Ship_Return_Qty
--   This method returns sum of qty returned for a given direct delivered po receipt information.
--   This method is used in DIRECT_DELIVERY_RETURNS view in Customer Order.
@UncheckedAccess
FUNCTION Get_Direct_Ship_Return_Qty (
   alt_source_ref1_        IN VARCHAR2,
   alt_source_ref2_        IN VARCHAR2,
   alt_source_ref3_        IN VARCHAR2,
   alt_source_ref4_        IN VARCHAR2,
   alt_source_ref_type_db_ IN VARCHAR2,
   part_no_                IN VARCHAR2,
   serial_no_              IN VARCHAR2 ) RETURN NUMBER
    
IS
   sum_qty_  NUMBER;

   CURSOR get_sum_qty IS
      SELECT SUM(quantity) quantity
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE alt_source_ref1 = alt_source_ref1_
      AND   alt_source_ref2 = alt_source_ref2_
      AND   alt_source_ref3 = alt_source_ref3_
      AND   alt_source_ref4 = alt_source_ref4_
      AND   alt_source_ref_type = alt_source_ref_type_db_
      AND   transaction_code IN ('RETPODIRSH', 'OERET-NI')
      AND   part_no = part_no_
      AND   serial_no = serial_no_;
BEGIN
   OPEN get_sum_qty;
   FETCH get_sum_qty INTO sum_qty_;
   CLOSE get_sum_qty;

   RETURN NVL(sum_qty_, 0);
END Get_Direct_Ship_Return_Qty;


-- Get_Rma_Multi_Site_Return_Qty
--   This method returns the sum qty return for the given alt source refs for rma return transactions. This is used in
--   ReturnMaterilaLine.apy when calculating the available qty to return.
@UncheckedAccess
FUNCTION Get_Rma_Multi_Site_Return_Qty (
   alt_source_ref1_        IN VARCHAR2,
   alt_source_ref2_        IN VARCHAR2,
   alt_source_ref3_        IN VARCHAR2,
   alt_source_ref4_        IN VARCHAR2,
   alt_source_ref_type_db_ IN VARCHAR2,
   serial_no_              IN VARCHAR2 DEFAULT NULL,
   waiv_dev_rej_no_        IN VARCHAR2 DEFAULT NULL,
   lot_batch_no_           IN VARCHAR2 DEFAULT NULL,
   handling_unit_id_       IN VARCHAR2 DEFAULT NULL ) RETURN NUMBER
IS
   sum_qty_returned_   NUMBER;

   CURSOR get_qty_returned IS
      SELECT SUM(quantity)
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  alt_source_ref1  = alt_source_ref1_
      AND    alt_source_ref2  = alt_source_ref2_
      AND    alt_source_ref3  = alt_source_ref3_
      AND    alt_source_ref4  = alt_source_ref4_
      AND    alt_source_ref_type = alt_source_ref_type_db_
      AND    (serial_no = serial_no_ OR serial_no_ IS NULL)
      AND    (lot_batch_no = lot_batch_no_ OR lot_batch_no_ IS NULL)
      AND    (waiv_dev_rej_no =  waiv_dev_rej_no_ OR waiv_dev_rej_no_ IS NULL)
      AND    (handling_unit_id =  handling_unit_id_ OR handling_unit_id_ IS NULL)
      AND    transaction_code IN ('RETINTPODS', 'RETPODIRNI', 'RETPODIRSH', 'OERET-NI', 'RETPODSINT');

BEGIN

   OPEN get_qty_returned;
   FETCH get_qty_returned INTO sum_qty_returned_;
   CLOSE get_qty_returned;

   RETURN NVL(sum_qty_returned_, 0);
   
END Get_Rma_Multi_Site_Return_Qty;

-- Get_Part_Ownership
--   Uses most of the key from project and customer reservations to determine the original part ownership (CLIENT value) from 
--   the inventory transaction history.
@UncheckedAccess
FUNCTION Get_Part_Ownership (
   order_ref1_          IN VARCHAR2,
   order_ref2_          IN NUMBER,
   order_ref3_          IN NUMBER,
   order_ref4_          IN NUMBER,
   contract_            IN VARCHAR2,
   part_no_             IN VARCHAR2,
   location_no_         IN VARCHAR2,
   lot_batch_no_        IN VARCHAR2,
   serial_no_           IN VARCHAR2,
   eng_chg_level_       IN NUMBER,
   waiv_dev_rej_no_     IN VARCHAR2,
   activity_seq_        IN NUMBER,
   configuration_id_    IN VARCHAR2 ) RETURN VARCHAR2
IS
   part_ownership_db_ VARCHAR2(30);
BEGIN
   part_ownership_db_ := Get_Part_Ownership_DB(order_ref1_,
                                               order_ref2_,
                                               order_ref3_,
                                               order_ref4_,
                                               contract_,
                                               part_no_,
                                               location_no_,
                                               lot_batch_no_,
                                               serial_no_,
                                               eng_chg_level_,
                                               waiv_dev_rej_no_,
                                               activity_seq_,
                                               configuration_id_);
   RETURN Part_Ownership_API.Decode(part_ownership_db_);
END Get_Part_Ownership;

-- Get_Part_Ownership_DB
--   Uses most of the key from project and customer reservations to determine the original part ownership (DATABASE value) from 
--   the inventory transaction history.
@UncheckedAccess
FUNCTION Get_Part_Ownership_DB (
   order_ref1_          IN VARCHAR2,
   order_ref2_          IN NUMBER,
   order_ref3_          IN NUMBER,
   order_ref4_          IN NUMBER,
   contract_            IN VARCHAR2,
   part_no_             IN VARCHAR2,
   location_no_         IN VARCHAR2,
   lot_batch_no_        IN VARCHAR2,
   serial_no_           IN VARCHAR2,
   eng_chg_level_       IN NUMBER,
   waiv_dev_rej_no_     IN VARCHAR2,
   activity_seq_        IN NUMBER,
   configuration_id_    IN VARCHAR2 ) RETURN VARCHAR2
IS
   part_ownership_db_ VARCHAR2(30);
   CURSOR get_ownership_from_history IS
      SELECT part_ownership
      FROM Inventory_Transaction_Hist_Tab
      WHERE source_ref1 = order_ref1_
      AND (source_ref2 = order_ref2_ OR source_ref2 IS NULL)
      AND source_ref3 = order_ref3_
      AND source_ref4 = order_ref4_
      AND contract = contract_
      AND part_no = part_no_
      AND location_no = location_no_
      AND lot_batch_no = lot_batch_no_
      AND serial_no = serial_no_
      AND eng_chg_level = eng_chg_level_
      AND waiv_dev_rej_no = waiv_dev_rej_no_
      AND activity_seq = activity_seq_
      AND configuration_id = configuration_id_;
BEGIN
   OPEN get_ownership_from_history;
   FETCH get_ownership_from_history INTO part_ownership_db_;
   CLOSE get_ownership_from_history;
   RETURN part_ownership_db_;
END Get_Part_Ownership_DB;

-- Get_Po_Arrival_Condition_Code
--   Returns the condition code of the part that has been entered when registering
--   the purchase order arrival
@UncheckedAccess
FUNCTION Get_Po_Arrival_Condition_Code (
   source_ref1_ IN VARCHAR2,
   source_ref2_ IN VARCHAR2,
   source_ref3_ IN VARCHAR2,
   source_ref4_ IN VARCHAR2) RETURN VARCHAR2
IS
   temp_ INVENTORY_TRANSACTION_HIST_TAB.condition_code%TYPE;

    CURSOR get_condition_code IS
      SELECT condition_code
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE source_ref1 = source_ref1_
         AND source_ref2 = source_ref2_
         AND source_ref3 = source_ref3_
         AND source_ref4 = source_ref4_
         AND source_ref_type  = 'PUR ORDER'
         AND transaction_code IN ('ARRIVAL', 'CO-ARRIVAL', 'ARRTRAN', 'ARR-COMP', 'PARTSWAP', 'SERLOTSWAP'); 
BEGIN
   OPEN get_condition_code;
   FETCH get_condition_code INTO temp_;
   CLOSE get_condition_code;
   RETURN temp_;
END Get_Po_Arrival_Condition_Code;


-- Get_Total_Source_Ref_Amount
--   Returns the total cost for the given sources
@UncheckedAccess
FUNCTION Get_Total_Source_Ref_Amount (
   source_ref1_        IN VARCHAR2,
   source_ref2_        IN VARCHAR2,
   source_ref3_        IN VARCHAR2,
   source_ref4_        IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2 ) RETURN NUMBER
IS
   total_source_ref_amount_ NUMBER := 0;

   CURSOR get_transactions IS
      SELECT transaction_id, DECODE(quantity, 0, 1, quantity) quantity
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE  source_ref1  = source_ref1_
         AND (source_ref2  = source_ref2_ OR source_ref2_ IS NULL)
         AND (source_ref3  = source_ref3_ OR source_ref3_ IS NULL)
         AND (source_ref4  = source_ref4_ OR source_ref4_ IS NULL)
         AND  source_ref_type   = source_ref_type_db_;
BEGIN
  FOR rec_ IN get_transactions LOOP
     total_source_ref_amount_ := total_source_ref_amount_ + (Get_Cost(rec_.transaction_id) * rec_.quantity);
  END LOOP;

  RETURN total_source_ref_amount_;
END Get_Total_Source_Ref_Amount;

@UncheckedAccess   
FUNCTION Get_Max_Date_Applied (
   source_ref1_        IN VARCHAR2,
   source_ref2_        IN VARCHAR2,
   source_ref3_        IN VARCHAR2,
   source_ref4_        IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2 ) RETURN DATE
IS
   max_date_applied_ DATE;

   CURSOR get_max_date_applied IS
      SELECT MAX(date_applied)
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE source_ref1   = source_ref1_
         AND source_ref2   = source_ref2_
         AND source_ref3   = source_ref3_
         AND (source_ref4  = source_ref4_ OR source_ref4_ IS NULL)
         AND source_ref_type   = source_ref_type_db_;
BEGIN
   OPEN  get_max_date_applied;
   FETCH get_max_date_applied INTO max_date_applied_;
   CLOSE get_max_date_applied;
   RETURN(max_date_applied_);
END Get_Max_Date_Applied;


@UncheckedAccess
FUNCTION Get_Avg_Charge_On_Receipt(
   source_ref1_       IN VARCHAR2,
   source_ref2_       IN VARCHAR2,
   source_ref3_       IN VARCHAR2,
   source_ref4_       IN VARCHAR2,
   alt_source_ref1_   IN VARCHAR2,
   alt_source_ref2_   IN VARCHAR2,
   alt_source_ref3_   IN VARCHAR2,
   alt_source_ref4_   IN VARCHAR2 ) RETURN NUMBER
IS
   value_                 NUMBER := 0;
   quantity_              NUMBER := 0;
   avg_charge_on_receipt_ NUMBER;
   found_                 BOOLEAN := FALSE;
 
   CURSOR get_purch_transactions IS
      SELECT accounting_id,
             quantity,
             transaction_code
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  source_ref1     = source_ref1_
        AND  source_ref2     = source_ref2_
        AND  source_ref3     = source_ref3_
        AND  source_ref4     = source_ref4_
        AND  source_ref_type = Order_Type_API.DB_PURCHASE_ORDER
        AND  part_ownership  <> Part_Ownership_API.DB_SUPPLIER_OWNED;

   CURSOR get_pur_dir_transactions IS
      SELECT accounting_id,
             quantity,
             transaction_code
      FROM   INVENTORY_TRANSACTION_HIST_TAB
      WHERE  alt_source_ref1     = alt_source_ref1_
        AND  alt_source_ref2     = alt_source_ref2_
        AND  alt_source_ref3     = alt_source_ref3_
        AND  alt_source_ref4     = alt_source_ref4_
        AND  alt_source_ref_type = Order_Type_API.DB_CUSTOMER_ORDER_DIRECT;

   TYPE Transaction_Tab_Type IS TABLE OF get_purch_transactions%ROWTYPE
      INDEX BY PLS_INTEGER;
   transaction_tab_          Transaction_Tab_Type;

BEGIN
   IF (source_ref1_ IS NOT NULL) THEN
      OPEN  get_purch_transactions;
      FETCH get_purch_transactions BULK COLLECT INTO transaction_tab_;
      CLOSE get_purch_transactions;
   ELSIF (alt_source_ref1_ IS NOT NULL) THEN
      OPEN  get_pur_dir_transactions;
      FETCH get_pur_dir_transactions BULK COLLECT INTO transaction_tab_;
      CLOSE get_pur_dir_transactions;
   END IF;

   IF (transaction_tab_.COUNT > 0 ) THEN
      FOR i IN transaction_tab_.FIRST..transaction_tab_.LAST LOOP
         IF (Purchase_Order_Receipt___(transaction_tab_(i).transaction_code) OR Direct_Ship_Customer_Order___(transaction_tab_(i).transaction_code)) THEN
            value_    := value_    + Mpccom_Accounting_API.Get_Sum_Value(transaction_tab_(i).accounting_id, 'M189');
            quantity_ := quantity_ + transaction_tab_(i).quantity;
            found_    := TRUE;
         END IF;
      END LOOP;
   END IF;

   IF (found_) THEN
      avg_charge_on_receipt_ := (value_ * -1) / quantity_;
   END IF;

   RETURN NVL(avg_charge_on_receipt_, 0);
END Get_Avg_Charge_On_Receipt;


@UncheckedAccess
FUNCTION Get_Consumed_Tot_Comp_Value(
   source_ref_1_ IN VARCHAR2,
   source_ref_2_ IN VARCHAR2,
   source_ref_3_ IN VARCHAR2 ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS
   consumed_total_comp_value_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;

   CURSOR get_consumed_total_comp_values IS
      SELECT accounting_year, itc.contract, cost_bucket_id, company, cost_source_id,
             SUM((quantity - qty_reversed) * CASE transaction_code
                                                WHEN 'POINV-WIP' THEN unit_cost
                                                ELSE unit_cost * -1 END) value
        FROM INVENTORY_TRANSACTION_HIST_TAB ith,
             inventory_transaction_cost_tab itc
       WHERE itc.transaction_id = ith.transaction_id
         AND source_ref1           = source_ref_1_
         AND source_ref2           = source_ref_2_
         AND source_ref3           = source_ref_3_
         AND source_ref_type       = 'PUR ORDER'
         AND transaction_code IN ('POINV-WIP','RETWOR-WIP')
         AND quantity - qty_reversed > 0
       GROUP BY accounting_year, itc.contract, cost_bucket_id, company, cost_source_id;
BEGIN

   OPEN  get_consumed_total_comp_values;
   FETCH get_consumed_total_comp_values BULK COLLECT INTO consumed_total_comp_value_tab_;
   CLOSE get_consumed_total_comp_values;

   RETURN (consumed_total_comp_value_tab_);
END Get_Consumed_Tot_Comp_Value;


-- Trans_Exist_For_Activity_Seq
--    Returns TRUE if a transaction exist for an activity sequence for the given source.
@UncheckedAccess   
FUNCTION Trans_Exist_For_Activity_Seq(
   source_ref1_        IN VARCHAR2, 
   source_ref2_        IN VARCHAR2,
   source_ref3_        IN VARCHAR2,
   source_ref4_        IN VARCHAR2,
   source_ref_type_db_ IN VARCHAR2,
   activity_seq_       IN NUMBER ) RETURN BOOLEAN
IS
   temp_        NUMBER;
   trans_exist_ BOOLEAN := FALSE;

   CURSOR invent_transaction_exist IS
      SELECT 1
         FROM INVENTORY_TRANSACTION_HIST_TAB
         WHERE source_ref1   = source_ref1_
           AND (source_ref2  = source_ref2_ OR source_ref2_ IS NULL)
           AND (source_ref3  = source_ref3_ OR source_ref3_ IS NULL)
           AND (source_ref4  = source_ref4_ OR source_ref4_ IS NULL)
           AND source_ref_type   = source_ref_type_db_
           AND activity_seq  = activity_seq_;
BEGIN   
   OPEN invent_transaction_exist;
   FETCH invent_transaction_exist INTO temp_;
   IF (invent_transaction_exist%FOUND) THEN
      trans_exist_ := TRUE;
   END IF;
   CLOSE invent_transaction_exist;
   
   RETURN (trans_exist_);
END Trans_Exist_For_Activity_Seq;            

PROCEDURE Refresh_Project_Connection (
   activity_info_tab_         IN OUT NOCOPY Public_Declarations_API.PROJ_Project_Conn_Cost_Tab,
   activity_revenue_info_tab_ IN OUT NOCOPY Public_Declarations_API.PROJ_Project_Conn_Revenue_Tab,
   attributes_                IN OUT NOCOPY Public_Declarations_API.PROJ_Project_Conn_Attr_Type,
   activity_seq_              IN     NUMBER,
   keyref1_                   IN     VARCHAR2,
   keyref2_                   IN     VARCHAR2,
   keyref3_                   IN     VARCHAR2,
   keyref4_                   IN     VARCHAR2,
   keyref5_                   IN     VARCHAR2,
   keyref6_                   IN     VARCHAR2,
   refresh_old_data_          IN     VARCHAR2 DEFAULT 'FALSE' )
IS
   part_no_                          VARCHAR2(25) := keyref1_;
   contract_                         VARCHAR2(5)  := keyref2_;
   empty_tab_                        Mpccom_Accounting_API.Project_Cost_Element_Tab;
   used_amount_tab_                  Mpccom_Accounting_API.Project_Cost_Element_Tab;
   earned_value_amount_tab_          Mpccom_Accounting_API.Project_Cost_Element_Tab;
   count_                            PLS_INTEGER;
   CURSOR get_project_cost_elements IS
      SELECT project_cost_element, 
             SUM(used_amount)      used_amount, 
             SUM(committed_amount) earned_value_cost 
      FROM   project_cost_element_tmp
      GROUP BY project_cost_element;
BEGIN
   used_amount_tab_         := Get_Activity_Transfer_Cost___ (part_no_                => part_no_,
                                                              contract_               => contract_,
                                                              activity_seq_           => activity_seq_,
                                                              report_earned_value_db_ => NULL  );

   earned_value_amount_tab_ := Get_Activity_Transfer_Cost___ (part_no_                => part_no_,
                                                              contract_               => contract_,
                                                              activity_seq_           => activity_seq_,
                                                              report_earned_value_db_ => 'TRUE' );

   Invent_Proj_Cost_Manager_API.Fill_Project_Cost_Element_Tmp (empty_tab_,
                                                               empty_tab_,
                                                               earned_value_amount_tab_,
                                                               used_amount_tab_);
   count_                                          := activity_info_tab_.COUNT;
   FOR rec_ IN get_project_cost_elements LOOP
      activity_info_tab_(count_).control_category  := rec_.project_cost_element;
      activity_info_tab_(count_).used              := rec_.used_amount;
      activity_info_tab_(count_).earned_value_cost := rec_.earned_value_cost;
      count_ := count_ + 1;
   END LOOP;
   attributes_.last_transaction_date               := SYSDATE;

   IF (refresh_old_data_ = 'FALSE') THEN
      $IF Component_Proj_SYS.INSTALLED $THEN
	      Project_Connection_Util_API.Refresh_Connection (proj_lu_name_              => 'PROJINVTRANS',
	                                                      activity_seq_              => activity_seq_,
	                                                      keyref1_                   => part_no_,
	                                                      keyref2_                   => contract_,
	                                                      keyref3_                   => '*',
	                                                      keyref4_                   => '*',
	                                                      keyref5_                   => '*',
	                                                      keyref6_                   => '*',
	                                                      object_description_        => lu_name_,
	                                                      activity_info_tab_         => activity_info_tab_,
	                                                      activity_revenue_info_tab_ => activity_revenue_info_tab_,
	                                                      attributes_                => attributes_);
      $ELSE
      	Error_SYS.Component_Not_Exist('PROJ');
      $END         
   END IF;
END Refresh_Project_Connection;


-- This method is used by DataCaptUnissueWo
@ServerOnlyAccess
PROCEDURE Create_Data_Capture_Lov (
   transaction_id_             IN NUMBER,
   contract_                   IN VARCHAR2,
   part_no_                    IN VARCHAR2,
   configuration_id_           IN VARCHAR2,
   location_no_                IN VARCHAR2,
   lot_batch_no_               IN VARCHAR2,
   serial_no_                  IN VARCHAR2,
   eng_chg_level_              IN VARCHAR2,
   waiv_dev_rej_no_            IN VARCHAR2,
   activity_seq_               IN NUMBER,
   handling_unit_id_           IN NUMBER,
   alt_handling_unit_label_id_ IN VARCHAR2,  -- send '%' if this item have not been entered/scanned yet
   condition_code_             IN VARCHAR2,  -- send '%' if this item have not been entered/scanned yet
   capture_session_id_         IN NUMBER,
   column_name_                IN VARCHAR2,
   lov_type_db_                IN VARCHAR2,
   sql_where_expression_       IN VARCHAR2 DEFAULT NULL )
IS
   -- NOTE: This method was created to handle unique calls from UnissueWO process, so thats the reason for the current limited parameters, 
   -- but it could easily be expanded with more parameters as long as they are NVL handled in the cursor and not mandatory.
   TYPE Get_Lov_Values       IS REF CURSOR;
   get_lov_values_           Get_Lov_Values;
   stmt_                     VARCHAR2(4000);
   TYPE Lov_Value_Tab        IS TABLE OF VARCHAR2(2000) INDEX BY PLS_INTEGER;
   lov_value_tab_            Lov_Value_Tab;
   session_rec_              Data_Capture_Common_Util_API.Session_Rec;
   second_column_name_       VARCHAR2(200);
   second_column_value_      VARCHAR2(200);
   lov_item_description_     VARCHAR2(200);
   lov_row_limitation_       NUMBER;
   exit_lov_                 BOOLEAN := FALSE;
BEGIN
   $IF Component_Wadaco_SYS.INSTALLED $THEN
      session_rec_ := Data_Capture_Session_API.Get_Session_Rec(capture_session_id_);    
      lov_row_limitation_ := Data_Capture_Config_API.Get_Lov_Row_Limitation(session_rec_.capture_process_id, session_rec_.capture_config_id);

      -- extra column check to be sure we have no risk for sql injection into column_name/data_item_id
      Assert_SYS.Assert_Is_Table_Column('INVENTORY_TRANSACTION_HIST3', column_name_);

      -- Note: Removed old select statements and replaced it with this new build up of the stmt_ where each where-statement is 
      -- added separately and avoiding NVL solution, to get better performance.                            
      stmt_ := ' FROM INVENTORY_TRANSACTION_HIST3
                 WHERE EXISTS (SELECT 1 FROM USER_ALLOWED_SITE_PUB WHERE site = contract) ';
      IF transaction_id_ IS NULL THEN                       
         stmt_ := stmt_ || ' AND :transaction_id_ IS NULL';
      ELSE
         stmt_ := stmt_ || ' AND transaction_id = :transaction_id_';
      END IF;
      IF contract_ IS NULL THEN                       
         stmt_ := stmt_ || ' AND :contract_ IS NULL';
      ELSE
         stmt_ := stmt_ || ' AND contract = :contract_';
      END IF;
      IF part_no_ IS NULL THEN                       
         stmt_ := stmt_ || ' AND :part_no_ IS NULL';
      ELSE
         stmt_ := stmt_ || ' AND part_no = :part_no_';
      END IF;
      IF configuration_id_ IS NULL THEN                       
         stmt_ := stmt_ || ' AND :configuration_id_ IS NULL';
      ELSE
         stmt_ := stmt_ || ' AND configuration_id = :configuration_id_';
      END IF;
      IF location_no_ IS NULL THEN                       
         stmt_ := stmt_ || ' AND :location_no_ IS NULL';
      ELSE
         stmt_ := stmt_ || ' AND location_no = :location_no_';
      END IF;
      IF lot_batch_no_ IS NULL THEN                       
         stmt_ := stmt_ || ' AND :lot_batch_no_ IS NULL';
      ELSE
         stmt_ := stmt_ || ' AND lot_batch_no = :lot_batch_no_';
      END IF;
      IF serial_no_ IS NULL THEN                       
         stmt_ := stmt_ || ' AND :serial_no_ IS NULL';
      ELSE
         stmt_ := stmt_ || ' AND serial_no = :serial_no_';
      END IF;
      IF eng_chg_level_ IS NULL THEN                       
         stmt_ := stmt_ || ' AND :eng_chg_level_ IS NULL';
      ELSE
         stmt_ := stmt_ || ' AND eng_chg_level = :eng_chg_level_';
      END IF;
      IF waiv_dev_rej_no_ IS NULL THEN                       
         stmt_ := stmt_ || ' AND :waiv_dev_rej_no_ IS NULL';
      ELSE
         stmt_ := stmt_ || ' AND waiv_dev_rej_no = :waiv_dev_rej_no_';
      END IF;
      IF activity_seq_ IS NULL THEN                       
         stmt_ := stmt_ || ' AND :activity_seq_ IS NULL';
      ELSE
         stmt_ := stmt_ || ' AND activity_seq = :activity_seq_';
      END IF;
      IF handling_unit_id_ IS NULL THEN                       
         stmt_ := stmt_ || ' AND :handling_unit_id_ IS NULL';
      ELSE
         stmt_ := stmt_ || ' AND handling_unit_id = :handling_unit_id_';
      END IF;
      IF alt_handling_unit_label_id_ IS NULL THEN                       
         stmt_ := stmt_ || ' AND alt_handling_unit_label_id is NULL AND :alt_handling_unit_label_id_ IS NULL';
      ELSIF alt_handling_unit_label_id_ = '%' THEN
         stmt_ := stmt_ || ' AND :alt_handling_unit_label_id_ =''%''';
      ELSE
         stmt_ := stmt_ || ' AND alt_handling_unit_label_id = :alt_handling_unit_label_id_';
      END IF;
      IF condition_code_ IS NULL THEN                       
         stmt_ := stmt_ || ' AND condition_code is NULL AND :condition_code_ IS NULL';
      ELSIF condition_code_ = '%' THEN
         stmt_ := stmt_ || ' AND :condition_code_ =''%''';
      ELSE
         stmt_ := stmt_ || ' AND condition_code = :condition_code_';
      END IF;

      IF (sql_where_expression_ IS NOT NULL) THEN
         stmt_ := stmt_ || sql_where_expression_;
      END IF;
      IF (lov_type_db_  = Data_Capture_Config_Lov_API.DB_AUTO_PICK) THEN
         -- Don't use DISTINCT select for AUTO PICK since only 1 value will be picked anyway
         stmt_ := 'SELECT ' || column_name_ || stmt_ || ' ORDER BY Utility_SYS.String_To_Number(' || column_name_ || '), ' || column_name_ || ' ASC';
      ELSE
         stmt_ := 'SELECT DISTINCT ' || column_name_ || stmt_ || ' ORDER BY Utility_SYS.String_To_Number(' || column_name_ || '), ' || column_name_ || ' ASC';
      END IF;

      @ApproveDynamicStatement(2015-04-16,DAZASE)
      OPEN get_lov_values_ FOR stmt_ USING transaction_id_,
                                           contract_,
                                           part_no_,
                                           configuration_id_,
                                           location_no_,
                                           lot_batch_no_,
                                           serial_no_,
                                           eng_chg_level_,
                                           waiv_dev_rej_no_,
                                           activity_seq_,
                                           handling_unit_id_,
                                           alt_handling_unit_label_id_,
                                           condition_code_;
      IF (lov_type_db_  = Data_Capture_Config_Lov_API.DB_AUTO_PICK) THEN
         -- Only 1 value for AUTO PICK
         FETCH get_lov_values_ INTO lov_value_tab_(1);
      ELSE
         FETCH get_lov_values_ BULK COLLECT INTO lov_value_tab_;
      END IF;
      CLOSE get_lov_values_;

      IF (lov_value_tab_.COUNT > 0) THEN
         CASE (column_name_)
            WHEN ('TRANSACTION_ID') THEN
               second_column_name_ := 'DATETIME_AND_TRANSACTION_QTY';
            ELSE
               NULL;
         END CASE;
         FOR i IN lov_value_tab_.FIRST..lov_value_tab_.LAST LOOP
            -- Don't fetch details for AUTO PICK
            IF (lov_type_db_ != Data_Capture_Config_Lov_API.DB_AUTO_PICK) THEN              
               IF (second_column_name_ IS NOT NULL) THEN
                  IF (second_column_name_ IN ('DATETIME_AND_TRANSACTION_QTY')) THEN
                     second_column_value_ := TO_CHAR(Get_Date_Time_Created(lov_value_tab_(i)),Client_SYS.date_format_) || ' | ' || Get_Quantity(lov_value_tab_(i));
                  END IF;
                  IF (second_column_value_ IS NOT NULL) THEN
                     lov_item_description_ := second_column_value_;
                  ELSE
                    lov_item_description_ := NULL;
                  END IF;
               END IF;
            END IF;
            Data_Capture_Session_Lov_API.New(exit_lov_              => exit_lov_,
                                             capture_session_id_    => capture_session_id_,
                                             lov_item_value_        => lov_value_tab_(i),
                                             lov_item_description_  => lov_item_description_,
                                             lov_row_limitation_    => lov_row_limitation_,    
                                             session_rec_           => session_rec_);
            EXIT WHEN exit_lov_;

         END LOOP;
      END IF;
   $ELSE
      NULL;
   $END
END Create_Data_Capture_Lov;


-- This method is used by DataCaptUnissueWo
@ServerOnlyAccess
FUNCTION Get_Column_Value_If_Unique (
   transaction_id_             IN NUMBER,
   contract_                   IN VARCHAR2,
   part_no_                    IN VARCHAR2,
   configuration_id_           IN VARCHAR2,
   location_no_                IN VARCHAR2,
   lot_batch_no_               IN VARCHAR2,
   serial_no_                  IN VARCHAR2,
   eng_chg_level_              IN VARCHAR2,
   waiv_dev_rej_no_            IN VARCHAR2,
   activity_seq_               IN NUMBER,
   handling_unit_id_           IN NUMBER,
   alt_handling_unit_label_id_ IN VARCHAR2,  -- send '%' if this item have not been entered/scanned yet
   condition_code_             IN VARCHAR2,  -- send '%' if this item have not been entered/scanned yet
   column_name_                IN VARCHAR2,
   sql_where_expression_       IN VARCHAR2 DEFAULT NULL ) RETURN VARCHAR2
IS
   -- NOTE: This method was created to handle unique calls from UnissueWO process, so thats the reason for the current limited parameters, 
   -- but it could easily be expanded with more parameters as long as they are NVL handled in the cursor and not mandatory.
   TYPE Get_Column_Value IS REF CURSOR;
   get_column_values_             Get_Column_Value;
   stmt_                          VARCHAR2(4000);
   unique_column_value_           VARCHAR2(50);
   TYPE Column_Value_Tab IS TABLE OF VARCHAR2(50) INDEX BY PLS_INTEGER;
   column_value_tab_              Column_Value_Tab; 
BEGIN
   -- extra column check to be sure we have no risk for sql injection into column_name/data_item_id
   Assert_SYS.Assert_Is_Table_Column('INVENTORY_TRANSACTION_HIST3', column_name_);

   -- Note: Removed old select statements and replaced it with this new build up of the stmt_ where each where-statement is 
   -- added separately and avoiding NVL solution, to get better performance.                            
   stmt_ := ' SELECT DISTINCT ' || column_name_ || '
              FROM INVENTORY_TRANSACTION_HIST3
              WHERE EXISTS (SELECT 1 FROM USER_ALLOWED_SITE_PUB WHERE site = contract) ';
   IF transaction_id_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :transaction_id_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND transaction_id = :transaction_id_';
   END IF;
   IF contract_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :contract_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND contract = :contract_';
   END IF;
   IF part_no_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :part_no_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND part_no = :part_no_';
   END IF;
   IF configuration_id_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :configuration_id_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND configuration_id = :configuration_id_';
   END IF;
   IF location_no_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :location_no_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND location_no = :location_no_';
   END IF;
   IF lot_batch_no_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :lot_batch_no_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND lot_batch_no = :lot_batch_no_';
   END IF;
   IF serial_no_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :serial_no_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND serial_no = :serial_no_';
   END IF;
   IF eng_chg_level_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :eng_chg_level_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND eng_chg_level = :eng_chg_level_';
   END IF;
   IF waiv_dev_rej_no_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :waiv_dev_rej_no_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND waiv_dev_rej_no = :waiv_dev_rej_no_';
   END IF;
   IF activity_seq_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :activity_seq_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND activity_seq = :activity_seq_';
   END IF;
   IF handling_unit_id_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :handling_unit_id_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND handling_unit_id = :handling_unit_id_';
   END IF;
   IF alt_handling_unit_label_id_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND alt_handling_unit_label_id is NULL AND :alt_handling_unit_label_id_ IS NULL';
   ELSIF alt_handling_unit_label_id_ = '%' THEN
      stmt_ := stmt_ || ' AND :alt_handling_unit_label_id_ =''%''';
   ELSE
      stmt_ := stmt_ || ' AND alt_handling_unit_label_id = :alt_handling_unit_label_id_';
   END IF;
   IF condition_code_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND condition_code is NULL AND :condition_code_ IS NULL';
   ELSIF condition_code_ = '%' THEN
      stmt_ := stmt_ || ' AND :condition_code_ =''%''';
   ELSE
      stmt_ := stmt_ || ' AND condition_code = :condition_code_';
   END IF;

   IF (sql_where_expression_ IS NOT NULL) THEN
      stmt_ := stmt_ || sql_where_expression_;
   END IF;

   stmt_ := stmt_ || ' FETCH FIRST 2 ROWS ONLY ';

   @ApproveDynamicStatement(2015-04-16,DAZASE)
   OPEN get_column_values_ FOR stmt_ USING transaction_id_,
                                           contract_,
                                           part_no_,
                                           configuration_id_,
                                           location_no_,
                                           lot_batch_no_,
                                           serial_no_,
                                           eng_chg_level_,
                                           waiv_dev_rej_no_,
                                           activity_seq_,
                                           handling_unit_id_,
                                           alt_handling_unit_label_id_,
                                           condition_code_;
                      
   -- Removed old loop solution and replaced it with collection solution and a count to increase performance                                 
   FETCH get_column_values_ BULK COLLECT INTO column_value_tab_;
   IF (column_value_tab_.COUNT = 1) THEN
      unique_column_value_ := NVL(column_value_tab_(1), 'NULL');      
   END IF;
   CLOSE get_column_values_;
   
   RETURN unique_column_value_;
END Get_Column_Value_If_Unique;


-- This method is used by DataCaptUnissueWo
@ServerOnlyAccess
PROCEDURE Record_With_Column_Value_Exist (
   transaction_id_             IN VARCHAR2,
   contract_                   IN VARCHAR2,
   part_no_                    IN VARCHAR2,
   configuration_id_           IN VARCHAR2,
   location_no_                IN VARCHAR2,
   lot_batch_no_               IN VARCHAR2,
   serial_no_                  IN VARCHAR2,
   eng_chg_level_              IN VARCHAR2,
   waiv_dev_rej_no_            IN VARCHAR2,
   activity_seq_               IN NUMBER,
   handling_unit_id_           IN NUMBER,
   alt_handling_unit_label_id_ IN VARCHAR2,  -- send '%' if this item have not been entered/scanned yet
   condition_code_             IN VARCHAR2,  -- send '%' if this item have not been entered/scanned yet
   column_name_                IN VARCHAR2,
   column_value_               IN VARCHAR2,
   column_description_         IN VARCHAR2,
   sql_where_expression_       IN VARCHAR2 DEFAULT NULL,
   column_value_nullable_      IN BOOLEAN  DEFAULT FALSE)
IS
   -- NOTE: This method was created to handle unique calls from UnissueWO process, so thats the reason for the current limited parameters, 
   -- but it could easily be expanded with more parameters as long as they are NVL handled in the cursor and not mandatory.
   TYPE Check_Exist IS REF CURSOR;
   exist_control_   Check_Exist;
   stmt_            VARCHAR2(2000);
   dummy_           NUMBER;
   exist_           BOOLEAN := FALSE;
BEGIN
   -- extra column check to be sure we have no risk for sql injection into column_name/data_item_id
   Assert_SYS.Assert_Is_Table_Column('INVENTORY_TRANSACTION_HIST3', column_name_);

   -- Note: Removed old select statements and replaced it with this new build up of the stmt_ where each where-statement is 
   -- added separately and avoiding NVL solution, to get better performance.                            
   stmt_ := ' SELECT 1
              FROM INVENTORY_TRANSACTION_HIST3
              WHERE EXISTS (SELECT 1 FROM USER_ALLOWED_SITE_PUB WHERE site = contract) ';
   IF transaction_id_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :transaction_id_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND transaction_id = :transaction_id_';
   END IF;
   IF contract_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :contract_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND contract = :contract_';
   END IF;
   IF part_no_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :part_no_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND part_no = :part_no_';
   END IF;
   IF configuration_id_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :configuration_id_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND configuration_id = :configuration_id_';
   END IF;
   IF location_no_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :location_no_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND location_no = :location_no_';
   END IF;
   IF lot_batch_no_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :lot_batch_no_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND lot_batch_no = :lot_batch_no_';
   END IF;
   IF serial_no_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :serial_no_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND serial_no = :serial_no_';
   END IF;
   IF eng_chg_level_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :eng_chg_level_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND eng_chg_level = :eng_chg_level_';
   END IF;
   IF waiv_dev_rej_no_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :waiv_dev_rej_no_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND waiv_dev_rej_no = :waiv_dev_rej_no_';
   END IF;
   IF activity_seq_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :activity_seq_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND activity_seq = :activity_seq_';
   END IF;
   IF handling_unit_id_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND :handling_unit_id_ IS NULL';
   ELSE
      stmt_ := stmt_ || ' AND handling_unit_id = :handling_unit_id_';
   END IF;
   IF alt_handling_unit_label_id_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND alt_handling_unit_label_id is NULL AND :alt_handling_unit_label_id_ IS NULL';
   ELSIF alt_handling_unit_label_id_ = '%' THEN
      stmt_ := stmt_ || ' AND :alt_handling_unit_label_id_ =''%''';
   ELSE
      stmt_ := stmt_ || ' AND alt_handling_unit_label_id = :alt_handling_unit_label_id_';
   END IF;
   IF condition_code_ IS NULL THEN                       
      stmt_ := stmt_ || ' AND condition_code is NULL AND :condition_code_ IS NULL';
   ELSIF condition_code_ = '%' THEN
      stmt_ := stmt_ || ' AND :condition_code_ =''%''';
   ELSE
      stmt_ := stmt_ || ' AND condition_code = :condition_code_';
   END IF;

   IF (sql_where_expression_  IS NOT NULL) THEN
      stmt_ := stmt_ || sql_where_expression_; 
   END IF;
   
   IF (column_value_nullable_) THEN
      stmt_ := stmt_ || ' AND ((' || column_name_ || ' = :column_value_) OR (' || column_name_ || ' IS NULL AND :column_value_ IS NULL)) ';
   ELSE -- NOT column_value_nullable_
      stmt_ := stmt_ || ' AND ' || column_name_ ||'  = :column_value_';
   END IF;
   
   IF (column_value_nullable_) THEN
      -- Column value check on a nullable column
      @ApproveDynamicStatement(2015-11-19,ERLISE) 
      OPEN exist_control_ FOR stmt_ USING transaction_id_,
                                          contract_,
                                          part_no_,
                                          configuration_id_,
                                          location_no_,
                                          lot_batch_no_,
                                          serial_no_,
                                          eng_chg_level_,
                                          waiv_dev_rej_no_,
                                          activity_seq_,
                                          handling_unit_id_,
                                          alt_handling_unit_label_id_,
                                          condition_code_,
                                          column_value_,
                                          column_value_;
   ELSE
      -- Column value check without any nullable handling
      @ApproveDynamicStatement(2014-11-03,CHJALK)
      OPEN exist_control_ FOR stmt_ USING transaction_id_,
                                          contract_,
                                          part_no_,
                                          configuration_id_,
                                          location_no_,
                                          lot_batch_no_,
                                          serial_no_,
                                          eng_chg_level_,
                                          waiv_dev_rej_no_,
                                          activity_seq_,
                                          handling_unit_id_,
                                          alt_handling_unit_label_id_,
                                          condition_code_,
                                          column_value_;
   END IF;

   FETCH exist_control_ INTO dummy_;
   IF (exist_control_%FOUND) THEN
      exist_ := TRUE;
   END IF;
   CLOSE exist_control_;
   IF (NOT exist_) THEN
      Error_SYS.Record_General(lu_name_, 'VALUENOTEXIST: :P1 :P2 does not exist in the context of the entered data and this process.', column_description_, column_value_);
   END IF;
END Record_With_Column_Value_Exist;


@UncheckedAccess
FUNCTION Get_Returned_Rental_Qty (
   order_no_      IN VARCHAR2,
   line_no_       IN VARCHAR2,
   rel_no_        IN VARCHAR2,
   line_item_no_  IN VARCHAR2,
   part_no_       IN VARCHAR2,
   serial_no_     IN VARCHAR2,
   lot_batch_no_  IN VARCHAR2,
   eng_chg_level_ IN NUMBER ) RETURN NUMBER
IS
   ret_quantity_   NUMBER;
   total_quantity_ NUMBER := 0;
   
   $IF Component_Order_SYS.INSTALLED $THEN
      CURSOR get_rma_detail IS
         SELECT rma_no, rma_line_no
            FROM return_material_line_tab
            WHERE order_no     = order_no_
            AND   line_no      = line_no_
            AND   rel_no       = rel_no_
            AND   line_item_no = line_item_no_;
   $END
   CURSOR get_returned_qty(rma_no_ NUMBER, rma_line_no_ NUMBER) IS
      SELECT SUM(quantity)
      FROM inventory_transaction_hist_tab
      WHERE source_ref1      = TO_CHAR(rma_no_)
 	   AND   source_ref4      = TO_CHAR(rma_line_no_)
      AND   serial_no        = serial_no_
      AND   lot_batch_no     = lot_batch_no_
      AND   eng_chg_level    = eng_chg_level_
      AND   transaction_code IN ('OERETURN','OERET-INT');
BEGIN
   $IF Component_Order_SYS.INSTALLED $THEN
      FOR rma_line_rec_ IN get_rma_detail LOOP
         OPEN get_returned_qty(rma_line_rec_.rma_no, rma_line_rec_.rma_line_no);
         FETCH get_returned_qty INTO ret_quantity_;
         CLOSE get_returned_qty;
         total_quantity_ := total_quantity_ + NVL(ret_quantity_,0);
      END LOOP;
   $END
   RETURN NVL(total_quantity_,0);
END Get_Returned_Rental_Qty;


@UncheckedAccess
FUNCTION Get_Sum_Qty_Scrapped_In_Invent (
   part_no_      IN VARCHAR2,
   activity_seq_ IN NUMBER,
   contract_     IN VARCHAR2) RETURN NUMBER
IS
   sum_qty_scrapped_in_invent_ NUMBER;
   CURSOR get_sum_qty_scrapped_in_invent IS
      SELECT SUM(quantity - qty_reversed)
        FROM inventory_transaction_hist_tab
       WHERE part_no = part_no_
         AND activity_seq = activity_seq_
         AND contract = contract_
         AND transaction_code IN ('INVSCRAP', 'CO-SCRAP');
BEGIN
   OPEN get_sum_qty_scrapped_in_invent;
   FETCH get_sum_qty_scrapped_in_invent INTO sum_qty_scrapped_in_invent_;
   CLOSE get_sum_qty_scrapped_in_invent;

   RETURN NVL(sum_qty_scrapped_in_invent_, 0);
END Get_Sum_Qty_Scrapped_In_Invent;

-- Get_Sum_Curr_Amount_Details
-- This method retuns Curr_Amount_Detail_Tab for the given source_ref details and str_code 
@UncheckedAccess
FUNCTION Get_Sum_Curr_Amount_Details (
   source_ref_type_db_ IN VARCHAR2,
   source_ref1_        IN VARCHAR2,
   source_ref2_        IN VARCHAR2,
   source_ref3_        IN VARCHAR2,
   source_ref4_        IN VARCHAR2,
   str_code_           IN VARCHAR2,
   to_date_            IN DATE ) RETURN Mpccom_Accounting_API.Curr_Amount_Detail_Tab
IS
   curr_amount_detail_tab_        Mpccom_Accounting_API.Curr_Amount_Detail_Tab;
   total_curr_amount_detail_tab_  Mpccom_Accounting_API.Curr_Amount_Detail_Tab;
   
   CURSOR get_acc IS
      SELECT accounting_id
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE source_ref1   = source_ref1_
         AND source_ref2   = source_ref2_
         AND source_ref3   = source_ref3_
         AND (source_ref4   = source_ref4_ OR source_ref4_ IS NULL)
         AND source_ref_type = source_ref_type_db_;
BEGIN  
   FOR trans_rec_ IN get_acc LOOP
      curr_amount_detail_tab_ := Mpccom_Accounting_API.Get_Curr_Amount_Details(accounting_id_ => trans_rec_.accounting_id,
                                                                               str_code_      => str_code_,
                                                                               to_date_       => to_date_);
                                                                               
      total_curr_amount_detail_tab_ := Mpccom_Accounting_API.Get_Merged_Curr_Amount_Tab(total_curr_amount_detail_tab_, curr_amount_detail_tab_);
      
      curr_amount_detail_tab_.DELETE;
   END LOOP;
   RETURN total_curr_amount_detail_tab_;
END Get_Sum_Curr_Amount_Details;


@UncheckedAccess
FUNCTION Get_Handling_Unit_Row_Count (
   handling_unit_id_  IN  NUMBER)  RETURN NUMBER
IS
   row_count_ NUMBER;
   CURSOR get_row_count IS
      SELECT count(*)
      FROM   inventory_transaction_hist_tab
      WHERE  handling_unit_id = handling_unit_id_;
BEGIN
   OPEN get_row_count;
   FETCH get_row_count INTO row_count_;
   CLOSE get_row_count;
   
   RETURN row_count_;
END Get_Handling_Unit_Row_Count;

@UncheckedAccess
FUNCTION Check_Lot_Batch_In_Use(
   part_no_       IN VARCHAR2,
   lot_batch_no_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   used_lot_ BOOLEAN := FALSE;
   dummy_    NUMBER;

   CURSOR check_usable_lot IS
      SELECT 1
      FROM  inventory_transaction_hist_tab t
      WHERE part_no = part_no_
      AND   lot_batch_no = lot_batch_no_
      AND   direction IN ('+', '-')
      AND   (quantity - qty_reversed) != 0;
BEGIN
   OPEN check_usable_lot;
   FETCH check_usable_lot INTO dummy_;
   IF ( check_usable_lot%FOUND ) THEN
      used_lot_ := TRUE;
   END IF;
   CLOSE check_usable_lot;
   RETURN used_lot_;
END Check_Lot_Batch_In_Use;


PROCEDURE Make_Po_Invoice_Balance_Trans (   
   order_no_                  IN VARCHAR2,
   line_no_                   IN VARCHAR2,
   release_no_                IN VARCHAR2,
   receipt_no_                IN NUMBER,
   order_type_db_             IN VARCHAR2,
   contract_                  IN VARCHAR2,
   part_no_                   IN VARCHAR2,
   company_                   IN VARCHAR2,
   purch_receipt_cost_        IN NUMBER,
   avg_inv_price_in_inv_curr_ IN NUMBER,
   unit_charge_               IN NUMBER,
   exchange_cost_             IN NUMBER,
   external_direct_delivery_  IN BOOLEAN,
   trans_reval_event_id_      IN NUMBER,
   invoice_curr_code_         IN VARCHAR2,
   unit_cost_in_receipt_curr_ IN NUMBER,
   receipt_curr_code_         IN VARCHAR2,
   positive_diff_trn_         IN VARCHAR2,
   negative_diff_trn_         IN VARCHAR2,
   to_date_                   IN DATE) 
IS
   transaction_amount_         NUMBER;
   value_                      NUMBER;
   received_qty_               NUMBER;
   transaction_code_           INVENTORY_TRANSACTION_HIST_TAB.transaction_code%TYPE;
   dummy_number_               NUMBER;   
   receipt_amount_             NUMBER;
   currency_rounding_          NUMBER;   
   curr_amount_detail_tab_     Mpccom_Accounting_API.Curr_Amount_Detail_Tab;     
   price_diff_                 NUMBER;
   curr_amount_                NUMBER;
   sum_amount_in_base_         NUMBER;
   sum_amount_in_curr_         NUMBER;
   inv_curr_rounding_          NUMBER;
   receipt_curr_amount_        NUMBER;
   transaction_curr_amount_    NUMBER;
   curr_transaction_code_      INVENTORY_TRANSACTION_HIST_TAB.transaction_code%TYPE;   
   str_code_                   VARCHAR2(10);
   invoiced_value_             NUMBER;
   include_price_diff_         VARCHAR2(5);
   consider_bal_round_pos_     VARCHAR2(5);
   transaction_qty_            NUMBER;
   base_curr_code_             VARCHAR2(3);
   post_curr_diff_             BOOLEAN := TRUE;
   consignment_trans_exist_    BOOLEAN := FALSE;
   exit_procedure_             EXCEPTION;
   local_receipt_curr_code_    VARCHAR2(3);
   
   CURSOR get_bal_invoic_acc_id IS
      SELECT accounting_id, transaction_code
        FROM INVENTORY_TRANSACTION_HIST_TAB
       WHERE ((source_ref1 = order_no_   AND
               source_ref2 = line_no_    AND
               source_ref3 = release_no_ AND
               source_ref4 = receipt_no_ AND
               source_ref_type = 'PUR ORDER') OR 
              (alt_source_ref1 = order_no_   AND
               alt_source_ref2 = line_no_    AND
               alt_source_ref3 = release_no_ AND
               alt_source_ref4 = receipt_no_ AND
               alt_source_ref_type = 'CUSTOMER ORDER DIRECT'))
         AND ((transaction_code IN ('BALINVOIC+', 'BALINVOIC-', 'RETWORK', 'RETCREDIT', 'RETCORWORK', 'RETCORCRE', 'SCPCREDIT', 'SCPCREDCOR',
                                    'POINV-WIP', 'RETCRE-WIP', 'RETWOR-WIP', 'UNRET-WIP')) OR
              (transaction_code IN ('BALINVROU+', 'BALINVROU-', 'COUNSUCONS', 'CO-RETURN', 'RETPODIRSH', 'RETPODSINT',
                                    'PRICEDIFF+', 'PRICEDIFF-') AND (consider_bal_round_pos_  = 'TRUE')));
BEGIN
   local_receipt_curr_code_ := receipt_curr_code_;
   -- Balance invoice rounding will not support 3rd currency scenarios.
   -- This condition will exit from procedure for 3rd currency scenarios for APP10 and onwards data.
   IF (local_receipt_curr_code_ != invoice_curr_code_) THEN
      RAISE exit_procedure_;
   END IF;
   base_curr_code_ := Company_Finance_API.Get_Currency_Code(company_);   
   
   IF (positive_diff_trn_ = 'BALINVOIC+' AND negative_diff_trn_ = 'BALINVOIC-') THEN
      consider_bal_round_pos_ := 'FALSE';
   ELSIF (positive_diff_trn_ = 'BALINVROU+' AND negative_diff_trn_ = 'BALINVROU-') THEN
      consider_bal_round_pos_ := 'TRUE';
   ELSE
      Error_SYS.Record_General(lu_name_,'INVALIDUSEERR: Implementation error. Invalid use of method Inventory_Transaction_Hist_API.Make_Po_Invoice_Balance_Trans. Contact System Support.');
   END IF;
   
   IF (external_direct_delivery_) THEN
      Get_Arrival_Info_For_Delivery(curr_amount_detail_tab_,
                                    dummy_number_,
                                    value_,
                                    received_qty_,
                                    order_no_,
                                    line_no_,
                                    release_no_,
                                    receipt_no_,
                                    NULL);
   ELSE
      -- Arrival transactions without M10 postings.
      Get_Val_Qty_Bal_Invoice_Rnd___(curr_amount_detail_tab_,
                                     value_,
                                     received_qty_,
                                     price_diff_,
                                     order_no_,
                                     line_no_,
                                     release_no_,
                                     receipt_no_,
                                     NULL);
   END IF;
   -- For release APP9 and earlier, data in ARRIVAL transaction will have M1 and M10 postings in accounting currency. So taking PO header currency 
   -- as receipt currency will not correctly identify 3rd currency scenario. It was required to get it from the transaction level to
   -- correctly exit from procedure for 3rd currency scenario.
   IF (curr_amount_detail_tab_.COUNT > 0 ) THEN
      IF (curr_amount_detail_tab_(1).currency_code != invoice_curr_code_) THEN
         RAISE exit_procedure_;
      ELSE         
         local_receipt_curr_code_ := curr_amount_detail_tab_(1).currency_code;
      END IF;
   END IF;
   
   curr_amount_ := ABS(Mpccom_Accounting_API.Get_Total_Curr_Amount(curr_amount_detail_tab_, invoice_curr_code_));
   
   FOR rec_ IN get_bal_invoic_acc_id LOOP      
      -- Get the effect of already created 'BALINVOIC+' and 'BALINVOIC-', 'BALINVROU+' and 'BALINVROU-' postings into value_.      
      IF (rec_.transaction_code IN ('BALINVOIC+', 'BALINVOIC-', 'POINV-WIP', 'RETCRE-WIP', 'RETWOR-WIP', 'UNRET-WIP', 'BALINVROU+', 'BALINVROU-', 'COUNSUCONS', 'CO-RETURN',
                                    'PRICEDIFF+', 'PRICEDIFF-')) THEN
         -- can not use sum_amount_in_base_ instead of Get_Sum_Value as sum_amount_in_base_ will return the sum for the given currency only
         str_code_ := 'M10';
         IF (rec_.transaction_code IN ( 'COUNSUCONS', 'CO-RETURN') )THEN
            consignment_trans_exist_ := TRUE;
         END IF;
      ELSE
         str_code_ := 'M14';
      END IF;   
      Mpccom_Accounting_API.Get_Sum_Amounts_Posted(sum_amount_in_base_,
                                                   sum_amount_in_curr_,
                                                   rec_.accounting_id, 
                                                   str_code_,
                                                   invoice_curr_code_,
                                                   Site_API.Get_Site_Date(contract_),
                                                   'FALSE');
                                                      
      value_ := value_ + (sum_amount_in_base_ * -1);
      curr_amount_ := curr_amount_ + (sum_amount_in_curr_ * -1);
      
   END LOOP;
   
   -- Get the effect of returns, scraps and their corrections into received_qty_
   received_qty_ := received_qty_ - Get_Rejected_Purch_Receipt_Qty(order_no_,
                                                                   line_no_, 
                                                                   release_no_, 
                                                                   receipt_no_,
                                                                   NULL);
                                                                   
   -- Get the effect of unissued consignment parts.
   IF (consignment_trans_exist_ )THEN
      received_qty_ := received_qty_ - Get_Returned_Suppl_Consignment(order_no_,
                                                                      line_no_, 
                                                                      release_no_, 
                                                                      receipt_no_);
   END IF;                                                                
      
   -- Add the charges occurred for the particular receipt to value_.
   value_ := value_ + (unit_charge_ * received_qty_);
--   curr_amount_ := curr_amount_ + (NVL(charge_value_in_inv_curr_, 0) * received_qty_);
   -- Add the exchange cost occured for the particular receipt to the value_.
   value_ := value_ + (exchange_cost_ * received_qty_);

   IF (consider_bal_round_pos_ = 'TRUE') THEN      
      IF (Inventory_Part_API.Get_Invoice_Consideration_Db(contract_, part_no_) = 'TRANSACTION BASED') THEN
         include_price_diff_ := 'TRUE';
      ELSE
         include_price_diff_ := 'FALSE';   
      END IF;     
      $IF Component_Purch_SYS.INSTALLED $THEN
         Purchase_Order_Invoice_API.Get_Receipt_Invoice_Value_Qty(dummy_number_,
                                                                  invoiced_value_,
                                                                  order_no_,
                                                                  line_no_,
                                                                  release_no_,
                                                                  receipt_no_,
                                                                  to_date_,
                                                                  include_price_diff_,
                                                                  'TRUE');
         transaction_amount_ := invoiced_value_ - value_;
         
         IF (base_curr_code_ = local_receipt_curr_code_) THEN
            IF (base_curr_code_ = invoice_curr_code_) THEN
               post_curr_diff_ := FALSE;
            END IF;
         END IF;
         
         IF (post_curr_diff_) THEN
            receipt_curr_amount_ := Purchase_Order_Invoice_API.Get_Invoiced_Total_Curr(order_no_,
                                                                                       line_no_,
                                                                                       release_no_,
                                                                                       receipt_no_,
                                                                                       company_,
                                                                                       NULL,
                                                                                       invoice_curr_code_,
                                                                                       include_price_diff_,
                                                                                       'TRUE');
            transaction_curr_amount_ := (receipt_curr_amount_ - curr_amount_);
         ELSE
            transaction_curr_amount_ := 0;
         END IF;
      $ELSE
         Error_SYS.Component_Not_Exist('PURCH');
      $END
   ELSE
      -- Rounded the purch receipt amount using the base currency rounding. This is done because purchasing has not done the rounding of receipt amount using base 
      -- currecy rounding. At first rounding was done to a higher precision (actual + 2) and then to the actual precision. This is done to achieve a more precise value.
      currency_rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, base_curr_code_);
      receipt_amount_ := ROUND(ROUND((received_qty_ * purch_receipt_cost_), currency_rounding_ + 2), currency_rounding_);   
      transaction_amount_ := receipt_amount_ - value_;
      inv_curr_rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, invoice_curr_code_);
      receipt_curr_amount_ := ROUND(ROUND((received_qty_ * avg_inv_price_in_inv_curr_), inv_curr_rounding_ + 2), inv_curr_rounding_);
      transaction_curr_amount_ := (receipt_curr_amount_ - curr_amount_);
   END IF;   
     
   IF (transaction_amount_ > 0) THEN
      transaction_code_ := positive_diff_trn_;
   ELSIF (transaction_amount_ < 0) THEN
      transaction_code_ := negative_diff_trn_;
   END IF;
   
   IF (transaction_curr_amount_ > 0) THEN
      curr_transaction_code_ := positive_diff_trn_;
   ELSIF (transaction_curr_amount_ < 0) THEN
      curr_transaction_code_ := negative_diff_trn_;
   END IF;
   
   transaction_qty_ := received_qty_;
   IF transaction_qty_ = 0 THEN
      transaction_qty_ := 1;
   END IF;
   
   IF (NVL(transaction_amount_, 0) != 0 OR NVL(transaction_curr_amount_, 0) != 0 ) THEN
      Make_Po_Line_Diff_Transaction (order_no_,
                                     line_no_, 
                                     release_no_,
                                     receipt_no_,
                                     order_type_db_,
                                     contract_,
                                     part_no_,
                                     company_,
                                     transaction_qty_,
                                     transaction_amount_/transaction_qty_,
                                     transaction_code_,
                                     trans_reval_event_id_,
                                     transaction_curr_amount_/transaction_qty_, 
                                     curr_transaction_code_,
                                     invoice_curr_code_,
                                     unit_cost_in_receipt_curr_,
                                     local_receipt_curr_code_);

   END IF;
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Make_Po_Invoice_Balance_Trans;

PROCEDURE Make_Po_Line_Diff_Transaction (
   order_no_                  IN VARCHAR2,
   line_no_                   IN VARCHAR2,
   release_no_                IN VARCHAR2,
   receipt_no_                IN NUMBER,
   order_type_db_             IN VARCHAR2,
   contract_                  IN VARCHAR2,
   part_no_                   IN VARCHAR2,
   company_                   IN VARCHAR2,
   qty_                       IN NUMBER,
   unit_cost_                 IN NUMBER,
   transaction_code_          IN VARCHAR2,
   trans_reval_event_id_      IN NUMBER,
   unit_cost_in_inv_curr_     IN NUMBER,   
   curr_transaction_code_     IN VARCHAR2,
   invoice_curr_code_         IN VARCHAR2,
   unit_cost_in_receipt_curr_ IN NUMBER,
   receipt_curr_code_         IN VARCHAR2 )

IS
   configuration_id_       INVENTORY_TRANSACTION_HIST_TAB.configuration_id%TYPE;
   transaction_amount_     NUMBER;
   currency_rounding_      NUMBER;
   dummy_number_           NUMBER;
   cost_detail_tab_        Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   exit_procedure_         EXCEPTION;
   trans_curr_amount_      NUMBER;
   inv_curr_rounding_      NUMBER;
   accounting_id_          NUMBER;
   empty_cost_detail_tab_  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   new_transaction_code_   VARCHAR2(10);
   new_cost_detail_tab_    Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
BEGIN
      
   transaction_amount_ := qty_ * unit_cost_;
   trans_curr_amount_ := qty_ * unit_cost_in_inv_curr_;
   
   IF (transaction_amount_ = 0 AND trans_curr_amount_ = 0) THEN
      RAISE exit_procedure_;
   END IF;
   
   currency_rounding_ := Currency_Code_API.Get_Currency_Rounding(company_ , Company_Finance_API.Get_Currency_Code(company_));
   inv_curr_rounding_ := Currency_Code_API.Get_Currency_Rounding(company_, invoice_curr_code_);                                                                 

   IF ((ROUND(ABS(transaction_amount_), currency_rounding_) = 0) AND (ROUND(ABS(trans_curr_amount_), inv_curr_rounding_) = 0)) THEN
      RAISE exit_procedure_;
   END IF;
   
   $IF Component_Purch_SYS.INSTALLED $THEN
      configuration_id_ := Purchase_Order_Line_Part_API.Get_Configuration_Id(order_no_, line_no_, release_no_);              
   $ELSE
      Error_SYS.Component_Not_Exist('PURCH');    
   $END

   cost_detail_tab_(1).accounting_year := '*';
   cost_detail_tab_(1).contract        := contract_;
   cost_detail_tab_(1).cost_bucket_id  := '*';
   cost_detail_tab_(1).company         := company_;
   cost_detail_tab_(1).cost_source_id  := '*';
   cost_detail_tab_(1).unit_cost       := ABS(unit_cost_);

   IF ((transaction_amount_ != 0) OR (transaction_amount_ = 0 AND transaction_code_ = curr_transaction_code_)) THEN
      new_transaction_code_ := transaction_code_;
      new_cost_detail_tab_ := cost_detail_tab_;
   ELSE 
      new_transaction_code_ := curr_transaction_code_;
      new_cost_detail_tab_ := empty_cost_detail_tab_;
   END IF;
   Create_And_Account(transaction_id_       => dummy_number_,
                      accounting_id_        => accounting_id_,
                      value_                => dummy_number_,
                      transaction_code_     => new_transaction_code_,
                      contract_             => contract_,
                      part_no_              => part_no_,
                      configuration_id_     => configuration_id_,
                      location_no_          => NULL,
                      lot_batch_no_         => NULL,
                      serial_no_            => NULL,
                      waiv_dev_rej_no_      => NULL,
                      eng_chg_level_        => NULL,
                      activity_seq_         => 0,
                      project_id_           => NULL,
                      source_ref1_          => order_no_,
                      source_ref2_          => line_no_,
                      source_ref3_          => release_no_,
                      source_ref4_          => receipt_no_,
                      source_ref5_          => NULL,
                      reject_code_          => NULL,
                      cost_detail_tab_      => new_cost_detail_tab_,
                      unit_cost_            => NULL,
                      quantity_             => qty_,
                      qty_reversed_         => 0,
                      catch_quantity_       => NULL,
                      source_               => NULL,
                      source_ref_type_      => Order_Type_API.Decode(order_type_db_),
                      owning_vendor_no_     => NULL,
                      condition_code_       => NULL,
                      location_group_       => NULL,
                      part_ownership_db_    => 'COMPANY OWNED',
                      owning_customer_no_   => NULL,
                      expiration_date_      => NULL,
                      trans_reval_event_id_ => trans_reval_event_id_,
                      value_adjustment_     => TRUE);
   
   IF (unit_cost_in_inv_curr_ IS NOT NULL AND unit_cost_in_inv_curr_ != 0) THEN
      Mpccom_Accounting_API.Do_Curr_Amt_Diff_Posting(company_,
                                                     accounting_id_,
                                                     contract_,
                                                     qty_,
                                                     trans_reval_event_id_,
                                                     unit_cost_in_receipt_curr_,
                                                     receipt_curr_code_,
                                                     invoice_curr_code_,
                                                     ABS(unit_cost_in_inv_curr_),
                                                     curr_transaction_code_);
   END IF;
                                           
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Make_Po_Line_Diff_Transaction;

PROCEDURE Get_Source_Ref_By_Acc_Id (
   source_ref1_            OUT VARCHAR2,
   source_ref2_            OUT VARCHAR2,
   source_ref3_            OUT VARCHAR2,
   source_ref4_            OUT VARCHAR2,
   source_ref5_            OUT VARCHAR2,
   source_ref_type_db_     OUT VARCHAR2,
   accounting_id_          IN  NUMBER )
   
IS
   rec_     Inventory_Transaction_Hist_Tab%ROWTYPE;
BEGIN
   rec_ := Get_Object_By_Accounting_Id___(accounting_id_);
   source_ref1_ := rec_.source_ref1;
   source_ref2_ := rec_.source_ref2;
   source_ref3_ := rec_.source_ref3;
   source_ref4_ := rec_.source_ref4;
   source_ref5_ := rec_.source_ref5;
   source_ref_type_db_  := rec_.source_ref_type;
END Get_Source_Ref_By_Acc_Id;

-- gelr:warehouse_journal, begin
PROCEDURE Modify_Delivery_Info (
   contract_           IN  VARCHAR2,
   source_ref1_        IN  VARCHAR2,
   source_ref2_        IN  VARCHAR2,
   source_ref3_        IN  VARCHAR2,
   source_ref4_        IN  VARCHAR2,
   source_ref5_        IN  VARCHAR2,
   source_ref_type_db_ IN  VARCHAR2,
   alt_del_note_no_    IN  VARCHAR2,
   delivery_reason_id_ IN  VARCHAR2,
   del_note_date_      IN  DATE )
IS
   CURSOR get_transactions IS
      SELECT transaction_id, transaction_code 
      FROM   inventory_transaction_hist_tab 
      WHERE  source_ref1              = source_ref1_
      AND    NVL(source_ref2,'DUMMY') = NVL(source_ref2_,NVL(source_ref2,'DUMMY'))
      AND    NVL(source_ref3,'DUMMY') = NVL(source_ref3_,NVL(source_ref3,'DUMMY'))
      AND    NVL(source_ref4,'DUMMY') = NVL(source_ref4_,NVL(source_ref4,'DUMMY'))
      AND    NVL(source_ref5,'DUMMY') = NVL(source_ref5_,NVL(source_ref5,'DUMMY'))
      AND    source_ref_type          = source_ref_type_db_;
BEGIN
   IF (source_ref1_ IS NOT NULL) THEN              
      FOR get_trans_ IN get_transactions LOOP 
         IF (get_trans_.transaction_code IN ('INVM-ISS','INVM-OUT','INVM-TRISS','PICK-OUT','PICK-IN','COMPM-OUT','OESHIP','OESHIPNI', 'SHIPDIR', 'SHIPTRAN'))THEN
            Modify_Delivery_Info___(get_trans_.transaction_id, alt_del_note_no_, delivery_reason_id_, del_note_date_);
         END IF;
      END LOOP;
   END IF; 
END Modify_Delivery_Info;

-- Dir_Del_Non_Serial_On_RMA___
--   This method checks whether the part returning from RMA is already direct delivered with serial_no = '*'
@UncheckedAccess
FUNCTION Dir_Del_Non_Serial_On_RMA___ (
   rma_no_        IN NUMBER,
   rma_line_no_   IN NUMBER,
   part_no_       IN VARCHAR2 ) RETURN BOOLEAN
IS
   non_serial_dir_delivered_  BOOLEAN := FALSE;
   $IF Component_Order_SYS.INSTALLED $THEN
      rma_line_rec_           Return_Material_Line_API.Public_Rec;
   $END
BEGIN
   $IF Component_Order_SYS.INSTALLED $THEN
      rma_line_rec_  := Return_Material_Line_API.Get(rma_no_, rma_line_no_);
      
      non_serial_dir_delivered_ := Inventory_Transaction_Hist_API.Serial_Processed_On_Order(rma_line_rec_.order_no,
                                                                                            rma_line_rec_.line_no,
                                                                                            rma_line_rec_.rel_no,
                                                                                            rma_line_rec_.line_item_no,
                                                                                            'CUST ORDER',
                                                                                            part_no_,
                                                                                            '*',
                                                                                            'PODIRSH');
   $END
   RETURN non_serial_dir_delivered_;
END Dir_Del_Non_Serial_On_RMA___;





PROCEDURE Modify_Delivery_Info (
   transaction_id_     IN NUMBER,
   alt_del_note_no_    IN VARCHAR2,   
   del_note_date_      IN DATE,
   delivery_reason_id_ IN VARCHAR2 DEFAULT NULL,
   remove_del_info_    IN BOOLEAN DEFAULT FALSE)
IS
BEGIN
   Modify_Delivery_Info___(transaction_id_, alt_del_note_no_, delivery_reason_id_, del_note_date_, remove_del_info_);
END Modify_Delivery_Info;
-- gelr:warehouse_journal, end   

@UncheckedAccess
FUNCTION Get_Sum_Qty_Part_Move_Tax_Id (
   part_move_tax_id_ IN NUMBER ) RETURN NUMBER
IS
   CURSOR get_sum_quantity IS
      SELECT SUM(quantity)
      FROM inventory_transaction_hist_tab
      WHERE part_move_tax_id = part_move_tax_id_;
      
   sum_quantity_    NUMBER;
BEGIN
   OPEN get_sum_quantity;
   FETCH get_sum_quantity INTO sum_quantity_;
   CLOSE get_sum_quantity;
   RETURN sum_quantity_;
END Get_Sum_Qty_Part_Move_Tax_Id;

---------------------------------------------------------------------------------------------
-- Set_Part_Move_Tax_Id
--    This method marks a transaction as being used for tax reporting. If one transaction is 
--    already used to tax reporting then an exception is raised.
---------------------------------------------------------------------------------------------
PROCEDURE Set_Part_Move_Tax_Id (
   transaction_id_tab_     IN Inventory_Transaction_Hist_API.Transaction_Id_Tab,
   part_move_tax_id_       IN NUMBER)
IS
   record_   inventory_transaction_hist_tab%ROWTYPE;
   -- We need to lock all the transactions sent in at once or no transaction at all.
   CURSOR lock_and_get_trans IS
      SELECT ith.*
      FROM  inventory_transaction_hist_tab ith                  
      WHERE ith.transaction_id IN (SELECT * FROM TABLE (transaction_id_tab_))
      FOR UPDATE;   
BEGIN
   IF (transaction_id_tab_.COUNT > 0) THEN
      FOR rec_ IN lock_and_get_trans LOOP         
         IF (rec_.part_move_tax_id IS NULL) THEN
            Error_SYS.Record_General(lu_name_, 'NOT_TAX_TRANSACTION: Transaction id :P1 is not supposed to be used for tax reporting.', rec_.transaction_id);
         ELSIF (rec_.part_move_tax_id = 0) THEN
            record_ := rec_;
            record_.part_move_tax_id := part_move_tax_id_; 
            Modify___(record_);
         ELSE
            Error_SYS.Record_General(lu_name_, 'ALREADY_TAX_REPORTED: Transaction id :P1 is already used for tax reporting.', rec_.transaction_id);
         END IF;   
      END LOOP;
   END IF;   
END Set_Part_Move_Tax_Id;

---------------------------------------------------------------------------------------
-- Get_Sum_Inventory_Cost
--    This method retrieves the total inventory cost for the collection of transactions  
---------------------------------------------------------------------------------------
@UncheckedAccess
FUNCTION Get_Sum_Inventory_Cost (
   transaction_id_tab_     Transaction_Id_Tab) RETURN NUMBER
IS
   total_inventory_cost_      NUMBER := 0;
BEGIN
   IF (transaction_id_tab_.COUNT > 0 ) THEN 
      FOR i IN transaction_id_tab_.FIRST..transaction_id_tab_.LAST LOOP
         total_inventory_cost_ := total_inventory_cost_ + (Get_Cost(transaction_id_tab_(i)) * Get_Quantity(transaction_id_tab_(i)));   
      END LOOP;
   END IF;
   RETURN total_inventory_cost_;
END Get_Sum_Inventory_Cost;


---------------------------------------------------------------------------------------
-- Get_Src_Ref_By_Part_Mov_Tax_Id
--   This method returns source ref keys, source type and transaction code for given part move tax id.
--   Although there can me multiple records with same part move tax id (ex. for Serials),
--   source references and the transaction code are the same.
---------------------------------------------------------------------------------------
@IgnoreUnitTest TrivialFunction
PROCEDURE Get_Src_Ref_By_Part_Mov_Tax_Id (
   source_ref1_            OUT VARCHAR2,
   source_ref2_            OUT VARCHAR2,
   source_ref3_            OUT VARCHAR2,
   source_ref4_            OUT VARCHAR2,
   source_ref5_            OUT VARCHAR2,
   source_ref_type_db_     OUT VARCHAR2,
   transaction_code_       OUT VARCHAR2,
   part_move_tax_id_       IN  NUMBER )   
IS 
   CURSOR get_src_refs IS
      SELECT source_ref1, source_ref2, source_ref3, source_ref4, source_ref5, source_ref_type, transaction_code
      FROM  inventory_transaction_hist_tab
      WHERE part_move_tax_id = part_move_tax_id_
      FETCH FIRST ROW ONLY;
BEGIN
   OPEN get_src_refs;
   FETCH get_src_refs INTO source_ref1_, source_ref2_, source_ref3_, source_ref4_, source_ref5_, source_ref_type_db_, transaction_code_;
   CLOSE get_src_refs;
END Get_Src_Ref_By_Part_Mov_Tax_Id;

FUNCTION Get_Earliest_Transaction_Id (
   source_ref1_         IN VARCHAR2,
   source_ref2_         IN VARCHAR2,
   source_ref3_         IN VARCHAR2,
   source_ref4_         IN VARCHAR2,
   source_ref5_         IN VARCHAR2,
   source_ref_type_db_  IN VARCHAR2,
   transaction_code_    IN VARCHAR2 ) RETURN NUMBER
IS
   earliest_transaction_id_   INVENTORY_TRANSACTION_HIST_TAB.location_no%TYPE;
   
   CURSOR get_transaction_id IS
      SELECT MIN(transaction_id)
      FROM INVENTORY_TRANSACTION_HIST_TAB
      WHERE source_ref1    = source_ref1_
      AND source_ref2      = source_ref2_
      AND source_ref3      = source_ref3_
      AND source_ref4      = source_ref4_
      AND source_ref5      = source_ref5_
      AND source_ref_type  = source_ref_type_db_
      AND transaction_code = transaction_code_;
BEGIN
   OPEN get_transaction_id;
   FETCH get_transaction_id INTO earliest_transaction_id_;
   CLOSE get_transaction_id;
   RETURN earliest_transaction_id_;
END Get_Earliest_Transaction_Id;

@UncheckedAccess
FUNCTION Get_Weighted_Average_Part_Cost (
   source_ref_type_db_  IN VARCHAR2,
   source_ref1_         IN VARCHAR2,
   source_ref2_         IN VARCHAR2,
   source_ref3_         IN VARCHAR2,
   source_ref4_         IN VARCHAR2,
   source_ref5_         IN VARCHAR2,
   transaction_code_    IN VARCHAR2,
   contract_            IN VARCHAR2,
   part_no_             IN VARCHAR2 ) RETURN NUMBER
IS
   total_amount_          NUMBER := 0;
   sum_qty_               NUMBER := 0;
   part_cost_             NUMBER;
   
   CURSOR get_transaction_info IS
      SELECT transaction_id, (quantity - qty_reversed) quantity
      FROM inventory_transaction_hist_tab
      WHERE source_ref_type = source_ref_type_db_
      AND source_ref1 = source_ref1_
      AND transaction_code = transaction_code_
      AND (source_ref2 = source_ref2_ OR source_ref2_ IS NULL)
      AND (source_ref3 = source_ref3_ OR source_ref3_ IS NULL)
      AND (source_ref4 = source_ref4_ OR source_ref4_ IS NULL)
      AND (source_ref5 = source_ref5_ OR source_ref5_ IS NULL)
      AND (quantity - qty_reversed) > 0
      AND contract = contract_
      AND part_no = part_no_;

BEGIN
   FOR rec_ IN get_transaction_info LOOP
      total_amount_ := total_amount_ + (Get_Cost(rec_.transaction_id) * rec_.quantity); 
      sum_qty_      := sum_qty_ + rec_.quantity;
   END LOOP;
   part_cost_ :=  total_amount_ / sum_qty_;   
   RETURN part_cost_;
END Get_Weighted_Average_Part_Cost;
