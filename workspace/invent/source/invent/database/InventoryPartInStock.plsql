-----------------------------------------------------------------------------
--
--  Logical unit: InventoryPartInStock
--  Component:    INVENT
--
--  IFS Developer Studio Template Version 3.0
--
--  Date    Sign    History
--  ------  ------  ---------------------------------------------------------
--  220126  JaThlk  SC21R2-2932, Added Public_Tab and modified Get_Other_Stock_Loc_Onhand, Count_Part and Validate_Count_Part 
--  220126          to update important attributes from existing serial location.
--  220125  RasDlk  SC21R2-3145, Modified Undo_Move_To_Order_Transit___ to support Undo Shipment Delivery in an Intra-Site scenario.
--  220119  RasDlk  SC21R2-3145, Modified Unissue_Part, Undo_Move_To_Order_Transit___ and Revalue_Int_Order_Transit___ to support
--  220119          the reversal process of INTORDTR when performing Undo Shipment Delivery in an Inter-Site scenario.
--  220113  JaThlk  SC21R2-2932, Added Get_Other_Stock_Loc_Onhand___ and modified Create_Empty_Stock_Record, Validate_Count_Part and Count_Part methods
--  220113          to allow adding serial records and confirming them in Counting Report Lines.
--  220111  AsZelk  SC21R2-6630, Modified Receive_Part_Impl___ to support Undo Purchase Receipt Return for Purchase Order source.
--  211230  RasDlk  SC21R2-3145, Modified Receive_Part_Impl___ to support Undo Shipment Delivery for sources other than Customer Order.
--  211221  ErRalk  SC21R2-2980, Modified Issue_Part to pass return reason as reject_code for the delivery of supplier return.
--  211220  PamPlk  SC21R2-2979, Added the parameter shipment_id_ to the medthods Move_Part_Shipment, Move_Part, Move_Part_Impl___.
--  211217  AsZelk  SC21R2-6630, Modified Check_Valid_Move_Combinations() to support move from Shipment location to an Arrival or QA locations only when Order Type is Purchase Receipt Return.
--  211217  JaThlk  SC21R2-2932, Modified Create_Empty_Stock_Record method to make it public and modified method signature to support additional parameters.
--  211211  JaThlk  SC21R2-2932, Modified Create_Count_Report_Lines___ to add route order information when creating count report lines.
--  211129  PamPlk  SC21R2-2979, Modified methods Move_Part_Impl___, Move_Part_Shipment and Check_Valid_Move_Combinations to validate move from/move to an Arrival or QA locations.
--  211123  RoJalk  SC21R2-6015, Modified Receive_Part_On_Order___ and assigned * for owning_vendor_no_ in Inventory_Part_In_Transit_API.Remove_From_Order_Transit for PO.
--  211112  RoJalk  SC21R2-3085, Added owning_customer_no, owning_vendor_no_ parameters to the method Receive_Part_On_Shipment_Order.
--  211112          Modified Receive_Part_On_Order___ to handle external ownerships in transit for Shipment Order.
--  211110  WaSalk  SC21R2-5189 Modified Move_Part() to call Change_Waiv_Dev_Rej_No() to generate WDR-In and WDR-OUT transactions if source and destination Waiv_Dev_Rej_Nos different.
--  211102  JaThlk  SC21R2-2927, Modified Create_Count_Report to support creating count reports per warehouse for group of warehouses when it is required
--  211102          by the user and modified Create_Count_Report___ to clear the COUNTING_REPORT_LINE_TMP once the count report lines are inserted.
--  211027  RoJalk  SC21R2-3082, Modified Issue_Part and included ownership info to Inventory_Part_In_Transit_API.Move_Into_Order_Transit call to support external ownerships for Shipment Order.
--  211014  PamPlk  SC21R2-901, Modified Check_Quantity_Reserved___ in order to raise an error on over reservation.
--  211011  AsZelk  SC21R2-5017, Modified Reserve_Part() to allow Reserve Part for Arrival and QA locations when source ref type is Purchase Receipt Return.
--  211008  RoJalk  SC21R2-688, Modified Receive_Part_On_Order___ to handle activity_seq_ for project connected Shipment Order.
--  210922  RoJalk  SC21R2-688, Modified Issue_Part to pass the parameter activity_seq_ to Inventory_Part_In_Transit_API.Move_Into_Order_Transit.
--  210806  SBalLK  Bug 160413(SCZ-15810), Modified Get_Company_Owned_Inventory() method by adding get_qty_in_details flat cursor when all the parameter has values.
--  210629  SBalLK  SC21R2-1426, Modified Check_Delete___() method to remove part in stock records when there is no pending task or stock available.
--  210629  TKAVLK  FI21R2-2112, Added new default parameters, move_dest_contract_ and move_dest_location_no_ into Issue_Part_Impl___() and assign values in Move_Part_Impl___().
--  210614  Wasalk  SC21R2-1214, Added method call User_Warehouse_Access_API.Find_User_Access_Warehouses() and Clear_Warehouse_Id_Tmp___ to Find_And_Issue_Part_Neg().
--  210607  WaSalk  SC21R2-1236, Added Warehouse_Id_Tab index, Fill_Warehouse_Id_Tmp() and Clear_Warehouse_Id_Tmp___. Modified Reserve_Part() and Reserve_For_Transport()
--  210607          by adding a call to User_Warehouse_Access_API.Check_Stock_Reserv_Allowed() and Clear_Warehouse_Id_Tmp(). Modified Find_And_Reserve_Or_Issue___() by 
--  210607          adding User_Warehouse_Access_API.Find_User_Access_Warehouses() and Find_Part___() with get_warehouse_tmp cursor to support gelr functionalities.   
--  210528  JaThlk  Bug 159408 (SCZ-14937), Modified Remove_Empty_Tracked_Record___ not to delete records if there are unconfirmed count report lines.
--  210310  BudKlk  SCZ-14045, Modified the method Handle_Serial_Condition_Change() by removing the condition to save the NULL values for new_avail_control_id_. 
--  210312  BudKlk  SC21R2-535, Modified the method Count_Part___() to assign location_type NULL for new records to avoid validation error.
--  210118  GRGALK  SC2020R1-12044, modified the error message when the target pool quantity is higher than the selected quantity in Validate_Rotable_Part_Pool___.
--  210114  LEPESE  SC2020R1-12096, correction in Reserve_For_Transport to assign oldrec_ to newrec_.
--  201222  LEPESE  SC2020R1-11853, replaced Client_SYS.Add_To_Attr by assigning values directly to newrec_ throughout the file. Created Check_And_Insert_By_Keys___.
--  201012  LEPESE  Bug 154198 (SCZ-10154), Modified Move_Part_Impl___(), Moved to_quantity_ calculation and Check_Storage_Requirements before calling Issue_Part_Impl___() for packed stock, 
--  201012          and changed the existing Check_Storage_Requirements call only for unpacked stock. Moved setting calling_process_ value for Transport Tasks to top.
--  200930  LEPESE  SC2020R1-10118, reverted correction done for LIM-10156 in method Check_Ownership___.
--  200921  LEPESE  SC2021R1-291, added Order_Type_API.DB_WORK_TASK to Check_Valid_Move_Combinations.
--  200917  LEPESE  SC2021R1-291, added transaction code CO-WTUNISS to method Undo_Consignment_Consum___.
--  200824  RoJalk  SC2020R1-9252, Added the new key parameters(ownership/project/delivery info) to Inventory_Part_In_Transit_API.Remove_From_Order_Transit/Move_Into_Order_Transit method calls.
--  200724  UdGnlk  Bug 154890 (SCZ-10818), Modified Move_Part_With_Transport_Task() to pass the correct value of Order Type which synchronize with Logistics Source Ref Type.
--  200721  WaSalk  Bug 154878 (SCZ-10804), Modified Count_Part___() to not to fetch default Expiration Date when counted quantity equals to 0.
--  200720  UtSwlk  Bug 154877(MFZ-4987), Corrected process id to MANUAL_ISSUE_SHOP_ORDER_PART in if condition in Create_Data_Capture_Lov().
--  200707  UdGnlk  Bug 154704 (SCZ-10449) Modified Count_Part___() to skip Mandatory Expiration Date error message when COUNT-IN with zero quantity for the serialized parts. It will get the latest transactions expiration date.
--  200529  RoJalk  SC2020R1-1231, Modified Move_Part_Impl___ and reverted the correction to not force serial identification when Shipment Order is intra-site.
--  200416  ErRalk  SC2020R1-2094, Modified Receive_Part_On_Order___ in order to assign ReceiptNo to the next available OrderRef value in the Inventory Transaction History Tab.
--  200414  AsZelk  SC2020R1-6602, Renamed Int_Order_Transit_Receipt___ into Intersite_Intracomp_Order___.
--  200311  ErRalk  SCSPRING20-1287, Modified Check_Valid_Move_Combinations by removing 'Order_Type_API.DB_SHIPMENT_ORDER' check to enable inbound shipment order to move into Arrival,Picking,Floor Stock and Production Line.
--  200311  DaZase  SCXTEND-3803, Changes in Create_Data_Capture_Lov, changed some of Bug 151218 implementation so we use session_rec_ instead of config_data_item_rec_. 
--  200303  Kagalk  GESPRING20-1797, Added del_reason_id_, del_note_no_, del_note_date_ to Receive_Customer_Order_Return, Receive_Part methods.
--  200228  SBalLK  Bug 152442(SCZ-8622), Added Get_All_Part_Stock_In_Loc___(), Get_All_Part_Stock_In_Hu___(), Part_Stock_Already_Counted___() and
--  200228          Merge_Collections_To_First___() methods. Added Keys_Rec and Keys_Tab types to system to hold collection of inventory part in stock keys.
--  200228          Modified Create_Count_Report___() method to improve the performance on creating count report.
--  200202  KHVESE  SCSPRING20-1749, Modified methods Move_Part_Impl___ to validate move from an Arrival or QA into a stock location for intersite shipment order Receipt process
--  200219  Kagalk  GESPRING20-1795, Modified Receive_Part_Impl___, Receive_Part_On_Order___, Receive_Part_On_Purchase_Order.
--  200218  PamPlk  Bug 152171(SCZ-8946), Modified the method Count_Part___(), in order to retrieve the expiration date from the lot batch master, when 'Mandatory expiration date' is False.
--  200217  KHVESE  SCSPRING20-674, Modified methods Issue_Part_Impl___, Receive_Part_Impl___,  Receive_Part and Check_Valid_Move_Combinations to validate location type for shipment order.
--  200217          SCSPRING20-674, Modified method Int_Order_Transit_Receipt___ and Change_Source_Handl_Unit_Id___ to support shipment order.
--  200217          SCSPRING20-674, replaced method Purchase_Order_Receipt___ with Receive_Part_On_Order___ and made it generic. Added methods Receive_Part_On_Order__, Receive_Part_On_Purchase_Order and Receive_Part_On_Shipment_Order. 
--  200217  WaSalk  GESPRING20-1794, Added Delivery reason to Receive_Part_With_Posting (), Rece_Part_With_Posting_Clob () and Receive_Part_Impl___ ().
--  200211  WaSalk  GESPRING20-1793, Added Delivery Reason parameter to Issue_Part_Impl___(),Issue_Part_With_Posting and Issue_Part_With_Posting___().
--  200211  RoJalk  SCSPRING20-1674, Modified Check_Valid_Move_Combinations and called Raise_Move_To_Location_Error for Order_Type_API.DB_SHIPMENT_ORDER.
--  200206  PamPlk  Bug 152109(SCZ-8448), Modified the method Count_Part___(), in order raise an error message when doing a COUNT IN for an existing lot tracking stock, which doesn't have an expiration date.
--  200123  ChFolk  Bug 152010(SCZ-8608), Revert the correction done for bug 149936 as it is not necessary by the customer.
--  200122  BudKlk  Bug 151922(SCZ-8162), Added a new private method Move_Part_With_Transp_Task__() to pass the info messages to the client side and passed allow_deviating_avail_ctrl_ to the Transport_Task_API.New_Or_Add_To_Existing in order to  
--  200122          allow move unreserved parts from the inventory part in stock window when "Allow Deviating Availability Control" set from the site level.  
--  200122  KiSalk  Bug 152011(SCZ-8621), Fixed a technical mistake done in 151966 correction.
--  200120  KiSalk  Bug 151966(SCZ-8417), Rewrote Get_Sum_Catch_Qty_Onhand to improve performance by properly using primary index. 
--  200109  PAMMLK  MFSPRING20-381, Added new parameter ownership_transfer_reason_id_ to Modify_Owning_Customer_No,Check_And_Update_By_Keys___,Handle_Owning_Cust_Change___and Update___.
--  200103  NISMLK  MFSPRING20-812, Added new parameter ownership_transfer_reason_id_ to Move_Part_Project, Issue_Part_Impl___, Receive_Part_Impl___ and Move_Part_Impl___.
--  200103  NISMLK  MFSPRING20-812, Added new parameter ownership_transfer_reason_id_ to Move_Part_Project, Issue_Part_Impl___ and Move_Part_Impl___.
--  191129  RoJalk  SCSPRING20-984, Modified Issue_Part and restricted the call Intersite_Profit_Manager_API.Create_Intersite_Transactions for 'SHIPODSIT-'. 
--  191115  RoJalk  SCSPRING20-984, Modified Issue_Part and called Inventory_Part_In_Transit_API.Move_Into_Order_Transit for 'SHIPODSIT-'.
--  191210  SWiclk  Bug 151218(SCZ-7901), Modified Create_Data_Capture_Lov() in order to handle LoV search setting in Where clause, also added new parameter data_item_id_.
--  191118  SWiclk  Bug 150998 (SCZ-7862, supplements SCZ-6808), Modified Create_Data_Capture_Lov(), Get_Column_Value_If_Unique() and Record_With_Column_Value_Exist() methods  
--  191023          in order to handle NULL for contract_ parameter.
--  191023  SWiclk  Bug 150632 (SCZ-6808), Modified Create_Data_Capture_Lov(), Get_Column_Value_If_Unique() and Record_With_Column_Value_Exist() methods  
--  191023          in order to improve performance by avoiding NVL in Where statements.
--  191007  ChFolk  Bug 149936 (SCZ-6697), Modified Check_Split_Into_Serials___ to validate eng part revision are same for the serials in the stock and serial catalog.
--  190926  DaZase  SCSPRING20-116, Added Raise_Invalid_Loc_Type_Error___, Raise_Pre_Posting_Not_Acc_Error___, Raise_Serial_Qty_1_Error___, Raise_No_Serials_Error___, 
--  190926          Raise_Qty_Onhand_Error___, Raise_Inconsistency_Error___, Raise_Ownership_Mism_Error___to solve MessageDefinitionValidation issues.
--  190918  SBalLK  Bug 150234 (SCZ-6522), Added latest_transaction_id column to the LU. Modified Issue_Part_Impl___(), Receive_Part_Impl___(), Move_Part_Impl___(),
--  190918          Scrap_Part___(), Count_Part() and Make_Individuals() methods to update latest transaction id when there is new transaction created in the system.
--  190923  BudKlk  Bug 146723 (SCZ-3261), Modified method Receive_Part_Impl___ by adding transaction codes 'UNCODELVOU' and 'UNCODELVIN' to allow undo customer order delivery for consignment parts which were delivered through shipment inventory.
--  190909  WaSalk  Bug 149808(SCZ-6322), Modified Update___() by adding another condition to check lot Batch number equals to '*' before calling Lot_Batch_Master_API.Modify_Expiration_Date().
--  190823  ErFelk  Bug 149647(SCZ-6496), Modified Count_Part___() by passing expiration_date_ to the Inventory_Transaction_Hist_API.NEW.
--  190612  AsZelk  Bug 148682 (SCZ-5280), Modified Check_And_Update_By_Keys___(), Check_Update___(), Count_Part___() methods to skip Mandatory Expiration Date error message 
--  190612          when count part with zero quantity.
--  190519  Cpeilk  Bug 147853 (SCZ-4420), Get_Move_Dest_Avail_Ctrl_Id___() to retrieve the correct availability control id to move.
--  190329  AsZelk  Bug 147626(SCZ-3458), Modified Check_Insert___() and Count_Part___() to skip the Mandatory Expiration Date check and try to retrieve lot batch number from the lot batch master.
--  190308  Asawlk  Bug 147290(SCZ-3613), Modified Move_Part() by passing the expiration_date of temporary created stock record with handling_unit_id = 0 if the parameter value of expiration_date_ is NULL when
--  190308          moving parts out of a handling unit. 
--  181207  ChBnlk  Bug 145776(SCZ-2087), modified Move_Part_Impl___() by passing value to the parameter validate_hu_struct_position_ in the method call Issue_Part_Impl___().
--  181204  ShPrlk  Bug 144892, Added new method Get_Move_Dest_Avail_Ctrl_Id().
--  181010  SBalLK  Bug 144418, Added Get_Available_Stock_Keys() method to fetch additional serial connected data when serial number manually entered in transport task line.
--  181010  SBalLK  Bug 144422, Modified Purchase_Order_Receipt___() method to update eng_chg_level in barcode information if there eng_chg_level conflicts exists during the purchase receipt from transit.
--  180902  ChFolk  SCUXXW4-5644, Added new method Get_Id_Version_By_Keys.
--  180807  UdGnlk  Bug 142077, Added Get_Serial_Avail_Control_Id() to retrieve the availability control id of part serial no. 
--  180716  RasDlk  Bug 142741, Modified Create_Count_Report___() by adding a condition to prevent creating a count report for parts with planning method K,O and T.
--  180309  LEPESE  STRSC-8437, Reversing the earlier change in method Putaway based on feedback during system tests. 
--  180308  LEPESE  STRSC-17479, Added package constant last_character_ and replaced usage of Database_SYS.Get_Last_Character with this new constant for increased performance.
--  180307  RaVdlk  STRSC-17471, Removed installation errors from sql plus tool
--  180302  MaAuse  STRSC-16691, Modified Create_Count_Report___ by adding exclude_supplier_rented_ and exclude_company_rental_asset in call to Counting_Report_API.New_List_Header.
--  180221  JaThlk  Bug 140182, Added parameter consider_unpicked_outbound_tt_ to methods Other_Conditions_Exist, Other_Lots_Exist and Other_Parts_Exist.
--  180220  LEPESE  STRSC-17081, Added parameter ignore_this_handling_unit_id_ to method Get_Root_Hu_Types_In_Stock.
--  180220  LEPESE  STRSC-16279, Added method Get_Destinat_Expiration_Date.
--  180214  LEPESE  STRSC-16027, Added method Get_Root_Hu_Types_In_Stock.
--  180214  SWiclk  STRSC-16849, Modified Create_Count_Report__() in order to initialize variables include_full_qty_of_hu_db_, exclude_attached_to_hu_ and 
--  180214          exclude_not_attached_to_hu_ with 'N' because create count report can be called from Shop order as well.
--  180208  KHVESE  STRSC-16772, Modified method Move_Part to add extra check for serial no after call to the method Change_Handling_Unit_Id.
--  180202  KHVESE  STRSC-16186, Modified method Move_Part to call to the method Change_Handling_Unit_Id with parameter always_preserve_serial_no_ set to move_part_shipment_
--  180202          to preserve serial when part moves to shipment location.
--  180129  LEPESE  STRSC-16186, Added parameter always_preserve_serial_no_ to methods Change_Handling_Unit_Id and Move_Part_Impl___. 
--  171215  ChJalk  Bug 139327, Modified the method Count_Part___ to assign the serial no to serial_no_for_stock_, if already exists in the stocks when confirming a counted line.
--  171214  ErFelk  Bug 139310, Modified Make_Onhand_Analysis_Impl___() by changing the error message NOT_IN_CAL_STAN. 
--  171208  KHVESE  STRSC-14829, Modified call to method Customer_Consignment_Stock_API.Increase_Consignment_Stock_Qty to pass parameter validate_hu_struct_position_.
--  171204  ChFolk  STRSC-15036, Added new method Raise_Move_To_Location_Error which is called from Check_Valid_Move_Combinations and 
--  171204          Invent_Part_Quantity_Util_API.Unreserve_Stock___ to validate moving to stocks location. 
--  171204  RoJalk  STRSC-14897, Modified Check_Valid_Move_Combinations to support shipment inventory for project deliverables.
--  171129  DAYJLK  STRSC-13921, Added parameter reserve_from_transp_task_db_ to methods Find_And_Reserve_Part and Find_And_Reserve_Or_Issue___.
--  171128  TiRalk  STRSC-14463, Modified Undo_Move_To_Order_Transit___, Revalue_Int_Order_Transit___  and Unissue_Part by adding COUNSHPTRN and COUNSHPDIR to
--  171128          reverse corresponding intersite profitability transactions.
--  171128          Modified Receive_Part_Impl___ by allowing undo delivery transactions COUNSHPTRN and COUNSHPDIR for shipment inventory.
--  171127  TiRalk  STRSC-13753, Modified Undo_Move_To_Order_Transit___, Revalue_Int_Order_Transit___  and Unissue_Part by adding UNINPODRIM and UNPODRINEM
--  171127          to reverse corresponding intersite profitability transactions.
--  171124  MaAuse  STRSC-14357, Modified Change_Handling_Unit_Id by removing parameter error_at_max_hu_capacity_. Removed condition for error message in Change_Handling_Unit_Id.
--  171123  AsZelk  Bug 138937, Modified Create_Count_Report___() in order to, not to fetch storage locations when storage_zone_id is not passed in.
--  171122  ChFolk  STRSC-14036, Modified Check_Valid_Move_Combinations to have a common validation for some order types when moving stocks to different location types.
--  171122  MaAuse  STRSC-14626, Modified Change_Handling_Unit_Id by moving the max capacity validation to to the end of the method.
--  171116  MaAuse  STRSC-14357, Modified Change_Handling_Unit_Id by adding parameter error_at_max_hu_capacity_. Added condition for error message in Change_Handling_Unit_Id.
--  171109  TiRalk  STRSC-13735, Modified Receive_Part_Impl___ by allowing undo delivery transaction UNSHIPDIR for shipment inventory.
--  171102  TiRalk  STRSC-12292, Modified Receive_Part_Impl___ by allowing undo delivery transaction UNSHIPTRAN for shipment inventory.
--  171026  LEPESE  STRSC-13819, Removed parameter ignore_transport_task_id_ from Any_Parts_Exist and replaced with parameter consider_inbound_parts_.
--  171026          Change in Move_Part_Imp___ to pass calling_process_ = 'EXECUTING_TRANSPORT_TASK_LINE' into Inventory_Putaway_Manager_API.Check_Storage_Requirements
--  171026          when transport_task_id_ parameter is not null.
--  171024  TiRalk  STRSC-12292, Modified Undo_Consignment_Consum___ by adding COUNSHPTRN.
--  171024  TiRalk  STRSC-13735, Modified Unissue_Part, Undo_Move_To_Order_Transit___ and Revalue_Int_Order_Transit___ by adding UNSHIPDIR.
--  171024          Modified Undo_Consignment_Consum___ by adding COUNSHPDIR.
--  171019  LEPESE  STRSC-13187, Added methods Find_For_Transport, Clear_Invent_Part_In_Stock_Tmp, Fill_Invent_Part_In_Stock_Tmp. Added consideration to
--  171019          inventory_part_in_stock_tmp, location_group and part_movement_control in method Find_Part___. Added action_ find_for_transport.
--  171019          Added parameters part_movement_control_db_ and location_group_ to methods Find_Part___, Find_And_Lock_Part. 
--  171019          Added parameter location_group_ to method Find_And_Reserve_Or_Issue___. 
--  171012  LEPESE  STRSC-12433, Added call to Transport_Task_Line_API.Handle_Stock_Reservat_Result from Find_And_Reserve_Or_Issue___.
--  171010  TiRalk  STRSC-12296, Modified Unissue_part to reverse intersite profitability transactions.
--  171004  KHVESE  STRSC-9352, Modified call to Customer_Consignment_Stock_API.Decrease_Consignment_Stock_Qty in method Unissue_Part. 
--  171003  LEPESE  STRSC-12433, Added transport_task_id and to_location_no to Keys_And_Qty_Rec.
--  171002  TiRalk  STRSC-12292, Modified Undo_Return_Rework by moving logic into Undo_Move_To_Order_Transit___, Revalue_Int_Order_Transit___.
--  171002          Modified Unissue_part to handle reverse transaction of SHIPTRAN and INTORDTR when undo a custome order delivery.
--  170927  LEPESE  STRSC-12390, Added call to Transport_Task_Line_API.Recreate_Removed_Lines from Find_And_Reserve_Or_Issue___.
--  170927  LEPESE  STRSC-12389, Added call to Transport_Task_Line_API.Find_And_Remove from Find_And_Reserve_Or_Issue___.
--  170912  ChFolk  STRSC-11923, Modified Create_Count_Report___ to remove parameter handling_unit_selection and added new parameters exclude_attached_to_hu and exclude_not_attached_to_hu.
--  170912          Also modified the method calls by removing the existing parameter handling_unit_selection_db_ and adding new parameters exclude_attached_to_hu_ and exclude_not_attached_to_hu_.
--  170901  UdGnlk  Bug 136645, Modified Issue_Part() to introduce 'PURTRAN' to move to transit object.
--  170830  ChFolk  STRSC-11366, Modified Create_Count_Report___ to handle the flag include_full_qty_of_hu_db_ is set where we need to include handling units of
--  170830          the full structure irrespective of the part no.
--  170822  ChFolk  STRSC-11366, Modified Create_Count_Report___ to add a new IN parameter to include_full_qty_of_hu_db_ and modified cursor get_all_qty to filter.
--  170822          the selected qty based on the parameter. Modified Create_Count_Report__ to unpack the parameter value for include_full_qty_of_hu_db_.
--  170816  Asawlk  Bug 137150, Modified cursor get_location in Find_Part___ to retrieve records either with exact condition code or irrespective to the condition code.
--  170809  ErRalk  Bug 135979, Change message constant REINPLSERCOUNT to REINPLSERCOUNTQS in Modify_Owning_Customer_No and REINPLSERCOUNTQO in Receipt_In_Place to emilinate duplication.
--  170802  DAYJLK  STRSC-9161, Modified Move_Part_With_Transport_Task to raise an error when a reservation is moved partially.
--  170728  ErRalk  Bug 136301, Modified Update___ method to update expiration date in Lot Batch Master.
--  170726  ChFolk  STRSC-10952, Modified Create_Count_Report___ to add filters for handling unit selection, handling unit type and category when collection information to count report.
--  170726  ChJalk  Bug 136550, Modified the methods Move_Part and Move_Part_Impl___ to add the parameter availability_ctrl_id_. Modified the methods Reserve_Part, 
--  170726          Move_Part_Project, Move_Part_Shipment, Connect_To_Lot_Batch, Change_Waiv_Dev_Rej_No, Rename_Serial, Modify_Owning_Customer_No and Split_Into_Serials 
--  170726          to pass NULL for availability_ctrl_id_ in the method Move_Part_Impl___.
--  170724  ChFolk  STRSC-11002, Modified Create_Count_Report___ to add new parameters to the method call Counting_Report_API.New_List_Header.
--  170720  ChFolk  STRSC-10939, Added new parameters handling_unit_selection_db_, handling_unit_type_id_, top_handling_unit_type_id_, handling_category_type_id_, and
--  170720          top_handling_category_type_id_ to Create_Count_Report___. Modified Create_Count_Report__ to get the values for new parameters from the attribute string.
--  170713  SWiclk  STRSC-9621, Increased length of stmt_ variable in Create_Data_Capture_Lov() and Record_With_Column_Value_Exist().
--  170712  NiDalk  Bug 136504, Modified Move_Part_Project not to show error message AVCTRLDIFFERS when to_availability_control_id_ is null and quantity is 0.
--  170703  JeLise  STRSC-9598, Added new parameters source_ref1_, source_ref2_, source_ref3_, receipt_no_ and source_ref_type_ to 
--  170703          method Move_Part_With_Transport_Task.
--  170602  UdGnlk  STRSC-8457, Modified Putaway() and  Receive_Part_With_Posting() method call from Fnd_Boolean_API.Evaluate to Fnd_Boolean_API.Evaluate_Db.  
--  170531  KHVESE  LIM-10758, Modified method Move_Part_With_Transport_Task to call to methods Move_Res_With_Transport_Task and Transport_Task_API.New_Or_Add_To_Existing with check_storage_requirements_ => TRUE.
--  170522  ChBnlk  Bug 135688, Added new method Get_Handling_Unit_Row_Count() to check the number of rows that are using a particular handling_unit_id.
--  170516  LEPESE  STRSC-7577, Restored earlier removed check on if oldrec_.catch_qty_onhand IS NULL in Check_Onhand_Decrease_Catch___.
--  170512  LEPESE  STRSC-8437, Modifications in method Putaway to call Handling_Unit_API.Putaway in case complete HU content will be involved. 
--  170503  UdGnlk  LIM-11456, Modified Move_Part_With_Transport_Task() to pass the correct parameter to order_supply_demand_type_db.
--  170331  MaEelk  LIM-11272, Modified Move_Part_With_Transport_Task. Reservations are fetched if the move_reservation_option is not set as 'Not Allowed' in Site Level.
--  170329  RuLiLk  Bug 134477, Modified method Modify_Availability_Control_Id to do the modification only if  the new availability control id is different from the old id.
--  170327  MaEelk  LIM-11272, Added OUT parameter moved_quantity to Move_Part_With_Transport_Task.
--  170327  MaEelk  LIM-11272, Renamed the method name Add_To_Transport_Task as Move_Part_With_Transport_Task.
--  170322  MaEelk  LIM-11272, Modified Add_To_Transport_Task. This method will support moving inventory part in stock quantities having both available and reserved quantities 
--  170322          in the same stock record in future.
--  170314  UdGnlk  LIM-10871, Modified Other_Parts_Exist(), Other_Conditions_Exist() and Other_Lots_Exist() to calling method Transport_Task_API.Get_Qty_Outbound().  
--  170314          Passed the parameter reserved_by_source_db_ to Transport_Task_API.Reduce_Qty_On_Unexecuted_Tasks().
--  170310  LEPESE  LIM-3740, Added consideration to Site_Invent_Info_API.Get_Auto_Reserve_Hu_Optim_Db in method Find_Part___.
--  170310  MaIklk  LIM-10562, Changed the data type to varachar2 for line_item_no_ parameter in Move_Part_Shipment, Move_Part  and Move_Part_Impl___
--  170309  LEPESE  LIM-3740, Added method Get_Consumed_Hu_Quantity___ and rewrote Check_Consume_From_This_Rec___ to handle random order in HU structure levels.
--  170224  NaSalk  LIM-10933, Modified Purchase_Order_Receipt to add new parameter transit_handling_unit_id.
--  170207  Chfose  LIM-10534, Added inventory_event_id Unissue_part and validate_hu_struct_position_ to Unisse_Part & Unreceive_Part.
--  170130  MAJOSE  STRMF-9424, Added method Get_Gross_Expired_Date_And_Qty
--  170123  Jhalse  LIM-10150, Added validate_hu_struct_position to Issue_Part and Issue_Part_Impl___.
--  170113  Chfose  LIM-10018, Converted Purchase_Order_Receipt into an implementation method and created new Purchase_Order_Receipt
--  170113          which handles breaking of handling unit structures and unpack similar to Move_Part & Receive_Part_From_Transit.
--  170111  MaEelk  LIM-10121, Passed parameters pick_list_no_ and shipment_id_ to Inv_Part_Stock_Reservation_API.Get_Qty_Reserved.
--  170105  LEPESE  LIM-10028, Added parameter ignore_this_handling_unit_id_ to methods Get_Consumed_Carrying_Capacity and Get_Consumed_Volume_Capacity.
--  170103  Chfose  LIM-10154, Added move_comment to Move_Part_Shipment.
--  161228  MaEelk  LIM-10156, Simplified the error messge given in check_Ownership___ when trying to transfer the ownership  of a Reserved or In Transit Qty between customers.
--  161219  Matkse  APPUXX-6441, Added Make_Onhand_Analysis_B2b_Vmi.
--  161206  NiDalk  LIM-9642, Modified Create_Count_Report_Lines___ to add handling_unit_id also to soring.
--  161125  Chfose  STRSC-4990, Added new overload to Receive_Part_From_Transit which handles breaking of handling unit structures
--  161125          and receiving out of a handling units similar to Move_Part.
--  161125  RALASE  LIM-9873, Removed methods Get_Actual_Catch_Qty_Onhand, Get_Qty_In_Transit_By_Location and Get_Qty_Onhand_By_Location since they are not used anymore.
--  161115  Chfose  LIM-9367, Bypassed shipment-validation in Check_Common___ when having a shipment location.
--  161104  LEPESE  LIM-9401, Made modifications to methods Get_Consumed_Carrying_Capacity and Get_Consumed_Volume_Capacity in such a way that the weights and volumes
--  161104          of parts packed into handling units are ignored, and instead calls are being made to find the gross weights and volumes of the handling units.
--  161024  LEPESE  LIM-1304, Added methods Raise_Putaway_Locat_Type_Error and Raise_Rotable_Pool_Move_Error. Changed method Raise_Freeze_Flag_Error___ into
--  161024          a public method Raise_Freeze_Flag_Error. Added call to Handling_Unit_API.Lock_By_Keys in Manage_Handling_Unit___.
--  161013  NiLalk  STRSC-4178, Modified Check_Update___  by adding two parameters for Transport_Task_Manager_API.Inbound_Or_Outbound_Task_Exist method call.
--  161006  LEPESE  LIM-9167, Added method Expiration_Date_Is_Missing. Added validations on mandatory_expiration_date in Check_Insert___ and Check_Update___.
--  161005  LEPESE  LIM-8729, Added parameter discon_zero_stock_handl_unit_ to method Change_Handling_Unit_Id and passed FALSE for this
--  161005          parameter when calling from overloaded clob-parameter version of the same method. 
--  161004  LEPESE  LIM-7798, Added method Find_And_Reserve_Or_Issue___. Called this method from Find_And_Reserve_Part and Find_And_Issue_Part.
--  161004  MaEelk  LIM-8624, Modified Change_Handling_Unit_Id and passed part_tracking_session_id to through the message_ and handled logic to assign a serial number
--  161004          to a Receipt and Issue Serial Tracking Part when attaching it to a Handling Unit.
--  161003  DaZase  LIM-7717, Added support for print_count_report_db_ in Validate_Create_Count_Report and Create_Count_Report__.
--  160930  LEPESE  LIM-7798, Modified Find_And_Issue_Part to call Find_And_Reserve_Part because this method includes Handling Unit Optimization.
--  160930  LEPESE  LIM-8882, Added validations in Check_Insert___ and Check_Update___ to give error if serial tracked part is packed into handling unit on 
--  160930          stock location without specified serial number. Should give error even if part is not serial tracked in inventory, only receipt and issue.
--  160929  LEPESE  LIM-8882, Added parameter handling_unit_id_ to method Get_Serial_No_For_Stock in order to make sure that we preserve the unique serial numbers
--  160929          in InventoryPartInStock when serials are packed into handling units. Development in Unissue_And_Move_Part to support a situation where
--  160929          a receipt and issue serial tracked part was issued from handling unit id 0 but unissued into a handling unit. Split_Into_Serials was added. 
--  160922  TiRalk  Bug 131311, Modified the error message 753 in method Validate_Count_Part() by adding additional information.
--  160919  Asawlk  LIM-8698, Added method Lock_By_Keys().
--  160909  Chfose  LIM-8399, Added new overload of Change_Handling_Unit_Id that takes a message to be able to handle changing multiple records to the same new Handling Unit ID
--  160902  RoJalk  LIM-8268, Added the parameter order_type_  to the method Move_Part_Shipment.
--  160816  LEPESE  LIM-7892, Added parameters inventory_event_id_ and validate_hu_struct_position_ to method Unissue_Part and passed them in call to
--  160816          Inventory_Transaction_Hist_API.Reverse_Transaction. Added parameter validate_hu_struct_position_ to method Receive_Part and passed value in call
--  160816          to Receive_Part_Impl___. Added parameter new_handling_unit_id_ to Unissue_And_Move_Part. Redesigned Unissue_And_Move_Part and added call to
--  160816          Change_Handling_Unit_Id. Passed inventory_event_id_ and validate_hu_struct_position_ in calls to methods Unissue_Part, Change_Handling_Unit_Id
--  160816          and Move_Part. Added parameter validate_hu_struct_position_ to Change_Handling_Unit_Id and passed value in call to Move_Part_Impl___. 
--  160810  LEPESE  LIM-7596, Added parameters old_qty_reserved_ and new_qty_reserved_ to method Manage_Handling_Unit___. Added calls towards
--  160810          Handling_Unit_API.Set_Stock_Reservation and Handling_Unit_API.Clear_Stock_Reservation from Manage_Handling_Unit___.
--  160808  NaSalk  LIM-8211, Added Change_Source_Handl_Unit_Id___ and Modified Change_Handling_Unit_Id to support changing handling unit for receipts in Arrival and QA locations.
--  160808  LEPESE  LIM-7798, Added condition for handling_unit_id = 0 in Find_And_Issue_Part_Neg. Also changed the direction of the waiv_dev_rej_no_ and
--  160808          handling_unit_id_parameters in Find_And_Issue_Part_Neg from IN OUT to OUT.
--  160803  UdGnlk  LIM-7793, Modified Find_And_Issue_Part_Neg() to support Inventory Event Concept.  
--  160729  Chfose  LIM-7791, Added inventory_event_id to Cleanup_Handl_Unit_Struct___, Count_Part___ & Change_Handling_Unit_Id.
--  160719  Jhalse  LIM-7789, Added inventory_event_id to Unreceive_Part()
--  160714  Chfose  LIM-7517, Added inventory_event_id to Split_Into_Serials.
--  160713  Jhalse  LIM-7789, Added default parameters to methods Find_And_Issue_Parts()
--  160704  Khvese  LIM-7129, Modified Create_Count_Report__ to create report for aggregated handling units.
--  160701  Jhalse  LIM-7520, Modified Create_Count_Report_Lines___ to use the Inventory_Event_Id concept.
--  160701  UdGnlk  LIM-7786, Added Issue_Part() a parameter inventory_event_id_ to support Inventory Event Concept.  
--  160627  JoAnSe  LIM-7775, Added include_temp_table_locs_ parameter to Find_And_Reserve_Part.
--  160613  SWeelk  Bug 129751, Modified Receive_Part_Impl___() by adding 'UNDELCONOU', 'UNDELCONIN' transaction codes to undo COs with order type that says to use Shipment Inventory.
--  160603  NaLrlk  LIM-7492, Modified Scrap_Part___() to validate qty_on_hand before creating inventory transaction hist.
--  160602  Chfose  LIM-7251, Added move_part_shipment_ to Move_Part and used it in Move_Part_Shipment to get the "Move and Unattach"-functionality when moving into ship inv.
--  160531  PrYaLK  Bug 127654, Added a new function Rece_Part_With_Posting_Clob().
--  160527  LEPESE  LIM-7474, Added method Manage_Handling_Unit___ and call it from Insert___ and Update___. Moved calls to validate handling unit structure,
--  160527          to refresh handling unit snapshots and to set or clear stock location information on handling unit from Insert___ and Update___ into this method.
--  160526  LEPESE  LIM-7474, Added calls to Handling_Unit_API.Set_Stock_Location from Insert___ and Update___.
--  160526          Added call to Handling_Unit_API.Set_Stock_Location from Update___.
--  160525  LEPESE  STRMF-3871, Added method Get_Default_Avail_Ctrl_Id.
--  160525  Chfose  STRSC-2411, Added error-msgs regarding reserved qty and modifying expiration date in Change_Handling_Unit_Id.
--  160524  ErFelk   Bug 128143, Modified Move_Part_Impl___() by passing TRUE to unit_cost_is_material_ and 'INTER_COMPANY_MOVE' to source_ref_type_db_ when calling
--  160524           Inventory_Part_Unit_Cost_API.Generate_Cost_Details(). 
--  160524  Apwilk  Bug 129104, Added an error message and modified the Cancel_Receipt_In_Place() in order to prevent cancelling the purchace order receipt 
--  160524          when sufficient quantity is not there in the location.
--  160523  LEPESE  LIM-7363, Replaced putaway_event_id_ with inventory_event_id_, remove_putaway_event_ with finish_inventory_event_, 
--  160523          Inventory_Putaway_Manager_API.Get_Next_Putaway_Event_Id with Inventory_Event_Manager_API.Get_Next_Inventory_Event_id and
--  160523          Putaway_To_Empty_Event_API.Remove_Putaway_Event with Inventory_Event_Manager_API.Finish.
--  160517  LEPESE  LIM-7363, Added method Refresh_Handl_Unit_Snapshot___ and call it from Insert___ and Update___. Added putaway_event_id_ as parameter to
--  160517          methods Insert___ and Update___ and pass values into these methods from various places where inserts and modifications of qty_onhand can be done.
--  160517          This means that a lot of methods have now putaway_event_id_ as a default parameter. 
--  160504  Chfose  STRSC-2208, Added @UncheckedAccess to Get_Rotable_Part_Pool_Qty.
--  160426  LEPESE  LIM-4581, modifications in overloaded Move_Part to unreserve before unattaching from Handling Unit ID. 
--  160420  JanWse  STRSC-1785, Added TRUE to also check for blocked in a call to Scrapping_Cause_API.Exist
--  160418  LEPESE  LIM-6322, correction in Check_Consume_From_This_Rec___ to avoid partially reserving from a handling unit when being
--  160408          in the Full Handling Unit mode. In the Full Handling Unit mode we should only reserve if full HU quantity can be reserved. 
--  160408  Jhalse  LIM-6982, Added error message for trying to unattach a larger qty than available.
--  160407  KhVese  LIM-5869, Added method Add_To_Transport_Task.
--  160325  Asawlk  Bug 127179, Modified Modify_Exp_Date_By_Lot_No() to only consider stock records with a quantity when calling Modify_Expiration_Date.  
--  160217  JeLise  LIM-6210, Removed one check on if oldrec_.catch_qty_onhand IS NULL in Check_Onhand_Decrease_Catch___.
--  160125  KhVese  LIM-5992, Added new method Check_Handling_Unit_Exist.
--  160114  LEPESE  LIM-3742, passing qty_to_find_ and consume_partial_handling_unit_ to Invent_Part_Putaway_Zone_API.Get_Zone_And_Fifo_Sorted_Stock from Find_Part___.
--  160114          Also modified Find_And_Reserve_Part to concatenate the two keys_and_qty_tab_ collections we get from each call to Find_And_Lock_Part.
--  160113  LEPESE  LIM-3742, added method Check_Consume_From_This_Rec___. Further development of handling unit reservation in Find_Part___.
--  160113          Added parameter available_record_was_skipped_ to methods Find_Part___ and Find_And_Lock_Part.
--  160112  LEPESE  LIM-3742, added homogeneous_hu_root_node_qty and root_handling_unit_id to Available_Stock_Rec. Implemented logic in Find_Part___
--  160112          that decides wether or not to consume from a stock record that is connected to a handling unit id. The idea is to only consume full
--  160112          top parent handling units. 
--  160111  LEPESE  LIM-3742, added sorting on handling_unit_id in method Find_Part___, to optimize behavior in 
--  160111          Invent_Part_Putaway_Zone_API.Get_Zone_And_Fifo_Sorted_Stock. 
--  160105  AwWelk  STRSC-578, Merged Bug 124047. Modified Move_Part_Impl___() to create LOT-IN and LOT-OUT transactions when lot tracked parts are moved.
--  151208  LEPESE  LIM-4581, added new overloaded version of Move_Part which handles handling unit structure validation errors by
--  151208          unattaching the quantity from the handling unit before moving it. 
--  151208  KhVese  LIM-4898, Modified the sql statement in Get_Sum_Column_Value().
--  151208  Cpeilk  Bug 125804, Modified Move_Part_Impl___ to check availability_control_id of the from location stock to check part movement allowed or not.
--  151207  LEPESE  LIM-5293, modification in Check_Handling_Unit___ to enable structure validation when moving into or out of transit.
--  151207  KhVese  LIM-4898, Renamed method Get_Columns_Value_Sum() to Get_Sum_Column_Value() and modified the cursor.
--  151207  LEPESE  LIM-3920, removed pallet_id_ parameter in call to Inventory_Putaway_Manager_API.Putaway_Part.
--  151203  Chfose  LIM-4842, Added call to Handling_Unit_API.Check_Allow_Mix in Check_Handling_Unit___.
--  151201  LEPESE  LIM-3917, renamed method Count_Part_No_Pallet into Count_part. Replaced all hardcoded location type strings with the global 
--  151201          constants of the Inventory_Location_Type_API enumeration package. Removed all remaining code related to pallet handling.
--  151201  KhVese  LIM-2917, Changed method Receive_Part_From_Transit to public method and added validate_hu_struct_position_ to it signature.
--  151201          Added new parameter validate_hu_struct_position_ to Receive_Part_Impl___() and added hard-coded value TRUE in all calls except from Receive_Part_From_Transit.
--  151201          Also changed calls to Insert___ and Check_And_Update_By_Keys___ by passing parameter validate_hu_struct_position_.
--  151126  JeLise  LIM-4470, Removed pallet_id from Available_Stock_Rec.
--  151123  Chfose  LIM-5033, Removed unused pallet-parameter in Move_Part, Scrap_Part, Scrap_Part___ , Return_Rework & Return_Credit.
--  151119  ErFelk  Bug 125713, Modified Issue_Part() by modifying a condition to check DB_CONSIGNMENT when transaction_ is in 'SHIPTRAN' or 'SHIPDIR'.  
--  151119  UdGnlk  LIM-3788, Removed the parameter of pallet_id from Scrap_Credit() and pallet_id_list_ from Purchase_Order_Receipt().
--  151118  KhVese  LIM-2926, Added method Get_Columns_Value_Sum().
--  151113  LEPESE  LIM-4837, added call to Cleanup_Handl_Unit_Struct___ in method Count_Part. 
--  151113  LEPESE  LIM-4833, modification of cursors get_partloc and get_all_qty in method Create_Count_Report___ to exclude records
--  151113          having_handling_unit_id != 0 and qty_onhand = 0. Same logic as for serials is implemented for handling units.
--  151110  RasDlk  Bug 124596, Modified the method Purchase_Order_Receipt() in order to remove the variable manual_dispatch_ since it only affects for the external suppliers.
--  151106  UdGnlk  LIM-3746, Removed Inventory_Part_Loc_Pallet_API method calls since INVENTORY_PART_LOC_PALLET_TAB will be obsolete.
--  151103  UdGnlk  LIM-3671, Removed method call Inventory_Transaction_Hist_API.Set_Pallet_Id() to support the pallet entity obsolete.
--  151016  MaEelk  LIM-3784, Removed the pallet_id from counting_report_line_tmp and Counting_Report_Line_API.New_List_Detail.
--  151014  LEPESE  LIM-4031, added validation in Check_Common___ to prevent attaching stock record quantities to shipment handling units.
--  150908  LEPESE  AFT-4195, change in Move_Part_Impl___ to call Get_Move_Dest_Avail_Ctrl_Id___ also when not changing contract or location_no.
--  150908          Change in Get_Move_Dest_Avail_Ctrl_Id___ to handle situation where contract and location_no is not changed.
--  150903  MAHPLK  AFT-3340, Modified Unissue_Part() to 'Decrease Qty At Customer' for UNCODELVOU and UNDELCONOU transactions.
--  150903  MAHPLK  AFT-3315, Modified Undo_Consignment_Consum___() to consider 'COOEUNSHIP' transaction code.
--  150901  UdGnlk  LIM-3603, Reverse the correction as it is a generic message. Modified Change_Handling_Unit_Id() to add a meaningful message.
--  150828  UdGnlk  LIM-3603, Modified Raise_Over_Issue_Error___() the error message ONHLESSAVAIL to be more meaningful.   
--  150812  MAHPLK  KES-1081, Modified Issue_Part() and Receive_Part() method to reflect parameters change of 
--  150812          Customer_Consignment_Stock_API.Increase_Consignment_Stock_Qty(), Inventory_Part_At_Customer_API.Increase_Our_Qty_At_Customer() 
--  150812          and Inventory_Part_At_Customer_API.Decrease_Our_Qty_At_Customer().
--  150806  MAHPLK  KES-905, Renamed order_no_, line_no_, release_no_, line_item_no_, deliv_no_, order_type_ attributes of Receive_Part_Impl___() 
--  150806          to source_ref1_, source_ref2_, source_ref3_, source_ref4_, source_ref5_, source_ref_type.
--  150805  DaZase  COB-610, Removed lov_id_ and cursor_id_ from Create_Data_Capture_Lov/Get_Column_Value_If_Unique/Record_With_Column_Value_Exist 
--  150805          since all calls to these methods now should use the sql_where_expression_ parameter for more control of the where statements.
--  150730  SWiclk  Bug 121254, Modified Move_Part_Impl___() by adding a method call to Inventory_Part_Barcode_API.Copy() in order to copy barcode.
--  150729  MeAblk   Bug 123826, Modified Scrap_Part___ by passing the value for the parameter expiration_date_ in method call Inventory_Transaction_Hist_API.NEW 
--  150729           in order to set the expiration date when scrapping inventory parts.--  150729  BudKlk  Bug 123377, Modified the method Create_Data_Capture_Lov() in order to use Utility_SYS.String_To_Number()
--  150729          method call in ORDER BY clause to sort string and number values seperately.
--  150728  ShKolk  Bug 123092, Modified Create_Count_Report__() to set COPIES option to support StreamServe reports.
--  150728  JeeJlk  Bug 122624, Modified Receipt_In_Place by passing catch_quantity to Receive_Part_Impl___.
--  150707  ShKolk  Bug 123413, Modified Receive_Part_With_Posting() to set default condition code if it's required in Part Serial Catalog or Lot Batch Master.
--  150709  IsSalk  KES-906, Added reference-by-name for the parameter list when calling the method Inventory_Part_In_Stock_API.Issue_Part().
--  150709  MAHPLK  KES-905, Added new parameter deliv_no_ as parameter to Receive_Part() and Receive_Part_Impl___().
--  150707  IsSalk  KES-905, Added reference-by-name for the parameter list when calling the method Inventory_Transaction_Hist_API.New().
--  150629  LEPESE  LIM-3513, added parameter validate_hu_struct_position_ to methods Move_Part, Move_Part_Impl___, Insert___, Update___,
--  150629          Check_And_Update_By_Keys___ and Check_Handling_Unit___.
--  150626  DaZase  COB-471, Added null handling in method Get_Column_Value_If_Unique, added cursor_id 8 to Record_With_Column_Value_Exist. 
--  150622  LEPESE  LIM-3099, added method Change_Handling_Unit_Id. Added parameter to_handling_unit_id_ in method Move_Part_Impl___.
--  150622  LEPESE  LIM-3106, added parameter print_serviceability_tag_db_ to method Scrap_Part. Added method Print_Serviceability_Tag___.
--  150618  DaZase  COB-475, Added out param to Get_Column_Value_If_Unique to make it possible to see difference between no unique value found and to many values found.
--  150612  LEPESE  LIM-3101, added methods Cleanup_Handl_Unit_Struct___ and Handling_Unit_Exist.
--  150527  DaZase  COB-439, Changed Create_Data_Capture_Lov to handle new version of Data_Capture_Session_Lov_API.New and the new set of parameters it needs.
--  150520  DaZase  COB-437, Removed 100 record description limitation in method Create_Data_Capture_Lov, 
--  150608  MAHPLK  KES-513, Modified Receive_Part_Impl___ to receive the parts in to shipment location when undo customer order delivery.
--  150512  IsSalk  KES-423, Added new parameter source_ref5_ to Inventory_Part_In_Stock_API.Issue_Part.
--- 150512  MAHPLK  KES-402, Renamed usage of order_no, release_no, sequence_no, line_item_no attributes of InventoryTransactionHist 
--  150512          to source_ref1, source_ref2, source_ref3, source_ref4
--  150520          this will be replaced with a new configurable LOV record limitation in WADACO framework.
--  150508  JeLise  LIM-2883, Added activity_seq and handling_unit_id in call to Counting_Result_API.Get_Last_Completed_Count_Date.
--  150428  MaEelk  LIM-1573, Passed handling_unit_id_ to the Inventory_Part_In_Transit_API.Get_Total_Qty_In_Order_Transit method call from Get_Inventory_Quantity.
--  150409  MAHPLK  KES-244, Added new parameter ignore_this_avail_control_id_ to Find_And_Issue_Part_Neg() and 
--  150409          modified it to ignore the given availability control when selecting the location. 
--  150408  LEPESE  LIM-77, implemented handling_unit_id throughout the complete file, all logic and all method interfaces. Added method Check_Handling_Unit___.
--  150402  LEPESE  LIM-75, added handling_unit_id as a new key column. 
--  150323  JoAnSe  MONO-109, Removed the restriction for inter-site move for Periodic Weighted Average parts in Move_Part_Impl___. 
--  150317  DaZase  COB-17, Added sql_where_expression_ parameter to Get_Column_Value_If_Unique, Create_Data_Capture_Lov and Record_With_Column_Value_Exist.
--  150227  Erlise  PRSC-5675, Passing parameter putaway_event_id_ in the call to 
--  150227          Inventory_Putaway_Manager_API.Putaway_Part in method Receive_Part___.
--  150216  KHVESE  PRSC-6042, Added new condition to where clause in method Record_With_Column_Value_Exist() with cursor_id_ = 7 to use in 
--  150216          Manual Issue Workorder in WADACO processes.
--  150215  Cpeilk  Bug 120365, Modified Cancel_Receipt_In_Place to get the inventory_value_ correctly by calling Inventory_Part_Unit_Cost_API.Get_Inventory_Value_By_Method
--  150215          which considers lot_batch_no and serial_no. Wrong inventory_value_ causes an unnecessary revaluation.
--  150129  Chfose  PRSC-5801, Corrected some error messages by exchanging 'and' with a ',' where suitable.
--  150129  KhVeSe  PRSC-5485, Added a logic to the method Move_Part() to support move part to a location with "receipt to 
--  150129          occupied is blocked" property when split into serials.
--  150127  LEPESE  PRSC-5663, added parameter putaway_event_id_ to method Receive_Customer_Order_Return and passed value to Receive_Part.
--  150126  Khvese  PRSC-4989, Removed the overload version of Receive_Part_With_Posting and changed the signature and the logic of the original 
--  150126          method to support multiple move to one location with "receipt to occupied is blocked" property. Also added same logic to the  
--  150126          Transfer_Rental_Asset method and Passed putaway_event_id_ and FALSE in call to Receive_Part_With_Posting for putaway_event_id_ 
--  150126          and remove_putaway_event_db_ respectively.
--  150123  LEPESE  PRSC-5482, changes in Receive_Part_Impl___ to consider value of parameter availability_control_id_ always when receiving
--  150123          into a new or empty (onhand = 0 and in_transit = 0) stock record. Erlier it was only during Unissue we used it. 
--  150122  Khvese  PRSC-4989, Added an additional overload version of Receive_Part_With_Posting with additional parameter remove_putaway_event_db_
--  150122          to support multiple selection in client. Also added putaway_event_id_ parameter to methods Receive_Part_With_Posting and call method 
--  150122          Receive_Part_Impl___ with putaway_event_id_ parameter instead of Null.
--  150113  Chfose  PRSC-5030, Hindered values from being null when comparing expiration dates in Check_Update___.
--  150113  MaEelk  PRSC-4978, Increased the length of part_no_ to 2000 in Create_Count_Report__.
--  150108  LEPESE  PRSC-4989, added putaway_event_id_ parameter to methods Receive_Part_Impl___, Receive_Part and Purchase_Order_Receipt.
--  150108          Passed putaway_event_id_ in call to Inventory_Putaway_Manager_API.Check_Storage_Requirements from Receive_Part_Impl___.
--  141231  MaEelk  PRSC-4811, Allowed selecting multiple part numbers when creating the count report.
--  141216  NaSalk  PRPJ-3751, Modified Receive_Part_With_Posting and Issue_Part_With_Posting___.
--  141211  NaSalk  PRPJ-3625, Added Check_Common___ to restrict having CRA ownership in pallet locations.
--  141211  NaSalk  PRPJ-3751, Moved common validations in Receipt_In_Place and Transfer_Rental_Asset to Check_Transfer_To_Own_Stock___.
--  141211          Added Raise_Trf_Ownership_Error___. Modified Issue_Part_Impl___, Receive_Part_With_Posting and Issue_Part_With_Posting___.
--  141208  NaSalk  PRPJ-3625, Modified the logic how part owneship is set in Receive_Part_With_Posting. 
--  141206  RaKalk  Added redundant parameters to call to Putaway to fix overload conflict.
--  141205  Erlise  PRSC-3253, Added an additional Putaway overload version.
--  141202  NaSalk  Added part_ownership_db_ parameter to Receive_Part_With_Posting to support company rental assets for NREC events.
--  141125  MaEelk  PRSC-4372, Modified Create_Count_Report__ and replaced the attribute name vales WAREHOUE, BAY_NO, ROW_NO, TIER_NO and BIN_NO with
--  141125          WAREHOUSE_ID, BAY_ID, ROW_ID, TIER_ID AND BIN_ID.
--  141122  MaEelk  PRSC-3144, Removed the comment Generic issue method. 'Obsolete in 10.6' from Issue_Part.
--  141106  LEPESE  PRSC-2214, Added availability_control_id_ as parameter when calling Inventory_Transaction_Hist_API.New from Issue_Part_Impl___.
--  141106          Added availability_control_id_ as a new parameter to methods Receive_Part and Receive_Part_Impl___. Added logic in Receive_Part_Impl___
--  141106          to reapply availability_control_id_ when receipts is result of reversal of an issue into new or empty stock record.
--  141103  ChJalk  PRSC-2216, Added missing assert safe anotation for exist_control_ , get_column_values_ and get_lov_values_.
--  141031  JeLise  Added filtering on location_group, abc_class, frequency_class and lifecycle_stage in cursor get_partloc in Create_Count_Report___.
--  141030  MaEelk  Added LOCATION_GROUP, ABC_CLASS, FREQUENCY_CLASS and 
--  141030          LIFECYCLE_STAGE to Create_Count_Report__ and Create_Count_Report___. 
--  141029  JeLise  PRSC-3299, Changed parameters in call to Counting_Report_API.New_List_Header.
--  141027  MaEelk  PRSC-3297 Removed From Warehouse To Warehouse, From Bay, To Bay, From Part No, To Part No and, 
--  141027          added Warehouse, Bay, Row, Tier, Bin, Storage Zone ID and Part No to the Count Report Parameters.
--  141010  NaSalk  Modified Transfer_Rental_Asset to restore available control id after issue and receipt transactions.
--  141008  LEPESE  PRSC-3231, Added parameters putaway_event_id_ and transport_task_id_ to methods Move_Part, Move_Part_Shipment and Move_Part_Impl___.
--  141008          Passed these values when calling Inventory_Putaway_Manager_API.Check_Storage_Requirements from Move_Part_Impl___.
--  141008          Added parameter ignore_transport_task_id_ to method Any_Parts_Exist, and passed it in call to Transport_Task_API.Any_Parts_Are_Inbound.
--  141008  NaSalk  Modified Check_Allow_Ownership_Mix to give correct error message for company rental assets.
--  140926  NaSalk  Modifed Receive_Part_Impl___, Receive_Part_With_Posting, Check_And_Update_By_Keys___, Transfer_Rental_Asset to 
--  140926          support rental asset ownership transfers.
--  140922  LEPESE  PRSC-2518, Added fetching of local_putaway_event_id_ in Refill_Using_Putaway. Added putaway_event_id_ when calling Putaway___
--  140922          and Inventory_Part_Loc_Pallet_API.Putaway from Optimize_Using_Putaway__.
--  140919  LEPESE  PRSC-2518, Added method Any_Parts_Exist.
--  140912  NaSalk  Modified Transfer_Rental_Asset to support company rental asset transfer to company owned.
--  140910  NaSalk  Modifed Receive_Part_Impl___, Fill_Part_Stock_Owner_Tmp___, Receipt_In_Place and Transfer_Rental_Asset
--  140910          to support ownershp change from company owned to company rental asset. Renamed Check_Receipt_In_Place___ 
--  140910          to Validate_Ownership_Mix___.
--  140903  AndDse  PRMF-1449, Modified Handle_Lot_Condition_Change and Handle_Serial_Condition_Change to only update records where qty_onhand != 0 OR qty_in_transit != 0.
--  140828  NaSalk  Modified Issue_Part_Impl___, Receive_Part_Impl___, Check_And_Update_By_Keys___, 
--  140828          Update___, Issue_Part_With_Posting___, Receive_Part_With_Posting and added Transfer_Rental_Asset
--  140828          for company owned to company rental asset ownership transfers.
--  140814  DaZase  PRSC-1611, Added extra column checks in methods Get_Column_Value_If_Unique, Create_Data_Capture_Lov and Record_With_Column_Value_Exist to avoid any risk of getting sql injection problems.
--  140812  NipKlk   Bug 118150, Modified the error messages with constants RESERVEDLESSZERO and ONHLESSAVAIL and added those error messages to new           
--  140812           implementation methods Reaise_Over_Issue_Error___() and Reaise_Qty_Neg_Error___() and removed error message ISSUE_TO_BIG.
--  140811  DaZase  PRSC-1612, Renamed Check_Valid_Value to Record_With_Column_Value_Exist and changed method to be more like other unique methods. 
--  140811          Removed cursor option 4 from Get_Column_Value_If_Unique since it was the same as 1. Also changed parameter order in these 2 methods.
--  140729  IsSalk   Bug 117972, Modified Receipt_In_Place() in order to allow ownership transfer when external quantity to transfer is greater than zero.
--  140728  BudKlk  Bug 117726, Added a new dynamic where for cursor_id_ 5 to filter the parts which has an available quantity and freeze_flag is 'N'
--                  in Get_Column_Value_If_Unique() method.
--  140724  ChBnlk   Bug 117727, Modified Create_Data_Capture_Lov() and Get_Column_Value_If_Unique() by adding a condition to the where clause to be used for the process
--  140724           RECEIVE_FROM_TRANSIT. Modified Check_Valid_Value() to add a new select statement to validate values in RECEIVE_FROM_TRANSIT process.
--  140619  ErFelk  Bug 115364, Modified Validate_Count_Part() by rephrasing an error message QTYCOUNTPOSITIVE. 
--  140619  DaZase  PRSC-1207, Changed Create_Data_Capture_Lov so it now only uses ORDER BY ASC.
--  140612  LEPESE  PRSC-805, modifications in Check_Valid_Move_Combinations to allow moving from Picking, Floor stock
--  140612          and Production Line into an ARRIVAL type location. so now same rules apply for ARRIVAL as for QA.
--  140523  DaZase  PBSC-9489, Added get_id_ 4 option to method Get_Column_Value_If_Unique.
--  140522  LEPESE  PBSC-9829, Modifications in Receipt_In_Place to reset the tracked_in_inventory flag in PartSerialCatalog
--  140522          before transferring a Receipt And Issue tracked serial from customer owned to company owned from CRO.
--  140506  HiWeGB  Added SUPPLIER RENTED and COMPANY RENTAL ASSET ownerships for counting
--  140505  MatKse  PBSC-8779, Modified Move_Part_Project by adding optional parameter catch_quantity_.
--  140505  IsSalk   Bug 116686, Modified Get_Inventory_Quantity() in order to calculate inventory quantity correctly.
--  140428  DaZase  PBSC-8556, Change in Check_Valid_Value for valid view 2, removed all string_null checks for this cursor since ACTIVITY_SEQ can be checked here and its 
--  140428          a number and no of the values checked for can even be null since they are keys here.
--  140410  RuLiLk   Bug 116226, Modified method Create_Count_Report___. Introduced new variable header_created_ to create report header only once. 
--  140328  LEPESE  PBSC-5936, Created methods Get_Move_Dest_Supply_Ctrl_Db and Get_Move_Dest_Avail_Ctrl_Id___.
--  140328          Moved functionality from Move_Part_Impl___ into Get_Move_Dest_Avail_Ctrl_Id___. Added call to 
--  140328          Get_Move_Dest_Avail_Ctrl_Id___ from Move_Part_Impl___. No change in functionality, just broken out the logic.
--  140321  LEPESE   PBSC-6065, Added parameter putaway_event_id_ to methods Putaway___, Putaway and Refill_Using_Putaway.
--  140311  SBalLK   Bug 115529, Removed Raise_Avail_Control_Error___() method. Modified Move_Part_Impl___() and Putaway___() to validate part movement using Check_Part_Movement_Allowed()
--  140311           from Part_Availability_Control_API.
--  140219  MeAblk   Modified method Get_Latest_Receipt_Location in order to avoid getting a remote warehouse location as the latest used location 
--  140219           when no remote warehouse defined as the destination warehouse id in the purchase order line. 
--  140218  MalLlk   Bug 115146, Modified Validate_Count_Part() by adding check for serial number when serial tracked at receipt and issue but not in inventory.
--  140218  JeLise   Added warehouse_id_ as new in parameter in Get_Latest_Receipt_Location.
--  140205  LEPESE   Added new error message CATCHNEEDSCOUNTING in method Check_Onhand_Decrease_Catch___.
--  140116  RuLiLk   Bug 114712, Modified method Create_Data_Capture_Lov() by enabling LOV values for the column contract.
--  130131  UdGnlk   Merged Bug 114214, Added Activity_Has_Parts_In_Stock() method to validate that selected project activity has inventory parts in stock.    
--  131230  AwWelk   PBSC-5298, Modified the parameters in Get_Company_Owned_Unit_Cost() and handled return logic only for company owned parts.
--  131220  DaZase   Bug 114022, Added get_id_ 3 handling in Get_Column_Value_If_Unique and lov_id_ 6 handling in Create_Data_Capture_Lov.
--  131220  DaZase   Bug 114021, Added parameter get_id_ to Get_Column_Value_If_Unique and some new dynamic where statement for get_id_ 2.
--  131220           Added new valid_id_ 5 handling for Check_Valid_Value. Added new where statements for dynamic lov for lov_id_ option 5 
--  131220           in Create_Data_Capture_Lov.                  
--  131107  DaZase   Bug 113189, Removed distinct from the cursor in method Get_Column_Value_If_Unique and renamed some variables and changed 
--  131107           an ELSE statement to ELSIF. Rewrote method Create_Data_Capture_Lov to use dynamic cursor instead. 
--  131107           View INVENTORY_PART_IN_STOCK_LOV25 replaced with INVENTORY_PART_IN_STOCK_LOV20 in Create_Data_Capture_Lov. 
--  131025  SWiclk   Bug 112203, Modified Create_Data_Capture_Lov() in order to filter activity seq and WDR no according to Location no.
--  130924  Cpeilk   Bug 110800, Modified Check_Consignment_Exist by adding default NULL parameter location_no_ 
--  130924           and changed return type from NUMBER to BOOLEAN.
--  130803  ErFelk   Bug 110715, Modified Move_Part_Impl___() by writing a generic code to fetch the transit_location_group_ for transactions. Removed the 
--  130803           transit_location_group_ fetching which was done in 'INVM-TRISS' transactions.
--  130912  UdGnlk   EBALL-174, Modified Receive_Part() for transaction 'CRO-EXR-IN' passing parameter expiration_date_.
--  130905  UdGnlk   EBALL-145, Modified Receive_Part() for code review comments receive part from stock at customer.
--  130809  ChJalk   TIBE-877, Removed the global variables.
--  130624  UdGnlk   EBALL-95, Modified Receive_Part() to call Inventory_Part_At_Customer_API.Decrease_Our_Qty_At_Customer() and the logic for business event 'CRO-EXR-IN'.
--  130613  ChFolk   Modified Receive_Part_Impl___ to create invent transaction interconnection between RETDIFSREC and RETINTPODS transactions.
--  130610  NaLrlk   Added part_ownership_db and owning_vendor_no parameters to Receive_Customer_Order_Return to support for rental CO lines.
--  130606  Asawlk   EBALL-37, Modified Get_Company_Owned_Unit_Cost() by using Invent_Part_Quantity_Util_API.Get_Company_Owned_Inventory() to get the inventory quantities.
--  130605  Asawlk   EBALL-37, Modified Cancel_Receipt_In_Place() to use the methods from Invent_Part_Quantity_Util_API when checking of related qunatities.
--  130604  Asawlk   EBALL-37, Modified Get_Lot_Batch_Track_Status() to check for records only in InventoryPartInStock.
--  130603  Asawlk   EBALL-37, Modified Issue_Part() by passing value to parameter remove_unit_cost_ when calling Issue_Part___() inside it.
--  130603  UdGnlk   EBALL-69, Removed conditional compilation section from Issue_Part() on part exchange transaction 'CRO-EXD-IN'.
--  130531  Asawlk   EBALL-37, Modified Check_Part_Exist() and Check_Individual_Exist() by removing a call to Inventory_Part_In_Transit_API. Also modified Get_Lot_Batch_Track_Status()
--  130531           to support quantities at customer. Modified Check_Split_Into_Serials___() and Rename_Serial() to use Invent_Part_Quantity_Util_API. Also modified message SPLITSERINV. 
--  130530  Asawlk   EBALL-37, Modified the method Get_Company_Owned_Inventory() by removing the call to Inventory_Part_In_Transit_API.Get_Total_Qty_In_Order_Transit.
--  130530           Also moved method Merge_Config_Lot_Serial_Tab___ to Invent_Part_Quantity_Util_API.
--  130530  NaSalk   Modified Return_Credit and Return_Rework to consider reserved quantity.
--  130528  Asawlk   EBALL-37, Modified Check_Quantity_Exist() by removing the call to Inventory_Part_In_Transit_API.Get_Total_Qty_In_Order_Transit().
--  130522  AwWelk   EBALL-77, Changed the Receipt_In_Place() by adding new parameter cost_detail_id_. Modified the Receipt_In_Place
--  130522           to fetch and pass the corresponding cost_detail_tab_ to the CRO-EX-ARR transaction.
--  130522  UdGnlk   EBALL-44, Modified Receipt_In_Place() call to transaction CRO-EX-ARR for transfer ownership from CRO exchange.
--  130510  UdGnlk   EBALL-66, Modified Issue_Part() to call Inventory_Part_At_Customer_API.Increase_Our_Qty_At_Customer() to support part exchange transaction 'CRO-EXD-IN'.
--  130426  Asawlk   EBALL-37, Modified Issue_Part() to call Inventory_Part_At_Customer_API.Increase_Our_Qty_At_Customer() and 
--  130426           Customer_Consignment_Stock_API.Increase_Consignment_Stock_Qty() for delivery confirmation and customer consignment stock increase respectively.
--  130411  ChFolk   Modified Receive_Part_Impl___ to create invent transaction interconnection between RETSHIPDIR and RETINTPODS transactions which is used in
--  130411           revaluation RETSHIPDIR using the cost of RETINTPODS in different sites.
--  130221  UdGnlk   Modified Undo_Return_Rework() to trigger transaction RINTORDTRX when transaction RETCORWINT occured. 
--  121116  NaLrlk   Modified Check_Ownership___, Check_Quantity_Exist, Check_Allow_Ownership_Mix, Find_Part___, Ownership_Conflict_Exists___, Find_And_Issue_Part_Neg 
--  121116           to consider the Supplier Rented and Company Rental Asset part ownerships.
--  130809  ChJalk   TIBE-877, Removed the global variables.
--  130411  GayDLK   Bug 109447, Modified Move_Part_Impl___() to pass to_expiration_date_ as the expiration date instead of expiration_date_ when calling 
--  130411           Inventory_Transaction_Hist_API.NEW().
--  130410  Asawlk   EBALL-37, Modified Issue_Part() and Cancel_Receipt_In_Place() to pass correct paramaters when calling methods in Inventory_Part_At_Customer_API. 
--  130322  Asawlk   EBALL-37, Modified Issue_Part() and Cancel_Receipt_In_Place() in order to make the calls to Inventory_Part_At_Customer_API static.
--  130322           Also removed the constant inst_InventoryPartAtCustomer_.
--  130308  GayDLK   Bug 108529, Modified the where clause of INVENTORY_PART_IN_STOCK_LOV3 view inorder to avoid considering Pallet handled locations. 
--  130214  BaMauk   WAX-760. Added configuration_id to Create_Data_Capture_Lov()
--  130214  VISALK   Bug 108032, Added new function Tran_Inv_Prt_Stk_To_Eng_Rev() for object connection LU transformation, from InventoryPartInStock to EngPartRevision.
--  130116  PraWlk   Bug 106676  Modified Issue_Part() by adding parameter allow_exceeding_available_qty_ and passed it when calling Issue_Part_Impl___().
--  130103  AyAmlk   Bug 106636, Added new parameter prevent_fifo_action_ to Unreceive_Part() and passed it when calling Issue_Part_Impl___().
--  121213  NipKlk   Bug 107075, Modified method Receive_Part_With_Posting() to validate the lowercase lot batch numbers to make them upper if no such lot batch number 
--  121213           available in Lot_Batch_Master.
--  121211  MAHPLK   Added warehouse_route_order, bay_route_order, row_route_order, tier_route_order and bin_route_order to INVENTORY_PART_IN_STOCK_TOTAL.
--  121211           Modified Find_Part___, Optimize_Using_Putaway__ and Refill_Using_Putaway to use route_order for sorting.
--  121210  Asawlk   Bug 107077, Modified Create_Count_Report___ to handle Warehouse_Bay_API.default_bay_id_ passed in as bay_no_from_ or bay_no_to_ when creating count report.  
--  121121  Jofise   Added Get_Column_Value_If_Unique.
--  121121  MAHPLK   Modified INVENTORY_PART_IN_STOCK_AVAIL view and Create_Count_Report___, Create_Count_Report_Lines___,  
--  121121           New_Count_Report_Line_Tmp___ method to implement route_order in counting report.
--  121116  NaLrlk   Modified Check_Ownership___, Check_Quantity_Exist, Check_Allow_Ownership_Mix, Find_Part___, Ownership_Conflict_Exists___, Find_And_Issue_Part_Neg 
--  121116           to consider the Supplier Rented and Company Rental Asset part ownerships.
--  120827  DaZase   Added method Create_Data_Capture_Lov.
--  121011  MaMalk   Bug 102071, Modified methods Check_Optimize_Using_Putaway and Optimize_Using_Putaway__ to handle DB value of the parameter location_type.
--  120827  DaZase   Added method Create_Data_Capture_Lov.--  121011  MaMalk   Bug 102071, Modified methods Check_Optimize_Using_Putaway and Optimize_Using_Putaway__ to handle DB value of the parameter location_type.
--  121009  PraWlk   Bug 102549, Moved Check_Activity_Seq___() and the calls to it away from InventoryPartInStock and into InventoryTransactionHist instead.
--  120913  GayDLK   Bug 101862, Added parameter prevent_fifo_action_ to Issue_Part_Impl___(). Passed it when calling to Inventory_Transaction_Hist_API.New(). 
--  120913           Modified Issue_Part() by adding parameters original_transaction_id_ and prevent_fifo_action_ and passed them when calling Issue_Part_Impl___() 
--  120913           inside Issue_Part(). FALSE is passed for parameter prevent_fifo_action_ in other places where Issue_Part_Impl___() is called. Removed the
--  120913           unnecessary call to Inventory_Transaction_Hist_API.Set_Original_Transaction_Id() from Unreceive_Part().  
--  120913  NALWLK   PCM-779, Modified in Find_And_Issue_Part_Neg() to add new parameter 'include_temp_table_locs_' 
--  120913           and used it to include or exclude locations in the temporary table. 
--  120907  NALWLK   PCM-779, Modified in Find_And_Issue_Part(),Find_And_Lock_Part(),Find_Part___() to add new parameter 'include_temp_table_locs_'.Also modified in
--  120907           Find_Part___ to include or exclude locations in the temporary table.                     
--  120827  AyAmlk   Bug 104632, Modified Find_And_Issue_Part_Neg() to support back flush to drive negative when having default location type Picking, Floor Stock or Production Schedule.
--  120815  NiDalk   Bug 104534, Added method Is_Frozen_For_Counting.
--  120504  LEPESE   Added check for inbound quantities on transport tasks in method Check_Allow_Ownership_Mix.
--  120407  Asawlk   Bug 102063, Added parameters inv_list_no_ and seq_no_ to Count_Part_No_Pallet() and Count_Part(). Also passed values to them when
--  120407           calling Count_Part() from Count_Part_No_Pallet(). Passed values to Order_ref1, Order_ref2 and and order_type_ when 
--  120407           Inventory_Transaction_Hist_API.NEW() is called inside Count_Part().   
--  120321  LEPESE   Improvement of error messages in Check_Ownership___.
--  120315  LEPESE   Added method Putaway___. Moved logic from Putaway to Putaway___. Changes in Optimize_Using_Putaway__
--  120315           to collect serial numbers into a collection and do a single Putaway on several serials.
--  120315  MaEelk   Removed the last parameter TRUE in call General_SYS.Init_Method from  non-implementation methods
--  120302  JeLise   Removed warehouse, bay_no, row_no, tier_no and bin_no from view INVENTORY_PART_IN_STOCK_LOV26.
--  120221  LEPESE   Redesigned methods Other_Parts_Exist, Other_Lots_Exist and Other_Conditions_Exist
--  120221           to also consider outbound quantities.
--  120220  Matkse   Added new view INVENTORY_PART_IN_STOCK_LOV26
--  120216  LEPESE   Added methods Optimize_Using_Putaway, Check_Optimize_Using_Putaway and Optimize_Using_Putaway__.
--  120202  LEPESE   Added method Refill_Other_Locations___ and called it from Insert___ and Update___.
--  120131  LEPESE   Added method Refill_Using_Putaway. Added column part_movement_control_db to view INVENTORY_PART_IN_STOCK_AVAIL.
--  120131           Changed conditions for triggering refill in method Update___. Now triggers for all "stock" locations.
--  120130  MaEelk   Modified Data Format of create_date, expiration_date, last-count_date, last_activity_date and receipt_date.
--  120124  Matkse   Modified view INVENTORY_PART_IN_STOCK_LOV3 by removing obsolete attributes lot_batch_no, serial_no, eng_chg_level, waiv_dev_rej_no, activity_seq
--  120124           Modified view INVENTORY_PART_IN_STOCK_LOV25 by adding new attribute qty_available and updating select order, column comments for location_no
--  120124           and where statement
--  120120  Matkse   Added attributes warehouse, bay_no, row_no, tier_no and bin_no to INVENTORY_PART_IN_STOCK_LOV3
--  120120  HimRlk   Bug 99673, Added new IN parameter to Purchase_Order_Receipt() and added new method call to connect ARRIVAL and POINV-WIP transactions.
--  120116  Matkse   added attribute pallet_handled to view INVENTORY_PART_IN_STOCK_LOV25
--  120112  Matkse   Added an undefine for the new view INVENTORY_PART_IN_STOCK_LOV25
--  120112  Matkse   Added new view INVENTORY_PART_IN_STOCK_LOV25
--  120111  Matkse   Added configuration_id, lot_batch_no, serial_no, eng_chg_level, waiv_dev_rej_no and activity_seq to INVENTORY_PART_IN_STOCK_LOV3
--  111229  PraWlk   Bug 100557, Added new method Check_Part_Revision_Exist___() and modified Find_And_Issue_Part_Neg() to do the issue from a stock record 
--  111229           having the latest part revision if no specific revision is specified in the method parameter.
--  111214  PraWlk   Bug 100376, Modified Issue_Part_With_Posting() and Receive_Part_With_Posting() by changing the length of error_desc_ to 2000 from 100
--  111214           to avoid buffer overflow error.
--  111214  LEPESE   Added method Ownership_Conflict_Exists___. Added calls to this method in Receive_Part_Impl___,
--  111214           Move_Part_Impl___, Check_Waiv_Dev_Rej_No___, Reserve_Part and Purchase_Order_Receipt. Added calls to
--  111214           Part_Serial_Catalog_API.Set_Tracked_In_Inventory() in Receive_Part_Impl___, Move_Part_Impl___
--  111214           and Reserve_Part. Idea is to skip changing serial_no to '*' if that creates an ownership conflict.
--  111129  LEPESE   Added use of Utility_SYS.String_To_Number for sorting of warehouse, bay, row, tier and bin
--  111129           in methods Create_Count_Report___ and Create_Count_Report_Lines___.
--  111123  PraWlk   Bug 100029, Optimized views INVENTORY_PART_IN_STOCK_OWNER and INVENTORY_PART_IN_STOCK_TOTAL by eliminating outer joins 
--  111123           and method calls and using in line select statements instead.  
--  111121  LEPESE   Added parameter part_no_ to method Get_Serial_No_For_Stock.
--  111118  LEPESE   Added implementation for method Identify_Serials.
--  111118  LEPESE   Added dummy value for pallet_id in cursor get_location in method Find_Part___.
--  111115  RaKalk   Modified Check_Split_Into_Serials___ to use Validate_serial function in Temporary _part_Tracking_Api.
--  111114  RaKalk   Added Procedure Identify_Serials.
--  111109  LEPESE   Modifications in method Find_Part___: Removed sorting on expiration_date, receipt_date,
--  111109           lot_batch_no and serial_no from cursor get_location. Instead added sorting on location_no.
--  111109           Fetch result into collection available_stock_tab_ and call
--  111109           Invent_Part_Putaway_Zone_API.Get_Zone_And_Fifo_Sorted_Stock to sort by putaway zone and fifo.
--  111028  LEPESE   Added calls to Inventory_Putaway_Manager_API.Check_Storage_Requirements
--  111028           in Receive_Part_Impl___ and Move_Part_Impl___.
--  111027  NISMLK   SMA-285, Increased revision_no length to STRING(6) in column comments.
--  111027  NISMLK   SMA-285, Increased eng_chg_level length to VARCHAR2(6)/STRING(6).
--  111024  MaEelk   Added UAS filter to INVENTORY_PART_IN_STOCK_SUM and INVENTORY_PART_IN_STOCK_LOV.
--  111021  MaEelk   Added UAS filter to INVENTORY_PART_LOCATION, INVENTORY_PART_IN_STOCK_LOV4, INVENTORY_PART_IN_STOCK_LOV5, 
--  111021           INVENTORY_PART_IN_STOCK_LOV6 and INVENTORY_PART_IN_STOCK_LOV7.
--  111014  LEPESE   Improved error message COUNTSERIALEXIST in method Validate_Count_Part.
--  111013  DaZase   Added info handling and a new info message to Receive_Part_From_Transit__.
--  110922  MaEelk   Modified Check_Allow_Ownership_Mix to raise different error messages when for multiple ownership.
--  110916  Darklk   Bug 98988, Modified Create_Count_Report to avoid creating another background job when it's invoked from a schedule job.
--  110913  MaEelk   Corrected Create_Count_Report___ to fetch part_no_in_part_rec_ soon afer the part information is fetched.
--  110824  LEPESE   Use Error_SYS.Record_Not_Exist() instead of Error_SYS.Record_Removed() in Lock_By_Keys___.
--  110818  LEPESE   Modification in Rename_Serial to try to use the location_no from the latest transaction when renaming
--  110818           a serial for a part that is serial tracked only at receipt and issue. 
--  110817  PraWlk   Bug 98303, Removed the "ip" prefix on the column references of INVENTORY_PART_IN_STOCK_TOTAL view definition.  
--  110817  PraWlk   Bug 98303, Used the method Condition_Code_Manager_API.Get_Condition_Code() to eliminate the outer joins in
--  110817           INVENTORY_PART_IN_STOCK_TOTAL view to improve the performance where the decode section for condition code 
--  110817           is also encapsulated with the same method. 
--  110802  MaEelk  Replaced the obsolete method call Print_Server_SYS.Enumerate_Printer_Id with Logical_Printer_API.Enumerate_Printer_Id.
--  110801  UdGnlk   Correct the error in view INVENTORY_PART_IN_STOCK_ROT. 
--  110718  IsSalk   Bug 98067, Modified Make_Individuals() by increasing the size of issue_msg_ to avoid oracle errors.
--  110715  MaEelk   Added user allowed site filter to INVENTORY_PART_IN_STOCK_ROT.
--  110707  MaEelk   Added user allowed site filter to INVENTORY_PART_IN_STOCK_LOV8, INVENTORY_PART_IN_STOCK_LOV19 and INVENTORY_PART_IN_STOCK_LOV20.
--  110627  PraWlk   Bug 95368, Modified Cancel_Receipt_In_Place() by passing a dummy variable for the out parameter cost_successfully_removed_
--  110627           when calling Inventory_Transaction_Hist_API.Remove_Fifo_Lifo_Cost().
--  110627  PraWlk   Bug 94346, Modified method Find_Part___() by adding lot_batch_no and serial_no to the order by clause in cursor get_location. 
--  110615  LEPESE   Modification in Rename_Serial to make it possible to rename a serial which is in inventory
--  110615           even when the part is only Receipt and Issue Serial Tracked. 
--  110609  MaRalk   Replaced NULL by expiration_date_ in the method call for Inventory_Transaction_Hist_API.NEW 
--  110609           inside Move_Part_Impl___ in order to get the correct expiration date for PICK-IN transaction.  
--  110526  LEPESE   Correction in Receipt_In_Place to use index_ for transfer_tab_ when calling
--  110526           Inventory_Transaction_Hist_API.Set_Previous_Ownership.
--  110526           Improved error message OWNERMISMATCHATLOC in method Check_Allow_Ownership_Mix.
--  110526  ShKolk   Added General_SYS for Get_Consumed_Carrying_Capacity() and Get_Consumed_Volume_Capacity().
--  110520  LEPESE   Added methods Fill_Part_Stock_Owner_Tmp___ and Check_Receipt_In_Place___. Added calls to these methods
--  110520           from Receipt_In_Place to handle check against Mix Of Ownership. Added condition in Receive_Part_Impl___
--  110520           to avoid calling Check_Allow_Ownership_Mix for transaction 'XO-ARRIVAL'.
--  110518  LEPESE   Modifications in Reserve_Part to avoid moving of quantity to serial_no = '*' when unreserving
--  110518           a Recept And Issue Serial Tracked on a shipment location. 
--  110514  MaEelk   Added missing assert safe comment to Check_Ownership___
--  110509  NiBalk   Added new default parameter unit_of_measure_type_ to Get_Inventory_Qty_Onhand() method in order to handle catch quantity correctly.
--  110509  MaEelk   Made the parameter change to the call Receive_Purchase_Order_API.Create_Consignment_Transaction in Move_Part_Impl___.
--  110504  JeLise   Modified procedure Create_Count_Report___ to check unconfirmed or rejected part locations
--  110504           before quantities are counted.
--  110428  JeLise   Added check on part_ownership_db_ in Receive_Part_With_Posting.
--  110427  MatKSE   Modified Count_Part() to handle lack of ownership for parts with qty = 0 when performing count report.
--  110420  MaEelk   Modified Issue_Part_Impl___ to handle ownership for negative quantity on hand allowed parts.
--  110408  LEPESE   Added calls to Transport_Task_API.Reduce_Qty_On_Unexecuted_Tasks in Issue_Part_Impl___.
--  110408  DaZase   Added Other_Lots_Exist.
--  110330  ChCrlk   Created view INVENT_PART_IN_STOCK_NOPAL_LOV. 
--  110324  LEPESE   Small correction in Validate_Count_Part to use package globals db_not_serial_tracking_
--  110324           and db_false_ instead of public globals in IID packages.
--  110311  LEPESE   Modification in Validate_Count_Part to allow counting result with serial_no != '*' when
--  110311           the part is serial tracked only at Issue and Receipt.
--  110311  DaZase   Removed obsolete methods Get_Last_Pallet_Location and Get_Last_Receipt_Date___.
--  110309  JeLise   Added Receive_Part with out parameter info_.
--  110309  DaZase   Changed calls to Inventory_Part_Pallet_API.Check_Exist so it uses Inventory_Part_API.Pallet_Handled instead.
--  110309  LEPESE   Modifications in method Modify_Owning_Customer_No to handle parts that are serial tracked
--  110309           only during Receipt and Issue but not serial tracked In Inventory.
--  110309           Modification in Move_Part to accept Identification of Serials for intrasite moves when 
--  110309           the move is also consuming Supplier Consignment Stock.
--  110308  LEPESE   Modifications in Cancel_Receipt_In_Place to handle parts that are serial tracked
--  110308           only during Receipt and Issue but not serial tracked In Inventory.
--  110307  LEPESE   Modifications in Receipt_In_Place to handle split of serials. Added call to Split_Into_Serials.
--  ----------------------- Blackbird Merge End -----------------------------
--  110302  harplk   Merge Blackbird Code
--  101007  ImFelk   BB10, Added column operational_condition to views INVENTORY_PART_IN_STOCK_DELIV and INVENTORY_PART_IN_STOCK_TOTAL.
--  100916  ImFelk   BB10, Added paramater operational_condition_db_ to methods Receive_Part, Purchase_Order_Receipt, Make_Individuals,
--  100916           Receive_Part_Impl___,Receive_Part_From_Transit__, Unissue_Part, Receive_Part_With_Posting, Receipt_In_Place.
--  ----------------------- Blackbird Merge Start -----------------------------
--  110225  ChJalk   Moved 'User Allowed Site' Default Where condition from client to base view and view15.
--  110224  LEPESE   Modifications in Count_Part_No_Pallet and Count_Part to handle the situation where
--  110224           a counting result is reported for a part that is only Receipt and Issue Serial Tracked
--  110224           (not serial tracked in Inventory). The serial numbers matching the counting difference
--  110224           will be fetched using method Temporary_Part_Tracking_API.Get_Serials_And_Remove_Session().
--  110223  JaJalk   Added the missing null parameter for call Inventory_Transaction_Hist_API.NEW the in Receive_Part_Impl___.
--  110222  LEPESE   Added method Check_Split_Into_Serials___ and called it from Split_Into_Serials and Validate_Count_Part.
--  110222           Added parameter part_tracking_session_id_ to method Count_Part_No_Pallet.
--  110222           Added validation logic for parts which are only receipt and issue serial tracked in Validate_Count_Part.
--  110222           Added parameters qty_difference_ and part_tracking_session_id_ to method Validate_Count_Part.
--  110221  RaKalk   Added code to accept PART_TRACKING_SESSION_ID attribute in procedure Submit_Part_To_Mrb
--  110218  LEPESE   Added logic in Move_Part_Impl___ to only require serial_no != '*' when moving from Arrival or QA
--  110218           if the full PO Receipt Quantity has not been split into serials yet.
--  110218  LEPESE   Added error messages ALLSERIALSIN, SERIALDEFINED and MORESERIALSIN to method Make_Individuals.
--  110217  LEPESE   Added logic in Reserve_Part to create a record with the requested serial if it does not exist in 
--  110217           the specified stock record. This is only for Receipt and Issue Serial Tracked parts. 
--  110217           Requires that the serial is In Inventory and not identified on any other stock record.
--  110210  MaEelk   Modified Count_Part to pass company ownerd ownership when inserting to new record.
--  110209  JeLise   Added in parameter perform_putaway_db_ and call to Inventory_Putaway_Manager_API.Putaway_Part in Receive_Part.
--  110207  DaZase   Added Other_Conditions_Exist.
--  110207  JeLise   Added Putaway.
--  110203  KiSalk   Moved 'User Allowed Site' Default Where condition from client to VIEW5 and VIEW6.
--  110203  DaZase   Added Other_Parts_Exist.
--  110126  DaZase   Added Get_Consumed_Volume_Capacity.
--  110110  DaZase   Added Get_Consumed_Carrying_Capacity.
--  101230  LEPESE   Added parameter part_tracking_session_id_ to method Move_Part and added logic for performing
--  101230           split into serials when the session_id has a value.
--  101227  LEPESE   Modifications in Scrap_Part and Scrap_Part___ for catch unit handling.
--  101210  LEPESE   Added logic in Issue_Part_Impl___ to split into serials if the part is not serial
--  101210           tracked in inventory but instead serial tracked at receipt and issue.
--  101210  LEPESE   Changed Split_Into_Serials___ into public Split_Into_Serials. Removed public
--  101210           interface Split_Reservation_Into_Serials.  
--  101209  RaKalk   Added part tracking session id parameter to Scrap_Part procedure. 
--  101209           Moved existing logic in Scrap_Part to Scrap_Part___ and implemented split in to serials logic in Scrap_Part.
--  101208  LEPESE   Modified Get_Serial_No_For_Stock to avoid transforming serial_no to '*' when moving to a
--  101208           shipment type location. 
--  101201  LEPESE   Removed Split_And_Issue_With_Posting. Added Issue_Part_With_Posting___. Added parameter
--  101201           part_tracking_session_id_ to method Issue_Part_With_Posting and moved its implementation to
--  101201           Issue_Part_With_Posting___. Calls Issue_Part_With_Posting___ once for each serial in serial_catch_tab_.
--  101126  LEPESE   Added methods Split_Into_Serials___ and Split_And_Issue_With_Posting. Made some modifications
--  101126           in Unissue_And_Move_Part to handle the situation where the unissue of a serial creates/updates
--  101126           a stock record with serial_no = '*' because the part is not serial tracked In Inventory.
--  101126  LEPESE   Modifications in Split_Reservation_Into_Serials to validate that ownership, owner, 
--  101126           configuration and lot/batch are the same on the serial as on the stock record.
--  101126  LEPESE   Modification in Update___ to make sure that Remove_Empty_Tracked_Record___ is called also
--  101126           when qty_in_transit is updated. Modification in Move_Part_Impl___ to make sure that a real 
--  101126           serial number is never replaced with star when moving into transit.
--  101125  LEPESE   Modified the reduction of qty_in_transit during "Receipt from Transit" in Receive_Part_Impl___. 
--  101125           This is done because of the new Receipt and Issue Serial Tracking functionality where the quantity
--  101125           might end up on a new record when received, because the serial number will be replaced with a star '*'.
--  101125           Still we need to recude qty_in_transit on the old record having the original serial number. 
--  101125  LEPESE   Removed validation Unpack_Check_Insert___ and Unpack_Check_Update___ that gave error message
--  101125           when trying to reserve on ARRIVAL and QA locations. This must be allowed now since we will use
--  101125           transport task functionality for the Putaway logic. Removed restriction for the same location types
--  101125           in method Reserve_For_Transport. Keep validation as is in Reserve_Part so that only transport tasks
--  101125           will be able to reserved on ARRIVAL, QA, PALLET ARRIVAL, PALLET QUALITY.
--  101123  LEPESE   Added logic in Move_Part_Impl___ to avoid resetting serial_no to '*' when method is called
--  101123           due to a "split stock record into serials" operation.
--  101122  LEPESE   Changed method Get_Serial_No_For_Stock___ into public Get_Serial_No_For_Stock.
--  101119  LEPESE   Modification in Purchase_Order_Receipt to give error message if PO arrival into stock location
--  101119           without serial numbers for a "Receipt and Issue Serial Tracked" part. 
--  101119           Modification in Move_Part_Impl___ to remove the specific serial numbers from the stock records
--  101119           when moving serials form Arrival or Qa into a stock location, if not In Inventory serial track.
--  101119           New validation in Make_Individuals to allow this only on Arrival and QA location types.
--  101115  LEPESE   Added methods Check_And_Update_By_Keys___ and Remove_Empty_Tracked_Record___. Replaced usage of
--  101115           Unpack_Check_Update___ plus Update___ with Check_And_Update_By_Keys___ which encapsulates both.
--  101115           Call to Remove_Empty_Tracked_Record___ from Update___ when tracked part and zero quantities.
--  101112  LEPESE   Added logic in method Reserve_Part to move the quantity from a serial-specific stock record to a
--  101112           record having serial_no = 0 when unreserving a serial and receipt_issue_serial_track is enabled
--  101112           but serial_tracking_code (In Inventory serial tracking) is disabled.
--  101112           Small modification of conditions for error message ILLQTYSERIAL in Move_Part_Impl___ to allow moving
--  101112           quantity from serial_no != '*' to serial_no = '*'.
--  101110  LEPESE   Modifications of Unpack_Check_Insert___ and Unpack_Check_Update___ to allow serial-number
--  101110           specific records when receipt_issue_serial_track = 'TRUE'.
--  101110  LEPESE   Created method Split_Reservation_Into_Serials.
--  101104  PraWlk   Bug 93907, Modified Receive_Customer_Order_Return() by removing previously added if condition for 93907.
--  101104           Added a new if condition to avoid calling Receive_Part() when issue_transaction_qty_ is zero.
--  101103  LEPESE   Removed parameter record_exists_ from method Check_Waiv_Dev_Rej_No___. Modifications in method 
--  101103           Purchase_Order_Receipt to handle the situation when the part is only serial tracked during receipt
--  101103           and not in inventory. 
--  101102  PraWlk   Bug 93907, Modified Receive_Customer_Order_Return() by adding a if condition to check whether the CO
--  101102           shipment transactions exists in Inventory_Part_Fifo_Issue_Tab.
--  101101  LEPESE   Replaced hard-coded strings 'SERIAL TRACKING' and 'NOT SERIAL TRACKING' with references towards constants
--  101101           Part_Serial_Tracking_API.db_serial_tracking and Part_Serial_Tracking_API.db_not_serial_tracking.
--  101101           Added global package constants db_serial_tracking_, db_not_serial_tracking_, db_true_ and db_false_.
--  101101           Replaced all occurences of strings 'TRUE' and 'FALSE' with db_true_ and db_false_.
--  101101           Added parameter part_catalog_rec_ to methods Issue_Part_Impl___, Receive_Part_Impl___, Unpack_Check_Insert___
--  101101           and Unpack_Check_Update___. Added methods Get_Part_Catalog_Rec___ and Get_Serial_No_For_Stock___. 
--  101029  PraWlk   Bug 93902, Modified error message NOENOUGHQTY by correcting spelling mistakes.
--  101026  LEPESE   Removed method Get_Serial_Track_Status. Added method Quantity_Exists.
--  101021  PraWlk   Bug 89847, Added method Receive_Customer_Order_Return() to unconsume the CO shipment transactions
--  101021           correctly instead of creating new FIFO stack records when created when the item is returned.
--  101015  GayDLK   Bug 93374, Changed the place where the comments were added from the previous correction of the same bug.
--  101007  ImFelk   BB10, Added column operational_condition to views INVENTORY_PART_IN_STOCK_DELIV and INVENTORY_PART_IN_STOCK_TOTAL.
--  101005  DeKoLK   EANE-3741, Moved 'User Allowed Site' in Default Where condition from client.
--  101005  GayDLK   Bug 93374, Added a '-' as the Lov Flag for QTY_ONHAND and QTY_RESERVED columns in
--  101005           both INVENTORY_PART_IN_STOCK_RES and INVENTORY_PART_IN_STOCK_TOTAL views.
--  100917  DAYJLK   Bug 89720, Modified procedure Create_Count_Report___ to avoid repeated fetch
--  100917           of unchanged data for a given part_no and location_no combination.
--  100916  ImFelk   BB10, Added paramater operational_condition_db_ to methods Receive_Part, Purchase_Order_Receipt, Make_Individuals,
--  100916           Receive_Part_Impl___,Receive_Part_From_Transit__, Unissue_Part, Receive_Part_With_Posting, Receipt_In_Place.
--  100826  MalLlk   Modified method Scrap_Part to pass owning_vendor_no to Inventory_Transaction_Hist_API.NEW.
--  100813  MalLlk   Modified method Scrap_Part to pass part ownership details to Inventory_Transaction_Hist_API.NEW.
--  100729  MaEelk   Modified the error messages OWNERMISMATCH and CONSIGNMENTEXISTS
--  100723  ShKolk   Modified methods Get_Starting_Balance, Get_Avail_Plan_Qty_Loc_Type and Get_Inventory_Quantity
--  100723           to consider min_durab_days_planning in quantity calculations. 
--  100715  GayDLK   Bug 89478, Added new overloaded method Get_Company_Owned_Inventory() and new method 
--  100715           Merge_Config_Lot_Serial_Tab___().
--  100712  MaRalk   Added new method Raise_Loc_Type_Reserv_Error___ in order to handle NOARRIVALRES
--  100712           error message in one place and replaced within Unpack_Check_Insert___,
--  100712           Unpack_Check_Update___ and Reserve_Part methods. Removed local variable
--  100712           order_type_db_ from Cancel_Receipt_In_Place and instead hardcoded
--  100712           in get_transactions cursor.
--  100709  MaRalk   Added new method Raise_Rotable_Pool_Error___ in order to handle 
--  100709           INROTABLEPOOL error message in one place and replaced within Check_Ownership___
--  100709           and Receipt_In_Place methods. Modified Cancel_Receipt_In_Place.
--  100630  Asawlk   Bug 91273, Added new method Get_Company_Owned_Unit_Cost().
--  100629  MaEelk   Added Externally_Owned_Stock_Exist to check if there exists an externally owned stock
--  100629           for cntract, part_no and location_no combination or not.
--  100629  MaRalk   Restructured the Cancel_Receipt_In_Place in order to support mix ownership functionality.
--  100629           Moved validations in Inv_Part_Ownership_Manager_API.Validate_Cancel_Per_Line
--  100629           into Cancel_Receipt_In_Place.
--  100624  GayDLK   Bug 90479, Modified the PROCEDURE Move_Part_Impl___() by increasing the length of the 
--  100624           int_move_comment_ variable to 2000 characters.
--  100622  MaRalk   Modified Receipt_In_Place. Modified method parameters in Handle_Owning_Cust_Change___.
--  100622           Moved error message SAMECUST from Inv_Part_Ownership_Manager_API.Transfer_Cust_To_Cust_Stock___ 
--  100622           to Modify_Owning_Customer_No.
--  100618  MaRalk   Moved validations which were in Inv_Part_Ownership_Manager_API.Validate_Transfer_To_Company
--  100618           to Receipt_In_Place and modified the method.
--  100615  MaRalk   Modified the checking condition for error message OWNERMISMATCH in Check_Ownership___ method.
--  100615           Added new method Handle_Owning_Cust_Change___ to move the logic of
--  100615           Inv_Part_Ownership_Manager_API.Transfer_Cust_To_Cust_Stock___ method and modified Update___.
--  100609  DAYJLK   Bug 90997, Modified Insert___ to set last count completed date for newrec_.last_count_date when empty.
--  100531  MaEelk   Modified the conditions that made for calling Check_Allow_Ownership_Mix from Receive_Part_Impl___
--  100531           and Issue_Part_Impl___. Changed the signature of Check_Ownership_Move_Part.
--  100531           Removed the call to Check_Ownership_Move_Part FROM Make_Individuals.
--  100526  MaEelk   Removed calling set_Correct_Owner___ from Unpack_Check_Update___ and Check_Allow_Ownership_Mix.
--  100526  MaEelk   Instead changed the logic of Check_Ownership___ and Check_Allow_Ownership_Mix.
--  100524  MaEelk   Modified parrameter values of contract, part_no and location_no
--  100524           when calling Check_Allow_Ownership_Mix IN Move_Part_Impl___.
--  100521  MaEelk   Added public methods Check_Ownership_Move_Part. This will make validation against moving a part between locations.
--  100521           Added Check_Allow_Ownership_Mix___ TO make sure THE ownership IS allowed TO be mixed IN THE part location LEVEL OR NOT.
--  100521           Called Check_Allow_Ownership_Mix___ from Receive_Part_Impl___ and Move_Part_Impl___.
--  100521  MaRalk   Modified the condition for error message OWNERMISMATCH within Check_Ownership___ method.
--  100520  MaRalk   Modified Receipt_In_Place to support ownership transfer from customer to company
--  100520           with mix ownership functionality.
--  100518  MaEelk   Modified the logic of set_Correct_Owner___ so it does not set ownership_null when qty_onhand and qty_in_transit are zero.
--  100514  MaEelk   Added Set_Correct_Owner___ and modified Unpack_Check_Update___ and Insert___
--  100514           to set ownership information null when the qty onhand is zero and and the qty in transit is zero,
--  100514           to set owning customer no null when the ownership is not of Customer Owned Stock and,
--  100514           to set the owning vendor no null when the ownership is not of Consignment, Supplier Loaned
--  100514           or Supplier Owned Stock.
--  100513  MaRalk   Modified Check_Ownership___ to support transfer of ownership between customers.
--  100510  KRPELK   Merge Rose Method Documentation.
--  100506  MaEelk   Created Check_Move_Ownersip___ to make validations against part ownership detail
--  100506           in a MOVE part TRANSACTION. Replaced the calls to Inv_Part_Ownership_Manager_API.Move_Part
--  100506           with Check_Move_Ownersip___ in Move_Part_Impl___ and Make_Individuals.
--  100506           Modified the methods Move_Part_Impl___ and Make_Individuals to work the ownership
--  100506           in Move Part and Split into Serial Functionality.
--  100504  MaRalk   Removed obsolete function Check_Consignment_Stock.
--  100504  Nuvelk   TWIN PEAKS Merge.
--  100430  MaEelk   Removed calls to Inv_Part_Ownership_Manager_API.Inventory_transaction from Receive_Part_Impl___ and
--  100430           Issue_Part_Impl___. Modified the signature of Check_Ownership___ removed exceptions raised from it.
--  100430           Removed the constant inst_ConsignmentConsumption.
--  100421  JeLise   Added three in parameters to Get_Latest_Receipt_Location and changed Get_Arrival_Location.
--  100420  MaEelk   Removed the call to Inv_Part_Ownership_Manager_API.Unissue_Part from Unissue_Part.
--  100420  MaRalk   Modified reference by name method calls to Inventory_Transaction_Hist_API.Create_And_Account 
--  100420           within Issue_Part method.
--  100420  MaEelk   Removed the public method Undo_Consignment_Consumption  and moved the logic to the new implementation method
--  100420           Undo_Consignment_Consum___. Modified Issue_Part_Impl___ to work the ownership with Issue functionality.
--  100409  JeLise   Made additional changes in Get_Latest_Receipt_Location.
--  100412  MaRalk   Moved methods Check_Consignment_Exist, Check_Consignment_Stock and Modify_Owning_Customer_No from the LU InventoryPartStockOwner.
--  100407  MaEelk   Moved all ownsership validations in Consignment_Stock_Manager_API.Inventory_Transaction
--  100407           and Inv_Part_Ownership_Manager_API.Inventory_Transaction to Check_Ownership___.
--  100407  MaRalk   Modified reference by name method calls to Inventory_Transaction_Hist_API.New within 
--  100407           Issue_Part_Impl___, Move_Part_Impl___ and Make_Individuals methods.
--  100401  MaEelk   Added Check_Ownership___ to make all validations regarding ownsership. Added Check_Owning_Customer_No___
--  100401           and Check_Owning_Vendor_No___ to make sure the Customer Order or Purch modules are installed in the system.
--  100325  MaEelk   Added 3 public attributes Part_Ownership, owning_Customer_No and Owning_Vendor_No to the LU
--  100325           and PUBLIC rec AND INVENTORY_PART_IN_STOCK_PUB. Added Get_Part_Ownership_Db tto fetch the db value of the ownership.
--  100335           Added  Get_Owner and Get_Owner_Name to fetch the owner detial of a given record.
--  100218  PraWlk   Bug 87698, Modified Find_And_Issue_Part_Neg() to create an empty InventoryPartInStock record on the 
--  100218           default location if no stock records can be found for the part. Added Create_Empty_Stock_Record___()
--  100218           and added default parameter skip_qty_check_ for Check_Part_Exist().  
--  100121  PraWlk   Bug 88017, Modified Unpack_Check_Update___() by moving the call to Check_Activity_Seq___() to do the
--  101021           validation only when the quantities on hand or in transit are changed.
--  091209  THTHLK   Defect DE368, Modified Issue_Part_Impl___, Move_Part_Impl___, Move_Part, Return_Rework, 
--                   Return_Credit, Issue_Part, Find_And_Issue_Part_Neg, Issue_Part_With_Posting, Unreceive_Part, 
--                   Move_Part_Project, Move_Part_Shipment, Make_Individuals, Connect_To_Lot_Batch, 
--                   Change_Waiv_Dev_Rej_No, Rename_Serial, Issue_Supplier_Owned_Stock, Scrap_Credit.
--  090112  RoJalk   Removed the parameter include_all_ from Get_Inventory_Quantity methods. 
--  090101  RoJalk   Added parameter include_all_ to methods Get_Inventory_Quantity.
--  090101           Modified the cursor get_qty in Get_Inventory_Quantity to consider
--  090101           both standard planned and project inventory stock.
--  091222  KAYOLK   Modified the methods Issue_Part_With_Posting() and Receive_Part_With_Posting() for renaming the
--  091222           code part cost_center, object_no, and project_no as codeno_b, codeno_e and codeno_f respectively.
--  100408  JeLise   Added check on receipts_blocked in Get_Latest_Receipt_Location.
--  100331  JeLise   Added where statement qty_on_hand > 0 in INVENTORY_PART_IN_STOCK_SUM and INVENTORY_PART_IN_STOCK_LOV.
--  100122  DaZase   Added extra where statement in Get_Last_Receipt_Date___ cursor.
--  100120  DaZase   Added new checks and calls to Move_Part_Impl___ in Receive_Part_Impl___/Move_Part_Impl___.
--  ------------------------- Best Price --------------------------------------
--  091218  SaWjlk   Bug 85239, Made Get_Closest_Work_Day___ () public and modified Make_Onhand_Analysis_Impl___() to 
--  091218           replace usage of Get_Closest_Work_Day___() with Get_Closest_Work_Day().
--  091217  PraWlk   Bug 84712, Added new parameter to Receive_Part_Impl___ and Receive_Part methods. Modified all the calls to 
--  091217           Receive_Part_Impl___  in Receive_Part_From_Transit__ , Unissue_Part, Receive_Part_With_Posting and 
--  091217           Purchase_Order_Receipt methods.
--  091130  PraWlk   Bug 86675, In Move_Part_Impl___ replaced the call to Activity_API.Validate_Inventory_Transfer with 
--  091130           two calls to Activity_API.Validate_Activity_State. In Check_Activity_Seq___ replaced the call to
--  091130           Activity_API.Validate_Invent_Balance_Change with one call to Activity_API.Validate_Activity_State.
--  091117  ShKolk   Bug 86768, Merge IPR to APP75 core.
--  091117  PraWlk   Bug 86917, Modified error messages SERIALMND, LOTBATMND, LOTBATNOTMND and SERIALNOTMND to make them
--  091117           more clear to the user.
--  091116  SaWjlk   Bug 86802, Added procedure call to Undo_Consignment_Consumption in Unissue_Part procedure 
--  091116           and changed the condition to include CO-PROJREC in Undo_Consignment_Consumption procedure.
--  091113  PraWlk   Bug 86917, Modified error messages SERIALMND, LOTBATMND, LOTBATNOTMND and SERIALNOTMND to include
--  091113           the part number. Added Raise_Serial_Req_Error___, Raise_Serial_Not_Req_Error___, Raise_Lot_Bat_Req_Error___ and 
--  091113           Raise_Lot_Bat_Not_Req_Error___ methods to avoid repeating of above error messages.
--  091112  PraWlk   Bug 86273, Removed the assignment of contract values to int_move_comment_ in Move_Part_Impl___
--  091112           and moved the code down to create postings for the first transaction after connecting first and 
--  091112           second transaction together.
--  091001  SaWjlk   Bug 86020, Added input parameter to the procedure Reserve_Part to restrict the update of  
--  091001           the record when the manual reservation is done, if a part availability control is not set to trigger it. 
--  090929  ChFolk   Removed parameter part_catalog_rec_ from Check_Onhand_Increase_Catch___, Check_Onhand_Decrease_Catch___,
--  090929           Check_Onhand_Nochange_Catch___, Check_Transi_Increase_Catch___ and Check_Transi_Decrease_Catch___.
--  090929           Removed cursor get_count_rec in Rename_Serial which is no used inside the method.
--  090929           Removed unused variables in the package.
--  090925  MaEelk   Removed unused views INVENTORY_PART_IN_STOCK_LOV1 and INVENTORY_PART_IN_STOCK_LOV2
--  090924  ChFolk   Removed function Calculate_M88_Curr_Value___ which is no longer used.
--  --------------------------------------- 14.0.0 --------------------------------------------------------------
--  091218  SaWjlk   Bug 85239, Made Get_Closest_Work_Day___ () public and modified Make_Onhand_Analysis_Impl___() to 
--  091218           replace usage of Get_Closest_Work_Day___() with Get_Closest_Work_Day().
--  091217  PraWlk   Bug 84712, Added new parameter to Receive_Part_Impl___ and Receive_Part methods. Modified all the calls to 
--  091217           Receive_Part_Impl___  in Receive_Part_From_Transit__ , Unissue_Part, Receive_Part_With_Posting and 
--  091217           Purchase_Order_Receipt methods.
--  091130  PraWlk   Bug 86675, In Move_Part_Impl___ replaced the call to Activity_API.Validate_Inventory_Transfer with 
--  091130           two calls to Activity_API.Validate_Activity_State. In Check_Activity_Seq___ replaced the call to
--  091130           Activity_API.Validate_Invent_Balance_Change with one call to Activity_API.Validate_Activity_State.
--  091117  ShKolk   Bug 86768, Merge IPR to APP75 core.
--  091117  PraWlk   Bug 86917, Modified error messages SERIALMND, LOTBATMND, LOTBATNOTMND and SERIALNOTMND to make them
--  091117           more clear to the user.
--  091116  SaWjlk   Bug 86802, Added procedure call to Undo_Consignment_Consumption in Unissue_Part procedure 
--  091116           and changed the condition to include CO-PROJREC in Undo_Consignment_Consumption procedure.
--  091113  PraWlk   Bug 86917, Modified error messages SERIALMND, LOTBATMND, LOTBATNOTMND and SERIALNOTMND to include
--  091113           the part number. Added Raise_Serial_Req_Error___, Raise_Serial_Not_Req_Error___, Raise_Lot_Bat_Req_Error___ and 
--  091113           Raise_Lot_Bat_Not_Req_Error___ methods to avoid repeating of above error messages.
--  091112  PraWlk   Bug 86273, Removed the assignment of contract values to int_move_comment_ in Move_Part_Impl___
--  091112           and moved the code down to create postings for the first transaction after connecting first and 
--  091112           second transaction together.
--  091001  SaWjlk   Bug 86020, Added input parameter to the procedure Reserve_Part to restrict the update of  
--  091001           the record when the manual reservation is done, if a part availability control is not set to trigger it. 
--  090723  PraWlk   Bug 84789, Made error messages 'MOVETOSAME' and 'MOVETOSAMEACTSEQ' more descriptive. 
--  090716  PraWlk   Bug 84789, Modified Move_Part_Impl___ by adding a new message when transferring to same project activity.  
--  090713  SUTHLK   Bug 82164, Added new IN parameter expiration_control_date_ to procedure and function 
--  090713           Get_Inventory_Quantity and did changes to the cursors in the procedure.
--  090812  ShKolk   Added expiration_control_date_ to methods Find_Part, Find_Part___, Find_And_Lock_Part, 
--  090812           Find_And_Reserve_Part, Get_Inventory_Quantity.
--  090807  NaLrlk   Modified the view INVENTORY_PART_IN_STOCK_LOC to use warehouse_bay_bin_tab.
--  090701  HoInlk   Modified ORDER BY of cursor get_partloc in method Create_Count_Report___
--  090701           to handle default ids properly.
--  090622  HoInlk   Bug 83802, Modified call to Get_Matched_Eng_Chg_Level in Move_Part_Impl___.
--  090603  HoInlk   Bug 82024, Modified Move_Part_Impl___ to validate eng_chg_level when moving between sites.
--  090603  MaEelk   Bug 83176, Modified Unpack_Check_Insert___ and Unpack_Check_Update___ to avoid moving serialized parts
--  090603           into Stock or Pallet locations without a serial number. Introduced Raise_Loc_Type_Serial_Error___ to
--  090603           to centralized the error message. 
--  090528  SaWjlk   Bug 83173, Removed the prog text duplications.
--  090526  MaEelk   Bug 82721, Modified Make_Individuals to get values to cost_detail_tab_ 
--  090526           when the inventory valuation method takes 'AV', 'FIFO' and 'LIFO' values.
--  090514  SuThlk   Bug 82688, Modified corrections related to 78283 in Get_Inventory_Quantity.
--  090422  SaWjlk   Bug 81492, Added NOCHECK for activity_seq in INVENTORY_PART_IN_STOCK_TOTAL, INVENTORY_PART_IN_STOCK_NOPAL, 
--  090422           INVENTORY_PART_IN_STOCK_ROT and INVENTORY_PART_IN_STOCK_OWNER views.
--  090402  SUTHLK   Bug 80295, Modified method Change_Waiv_Dev_Rej_No by adding parameter catch_quantity_.
--  090318  HoInlk   Bug 80886, Modified Move_Part_Impl___ to use from location expiration date
--  090318           when expiration date is NULL or qty onhand/intransit is 0.
--  090303  JENASE   Bug 78283, Added new IN parameter unit_of_measure_type_ Get_Inventory_Quantity  
--                   that enable the procedure to return catch qty if set to 'CATCH'.
--  090216  HoInlk   Bug 80300, Set default availability control id when inserting a new record except
--  090216           when inserting through Move_Part_Impl___.
--  090205  PraWlk   Bug 80075, Modified Get_Closest_Work_Day___ and Make_Onhand_Analysis_Impl___to avoid incorrect error
--  090205           message raised when saving CO line using availability check and part status does not allow supplies.
--  090203  NWeelk   Bug 79703, Modified Issue_Part_With_Posting to check the part availability control for 
--  090203           part noorder issue control.
--  090130  NWeelk   Bug 79854, Modified Count_Part to get the absolute value for catch_diff_.
--  081211  DAYJLK   Bug 79138, Modified column comments on attribute eng_chg_level in base view INVENTORY_PART_IN_STOCK.
--  081128  MaEelk   Bug 78875, Added condition to check if the to_destination_ gets a correct value in Move_Part
--  080901  NiBalk   Bug 75178, Added new OUT parameter to Modify_Date_Applied method call in Purchase_Order_Receipt().
--  080624  UdGnlk   Bug 73132, Modified view19 and view20 by adding project_id as a column.
--  080616  Prawlk   Bug 74816, Modified PROCEDURE Move_Part_Impl___ to raise correct error message when 
--  080616           changing inventory part location for serial tracked parts. 
--  080422  NiBalk   Bug 72596, Renamed method Validate_Params to Validate_Create_Count_Report and modified its content.
--  080422           Removed method Create_Count_Report after moving its content to Validate_Create_Count_Report.  
--  080422            Renamed Create_Count_Report_Shell__ to Create_Count_Report. 
--  080422            Renamed Create_Count_Report_Deferred__ to Create_Count_Report__.  
--  080422            Renamed Create_Count_Report_Impl___ to Create_Count_Report___.
--  080412  MAJOSE   Bug 73067, New parameter, use_distribution_calendar_, added to Make_Onhand_Analysis_Impl___.
--                   Small changes in Make_Onhand_Analysis and Make_Onhand_Analysis_Shpord to reflect this.
--  080404  NiBalk   Bug 72517, Added new implementation method Int_Order_Transit_Receipt___ and did
--  080404           some changes to Receive_Part_Impl___, to handle expiration date in inter-site movements.
--  080314  NiBalk   Bug 72159, Modified Move_Part_Impl___ to handle part revisions when moving parts between sites.
--  080229  NiBalk   Bug 71369, Modified Receive_Part_Impl___, to remove some unused code , and to do some
--  080229           performance and functional enhancements when receiving quantities from Internal Order Transit.
--  080225  NuVelk   Bug 70819, Replaced cycle_code_, freeze_code_, include_all_qty_ with db parameters in
--  080225           procedures Create_Count_Report_Impl___ and Create_Count_Report_Deferred__.
--  080225           Also changed Validate_Params to use Cyclic_Counting_API.Exist_Db for checking cycle_code_.
--  080207  LEPESE   Bug 71124, added FUNCTION Quantity_Exist_At_Location.
--  080123  LEPESE   Bug 68763, Removed calls to Inventory_Transaction_Hist_API.Handle_Wip_When_Return_Rework
--  080123           and Inventory_Transaction_Hist_API.Handle_Wip_When_Return_Credit from methods
--  080123           Return_Rework, Return_Credit and Scrap_Credit.
--  080123  LEPESE   Bug 68763, added methods Is_Internal_Transit_Deliv___ and Get_Acquisition_Site___.
--  080123           Major redesign of methods Return_Rework, Return_Credit and Scrap_Credit.
--  080117  SuSalk   Bug 70478, Modified Create_Count_Report_Impl___ method by replacing activity_seq_ from rec_.activity_seq
--  080117           for get the relevant activity sequence value from the fetched records of the get_all_qty cursor.
--  071024  NuVelk   Bug 68251, Removed obsolete columns department, del_type, location_class, low_level_code and ownership.
--  070918  AmPalk   Removed parameter 'TRUE' passed in to the 'General_SYS.Init_Method' in Get_Eng_Chg_Level_By_Location.
--  070913  RoJalk   Removed the parameter first_receipt_in_lot_ and its usage
--  070913           from Purchase_Order_Receipt.
--  070813  AmPalk   Bug 66846, Change the order of parameters and redeisgn the Function Get_Eng_Chg_Level_By_Location.
--  070813  AmPalk   Bug 65700, Added new Function Get_Eng_Chg_Level_By_Location.
--  070723  ViGalk   Bug 63632, Added new method Check_Activity_Seq___ and called it in Unpack_Check_Insert___ and Unpack_Check_Update___.
--  070723           Also made a dynamic call to Activity_API.Validate_Inventory_Transfer in method Move_Part_Impl___.
--  070716  KaDilk   Modified procedure Rename_Serial to allow rename SUPPLIER LOANED Parts.
--  070628  ViGalk   B143702, Replaced the variable 'infinity_' in Make_Onhand_Analysis_Impl___() with the global constant infinite_quantity_.
--  070619  WaJalk   Bug 65135, Replaced UNISTR with new functions in Database_SYS.
--  070605  LEPESE   Added parameter transit_location_group_ to method Issue_Part_Impl___.
--  070605           Implemented logic for transit_location_group in method Move_Part_Impl___.
--  070605           Added location_group = 'CONSIGNMENT' for transaction_code 'CO-DELV-IN' in
--  070605           method Issue_Part.
--  070604  ChJalk   Bug 64872, Added condition_code to INVENTORY_PART_IN_STOCK_DELIV (VIEW6) and
--  070604           modified data source for view VIEW6 from INVENTORY_PART_IN_STOCK_OWNER (VIEW2) to INVENTORY_PART_IN_STOCK_TOTAL (VIEW18).
--  070601  ChJalk   Bug 64839, Modified method Update___, to check and refill the part when
--  070601           changing or removing the PAC.Modified method Update___, to trigger the refill functionality
--  070601           regardless of the setting of part_movement_control of the old PAC ID.
--  070523  RoJalk   Replaced moved to transport" into "moved to transit" in the tags
--  070523           WDRNODESTERR,SERNODESTI,PRJNODESTI,TOTRANSITFROM,TOTRANSITTO.
--  070512  Kaellk   Bug 61731, Modified methods Get_Starting_Balance and Get_Avail_Plan_Qty_Loc_Type
--  070306           to include qty_in_transit. Added new condition in function Get_Inventory_Quantity.
--  070504  SuSalk   Modified Move_Part_Impl___ method to run Invent_Trans_Interconnect_API.Connect_Transactions
--  070504           method call when transaction is CO-CONS-IN.
--  070425  Haunlk   Checked and added assert_safe comments where necessary.
--  070420  RaKalk   Removed transaction_ parameter from the calls to Consignment_Stock_Manager_API.Get_Corresponding_Cons_Trans
--  070420           and the Inv_Part_Ownership_Manager_API.Unissue_Part
--  070411  KaDilk   Call 142118,Modified Move_Part_Impl___ to fetch correct revisions for the Part History.
--  070205  SuSalk   Modified error message in Scrap_Credit method to show scrap for credit when order code is 4.
--  070226  SuSalk   Removed Default NULL from the Scrap_Credit method parameteres.
--  070219  ErSrlk   Bug 62594, Introduced new function Get_Actual_Catch_Qty_Onhand to return the actual value or null.
--  070219           Modified Inventory_Part_In_Stock_LOV8 and added additional columns and made some columns LOV enabled.
--  070219           Introduced function Get_Catch_Qty_In_Transit. Added catch_qty_in_transit to cursor
--  070219           get_attr of function Get.
--  070215  SuSalk   Added procedure Scrap_Credit.
--  070214  NuVelk   Bug 62694, Added NVL check for activity_seq in method Unissue_And_Move_Part.
--  070212  DAYJLK   B140960, Modified Move_Part_Impl___ to fetch appropriate value for eng_chg_level when renaming a serial.
--  -------------------------- Wings Merge End -------------------------------
--  070130  DAYJLK   Merged Wings Code. Modified Make_Individuals by adding new parameter to call Inv_Part_Ownership_Manager_API.Move_Part.
--  070126  DAYJLK   Added method Get_Serial_Contract. Modified method Rename_Serial by changing the validations.
--  070118  DAYJLK   Modified parameter part_no_ to from_part_no_. Renamed method Replace_Serial_No to Rename_Serial.
--  070118           Code cleanup on methods Move_Part_Impl___, Check_Valid_Move_Combinations, and Rename_Serial.
--  070104  DAYJLK   Added overloaded methods Replace_Serial_No and Check_Valid_Move_Combinations and Modified the existing
--  070104           methods with the same names. Modified Move_Part_Impl___ by adding logic changes for new parameter to_part_no_.
--  070104           Modified all instances in the package where Move_Part_Impl___ is invoked, by adding values for the new parameter to_part_no_.
--  061215  BEHAUS   B128805. Made ownership, owning name, condition code fields LOVable to INVENTORY_PART_IN_STOCK_LOV8
--  -------------------------- Wings Merge Start -----------------------------
--  070126  NuVelk   Bug 61856, Modified methods Receive_Part,Issue_Part_Impl__,and Receive_Part_Impl__ to handle receipt_date.
--  070116  WaJalk   Bug 59833, Added a new procedure Check_Waiv_Dev_Rej_No___ to check uppercase for waiv_dev_rej_no_ in procedures
--  070116           Purchase_Order_Receipt, Receive_Part_With_Posting, Receive_Part & Change_Waiv_Dev_Rej_No.
--  070116  NuVelk   Bug 62606, Modified the procedure Create_Count_Report_Impl___, inorder to create a count report.
--  061228  DaZase   Changed all usage of catch_unit_code from part catalog record so it now is fetched from Inventory_Part_API.Get_Catch_Unit_Meas instead.
--  061228  NaLwlk   Bug 58299, Added method Find_And_Lock_Part. Added calls to Find_And_Lock_Part
--  061228           from latest versions of methods Find_And_Reserve_Part and Find_And_Issue_Part.
--  061228           Added method Find_Part___. Also added new versions of methods
--  061228           Find_And_Reserve_Part and Find_And_Issue_Part which have an out parameter of
--  061228           type Keys_And_Qty_Tab. Completely rewritten the code inside method Find_Part
--  061228           and inside the older versions of Find_And_Reserve_Part and Find_And_Issue_Part.
--  061227  DaZase   Converted qty to destination sites UoM in the methods Move_Part_Impl___, Undo_Return_Rework.
--  061214  ErSrlk   Bug 60908, Added two LOV views INVENTORY_PART_IN_STOCK_LOV22 and INVENTORY_PART_IN_STOCK_LOV23,
--  061214           inorder to list all distinct lot_batch_no/serial_no values for a specific contract, part_no combination.
--  061207  NaLwlk   Bug 60731, Added error message in method Issue_Part_Impl___ to check whether
--  061207           quantity is available when unreceiving the stock.
--  061207  SeNslk   LCS Merge 61772, Removed function Get_Max_Lot_Batch_No.
--  061126  ChBalk   Bug 60516, Made changes to the call Order_Supply_Demand_API.Get_Available_Balance
--                   in method Make_Onhand_Analysis_Impl___.
--  061117  RoJalk   Modified Purchase_Order_Receipt to identify the first receipt
--  061117           to a specific lot and pass that information to Do_Transaction_Booking.
--  061115  NaLrlk   Bug 60430, Modified Unpack_Check_Update___ to check whether the change of
--  061115           availability_control_id is valid.
--  061115  NaWilk   Bug 61009, Increased the length of the variable cycle_code_ to 100 in method Validate_Params.
--  061106  NiBalk   Bug 60671, Modified the procedure Unpack_Check_Insert___,
--  061106           in order to avoid special characters used by F1.
--  060914  ChJalk   Bug 58903, Changed the procedure Move_Part_Shipment to allow moving stocks between Shipment location
--  060914           and Production line,Floor stock locations. Removed dynamic call to Cust_Order_Type_API in Move_Part_Shipment.
--  060901  KaDilk   Bug 59841, Replaced cursor get_qty_in_transit with a call to Lock_By_Keys___
--  060821           inside method Receive_Part_From_Transit__,
--  060816  MarSlk   Bug 59403, Modified method Scrap_Part to scrap consignment stock when order details are not available.
--  060816  Asawlk   Bug 59287, Removed unnecessary closing of cursor get_location in method Find_And_Issue_Part_Neg.
--  060810  ChJalk   Modified hard_coded dates to be able to use any calendar.
--  060518  WiJalk   Bug 57559, Added a new parameter set_qty_reversed_ to Receive_Part_Impl___ and transfer the functionality
--  060518           of unissue_ to set_qty_reversed_. Added check when unissuing expired stock.
--  060517  HoInlk   Bug 55969, Modified methods Find_And_Reserve_Part, Find_And_Issue_Part and
--  060517           Find_And_Issue_Part_Neg to include a locking mechanism.
--  060503  ChFolk   Bug 56598, Modified methods Scrap_Part, Return_Rework and Return_Credit to Add new IN parameter pallet_id_
--  060503           and called Inventory_Transaction_Hist_API.Set_Pallet_Id to update pallet_id in inventory transaction.
--  060503           Removed parameter pallet_id_issue_ from Undo_Return_Rework.
--  060427  IsWilk   Bug 57320, Removed the duplicate calls to Move_Part_Impl___ with IF ELSE condition
--  060427           and replaced by a one call and also removed the unused code for stdinv_expiration_date_.
--  060427           And removed the calls to Get_Availability_Control_Id, Check_Exist___ and Get_Expiration_Date
--  060427           and replaced by one single call to Get_Object_By_Keys___ for improving the performance.
--  060420  IsAnlk   Enlarge supplier - Changed variable definitions.
--  060420  IsAnlk   Enlarge customer - Changed variable definitions.
--  060418  NaLrlk   Enlarge Identity - Changed view comments.
--  ------------------------- 13.4.0 -----------------------------------------
--  060310  JaJalk   Modified the method Move_Part_Project to validate the project against the company.
--  060309  JOHESE   Added parametr move_comment_ to Move_Part_Project to store notes on project transfers
--  060222  JoAnSe   Code for creation of RETREVAL postings removed from Return_Rework
--  060222           and Return_Credit, this is now handled in Inventory_Transaction_History.
--  060217  LEPESE   Replaced usage of obsolete column cost in inventory_transaction_hist_pub in
--  060217           method Cancel_Receipt_In_Place. use Inventory_Transaction_Cost_API instead.
--  060215  LEPESE   Added parameter make_transaction_and_postings_ to method Move_Part_Impl___.
--  060215           Removed DEFAULT option for parameters consume_consignment_stock_ and order_type_
--  060215           in the same method. Added parameter make_transaction_ to method Issue_Part_Impl___.
--  060215           Implemented a check against system parameter TRANSACTIONS_PROJECT_TRANSFERS in
--  060215           method Move_Part_Project to avoid creating transaction history records and
--  060215           postings when PROJTRAN+ and PROJTRAN- transactions are created if the system
--  060215           parameter is set to 'N'. This will only happen as a post-upgrade activity.
--  060215  LEPESE   Switched pos_diff_transaction and neg_diff_transaction when calling method
--  060215           Inventory_Transaction_Hist_API.Reverse_Transaction from Undo_Return_Rework.
--  060215  DAYJLK   Modified Scrap_Part by replacing dynamic call to Create_Consignment_Transaction
--  060215           in package Receive_Purchase_Order_API with Scrap_Consignment_On_Receipt.
--  060210  LEPESE   Modifications in method Cancel_Receipt_In_Place. Replaced call to
--  060210           Inventory_Part_Cost_Fifo_API.Remove_Cost with a call to
--  060210           Inventory_Transaction_Hist_API.Remove_Fifo_Lifo_Cost.
--  060202  JoAnSe   Replaced calls to Mpccom_Accounting_API.Reverse_Accounting
--  060202           with Inventory_Transaction_Hist_API.Reverse_Accounting
--  060202           Replaced parameter old_accounting_id with org_transaction_id in
--  060202           Unreceive_Part created connection to org_transaction_id in same method.
--  060202  LEPESE   Added configuration_id_ in call to Inventory_Part_Unit_Cost_API.Generate_Cost_Details.
--  060201  LEPESE   Changes in Return_Rework and Return_Credit to pass the value in a
--  060201           value_detail_tab_ to method Do_Booking. Major changes in method
--  060201           Undo_Return_Rework in order to clear out the M4 account on a cost detail
--  060201           level when undoing a return for rework in the internal order flow.
--  060201  JaJalk   Added the original transaction id for RINTOTRCOR in Undo_Return_Rework to maintain the connection.
--  060131  JoAnSe   Added merge of cost details to Transfor_Cost_Details
--  060123  LEPESE   Changes in method Move_Part_Impl___. Added call to method
--  060123           Inventory_Part_Unit_Cost_API.Generate_Cost_Details to create cost details
--  060123           when moving parts between companies.
--  060123  LEPESE   Added call to method Inventory_Part_Unit_Cost_API.Get_Year_And_Source_Merged()
--  060123           from method Transform_Cost_Details. Added parameters to_valuation_method_db_
--  060123           and to_part_cost_level_db_ to Transform_Cost_Details.
--  060123  NiDalk   Added Assert safe annotation.
--  060118  JoAnSe   Added handling for cost details in Cancel_Receipt_In_Place for
--  060118           inventory_valuation_method 'ST'
--  060112  DAYJLK   Modified Undo_Consignment_Consumption to consider reversed quantitiy when reversing consumption transactions.
--  060111  Asawlk  Bug 55356, Added parameter detect_supplies_not_allowed_ to methods Make_Onhand_Analysis and to
--  060111          Make_Onhand_Analysis_Impl___. Added functions Get_Closest_Work_Day___ and Get_End_Date___.
--  060111          Modified Make_Onhand_Analysis, Make_Onhand_Analysis_Shpord and Make_Onhand_Analysis_Impl___.
--  060111  JoAnSe   Removed parameter get_current_cost in calls made to
--  060111           Inventory_Transaction_Hist_API.Get_Arrival_Cost
--  060110  JoAnSe   Added parameter cost_detail_tab_ to Purchase_Order_Receipt
--  060106  IsAnlk   Added General_Sss.Init to Undo_Consignment_Consumption.
--  051222  HoInlk  Bug 55170, Modified Validate_Count_Part to raise error if mrp order code is O,K or T.
--  051222  HoInlk   Bug 55158, Modified Validate_Count_Part to display COUNTSERIALEXIST error only if qty_counted is not zero.
--  051222  DAYJLK   Made dynamic calls to Receive_Purchase_Order_API.Create_Consignment_Transaction in Move_Part_Impl___,
--  051222           Count_Part, Scrap_Part, Issue_Part, Find_And_Issue_Part_Neg, and Issue_Part_With_Posting.
--  051222           Added new procedure Undo_Consignment_Consumption and invoked it in Unissue_Part.
--  051214  JoAnSe   Changed Transform_Cost_Details to handle the case when costing is not installed.
--  051207  ISWILK   Replaced the availability_control_id_ with fromrec_.availability_control_id
--  051207           in PROCEDURE Move_Part_Impl___.
--  051111  JoAnSe   Replaced call to Inventory_Transaction_Hist_API.Associate_Transactions
--                   with Invent_Trans_Interconnect_API.Connect_Transactions.
--                   Replaced use of associated_transaction_id with
--                   Invent_Trans_Interconnect_API.Get_Connected_Transaction_Id
--  051107  JoAnSe   Replaced call to Inventory_Transaction_Hist_API.Set_Associated_Transaction_Id
--                   with Inventory_Transaction_Hist_API.Associate_Transactions
--                   Removed Intersite_Move_Revaluation now handled within Do_Booking in
--                   Inventory_Transaction_Hist_API
--  051103  LEPESE   Corrections in method Issue_Part to get cost details on the
--  051103           extra transactions created for customer consignment stock (CO-DELV-IN)
--  051103           and delivery confirmation (DELCONF-IN).
--  051031  RaSilk   Modified error message on pallet parts in method Validate_Mrb_Submission___.
--  051027  MaEelk   Added LOV properties to the column Location_No in VIEW21.
--  051023  LEPESE   Major changes in order to be able to handle cost details when reversing
--  051023           transactions. Changes in methods Issue_Part_Impl___, Receive_Part_Impl___,
--  051023           Issue_Part, Receive_Part, Unissue_Part, Unreceive_Part.
--  051020  MaEelk   Created VIEW21.
--  051019  RaSilk   Added keys as parameters to method Validate_Mrb_Submission___.
--  051017  JoAnSe   Replaced Add_And_Sort_Value_Details___ with call to
--                   Mpccom_Accounting_API.Create_Value_Diff_Tables.
--  051017  JoAnSe   Corrected Add_And_Sort_Value_Details___.
--                   Added abs() when assigning value for negative details.
--  051014  NuFilk   Modified Create_Count_Report_Impl___ to only allow positive integers for process_count.
--  051014  RaSilk   Added missing specification of method Validate_Mrb_Submission___.
--  051011  JoAnSe   Changed booking of differences in Return_Rework and Return_Credit
--                   Corrected constant inst_CostBucketCrossRef, corrected Transform_Cost_Details
--                   Changed wip cost retrieval in Return_Rework and Return_Credit.
--  051010  RaSilk   Added methods Validate_Mrb_Submission___ and Submit_Part_To_Mrb.
--  051007  JoAnSe   Corrected Add_And_Sort_Value_Details___
--  051007  KanGlk   Added check to control the inventory movement depending on
--  051007           part availability control data in 'Move_Part_Impl___' method.
--  051006  JoAnSe   Added handling for Zero Cost Only on receiving site in Move_Part_Impl___
--  051005  JoAnSe   Added Transform_Cost_Details and call to this method from Move_Part_Impl___
--  051003  KeFelk   Replaced site_rec_.Picking_Leadtime with Site_Invent_Info_API.Get_Picking_Leadtime(),
--  050927  HoInlk   Bug 51652, Modified to use new IID CyclicCounting instead of InventoryPartCountType.
--  050927  JoAnSe   Merged DMC Changes below
--  **********************  DMC Merge End  *************************************
--  050921  JoAnSe   Corrections in Add_And_Sort_Value_Details___
--  050920  JoAnSe   Added handling for cost details to Intersite_Move_Revaluation,
--                   also added new parameter order_related_move_.
--                   Added Add_And_Sort_Value_Details___._
--  050914  JoAnSe   Removed one of the overloaded Receive_Part methods
--  050907  JoAnSe   Added new parameter cost_detail_tab_ to Receive_Part
--  050818  HoInlk   Bug 51652, Added methods Count_Report_Line_Tmp_Exist___, Create_Count_Report_Lines___,
--  050818           New_Count_Report_Line_Tmp___. Modified Create_Count_Report_Impl___ to sort count reports by next_count_date.
--  050808  LEPESE   Implementation of cost_detail_id_ in methods Count_Part and
--  050808           Count_Part_No_Pallet. Added a lot of business logic for calculating the
--  050808           correct counting transaction cost in method Count_Part.
--  050728  LEPESE   Modifications in method Receive_Part_With_Posting to fetch cost_detail_tab_
--  050728           from Temporary_Cost_Detail_API when cost_detail_id_ has a value. Also added
--  050728           new parameter cost_detail_id_ to Receive_Part_With_Posting.
--  050728           Modified method Receive_Part_Impl___ and added new parameter cost_detail_tab_.
--  050728           Also added cost_detail_tab_ in all calls to Receive_Part_Impl___.
--  050728           Code cleanup to remove all &PKG.. prefixes in calls to internal methods.
--  050622  LEPESE   Modifications in method Update___. Removed several validations preceeding the
--  050622           call to Inventory_Part_Unit_Cost_API.Remove and placed them inside that method.
--  **********************  DMC Merge Begin  **********************************
--  050920  NiDalk   Removed unused variables.
--  050912  HoInlk   Bug 53131, Modified Create_Count_Report to only allow positive integers for process_count.
--  050901  IsAnlk   Modified procedure Receive_Part_Impl__ to validate expiration_date when it received from transit.
--  050901  SaRalk   Modified procedure Receive_Part_Impl__.
--  050831  IsAnlk   Modified Return_Rework to pass expiration_date from InventoryPartInStock record to transit object.
--  050829  JOHESE   Added check on availability_control_id in Move_Part_Project
--  050826  SaRalk   Added expiration date as an IN parameter to procedure Purchase_Order_Receipt and modified procedure Receive_Part_Impl__.
--  050826           Modified procedure Issue_Part by adding expiration_date to the call Inventory_Part_In_Transit_API.Move_Into_Order_Transit.
--  050823  IsAnlk   Added EXPIRATION_DATE as a key to InventoryPartInTransit LU and changed the code accordingly.
--  050816  DaYjlk   Bug 49976, Modified Move_Part_Impl___ to use new transaction codes WDR-OUT, and WDR-IN
--  050816           instead of INVM-ISS and INVM-IN respectively for WDR No. change transactions.
--  050815  VeMolk   Bug 50469, Made the parameter location_type2_flag_ obsolete in Make_Onhand_Analysis and
--  050815           Make_Onhand_Analysis_Shpord and modified the call to the method Make_Onhand_Analysis in
--  050815           Move_Part_Impl___.
--  050811  PHDEUS   B126175, In Find_And_Issue_Part_Neg, assigned the internal
--                   i_activity_seq_ variable to the out parameter activity_seq_.
--  050810  NaLrlk   B124408, Modified the cursor in Get_Catch_Qty_Onhand.
--  050720  MaEelk   Modified Move_Part_Project set the expireation dates correctly.
--  050707  ChFolk   Bug 51942, Added IN parameter transit_eng_chg_level_ into Purchase_Order_Receipt
--  050707           and use the value when modifying the transit object.
--  050706  JOHESE   Modified call to Inv_Part_Ownership_Manager_API.Validate_Cancel_Per_Line to support project inventory
--  050628  HaPulk   Fixed invalid usage of General_SYS.Init_Method.
--  050525  RaKalk   Moved the method Arrival_Or_Quality_Location___ to Inventory_Location_API and made it a public method.
--  050518  RaKalk   Removed method Load_Serial_Array___,changed the last parameter of Make_Individuals from serials_ to Serial_Catch_Tab_.
--  050505  ErSolk   Bug 50469, Modified interface Make_Onhand_Analysis_Impl___ by
--  050505           removing parameter location_type2_flag_ and changed parameters
--  050505           part_ownership_, owning_vendor_no_, owning_customer_no_ with
--  050505           DEFAULT option into normal parameters. Since location_type2 is
--  050505           removed from Make_Onhand_Analysis_Impl___, parameter location_type2_flag_
--  050505           will be obsolete in Make_Onhand_Analysis and Make_Onhand_Analysis_Shpord.
--  050509  KanGlk   Added expiration_date, qty_onhand to INVENTORY_PART_IN_STOCK_LOV8.
--  050429  GeKalk   Added catch_quantity_ parameter to Unreceive_part and Unissue_Part methods.
--  050415  ErSolk   Bug 50469, Modified procedure Make_Onhand_Analysis_Impl___ to
--  050415           include quantity in shop locations.
--  050407  JOHESE   Added call Inventory_Part_At_Customer_API.Increase_Our_Qty_At_Customer in Issue_Part
--  050401  JOHESE   Modified procedure Find_Part to give the possibility to exclude consignment stock from the search
--  050330  JOHESE   Replaced call to Customer_Consignment_Stock_API.Get_Sum_Consignment_Stock_Qty
--                   with Inventory_Part_At_Customer_Api.Get_Our_Total_Qty_At_Customer call to include
--                   parts in consignment as well as parts awaiting delivery confirmation.
--  050328  IsWilk   Added the PROCEDURE Validate_Params to validae the parameter
--  050328           when running the Schedule Create Count Report.
--  050322  AnLaSe   SCJP625: added creation of DELCONF-IN in Issue_Part, using location group DELIVERY CONFIRM.
--  050311  DAYJLK   Bug 35605, Added procedures Fill_Inventory_Location_Tmp and Clear_Inventory_Location_Tmp.
--  050311           Modified methods Find_Part and Find_And_Issue_Part_Neg.
--  050311  JaBalk   Modified Make_Onhand_Analysis_Impl___ to avoid no data found error when the
--  050311           Available_BalanceDate_Tab(j) position is null and changed the condition
--  050311           next_analysis_date_ := Available_BalanceDate_Tab(j_) to next_analysis_date_ := Available_BalanceDate_Tab(j_ - 1);
--  050303  IsWilk   Removed parameter m88_curr_value_ in PROCEDURE Intersite_Move_Revaluation,
--  050303           modified PROCEDURE Intersite_Move_Revaluation and call the FUNCTION
--  050303           Site_API.Get_Currency_Converted_Cost from  PROCEDURE Move_Part_Impl___.
--  050302  JOHESE   Modified call to Order_Supply_Demand_API.Get_Available_Balance in Make_Onhand_Analysis_Impl___
--  050210  SaNalk   Modified the condition for pallet part receiving in method Purchase_Order_Receipt.
--  050201  SeJalk   Bug 48192, Changed comparisons and error messages where parts having expiration date as today's
--  050201           date to be considered as expired and truncateted expiration date before inserting and updating.
--  050121  ErSolk   Bug 47247, Modified procedure Move_Part_Impl___ by moving
--  050121           m88_curr_value_ calculation to the place it is used,and made
--  050121           changes to overcome errors when changing inventory part
--  050121           locations of parts with cost less than 1/2 cent.
--  050106  JaJalk   Implemented the NOCHECK for the view INVENTORY_PART_LOCATION.
--  041216  IsWilk   Modified the VIEW_BKFL to view19 and added the view VIEW20.
--  041216  IsWilk   Added the VIEW_BKFL to use for Backflush Process when reserving the trcaked parts.
--  041213  JOHESE   Modified procedure Receipt_In_Place
--  041207  RaKalk   Moved Inventory_Part_Location view from partloc.apy
--  041129  IsAnlk   Renamed Check_Qty_In_Transit_Exist as Transi_Qty_Without_Catch_Exist and modified the cursor.
--  041129  SaJjlk   Modified counting catch quantities in method Count_Part.
--  041125  JOHESE   Modified Make_Onhand_Analysis, Make_Onhand_Analysis_Impl___, Make_Onhand_Analysis_Shpord, Get_Starting_Balance and Get_Inventory_Quantity
--  041118  SaJjlk   Removed a null value check for catch quantity in Receive_Part_Impl___.
--  041111  SaJjlk   Modified wording of error message in Check_Onhand_Increase_Catch___.
--  041111  RaKalk   Added Catch_Quantity_ OUT parameter to Find_And_Issue_Part 24param version.
--  041110  JOHESE   Modified Move_Part_Impl___
--  041110  SaJjlk   Modifications in method Reserve_Part for catch quantity handling.
--  041109  SaJjlk   Added parameter catch_quantity_ to method Undo_Return_Rework.
--                   Changed parameter catch_quantity_ to an IN OUT parameter in Return_Credit, Return_Rework and Move_Part_Shipment.
--  041108  SaJjlk   Added parameter catch_quantity_ to method Return_Credit and Return_Rework.
--  041108  DiVelk   Added 'ACTIVITY_SEQ' in Prepare_Insert___.
--  041105  SaJjlk   Added parameter catch_quantity_ to method calls for Inventory_Transaction_Hist_API.Reverse_Transaction.
--  041105           Added parameter catch_quantity_ to Move_Part_Shipment.
--  041104  WaJalk   Added parameter order_type_ to method Issue_Supplier_Owned_Stock.
--  041102  Samnlk   Added error message for supplier owned pallet handled part in method Purchase_Order_Receipt.
--  041102  IsAnlk   Modified Issue_Part by adding IN OUT parameter catch_quantity_.
--  041101  WaJalk   Modified method Issue_Supplier_Owned_Stock.
--  041101  Samnlk   Added new parameter exclude_supplier_owned_stock_, to function Check_Quantity_Exist.
--  041029  WaJalk   Modified method name to Issue_Supplier_Owned_Stock.
--  041028  Asawlk   Bug 46794, Modified method Update___, removed old code that has been added
--  041028           to support Refill Picking Location functionality and added new code to
--  041028           support the same functionality. Removed function Get_Picking_Loc_To_Refill.
--  041028  RaKalk   Modified Receive_Part_From_Transit___ to set catch_qty to catch_qty_in_Transit
--  041028           if the full qty is being received and the catch_qty from client is null.
--  041028  SaJjlk   Added parameter catch_quantity_ to Unissue_Part.
--  041026  SaJjlk   Added methods Arrival_Or_Quality_Location___, Stock_Location___, Raise_Catch_Qty_Null_Error___ and Raise_Catch_Zero_Neg_Error___.
--  041025  MaJalk   Bug 46935, In procedure Move_Part_Impl___ added an error message
--  041025           to be risen when destination location parts are frozen.
--  041025  SaJjlk   Added parameter catch_quantity_ to Unreceive_Part and Unissue_And_Move_Part.
--  041022  SaJjlk   Modified method call for Move_part_Impl___ in Move_Part_Shipment.
--  041021  WaJalk   Modified method Transfer_Supplier_To_Own_Stock.
--  041020  SaJjlk   Modifications to catch quantity validations in Validate_Count_Part.
--  041020  WaJalk   Added new method Transfer_Supplier_To_Own_Stock.
--  041020  SaJjlk   Modifications to counting catch quantity.
--  041020  IsAnlk   Added catch_qty_onhand and catch_qty_in_transit to view INVENTORY_PART_IN_STOCK_RES.
--  041015  SaJjlk   Modifications to abs_catch_diff_ in Count_Part.
--  041014  GeKalk   Modified Issue_Part_Impl___ to give an error msg when the quantity is null.
--  041014  SaJjlk   Added parameter catch_quantity_ to Reserve_Part, Purchase_Order_Receipt and Connect_To_Lot_Batch.
--  041013  SaJjlk   Added parameter catch_quantity_ to Issue_Part.Receive_Part.
--  041012  SaJjlk   Modified parameter catch_quantity_ to make it IN OUT in methods Issue_Part_Impl___, Move_Part_Impl___ Scrap_Part and Move_Part.
--  041006  SaJjlk   Modifications to counting catch unit enabled parts.
--  041005  JOHESE   Removed attribute vendor_no and added some checks in Unpack_Check_Insert___
--  041004  SaJjlk   Modifications in method Count_Part for handling catch unit.
--  040929  AnLaSe   Inter-site Profitability: added call to Intersite_Profit_Manager_API.
--                   Added variable company_ in Issue_Part() to avoid several calls to Site_API.Get_Company.
--  040927  RaKalk   Modified the catch unit vlidation methods.(Check_Onhand_Decrease_Catch___, Check_Onhand_Increase_Catch___)
--  040927           and Unpack_Check_Update___ method
--  040923  Rakalk   Added new methods for Catch Unit validation. (Check_Catch_Unit_Insert___, Check_Catch_Unit_Update___,
--  040923           Check_Onhand_Increase_Catch___, Check_Onhand_Decrease_Catch___, Check_Onhand_Nochange_Catch___, Check_Transi_Increase_Catch___,
--  040923           Check_Transi_Decrease_Catch___, Check_Transi_Nochange_Catch___) added new default null parameter (counting_result_)
--  040923           to method Unpack_Check_Update___. Modified Unpack_Check_Insert___ to add catch unit validations.
--  040922  RaKalk   Modified view comments for catch_qty_onhand and catch_qty_in_transit.
--  040920  SaJjlk   Added the parameter catch_qty_difference_ to method Count_Part, Count_Part_No_Pallet and catch_qty_counted_ to Validate_Count_Part.
--  040917  WaJalk   Added a check for activity_seq in WHERE condition of view INVENTORY_PART_IN_STOCK_ROT.
--  040917           Modified method Modify_Rotable_Part_Pool_Id.
--  040917  NaWalk   Added the parameter catch_quantity_ to method Receive_Part_From_Transit__
--  040916  SaJjlk   Added parameter catch_qty_onhand_ in method calls to Counting_Report_Line_API.New_List_Detail.
--  040916  JOHESE   Modified function Get_Avail_Plan_Qty_Loc_Type
--  040916  SaJjlk   Replaced the NULL parameter with catch_quantity_ in method calls Inventory_Part_In_Transit_API.Move_Into_Order_Transit and Remove_From_Order_Transit.
--  040915  GaJalk   Bug 46906, Removed the validation to prevent quantities for parts with
--  040915          'Onhand not allowed' inside the procedure Receive_Part_Impl___.
--  040915           Added the mentioned validation inside procedures Unpack_Check_Insert___
--  040915           and Unpack_Check_Update___.
--  040915  HeWelk   Perform the Receive/Issue update with regards to catch quantity.
--  040915  WaJalk   Modified view INVENTORY_PART_IN_STOCK_ROT, added column activity_seq.
--  040915  SaJjlk   Added parameter catch_quantity to method Scrap_Part and added column catch_qty_onhand to VIEW14.
--  040915  RaKalk   Added new parameter (catch_quantity_) to methods Move_Part, Move_Part_Impl___
--  040915           and changed all the calls to those methods to include new parameter.
--  040914  JOHESE   Modified VIEW17, Unpack_Check_Insert___, Get_Inventory_Qty_Rejected, Get_Qty_In_Quality_Control and Get_Inventory_Quantity
--  040910  UsRalk   Changed the LU prompt [InvPartLocation] to [Inventory Part In Stock].
--  040910  SaJjlk   Added methods Check_Qty_In_Transit_Exist and Check_Qty_Onhand_Exist.
--  040910  HeWelk   Added parameter catch_quantity_ to Receive_Part_Impl___(),Issue_Part_Impl___().
--  040910  HeWelk   Added parameter catch_quantity_ to Receive_Part_With_Posting(),Issue_Part_With_Posting()
--  040909  SaJjlk   Added catch_qty_ parameter to method calls Inventory_Part_In_Transit_API.Move_Into_Order_Transit and Remove_From_Order_Transit.
--  040908  HeWelk   Added catch_qty_in_transit,catch_qty_onhand to
--                   VIEW5 ,VIEW18,VIEW2,VIEW6.
--  040908  HeWelk   Added catch_qty_in_transit,catch_qty_onhand to INVENTORY_PART_IN_STOCK.
--  040903  MaEelk   Modified Issue_Part_With_Posting and Receive_Part_With_Posting to restrict manual transactions in Project Inventory parts.
--  040827  DAYJLK   Call ID 117232, Modified Get_Company_Owned_Inventory by setting qty_in_transit_ to 0 when the cursor returns a NULL value.
--  040825  DAYJLK   Call ID 117035, Added default TRUE parameter remove_unit_cost_ and modified Unreceive_Part.
--  040824  DAYJLK   Call ID 116770, Modified parameter list to call Inventory_Part_In_Transit_API.Remove_From_Order_Transit in Purchase_Order_Receipt.
--  040820  DAYJLK   Call ID 116941, Added default 'FALSE' parameter remove_default_qty_ to Purchase_Order_Receipt to indicate
--  040820           whether the row with the default values or a specific row should be removed from the transit object.
--  040819  DAYJLK   Call ID 116524, Modified Column Comments of view INVENTOERY_PART_IN_STOCK_DELIV.
--  040818  DhWilk   Inserted General_SYS.Init_Method to Undo_Return_Rework & Move_Part_Project.
--  040811  GeKalk   Modified Return_Credit to give a proper error msg when both companies are the same.
--  040809  DAYJLK   Modified the condition that removes parts in transit in Purchase_Order_Receipt.
--  040729  NuFilk   Modified function Check_Quantity_Exist modified the If condition to include check on company owned stock.
--  040727  UsRalk   Added ACTIVITY_SEQ and PROJECT_ID to view INVENTORY_PART_IN_STOCK_RES.
--  040722  Samnlk   Added new default NULL parameter to procedure Count_Part and procedure Count_Part_No_Pallet.
--  040722  Samnlk   Interchange the two parameters send to Counting_Report_API.New_List_Header.
--  040722  DiVelk   Modified call to Counting_Report_Line.Check_Unconfirmed_Part_Loc.
--  040721  JOHESE   Added procedure Move_Part_Project and modified Move_Part_Impl___
--  040715  Samnlk   Change the parameter list in PROCEDURE Create_Count_Report.
--  040714  Samnlk   Modified Create_Count_Report, Create_Count_Report_Deferred__ ,Create_Count_Report_Impl___ and Count_Part.
--  040709  MaGulk   Added method Undo_Return_Rework, modified methods Return_Rework
--  040704  JOHESE   Modified Get_Sum_Qty_Plannable, Get_Qty_Onhand_By_Location and Get_Inventory_Quantity
--  040701  MaGulk   Modified Get_Inventory_Quantity to consider qty in order transit
--  040701  JOHESE   Modified Make_Individuals and Connect_To_Lot_Batch
--  040630  DaZaSe   Adding activity_seq and project_id to LOV 4-7.
--  040621  SHVESE   Added parameter transit_qty_direction in call to InventoryPartCostFifo.Remove_Cost.
--  040621  NuFilk   Modified the call to Inventory_Part_In_Transit_API.Get_Total_Oder_Tansit_Qty to
--  040621           Inventory_Part_In_Transit_API.Get_Total_Qty_In_Order_Transit
--  040618  JOHESE   Added check on project site in Unpack_Check_Insert___
--  040609  MaGulk   Removed obselete methods Check_Inventory_Empty & Check_Site_Inventory_Empty
--  040607  MaGulk   Modified Count_Part to include qty in order transit, Check_Part_Exist to check qty in order transit,
--  040607  MaGulk   M4/Transibal: Modified methods Get_Serial_Track_Status, Get_Lot_Batch_Track_Status, Check_Individual_Exist, Issue_Part
--  040607           Purchase_Order_Receipt, Get_Company_Owned_Inventory, Check_Lot_Batch_Exist, Check_Quantity_Exist
--  040607           Replace_Serial_No
--  040528  ErSolk   Bug 39943, Added function Check_Qty_For_Condition. Modified
--  040528           procedure Cancel_Receipt_In_Place.
--  040519  Cpeilk   Bug 43950, Restructured the code for better performances in method Validate_Count_Part.
--  040514  SeJalk   Bug 44460, Changed the error massages with the constants '1226' and 'PARTZEROCOSTONLY'.
--  040511  JOHESE   Added new key activity_seq and attribute project_id
--  **************   Touchdown Merge Begin  *********************
--  040219  LEPESE   Added methods Intersite_Move_Revaluation and Calculate_M88_Curr_Value___.
--                   The logic in these methods has been cut&pasted from Move_Part_Impl___.
--  040210  LEPESE   Modifications in Return_Credit and Return_Rework to allow
--                   revaluation transactions when Standard Cost is combined with Transaction Based.
--  040129  LEPESE   Changed actual_cost to invoice_consideration.
--  **************   Touchdown Merge End    *********************
--  040311  Asawlk   Bug 42385, Added the value oldrec_.expiration_date as an in parameter when calling Inventory_Transaction_Hist_API.NEW
--                   inside the method Issue_Part_Impl___.
--  040301  GeKalk   Removed substrb from the views and replaced substrb with substr where necessary to keep substr for UNICODE modifications.
--  040209  NaWalk   Converted CHR(255) to UNISTR for Unicode Modification.
--  040127  SaNalk   Modified cursor get_inv_tran_hist according to the standards.
--  040121  LoPrlk   Merge split packages, PKG2 was removed along with init method.
--  040121  LoPrlk   Merge split packages, Load_Serial_Array___ was moved from PKG2 to PKG. Miner changes were done.
--  040121  LoPrlk   Merge split packages, Make_Onhand_Analysis_Impl___ was moved from PKG2 to PKG. Miner changes were done.
--  040121  LoPrlk   Merge split packages, Update___ and Create_Count_Report_Impl___ were moved from PKG2 to PKG. Miner changes were done.
--  040121  LoPrlk   Merge split packages, Method Unpack_Check_Update___ and Validate_Rotable_Part_Pool___ were moved from PKG2 to PKG. Miner changes were done.
--  040120  SaNalk   Send the Encoded value of Order Type to Cursor Get_Inv_Tran_Hist in methods Return_Rework and Return_Credit.
--  040120  LoPrlk   Merge split packages, Method Insert___ was moved from PKG2 to PKG. Miner changes were done to the file.
--  040120  LoPrlk   Merge split packages, Methods Unpack_Check_Insert___,  Receive_Part_Impl___, Lock_By_Keys___ and Issue_Part_Impl___ were moved
--  040120           PKG2 to PKG. Appropriate miner changes were done to make the file compilable.
--  040116  SaNalk   Added cursor Get_Inv_Tran_Hist to methods Return_Rework and Return_Credit.
--  040112  SaNalk   Added cursor Get_Location_Pallet in method Create_Count_Report_Impl___.Called this cursor in this method
--  040112           Instead of calling the Public Cursor from INVENTORY_PART_LOC_PALLET_API.
--  ------------------------------ 13.3.0-------------------------------------
--  031104  MaGulk  Removed obselete comments on method usage.
--  031029  LEPESE  Major view cleanup. Removed a lot of outher joins with part_serial_catalog_pub,
--                  lot_batch_master_pub, inventory_part_stock_owner_pub and
--                  part_availability_control_pub. Instead we keep these joins in VIEW2 and VIEW18.
--                  Many other views are based on VIEW2 and VIEW18. These two views are also
--                  used in many cursor definitions in this file.
--  031024  LEPESE  Major code cleanup. Redesign of methods Find_Part and Find_And_Issue_Part_Neg.
--                  Created view INVENTORY_PART_IN_STOCK_TOTAL to be a new extened base view
--                  only for use within this LU, not for client usage.
--  031021  MaEelk  Call ID 108620, Added error message 'The expiration date may not be changed' in Receive_Part_Impl___
--  031016  MaGulk  Merged bug 38948, Modified the PROCEDURE Make_Inventory_Trans___ by adding the condition to check the receipt date with the Site Date.
--  031016  PrJalk  Bug Fix 106224, Corrected wrong General_Sys.Init_Method calls for Implementation methods declared in Package.
--  031016  LEPESE  Added default parameter remove_unit_cost_ to methods Update___ and
--                  Issue_Part_Impl___. This is used to control removal of InventoryPartUnitCost
--                  records after issue (in method Update___). Added code in method Move_Part_Impl___
--                  to set a correct value of remove_unit_cost_ depending on type of move.
--  031014  PrJalk   Bug Fix 106224, Added missing and corrected wrong General_Sys.Init_Method calls.
--  031010  AnLaSe  Call Id 101491: added rotable_part_pool_id to view INVENTORY_PART_IN_STOCK_LOC.
--  031006  LEPESE  Added code in method Update___ to remove records from LU InventoryPartUnitCost
--                  when all quantity is issued for a given lot_batch_no and serial_no.
--  031001  GEBOSE  Call Id 104805, Added NOCHECK option to PartAvailabilityControl
--  031001          and CustOrdCustomer references in comments on columns in VIEW16,
--  031001          as well as PartAvailabilityControl reference in VIEW17.
--  031001  ThGulk  Changed substr to substrb, instr to instrb, length to lengthb.
--  030930  DAYJLK  Call Id 104193, Removed call to Inventory_Transaction_Hist_API.Set_Transaction_Ownership in Cancel_Receipt_In_Place.
--  030930  MaEelk  Merged LCS Bug 38482. Modified cursor get_max_lot_batch_no in method Get_Max_Lot_Batch_No.
--  030929  GEBOSE  Call Id 104805, Removed Rotable_Part_Pool_Id validation in method
--  030929          Unpack_Check_Insert___ and set the attribute to be non-insertable.
--  030929  DAYJLK  Call Id 104181, Modified Cancel_Receipt_In_Place to handle inventory revaluation accounting.
--  030929  MaEelk  Call ID 104250, Modified the error message as requested.
--  030926  JOHESE  Added check in Handle_Serial_Condition_Change & Handle_Lot_Condition_Change to prevent
--                  availability control id from being overwritten if the new condition code has no default
--                  availability control id.
--  030926  LEPESE  Call Id 103858: Added checks to prevent parts with part_cost_level
--                  'COST PER CONDITION', 'COST PER SERIAL', COST PER LOT BATCH' to be
--                  put into inventory without serial- or lot_batch number if they are
--                  serial- or lot_batch tracked. Changes made in the unpack_check methods.
--                  Moved correction of call ID 102382 to invtrans.apy.
--  030923  GEBOSE  Call Id 99720; Moved event firing for rotables from method
--  030923          Modify_Rotable_Part_Pool_Id to Update___ for better consistency.
--  030919  KrSilk  Call Id 103472; Modified view17 to add part_ownership_db column.
--  030919  DAYJLK  Call Id 103634, Modified Move_Part_Impl___ to update ownership information when parts are moved into transit.
--  030319  MaEelk  Call ID 103672, Modified Get_Inventory_Quantity.
--  030919  KrSilk  Call Id 103472; Modified view17 to have ownership data so that
--                  proper restrictions could be put on the LOV resulting out of it.
--  030918  JOHESE  Added condtion code to INVENTORY_PART_IN_STOCK_LOV8 and modified where condition
--  030918  ThPalk  Bug 38379, Removed the previous changes done under this bug.
--  030918  ThPalk  Bug 38379, Modified Unpack_Check_Insert___ and Unpack_Check_Update___
--  030917  JOHESE  Modified cursor get_location to select part_ownership_db instead of part_ownership in procedure Find_And_Issue_Part_Neg
--  030917  MAEELK  Call ID 102382, Changed the error message in Receive_Part_With_Posting.
--  030915  GEBOSE  Bug 102382, Created an additional check in the very beginning
--  030915          of method Receive_Part_With_Posting.
--  030814  RaSilk  Bug 37187, Removed check for del_oh_ = 0 in methods Return_Rework and Return_Credit.
--  030911  MIKULK  Bug 37995, Modified the VARCHAR declaration in the coding as VARCHAR2.
--  030911  DAYJLK  Modified parameter list of Cancel_Receipt_In_Place. Moved ownership validations to Validate_Cancel_Per_Line.
--  030910  DAYJLK  Modified Cancel_Receipt_In_Place by adding validations per inventory location and per InventoryPartInStock Record.
--  030909  DAYJLK  Called method Inv_Part_Ownership_Manager_API.Validate_Per_Inv_Part_Location in Receipt_In_Place.
--  030908  DAYJLK  Removed method Modify_On_Hand_By_Transfer_Qty and modified Receipt_In_Place.
--  030905  DAYJLK  Added method Cancel_Receipt_In_Place.
--  030904  JOHESE  Changed view INVENTORY_PART_IN_STOCK_ROT
--  030904  DAYJLK  Added overloaded procedure Get_Inventory_Quantity. Added function Get_Location_Type and
--  030904          Modified contents and parameters of Receipt_In_Place.
--  030901  GEBOSE  Added event firing for rotables in method Modify_Rotable_Part_Pool_Id.
--  030820  DAYJLK  Performed CR Merge.
--  030729  SeKalk  Modified procedure Return_Credit
--  030509  NaWalk  Made changes to take the value of the 'Order_Code' to be taken from Order Line.
--  ********************************** CR Merge **************************************************
--  030815  KiSalk   In Get_Inventory_Quantity, added cursor get_qty_loc and called when location is specified
--  030815           but not ownership, condition code, location type, etc. as suggested by AnTaus.
--  030814  KiSalk   The three tables in cursor get_location of Find_Part replaced with INVENTORY_PART_IN_STOCK_OWNER, replaced the occurrances
--  030814            of Inventory_Part_In_Stock_Tab & Inventory_Part_In_Stock with '&TABLE' and '&VIEW' and beautified some parts.
--  030806  DAYJLK  Added parameters exclude_rotable_pool_, and exclude_fa_rotable_pool_ to methods Create_Count_Report and
--  030806          Create_Count_Report_Impl___. Modified Create_Count_Report_Deferred__ to handle these parameters.
--  030806          Modified Cursor get_partloc in Create_Count_Report_Impl___ to include rotable pool id.
--  030730  KiSalk  SP4 Merge.
--  030725  DAYJLK  Added method Modify_On_Hand_By_Transfer_Qty, used in Transfer of Ownership to Company. Modified procedure Receipt_In_Place.
--  030724  DAYJLK  Modified procedure Receipt_In_Place.
--  030723  DAYJLK  Modified procedure Receipt_In_Place by adding call Inventory_Transaction_Hist_API.Set_Previous_Ownership.
--  030721  DAYJLK  Added public procedure Receipt_In_Place used for Transfer of Ownership in PKG.
--  030717  MaEelk  Removed the redirection to Get_Inventory_Quantity in Get_Qty_Onhand_By_Location, Get_Qty_In_Transit_By_Location and re_write the old logic.
--  030714  MaEelk  Added col comments to INVENTORY_PART_IN_STOCK_OWNER view.
--  030712  MaEelk  Redirected the code to Get_Inventory_Quantity in Get_Qty_Onhand_By_Location, Get_Qty_In_Transit_By_Location, Get_Inventory_Qty_Onhanad,
--  030712          Get_Inventory_Qty_Reserved, Get_Inventory_Qty_Rejected, Get_Inventory_Qty_Expired and Get_Aum_Qty_Plannable methods.
--  030709  GEBOSE  Wrapped nullable rotables-related text elements into NVL-functions
--  030709          to prevent erroneous code execution in Unpack_Check_Update___ and Validate_Rotable_Part_Pool___
--  030708  MaEelk  Added part ownership information to Make_Onhand_Analysis,Make_Onhand_Analysis_Impl___ and Make_Onhand_Analysis_Shopord.
--  030708          Modified Check_Quantity_Exist.
--  030707  MaGulk  Modified Get_Inventory_Quantity with default availability control values
--  030707  KiSalk replaced the call to Inventory_Part_In_Stock_API.Get_Aggregate_Qty_Consignment
--  030707           with Get_Externally_Owned_Inventory of same API.
--  030707  MaGulk  Modified Get_Inventory_Quantity cursor get_qty_cc to use VIEW15
--  030707          Modified VIEW15 to use VIEW2, Modified Get_Company_Owned_Inventory to use VIEW2 instead of subselect
--  030707          Renamed VIEW16 as VIEW2 and renamed all other views
--  030703  MaGulk  Modified Get_Inventory_Quantity to get quantities in transit
--  030701  MaGulk  Added Get_Inventory_Quantity and removed Get_Usable_Qty_Loc_Type
--  030630  GEBOSE  Moved part availability control check from Modify_Availability_Control_Id to Validate_Rotable_Part_Pool___
--  030627  MaGulk  Modified Get_Starting_Balance to exclude externally owned stock
--  030626  MaGulk  Added method Get_Usable_Qty_Loc_Type
--  030626  DAYJLK  Added parameters inventory_value_ and condition_code_ to method Count_Part_No_Pallet and Count_Part.
--  030626          Modified Count_Part by including condition_code_ as parameters in call to Inventory_Transaction_Hist_API.New.
--  030625  MaGulk  Added methods Get_Company_Owned_Inventory, Get_Externally_Owned_Inventory, Check_Quantity_Exist
--  030625          Modified VIEW3, added Qty_On_Hand & Qty_In_Transit
--  030624  MaGulk  Modified Get_Avail_Plan_Qty_Loc_Type to filter externally owned stock
--  030624          Added VIEW16 Inventory_Part_In_Stock_Owner
--  030624  MaGulk  Added validations specific to FA Rotable Pools to Validate_Rotable_Part_Pool___
--  030623  MaGulk  Replaced all logic in Get_Plannable_Qty_Onhand, Get_Plannable_Qty_Reserved,
--  030623          Get_Sales_Plannable_Qty_Onhand, Get_Sales_Plannable_Qty_Res, Get_Shop_Plannable_Qty_Onhand, Get_Shop_Plannable_Qty_Res
--  030623          with call to Get_Avail_Plan_Qty_Loc_Type
--  030620  MaGulk  Modified Validate_Rotable_Part_Pool___ added quantity validations and restructured for performance
--  030619  MaGulk  Added oldrec_ & partrec_ to parameters of Validate_Rotable_Part_Pool___
--  030619          Modifed Unpack_Check_Update___ to call Validate_Rotable_Part_Pool___ efficiently
--  030618  MaGulk  Replaced call to Validate_Rotable_Part_Pool___ with error in Unpack_Check_Insert___
--  030618          Modified Get_Rotable_Part_Pool_Qty with NVL to return 0 when NULL
--  030618          Moved Rotable_Pool_Site exist validation to Unpack_Check_Update___
--  030616  DAYJLK  Modified Count_Part by adding part ownership parameters to call Inventory_Transaction_Hist_API.New.
--  030616          Added new info message in Create_Count_Report_Deferred__.
--  030613  JOHESE  Added function Is_Part_In_Fa_Rotable_Pool
--  030613  MAJOSE  Corrections in call to Issue_Part within Find_And_Issue_Part.
--  030612  DAYJLK  Modified Cursor get_partloc in Create_Count_Report_Impl___.
--  030611  DAYJLK  Added parameters exclude_customer_owned_, exclude_supplier_loaned_, exclude_consignment_
--  030611          and exclude_company_owned_ to methods Create_Count_Report and Create_Count_Report_Impl___.
--  030611          Modified Create_Count_Report_Deferred__ to handle these parameters.
--  030611          Modified Cursor get_partloc in Create_Count_Report_Impl___ to include Part Ownership information.
--  030606  JOHESE  Modified Validate_Rotable_Part_Pool___
--  030605  MAJOSE  Added new Find_And_Issue_Part and Find_And_Issue_Part_Neg methods.
--                  These methods also returns transaction_id. Kept old methods for
--                  compatibility reasons.
--  030602  SHVESE  Added part_ownership and owning_customer_no in calls to Inventory_Transaction_Hist_API.New in the
--                  methods Move_Part_Impl__ and Make_Individuals.
--  030528  DAYJLK  Modified method Unissue_Part to use Inv_Part_Ownership_Manager_API.Unissue_Part instead of
--  030528          the corresponding method in Consignment_Stock_Manager_API.
--  030528  MaEelk  Removed public methods Get_Aggregate_Qty_Own_Consign,Get_Qty_In_Transit_Own_Consign and Get_Plannable_Qty_Onhand_Owner from the LU
--  030527  MaEelk  Replaced the call to Inventory_Part_In_Stock_API.Get_Qty_In_Transit_Own_Consign with Inventory_Part_In_Stock_API.Get_Total_Qty_In_Transit at prcedure Count_Part.
--  030526  MaEelk  Replaced the call to Inventory_Part_In_Stock_API.Get_Total_Qty_In_Transit with Inventory_Part_In_Stock_API.Get_Qty_In_Transit_Own_Consign at prcedure Count_Part.
--  030526  MaEelk  Added public method Get_Qty_In_Transit_Own_Consign to get sum of Qty_In_Transit for company owned and consignment stocks.
--  030526          Added public method Get_Plannable_Qty_Onhand_Owner to get sum of a particular ownership.
--  030523  MaEelk  Added public method Get_Aggregate_Qty_Own_Consign to get sum of Qty_Onhand for company owned and consignment stocks.
--  030523  JOHESE  Changed view INVENTORY_PART_IN_STOCK_ROT
--  030523  MaEelk  Added Ownership details to INVENTORY_PART_IN_STOCK_LOV, INVENTORY_PART_IN_STOCK_NOPAL, INVENTORY_PART_IN_STOCK_DELIV,
--  030523          INVENTORY_PART_IN_STOCK_LOV1, INVENTORY_PART_IN_STOCK_LOV3, INVENTORY_PART_IN_STOCK_LOV4 and INVENTORY_PART_IN_STOCK_LOV5.
--  030522  DAYJLK  Modified list of parameters in call to Inv_Part_Ownership_Manager_API.Move_Part by including Owning_Vendor_No_
--  030522          and Owning_Customer_No_ as additional parameters, and replacing from_consignment_stock_ and dest_consignment_stock_
--  030522          with from_loc_part_ownership_ and dest_part_loc_ownership respectively in Move_Part_Impl___ and Make_Individuals.
--  030521  JOHESE  Changed view INVENTORY_PART_IN_STOCK_ROT
--  030520  MaEelk  Added parameters Part_Ownership, Owning_Vendor_No and Owning_Customer_No to Receive_Part.Changed the logic to pass ownership details to Receive_Part_Impl___.
--  030520          Changed Receive_Part_From_Transit__ get ownership detatils of Inventory Location and passed those details to Receive_Part_Impl___.
--  030520  DAYJLK  Replaced call Inventory_Part_Stock_Owner_API.Check_Exist with call to Check_Consignment_Stock instead
--  030520          in Methods Return_Rework and Return_Credit to check specifically for consignment stock.
--  030520          Replaced the usage of Consignment_Stock_API with values in Part_Ownership in Make_Individuals and Move_Part_Impl___.
--  030516  MaEelk  Added parameters Part_Ownership, Owning_Vendor_No and Owning_Customer_No to Find_And_Issue_Part and Find_And_Issue_Part_Neg.
--  030516          Changed the logic to find the record matched with part ownership details.
--  030516  DAYJLK  Replaced call Consignment_Stock_Manager_API.Move_Part with Inv_Part_Ownership_Manager_API.Move_Part
--  030516          in method Move_Part_Impl___ and modified conditions to include Zero Cost checks only for
--  030516          Company Owned and Consignment Stock in method Issue_Part_Impl___.
--  030515  LEPESE  Bug 33933, Moved statements to update associated_transaction_id on transactions
--                  in method Move_Impl___ so that all move transactions gets updated.
--  030514  MaEelk  Added parameters Part_Ownership, Owning_Vendor_No and Owning_Customer_No to Find_Part and Find_And_Reserve_Part.
--  030513  MaEelk  Added Part_Ownership, Owning_Vendor_No and Owning_Customer_No to the view INVENTORY_PART_IN_STOCK_RES.
--  030507  MaGulk  Call ID 96959, Modified Modify_Availability_Control_Id to check
--  030507          for rotable part pool id
--  030505  GEBOSE  Changed method Purchase_Order_Receipt to handle ownership by
--  030425          adding Part_Ownership and Owning_Customer_No to the interface.
--  030430  MaGulk  Added quantity validations to Validate_Rotable_Part_Pool___
--  030430  JOHESE  Added view INVENTORY_PART_IN_STOCK_ROT
--  030429  MaGulk  Added location validations to Validate_Rotable_Part_Pool___
--  030428  MaMalk  Bug 37060, Removed VIEW15 and Instead of that Used the public view part_availability_control_pub for view INVENTORY_PART_IN_STOCK_LOV8.
--  030428  MaGulk  Modified Scrap_Part to check with part availability control
--  030425  GEBOSE  Changed method Receive_Part_Impl___ to consider ownership
--  030425          when calculating inventory value (zero for types of ownership
--  030425          other than company-owned or consignment).
--  030425  GEBOSE  Changed method Receive_Part_Impl___ to handle ownership by
--  030425          adding Part_Ownership and Owning_Customer_No to the interface.
--  030422  MaGulk  Added Validate_Rotable_Part_Pool___
--  030415  MaGulk  Added Get_Rotable_Part_Pool_Qty, Modify_Rotable_Part_Pool_Id
--  030415          Get_Rotable_Part_Pool_Id
--  030414  MaGulk  Added modifications for new column ROTABLE_PART_POOL_ID
--  030403  SaRalk  Bug 36638, Modified procedure Return_Credit.
--  030331  MaMalk  Bug 35144,  Added the view INVENTORY_PART_IN_STOCK_LOV8  to make manual reservations not possible with part availaility control
--  030331          set to Not Manual Reservation in shop order material reservation, Defined the view VIEW15 to use in a sub-query.
--  030324  DayJlk  Replaced all calls to methods in Pkg INVENTORY_PART_LOC_CONSIGN_API to Pkg INVENTORY_PART_STOCK_OWNER_API.
--  030324          Renamed call Get_Consignment_Vendor_No to Get_Owning_Vendor_No of Pkg Inventory_Transaction_Hist_API in Method Unissue_Part.
--  030321  JeLise  Bug 36103, Added create_date to view INVENTORY_PART_IN_STOCK_LOC and made some
--  030321          more changes in Get_Next_Count_Date.
--  **************************  TAKEOFF-2  **********************************
--  030314  ANHOSE  Bug 36103, Added attribute create_date and rewrote function Get_Next_Count_Date.
--  030306  ANHOSE  Bug 36101, Added include_all_qty to Create_Count_Report and Create_Count_Report_Impl___.
--  030306          Added new cursor get_all_qty to Create_Count_Report_Impl___.
--  030221  AnLaSe  Bug 29435 Changed errormessage in method Check_Valid_Move_Combinations (missed in IceAgeMerge).
--  030205  MaGulk  Bug 35435, Modified Get_Next_Count_Date, to calculate next count date when cyclic counting enabled and no counting has done earlier.
--  030130  MaEelk  Call ID 93384, Added Condition_Code to views INVENTORY_PART_IN_STOCK_LOV4 and INVENTORY_PART_IN_STOCK_LOV5.
--  030121  ChJalk  Bug 35154, Modified method Move_Part_Shipment, to facilitate moving parts from a floor stock
--  030121          location If uses 'Shipment Inventory' in order type.
--  021223  NaWalk  Bug 34626, Added the check for 'SERIAL TRACKING', 'LOT TRACKING' and 'ORDER BASED' to procedure 'Find_And_Issue_Part_Neg()'.
--  021125  ViPalk  Bug 34087, Modified the procedure Validate_Count_Part.
--  021118  ViPalk  Bug 34087, Modified the procedure Unpack_Check_Update___.
--  **************************** TSO Merge **********************************
--  021101  DhAalk  Bug 31860, Modified the PROCEDURE Receive_Part_Impl___.
--  021017  GaJalk  Bug 33377, Modified the procedure Find_Part.
--  020912  LEPESE  Bug 32806, added cost_ as parameter to method Unissue_Part. Used in call to
--                  Inventory_Part_In_Stock2_API.Receive_Part_Impl___.
--  021024  LEPESE  Moved validations for lot_batch_tracking in unpack_check_update___.
--  020920  LEPESE  ***************** IceAge Merge Start *********************
--  020823  AnHose  Bug 32202, To avoid the info message when the part is not pallet handled a dummy value is
--  020823          returned in method Get_Picking_Loc_To_Refill.
--  020806  Susalk  Bug 29435, Changed the Error messages in procedure 'Check_Valid_Move_Combinations'.
--  020703  Samnlk  Bug 29401, Change the If condition for the serial tracking in PROCEDURE Validate_Count_Part,Unpack_Check_Update and Unpack_Check_Insert
--  020619  AnHose  Bug 28092, Added code to Return_Rework to call Inventory_Transaction_Hist_API.Do_Booking
--  020619          with new transaction_code RETWOR-WIP and in Return_Credit with new transaction_code RETCRE-WIP.
--  020611  JICE    Bug 30944, Trunc added to expiration date checks in Unpack_Check_Update.
--  020531  JOHESE  Bug 28297, Optimized shortage check in Receive_Part_Impl___
--  020530  JSAnse  Bug fix 28622, in function Return_Rework and Return_Credit added check if the sites are connected to different companies.
--  020920  LEPESE  ***************** IceAge Merge End ***********************
--  020913  LEPESE  Added parameter cost_ to method Unissue_Part in order to be able
--                  to use original transaction cost in call to Inventory_Transaction_Hist_API.New.
--  020830  BEHAUS  Removed Split_Lot and Do_Split_Lot___. Added method Check_Lot_Batch_Exist.
--  020829  ANLASE  Added public methods Handle_Average_Level_Change and Handle_Serial_Removal
--                  for changing availability control id upon changing condition code.
--  020826  LEPESE  Removed correction of CID 87175.
--  020823  PEKR    CID 87175. Added condition_code allow check in Receive_Part_With_Posting.
--  020816  LEPESE  Added condition_code_ as parameter to method Receive_Part_With_Posting.
--  020816  PEKR    Added condition_code to VIEW3 (INVENTORY_PART_IN_STOCK_LOV).
--  020815  PEKR    Added condition_code to VIEW7 (INVENTORY_PART_IN_STOCK_LOV1) and
--                  VIEW4 (INVENTORY_PART_IN_STOCK_NOPAL).
--  020814  LEPESE  Added public function Is_Reserved_At_Any_Location.
--  020814  LEPESE  Minor code cleanup in methods modified 020813.
--  020813  LEPESE  Added condition_code functionality to methods Find_And_Issue_Part
--                  and Find_And_Issue_part_Neg.
--  020812  jagrno  Optimized call to VimSerialFromRemote in Insert___.
--  020809  LEPESE  Added parameter condition_code to the two methods named Receive_Part.
--                  Added validations for the combination of serial_tracking, lot_tracking and
--                  condition_code_usage in the unpack_check methods.
--  020808  JoAnSe  Added new view INVENTORY_PART_IN_STOCK_RES containing condition_code.
--                  The new view should be used from the manual reservation clients.
--  020806  ANLASE  Added parameter condition_code with default NULL in method Receive_Part_Impl___,
--                  Added condition_code to call to Receive_Part_Impl___ in Purchase_Order_Receipt.
--  020717  BEHAUS  Merged Lot Batch Mod functionality.
--  020715  LEPESE  Extended method Find_Part to allow search for quantities with a
--                  specific condition_code. Added default parameter condition_code to
--                  method Find_And_Reserve_Part.
--  020711  jagrno  Added dynamic call to VimSerialFromRemote in Insert___ in order
--                  to make VIM aware of new serials in Inventory.
--  020703  PEKR    Added public procedure Replace_Serial_No. Introduced a new
--                  in-parameter to_serial_no_ to method Move_Part_Impl___. Modified
--                  method Move_Part_Impl___ to handle call from Replace_Serial_No.
--  020701  NABEUS  Changed Purchase_Order_Receipt receipt method to have condition_code as
--                  a default null parameter.
--  020619  LEPESE  Replaced usage of method Inventory_Part_Config_API.Get_Inventory_Value_By_Method
--                  with usage of Inventory_Part_Unit_Cost_API.Get_Inventory_Value_By_Method.
--  020614  LEPESE  Added lot_batch_no and serial_no as default-parameters to methods
--                  Get_Aggregate_Qty_Consignment, Get_Aggregate_Qty_Onhand and
--                  Get_Total_Qty_In_Transit.
--  020614  CHJALK  Removed public attribute CONDITION_CODE from INVENTORY_PART_IN_STOCK_TAB.
--  020607  CHJALK  Added public attribute CONDITION_CODE to INVENTORY_PART_IN_STOCK_TAB.
--  020530  PEKR    Part_Serial_Catalog_API.Get_Current_Position changed to Part_Serial_Catalog_API.Get_Latest_Transaction
--                  in Validate_Count_Part.
--  020523  NASALK  Extended length of Serial no from VARCHAR2(15) to VARCHAR2(50) in view comments and in procedure Load_Serial_Array___
--  ******************************** takeoff ( Baseline)**************************************************
--  020328  ChFolk  Call ID 80641, Modifed the view, INVENTORY_PART_IN_STOCK_LOC.
--  020325  ANHO    Removed the commented code about the removed part_auto_reserv_ctrl.
--  020315  ChFolk  Rollback the changes renaming of column, part_reservation_control.
--  020313  MGUO    Bug fix 28478, The frequently used method Make_Onhand_Analysis_Impl___ has
--                  3 different calls to Site_API. This have been replaced by a single Site_API.Get call.
--  020304  CHFOLK  Added new parameter, to_wiev_dev_rej_no_ to the procedure, Move_Part.
--  020226  CaStse  Added NOCHECK in view INVENTORY_PART_IN_STOCK_LOC.
--  020220  CHFOLK  Modified PROCEDURE Move_Part_Impl___.
--  020206  CHFOLK  Modified CURSOR, get_location in the procedure, Find_Part according to the renaming of column, part_reservation_control as part_auto_reserv_ctrl in part_availability_control_tab.
--                  Created a new view, INVENTORY_PART_IN_STOCK_LOC.
--  020124  PHDE    Bug fix 26841, Set receipt date to most current date/time in Receive_Part_Impl___.
--  020111  JABALK  Removed the Bug fix 27028, because it is not a bug.
--  020110  MGUO    Bug fix 26832, Removed the pall_rec.pallet_state = 'AVAILABLE' check in Create_Count_Report_Impl___.
--  020108  JABALK  Bug fix 27028, Modified the method Issue_Part_Impl___ by adding a check on allow_neg_onhand_db_
--                  before raising error ISSUE_TO_BIG.
--  011211  MGUO    Bug fix 26841, Set receipt date to the most current date/time in Receive_Part_Impl___.
--  011019  JOHESE  Bug fix 19495, Removed bug fix 24032 an added new procedure Unissue_And_Move_Part.
--  011017  ANLASE  Removed Bug fix 25059.
--  011012  OSALLK  Bug Fix 20315,Modified the procedure Update___  and Insert__ to create refil task.
--  011008  ANLASE  Bug fix 25059, added call to Inventory_Part_API.Get_Negative_On_Hand_Db before
--                  ERROR_SYS ISSUE_TO_BIG in method Issue_Part_Impl___ to allow negative onhand for manufacturing.
--  011004  SuSalk  Bug 24658 fix,Extend the length of 'Company' to VARCHAR2(20).
--  011001  OSAllk  Bug fix 20315,Added FUNCTION Get_Picking_Loc_To_Refill and Modified the procedure Update___ to create refil task.
--  010919  AnHose  Bug 18007, Added code to Return_Rework and Return_Credit to
--                  Inventory_Transaction_Hist_API.Do_Booking with new transaction_code RETREVAL.
--  010918  CaSt    Bug 24032, Cleanup.
--  010914  SAMNLK  Bug Fix 24016 , Modify the procedure Move_Part_Impl___,Change the length to 200 in onhand_analysis_flag_.
--  010906  CaSt    Bug 24032, Added in-parameter location_no_ in procedure Unissue_Part.
--  010522  JSAnse  Bug fix 21592, Removed  dbms_output.
--  010322  DaJolk  Bug fix 20373, Modified PROCEDURE Purchase_Order_Receipt to set price to Zero
--                  when Zero Cost Only is used and Valuation method is Standard Cost.
--  010312  LeIsse  Bug fix 20297, Added check on order_code_ in Return_Rework and Return_Credit.
--  010302  ANLASE  Bug fix 19177, added call to Inventory_Transaction_Hist_API.Set_Associated_Transaction_Id
--                  for intrastat report.
--  010109  SHVE    Removed commented code(call to Inventory_Part_Config_API.New).
--  001214  PaLj    Removed overloading to the methods Make_Onhand_Analysis,
--                  Make_Onhand_Analysis_Shpord and Get_Starting_Balance
--  001214  LEPE    Added parameter issue_corr_cost_ to method Issue_Part. Modified
--                  parameter values in call to Issue_Part_Impl___ from Issue_Part.
--  001212  PaLj    Removed calls to Inventory_Part_Config_API.New
--  001208  PaLj    CID 57535. Changed function Get_Next_Count_Date to return NULL if location_type
--                  not is 'PICKING','F','PALLET','DEEP','BUFFER' or 'MANUFACTURING'.
--  001130  PaLj    CID 53969. Changed function Get_Next_Count_Date
--  001116  JOHESE  Added check on qty_in_transit when changing expiration_date in Update___.
--  001102  PaLj    Removed call to Part_Serial_Catalog_API.Set_Sup_Warranty_Man and Set_Cust_Warranty
--  001030  PaLj    Changed call to Part_Serial_Catalog_API.Set_Sup_Warranty to Set_Sup_Warranty_Man
--  001026  PaLj    Receive_Part_With_Posting: Get warranty for serial parts and
--                  copy them to the serial part, added after call to Receive_Part_Impl
--  001019  ANLASE  Changed error message in Unpack_Check_Insert___.
--  001017  PaLj    Changed check and error message in the end of Unpack_Check_Insert___
--  001017  JOKE    Added validation in move_part_impl___ that makes sure that
--                  Actual Cost handled parts aren't moved between sites.
--  001013  ANLASE  Replaced call Part_Catalog_API.Get_Configurable with Part_Catalog_API.Get_Configurable_Db
--                  in validation for configurations.
--  001009  JOKE    Added call to Set_Original_Transaction_Id for cancel transactions.
--  001003  ANLASE  Added validation in Unpack_Check_Insert to prevent storing configured parts.
--  000927  PaLj    Added overloading to the methods Make_Onhand_Analysis,
--                  Make_Onhand_Analysis_Impl, Make_Onhand_Analysis_Shpord and Get_Starting_Balance
--                  Until the other modules supports configuration_id.
--  000925  JOHESE  Added undefines.
--  000919  PaLj    Added configuration_id as parameter to the methods Make_Onhand_Analysis,
--                  Make_Onhand_Analysis_Impl, Make_Onhand_Analysis_Shpord and Get_Starting_Balance
--                  (configuration_id_ = NULL => Sum of all configurations)
--  000919  LEPE    Added call to Inventory_Part_Config_API.New from method
--                  Move_Part_Impl___ when moving a configuration to a new site.
--  000913  SHVE    Switched configuration_id and location_no to match the order of the
--                  view comments in VIEW3.
--  000901  JOHW    CTO changes added to support transport task.
--  000823  PERK    Added configuration_id in calls to functions in Counting_Report_Line_API
--                  and Counting_Result_API
--  000815  LEPE    Added calls to Inventory_Part_Config_API.New from methods
--                  Receive_Part and Purchase_Order_Receipt.
--  000803  LEPE    Completed adding of configuration_id.
--  000801  LEPE    Continued work with adding configuration_id.
--  000731  LEPE    Copied from LU InventoryPartLocation and added column
--                  configuration_id as part of the primary key
-----------------------------------------------------------------------------

layer Core;

-------------------- PUBLIC DECLARATIONS ------------------------------------

infinite_quantity_  CONSTANT NUMBER := 99999999999.99;

reserve_            CONSTANT VARCHAR2(7)  := 'RESERVE';

issue_              CONSTANT VARCHAR2(5)  := 'ISSUE';

TYPE Inventory_Location_Table IS TABLE OF INVENTORY_PART_IN_STOCK_TAB.location_no%TYPE INDEX BY BINARY_INTEGER;

TYPE Serial_Catch_Rec IS RECORD (
   serial_no  INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE,
   catch_qty  INVENTORY_PART_IN_STOCK_TAB.catch_qty_onhand%TYPE);

TYPE Serial_Catch_Table IS TABLE OF Serial_Catch_Rec INDEX BY BINARY_INTEGER;

TYPE Keys_And_Qty_Rec IS RECORD (
   contract          inventory_part_in_stock_tab.contract%TYPE,
   part_no           inventory_part_in_stock_tab.part_no%TYPE,
   configuration_id  inventory_part_in_stock_tab.configuration_id%TYPE,
   location_no       inventory_part_in_stock_tab.location_no%TYPE,
   lot_batch_no      inventory_part_in_stock_tab.lot_batch_no%TYPE,
   serial_no         inventory_part_in_stock_tab.serial_no%TYPE,
   eng_chg_level     inventory_part_in_stock_tab.eng_chg_level%TYPE,
   waiv_dev_rej_no   inventory_part_in_stock_tab.waiv_dev_rej_no%TYPE,
   activity_seq      inventory_part_in_stock_tab.activity_seq%TYPE,
   handling_unit_id  inventory_part_in_stock_tab.handling_unit_id%TYPE,
   quantity          inventory_part_in_stock_tab.qty_onhand%TYPE,
   catch_quantity    inventory_part_in_stock_tab.catch_qty_onhand%TYPE,
   transaction_id    NUMBER,
   transport_task_id NUMBER,
   to_location_no    inventory_part_in_stock_tab.location_no%TYPE);

TYPE Keys_And_Qty_Tab IS TABLE OF Keys_And_Qty_Rec
INDEX BY PLS_INTEGER;

TYPE Config_Lot_Serial_Rec IS RECORD (
   configuration_id inventory_part_in_stock_tab.configuration_id%TYPE,
   lot_batch_no     inventory_part_in_stock_tab.lot_batch_no%TYPE,
   serial_no        inventory_part_in_stock_tab.serial_no%TYPE,
   quantity         inventory_part_in_stock_tab.qty_onhand%TYPE);

TYPE Config_Lot_Serial_Tab IS TABLE OF Config_Lot_Serial_Rec
INDEX BY PLS_INTEGER;

TYPE Available_Stock_Rec IS RECORD
   (part_no                      inventory_part_in_stock_tab.part_no%TYPE, 
    location_no                  inventory_part_in_stock_tab.location_no%TYPE,
    lot_batch_no                 inventory_part_in_stock_tab.lot_batch_no%TYPE,
    serial_no                    inventory_part_in_stock_tab.serial_no%TYPE,
    eng_chg_level                inventory_part_in_stock_tab.eng_chg_level%TYPE,
    waiv_dev_rej_no              inventory_part_in_stock_tab.waiv_dev_rej_no%TYPE,
    configuration_id             inventory_part_in_stock_tab.configuration_id%TYPE,
    activity_seq                 inventory_part_in_stock_tab.activity_seq%TYPE,
    handling_unit_id             inventory_part_in_stock_tab.handling_unit_id%TYPE,
    qty_available                inventory_part_in_stock_tab.qty_onhand%TYPE,
    warehouse                    inventory_part_in_stock_tab.warehouse%TYPE,
    bay_no                       inventory_part_in_stock_tab.bay_no%TYPE,
    tier_no                      inventory_part_in_stock_tab.tier_no%TYPE,
    row_no                       inventory_part_in_stock_tab.row_no%TYPE,
    bin_no                       inventory_part_in_stock_tab.bin_no%TYPE,
    expiration_date              inventory_part_in_stock_tab.expiration_date%TYPE,
    receipt_date                 inventory_part_in_stock_tab.receipt_date%TYPE,
    warehouse_route_order        inventory_part_in_stock_tab.warehouse%TYPE,
    bay_route_order              inventory_part_in_stock_tab.bay_no%TYPE,
    row_route_order              inventory_part_in_stock_tab.row_no%TYPE,
    tier_route_order             inventory_part_in_stock_tab.tier_no%TYPE,
    bin_route_order              inventory_part_in_stock_tab.bin_no%TYPE,
    homogeneous_hu_node_qty      inventory_part_in_stock_tab.qty_onhand%TYPE,
    homogeneous_handling_unit_id inventory_part_in_stock_tab.handling_unit_id%TYPE);

TYPE Available_Stock_Tab IS TABLE OF Available_Stock_Rec
INDEX BY PLS_INTEGER;

TYPE Expired_Date_Qty_Rec IS RECORD
   (expiration_date        inventory_part_in_stock_tab.expiration_date%TYPE,
    contract               inventory_part_in_stock_tab.contract%TYPE,
    part_no                inventory_part_in_stock_tab.part_no%TYPE,
    configuration_id       inventory_part_in_stock_tab.configuration_id%TYPE,
    activity_seq           inventory_part_in_stock_tab.activity_seq%TYPE,
    lot_batch_no           inventory_part_in_stock_tab.lot_batch_no%TYPE,
    qty_expired            inventory_part_in_stock_tab.qty_onhand%TYPE);
    
TYPE Expired_Date_Qty_Tab IS TABLE OF Expired_Date_Qty_Rec
INDEX BY PLS_INTEGER;

-- gelr:access_ctrl_for_inv_reserv, start
TYPE Warehouse_Id_Tab IS TABLE OF inventory_part_in_stock_tab.warehouse%TYPE INDEX BY BINARY_INTEGER;
-- gelr:access_ctrl_for_inv_reserv, end

TYPE Public_Tab IS TABLE OF Public_Rec INDEX BY PLS_INTEGER;

-------------------- PRIVATE DECLARATIONS -----------------------------------

TYPE Plannable_Balance_TabType IS TABLE OF NUMBER
 INDEX BY BINARY_INTEGER;

TYPE Keys_Rec IS RECORD
   ( part_no            inventory_part_in_stock_tab.part_no%TYPE,
     contract           inventory_part_in_stock_tab.contract%TYPE,
     configuration_id   inventory_part_in_stock_tab.configuration_id%TYPE,
     location_no        inventory_part_in_stock_tab.location_no%TYPE,
     lot_batch_no       inventory_part_in_stock_tab.lot_batch_no%TYPE,
     serial_no          inventory_part_in_stock_tab.serial_no%TYPE,
     eng_chg_level      inventory_part_in_stock_tab.eng_chg_level%TYPE,
     waiv_dev_rej_no    inventory_part_in_stock_tab.waiv_dev_rej_no%TYPE,
     activity_seq       inventory_part_in_stock_tab.activity_seq%TYPE,
     handling_unit_id   inventory_part_in_stock_tab.handling_unit_id%TYPE );

TYPE Keys_Tab IS TABLE OF Keys_Rec INDEX BY PLS_INTEGER;

db_serial_tracking_             CONSTANT VARCHAR2(15) := Part_Serial_Tracking_API.db_serial_tracking;

db_not_serial_tracking_         CONSTANT VARCHAR2(19) := Part_Serial_Tracking_API.db_not_serial_tracking;

db_true_                        CONSTANT VARCHAR2(4)  := Fnd_Boolean_API.db_true;

db_false_                       CONSTANT VARCHAR2(5)  := Fnd_Boolean_API.db_false;

string_null_                    CONSTANT VARCHAR2(11) := Database_SYS.string_null_;

last_character_                 CONSTANT VARCHAR2(1)  := Database_SYS.Get_Last_Character;

find_for_transport_             CONSTANT VARCHAR2(18) := 'FIND_FOR_TRANSPORT';

-------------------- LU SPECIFIC IMPLEMENTATION METHODS ---------------------

PROCEDURE Raise_Invalid_Loc_Type_Error___ (
   part_no_          IN VARCHAR2,
   location_type_db_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'WRONGRECLOCTYPENOPA: Location type :P1 is not valid for part :P2', Inventory_Location_Type_API.Decode(location_type_db_), part_no_); 
END Raise_Invalid_Loc_Type_Error___;   
   
PROCEDURE Raise_Pre_Posting_Not_Acc_Error___ (
   error_desc_  IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'PREPOSTING: The Pre Posting is not accepted. :P1', error_desc_);   
END Raise_Pre_Posting_Not_Acc_Error___;   

PROCEDURE Raise_Serial_Qty_1_Error___
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'SERIALNOQTY: The quantity may only be 1 when serial numbers are being used.');
END Raise_Serial_Qty_1_Error___;

PROCEDURE Raise_No_Serials_Error___
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'NOSERIAL: No serials have been identified.');
END Raise_No_Serials_Error___;

PROCEDURE Raise_Qty_Onhand_Error___ (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   part_status_desc_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'ONHAQTYNOTALLOW: Inventory part :P1 on site :P2 has part status :P3 which does not allow quantity on hand', part_no_, contract_, part_status_desc_);
END Raise_Qty_Onhand_Error___;   
   
PROCEDURE Raise_Inconsistency_Error___ 
IS
BEGIN
   Error_SYS.Record_General(lu_name_,'INVPARTSERINCOS: Inconsistency between Inventory and Part Serial Catalog. Contact System Support.');
END Raise_Inconsistency_Error___;   

PROCEDURE Raise_Ownership_Mism_Error___
IS
BEGIN
   Error_SYS.Record_General(lu_name_, 'OWNERSIPMISMATCH: The ownership info on the source location does not match the ownership info on the destination location.');
END Raise_Ownership_Mism_Error___;   

-- Issue_Part_Impl___
--   Implementation method for Issue_Part.
PROCEDURE Issue_Part_Impl___ (
   transaction_id_               IN OUT NUMBER,
   accounting_id_                IN OUT NUMBER,
   trans_value_                  IN OUT NUMBER,
   catch_quantity_               IN OUT NUMBER,
   contract_                     IN     VARCHAR2,
   part_no_                      IN     VARCHAR2,
   configuration_id_             IN     VARCHAR2,
   location_no_                  IN     VARCHAR2,
   lot_batch_no_                 IN     VARCHAR2,
   serial_no_                    IN     VARCHAR2,
   eng_chg_level_                IN     VARCHAR2,
   waiv_dev_rej_no_              IN     VARCHAR2,
   activity_seq_                 IN     NUMBER,
   handling_unit_id_             IN     NUMBER,
   transaction_                  IN     VARCHAR2,
   quantity_                     IN     NUMBER,
   quantity_reserved_            IN     NUMBER,
   source_ref1_                  IN     VARCHAR2,
   source_ref2_                  IN     VARCHAR2,
   source_ref3_                  IN     VARCHAR2,
   source_ref4_                  IN     VARCHAR2,
   source_ref5_                  IN     VARCHAR2,
   source_                       IN     VARCHAR2,
   unreceive_                    IN     BOOLEAN,
   forced_                       IN     BOOLEAN,
   cost_detail_tab_              IN     Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   source_ref_type_              IN     VARCHAR2,
   reject_code_                  IN     VARCHAR2,
   remove_unit_cost_             IN     BOOLEAN,
   make_transaction_             IN     BOOLEAN,
   transit_location_group_       IN     VARCHAR2,
   report_earned_value_db_       IN     VARCHAR2,
   part_catalog_rec_             IN     Part_Catalog_API.Public_Rec,
   original_transaction_id_      IN     NUMBER,
   prevent_fifo_action_          IN     BOOLEAN,
   ownership_transfer_reason_id_ IN     VARCHAR2,
   validate_hu_struct_position_  IN     BOOLEAN DEFAULT TRUE,
   delivery_reason_id_           IN     VARCHAR2 DEFAULT NULL,
   move_dest_contract_           IN     VARCHAR2 DEFAULT NULL,
   move_dest_location_no_        IN     VARCHAR2 DEFAULT NULL )
IS
   oldrec_                     inventory_part_in_stock_tab%rowtype;
   newrec_                     inventory_part_in_stock_tab%rowtype;
   qty_unreceive_              NUMBER;
   source_ref_type_db_         VARCHAR2(50);
   unit_cost_                  NUMBER;
   inventory_part_rec_         Inventory_Part_API.Public_Rec;
   remove_unit_cost_local_     BOOLEAN;
   local_part_catalog_rec_     Part_Catalog_API.Public_Rec;
   report_earned_value_temp_   VARCHAR2(5);
   serial_no_for_stock_        INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE;
   location_type_db_           INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   serial_catch_tab_           Serial_Catch_Table;
   reservation_                BOOLEAN := FALSE;
   transport_tasks_reduced_    BOOLEAN := FALSE;
   refill_this_location_       BOOLEAN := TRUE;
BEGIN
   local_part_catalog_rec_ := Get_Part_Catalog_Rec___(part_no_, part_catalog_rec_);
   source_ref_type_db_     := Order_Type_API.Encode(source_ref_type_);
   --Avoid refill functinoality for issue transactions used for ownership transfer from/to CRA.
   IF (transaction_  IN ('COTOCRA-', 'CRATOCO-')) THEN 
      refill_this_location_ := FALSE;
   END IF;
   
   IF (serial_no_ != '*') THEN
      -- This is an attempt to issue a serial from Inventory
      IF NOT (Check_Exist___(contract_,
                             part_no_,
                             configuration_id_,
                             location_no_,
                             lot_batch_no_,
                             serial_no_,
                             eng_chg_level_,
                             waiv_dev_rej_no_,
                             activity_seq_,
                             handling_unit_id_)) THEN
         -- The serial does not exist in Inventory on the given stock record
         location_type_db_    := Inventory_Location_API.Get_Location_Type_Db(contract_,location_no_);
         serial_no_for_stock_ := Get_Serial_No_For_Stock(part_no_,
                                                         serial_no_,
                                                         local_part_catalog_rec_,
                                                         location_type_db_,
                                                         handling_unit_id_);
         IF (serial_no_for_stock_ = '*') THEN
            -- It is clear now that this part is not serial tracked in inventory at this location type.
            -- So in order to be able to proceed with the issue we must first create a stock record with
            -- this specific serial_no. It is done by running the generic split method. From there on the 
            -- logic can be execute as normal because now the serial exist in the expected stock location.
            serial_catch_tab_(1).serial_no := serial_no_;
            serial_catch_tab_(1).catch_qty := catch_quantity_;

            IF (quantity_reserved_ != 0) THEN
               reservation_ := TRUE;
            END IF;

            IF (unreceive_) THEN
               -- if there are any unexecuted transport tasks created to transport this receipt further then 
               -- we need to remove them before splitting the qty into the serial number
               Transport_Task_API.Reduce_Qty_On_Unexecuted_Tasks(contract_,
                                                                 part_no_,
                                                                 configuration_id_,
                                                                 location_no_,
                                                                 lot_batch_no_,
                                                                 serial_no_for_stock_,
                                                                 eng_chg_level_,
                                                                 waiv_dev_rej_no_,
                                                                 activity_seq_,
                                                                 handling_unit_id_,
                                                                 quantity_,
                                                                 catch_quantity_,
                                                                 source_ref1_ ,
                                                                 source_ref2_ ,
                                                                 source_ref3_ ,
                                                                 source_ref4_ ,
                                                                 NULL,
                                                                 NULL,
                                                                 source_ref_type_db_,
                                                                 Fnd_Boolean_API.DB_FALSE);
               transport_tasks_reduced_ := TRUE;
            END IF;

            Split_Into_Serials(contract_,
                               part_no_,
                               configuration_id_,
                               location_no_,
                               lot_batch_no_,
                               eng_chg_level_,
                               waiv_dev_rej_no_,
                               activity_seq_,
                               handling_unit_id_,
                               serial_catch_tab_,
                               reservation_);
         END IF;
      END IF;
   END IF;

   IF (unreceive_) AND (NOT transport_tasks_reduced_) THEN
      -- The receipt might have been directly assigned to a transport task for putaway.
      -- We need to reduce the quantity that we are about to unreceive from the transport task
      -- before reducing the qty_onhand on the stock record.
      Transport_Task_API.Reduce_Qty_On_Unexecuted_Tasks(contract_,
                                                        part_no_,
                                                        configuration_id_,
                                                        location_no_,
                                                        lot_batch_no_,
                                                        serial_no_,
                                                        eng_chg_level_,
                                                        waiv_dev_rej_no_,
                                                        activity_seq_,
                                                        handling_unit_id_,
                                                        quantity_,
                                                        catch_quantity_,
                                                        source_ref1_ ,
                                                        source_ref2_ ,
                                                        source_ref3_ ,
                                                        source_ref4_ ,
                                                        NULL,
                                                        NULL,
                                                        source_ref_type_db_,
                                                        Fnd_Boolean_API.DB_FALSE);
   END IF;

   IF quantity_ IS NULL THEN
      Error_SYS.Record_General('InventoryPartInStock', 'NULL_QTY: The quantity must have a value.');
   END IF;

   Error_SYS.Check_Not_Null('InventoryPartInStock', 'QUANTITY_RESERVED', quantity_reserved_);

   trans_value_   := 0;
   accounting_id_ := 0;
   -- Always 'MODIFY'
   oldrec_ := Lock_By_Keys___(contract_, part_no_, configuration_id_,
                              location_no_, lot_batch_no_, serial_no_,
                              eng_chg_level_, waiv_dev_rej_no_, activity_seq_, handling_unit_id_);

   IF (oldrec_.location_type = Inventory_Location_Type_API.DB_QUALITY_ASSURANCE) THEN
      IF ((source_ref1_     IS NULL) OR
          (source_ref_type_db_  IS NULL) OR
          (source_ref_type_db_ NOT IN (Order_Type_API.DB_PURCHASE_ORDER, Order_Type_API.DB_PURCH_RECEIPT_RETURN))) THEN
         Error_SYS.Record_General('InventoryPartInStock','NOPURRETISS: It is only allowed to issue from a quality assurance location when connected to a :P1 or :P2.', Order_Type_API.Decode(Order_Type_API.DB_PURCHASE_ORDER), Order_Type_API.Decode(Order_Type_API.DB_PURCH_RECEIPT_RETURN));
      END IF;
   END IF;

   IF (oldrec_.location_type = Inventory_Location_Type_API.DB_ARRIVAL) THEN
      IF ((source_ref1_     IS NULL) OR
          (source_ref_type_db_  IS NULL) OR
          (source_ref_type_db_ NOT IN (Order_Type_API.DB_PURCHASE_ORDER, Order_Type_API.DB_SHIPMENT_ORDER, Order_Type_API.DB_PURCH_RECEIPT_RETURN))) THEN
         Error_SYS.Record_General('InventoryPartInStock','NOPURRETSHIPISS: It is only allowed to issue from an arrival location when connected to a :P1 or :P2 or :P3.', Order_Type_API.Decode(Order_Type_API.DB_PURCHASE_ORDER), Order_Type_API.Decode(Order_Type_API.DB_SHIPMENT_ORDER),
                                   Order_Type_API.Decode(Order_Type_API.DB_PURCH_RECEIPT_RETURN));
      END IF;
   END IF;

   inventory_part_rec_ := Inventory_Part_API.Get(contract_, part_no_);
   -- Check for frozen part
   IF oldrec_.freeze_flag = 'Y' THEN
      Raise_Freeze_Flag_Error(part_no_, location_no_);
   END IF;

   -- Check for zero_cost_flag only if stock is Company Owned or Consignment
   IF (NVL(oldrec_.part_ownership, Part_Ownership_API.DB_COMPANY_OWNED) IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                                                           Part_Ownership_API.DB_CONSIGNMENT)) THEN
      IF inventory_part_rec_.zero_cost_flag = 'N' THEN
         unit_cost_ := Inventory_Part_Unit_Cost_API.Get_Inventory_Value_By_Method(contract_,
                                                                                  part_no_,
                                                                                  configuration_id_,
                                                                                  lot_batch_no_,
                                                                                  serial_no_);
         IF (unit_cost_ = 0)  THEN
            Error_SYS.Record_General('InventoryPartInStock', '1226: The value of the inventory transaction may not be 0 for part :P1 on site :P2.', part_no_, contract_);
         END IF;
      END IF;
      IF inventory_part_rec_.zero_cost_flag = 'O' THEN
         unit_cost_ := Inventory_Part_Unit_Cost_API.Get_Inventory_Value_By_Method(contract_,
                                                                                  part_no_,
                                                                                  configuration_id_,
                                                                                  lot_batch_no_,
                                                                                  serial_no_);
         IF (unit_cost_ != 0)  THEN
             Error_SYS.Record_General('InventoryPartInStock', 'PARTZEROCOSTONLY: The value of the inventory transaction may only be 0 for part :P1 on site :P2.', part_no_, contract_);
         END IF;
      END IF;
   END IF;

   IF forced_ = FALSE THEN
      IF (quantity_ > (oldrec_.qty_onhand - oldrec_.qty_reserved + quantity_reserved_)) THEN
         IF (unreceive_) THEN
            Error_SYS.Record_General('InventoryPartInStock', 'STOCK_NOT_AVAILABLE: The receipt cannot be undone since the received quantity is no longer available on the location to which it was received.');
         ELSE
            Raise_Over_Issue_Error___(oldrec_);
         END IF;
      END IF;
   END IF;

   IF unreceive_ = TRUE THEN
      qty_unreceive_ := quantity_;
   ELSE
      qty_unreceive_ := 0;
   END IF;

   IF (quantity_ = oldrec_.qty_onhand) THEN
      catch_quantity_ := NVL(catch_quantity_, oldrec_.catch_qty_onhand);
   END IF;

   IF (make_transaction_) THEN
      IF (NVL(activity_seq_, 0) = 0) THEN
         report_earned_value_temp_ := NULL;
      ELSE
         report_earned_value_temp_ := report_earned_value_db_;
      END IF;

      Inventory_Transaction_Hist_API.NEW(
                               transaction_id_               => transaction_id_,
                               accounting_id_                => accounting_id_,
                               value_                        => trans_value_,
                               transaction_code_             => transaction_,
                               contract_                     => contract_,
                               part_no_                      => part_no_,
                               configuration_id_             => configuration_id_,
                               location_no_                  => location_no_,
                               lot_batch_no_                 => lot_batch_no_,
                               serial_no_                    => serial_no_,
                               waiv_dev_rej_no_              => waiv_dev_rej_no_,
                               eng_chg_level_                => eng_chg_level_,
                               activity_seq_                 => activity_seq_,
                               handling_unit_id_             => handling_unit_id_,
                               project_id_                   => oldrec_.project_id,
                               source_ref1_                  => source_ref1_ ,
                               source_ref2_                  => source_ref2_ ,
                               source_ref3_                  => source_ref3_ ,
                               source_ref4_                  => source_ref4_ ,
                               source_ref5_                  => source_ref5_,
                               reject_code_                  => reject_code_,
                               cost_detail_tab_              => cost_detail_tab_,
                               unit_cost_                    => NULL,
                               quantity_                     => quantity_,
                               qty_reversed_                 => qty_unreceive_,
                               catch_quantity_               => catch_quantity_,
                               source_                       => source_,
                               source_ref_type_              => source_ref_type_,
                               owning_vendor_no_             => oldrec_.owning_vendor_no,
                               condition_code_               => NULL,
                               location_group_               => NULL,
                               part_ownership_db_            => NVL(oldrec_.part_ownership, Part_Ownership_API.DB_COMPANY_OWNED),
                               owning_customer_no_           => oldrec_.owning_customer_no,
                               expiration_date_              => oldrec_.expiration_date,
                               receipt_date_                 => oldrec_.receipt_date,
                               transit_location_group_       => transit_location_group_,
                               report_earned_value_db_       => report_earned_value_temp_,
                               operational_condition_db_     => NULL,
                               original_transaction_id_      => original_transaction_id_,
                               prevent_fifo_action_          => prevent_fifo_action_,
                               availability_control_id_      => oldrec_.availability_control_id,
                               ownership_transfer_reason_id_ => ownership_transfer_reason_id_,
                               delivery_reason_id_           => delivery_reason_id_,
                               move_dest_contract_           => move_dest_contract_,
                               move_dest_location_no_        => move_dest_location_no_ );
   END IF;

   newrec_                  := oldrec_;
   newrec_.qty_onhand       := oldrec_.qty_onhand - quantity_;
   newrec_.catch_qty_onhand := NVL(oldrec_.catch_qty_onhand,0) - catch_quantity_;

   IF (quantity_reserved_ != 0) THEN
      newrec_.qty_reserved := oldrec_.qty_reserved - Least(quantity_reserved_, quantity_);
   END IF;
      
   IF (oldrec_.part_ownership IS NULL) THEN
      newrec_.part_ownership := Part_Ownership_API.DB_COMPANY_OWNED;
   END IF;

   IF (transaction_id_ IS NOT NULL) THEN
      newrec_.latest_transaction_id := transaction_id_;
   END IF;
   IF (make_transaction_) THEN
      remove_unit_cost_local_ := remove_unit_cost_;
   ELSE
      remove_unit_cost_local_ := FALSE;
   END IF;

   Check_And_Update_By_Keys___(oldrec_                       => oldrec_,
                               newrec_                       => newrec_,
                               remove_unit_cost_             => remove_unit_cost_local_,
                               part_catalog_rec_             => local_part_catalog_rec_,
                               refill_this_location_         => refill_this_location_,
                               validate_hu_struct_position_  => validate_hu_struct_position_);
END Issue_Part_Impl___;


-- Receive_Part_Impl___
--   Implementation method for ReceivePartFromTransit.
PROCEDURE Receive_Part_Impl___ (
   transaction_id_               IN OUT NUMBER,
   accounting_id_                IN OUT NUMBER,
   trans_value_                  IN OUT NUMBER,
   contract_                     IN     VARCHAR2,
   part_no_                      IN     VARCHAR2,
   configuration_id_             IN     VARCHAR2,
   location_no_                  IN     VARCHAR2,
   lot_batch_no_                 IN     VARCHAR2,
   serial_no_                    IN     VARCHAR2,
   eng_chg_level_                IN     VARCHAR2,
   waiv_dev_rej_no_              IN     VARCHAR2,
   activity_seq_                 IN     NUMBER,
   handling_unit_id_             IN     NUMBER,
   transaction_                  IN     VARCHAR2,
   expiration_date_              IN     DATE,
   quantity_                     IN     NUMBER,
   quantity_reserved_            IN     NUMBER,
   catch_quantity_               IN     NUMBER,
   source_ref1_                  IN     VARCHAR2,
   source_ref2_                  IN     VARCHAR2,
   source_ref3_                  IN     VARCHAR2,
   source_ref4_                  IN     VARCHAR2,
   source_ref5_                  IN     VARCHAR2,
   source_                       IN     VARCHAR2,
   unissue_                      IN     BOOLEAN,
   unit_cost_                    IN     NUMBER,
   source_ref_type_              IN     VARCHAR2,
   vendor_no_                    IN     VARCHAR2,
   receipt_date_                 IN     DATE,
   condition_code_               IN     VARCHAR2,
   part_ownership_               IN     VARCHAR2,
   owning_customer_no_           IN     VARCHAR2,
   cost_detail_tab_              IN     Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   set_qty_reversed_             IN     BOOLEAN,
   issue_transaction_id_         IN     NUMBER,   
   operational_condition_db_     IN     VARCHAR2,
   part_catalog_rec_             IN     Part_Catalog_API.Public_Rec,
   availability_control_id_      IN     VARCHAR2,
   validate_hu_struct_position_  IN     BOOLEAN,
   ownership_transfer_reason_id_ IN     VARCHAR2,
   delivery_reason_id_           IN     VARCHAR2  DEFAULT NULL,
   del_note_no_                  IN     VARCHAR2  DEFAULT NULL,
   del_note_date_                IN     DATE      DEFAULT NULL)
IS
   new_record_                    BOOLEAN;
   oldrec_                        inventory_part_in_stock_tab%ROWTYPE;
   newrec_                        inventory_part_in_stock_tab%ROWTYPE;
   location_type_db_              inventory_part_in_stock_tab.location_type%TYPE;
   local_unit_cost_               NUMBER := 0;
   qty_unissue_                   NUMBER := 0;
   source_ref_type_db_             VARCHAR2(50);
   new_expiration_date_           DATE;
   new_receipt_date_              DATE;
   new_availability_control_id_   INVENTORY_PART_IN_STOCK_TAB.availability_control_id%TYPE;
   today_                         DATE := Site_API.Get_Site_Date(contract_);
   part_rec_                      Inventory_Part_API.Public_Rec;
   local_cost_detail_tab_         Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   serial_no_for_stock_           INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE;
   local_part_catalog_rec_        Part_Catalog_API.Public_Rec;
   receive_from_transit_          BOOLEAN := FALSE;
   receipt_in_place_              BOOLEAN := FALSE;
   receipt_for_rental_asset_trf_  BOOLEAN := FALSE;
   serial_no_is_changed_          BOOLEAN := FALSE;
   set_serial_as_invent_tracked_  BOOLEAN := FALSE;
   undo_customer_order_delivery_  BOOLEAN := FALSE;
   undo_shipment_delivery_        BOOLEAN := FALSE;
   undo_purch_receipt_return_     BOOLEAN := FALSE;
   ownership_conflict_            BOOLEAN := FALSE;
   last_calendar_date_            DATE    := Database_SYS.last_calendar_date_;
BEGIN
   CASE transaction_
      WHEN 'INVREC'     THEN  receive_from_transit_         := TRUE;
      WHEN 'XO-ARRIVAL' THEN  receipt_in_place_             := TRUE;
      WHEN 'COTOCRA+'   THEN  receipt_for_rental_asset_trf_ := TRUE;
      WHEN 'CRATOCO+'   THEN  receipt_for_rental_asset_trf_ := TRUE;
      WHEN 'OEUNSHIP'   THEN  undo_customer_order_delivery_ := TRUE;
      WHEN 'OEUNSHIPNI' THEN  undo_customer_order_delivery_ := TRUE;
      WHEN 'UNDELCONOU' THEN  undo_customer_order_delivery_ := TRUE;
      WHEN 'UNDELCONIN' THEN  undo_customer_order_delivery_ := TRUE;
      WHEN 'UNSHIPTRAN' THEN  undo_customer_order_delivery_ := TRUE;
      WHEN 'COUNSHPTRN' THEN  undo_customer_order_delivery_ := TRUE;
      WHEN 'UNSHIPDIR'  THEN  undo_customer_order_delivery_ := TRUE;
      WHEN 'COUNSHPDIR' THEN  undo_customer_order_delivery_ := TRUE;
      WHEN 'UNCODELVOU' THEN  undo_customer_order_delivery_ := TRUE;
      WHEN 'UNCODELVIN' THEN  undo_customer_order_delivery_ := TRUE;
      WHEN 'UND-SHPODW' THEN  undo_shipment_delivery_       := TRUE;
      WHEN 'UND-SHPODS' THEN  undo_shipment_delivery_       := TRUE;
      WHEN 'PD-UNSHIP'  THEN  undo_shipment_delivery_       := TRUE;
      WHEN 'RETCORWORK' THEN  undo_purch_receipt_return_    := TRUE;
      WHEN 'RETCORWINT' THEN  undo_purch_receipt_return_    := TRUE;
      WHEN 'RETCORCRE'  THEN  undo_purch_receipt_return_    := TRUE;
      ELSE NULL;
   END CASE;

   IF ((issue_transaction_id_ IS NULL) AND (NOT receive_from_transit_) AND (NOT receipt_for_rental_asset_trf_)) THEN
      -- This is not Cancel of Issue or Receipt from Transit, just a normal receipt into stock.
      Warehouse_Bay_Bin_API.Check_Receipts_Blocked(contract_, location_no_);
      Inventory_Putaway_Manager_API.Check_Storage_Requirements(contract_,
                                                               part_no_,
                                                               configuration_id_,
                                                               location_no_,
                                                               lot_batch_no_,
                                                               serial_no_,
                                                               eng_chg_level_,
                                                               waiv_dev_rej_no_,
                                                               activity_seq_,
                                                               handling_unit_id_,
                                                               quantity_);
   END IF;

   part_rec_               := Inventory_Part_API.Get(contract_,part_no_);
   trans_value_            := 0;
   accounting_id_          := 0;
   local_part_catalog_rec_ := Get_Part_Catalog_Rec___(part_no_, part_catalog_rec_);
   location_type_db_       := Inventory_Location_API.Get_Location_Type_Db(contract_,location_no_);
   serial_no_for_stock_    := Get_Serial_No_For_Stock(part_no_,
                                                      serial_no_,
                                                      local_part_catalog_rec_,
                                                      location_type_db_,
                                                      handling_unit_id_);
   IF (serial_no_for_stock_ != serial_no_) THEN
      ownership_conflict_ := Ownership_Conflict_Exists___(contract_,
                                                          part_no_,
                                                          configuration_id_,
                                                          location_no_,
                                                          lot_batch_no_,
                                                          serial_no_for_stock_,
                                                          eng_chg_level_,
                                                          waiv_dev_rej_no_,
                                                          activity_seq_,
                                                          handling_unit_id_,
                                                          part_ownership_,
                                                          owning_customer_no_,
                                                          vendor_no_);
      IF (ownership_conflict_) THEN
         -- Changing the serial number will create an ownership conflict that results in an error message.
         -- So instead we keep the serial number as it is in InventoryPartInStock and indicate the serial
         -- as being tracked in inventory although it is only set as receipt and issue tracking in PartCatalog.
         serial_no_for_stock_          := serial_no_;
         set_serial_as_invent_tracked_ := TRUE;
      ELSE
         serial_no_is_changed_ := TRUE;
      END IF;
   END IF;

   -- Investigate if a new record should be created or if an old
   -- one is present and should be updated.
   IF (Check_Exist(contract_, part_no_,configuration_id_,
                   location_no_, lot_batch_no_,serial_no_for_stock_,
                   eng_chg_level_,waiv_dev_rej_no_, activity_seq_, handling_unit_id_)) THEN

      new_record_ := FALSE;
      oldrec_     := Lock_By_Keys___(contract_,part_no_,configuration_id_,
                                     location_no_,lot_batch_no_,serial_no_for_stock_,
                                     eng_chg_level_,waiv_dev_rej_no_,activity_seq_, handling_unit_id_);
   ELSE
      new_record_ := TRUE;
   END IF;

   IF ((new_record_) OR (oldrec_.qty_onhand = 0 AND oldrec_.qty_in_transit = 0)) THEN
      -- Checks if the ownership is allowed to be mixed or not in the location level
      IF (issue_transaction_id_ IS NULL) AND (NOT receipt_in_place_ AND NOT receipt_for_rental_asset_trf_) THEN
         Check_Allow_Ownership_Mix (contract_,
                                    part_no_,
                                    location_no_,
                                    part_ownership_,
                                    owning_customer_no_,
                                    vendor_no_);
      END IF;

      -- both receipt_date and expiration_date should be inititated
      new_receipt_date_ := NVL(receipt_date_, today_);
      IF (expiration_date_ IS NULL) THEN
         IF (part_rec_.durability_day IS NOT NULL)  THEN
            new_expiration_date_ := TRUNC(new_receipt_date_) + part_rec_.durability_day;
         END IF;
      ELSE
         new_expiration_date_ := expiration_date_;
      END IF;
      -- When receiving into a new or empty stock record then we accept the PAC ID sent in through the method parameter.
      new_availability_control_id_ := availability_control_id_;
   ELSE
      IF ((NVL(TRUNC(oldrec_.expiration_date), last_calendar_date_)) >
          (NVL(TRUNC(expiration_date_),        last_calendar_date_))) THEN
         IF (Intersite_Intracomp_Order___(contract_,
                                          source_ref1_,
                                          Order_Type_API.Encode(source_ref_type_),
                                          vendor_no_)) THEN
            Error_SYS.Record_General(lu_name_, 'TRANSEXPDATELATE: The quantity In Transit can only be received to a Stock Record having expiration date :P1 or earlier.', TRUNC(expiration_date_));
         END IF;
      END IF;

      IF (oldrec_.expiration_date IS NULL) THEN
         new_expiration_date_ := expiration_date_;
      END IF;
   END IF;

   IF ((new_expiration_date_ IS NOT NULL) AND
       (NOT unissue_) AND
       (TRUNC(new_expiration_date_) <= TRUNC(today_))) THEN
      IF NOT (Intersite_Intracomp_Order___(contract_,
                                           source_ref1_,
                                           Order_Type_API.Encode(source_ref_type_),
                                           vendor_no_)) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'EXPIREDATEERR: The expiration date must be a future date.');
      END IF;
   END IF;

   -- Check for frozen part
   IF oldrec_.freeze_flag = 'Y' THEN
      Raise_Freeze_Flag_Error(part_no_, location_no_);
   END IF;
   -- Allow positive quantity only
   IF NVL(quantity_, 0) <= 0 THEN
      Error_SYS.Record_General('InventoryPartInStock', 'RECQTYNOVALID: The quantity to receive must be greater than zero.');
   END IF;

   source_ref_type_db_ := Order_Type_API.Encode(source_ref_type_);
   IF (oldrec_.location_type = Inventory_Location_Type_API.DB_QUALITY_ASSURANCE) THEN
      IF ((source_ref1_          IS NULL) OR
          (source_ref_type_db_   IS NULL) OR
          (source_ref_type_db_   != Order_Type_API.DB_PURCHASE_ORDER)) THEN
         Error_SYS.Record_General('InventoryPartInStock','NOPURREC: It is only allowed to receive into a quality assurance location when connected to a :P1.', Order_Type_API.Decode(Order_Type_API.DB_PURCHASE_ORDER));
      END IF;
   END IF;

   IF (oldrec_.location_type = Inventory_Location_Type_API.DB_ARRIVAL) THEN
      IF ((source_ref1_          IS NULL) OR
          (source_ref_type_db_   IS NULL) OR
          (source_ref_type_db_   NOT IN (Order_Type_API.DB_PURCHASE_ORDER, Order_Type_API.DB_SHIPMENT_ORDER))) THEN
         Error_SYS.Record_General('InventoryPartInStock','NOPURSHIPREC: It is only allowed to receive into an arrival location when connected to a :P1 or :P2.', Order_Type_API.Decode(Order_Type_API.DB_PURCHASE_ORDER), Order_Type_API.Decode(Order_Type_API.DB_SHIPMENT_ORDER));
      END IF;
   END IF;
   
   IF NOT (location_type_db_ IN (Inventory_Location_Type_API.DB_PICKING,
                                 Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                 Inventory_Location_Type_API.DB_PRODUCTION_LINE,
                                 Inventory_Location_Type_API.DB_ARRIVAL) OR
          (location_type_db_ = Inventory_Location_Type_API.DB_QUALITY_ASSURANCE AND source_ref_type_db_  != Order_Type_API.DB_SHIPMENT_ORDER) OR 
          (location_type_db_ = Inventory_Location_Type_API.DB_SHIPMENT AND (undo_shipment_delivery_ OR undo_customer_order_delivery_ OR undo_purch_receipt_return_))) THEN
      Raise_Invalid_Loc_Type_Error___(part_no_, location_type_db_);
   END IF;
   
   IF (part_ownership_ IN ( 'CONSIGNMENT','COMPANY OWNED')) THEN
      local_unit_cost_       := unit_cost_;
      local_cost_detail_tab_ := cost_detail_tab_;

      IF ((unit_cost_ IS NULL) AND (cost_detail_tab_.COUNT = 0)) THEN
         local_cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(contract_,
                                                                                           part_no_,
                                                                                           configuration_id_,
                                                                                           lot_batch_no_,
                                                                                           serial_no_);
      END IF;
   END IF;

   IF (set_qty_reversed_) THEN
      qty_unissue_ := quantity_;
   END IF;
   
   Inventory_Transaction_Hist_API.NEW(transaction_id_           => transaction_id_,
                                      accounting_id_            => accounting_id_,
                                      value_                    => trans_value_,
                                      transaction_code_         => transaction_,
                                      contract_                 => contract_,
                                      part_no_                  => part_no_,
                                      configuration_id_         => configuration_id_,
                                      location_no_              => location_no_,
                                      lot_batch_no_             => lot_batch_no_,
                                      serial_no_                => serial_no_,
                                      waiv_dev_rej_no_          => waiv_dev_rej_no_,
                                      eng_chg_level_            => eng_chg_level_,
                                      activity_seq_             => activity_seq_,
                                      handling_unit_id_         => handling_unit_id_,
                                      project_id_               => oldrec_.project_id,
                                      source_ref1_              => source_ref1_,
                                      source_ref2_              => source_ref2_,
                                      source_ref3_              => source_ref3_,
                                      source_ref4_              => source_ref4_,
                                      source_ref5_              => source_ref5_,
                                      reject_code_              => NULL,
                                      cost_detail_tab_          => local_cost_detail_tab_,
                                      unit_cost_                => local_unit_cost_,
                                      quantity_                 => quantity_,
                                      qty_reversed_             => qty_unissue_,
                                      catch_quantity_           => catch_quantity_,
                                      source_                   => source_,
                                      source_ref_type_          => source_ref_type_,
                                      owning_vendor_no_         => vendor_no_,
                                      condition_code_           => condition_code_,
                                      location_group_           => NULL,
                                      part_ownership_db_        => part_ownership_,
                                      owning_customer_no_       => owning_customer_no_,
                                      expiration_date_          => NVL(new_expiration_date_, oldrec_.expiration_date),
                                      issue_transaction_id_     => issue_transaction_id_,
                                      operational_condition_db_ => operational_condition_db_,
                                      ownership_transfer_reason_id_ => ownership_transfer_reason_id_,
                                      delivery_reason_id_           => delivery_reason_id_,
                                      del_note_no_                  => del_note_no_,
                                      del_note_date_                => del_note_date_);

   IF (transaction_ IN ('RETSHIPDIR', 'RETDIFSREC')) THEN
      Invent_Trans_Interconnect_API.Connect_Transactions(issue_transaction_id_, transaction_id_, Invent_Trans_Conn_Reason_API.DB_INTERSITE_TRANSFER);
   END IF;

   IF (set_serial_as_invent_tracked_) THEN
      Part_Serial_Catalog_API.Set_Tracked_In_Inventory(part_no_, serial_no_);
   END IF;

   IF ((Mpccom_System_Parameter_API.Get_parameter_value1('SHORTAGE_HANDLING') = 'Y')  AND
                                                     (part_rec_.shortage_flag = 'Y')) THEN
      IF (Shortage_Demand_API.Shortage_Exists(contract_, part_no_) != 0) THEN
         Short_Part_Increase_Hist_API.New(contract_,
                                          part_no_,
                                          NVL(source_ref_type_,Mpccom_Transaction_Code_API.Get_Order_Type(transaction_)),
                                          source_ref1_,
                                          source_ref2_,
                                          source_ref3_,
                                          source_ref4_,
                                          quantity_,
                                          today_);
      END IF;
   END IF;

   newrec_ := oldrec_;

   IF new_expiration_date_ IS NOT NULL THEN
      newrec_.expiration_date := new_expiration_date_;
   END IF;

   IF new_receipt_date_ IS NOT NULL THEN
      newrec_.receipt_date := new_receipt_date_;
   END IF;

   IF (new_availability_control_id_ IS NOT NULL) THEN
      newrec_.availability_control_id := new_availability_control_id_;
   END IF;

   IF (part_ownership_ IS NOT NULL) THEN
      newrec_.part_ownership := part_ownership_;
   END IF;

   IF (vendor_no_ IS NOT NULL) THEN
      newrec_.owning_vendor_no := vendor_no_;
   END IF;

   IF (owning_customer_no_ IS NOT NULL) THEN
      newrec_.owning_customer_no := owning_customer_no_;
   END IF;
   IF (transaction_id_ IS NOT NULL) THEN
      newrec_.latest_transaction_id := transaction_id_;
   END IF;
   -- Create the new record or update the one present
   IF new_record_ = TRUE THEN
      newrec_.contract         := contract_           ;
      newrec_.part_no          := part_no_            ;
      newrec_.configuration_id := configuration_id_   ;
      newrec_.location_no      := location_no_        ;
      newrec_.lot_batch_no     := lot_batch_no_       ;
      newrec_.serial_no        := serial_no_for_stock_;
      newrec_.eng_chg_level    := eng_chg_level_      ;
      newrec_.waiv_dev_rej_no  := waiv_dev_rej_no_    ;
      newrec_.activity_seq     := activity_seq_       ;
      newrec_.handling_unit_id := handling_unit_id_   ;
      newrec_.qty_onhand       := quantity_           ;
      newrec_.catch_qty_onhand := catch_quantity_     ;
      IF Nvl(quantity_reserved_, 0) != 0 THEN
         newrec_.qty_reserved := quantity_reserved_;
      END IF;

      Check_And_Insert_By_Keys___(newrec_                       => newrec_,
                                  part_catalog_rec_             => local_part_catalog_rec_,
                                  set_default_avail_control_id_ => NOT receipt_for_rental_asset_trf_,
                                  validate_hu_struct_position_  => validate_hu_struct_position_);
   ELSE
      newrec_.qty_onhand       := oldrec_.qty_onhand + quantity_            ;
      newrec_.catch_qty_onhand := oldrec_.catch_qty_onhand + catch_quantity_;

      IF Nvl(quantity_reserved_, 0) != 0 THEN
         newrec_.qty_reserved := oldrec_.qty_reserved + quantity_reserved_;
      END IF;
      IF ((receive_from_transit_) AND (NOT serial_no_is_changed_)) THEN
         -- Serial number has not been transformed during receipt from transit. Reduce qty_in_transit on the same record
         newrec_.catch_qty_in_transit := oldrec_.catch_qty_in_transit - catch_quantity_;
         newrec_.qty_in_transit       := oldrec_.qty_in_transit - quantity_            ;
      END IF;

      Check_And_Update_By_Keys___(oldrec_                       => oldrec_,
                                  newrec_                       => newrec_,
                                  part_catalog_rec_             => local_part_catalog_rec_,
                                  set_default_avail_control_id_ => NOT (receipt_in_place_ OR receipt_for_rental_asset_trf_),
                                  refill_this_location_         => NOT receipt_for_rental_asset_trf_,
                                  validate_hu_struct_position_  => validate_hu_struct_position_);
   END IF;

   IF ((receive_from_transit_) AND (serial_no_is_changed_)) THEN
      -- The code section below with the extra lock and update is here because it might be so that the quantity goes into
      -- a separate record when a serial in transit is received into stock. The serial number might be transformed into a star '*'
      -- if In Inventory serial tracking is disabled and only Receipt and Issue Serial Tracking is enabled. So we need to separately
      -- reduce the qty_in_transit on the record that has the real serial number attached to it. 
      oldrec_ := Lock_By_Keys___(contract_,
                                 part_no_,
                                 configuration_id_,
                                 location_no_,
                                 lot_batch_no_,
                                 serial_no_,
                                 eng_chg_level_,
                                 waiv_dev_rej_no_,
                                 activity_seq_,
                                 handling_unit_id_);

      newrec_                      := oldrec_;
      newrec_.catch_qty_in_transit := oldrec_.catch_qty_in_transit - catch_quantity_;
      newrec_.qty_in_transit       := oldrec_.qty_in_transit - quantity_            ;

      Check_And_Update_By_Keys___(oldrec_                       => oldrec_,
                                  newrec_                       => newrec_,
                                  remove_unit_cost_             => FALSE,
                                  part_catalog_rec_             => local_part_catalog_rec_,
                                  validate_hu_struct_position_  => validate_hu_struct_position_);
   END IF;
END Receive_Part_Impl___;


-- Create_Count_Report___
--   Implementation method for Create_Inventory_Count_List.
PROCEDURE Create_Count_Report___ (
   inv_list_no_                  OUT VARCHAR2,
   contract_                     IN  VARCHAR2,
   warehouse_id_                 IN  VARCHAR2,
   bay_id_                       IN  VARCHAR2,
   row_id_                       IN  VARCHAR2,
   tier_id_                      IN  VARCHAR2,
   bin_id_                       IN  VARCHAR2,  
   storage_zone_id_              IN  VARCHAR2,
   second_commodity_             IN  VARCHAR2,
   part_no_                      IN  VARCHAR2,
   max_qty_onhand_               IN  NUMBER,
   exclude_since_                IN  NUMBER,
   cycle_code_db_                IN  VARCHAR2,
   freeze_code_db_               IN  VARCHAR2,
   process_count_                IN  NUMBER,
   project_id_                   IN  VARCHAR2,
   include_all_qty_db_           IN  VARCHAR2,
   exclude_customer_owned_       IN  VARCHAR2,
   exclude_supplier_loaned_      IN  VARCHAR2,
   exclude_consignment_          IN  VARCHAR2,
   exclude_company_owned_        IN  VARCHAR2,
   exclude_rotable_pool_         IN  VARCHAR2,
   exclude_fa_rotable_pool_      IN  VARCHAR2,
   exclude_project_inventory_    IN  VARCHAR2,
   exclude_standard_inventory_   IN  VARCHAR2,
   exclude_supplier_rented_      IN  VARCHAR2,
   exclude_company_rental_asset_ IN  VARCHAR2,
   exclude_attached_to_hu_       IN  VARCHAR2,
   exclude_not_attached_to_hu_   IN  VARCHAR2,
   location_group_               IN  VARCHAR2,
   abc_class_                    IN  VARCHAR2,
   frequency_class_db_           IN  VARCHAR2,
   lifecycle_stage_db_           IN  VARCHAR2,
   include_full_qty_of_hu_db_    IN  VARCHAR2,
   handling_unit_type_id_        IN  VARCHAR2,
   top_handling_unit_type_id_    IN  VARCHAR2,
   handling_category_type_id_    IN  VARCHAR2,
   top_handling_category_type_id_ IN  VARCHAR2 )
   
IS
   processed_count_            NUMBER;
   ilh_inv_list_no_            VARCHAR2(15);
   local_part_no_              INVENTORY_PART_IN_STOCK_TAB.part_no%TYPE;
   configuration_id_           INVENTORY_PART_IN_STOCK_TAB.configuration_id%TYPE;
   lot_batch_no_               INVENTORY_PART_IN_STOCK_TAB.lot_batch_no%TYPE;
   serial_no_                  INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE;
   waiv_dev_rej_no_            INVENTORY_PART_IN_STOCK_TAB.waiv_dev_rej_no%TYPE;
   eng_chg_level_              INVENTORY_PART_IN_STOCK_TAB.eng_chg_level%TYPE;
   location_no_                INVENTORY_PART_IN_STOCK_TAB.location_no%TYPE;
   curr_contract_              INVENTORY_PART_IN_STOCK_TAB.contract%TYPE;
   part_rec_                   Inventory_Part_API.Public_Rec;
   last_count_date_            DATE;
   user_                       VARCHAR2(30) := Fnd_Session_API.Get_Fnd_User;
   next_count_date_            DATE;
   today_                      DATE := TRUNC(Site_API.Get_Site_Date(contract_));
   part_ownership_             VARCHAR2(20);
   rotable_part_pool_id_       VARCHAR2(20);
   rotable_pool_asset_type_db_ VARCHAR2(20);
   activity_seq_               INVENTORY_PART_IN_STOCK_TAB.activity_seq%TYPE;
   handling_unit_id_           INVENTORY_PART_IN_STOCK_TAB.handling_unit_id%TYPE;
   project_                    VARCHAR2(30);
   previous_part_no_           INVENTORY_PART_IN_STOCK_TAB.part_no%TYPE := CHR(32);
   previous_location_no_       INVENTORY_PART_IN_STOCK_TAB.location_no%TYPE := CHR(32);
   part_no_in_part_rec_        INVENTORY_PART_IN_STOCK_TAB.part_no%TYPE := CHR(32);
   last_calendar_date_         DATE := Database_Sys.last_calendar_date_;
   header_created_             BOOLEAN := FALSE;
   location_no_tab_            Warehouse_Bay_Bin_API.Location_No_Tab;
   bin_rec_                    Warehouse_Bay_Bin_API.Public_Rec;
   local_warehouse_id_         INVENTORY_PART_IN_STOCK_TAB.warehouse%TYPE;
   local_bay_id_               INVENTORY_PART_IN_STOCK_TAB.bay_no%TYPE;
   local_tier_id_              INVENTORY_PART_IN_STOCK_TAB.tier_no%TYPE;
   local_row_id_               INVENTORY_PART_IN_STOCK_TAB.row_no%TYPE;
   local_bin_id_               INVENTORY_PART_IN_STOCK_TAB.bin_no%TYPE;
   check_top_handling_unit_    BOOLEAN := FALSE;
   root_handling_unit_id_      NUMBER;
   part_stock_key_tab_         Keys_Tab;
   key_count_                  NUMBER := 0;
   part_stock_rec_             INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   warehouse_route_order_      VARCHAR2(15);
   bay_route_order_            VARCHAR2(5);
   row_route_order_            VARCHAR2(5);
   tier_route_order_           VARCHAR2(5);
   bin_route_order_            VARCHAR2(5);
   
   CURSOR get_partloc IS
      SELECT ipis.part_no,
             ipis.configuration_id,
             ipis.location_no,
             ipis.lot_batch_no,
             ipis.serial_no,
             ipis.eng_chg_level,
             ipis.waiv_dev_rej_no,
             ipis.activity_seq,
             ipis.handling_unit_id,
             ipis.contract,
             NVL(ipis.part_ownership_db, Part_Ownership_API.DB_COMPANY_OWNED),
             ipis.rotable_part_pool_id,
             NVL(Inventory_Part_In_Stock_API.Get_Next_Count_Date(ipis.contract,
                                                                 ipis.part_no,
                                                                 ipis.configuration_id,
                                                                 ipis.location_no,
                                                                 ipis.lot_batch_no,
                                                                 ipis.serial_no,
                                                                 ipis.eng_chg_level,
                                                                 ipis.waiv_dev_rej_no,
                                                                 ipis.activity_seq,
                                                                 ipis.handling_unit_id), TRUNC(Site_API.Get_Site_Date(ipis.contract))) as next_count_date,
             warehouse,
             bay_no,
             tier_no,
             row_no,
             bin_no
      FROM INVENTORY_PART_IN_STOCK_AVAIL ipis,
           INVENTORY_PART_TAB ip
      WHERE (((ipis.serial_no  = '*' AND ipis.handling_unit_id  = 0) AND ipis.qty_onhand >= 0) OR
             ((ipis.serial_no != '*' OR  ipis.handling_unit_id != 0) AND ipis.qty_onhand >  0))
      AND ((ipis.qty_onhand <= max_qty_onhand_) OR (max_qty_onhand_ IS NULL))
      AND ((ipis.last_count_date IS NULL) OR
         (ipis.last_count_date < last_count_date_))
      AND ipis.location_type_db IN (Inventory_Location_Type_API.DB_PICKING,
                                    Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                    Inventory_Location_Type_API.DB_PRODUCTION_LINE)
      AND ((UPPER(ipis.warehouse) LIKE UPPER(warehouse_id_)) OR warehouse_id_ IS NULL)
      AND ((UPPER(ipis.bay_no)    LIKE UPPER(bay_id_)) OR bay_id_ IS NULL)
      AND ((UPPER(ipis.row_no)    LIKE UPPER(row_id_)) OR row_id_ IS NULL)
      AND ((UPPER(ipis.tier_no)   LIKE UPPER(tier_id_)) OR tier_id_ IS NULL)
      AND ((UPPER(ipis.bin_no)    LIKE UPPER(bin_id_)) OR bin_id_ IS NULL) 
      AND (ipis.location_no in (SELECT * FROM TABLE(location_no_tab_)) OR (storage_zone_id_ IS NULL))
      AND ((UPPER(ipis.project_id)    LIKE UPPER(project_id_)) OR project_id_ IS NULL) 
      AND (((ipis.activity_seq = 0) AND (exclude_standard_inventory_ = 'N')) OR
           ((ipis.activity_seq != 0) AND (exclude_project_inventory_ = 'N')))
      AND Report_SYS.Parse_Parameter(upper(ipis.part_no), part_no_) = 'TRUE'      
      AND ipis.contract         LIKE contract_
      AND ipis.contract         = ip.contract
      AND ipis.part_no          = ip.part_no
      AND ((exclude_attached_to_hu_ = 'N' AND ipis.handling_unit_id != 0) OR
           (exclude_not_attached_to_hu_ = 'N' AND ipis.handling_unit_id = 0))
      AND (( ipis.handling_unit_id != 0 AND ipis.handling_unit_id IN (SELECT hu.handling_unit_id
                                                                      FROM handling_unit_tab hu, handling_unit_type_tab hut
                                                                      WHERE hu.handling_unit_id = ipis.handling_unit_id
                                                                      AND   hu.handling_unit_type_id = hut.handling_unit_type_id
                                                                      AND  (hu.handling_unit_type_id = handling_unit_type_id_ OR handling_unit_type_id_ IS NULL)
                                                                      AND  (hut.handling_unit_category_id = handling_category_type_id_ OR handling_category_type_id_ IS NULL))) OR ipis.handling_unit_id = 0)
      AND EXISTS (SELECT 1
                    FROM inventory_part_planning_pub ipp
                   WHERE ipp.contract = ip.contract
                     AND ipp.part_no = ip.part_no
                     AND ipp.planning_method NOT IN ('K','O','T'))                                                                      
      ORDER BY next_count_date,
               contract,
               Utility_SYS.String_To_Number(warehouse_route_order),
               upper(warehouse_route_order),
               Utility_SYS.String_To_Number(bay_route_order),
               upper(decode(bay_route_order,  Warehouse_Bay_API.default_bay_id_, last_character_, bay_route_order)),
               Utility_SYS.String_To_Number(row_route_order),
               upper(decode(row_route_order,  Warehouse_Bay_Row_API.default_row_id_, last_character_, row_route_order)),
               Utility_SYS.String_To_Number(tier_route_order),
               upper(decode(tier_route_order, Warehouse_Bay_Tier_API.default_tier_id_, last_character_, tier_route_order)),
               Utility_SYS.String_To_Number(bin_route_order),
               upper(decode(bin_route_order,  Warehouse_Bay_Bin_API.default_bin_id_, last_character_, bin_route_order)),
               part_no,
               lot_batch_no,
               serial_no;
BEGIN
   IF (process_count_ < 1 OR MOD(process_count_, 1) != 0) THEN
      Error_SYS.Record_General(lu_name_, 'NOPROCCOUNT: The value for number of records to be printed should be an integer greater than zero.');
   END IF;

   IF (exclude_since_ IS NULL) THEN
      last_count_date_ := last_calendar_date_;
   ELSE
      last_count_date_ := Site_API.Get_Site_Date(contract_) - exclude_since_;
   END IF;

   IF (storage_zone_id_ IS NOT NULL) THEN
      location_no_tab_ := Warehouse_Bay_Bin_API.Get_Storage_Zone_Locations(contract_, storage_zone_id_);
   END IF;
   
   project_         := NVL(project_id_, '%');

   processed_count_ := 0;
   IF (top_handling_unit_type_id_ IS NOT NULL OR top_handling_category_type_id_ IS NOT NULL) THEN
      check_top_handling_unit_ := TRUE;
   END IF;
   OPEN get_partloc;
   LOOP
      IF process_count_ > 0 THEN
         EXIT WHEN processed_count_ >= process_count_;
      END IF;

      FETCH get_partloc INTO local_part_no_,
                             configuration_id_,
                             location_no_,
                             lot_batch_no_,
                             serial_no_,
                             eng_chg_level_,
                             waiv_dev_rej_no_,
                             activity_seq_,
                             handling_unit_id_,
                             curr_contract_,
                             part_ownership_,
                             rotable_part_pool_id_,
                             next_count_date_,
                             local_warehouse_id_,
                             local_bay_id_,
                             local_tier_id_,
                             local_row_id_,
                             local_bin_id_;

      EXIT WHEN get_partloc%NOTFOUND;
      
      -- Reset collection information before gather information relate to next part in location.
      key_count_ := 0;
      part_stock_key_tab_.delete;
      IF ((local_part_no_      != previous_part_no_)     OR
          (location_no_        != previous_location_no_) OR
          (include_all_qty_db_ != 'Y'))                  THEN                  
         IF (rotable_part_pool_id_ IS NOT NULL) THEN
            rotable_pool_asset_type_db_ := Rotable_Part_Pool_API.Get_Rotable_Pool_Asset_Type_Db(rotable_part_pool_id_);
         ELSE
            -- A not NULL value is assigned to ensure that the conditions do not fail
            rotable_pool_asset_type_db_ := 'NOT IN ROTABLE POOL';
         END IF;
   
         IF (((exclude_customer_owned_       = 'INCLUDE') AND (part_ownership_ = 'CUSTOMER OWNED')) OR
             ((exclude_supplier_loaned_      = 'INCLUDE') AND (part_ownership_ = 'SUPPLIER LOANED')) OR
             ((exclude_company_owned_        = 'INCLUDE') AND (part_ownership_ = 'COMPANY OWNED')) OR
             ((exclude_consignment_          = 'INCLUDE') AND (part_ownership_ = 'CONSIGNMENT')) OR
             ((exclude_supplier_rented_      = 'INCLUDE') AND (part_ownership_ = 'SUPPLIER RENTED')) OR
             ((exclude_company_rental_asset_ = 'INCLUDE') AND (part_ownership_ = 'COMPANY RENTAL ASSET'))) THEN
 
            IF (rotable_part_pool_id_ IS NULL) OR ((exclude_rotable_pool_ = 'INCLUDE')
               AND (exclude_fa_rotable_pool_ = 'INCLUDE' OR rotable_pool_asset_type_db_ != 'FIXED ASSET')) THEN
                     
               IF (local_part_no_ != part_no_in_part_rec_) THEN               
                  part_rec_            := Inventory_Part_API.Get(contract_, local_part_no_);
                  part_no_in_part_rec_ := local_part_no_;
               END IF;
   
               IF (location_group_ IS NOT NULL) THEN
                  IF (location_no_ != NVL(bin_rec_.location_no, Database_SYS.STRING_NULL_)) THEN
                     bin_rec_ := Warehouse_Bay_Bin_API.Get(curr_contract_,
                                                           local_warehouse_id_,
                                                           local_bay_id_,
                                                           local_tier_id_,
                                                           local_row_id_,
                                                           local_bin_id_);
                  END IF;
               END IF;
               
               IF (NVL(part_rec_.second_commodity,'DuMmY') LIKE NVL(second_commodity_, '%')
                  AND ((part_rec_.abc_class       = abc_class_)          OR (abc_class_          IS NULL))
                  AND ((part_rec_.frequency_class = frequency_class_db_) OR (frequency_class_db_ IS NULL))
                  AND ((part_rec_.lifecycle_stage = lifecycle_stage_db_) OR (lifecycle_stage_db_ IS NULL))
                  AND ((bin_rec_.location_group   = location_group_)     OR (location_group_     IS NULL))
                  AND ((cycle_code_db_ = 'PARTS WITH CYCLIC COUNTING'
                       AND part_rec_.cycle_code = 'Y'
                       AND next_count_date_ <= today_)
                      OR (cycle_code_db_ = 'PARTS WITHOUT CYCLIC COUNTING'
                         AND part_rec_.cycle_code = 'N')
                      OR (cycle_code_db_ = 'PARTS WITH AND WITHOUT CYCLIC COUNTING'
                         AND ((part_rec_.cycle_code = 'Y'
                         AND next_count_date_ <= today_)
                         OR (part_rec_.cycle_code = 'N'))))) THEN
                  
                     
                  IF (handling_unit_id_ != 0 AND (include_full_qty_of_hu_db_ = 'Y' OR check_top_handling_unit_)) THEN
                     root_handling_unit_id_ := Handling_unit_API.Get_Root_Handling_Unit_Id(handling_unit_id_);
                  END IF;       
                  IF ((handling_unit_id_ = 0) OR
                      (handling_unit_id_ != 0 AND (NOT check_top_handling_unit_ OR (check_top_handling_unit_ AND 
                                                                                    Handling_Unit_API.Is_Hu_Type_And_Category_Match(root_handling_unit_id_,
                                                                                                                                    top_handling_unit_type_id_,
                                                                                                                                    top_handling_category_type_id_))))) THEN

                     -- Initially set the main cursor selected part in stock record since need to avaible in the count report.
                     key_count_ := key_count_ + 1;
                     part_stock_key_tab_(key_count_).contract         := contract_;
                     part_stock_key_tab_(key_count_).part_no          := local_part_no_;
                     part_stock_key_tab_(key_count_).location_no      := location_no_;
                     part_stock_key_tab_(key_count_).configuration_id := configuration_id_;
                     part_stock_key_tab_(key_count_).lot_batch_no     := lot_batch_no_;
                     part_stock_key_tab_(key_count_).serial_no        := serial_no_;
                     part_stock_key_tab_(key_count_).eng_chg_level    := eng_chg_level_;
                     part_stock_key_tab_(key_count_).waiv_dev_rej_no  := waiv_dev_rej_no_;
                     part_stock_key_tab_(key_count_).activity_seq     := activity_seq_;
                     part_stock_key_tab_(key_count_).handling_unit_id := handling_unit_id_;

                     IF ( NOT Part_Stock_Already_Counted___(part_stock_key_tab_(key_count_), check_in_own_report_ => FALSE)) THEN
                        -- Including full quantities in the location if user request to do so.
                        IF (include_all_qty_db_  = 'Y') THEN
                           Merge_Collections_To_First___( part_stock_key_tab_, Get_All_Part_Stock_In_Loc___(local_part_no_, contract_, location_no_, max_qty_onhand_));
                        END IF;
                        
                        -- Fetching full quantity information in the handling unit if user request so.
                        IF (root_handling_unit_id_ IS NOT NULL AND include_full_qty_of_hu_db_ = 'Y') THEN
                           Merge_Collections_To_First___( part_stock_key_tab_, Get_All_Part_Stock_In_Hu___(root_handling_unit_id_, max_qty_onhand_));
                        END IF;

                        -- Fetching information from the inventory part stock which is valid for end up in count report with using filltered key collection.
                        FOR j_ IN part_stock_key_tab_.first..part_stock_key_tab_.last LOOP
                           part_stock_rec_ := Get_Object_By_Keys___(part_stock_key_tab_(j_).contract,         part_stock_key_tab_(j_).part_no,         part_stock_key_tab_(j_).configuration_id,
                                                                    part_stock_key_tab_(j_).location_no,      part_stock_key_tab_(j_).lot_batch_no,    part_stock_key_tab_(j_).serial_no,
                                                                    part_stock_key_tab_(j_).eng_chg_level,    part_stock_key_tab_(j_).waiv_dev_rej_no, part_stock_key_tab_(j_).activity_seq,
                                                                    part_stock_key_tab_(j_).handling_unit_id);
                           
                           IF ( NOT Part_Stock_Already_Counted___(part_stock_key_tab_(j_), check_in_own_report_ => TRUE)) THEN
                              -- Create the head if this is not already done before.
                              IF header_created_ = FALSE THEN
                                 SELECT To_char(inv_list_no.nextval) INTO ilh_inv_list_no_ FROM dual;
                                 Counting_Report_API.New_List_Header(ilh_inv_list_no_,
                                                                     contract_,
                                                                     cycle_code_db_,
                                                                     NVL(second_commodity_,'%'),
                                                                     user_,
                                                                     warehouse_id_,
                                                                     bay_id_,
                                                                     row_id_,
                                                                     tier_id_,
                                                                     bin_id_,
                                                                     storage_zone_id_,
                                                                     part_no_,                                                                 
                                                                     max_qty_onhand_,
                                                                     last_count_date_,
                                                                     freeze_code_db_,
                                                                     process_count_,
                                                                     project_id_,
                                                                     include_all_qty_db_,
                                                                     exclude_customer_owned_,
                                                                     exclude_supplier_loaned_,
                                                                     exclude_consignment_,
                                                                     exclude_company_owned_,
                                                                     exclude_rotable_pool_,
                                                                     exclude_fa_rotable_pool_,
                                                                     exclude_standard_inventory_,
                                                                     exclude_project_inventory_,
                                                                     exclude_attached_to_hu_,
                                                                     exclude_not_attached_to_hu_,
                                                                     exclude_supplier_rented_,
                                                                     exclude_company_rental_asset_,
                                                                     location_group_,
                                                                     abc_class_,
                                                                     frequency_class_db_,
                                                                     lifecycle_stage_db_,
                                                                     include_full_qty_of_hu_db_,                                                                
                                                                     handling_unit_type_id_,
                                                                     top_handling_unit_type_id_,
                                                                     handling_category_type_id_,
                                                                     top_handling_category_type_id_);
                                 header_created_ := TRUE;                                                                  
                              END IF;
                              -- Create the rows in the counting report depending on location_type
                              IF part_stock_rec_.location_type IN ( Inventory_Location_Type_API.DB_PICKING,
                                                                    Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                                                    Inventory_Location_Type_API.DB_PRODUCTION_LINE) THEN
                                 processed_count_ := processed_count_ + 1;
                                 Warehouse_Bay_Bin_API.Get_Route_Order_Strings(warehouse_route_order_, bay_route_order_, row_route_order_, tier_route_order_, bin_route_order_, contract_, location_no_);
                                 New_Count_Report_Line_Tmp___( ilh_inv_list_no_,
                                                               contract_,
                                                               part_stock_rec_.part_no,
                                                               part_stock_rec_.configuration_id,
                                                               location_no_,
                                                               part_stock_rec_.lot_batch_no,
                                                               part_stock_rec_.serial_no,
                                                               part_stock_rec_.eng_chg_level,
                                                               part_stock_rec_.waiv_dev_rej_no,
                                                               part_stock_rec_.activity_seq,
                                                               part_stock_rec_.handling_unit_id,
                                                               warehouse_route_order_,
                                                               bay_route_order_,
                                                               row_route_order_,
                                                               tier_route_order_,
                                                               bin_route_order_,
                                                               part_stock_rec_.qty_onhand,
                                                               part_stock_rec_.catch_qty_onhand);

                                 IF freeze_code_db_ != 'N' THEN
                                    Set_Freeze_Flag( contract_,
                                                     part_stock_rec_.part_no,
                                                     part_stock_rec_.configuration_id,
                                                     location_no_,
                                                     part_stock_rec_.lot_batch_no,
                                                     part_stock_rec_.serial_no,
                                                     part_stock_rec_.eng_chg_level,
                                                     part_stock_rec_.waiv_dev_rej_no,
                                                     part_stock_rec_.activity_seq,
                                                     part_stock_rec_.handling_unit_id);
                                 END IF;
                              END IF;
                           END IF;
                        END LOOP;
                     END IF;
                  END IF;
               END IF;
            END IF;
         END IF;
         previous_part_no_     := local_part_no_;         
         previous_location_no_ := location_no_;
      END IF;
   END LOOP;
   CLOSE get_partloc;
   Create_Count_Report_Lines___;
   inv_list_no_ := ilh_inv_list_no_;
   -- Clearing the table once count report lines are inserted to prevent duplicates when it is scheduled one report per warehouse.
   DELETE FROM COUNTING_REPORT_LINE_TMP where inv_list_no = inv_list_no_;
END Create_Count_Report___;

-- Get_All_Part_Stock_In_Loc___
--    This implementation method collect and return all part information for a specific part located in the given location.
FUNCTION Get_All_Part_Stock_In_Loc___(
   part_no_            IN VARCHAR2,
   contract_           IN VARCHAR2,
   location_no_        IN VARCHAR2,
   max_qty_onhand_     IN NUMBER ) RETURN Keys_Tab
IS
   stock_key_tab_ Keys_Tab;

   -- This cursor fetches full quantities in the same location.
   CURSOR Get_Part_Location_Keys IS
      SELECT part_no,
             contract,
             configuration_id,
             location_no,
             lot_batch_no,
             serial_no,
             eng_chg_level,
             waiv_dev_rej_no,
             activity_seq,
             handling_unit_id
      FROM  inventory_part_in_stock_tab
      WHERE contract      = contract_
      AND   location_no   = location_no_
      AND   part_no       = part_no_
      AND   (qty_onhand <= max_qty_onhand_ OR max_qty_onhand_ IS NULL)
      AND   (((serial_no  = '*' AND handling_unit_id  = 0) AND qty_onhand >= 0) OR
             ((serial_no != '*' OR  handling_unit_id != 0) AND qty_onhand >  0));
BEGIN
   OPEN  Get_Part_Location_Keys;
   FETCH Get_Part_Location_Keys BULK COLLECT INTO stock_key_tab_;
   CLOSE Get_Part_Location_Keys;
   
   RETURN (stock_key_tab_);
END Get_All_Part_Stock_In_Loc___;

-- Get_All_Part_Stock_In_Hu___
--    This implementation method get all the part information contain inside the handling unit.
FUNCTION Get_All_Part_Stock_In_Hu___(
   root_handling_unit_id_   IN NUMBER,
   max_qty_onhand_          IN NUMBER ) RETURN Keys_Tab
IS
   stock_key_tab_         Keys_Tab;
   temp_stock_key_tab_    Keys_Tab;
   handling_unit_id_tab_  Handling_Unit_API.Handling_Unit_Id_Tab;

   -- This cursor will fetched the full quantities in the same handling unit.
   CURSOR Get_Hu_Structure_Keys (handling_unit_id_ IN NUMBER) IS
      SELECT part_no,
             contract,
             configuration_id,
             location_no,
             lot_batch_no,
             serial_no,
             eng_chg_level,
             waiv_dev_rej_no,
             activity_seq,
             handling_unit_id
      FROM  inventory_part_in_stock_tab
      WHERE handling_unit_id  = handling_unit_id_
      AND   qty_onhand        > 0
      AND   (qty_onhand <= max_qty_onhand_ OR max_qty_onhand_ IS NULL);
BEGIN
   handling_unit_id_tab_ := Handling_Unit_API.Get_Node_And_Descendants(root_handling_unit_id_);
                           
   IF (handling_unit_id_tab_.COUNT > 0) THEN
      FOR i_ IN handling_unit_id_tab_.first..handling_unit_id_tab_.last LOOP
         OPEN  Get_Hu_Structure_Keys(handling_unit_id_tab_(i_).handling_unit_id);
         FETCH Get_Hu_Structure_Keys BULK COLLECT INTO temp_stock_key_tab_;
         CLOSE Get_Hu_Structure_Keys;
         
         Merge_Collections_To_First___(stock_key_tab_, temp_stock_key_tab_);
      END LOOP;
   END IF;
   RETURN (stock_key_tab_);
END Get_All_Part_Stock_In_Hu___;

-- Part_Stock_Already_Counted___
--    This implementation method validates the selected part in stock record already included into another open count report
-- or already creating count report.
FUNCTION Part_Stock_Already_Counted___(
   part_stock_key_rec_     Keys_Rec,
   check_in_own_report_    BOOLEAN  ) RETURN BOOLEAN
IS
   already_counted_ BOOLEAN := FALSE;
   
BEGIN
   IF (Counting_Report_Line_API.Check_Unconfirmed_Part_Loc( part_stock_key_rec_.contract,
                                                            part_stock_key_rec_.part_no, 
                                                            part_stock_key_rec_.configuration_id,
                                                            part_stock_key_rec_.location_no,
                                                            part_stock_key_rec_.lot_batch_no,
                                                            part_stock_key_rec_.serial_no,
                                                            part_stock_key_rec_.eng_chg_level,
                                                            part_stock_key_rec_.waiv_dev_rej_no,
                                                            part_stock_key_rec_.activity_seq,
                                                            part_stock_key_rec_.handling_unit_id ) = db_true_ ) THEN
      already_counted_ := TRUE;
   ELSIF (Counting_Result_API.Check_Rejected_Part_Location( part_stock_key_rec_.contract,
                                                            part_stock_key_rec_.part_no, 
                                                            part_stock_key_rec_.configuration_id,
                                                            part_stock_key_rec_.location_no,
                                                            part_stock_key_rec_.lot_batch_no,
                                                            part_stock_key_rec_.serial_no,
                                                            part_stock_key_rec_.eng_chg_level,
                                                            part_stock_key_rec_.waiv_dev_rej_no,
                                                            part_stock_key_rec_.activity_seq,
                                                            part_stock_key_rec_.handling_unit_id ) = db_true_) THEN
      already_counted_ := TRUE;
   ELSIF ( check_in_own_report_ AND  Count_Report_Line_Tmp_Exist___( part_stock_key_rec_.contract,
                                                                     part_stock_key_rec_.part_no,
                                                                     part_stock_key_rec_.configuration_id,
                                                                     part_stock_key_rec_.location_no,
                                                                     part_stock_key_rec_.lot_batch_no,
                                                                     part_stock_key_rec_.serial_no,
                                                                     part_stock_key_rec_.eng_chg_level,
                                                                     part_stock_key_rec_.waiv_dev_rej_no,
                                                                     part_stock_key_rec_.activity_seq,
                                                                     part_stock_key_rec_.handling_unit_id)) THEN
      already_counted_ := TRUE;
   END IF;
   RETURN already_counted_;
END Part_Stock_Already_Counted___;

-- Merge_Collections_To_First___
--    This method accepts two inventory part in stock key collections and merge them in the to the first collection.
PROCEDURE Merge_Collections_To_First___(
   first_stock_key_tab_    IN OUT NOCOPY  Keys_Tab,
   second_stock_key_tab_   IN Keys_Tab )
IS
   next_index_no_ NUMBER := first_stock_key_tab_.COUNT + 1;
BEGIN
   IF ( second_stock_key_tab_.COUNT > 0 ) THEN
      FOR i_ IN second_stock_key_tab_.FIRST..second_stock_key_tab_.LAST LOOP
         first_stock_key_tab_(next_index_no_) := second_stock_key_tab_(i_);
         next_index_no_ := next_index_no_ + 1;
      END LOOP;
   END IF;
END Merge_Collections_To_First___;


-- Make_Onhand_Analysis_Impl___
--   Implementation method for Make_Onhand_Analysis.
PROCEDURE Make_Onhand_Analysis_Impl___ (
   result_                      IN OUT VARCHAR2,
   qty_possible_                IN OUT NUMBER,
   qty_earliest_                IN OUT NUMBER,
   next_analysis_date_          IN OUT DATE,
   planned_delivery_date_       IN OUT DATE,
   planned_due_date_            IN OUT DATE,
   contract_                    IN     VARCHAR2,
   part_no_                     IN     VARCHAR2,
   configuration_id_            IN     VARCHAR2,
   include_standard_            IN     VARCHAR2,   
   include_project_             IN     VARCHAR2,   
   project_id_                  IN     VARCHAR2,
   activity_seq_                IN     NUMBER,
   row_id_                      IN     VARCHAR2,
   qty_desired_                 IN     NUMBER,
   picking_leadtime_            IN     NUMBER,
   use_pick_leadtime_           IN     BOOLEAN,
   part_ownership_              IN     VARCHAR2,
   owning_vendor_no_            IN     VARCHAR2,
   owning_customer_no_          IN     VARCHAR2,
   detect_supplies_not_allowed_ IN     BOOLEAN,
   use_distribution_calendar_   IN     BOOLEAN ) 
IS
   available_balance_tab_      Order_Supply_Demand_API.Avail_Balance_Qty_Tab;
   available_balance_date_tab_ Order_Supply_Demand_API.Avail_Balance_Date_Tab;
   plannable_balance_tab_      Plannable_Balance_TabType;
   i_                          PLS_INTEGER := 0; 
   j_                          PLS_INTEGER := 0; 
   starting_balance_           NUMBER := 0;
   available_balance_          NUMBER := 0;
   stop_analysis_date_         DATE;
   orig_planned_due_date_      DATE;
   dist_calendar_id_           VARCHAR2(30);
   manuf_calendar_id_          VARCHAR2(30);
   local_picking_leadtime_     NUMBER;
   no_analysis                 EXCEPTION;
   today_                      DATE := Site_API.Get_Site_Date(contract_);
   lead_time_code_db_          VARCHAR2(20);
   calendar_id_                VARCHAR2(30);
   site_rec_                   Site_API.Public_Rec := Site_API.Get(contract_);
   count_                      NUMBER := 0;
   detect_suppl_not_allowed_   VARCHAR2(5) := db_false_;
   last_calendar_date_         DATE := Database_Sys.last_calendar_date_;
BEGIN
   result_            := 'SUCCESS';
   dist_calendar_id_  := site_rec_.dist_calendar_id;
   manuf_calendar_id_ := site_rec_.manuf_calendar_id;

   IF (detect_supplies_not_allowed_) THEN
      detect_suppl_not_allowed_ := db_true_;
   END IF;

   stop_analysis_date_:= Inventory_Part_API.Get_Stop_Analysis_Date(contract_,
                                                                   part_no_,
                                                                   today_,
                                                                   dist_calendar_id_,
                                                                   manuf_calendar_id_,
                                                                   detect_suppl_not_allowed_);
   IF (stop_analysis_date_ IS NULL) THEN
      -- Use the correct calendar id in the error message
      lead_time_code_db_ := Inv_Part_Lead_Time_Code_API.Encode(Inventory_Part_API.Get_Lead_Time_Code(contract_, part_no_));
      IF lead_time_code_db_ = 'P' THEN
         calendar_id_ := dist_calendar_id_;
      ELSIF lead_time_code_db_ = 'M' THEN
         calendar_id_ := manuf_calendar_id_;
      END IF;      
      Error_SYS.Record_General(lu_name_, 'NOT_IN_CAL_STAN: Retrieving the unlimited supply date failed for part :P1 on site :P2. The date is outside the interval of the calendar :P3.', part_no_, contract_, calendar_id_);
   END IF;

   -- IF used from manufacturing then use the manufacturing calendar id when calling the calendar functions
   IF use_distribution_calendar_ THEN
      calendar_id_ := dist_calendar_id_;
   ELSE
      calendar_id_ := manuf_calendar_id_;
   END IF;

   IF use_pick_leadtime_ THEN
      local_picking_leadtime_ := NVL(picking_leadtime_, Site_Invent_Info_API.Get_Picking_Leadtime(contract_));
   END IF;
   
   planned_due_date_      := Get_Closest_Work_Day(calendar_id_, planned_due_date_);
   orig_planned_due_date_ := planned_due_date_;

   IF (part_ownership_ = 'COMPANY OWNED') THEN
      IF (orig_planned_due_date_ >= stop_analysis_date_ + 1) THEN
         RAISE no_analysis;
      END IF;

      -- Conditionally use picking leadtime.
      IF (use_pick_leadtime_) THEN
         planned_delivery_date_ := Get_End_Date___(dist_calendar_id_,
                                                   planned_due_date_,
                                                   local_picking_leadtime_);
      ELSE
         planned_delivery_date_ := planned_due_date_;
      END IF;
      starting_balance_ := Get_Starting_Balance(contract_,
                                                part_no_,
                                                configuration_id_,
                                                include_standard_,
                                                include_project_,
                                                project_id_,
                                                activity_seq_,
                                                db_true_);

      available_balance_ := Order_Supply_Demand_API.Get_Available_Balance(contract_,
                                                                          part_no_,
                                                                          configuration_id_,
                                                                          include_standard_,
                                                                          include_project_,
                                                                          project_id_,
                                                                          activity_seq_,
                                                                          row_id_,
                                                                          'CUSTORD_SUPPLY_DEMAND',
                                                                          db_true_,
                                                                          db_false_);
      available_balance_tab_(i_)      := available_balance_ + starting_balance_;
      available_balance_date_tab_(i_) := Trunc(today_);
      Order_Supply_Demand_API.Get_Avail_Balance_Per_Date(available_balance_tab_,
                                                         available_balance_date_tab_,
                                                         i_,
                                                         contract_,
                                                         part_no_,
                                                         configuration_id_,
                                                         include_standard_,
                                                         include_project_,
                                                         project_id_,
                                                         activity_seq_,
                                                         row_id_,
                                                         stop_analysis_date_);
      i_ := i_ + 1;
      available_balance_tab_(i_)      := infinite_quantity_;
      available_balance_date_tab_(i_) := stop_analysis_date_ +1;
      j_ := i_;
      plannable_balance_tab_(j_+1)    := available_balance_tab_(j_);
      WHILE (j_ >= 0) LOOP
         plannable_balance_tab_(j_) := Least(plannable_balance_tab_(j_+1), available_balance_tab_(j_));
         j_ := j_ - 1;
      END LOOP;
      IF (i_ = 1) THEN
         IF (plannable_balance_tab_(0) < qty_desired_) THEN
            planned_due_date_ := available_balance_date_tab_(1);
            planned_due_date_ := Get_Closest_Work_Day(calendar_id_, planned_due_date_); 
         ELSE
            planned_due_date_ := greatest(orig_planned_due_date_, Trunc(today_));
            planned_due_date_ := Get_Closest_Work_Day(calendar_id_, planned_due_date_); 
         END IF;
      ELSE
         planned_due_date_ := available_balance_date_tab_(i_);
         planned_due_date_ := Get_Closest_Work_Day(calendar_id_, planned_due_date_); 
      END IF;

      -- Conditionally use picking leadtime.
      IF (use_pick_leadtime_) THEN
         planned_delivery_date_ := Get_End_Date___(dist_calendar_id_,
                                                   planned_due_date_,
                                                   local_picking_leadtime_);
      ELSE
         planned_delivery_date_ := planned_due_date_;
      END IF;

      WHILE (i_ >= 0) LOOP
         IF (plannable_balance_tab_(i_) < qty_desired_) THEN
            EXIT;
         ELSE
            qty_earliest_     := plannable_balance_tab_(i_);
            planned_due_date_ := available_balance_date_tab_(i_);
            planned_due_date_ := Get_Closest_Work_Day(calendar_id_, planned_due_date_); 

            -- Conditionally use picking leadtime.
            IF (use_pick_leadtime_) THEN
               planned_delivery_date_ := Get_End_Date___(dist_calendar_id_,
                                                         planned_due_date_,
                                                         local_picking_leadtime_);
            ELSE
               planned_delivery_date_ := planned_due_date_;
            END IF;

            IF (i_ = 0) THEN
               EXIT;
            END IF;
         END IF;
         i_ := i_ - 1;
         IF (available_balance_date_tab_(i_) < orig_planned_due_date_) THEN
            IF (plannable_balance_tab_(i_) >= qty_desired_) THEN
               qty_earliest_     := plannable_balance_tab_(i_);
               planned_due_date_ := greatest(orig_planned_due_date_, Trunc(today_));
               planned_due_date_ := Get_Closest_Work_Day(calendar_id_, planned_due_date_); 

               -- Conditionally use picking leadtime.
               IF (use_pick_leadtime_) THEN
                  planned_delivery_date_ := Get_End_Date___(dist_calendar_id_,
                                                            planned_due_date_,
                                                            local_picking_leadtime_);
               ELSE
                  planned_delivery_date_ := planned_due_date_;
               END IF;
            END IF;
            EXIT;
         END IF;
      END LOOP;
      IF (orig_planned_due_date_ < Trunc(today_)) THEN
         qty_possible_       := 0;
         next_analysis_date_ := Trunc(today_);
      ELSE
         j_ := 0;
         count_ := available_balance_date_tab_.count;
         WHILE (j_ < count_) LOOP
            IF (orig_planned_due_date_ < available_balance_date_tab_(j_)) THEN
               EXIT;
            END IF;
            j_ := j_ + 1;
         END LOOP;
         IF (j_ = 0) THEN
            next_analysis_date_ := available_balance_date_tab_(1);
            qty_possible_       := plannable_balance_tab_(0);
         ELSE
            next_analysis_date_ := available_balance_date_tab_(j_ - 1);
            qty_possible_       := plannable_balance_tab_(j_ - 1);
         END IF;
      END IF;
      IF (planned_due_date_ != orig_planned_due_date_) THEN
         IF (planned_due_date_ <= stop_analysis_date_) THEN
            result_ := 'INSIDE_LEADTIME';
         ELSIF ((detect_supplies_not_allowed_) AND
                (stop_analysis_date_ = last_calendar_date_-1)) THEN
            result_ := 'SUPPLIES_NOT_ALLOWED';
         ELSE
            result_ := 'OUTSIDE_LEADTIME';
         END IF;
      ELSE
         result_ := 'SUCCESS';
      END IF;
   ELSE
      --Get available quantity based on ownership from all location types except SHIPMENT
      available_balance_ := Get_Inventory_Quantity(contract_           => contract_,
                                                   part_no_            => part_no_,
                                                   configuration_id_   => configuration_id_,
                                                   qty_type_           => 'AVAILABLE',
                                                   expiration_control_ => 'NOT EXPIRED',
                                                   supply_control_db_  => 'NETTABLE',
                                                   ownership_type1_db_ => part_ownership_,
                                                   owning_customer_no_ => owning_customer_no_,
                                                   owning_vendor_no_   => owning_vendor_no_,
                                                   location_type1_db_  => Inventory_Location_Type_API.DB_PICKING,
                                                   location_type2_db_  => Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                                   location_type3_db_  => Inventory_Location_Type_API.DB_PRODUCTION_LINE,
                                                   include_standard_   => include_standard_,
                                                   include_project_    => include_project_,
                                                   activity_seq_       => activity_seq_,
                                                   project_id_         => project_id_);
      next_analysis_date_ := TRUNC(today_);
      qty_earliest_       := available_balance_;
      qty_possible_       := available_balance_;

      IF (available_balance_ >= qty_desired_) THEN
         -- Enough is available so return success.
         planned_delivery_date_ := planned_due_date_;
         result_ := 'SUCCESS';
      ELSE
         -- Not enough is available, so return inside leadtime.
         result_ := 'INSIDE_LEADTIME';

         IF (orig_planned_due_date_ < TRUNC(today_) ) THEN
            -- Set quantity possible to zero because it was due before today.
            qty_possible_ := 0;
         END IF;
      END IF;
   END IF;
EXCEPTION
   WHEN no_analysis THEN
      result_       := 'SUCCESS';
      qty_possible_ := infinite_quantity_;
END Make_Onhand_Analysis_Impl___;


-- Move_Part_Impl___
--   Implementation method for Move_Part.
PROCEDURE Move_Part_Impl___ (
   catch_quantity_                IN OUT NUMBER,
   contract_                      IN     VARCHAR2,
   part_no_                       IN     VARCHAR2,
   configuration_id_              IN     VARCHAR2,
   location_no_                   IN     VARCHAR2,
   lot_batch_no_                  IN     VARCHAR2,
   serial_no_                     IN     VARCHAR2,
   eng_chg_level_                 IN     VARCHAR2,
   waiv_dev_rej_no_               IN     VARCHAR2,
   activity_seq_                  IN     NUMBER,
   handling_unit_id_              IN     NUMBER,
   expiration_date_               IN     DATE,
   to_contract_                   IN     VARCHAR2,
   to_part_no_                    IN     VARCHAR2,
   to_location_no_                IN     VARCHAR2,
   to_destination_db_             IN     VARCHAR2,
   to_waiv_dev_rej_no_            IN     VARCHAR2,
   to_lot_batch_no_               IN     VARCHAR2,
   to_serial_no_                  IN     VARCHAR2,
   to_activity_seq_               IN     NUMBER,
   to_handling_unit_id_           IN     NUMBER,
   quantity_                      IN     NUMBER,
   quantity_reserved_             IN     NUMBER,
   move_comment_                  IN     VARCHAR2,
   order_no_                      IN     VARCHAR2,
   line_no_                       IN     VARCHAR2,
   release_no_                    IN     VARCHAR2,
   line_item_no_                  IN     VARCHAR2,
   source_ref5_                   IN     VARCHAR2,
   order_type_                    IN     VARCHAR2,
   consume_consignment_stock_     IN     BOOLEAN,
   make_transaction_and_postings_ IN     BOOLEAN,
   report_earned_value_db_        IN     VARCHAR2,
   from_part_catalog_rec_         IN     Part_Catalog_API.Public_Rec,
   to_part_catalog_rec_           IN     Part_Catalog_API.Public_Rec,
   transport_task_id_             IN     NUMBER,
   validate_hu_struct_position_   IN     BOOLEAN,
   availability_ctrl_id_          IN     VARCHAR2, 
   always_preserve_serial_no_     IN     BOOLEAN,
   ownership_transfer_reason_id_  IN     VARCHAR2)
IS
   new_record_                    BOOLEAN;
   torec_                         INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   fromrec_                       INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   newrec_                        INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   from_transaction_id_           NUMBER;
   to_transaction_id_             NUMBER;
   to_qty_onhand_                 NUMBER;
   to_qty_in_transit_             NUMBER;
   to_catch_qty_onhand_           NUMBER;
   to_catch_qty_in_transit_       NUMBER;
   to_avg_unit_transit_cost_      NUMBER;
   qty_possible_                  NUMBER;
   transaction_                   VARCHAR2(20);
   move_to_transit_               VARCHAR2(20);
   to_location_type_db_           INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   from_location_type_db_         INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   availability_control_id_       INVENTORY_PART_IN_STOCK_TAB.availability_control_id%TYPE;
   dest_loc_part_ownership_       INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE;
   from_company_                  VARCHAR2(20);
   to_company_                    VARCHAR2(20);
   int_move_comment_              VARCHAR2(2000);
   onhand_analysis_flag_          VARCHAR2(200);
   result_                        VARCHAR2(20);
   price_                         NUMBER;
   from_accounting_id_            NUMBER := 0;
   to_accounting_id_              NUMBER := 0;
   trans_value_                   NUMBER := 0;
   test_date_                     DATE;
   dummy_date_                    DATE;
   dummy_date2_                   DATE;
   receipt_date_                  DATE;
   remove_unit_cost_              BOOLEAN := TRUE;
   condition_code_                VARCHAR2(10);
   empty_cost_detail_tab_         Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   from_cost_detail_tab_          Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   to_cost_detail_tab_            Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   to_inv_part_rec_               Inventory_Part_API.Public_Rec;   
   from_quantity_                 NUMBER;
   to_quantity_                   NUMBER;
   invent_trans_connect_reason_   VARCHAR2(50):=NULL;
   to_eng_chg_level_              INVENTORY_PART_IN_STOCK_TAB.eng_chg_level%TYPE;
   transit_location_group_        VARCHAR2(5);
   to_expiration_date_            INVENTORY_PART_IN_STOCK_TAB.expiration_date%TYPE;
   report_earned_value_temp_      VARCHAR2(5);
   db_consignment_                CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_CONSIGNMENT;
   owning_vendor_no_              INVENTORY_PART_IN_STOCK_TAB.owning_vendor_no%TYPE;
   owning_customer_no_            INVENTORY_PART_IN_STOCK_TAB.owning_customer_no%TYPE;
   local_from_part_catalog_rec_   Part_Catalog_API.Public_Rec;
   local_to_part_catalog_rec_     Part_Catalog_API.Public_Rec;
   to_serial_no_for_stock_        INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE;
   order_type_db_                 VARCHAR2(50);
   order_receipt_serial_count_    NUMBER;
   sum_qty_received_              NUMBER;
   ownership_conflict_            BOOLEAN;
   last_calendar_date_            DATE := Database_Sys.last_calendar_date_;
   calling_process_               VARCHAR2(50);
   move_dest_contract_            VARCHAR2(5);
   move_dest_location_no_         VARCHAR2(35);
BEGIN
   local_from_part_catalog_rec_ := Get_Part_Catalog_Rec___(part_no_, from_part_catalog_rec_);

   IF (to_part_no_ = part_no_) THEN
      local_to_part_catalog_rec_ := local_from_part_catalog_rec_;
   ELSE
      local_to_part_catalog_rec_ := Get_Part_Catalog_Rec___(to_part_no_, to_part_catalog_rec_); 
   END IF;

   move_to_transit_     := 'Y';
   int_move_comment_    := move_comment_;
   from_quantity_       := quantity_;
   to_location_type_db_ := Inventory_Location_API.Get_Location_Type_db(to_contract_,to_location_no_);
   order_type_db_       := Order_Type_API.Encode(order_type_);

   IF (transport_task_id_ IS NOT NULL) THEN
      calling_process_ := 'EXECUTING_TRANSPORT_TASK_LINE';
   END IF;

   IF ((serial_no_ = '*') AND (to_serial_no_ != '*')) THEN
      -- The call to Move_Part_Impl___ is done in order to split a stock record into serial numbers, so therefore
      -- we should use the value in to_serial_no_ as to_serial_no_for_stock_ even if the to_location_type_ is
      -- a normal stock location type like PICKING or FLOOR STOCK.
      to_serial_no_for_stock_ := to_serial_no_;
   ELSE
      IF (to_destination_db_ = move_to_transit_) THEN
         -- When a serial in stock is moved to transit then we must keep the serial number as it is because
         -- the current position of the serial is changed into "Under Transportation". When receiving the serial from
         -- transit then if not "In Inventory" serial tracking then the quantity will be stored with serial_no = '*'.
         to_serial_no_for_stock_ := to_serial_no_;
      ELSE
         IF (always_preserve_serial_no_) THEN
            -- This option is useful when changing handling unit ID to zero in a picking location with serial tracking only at receipt and issue
            -- We still want to keep the identified serial number if this is done as part of moving reserved stock since we do not want to loose
            -- the already identified serial number because of the unpacking. It is going to be re-reserved again.
            to_serial_no_for_stock_ := to_serial_no_;
         ELSE
            to_serial_no_for_stock_ := Get_Serial_No_For_Stock(to_part_no_,
                                                               to_serial_no_,
                                                               local_to_part_catalog_rec_,
                                                               to_location_type_db_,
                                                               to_handling_unit_id_);
         END IF;
      END IF;
   END IF;

   IF (to_lot_batch_no_ != lot_batch_no_) THEN
      IF (to_destination_db_ = move_to_transit_) THEN
         Error_SYS.Record_General('InventoryPartInStock','WDRNODESTERR: Qty may not be moved to transit when changing Lot Batch No.');
      END IF;
      IF (to_location_no_ != location_no_) THEN
         Error_SYS.Record_General('InventoryPartInStock','WDRNOLOCERR: Qty may not be moved to another location when changing Lot Batch No');
      END IF;
      IF (to_contract_ != contract_) THEN
         Error_SYS.Record_General('InventoryPartInStock','WDRNOSITEERR: Qty may not be moved to another site when changing Lot Batch No');
      END IF;
   END IF;

   IF ((to_serial_no_ != serial_no_) OR (to_part_no_ != part_no_)) THEN
      IF (to_destination_db_ = move_to_transit_) THEN
         Error_SYS.Record_General('InventoryPartInStock','SERNODESTI: Qty may not be moved to transit when renaming a serial.');
      END IF;
      IF (to_location_no_ != location_no_) THEN
         Error_SYS.Record_General('InventoryPartInStock','SERNOLOCNO: Qty may not be moved to another location when renaming a serial.');
      END IF;
      IF (to_contract_ != contract_) THEN
         Error_SYS.Record_General('InventoryPartInStock','SERNOSITE: Qty may not be moved to another site when renaming a serial.');
      END IF;
      IF (to_waiv_dev_rej_no_ != waiv_dev_rej_no_) THEN
         Error_SYS.Record_General('InventoryPartInStock','SERNOWDR: W/D/R No may not be changed when renaming a serial.');
      END IF;
      IF (to_lot_batch_no_ != lot_batch_no_) THEN
         Error_SYS.Record_General('InventoryPartInStock','SERNOLOTBATCH: Lot/Batch No may not be changed when renaming a serial.');
      END IF;
      IF (to_activity_seq_ != activity_seq_) THEN
         Error_SYS.Record_General('InventoryPartInStock','SERNOACTIVITY: Activity Sequence may not be changed when renaming a serial.');
      END IF;
      IF (to_handling_unit_id_ != handling_unit_id_) THEN
         Error_SYS.Record_General('InventoryPartInStock','SERNOHANDLUNIT: Handling Unit Id may not be changed when renaming a serial.');
      END IF;
   END IF;

   IF (to_activity_seq_ != activity_seq_) THEN
      IF (to_destination_db_ = move_to_transit_) THEN
         Error_SYS.Record_General('InventoryPartInStock','PRJNODESTI: Qty may not be moved to transit when changing Activity Sequence.');
      END IF;
      IF (to_location_no_ != location_no_) THEN
         Error_SYS.Record_General('InventoryPartInStock','PRJNOLOCNO: Qty may not be moved to another location when changing Activity Sequence.');
      END IF;
      IF (to_contract_ != contract_) THEN
         Error_SYS.Record_General('InventoryPartInStock','PRJNOSITE: Qty may not be moved to another site when changing Activity Sequence.');
      END IF;
      IF (to_waiv_dev_rej_no_ != waiv_dev_rej_no_) THEN
         Error_SYS.Record_General('InventoryPartInStock','PRJNOWDR: W/D/R No may not be changed when changing Activity Sequence.');
      END IF;
      IF (to_lot_batch_no_ != lot_batch_no_) THEN
         Error_SYS.Record_General('InventoryPartInStock','PRJNOLOTBATCH: Lot/Batch No may not be changed when changing Activity Sequence.');
      END IF;
      IF (to_serial_no_ != serial_no_) THEN
         Error_SYS.Record_General('InventoryPartInStock','PRJNOSERIAL: Serial No may not be changed when changing Activity Sequence.');
      END IF;
      IF (to_part_no_ != part_no_) THEN
         Error_SYS.Record_General('InventoryPartInStock','PRJNOPARTNO: Part No may not be changed when changing Activity Sequence.');
      END IF;
      IF (to_handling_unit_id_ != handling_unit_id_) THEN
         Error_SYS.Record_General('InventoryPartInStock','PRJNOHANDLUNIT: Handling Unit ID may not be changed when changing Activity Sequence.');
      END IF;
      $IF Component_Proj_SYS.INSTALLED $THEN     
         Activity_API.Validate_Activity_State(activity_seq_, 'INVENTORY_TRANSFER_FROM');
         Activity_API.Validate_Activity_State(to_activity_seq_, 'INVENTORY_TRANSFER_TO');         
      $ELSE
         Error_SYS.Record_General(lu_name_, 'NOACTIVITY2: Activity Sequence must be zero when LU Activity is not installed.');
      $END
   END IF;

   IF (to_handling_unit_id_ != handling_unit_id_) THEN
      IF (to_destination_db_ = move_to_transit_) THEN
         Error_SYS.Record_General('InventoryPartInStock','HANDLUNITDESTI: Qty may not be moved to transit when changing Handling Unit ID.');
      END IF;
      IF (to_location_no_ != location_no_) THEN
         Error_SYS.Record_General('InventoryPartInStock','HANDLUNITLOCNO: Qty may not be moved to another location when changing Handling Unit ID.');
      END IF;
      IF (to_contract_ != contract_) THEN
         Error_SYS.Record_General('InventoryPartInStock','HANDLUNITSITE: Qty may not be moved to another site when changing Handling Unit ID.');
      END IF;
      IF (to_waiv_dev_rej_no_ != waiv_dev_rej_no_) THEN
         Error_SYS.Record_General('InventoryPartInStock','HANDLUNITWDR: W/D/R No may not be changed when changing Handling Unit ID.');
      END IF;
      IF (to_lot_batch_no_ != lot_batch_no_) THEN
         Error_SYS.Record_General('InventoryPartInStock','HANDLUNITLOTBATCH: Lot/Batch No may not be changed when changing Handling Unit ID.');
      END IF;
      IF (to_serial_no_ != serial_no_) THEN
         Error_SYS.Record_General('InventoryPartInStock','HANDLUNITSERIAL: Serial No may not be changed when changing Handling Unit ID.');
      END IF;
      IF (to_part_no_ != part_no_) THEN
         Error_SYS.Record_General('InventoryPartInStock','HANDLUNITPARTNO: Part No may not be changed when changing Handling Unit ID.');
      END IF;
      IF (to_activity_seq_ != activity_seq_) THEN
         Error_SYS.Record_General('InventoryPartInStock','HANDLUNITACTIVITY: Activity Sequence may not be changed when changing Handling Unit ID.');
      END IF;
   END IF;

   IF (part_no_ = to_part_no_) THEN
      IF (contract_ = to_contract_) THEN
         -- move part within one site
         to_eng_chg_level_ := eng_chg_level_;
      ELSE
         -- move part between sites
         Inventory_Part_Revision_API.Get_Matched_Eng_Chg_Level(to_eng_chg_level_,
                                                               contract_,
                                                               to_contract_,
                                                               part_no_,
                                                               eng_chg_level_,
                                                               TRUE);
      END IF;
   ELSE
      -- Rename_Serial - new part number
      to_eng_chg_level_ := Inventory_Part_Revision_API.Get_Latest_Eng_Chg_Level(to_contract_,to_part_no_);
   END IF;

   fromrec_ := Lock_By_Keys___(contract_,
                               part_no_,
                               configuration_id_,
                               location_no_,
                               lot_batch_no_,
                               serial_no_,
                               eng_chg_level_,
                               waiv_dev_rej_no_,
                               activity_seq_,
                               handling_unit_id_);

   IF (from_quantity_ > fromrec_.qty_onhand) THEN
      Error_SYS.Record_General('InventoryPartInStock','QTYMORETHANONHAND: Cannot move more than qty on hand.');
   END IF;

   from_location_type_db_ := fromrec_.location_type;

   IF (to_serial_no_for_stock_ != to_serial_no_) THEN
      ownership_conflict_ := Ownership_Conflict_Exists___(to_contract_,
                                                          to_part_no_,
                                                          configuration_id_,
                                                          to_location_no_,
                                                          to_lot_batch_no_,
                                                          to_serial_no_for_stock_,
                                                          to_eng_chg_level_,
                                                          to_waiv_dev_rej_no_,
                                                          to_activity_seq_,
                                                          to_handling_unit_id_,
                                                          fromrec_.part_ownership,
                                                          fromrec_.owning_customer_no,
                                                          fromrec_.owning_vendor_no);
      IF (ownership_conflict_) THEN
         -- Changing the serial number will create an ownership conflict that results in an error message.
         -- So instead we keep the serial number as it is in InventoryPartInStock and indicate the serial
         -- as being tracked in inventory although it is only set as receipt and issue tracking in PartCatalog.
         to_serial_no_for_stock_ := to_serial_no_;
         Part_Serial_Catalog_API.Set_Tracked_In_Inventory(to_part_no_, to_serial_no_);
      END IF;
   END IF;

   -- Check if the location to move to already exists or not
   IF (Check_Exist___(to_contract_,
                      to_part_no_,
                      configuration_id_,
                      to_location_no_,
                      to_lot_batch_no_,
                      to_serial_no_for_stock_,
                      to_eng_chg_level_,
                      to_waiv_dev_rej_no_,
                      to_activity_seq_,
                      to_handling_unit_id_)) THEN
      new_record_ := FALSE;

      -- Lock the record found for update.
      torec_ := Lock_By_Keys___(to_contract_,
                                to_part_no_,
                                configuration_id_,
                                to_location_no_,
                                to_lot_batch_no_,
                                to_serial_no_for_stock_,
                                to_eng_chg_level_,
                                to_waiv_dev_rej_no_,
                                to_activity_seq_,
                                to_handling_unit_id_);
      newrec_ := torec_;

      IF (fromrec_.contract         = torec_.contract         AND
          fromrec_.part_no          = torec_.part_no          AND
          fromrec_.configuration_id = torec_.configuration_id AND
          fromrec_.location_no      = torec_.location_no      AND
          fromrec_.lot_batch_no     = torec_.lot_batch_no     AND
          fromrec_.serial_no        = torec_.serial_no        AND
          fromrec_.eng_chg_level    = torec_.eng_chg_level    AND
          fromrec_.waiv_dev_rej_no  = torec_.waiv_dev_rej_no  AND
          fromrec_.activity_seq     = torec_.activity_seq     AND
          fromrec_.handling_unit_id = torec_.handling_unit_id) THEN
         IF ( fromrec_.activity_seq = 0 ) THEN
            Error_SYS.Record_General('InventoryPartInStock','MOVETOSAME: You cannot move the part(s) to the same location :P1, select a different location.', fromrec_.location_no);
         ELSE
            Error_SYS.Record_General('InventoryPartInStock','MOVETOSAMEACTSEQ: You cannot move the part(s) to the same project activity, select a different project activity.');
         END IF;
      END IF;

      IF ((torec_.freeze_flag  = 'Y') AND (to_destination_db_ != move_to_transit_)) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'FREEZEPART: Inventory Part :P1 on location :P2 at site :P3 is blocked for inventory transactions because of counting.', to_part_no_, to_location_no_, to_contract_);
      END IF;

      to_qty_onhand_            := torec_.qty_onhand;
      to_qty_in_transit_        := torec_.qty_in_transit;
      to_catch_qty_onhand_      := torec_.catch_qty_onhand;
      to_catch_qty_in_transit_  := torec_.catch_qty_in_transit;
      to_avg_unit_transit_cost_ := torec_.avg_unit_transit_cost;

      IF (((NVL(fromrec_.receipt_date,last_calendar_date_))  >
           (NVL(torec_.receipt_date,last_calendar_date_))) AND (torec_.qty_onhand > 0)) THEN
         receipt_date_ := torec_.receipt_date;
      ELSE
         receipt_date_ := fromrec_.receipt_date;
      END IF;
   ELSE
      new_record_               := TRUE;
      to_qty_onhand_            := 0;
      to_qty_in_transit_        := 0;
      to_catch_qty_onhand_      := 0;
      to_catch_qty_in_transit_  := 0;
      to_avg_unit_transit_cost_ := 0;
      receipt_date_             := fromrec_.receipt_date;
   END IF;

   -- Restructured to give priority to the IN parameter availability_ctrl_id_ when assigning the value for availability_control_id_.
   -- If the value set from the client is STRING_NULL for the IN parameter availability_ctrl_id_, we will assign it to availability_control_id_ and 
   -- we will assign NULL for that to update the availability control Id in a later stage.
   IF (availability_ctrl_id_ IS NOT NULL) THEN
      availability_control_id_ := availability_ctrl_id_;      
   ELSE
      IF (to_qty_onhand_ = 0 AND to_qty_in_transit_ = 0) THEN
         availability_control_id_ := Get_Move_Dest_Avail_Ctrl_Id___(fromrec_,
                                                                 torec_,
                                                                 to_contract_,
                                                                 to_location_no_,
                                                                 new_record_);         
      END IF;
   END IF;   
   IF (to_qty_onhand_ = 0 AND to_qty_in_transit_ = 0) THEN
      to_expiration_date_ := NVL(expiration_date_, fromrec_.expiration_date);
   ELSE
      to_expiration_date_ := expiration_date_;
   END IF;

   IF ((contract_ = to_contract_) AND
       (part_no_  = to_part_no_ ) AND
       (fromrec_.serial_no = '*') AND
       (NOT Stock_Location___(from_location_type_db_)) AND
       (    Stock_Location___(to_location_type_db_  )) AND
       (local_from_part_catalog_rec_.receipt_issue_serial_track = db_true_)) THEN
      -- This is typically a move from an Arrival or QA location into a stock location like Picking or Floor Stock,
      -- as a part of the PO or intersite shipment order Receipt process. IF the part is Receipt And Issue Serial 
      -- Tracked then we require that the serial numbers are specified in this process. The reason for this is that
      -- we need to make sure that serial numbers have been entered for the complete receipt.
      
      IF (local_from_part_catalog_rec_.serial_tracking_code = db_serial_tracking_) THEN
         Raise_Loc_Type_Serial_Error___(part_no_, to_location_type_db_);
      END IF;

      order_receipt_serial_count_ := Inventory_Transaction_Hist_API.Get_Order_Receipt_Serial_Count(order_no_,
                                                                                                   line_no_,
                                                                                                   release_no_,
                                                                                                   line_item_no_,
                                                                                                   order_type_db_);

      sum_qty_received_ := Inventory_Transaction_Hist_API.Get_Sum_Qty_Received(source_ref1_        => order_no_,
                                                                               source_ref2_        => line_no_,
                                                                               source_ref3_        => release_no_,
                                                                               source_ref4_        => line_item_no_,
                                                                               source_ref_type_db_ => order_type_db_,
                                                                               contract_           => NULL,
                                                                               part_no_            => NULL,
                                                                               configuration_id_   => NULL,
                                                                               lot_batch_no_       => NULL);
      IF (order_receipt_serial_count_ < sum_qty_received_) THEN
         Raise_Loc_Type_Serial_Error___(part_no_, to_location_type_db_);
      END IF;      
   END IF;

   --------------------------------------------------------------------------------------
   --  The call to method Check_Valid_Move_Combinations secures that all moving of parts
   --  is done in a way that guarantees database consistency. Do NOT change or remove this
   --  method call. That can result in database inconsistency and serious problems.
   --------------------------------------------------------------------------------------
   Check_Valid_Move_Combinations(contract_,
                                 from_location_type_db_,
                                 to_contract_,
                                 to_location_type_db_,
                                 to_destination_db_,
                                 order_no_,
                                 order_type_db_,
                                 part_no_,
                                 to_part_no_);
   IF (NVL(TRUNC(to_expiration_date_), last_calendar_date_)
          > NVL(fromrec_.expiration_date, last_calendar_date_)) THEN
      Error_SYS.Record_General(lu_name_, 'EXPDATELATE: Expiration date may not be later than from-locations exp. date.');
   END IF;
   
   IF (fromrec_.serial_no != '*') THEN
      IF (from_quantity_ != 1) THEN
         Error_SYS.Record_General(lu_name_, 'ZEROQUANTITY: The quantity must be greater than 0.');
      END IF;
      IF ((quantity_reserved_ NOT IN (0,1)) OR
         ((NVL(torec_.qty_onhand,0) != 0) AND (to_serial_no_for_stock_ != '*'))) THEN
         Error_SYS.Record_General(lu_name_, 'ILLQTYSERIAL: The quantity may only be 0 or 1 when serial numbers are being used.');
      END IF;
   END IF;

   from_company_ := Site_API.Get_Company(contract_);
   to_company_   := from_company_;

   IF (contract_ != to_contract_) THEN
      -- This is a move between two different sites.
      remove_unit_cost_ := TRUE;
      to_company_       := Site_API.Get_Company(to_contract_);

      IF (from_company_ = to_company_) THEN
         transaction_ := 'INVM-OUT';
      ELSE
         -- This is a move between two different companies. This requires a different
         -- transaction code. We also put the contract that we are moving to in the
         -- int_move_comment_. This is used in the posting control to find the other company.
         transaction_ := 'COMPM-OUT';
      END IF;

      IF (Part_Availability_Control_API.Check_Supply_Control(fromrec_.availability_control_id) = 'NETTABLE')
       AND NVL(fromrec_.expiration_date, last_calendar_date_) > TRUNC(Site_API.Get_Site_Date(contract_)) THEN
         onhand_analysis_flag_ := Inventory_Part_API.Get_Onhand_Analysis_Flag(fromrec_.contract, fromrec_.part_no);

         IF onhand_analysis_flag_ = Inventory_Part_Onh_Analys_API.Decode('Y') THEN
            test_date_ := Site_API.Get_Site_Date(contract_);

            Make_Onhand_Analysis(result_,
                                 qty_possible_,
                                 dummy_date2_,
                                 dummy_date_,
                                 test_date_,
                                 contract_,
                                 part_no_,
                                 configuration_id_,
                                 db_true_,
                                 db_true_,
                                 fromrec_.project_id,
                                 fromrec_.activity_seq,
                                 'ROWID',
                                 from_quantity_);

            IF (result_ IN ('INSIDE_LEADTIME', 'OUTSIDE_LEADTIME')) THEN
               Client_SYS.Add_Warning(lu_name_, 'PLANLESS: Only :P1 is plannable on the delivery date entered.',To_Char(qty_possible_));
            END IF;
         END IF;
      END IF;
   ELSE
      -- This is a move within one site.
      IF ((lot_batch_no_ != to_lot_batch_no_)  OR
          (part_no_      != to_part_no_     )  OR
          (serial_no_    != to_serial_no_   )) THEN
         remove_unit_cost_ := TRUE;
      ELSE
         remove_unit_cost_ := FALSE;
      END IF;

      -- Setting the transaction code for the Issue transaction.
      IF (to_location_no_ != location_no_) THEN
         -- A move between locations
         IF (from_location_type_db_ = Inventory_Location_Type_API.DB_SHIPMENT OR
             to_location_type_db_   = Inventory_Location_Type_API.DB_SHIPMENT) THEN
            transaction_ := 'PICK-OUT';
         ELSIF (to_destination_db_ = move_to_transit_) THEN
            transaction_ := 'INVM-TRISS';   
         ELSE
            transaction_ := 'INVM-ISS';
         END IF;
      ELSIF (part_no_ != to_part_no_) THEN
         -- Replacing the part number on a serial
         transaction_ := 'PARTREN-';
      ELSIF (lot_batch_no_ != to_lot_batch_no_) THEN
         transaction_ := 'LOT-OUT';
      ELSIF (serial_no_ != to_serial_no_) THEN
         -- Replacing the serial number on a serial
         transaction_      := 'SERREN-';
         int_move_comment_ := to_serial_no_;
      ELSIF (activity_seq_ != to_activity_seq_) THEN
         -- Transferring quantities between project actitivites
         transaction_ := 'PROJTRAN-';
      ELSIF (to_waiv_dev_rej_no_ != waiv_dev_rej_no_) THEN
         -- Changing the WDR Number of a stock record quantity
         transaction_ := 'WDR-OUT';
      ELSIF (to_handling_unit_id_ != handling_unit_id_) THEN
         -- putting a stock record quantity in a handling unit or moving between handling units or removing from a handling unit.
         transaction_ := 'HANDLUNIT-';
      END IF;
   END IF;

   Check_Ownership_Move_Part(fromrec_.part_ownership,
                             fromrec_.owning_vendor_no,
                             fromrec_.owning_customer_no,
                             fromrec_.part_no,
                             fromrec_.location_no,
                             fromrec_.location_type,
                             torec_.part_ownership,
                             torec_.owning_vendor_no,
                             torec_.owning_customer_no,
                             torec_.part_no,
                             torec_.location_no,
                             to_destination_db_,
                             consume_consignment_stock_);

   IF (fromrec_.part_ownership = db_consignment_) AND (consume_consignment_stock_) THEN
      -- Ownership is changed to company owned when consignment is consumed
      dest_loc_part_ownership_ := Part_Ownership_API.DB_COMPANY_OWNED;
      owning_vendor_no_        := NULL;
      owning_customer_no_      := NULL;
   ELSE
      dest_loc_part_ownership_ := fromrec_.part_ownership;
      owning_vendor_no_        := fromrec_.owning_vendor_no;
      owning_customer_no_      := fromrec_.owning_customer_no;
   END IF;

   IF ((to_part_no_     != part_no_)  OR
       (to_contract_    != contract_) OR
       (to_location_no_ != location_no_)) THEN
      IF (to_qty_onhand_ = 0) AND (to_qty_in_transit_ = 0) THEN
         Check_Allow_Ownership_Mix(to_contract_,
                                   to_part_no_,
                                   to_location_no_,
                                   dest_loc_part_ownership_,
                                   owning_customer_no_,
                                   owning_vendor_no_);
      END IF;
   END IF;

   IF (((to_location_no_ != location_no_) OR (to_contract_ != contract_)) AND (from_company_ = to_company_)) THEN
      -- Need to use location_group of destination location as control type value for the M3 posting.
      transit_location_group_ := Inventory_Location_API.Get_Location_Group(to_contract_, to_location_no_);
   END IF;
   
   IF (contract_ = to_contract_) THEN
      to_quantity_ := from_quantity_;
   ELSE
      -- The to_quantity has to be converted into the destination locations UoM if a move takes place between 2 sites.
      to_quantity_ :=Inventory_Part_API.Get_Site_Converted_Qty(contract_,
                                                            part_no_,
                                                            to_contract_,
                                                            from_quantity_,
                                                            'REMOVE');
   END IF;

   IF ((to_location_no_ != location_no_) OR (to_contract_ != contract_)) THEN
      move_dest_contract_    := to_contract_;
      move_dest_location_no_ := to_location_no_;
      IF (to_handling_unit_id_ != 0) THEN
         -- The check for packed stock needs to be done before the call to Issue_Part_Impl___.
         -- The check for unpacked stock needs to be done after the call to Issue_Part_Impl___ further down in the method
         Inventory_Putaway_Manager_API.Check_Storage_Requirements(to_contract_,
                                                                  to_part_no_,
                                                                  configuration_id_,
                                                                  to_location_no_,
                                                                  to_lot_batch_no_,
                                                                  to_serial_no_,
                                                                  to_eng_chg_level_,
                                                                  to_waiv_dev_rej_no_,
                                                                  to_activity_seq_,
                                                                  to_handling_unit_id_,
                                                                  to_quantity_,
                                                                  calling_process_);
      END IF;
   END IF;

   Issue_Part_Impl___(transaction_id_               => from_transaction_id_,
                      accounting_id_                => from_accounting_id_,
                      trans_value_                  => trans_value_,
                      catch_quantity_               => catch_quantity_,
                      contract_                     => contract_,
                      part_no_                      => part_no_,
                      configuration_id_             => configuration_id_,
                      location_no_                  => location_no_,
                      lot_batch_no_                 => lot_batch_no_,
                      serial_no_                    => serial_no_,
                      eng_chg_level_                => eng_chg_level_,
                      waiv_dev_rej_no_              => waiv_dev_rej_no_,
                      activity_seq_                 => activity_seq_,
                      handling_unit_id_             => handling_unit_id_,
                      transaction_                  => transaction_,
                      quantity_                     => from_quantity_,
                      quantity_reserved_            => quantity_reserved_,
                      source_ref1_                  => order_no_,
                      source_ref2_                  => line_no_,
                      source_ref3_                  => release_no_,
                      source_ref4_                  => line_item_no_,
                      source_ref5_                  => source_ref5_, 
                      source_                       => int_move_comment_,
                      unreceive_                    => FALSE,
                      forced_                       => FALSE,
                      cost_detail_tab_              => empty_cost_detail_tab_,
                      source_ref_type_              => order_type_,
                      reject_code_                  => NULL,
                      remove_unit_cost_             => remove_unit_cost_,
                      make_transaction_             => make_transaction_and_postings_,
                      transit_location_group_       => transit_location_group_,
                      report_earned_value_db_       => report_earned_value_db_,
                      part_catalog_rec_             => local_from_part_catalog_rec_,
                      original_transaction_id_      => NULL,
                      prevent_fifo_action_          => FALSE,
                      ownership_transfer_reason_id_ => ownership_transfer_reason_id_,
                      validate_hu_struct_position_  => FALSE,
                      move_dest_contract_           => move_dest_contract_,
                      move_dest_location_no_        => move_dest_location_no_);


   IF ((contract_ != to_contract_) OR
        ((contract_           = to_contract_) AND
         (to_destination_db_ != move_to_transit_))) THEN
      --  A second inventory transaction needs to be created because either this
      --  is a move to another site, or, if within a site, it is not via transit
      IF ((contract_           = to_contract_) AND
          (to_destination_db_ != move_to_transit_)) THEN
         -- Setting the transaction code for the Receipt transaction.
         IF (to_location_no_ != location_no_) THEN
            --  This is a direct move within the same site, not via transit
            IF ((to_location_type_db_   = Inventory_Location_Type_API.DB_SHIPMENT) OR
                (from_location_type_db_ = Inventory_Location_Type_API.DB_SHIPMENT)) THEN
               transaction_ := 'PICK-IN';
            ELSE
               transaction_ := 'INVM-IN';
            END IF;
         ELSIF (part_no_ != to_part_no_) THEN
            -- Replacing the part number on a serial
               transaction_                 := 'PARTREN+';
               invent_trans_connect_reason_ := 'RENAME SERIAL';
         ELSIF (lot_batch_no_ != to_lot_batch_no_) THEN
               transaction_ := 'LOT-IN';
         ELSIF (serial_no_ != to_serial_no_) THEN
            -- Replacing the serial number on a serial
               transaction_                 := 'SERREN+';
               int_move_comment_            := serial_no_;
               invent_trans_connect_reason_ := 'RENAME SERIAL';
         ELSIF (activity_seq_ != to_activity_seq_) THEN
            -- Transferring quantities between project actitivites
               transaction_ := 'PROJTRAN+';
         ELSIF (to_waiv_dev_rej_no_ != waiv_dev_rej_no_) THEN
            -- Changing the WDR Number of a stock record quantity
               transaction_ := 'WDR-IN';
         ELSIF (to_handling_unit_id_ != handling_unit_id_) THEN
            -- putting a stock record quantity in a handling unit or moving between handling units or removing from a handling unit.
            transaction_ := 'HANDLUNIT+';
         END IF;
      ELSIF ((contract_          != to_contract_) AND
             (to_destination_db_ != move_to_transit_)) THEN
         --  This is a direct move to another site, not via transit
         IF (from_company_ = to_company_) THEN
            transaction_                 := 'INVM-COIN';
            invent_trans_connect_reason_ := 'INTERSITE TRANSFER';
         ELSE
            -- This is a move between two different companies. This requires a different
            -- transaction code. We also put the contract that we are moving from in the
            -- int_move_comment_. This is used in the posting control to find the other company.
            transaction_                 := 'COMPM-IN';
            invent_trans_connect_reason_ := 'INTERSITE TRANSFER';
         END IF;

         catch_quantity_ :=Inventory_Part_API.Get_Site_Converted_Qty(contract_,
                                                                     part_no_,
                                                                     to_contract_,
                                                                     catch_quantity_,
                                                                     'REMOVE',
                                                                     'CATCH' );
      ELSE
         --  This is a move to another site, via transit
         IF (from_company_ = to_company_) THEN
            transaction_                 := 'INVM-TRIN';
            invent_trans_connect_reason_ := 'INTERSITE TRANSFER';
         ELSE
            -- This is a move between two different companies. This requires a different
            -- transaction code. We also put the contract that we are moving from in the
            -- int_move_comment_. This is used in the posting control to find the other company.
            transaction_                 := 'COMPM-TRIN';
            invent_trans_connect_reason_ := 'INTERSITE TRANSFER';
         END IF;

         catch_quantity_ :=Inventory_Part_API.Get_Site_Converted_Qty(contract_,
                                                                     part_no_,
                                                                     to_contract_,
                                                                     catch_quantity_,
                                                                     'REMOVE',
                                                                     'CATCH');
      END IF;

      -- IF this is a move between site in the same company the cost details from the issue
      -- transaction at the source site should be passed when creating the receive transaction on
      -- the destination site. Since cost buckets might differ on the two site these will have to
      -- be 'translated' to buckets at the receiving site.
      -- For moves between companies only the total cost of the issue will be past.

      to_inv_part_rec_:= Inventory_Part_API.Get(to_contract_, to_part_no_);

      -- Check for Zero Cost Only on receiving site
      IF (to_inv_part_rec_.inventory_valuation_method = 'ST') AND
         (to_inv_part_rec_.zero_cost_flag = 'O') THEN
         price_ := 0;
      ELSIF (from_company_ = to_company_) THEN
         price_          := NULL;
         condition_code_ := Condition_Code_Manager_API.Get_Condition_Code (to_part_no_,
                                                                           to_serial_no_,
                                                                           to_lot_batch_no_);

         IF ((to_inv_part_rec_.inventory_valuation_method = 'ST') AND
             (Inventory_Part_Unit_Cost_API.Standard_Cost_Exist(to_contract_,
                                                               to_part_no_,
                                                               configuration_id_,
                                                               to_lot_batch_no_,
                                                               to_serial_no_,
                                                               condition_code_) = db_true_)) THEN
            -- In this case cost details will not have to be passed when creating the transaction
            -- at the receiving site.
            NULL;
         ELSE
            -- Retrive cost details from the issue transaction and transform them into
            -- the corresponding details on the receiving site
            from_cost_detail_tab_ := Inventory_Transaction_Hist_API.Get_Transaction_Cost_Details(from_transaction_id_);
            to_cost_detail_tab_   := Transform_Cost_Details(contract_,
                                                            from_cost_detail_tab_,
                                                            to_contract_,
                                                            to_inv_part_rec_.inventory_valuation_method,
                                                            to_inv_part_rec_.inventory_part_cost_level);
         END IF;
      ELSE
         -- Move between different companies
         price_ := Inventory_Transaction_Hist_API.Get_Cost(from_transaction_id_);
         price_ := Site_API.Get_Currency_Converted_Cost(contract_, to_contract_, price_);

         to_cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Generate_Cost_Details(
                                                  cost_detail_tab_       => empty_cost_detail_tab_,
                                                  unit_cost_             => price_,
                                                  unit_cost_is_material_ => TRUE,
                                                  company_               => to_company_,
                                                  contract_              => to_contract_,
                                                  part_no_               => to_part_no_,
                                                  configuration_id_      => configuration_id_,
                                                  source_ref1_           => NULL,
                                                  source_ref2_           => NULL,
                                                  source_ref3_           => NULL,
                                                  source_ref4_           => NULL,
                                                  source_ref_type_db_    => 'INTER_COMPANY_MOVE');
         price_ := NULL;
      END IF;

      -- IF destination location is a consignment stock, or destination is a "not consignment
      -- inventory" location but isn't going to be consumed.
      IF (fromrec_.part_ownership = db_consignment_) AND
          (dest_loc_part_ownership_ != db_consignment_) THEN
         transaction_                 := 'CO-CONS-IN';
         invent_trans_connect_reason_ := 'INTERSITE TRANSFER';
      END IF;

      IF (make_transaction_and_postings_) THEN
         IF (to_cost_detail_tab_.COUNT > 0) THEN
            FOR i_ IN to_cost_detail_tab_.FIRST..to_cost_detail_tab_.LAST LOOP
               to_cost_detail_tab_(i_).unit_cost := ((to_cost_detail_tab_(i_).unit_cost * from_quantity_)/to_quantity_);
            END LOOP;
         END IF;

         IF (NVL(to_activity_seq_, 0) = 0) THEN
            report_earned_value_temp_ := NULL;
         ELSE
            report_earned_value_temp_ := report_earned_value_db_;
         END IF;
         
         Inventory_Transaction_Hist_API.NEW(
                                  transaction_id_           => to_transaction_id_,
                                  accounting_id_            => to_accounting_id_,
                                  value_                    => trans_value_,
                                  transaction_code_         => transaction_,
                                  contract_                 => to_contract_,
                                  part_no_                  => to_part_no_,
                                  configuration_id_         => configuration_id_,
                                  location_no_              => to_location_no_,
                                  lot_batch_no_             => to_lot_batch_no_,
                                  serial_no_                => to_serial_no_,
                                  waiv_dev_rej_no_          => to_waiv_dev_rej_no_,
                                  eng_chg_level_            => to_eng_chg_level_,
                                  activity_seq_             => to_activity_seq_,
                                  handling_unit_id_         => to_handling_unit_id_,
                                  project_id_               => NULL,
                                  source_ref1_              => order_no_,
                                  source_ref2_              => line_no_,
                                  source_ref3_              => release_no_,
                                  source_ref4_              => line_item_no_,
                                  source_ref5_              => source_ref5_,
                                  reject_code_              => NULL,
                                  cost_detail_tab_          => to_cost_detail_tab_,
                                  unit_cost_                => price_,
                                  quantity_                 => to_quantity_,
                                  qty_reversed_             => 0,
                                  catch_quantity_           => catch_quantity_,
                                  source_                   => int_move_comment_,
                                  source_ref_type_          => order_type_,
                                  owning_vendor_no_         => owning_vendor_no_,
                                  condition_code_           => NULL,
                                  location_group_           => NULL,
                                  part_ownership_db_        => dest_loc_part_ownership_,
                                  owning_customer_no_       => owning_customer_no_,
                                  expiration_date_          => to_expiration_date_,
                                  report_earned_value_db_   => report_earned_value_temp_ ,
                                  operational_condition_db_ => NULL,
                                  ownership_transfer_reason_id_ => ownership_transfer_reason_id_);

         IF (invent_trans_connect_reason_ IS NOT NULL) THEN
            -- Create a connection between transactions
            Invent_Trans_Interconnect_API.Connect_Transactions(from_transaction_id_,
                                                               to_transaction_id_,
                                                               invent_trans_connect_reason_);
         END IF;
         
         Inventory_Transaction_Hist_API.Do_Transaction_Booking(from_transaction_id_,
                                                               from_company_,
                                                               'N',
                                                               NULL);
         Inventory_Transaction_Hist_API.Do_Transaction_Booking(to_transaction_id_,
                                                               to_company_,
                                                               'N',
                                                               NULL);
      END IF;

      $IF Component_Purch_SYS.INSTALLED $THEN         
         Receive_Purchase_Order_API.Create_Consignment_Transaction(to_transaction_id_);                  
      $END
   ELSIF ((contract_ = to_contract_) AND (to_destination_db_ = move_to_transit_)) THEN
      IF (from_transaction_id_ IS NOT NULL) THEN
         Inventory_Transaction_Hist_API.Do_Transaction_Booking(from_transaction_id_,
                                                               from_company_,
                                                               'N',
                                                               NULL);
      END IF;
   END IF;

   IF new_record_ = TRUE THEN
      newrec_.contract         := to_contract_           ;
      newrec_.part_no          := to_part_no_            ;
      newrec_.configuration_id := configuration_id_      ;
      newrec_.location_no      := to_location_no_        ;
      newrec_.lot_batch_no     := to_lot_batch_no_       ;
      newrec_.serial_no        := to_serial_no_for_stock_;
      newrec_.eng_chg_level    := to_eng_chg_level_      ;
      newrec_.waiv_dev_rej_no  := to_waiv_dev_rej_no_    ;
      newrec_.activity_seq     := to_activity_seq_       ;
      newrec_.handling_unit_id := to_handling_unit_id_   ;
   END IF;

   IF to_destination_db_ != move_to_transit_ THEN
      newrec_.qty_onhand       := to_qty_onhand_       + to_quantity_   ;
      newrec_.catch_qty_onhand := to_catch_qty_onhand_ + catch_quantity_;
   ELSE
      to_avg_unit_transit_cost_ := ((Nvl(to_qty_in_transit_, 0) * to_avg_unit_transit_cost_) +
             trans_value_) / (Nvl(to_qty_in_transit_, 0) + to_quantity_);

      newrec_.qty_in_transit        := to_qty_in_transit_ + to_quantity_;
      newrec_.qty_onhand            := to_qty_onhand_;
      newrec_.catch_qty_in_transit  := NVL(to_catch_qty_in_transit_,0) + catch_quantity_;
      newrec_.catch_qty_onhand      := to_catch_qty_onhand_;
      newrec_.avg_unit_transit_cost := to_avg_unit_transit_cost_;
      newrec_.source                := move_comment_;
   END IF;

   IF to_expiration_date_ IS NOT NULL THEN
      newrec_.expiration_date := to_expiration_date_;
   END IF;

   IF receipt_date_ IS NOT NULL THEN
      newrec_.receipt_date := receipt_date_;
   END IF;

   IF availability_control_id_ IS NOT NULL THEN
      -- If the value sent from the client dialog is STRING_NULL, update the availability control Id to NULL.
      IF availability_control_id_ = Database_Sys.string_null_ THEN
         availability_control_id_ := NULL;         
      END IF;
      newrec_.availability_control_id := availability_control_id_;
   END IF;

   IF ((to_location_no_ != location_no_) OR (to_contract_ != contract_)) THEN
      Part_Availability_Control_API.Check_Part_Movement_Allowed(part_no_, fromrec_.availability_control_id);
      Warehouse_Bay_Bin_API.Check_Receipts_Blocked(to_contract_, to_location_no_);

      IF (to_handling_unit_id_ = 0) THEN
         -- The check for unpacked stock needs to be done after the call to Issue_Part_Impl___. 
         -- The check for packed stock needs to be done before the call to Issue_Part_Impl___ higher up in the method.
         Inventory_Putaway_Manager_API.Check_Storage_Requirements(to_contract_,
                                                                  to_part_no_,
                                                                  configuration_id_,
                                                                  to_location_no_,
                                                                  to_lot_batch_no_,
                                                                  to_serial_no_,
                                                                  to_eng_chg_level_,
                                                                  to_waiv_dev_rej_no_,
                                                                  to_activity_seq_,
                                                                  to_handling_unit_id_,
                                                                  to_quantity_,
                                                                  calling_process_);
      END IF;
   END IF;

   IF (dest_loc_part_ownership_ IS NOT NULL) THEN
      newrec_.part_ownership := dest_loc_part_ownership_;
   END IF;

   IF (owning_vendor_no_ IS NOT NULL) THEN
      newrec_.owning_vendor_no := owning_vendor_no_;
   END IF;
   IF (owning_customer_no_ IS NOT NULL) THEN
      newrec_.owning_customer_no := owning_customer_no_;
   END IF;
   IF (to_transaction_id_ IS NOT NULL) THEN
      newrec_.latest_transaction_id := to_transaction_id_;
   END IF;
   
   -- Create the new record or update the one present
   IF new_record_ = TRUE THEN
      Check_And_Insert_By_Keys___(newrec_                       => newrec_,
                                  part_catalog_rec_             => local_to_part_catalog_rec_,
                                  set_default_avail_control_id_ => FALSE,
                                  validate_hu_struct_position_  => validate_hu_struct_position_);
   ELSE
      Check_And_Update_By_Keys___(oldrec_                        => torec_,
                                  newrec_                        => newrec_,
                                  part_catalog_rec_              => local_to_part_catalog_rec_,
                                  set_default_avail_control_id_  => FALSE,
                                  validate_hu_struct_position_   => validate_hu_struct_position_);
   END IF;
   IF (contract_ != to_contract_)  THEN
      Inventory_Part_Barcode_API.Copy(from_contract_       => contract_,            
                                      to_contract_         => to_contract_,
                                      to_eng_chg_level_    => to_eng_chg_level_,
                                      part_no_             => part_no_,             
                                      configuration_id_    => configuration_id_,   
                                      lot_batch_no_        => lot_batch_no_,        
                                      serial_no_           => serial_no_,           
                                      eng_chg_level_       => eng_chg_level_,       
                                      waiv_dev_rej_no_     => waiv_dev_rej_no_,     
                                      activity_seq_        => activity_seq_);
   END IF;
END Move_Part_Impl___;


-- Validate_Rotable_Part_Pool___
--   Validates updates when part is added to a Rotable Part Pool
PROCEDURE Validate_Rotable_Part_Pool___ (
   newrec_  IN INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   oldrec_  IN INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   partrec_ IN Part_Catalog_API.Public_Rec)
IS
   poolrec_    Rotable_Part_Pool_API.Public_Rec;
   serialrec_  Part_Serial_Catalog_API.Public_Rec;
   invpartrec_ Inventory_Part_API.Public_Rec;
BEGIN
   -- Adding to a rotable part pool
   IF oldrec_.rotable_part_pool_id IS NULL AND
      newrec_.rotable_part_pool_id IS NOT NULL THEN

      poolrec_ := Rotable_Part_Pool_API.Get(newrec_.rotable_part_pool_id);

      -- IF part_no is different, check if alternative
      IF (newrec_.part_no != poolrec_.part_no) THEN
         IF (Part_Catalog_Alternative_API.Is_The_Part_Legal(poolrec_.part_no, newrec_.part_no) = db_false_) THEN
            Error_SYS.Record_General('InventoryPartInStock', 'INVALIDPART: Invalid part or alternative part');
         END IF;
      END IF;

      IF (partrec_.serial_tracking_code = db_not_serial_tracking_) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'NOTSERIALTRACKING: Only parts with Inventory Serial Tracking can be used for Rotable pools.');
      END IF;

      IF partrec_.position_part = 'POSITION PART' THEN
         Error_SYS.Record_General('InventoryPartInStock', 'POSITIONPART: Position parts can not be used for Rotable Part Pool.');
      END IF;

      serialrec_ := Part_Serial_Catalog_API.Get(newrec_.part_no, newrec_.serial_no);

      IF (poolrec_.part_ownership != serialrec_.part_ownership) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'INVALIDOWNERSHIP: Part ownership does not match with Rotable Part Pool.');
      END IF;

      IF (poolrec_.part_ownership = 'CUSTOMER OWNED') THEN
         IF (poolrec_.owning_customer_no != serialrec_.owning_customer_no) THEN
            Error_SYS.Record_General('InventoryPartInStock', 'INVALIDOWNER: Part owner does not match with Rotable Part Pool.');
         END IF;
      END IF;

      IF Inventory_Location_API.Get_Location_Type_Db(newrec_.contract, newrec_.location_no)
         NOT IN (Inventory_Location_Type_API.DB_PICKING,
                 Inventory_Location_Type_API.DB_FLOOR_STOCK,
                 Inventory_Location_Type_API.DB_PRODUCTION_LINE) THEN
            Error_SYS.Record_General('InventoryPartInStock', 'INVALIDLOCATION: Invalid Location Type for Rotable Part Pool.');
      END IF;

      IF Get_Rotable_Part_Pool_Qty(newrec_.rotable_part_pool_id) >= poolrec_.target_qty THEN
         Error_SYS.Record_General('InventoryPartInStock', 'POOLFULL: Adding the selected serials would exceed the target pool quantity.');
      END IF;

      -- Check if availability control matches
      IF (nvl(newrec_.availability_control_id, 'DuMmY1') != nvl(poolrec_.availability_control_id, 'DuMmY1')) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'INVALIDPAC: Availability Control does not match Default Availability Control (:P1) for Rotable Part Pool :P2.', poolrec_.availability_control_id, newrec_.rotable_part_pool_id );
      END IF;

      -- Specific validations for FA pools
      IF poolrec_.rotable_pool_asset_type = 'FIXED ASSET' THEN

         invpartrec_ := Inventory_Part_API.Get(newrec_.contract, newrec_.part_no);

         IF invpartrec_.inventory_valuation_method != 'ST' THEN
            Error_SYS.Record_General('InventoryPartInStock', 'NOTSTVALUATION: Inventory valuation method should be Standard Cost for FA Rotable Pool');
         END IF;

         IF invpartrec_.inventory_part_cost_level != 'COST PER SERIAL' THEN
            Error_SYS.Record_General('InventoryPartInStock', 'NOTCOSTPERSERIAL: Costing method should be Cost Per Serial for FA Rotable Pool');
         END IF;
      END IF;
   -- Already in a rotable pool
   ELSIF oldrec_.rotable_part_pool_id IS NOT NULL AND
         newrec_.rotable_part_pool_id IS NOT NULL THEN

      IF (nvl(newrec_.rotable_part_pool_id, 'DuMmY1') != nvl(oldrec_.rotable_part_pool_id, 'DuMmY1')) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'ALREADYINPOOL: Part is already in Rotable Part Pool :P1', oldrec_.rotable_part_pool_id);
      END IF;

      IF (nvl(newrec_.availability_control_id, 'DuMmY1') != nvl(oldrec_.availability_control_id, 'DuMmY1')) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'INAROTABLEPOOL: Part availability control ID can not be modified while part is in Rotable part pool :P1', oldrec_.rotable_part_pool_id);
      END IF;

      IF (newrec_.qty_onhand      != oldrec_.qty_onhand)     OR
          (newrec_.qty_in_transit != oldrec_.qty_in_transit) OR
          (newrec_.qty_reserved   != oldrec_.qty_reserved)   THEN
         Error_SYS.Record_General('InventoryPartInStock', 'INROTPOOL: Quantity cannot be modified since part is connected to Rotable Part Pool :P1', newrec_.rotable_part_pool_id);
      END IF;
   END IF;
END Validate_Rotable_Part_Pool___;


PROCEDURE Check_Catch_Unit_Update___ (
   newrec_           IN OUT INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   oldrec_           IN     INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   part_catalog_rec_ IN     Part_Catalog_API.Public_Rec,
   counting_result_  IN     BOOLEAN )
IS
BEGIN
   IF (part_catalog_rec_.catch_unit_enabled = db_true_) THEN
      --Diferent validations based on the way the qty_onhand is changing
      IF (newrec_.qty_onhand < oldrec_.qty_onhand) THEN
         Check_Onhand_Decrease_Catch___(newrec_,
                                        oldrec_,
                                        counting_result_);
      ELSIF (newrec_.qty_onhand > oldrec_.qty_onhand) THEN
         Check_Onhand_Increase_Catch___(newrec_,
                                        oldrec_,
                                        counting_result_);
      ELSE
         Check_Onhand_Nochange_Catch___(newrec_,
                                        oldrec_,
                                        counting_result_);
      END IF;

      --Diferent validations based on the way the qty_in_transit is changing
      IF (newrec_.qty_in_transit < oldrec_.qty_in_transit) THEN
         Check_Transi_Decrease_Catch___(newrec_,
                                        oldrec_);
      ELSIF (newrec_.qty_in_transit > oldrec_.qty_in_transit) THEN
         Check_Transi_Increase_Catch___(newrec_,
                                        oldrec_);
      ELSE
         Check_Transi_Nochange_Catch___(newrec_,
                                        oldrec_ );
      END IF;
   ELSE
      --If the catch unit is disabled the ctch quantities are set to null
      newrec_.catch_qty_onhand     := NULL;
      newrec_.catch_qty_in_transit := NULL;
   END IF;
END Check_Catch_Unit_Update___;


PROCEDURE Check_Onhand_Increase_Catch___ (
   newrec_          IN OUT INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   oldrec_          IN     INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   counting_result_ IN     BOOLEAN )
IS
   counting_is_required_ EXCEPTION;
   exit_procedure_       EXCEPTION;
BEGIN
   IF (newrec_.catch_qty_onhand IS NULL) THEN
      --Catch Quantity On Hand from the client is NULL
      IF (oldrec_.catch_qty_onhand IS NULL) THEN
         --Catch Quantity On Hand on location is NULL
         IF (Inventory_Location_API.Arrival_Or_Quality_Location(newrec_.location_type) = db_true_) THEN
            RAISE exit_procedure_;
         ELSE
            RAISE counting_is_required_;
         END IF;
      ELSE
         IF (Inventory_Location_API.Arrival_Or_Quality_Location(newrec_.location_type) = db_true_) THEN
            IF (oldrec_.qty_onhand = 0) THEN
               RAISE exit_procedure_;
            ELSE
               -- We cannot afford to destroy existing information about catch qty
               -- even on receipt locations.
               Raise_Catch_Qty_Null_Error___(newrec_.part_no, Inventory_Part_API.Get_Catch_Unit_Meas(newrec_.contract, newrec_.part_no));
            END IF;
         ELSE
            Raise_Catch_Qty_Null_Error___(newrec_.part_no, Inventory_Part_API.Get_Catch_Unit_Meas(newrec_.contract, newrec_.part_no));
         END IF;
      END IF;
   ELSE
      -- Catch Unit On Hand from Client is not NULL
      IF (counting_result_) THEN
         IF (newrec_.catch_qty_onhand <= 0) THEN
            --User has entered 0 or a negative value as Catch Quantity as counting result
            Raise_Catch_Zero_Neg_Error___;
         END IF;
      ELSE
         IF (oldrec_.catch_qty_onhand IS NULL) THEN
            --Catch Quantity On Hand on location is NULL
            IF (Inventory_Location_API.Arrival_Or_Quality_Location(newrec_.location_type) = db_true_) THEN
               IF (oldrec_.qty_onhand != 0) THEN
                  newrec_.catch_qty_onhand := NULL;
               END IF;
               RAISE exit_procedure_;
            ELSE
               RAISE counting_is_required_;
            END IF;
         END IF;
         IF (newrec_.catch_qty_onhand <= oldrec_.catch_qty_onhand) THEN
            --User has entered 0 or a negative value as Catch Quantity
            Raise_Catch_Zero_Neg_Error___;
         END IF;
      END IF;
   END IF;
EXCEPTION
   WHEN counting_is_required_ THEN
      Error_SYS.Record_General('InventoryPartInStock', 'CATCHQTYPLSCOUNT: Catch Unit is enabled and Catch Quantity needs to be defined on the location to allow any transaction. Please perform a Counting.');
   WHEN exit_procedure_ THEN
      NULL;
END Check_Onhand_Increase_Catch___;


PROCEDURE Check_Onhand_Decrease_Catch___ (
   newrec_          IN OUT INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   oldrec_          IN     INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   counting_result_ IN     BOOLEAN )
IS
   exit_procedure_ EXCEPTION;
BEGIN
   IF (newrec_.qty_onhand = 0) THEN
      --This is a complete Issue
      IF (newrec_.catch_qty_onhand IS NULL) THEN
         --Catch Qty On Hand from client is null
         IF ((oldrec_.catch_qty_onhand IS NULL) AND
             (Stock_Location___(newrec_.location_type))) THEN
            --Catch Qty On Hand before transaction is null
            Raise_Catch_Qty_Null_Error___(newrec_.part_no, Inventory_Part_API.Get_Catch_Unit_Meas(newrec_.contract, newrec_.part_no));
         ELSE
            newrec_.catch_qty_onhand := 0;
         END IF;
      ELSE
         newrec_.catch_qty_onhand := 0;
      END IF;
   ELSE
      --This is a partial issue
      IF (newrec_.catch_qty_onhand IS NULL) THEN
         --Catch Qty from the client is NULL
         IF (Inventory_Location_API.Arrival_Or_Quality_Location(newrec_.location_type) = db_true_) THEN
            IF (oldrec_.catch_qty_onhand IS NULL) THEN
               -- Both old and new catch_qty_onhand is null. That is ok for a receipt location.
               RAISE exit_procedure_;
            ELSE
               Raise_Catch_Qty_Null_Error___(newrec_.part_no, Inventory_Part_API.Get_Catch_Unit_Meas(newrec_.contract, newrec_.part_no));
            END IF;
         ELSE
            IF (oldrec_.catch_qty_onhand IS NULL) THEN
               -- Since Catch Qty in the database was NULL before the Onhand Decrease then we should tell
               -- the user that a Counting must be performed to establish a value for Catch Qty Onhand first.
               Error_SYS.Record_General('InventoryPartInStock', 'CATCHNEEDSCOUNTING: The reduction of On Hand Qty cannot be performed since the On Hand Catch Qty is unknown. Perform Counting to establish a correct On Hand Catch Qty before proceeding.');
            ELSE
               Raise_Catch_Qty_Null_Error___(newrec_.part_no, Inventory_Part_API.Get_Catch_Unit_Meas(newrec_.contract, newrec_.part_no));
            END IF;            
         END IF;
      END IF;

      IF (counting_result_)  THEN
         IF (newrec_.catch_qty_onhand <= 0) THEN
           --User has entered 0 or a negative value as Catch Quantity as counting results
            Raise_Catch_Zero_Neg_Error___;
         END IF;
      ELSE
         IF (newrec_.catch_qty_onhand >= NVL(oldrec_.catch_qty_onhand, 0)) THEN
            --User has entered 0 or a negative value as Catch Quantity
            Raise_Catch_Zero_Neg_Error___;
         END IF;

         IF (newrec_.catch_qty_onhand <= 0) THEN
            -- Catch Qty Issued from client is greater than the catch quantity on hand before the transaction
            -- catch_qty_onhand should be set to NULL in this situation.
            newrec_.catch_qty_onhand := NULL;
         END IF;

         IF (oldrec_.catch_qty_onhand IS NULL) THEN
            -- IF the catch quantity before transaction is null it should remain as null
            -- unless this is a counting
            newrec_.catch_qty_onhand := NULL;
         END IF;
      END IF;
   END IF;
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Check_Onhand_Decrease_Catch___;


PROCEDURE Check_Onhand_Nochange_Catch___ (
   newrec_          IN OUT INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   oldrec_          IN     INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   counting_result_ IN     BOOLEAN )
IS
   number_null_ NUMBER := -999999999999;
BEGIN
   IF (NVL(newrec_.catch_qty_onhand, number_null_) !=
       NVL(oldrec_.catch_qty_onhand, number_null_)) THEN
      --Catch Qty On Hand has changed although inventory qty is not changed
      --This is only allowed during counting
      IF (NOT counting_result_) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'CATCHQTYNOCHANGE: Catch Qty On Hand can not be changed unless inventory Qty On Hand is changed.');
      END IF;
      IF (newrec_.catch_qty_onhand IS NULL) THEN
         Raise_Catch_Qty_Null_Error___(newrec_.part_no, Inventory_Part_API.Get_Catch_Unit_Meas(newrec_.contract, newrec_.part_no));
      END IF;
      IF (newrec_.catch_qty_onhand < 0) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'CATCHQTYONHANDNOTNEG: Catch Qty On Hand must not be negative.');
      END IF;
   END IF;
END Check_Onhand_Nochange_Catch___;


PROCEDURE Check_Transi_Increase_Catch___ (
   newrec_ IN OUT INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   oldrec_ IN     INVENTORY_PART_IN_STOCK_TAB%ROWTYPE )
IS
   exit_procedure_ EXCEPTION;
BEGIN
   IF (newrec_.catch_qty_in_transit IS NULL) THEN
      --Catch Qty from client is NULL
      IF (Inventory_Location_API.Arrival_Or_Quality_Location(newrec_.location_type) = db_true_) THEN
         IF (oldrec_.catch_qty_in_transit IS NULL) THEN
            RAISE exit_procedure_;
         ELSE
            IF (oldrec_.qty_in_transit = 0) THEN
               RAISE exit_procedure_;
            ELSE
               Raise_Catch_Qty_Null_Error___(newrec_.part_no, Inventory_Part_API.Get_Catch_Unit_Meas(newrec_.contract, newrec_.part_no));
            END IF;
         END IF;
      ELSE
         Raise_Catch_Qty_Null_Error___(newrec_.part_no, Inventory_Part_API.Get_Catch_Unit_Meas(newrec_.contract, newrec_.part_no));
      END IF;
   END IF;
   IF ((oldrec_.catch_qty_in_transit IS NULL) AND
      (oldrec_.qty_in_transit != 0)) THEN
      IF (Inventory_Location_API.Arrival_Or_Quality_Location(newrec_.location_type) = db_true_) THEN
            -- There was already a qty in transit with unknown catch qty.
            -- We can not calculate a new catch qty. Set to NULL.
         newrec_.catch_qty_in_transit := NULL;
         RAISE exit_procedure_;
      ELSE
         --There is already a quantity in transit without catch qty info
         --This situation must not occur since there is a validation when
         --catch unit is enabled to ensure there are no parts in transit
         Error_SYS.Record_General('InventoryPartInStock', 'CATCHQTYMISSING: Value missing for Catch Qty In Transit. Please contact System Support.');
      END IF;
   END IF;

   IF (newrec_.catch_qty_in_transit <= NVL(oldrec_.catch_qty_in_transit, 0)) THEN
      --User has entered 0 or a negative value as Catch Quantity
      Raise_Catch_Zero_Neg_Error___;
   END IF;
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Check_Transi_Increase_Catch___;


PROCEDURE Check_Transi_Decrease_Catch___ (
   newrec_ IN OUT INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   oldrec_ IN     INVENTORY_PART_IN_STOCK_TAB%ROWTYPE )
IS
   exit_procedure_ EXCEPTION;
BEGIN
   IF ((oldrec_.catch_qty_in_transit IS NULL) AND
       (oldrec_.qty_in_transit != 0)) THEN
      --There is already a quantity in transit without catch qty info
      --This situation must not occur since there is a validation when
      --catch unit is enabled to ensure there are no parts in transit
      Error_SYS.Record_General('InventoryPartInStock', 'CATCHQTYMISSING: Value missing for Catch Qty In Transit. Please contact System Support.');
   END IF;

   IF (newrec_.qty_in_transit = 0) THEN
      --This is a complete issue
      newrec_.catch_qty_in_transit :=0;
   ELSE
      --This is a partial issue
      IF (newrec_.catch_qty_in_transit IS NULL) THEN
         --Catch Qty from client is NULL
         IF (Inventory_Location_API.Arrival_Or_Quality_Location(newrec_.location_type) = db_true_) THEN
            IF (oldrec_.catch_qty_in_transit IS NULL) THEN
               -- Catch qty is null both in the database and from the client.
               -- This is OK for arrival and quality locations.
               RAISE exit_procedure_;
            ELSE
               -- We cannot afford to destroy existing catch qty information on receipt locations.
               Raise_Catch_Qty_Null_Error___(newrec_.part_no, Inventory_Part_API.Get_Catch_Unit_Meas(newrec_.contract, newrec_.part_no));
            END IF;
         ELSE
            Raise_Catch_Qty_Null_Error___(newrec_.part_no, Inventory_Part_API.Get_Catch_Unit_Meas(newrec_.contract, newrec_.part_no));
         END IF;
      END IF;
      IF (newrec_.catch_qty_in_transit >= oldrec_.catch_qty_in_transit) THEN
         --User has entered 0 or a negative value as Catch Quantity
         Raise_Catch_Zero_Neg_Error___;
      END IF;
      IF (newrec_.catch_qty_in_transit < 0) THEN
         --User Issuing more catch quantity than there in the location
         --Catch Qty should be set to 0
         newrec_.catch_qty_in_transit :=0;
      END IF;
   END IF;
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Check_Transi_Decrease_Catch___;


PROCEDURE Check_Transi_Nochange_Catch___ (
   newrec_ IN OUT INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   oldrec_ IN     INVENTORY_PART_IN_STOCK_TAB%ROWTYPE )
IS
   number_null_ NUMBER := -999999999999;
BEGIN
   IF (NVL(newrec_.catch_qty_in_transit, number_null_) !=
       NVL(oldrec_.catch_qty_in_transit, number_null_)) THEN
      Error_SYS.Record_General('InventoryPartInStock','CATCHQTYINTRNOCHANGE: Catch Quantity In Transit can not be changed unless Inventory Quantity In Transit is changed.');
   END IF;
END Check_Transi_Nochange_Catch___;


PROCEDURE Check_Catch_Unit_Insert___ (
   newrec_           IN OUT INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   part_catalog_rec_ IN     Part_Catalog_API.Public_Rec)
IS
   exit_procedure_ EXCEPTION;
BEGIN
   IF part_catalog_rec_.catch_unit_enabled = db_true_ THEN
      IF (newrec_.qty_onhand != 0) THEN
         --Quantity On hand from client is not 0
         IF (newrec_.catch_qty_onhand IS NULL) THEN
            --Catch Quantity On Hand from client is NULL
            IF (Inventory_Location_API.Arrival_Or_Quality_Location(newrec_.location_type) = db_true_) THEN
               -- Can quit the validations right here. NULL is ok for a receipt location.
               RAISE exit_procedure_;
            ELSE
               Raise_Catch_Qty_Null_Error___(newrec_.part_no, Inventory_Part_API.Get_Catch_Unit_Meas(newrec_.contract, newrec_.part_no));
            END IF;
         END IF;
         IF (newrec_.catch_qty_onhand <= 0) THEN
            --Catch Quantity On Hand from client is negative or 0
            Raise_Catch_Zero_Neg_Error___;
         END IF;
      ELSE
         --If Qty On Hand is 0 Catch Quantity On Hand is 0
         newrec_.catch_qty_onhand := 0;
      END IF;

      IF (newrec_.qty_in_transit != 0) THEN
         --Quantity In Transit from client is not 0
         IF (newrec_.catch_qty_in_transit IS NULL) THEN
            --Catch Quantity On Hand from client is NULL
            IF (Inventory_Location_API.Arrival_Or_Quality_Location(newrec_.location_type) = db_true_) THEN
               -- Can quit the validations right here. NULL is ok for a receipt location.
               RAISE exit_procedure_;
            ELSE
               Raise_Catch_Qty_Null_Error___(newrec_.part_no, Inventory_Part_API.Get_Catch_Unit_Meas(newrec_.contract, newrec_.part_no));
            END IF;
         END IF;
         IF (newrec_.catch_qty_in_transit <= 0) THEN
            --Catch Quantity In Transit from client is negative or 0
            Raise_Catch_Zero_Neg_Error___;
         END IF;
      ELSE
         --If Qty In Transit is 0 Catch Quantity In Transit is 0
         newrec_.catch_qty_in_transit := 0;
      END IF;
   ELSE
      --When Catch Unit is not enabled catch quantities are NULL
      newrec_.catch_qty_onhand     := NULL;
      newrec_.catch_qty_in_transit := NULL;
   END IF;
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Check_Catch_Unit_Insert___;


-- Stock_Location___
--   This method returns TRUE if the given location is a stock location.
FUNCTION Stock_Location___ (
   location_type_db_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   stock_location_ BOOLEAN := TRUE;
BEGIN
   IF (Inventory_Location_API.Arrival_Or_Quality_Location(location_type_db_) = db_true_) THEN
      stock_location_ := FALSE;
   END IF;
   RETURN (stock_location_);
END Stock_Location___;


-- Raise_Catch_Qty_Null_Error___
--   This raises error messages if the catch quantity is null.
PROCEDURE Raise_Catch_Qty_Null_Error___ (
   part_no_         IN VARCHAR2,
   catch_unit_code_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'CATCHQTYPLSENTER: Part :P1 uses Catch Unit :P2 and Catch Quantity must be entered.',
                            part_no_, catch_unit_code_);
END Raise_Catch_Qty_Null_Error___;


-- Raise_Catch_Zero_Neg_Error___
--   This raises an error message if the catch quantity is negative or zero.
PROCEDURE Raise_Catch_Zero_Neg_Error___
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'CATCHQTYPOSITIVE: Catch Quantity must be greater than 0.');
END Raise_Catch_Zero_Neg_Error___;


-- Validate_Mrb_Submission___
--   Validates the MRB creation.
PROCEDURE Validate_Mrb_Submission___ (
   contract_                IN VARCHAR2,
   part_no_                 IN VARCHAR2,
   configuration_id_        IN VARCHAR2,
   location_no_             IN VARCHAR2,
   lot_batch_no_            IN VARCHAR2,
   serial_no_               IN VARCHAR2,
   eng_chg_level_           IN VARCHAR2,
   waiv_dev_rej_no_         IN VARCHAR2,
   activity_seq_            IN NUMBER,
   handling_unit_id_        IN NUMBER,
   availability_control_id_ IN VARCHAR2,
   qty_onhand_              IN NUMBER )
IS
   case_exists_ VARCHAR2(5) := db_false_;   
BEGIN
   IF (qty_onhand_ <= 0) THEN
      Error_SYS.Record_General(lu_name_, 'MRBNOQUANTITY: Quantity 0 not allowed in MRB Case.');
   END IF;
   IF (availability_control_id_ IS NULL) THEN
      Error_SYS.Record_General(lu_name_, 'MRBAVAILANULL: A value is required in the Part Availability Control ID field.');
   END IF;

   $IF Component_Chmgmt_SYS.INSTALLED $THEN    
      case_exists_ := Mrb_Int_API.Exist_Connection_By_Order(contract_,
                                                            part_no_, 
                                                            location_no_, 
                                                            serial_no_, 
                                                            lot_batch_no_,
                                                            configuration_id_, 
                                                            waiv_dev_rej_no_, 
                                                            eng_chg_level_, 
                                                            activity_seq_,
                                                            handling_unit_id_);     
      IF (case_exists_ = db_true_) THEN
         Error_SYS.Record_General(lu_name_, 'OPENMRBEXIST: Open MRB case Exists for the given Part :P1 site :P2 in the Location :P3.',part_no_ ,contract_, location_no_);
      END IF;
   $END
END Validate_Mrb_Submission___;


-- New_Count_Report_Line_Tmp___
--   Insert a record into the count_report_line_tmp table.
PROCEDURE New_Count_Report_Line_Tmp___ (
   inv_list_no_            IN VARCHAR2,
   contract_               IN VARCHAR2,
   part_no_                IN VARCHAR2,
   configuration_id_       IN VARCHAR2,
   location_no_            IN VARCHAR2,
   lot_batch_no_           IN VARCHAR2,
   serial_no_              IN VARCHAR2,
   eng_chg_level_          IN VARCHAR2,
   waiv_dev_rej_no_        IN VARCHAR2,
   activity_seq_           IN NUMBER,
   handling_unit_id_       IN NUMBER,
   warehouse_route_order_  IN VARCHAR2,
   bay_route_order_        IN VARCHAR2,
   row_route_order_        IN VARCHAR2,
   tier_route_order_       IN VARCHAR2,
   bin_route_order_        IN VARCHAR2,
   qty_onhand_             IN NUMBER,
   catch_qty_onhand_       IN NUMBER )
IS
BEGIN
   INSERT
      INTO COUNTING_REPORT_LINE_TMP (
         inv_list_no,
         contract,
         part_no,
         configuration_id,
         location_no,
         lot_batch_no,
         serial_no,
         eng_chg_level,
         waiv_dev_rej_no,
         activity_seq,
         handling_unit_id,
         warehouse_route_order,
         bay_route_order,
         row_route_order,
         tier_route_order,
         bin_route_order,
         qty_onhand,
         catch_qty_onhand)
      VALUES (
         inv_list_no_,
         contract_,
         part_no_,
         configuration_id_,
         location_no_,
         lot_batch_no_,
         serial_no_,
         eng_chg_level_,
         waiv_dev_rej_no_,
         activity_seq_,
         handling_unit_id_,
         warehouse_route_order_,
         bay_route_order_,
         row_route_order_,
         tier_route_order_,
         bin_route_order_,
         qty_onhand_,
         catch_qty_onhand_);
END New_Count_Report_Line_Tmp___;


-- Create_Count_Report_Lines___
--   Create sorted count report from records in count_report_line_tmp table.
PROCEDURE Create_Count_Report_Lines___
IS
   processed_count_ NUMBER := 0;
   user_            VARCHAR2(30) := Fnd_Session_API.Get_Fnd_User;

   CURSOR count_lines IS
      SELECT inv_list_no,
             contract,
             part_no,
             configuration_id,
             location_no,
             lot_batch_no,
             serial_no,
             eng_chg_level,
             waiv_dev_rej_no,
             activity_seq,
             handling_unit_id,
             qty_onhand,
             catch_qty_onhand,
             warehouse_route_order,
             bay_route_order,
             row_route_order,
             tier_route_order,
             bin_route_order
      FROM COUNTING_REPORT_LINE_TMP
      ORDER BY contract,
               Utility_SYS.String_To_Number(warehouse_route_order),
               upper(warehouse_route_order),
               Utility_SYS.String_To_Number(bay_route_order),
               upper(decode(bay_route_order,  Warehouse_Bay_API.default_bay_id_, last_character_, bay_route_order)),
               Utility_SYS.String_To_Number(row_route_order),
               upper(decode(row_route_order,  Warehouse_Bay_Row_API.default_row_id_, last_character_, row_route_order)),
               Utility_SYS.String_To_Number(tier_route_order),
               upper(decode(tier_route_order, Warehouse_Bay_Tier_API.default_tier_id_, last_character_, tier_route_order)),
               Utility_SYS.String_To_Number(bin_route_order),
               upper(decode(bin_route_order,  Warehouse_Bay_Bin_API.default_bin_id_, last_character_, bin_route_order)),
               part_no, lot_batch_no, serial_no, handling_unit_id;
BEGIN
   Inventory_Event_Manager_API.Start_Session;
   FOR rec_ IN count_lines LOOP
      processed_count_ := processed_count_ + 1;
      Counting_Report_Line_API.New_List_Detail(rec_.inv_list_no,
                                               processed_count_,
                                               rec_.contract,
                                               rec_.part_no,
                                               rec_.configuration_id,
                                               rec_.location_no,
                                               rec_.lot_batch_no,
                                               rec_.serial_no,
                                               rec_.eng_chg_level,
                                               rec_.waiv_dev_rej_no,
                                               rec_.activity_seq,
                                               rec_.handling_unit_id,
                                               0,
                                               rec_.qty_onhand,
                                               rec_.catch_qty_onhand,
                                               user_,
                                               rec_.warehouse_route_order,
                                               rec_.bay_route_order,
                                               rec_.row_route_order,
                                               rec_.tier_route_order,
                                               rec_.bin_route_order);
   END LOOP;
   Inventory_Event_Manager_API.Finish_Session;
END Create_Count_Report_Lines___;


-- Count_Report_Line_Tmp_Exist___
--   Check if a record exists in the count_report_line_tmp table.
FUNCTION Count_Report_Line_Tmp_Exist___ (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_no_      IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER ) RETURN BOOLEAN
IS
   dummy_ NUMBER;
   CURSOR line_exists IS
      SELECT 1
      FROM   COUNTING_REPORT_LINE_TMP
      WHERE  contract         = contract_
      AND    part_no          = part_no_
      AND    configuration_id = configuration_id_
      AND    location_no      = location_no_
      AND    lot_batch_no     = lot_batch_no_
      AND    serial_no        = serial_no_
      AND    eng_chg_level    = eng_chg_level_
      AND    waiv_dev_rej_no  = waiv_dev_rej_no_
      AND    activity_seq     = activity_seq_
      AND    handling_unit_id = handling_unit_id_;
BEGIN
   OPEN line_exists;
   FETCH line_exists INTO dummy_;
   IF (line_exists%FOUND) THEN
      CLOSE line_exists;
      RETURN TRUE;
   END IF;
   CLOSE line_exists;
   RETURN FALSE;
END Count_Report_Line_Tmp_Exist___;


-- Get_End_Date___
--   Returns the end date only if the start date is realistic else returns start date.
FUNCTION Get_End_Date___ (
   calendar_id_ IN VARCHAR2,
   start_date_  IN DATE,
   duration_    IN NUMBER ) RETURN DATE
IS
   end_date_           DATE;
   last_calendar_date_ DATE := Database_Sys.last_calendar_date_;
BEGIN
   IF (start_date_ > last_calendar_date_) THEN
      end_date_ := start_date_;
   ELSE
      end_date_ := Work_Time_Calendar_API.Get_End_Date(calendar_id_, start_date_, duration_);
   END IF;
   RETURN (end_date_);
END Get_End_Date___;


-- Check_Waiv_Dev_Rej_No___
--   Validates w/d/r No for upper-case when w/d/r No is newly created or changed.
PROCEDURE Check_Waiv_Dev_Rej_No___ (
   contract_             IN VARCHAR2,
   part_no_              IN VARCHAR2,
   configuration_id_     IN VARCHAR2,
   location_no_          IN VARCHAR2,
   lot_batch_no_         IN VARCHAR2,
   serial_no_            IN VARCHAR2,
   eng_chg_level_        IN VARCHAR2,
   waiv_dev_rej_no_      IN VARCHAR2,
   activity_seq_         IN NUMBER,
   handling_unit_id_     IN NUMBER,
   check_during_receipt_ IN BOOLEAN,
   part_catalog_rec_     IN Part_Catalog_API.Public_Rec,
   location_type_db_     IN VARCHAR2,
   part_ownership_db_    IN VARCHAR2,
   owning_customer_no_   IN VARCHAR2,
   owning_vendor_no_     IN VARCHAR2 )
IS
   record_exists_       BOOLEAN;
   serial_no_for_check_ INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE;
   ownership_conflict_  BOOLEAN;
BEGIN
   IF (UPPER(NVL(waiv_dev_rej_no_,'*')) != NVL(waiv_dev_rej_no_,'*')) THEN
      IF (check_during_receipt_) THEN
         serial_no_for_check_ := Get_Serial_No_For_Stock(part_no_, serial_no_, part_catalog_rec_, location_type_db_, handling_unit_id_);

         IF (serial_no_for_check_ != serial_no_) THEN
            ownership_conflict_ := Ownership_Conflict_Exists___(contract_,
                                                                part_no_,
                                                                configuration_id_,
                                                                location_no_,
                                                                lot_batch_no_,
                                                                serial_no_for_check_,
                                                                eng_chg_level_,
                                                                waiv_dev_rej_no_,
                                                                activity_seq_,
                                                                handling_unit_id_,
                                                                part_ownership_db_,
                                                                owning_customer_no_,
                                                                owning_vendor_no_);
            IF (ownership_conflict_) THEN
               serial_no_for_check_ := serial_no_;
            END IF;
         END IF;
      ELSE
         serial_no_for_check_ := serial_no_;
      END IF;

      record_exists_ := Check_Exist___(contract_,
                                       part_no_,
                                       configuration_id_,
                                       location_no_,
                                       lot_batch_no_,
                                       serial_no_for_check_,
                                       eng_chg_level_,
                                       waiv_dev_rej_no_,
                                       activity_seq_,
                                       handling_unit_id_);
      IF NOT (record_exists_) THEN
         Error_SYS.Record_General(lu_name_,'WDRUPPERCASE: The W/D/R No number must be entered in upper-case.');
      END IF;
   END IF;
END Check_Waiv_Dev_Rej_No___;


FUNCTION Is_Internal_Transit_Deliv___ (
   source_ref_1_ IN VARCHAR2,
   source_ref_2_ IN VARCHAR2,
   source_ref_3_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   stmt_                      VARCHAR2(500);
   order_code_                VARCHAR2(20);
   internal_transit_delivery_ BOOLEAN := FALSE;
BEGIN
   stmt_ := 'BEGIN '                                                                         ||
               ':order_code := Purchase_Order_Line_Part_API.Get_Order_Code(:source_ref_1, '  ||
                                                                          ':source_ref_2, '  ||
                                                                          ':source_ref_3); ' ||
            'END; ';
      @ApproveDynamicStatement(2007-11-07,LEPESE)
   EXECUTE IMMEDIATE stmt_ USING OUT order_code_,
                                 IN  source_ref_1_,
                                 IN  source_ref_2_,
                                 IN  source_ref_3_;
   IF (order_code_ = '4') THEN
      internal_transit_delivery_ := TRUE;
   END IF;
   RETURN (internal_transit_delivery_);
END Is_Internal_Transit_Deliv___;


FUNCTION Get_Acquisition_Site___ (
   order_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   stmt_             VARCHAR2(500);
   acquisition_site_ INVENTORY_PART_IN_STOCK_TAB.contract%TYPE;
BEGIN
   stmt_ := 'DECLARE '                                                                          ||
               'order_rec_ Purchase_Order_API.Public_Rec; '                                     ||
            'BEGIN '                                                                            ||
               'order_rec_        := Purchase_Order_API.Get(:order_no); '                       ||
               ':acquisition_site := Supplier_API.Get_Acquisition_Site(order_rec_.vendor_no); ' ||
            'END; ';
      @ApproveDynamicStatement(2007-11-07,LEPESE)
   EXECUTE IMMEDIATE stmt_ USING IN  order_no_,
                                 OUT acquisition_site_;
   RETURN (acquisition_site_);
END Get_Acquisition_Site___;


FUNCTION Intersite_Intracomp_Order___ (
   contract_      IN VARCHAR2,
   order_no_      IN VARCHAR2,
   order_type_db_ IN VARCHAR2,
   vendor_no_     IN VARCHAR2 ) RETURN BOOLEAN
IS
   acquisition_site_           INVENTORY_PART_IN_STOCK_TAB.contract%TYPE;
   int_order_transit_receipt_  BOOLEAN := FALSE;   
BEGIN
   -- For order_type RMA IN parameter order_no_ contains the RMA No.
   $IF Component_Order_SYS.INSTALLED $THEN
      IF ((order_no_ IS NOT NULL) AND (order_type_db_ = 'RMA')) THEN      
         acquisition_site_ := Cust_Ord_Customer_API.Get_Acquisition_Site(Return_Material_API.Get_Customer_No(order_no_));      
      END IF;
   $END
   
   $IF Component_Purch_SYS.INSTALLED $THEN
      IF ((vendor_no_ IS NOT NULL) AND (order_type_db_ = Order_Type_API.DB_PURCHASE_ORDER)) THEN      
         acquisition_site_ := Supplier_API.Get_Acquisition_Site(vendor_no_);       
      END IF;
   $END

   $IF Component_Shipod_SYS.INSTALLED $THEN
      IF ((order_no_ IS NOT NULL) AND (order_type_db_ = Order_Type_API.DB_SHIPMENT_ORDER)) THEN      
         int_order_transit_receipt_ := (Shipment_Order_API.Is_Intersite_Intra_Company(order_no_) = db_true_);
      END IF;
   $END

   IF (acquisition_site_ IS NOT NULL) THEN
      IF (Site_API.Get_Company(contract_) = Site_API.Get_Company(acquisition_site_)) THEN
         int_order_transit_receipt_ := TRUE;
      END IF;
   END IF;

   RETURN (int_order_transit_receipt_);
END Intersite_Intracomp_Order___;


PROCEDURE Raise_Loc_Type_Serial_Error___ (
   part_no_          IN VARCHAR2,
   location_type_db_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'SERIALLOCTYPE: You must define the serial numbers when storing part :P1 on location type :P2.',
                            part_no_, Inventory_Location_type_API.Decode(location_type_db_));
END Raise_Loc_Type_Serial_Error___;


PROCEDURE Raise_Loc_Hu_Serial_Error___ (
   part_no_          IN VARCHAR2,
   location_type_db_ IN VARCHAR2,
   handling_unit_id_ IN NUMBER )
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'SERIALLOCHU: You must define the serial numbers when storing part :P1 on location type :P2 in handling unit :P3.',
                            part_no_, Inventory_Location_type_API.Decode(location_type_db_), handling_unit_id_);
END Raise_Loc_Hu_Serial_Error___;


PROCEDURE Raise_Serial_Req_Error___ (
   part_no_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'SERIALMND: A serial number must be specified for part :P1.', part_no_);      
END Raise_Serial_Req_Error___;


PROCEDURE Raise_Serial_Not_Req_Error___ (
   part_no_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'SERIALNOTMND: A serial number may not be entered for part :P1.', part_no_);
END Raise_Serial_Not_Req_Error___;


PROCEDURE Raise_Lot_Bat_Req_Error___ (
   part_no_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'LOTBATMND: A lot/batch number must be specified for part :P1.', part_no_);
END Raise_Lot_Bat_Req_Error___;


PROCEDURE Raise_Lot_Bat_Not_Req_Error___ (
   part_no_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'LOTBATNOTMND: A lot/batch number may not be entered for part :P1.', part_no_);
END Raise_Lot_Bat_Not_Req_Error___;


PROCEDURE Raise_Trf_Ownership_Error___ (
   part_ownership_db_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'TRFINVALOWNER: Transfer of ownership is not allowed for :P1 Stock.', Part_Ownership_API.Decode(part_ownership_db_));
END Raise_Trf_Ownership_Error___;

PROCEDURE Create_Empty_Stock_Record (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   location_no_      IN VARCHAR2,
   configuration_id_ IN VARCHAR2 DEFAULT '*',
   lot_batch_no_     IN VARCHAR2 DEFAULT '*',
   serial_no_        IN VARCHAR2 DEFAULT '*',
   eng_chg_level_    IN VARCHAR2 DEFAULT NULL,
   waiv_dev_rej_no_  IN VARCHAR2 DEFAULT '*',
   activity_seq_     IN NUMBER   DEFAULT 0,
   handling_unit_id_ IN NUMBER   DEFAULT 0)
IS
   latest_eng_chg_level_      inventory_part_in_stock_tab.eng_chg_level%TYPE;
   record_                    inventory_part_in_stock_tab%ROWTYPE;
   objid_                     INVENTORY_PART_IN_STOCK.objid%TYPE;
   objversion_                INVENTORY_PART_IN_STOCK.objversion%TYPE;
   indrec_                    Indicator_Rec;
   attr_                      VARCHAR2(32000);
BEGIN
   latest_eng_chg_level_ := Inventory_Part_Revision_API.Get_Latest_Eng_Chg_Level(contract_, part_no_);      
      
   record_.contract         := contract_;
   record_.part_no          := part_no_;
   record_.configuration_id := configuration_id_;
   record_.location_no      := location_no_;
   record_.lot_batch_no     := lot_batch_no_;
   record_.serial_no        := serial_no_;
   record_.eng_chg_level    := NVL(eng_chg_level_, latest_eng_chg_level_);
   record_.waiv_dev_rej_no  := waiv_dev_rej_no_;
   record_.activity_seq     := activity_seq_;
   record_.handling_unit_id := handling_unit_id_;
    
   indrec_ := Get_Indicator_Rec___(record_);
   Check_Insert___(record_, indrec_, attr_, NULL, NULL, TRUE);
   Insert___(objid_, objversion_, record_, attr_);
END Create_Empty_Stock_Record;


PROCEDURE Check_Owning_Customer_No___ (
   owning_customer_no_ IN INVENTORY_PART_IN_STOCK_TAB.owning_customer_no%TYPE )
IS   
BEGIN
   $IF Component_Order_SYS.INSTALLED $THEN
      Cust_Ord_Customer_API.Exist(owning_customer_no_);      
   $ELSE
      Error_SYS.Record_General(lu_name_, 'NOCUSTOMER: A Customer may not be specified as Owner when Customer Order is not installed.');
   $END
END Check_Owning_Customer_No___;


PROCEDURE Check_Owning_Vendor_No___ (
   owning_vendor_no_ IN INVENTORY_PART_IN_STOCK_TAB.owning_vendor_no%TYPE )
IS   
BEGIN
   $IF Component_Purch_SYS.INSTALLED $THEN
      Supplier_API.Exist(owning_vendor_no_);      
   $ELSE
      Error_SYS.Record_General(lu_name_, 'NOSUPPLIER: A Supplier may not be specified as Owner when Purchasing is not installed.');
   $END
END Check_Owning_Vendor_No___;


PROCEDURE Check_Ownership___ (
   oldrec_                     IN INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   newrec_                     IN INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   invent_valuation_method_db_ IN VARCHAR2 )
IS
   db_company_owned_        CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_COMPANY_OWNED;
   db_consignment_          CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_CONSIGNMENT;
   db_supplier_loaned_      CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_SUPPLIER_LOANED;
   db_supplier_owned_       CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_SUPPLIER_OWNED;
   db_customer_owned_       CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_CUSTOMER_OWNED;
   db_company_rental_asset_ CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_COMPANY_RENTAL_ASSET;
   db_supplier_rented_      CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_SUPPLIER_RENTED;
   stmt_                    VARCHAR2(1000);
   message_                 VARCHAR2(500);
   has_single_ownership_    VARCHAR2(10);
BEGIN
   IF ((oldrec_.qty_onhand != 0) OR (oldrec_.qty_in_transit != 0)) THEN
      IF ((NVL(newrec_.part_ownership    , string_null_) != NVL(oldrec_.part_ownership    , string_null_))   OR
          ((newrec_.part_ownership IN (db_consignment_, db_supplier_loaned_, db_supplier_owned_, db_supplier_rented_)) AND
          (NVL(newrec_.owning_vendor_no  , string_null_) != NVL(oldrec_.owning_vendor_no  , string_null_)))  OR
          ((newrec_.part_ownership = db_customer_owned_) AND
          (NVL(newrec_.owning_customer_no, string_null_) != NVL(oldrec_.owning_customer_no, string_null_)))) THEN

         IF ((oldrec_.qty_onhand                         = newrec_.qty_onhand    )  AND
             (oldrec_.qty_in_transit                     = newrec_.qty_in_transit)  AND
             (oldrec_.qty_in_transit                     = 0                     )  AND
             (oldrec_.qty_reserved                       = newrec_.qty_reserved  )  AND
             (oldrec_.qty_reserved                       = 0                     )  AND
             (NVL(oldrec_.part_ownership, string_null_)  = db_customer_owned_    )  AND
             (NVL(newrec_.part_ownership, string_null_)  = db_customer_owned_    )) THEN

            -- Ownership Transfer of existing stock from one Customer to another Customer
            stmt_ := 'BEGIN
                         Cust_Ord_Customer_API.Check_Ownership_Transfer(:owning_customer_no);
                      END;';
           @ApproveDynamicStatement(2011-05-14,maeelk)
            EXECUTE IMMEDIATE stmt_ USING IN oldrec_.owning_customer_no;

            IF oldrec_.location_type NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                             Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                             Inventory_Location_Type_API.DB_SHIPMENT,
                                             Inventory_Location_Type_API.DB_PRODUCTION_LINE) THEN
               Error_SYS.Record_General(lu_name_,'NOTINSTOCK: Transfer of ownership is only allowed for parts that have been received into a stock location.');
            END IF;

            -- Check if stock is in rotable pool
            IF (oldrec_.rotable_part_pool_id IS NOT NULL) THEN
               Raise_Rotable_Pool_Error___;
            END IF;

            -- Check Structure Ownership for serial tracked parts
            IF (oldrec_.serial_no != '*') THEN
               Inv_Part_Ownership_Manager_API.Check_Structure_Ownership__(message_,
                                                                          has_single_ownership_,
                                                                          oldrec_.part_no,
                                                                          oldrec_.lot_batch_no,
                                                                          oldrec_.serial_no,
                                                                          oldrec_.part_ownership,
                                                                          oldrec_.owning_customer_no,
                                                                          NULL,
                                                                          'NO');
               IF (has_single_ownership_ = 'FALSE') THEN
                  Error_SYS.Record_General(lu_name_,'RECEVIEDMESSAGE: :P1 .',message_);
               END IF;
            END IF;
         ELSE
            IF (NVL(newrec_.part_ownership, string_null_) != NVL(oldrec_.part_ownership, string_null_)) THEN
               Error_SYS.Record_General(lu_name_, 'OWNERSHIPMISMATCH: The quantity on the stock record is :P1. You are trying to perform a transaction with ownership :P2 on the same record.', Part_Ownership_API.Decode(oldrec_.part_ownership), Part_Ownership_API.Decode(newrec_.part_ownership));
            ELSIF (oldrec_.part_ownership IN (db_consignment_, db_supplier_loaned_, db_supplier_owned_, db_supplier_rented_)) THEN
               Error_SYS.Record_General(lu_name_, 'VENDOWNMISMATCH: The quantity on the stock record is owned by Supplier :P1. You are trying to perform a transaction on the same record with Supplier :P2 indicated as being the owner.', oldrec_.owning_vendor_no, newrec_.owning_vendor_no);
            ELSIF (oldrec_.part_ownership = db_customer_owned_) THEN
               Error_SYS.Record_General(lu_name_, 'CUSTOWNMISMATCH: The quantity on the stock record is owned by Customer :P1. You are trying to perform a transaction on the same record with Customer :P2 indicated as being the owner.', oldrec_.owning_customer_no, newrec_.owning_customer_no);
            ELSE
               Error_SYS.Record_General(lu_name_, 'OWNERSHIPERROR: There is an ownership mismatch between the stock record and the transaction.');
            END IF;
         END IF;
      END IF;
   END IF;

   IF (newrec_.qty_onhand != 0 OR newrec_.qty_in_transit != 0) THEN
     Error_SYS.Check_Not_Null(lu_name_, 'PART_OWNERSHIP', newrec_.part_ownership);
   END IF;

   IF (newrec_.part_ownership IN (db_consignment_,
                                  db_supplier_loaned_,
                                  db_supplier_owned_,
                                  db_supplier_rented_)) THEN
      IF (newrec_.owning_vendor_no IS NULL) THEN
         Error_SYS.Record_General(lu_name_, 'VENDORNEEDSVALUE: Owning Vendor No needs to have a value for :P1 stock.', Part_Ownership_API.Decode(newrec_.part_ownership));
      END IF;

      IF (newrec_.part_ownership = db_consignment_) THEN
         IF invent_valuation_method_db_ != 'ST' THEN
              Error_SYS.Record_General(lu_name_, 'INVENTORYVAL: You are not allowed to use Consignment Stock with any other Inventory Value Method than Standard Cost. Error for part :P1 in site :P2', newrec_.part_no, newrec_.contract);
         END if;
         IF (newrec_.configuration_id != '*') THEN
            -- Consignment Stock functionality is not implemented for configurations.
            Error_SYS.Record_General(lu_name_,'CONFIGUREDPART: Configured parts are not allowed to be put into :P1 stock. :P2 is a configured part.', Part_Ownership_API.Decode(newrec_.part_ownership), newrec_.part_no);
         END IF;
      END IF;

      IF (newrec_.part_ownership = db_supplier_owned_) AND (newrec_.location_type NOT IN (Inventory_Location_Type_API.DB_ARRIVAL,
                                                                                          Inventory_Location_Type_API.DB_QUALITY_ASSURANCE)) THEN
         Error_SYS.Record_General(lu_name_, 'SUPPLIEROWNED: It is not allowed to move :P1 stock in to locations other than Arrival and Quality Assurance', Part_Ownership_API.Decode(newrec_.part_ownership));
      END IF;
      
   ELSIF (newrec_.part_ownership = db_customer_owned_) THEN      
      IF (newrec_.owning_customer_no IS NULL) THEN
         Error_SYS.Record_General(lu_name_, 'CUSTOMERNEEDSVALUE: Owning Customer No needs to have a value for :P1 stock.', Part_Ownership_API.Decode(newrec_.part_ownership));
      END IF;      
   ELSIF (newrec_.part_ownership NOT IN (db_company_owned_, db_company_rental_asset_)) THEN      
      Error_SYS.Record_General(lu_name_, 'OWNERSHIPERR: Part Ownership :P1 is not supported in this operation.', Part_Ownership_API.Decode(newrec_.part_ownership));
   END IF;   
END Check_Ownership___;


PROCEDURE Undo_Consignment_Consum___ (
   transaction_id_issue_   IN NUMBER,
   transaction_id_unissue_ IN NUMBER,
   source_                 IN VARCHAR2 )
IS
   issue_trans_rec_              Inventory_Transaction_Hist_API.Public_Rec;
   unissue_trans_rec_            Inventory_Transaction_Hist_API.Public_Rec;
   connected_trans_rec_          Inventory_Transaction_Hist_API.Public_Rec;
   connected_transaction_id_tab_ Invent_Trans_Interconnect_API.Connected_Transaction_Id_Tab;
   exit_procedure_               EXCEPTION;
   reverse_cons_trans_id_        NUMBER;
   stmt_                         VARCHAR2(2000);
   qty_remaining_                NUMBER;
   qty_reversed_                 NUMBER;
BEGIN
   unissue_trans_rec_ := Inventory_Transaction_Hist_API.Get( transaction_id_unissue_ );

   IF unissue_trans_rec_.transaction_code NOT IN ('CO-INTUNIS', 'CO-SCRPCOR', 'CO-UNISS', 'CO-WOUNISS',                                                  
                                                  'CO-RPSBKFL', 'CO-UNPSHIP', 'CO-PROJREC', 'COOEUNSHIP',
                                                  'COUNSHPDIR', 'COUNSHPTRN', 'CO-WTUNISS') THEN
      RAISE exit_procedure_;
   END IF;

   stmt_ := 'BEGIN Consignment_Consumption_API.New(:PART_NO,
                                                   :CONTRACT,
                                                   :VENDOR_NO,
                                                   :CONSUMPTION_DATE,
                                                   :CONSUMED_QTY );END;';
   @ApproveDynamicStatement(2010-04-19,maeelk)
   EXECUTE IMMEDIATE stmt_
     USING IN unissue_trans_rec_.part_no,
           IN unissue_trans_rec_.contract,
           IN unissue_trans_rec_.owning_vendor_no,
           IN Site_API.Get_Site_Date(unissue_trans_rec_.contract),
           IN unissue_trans_rec_.quantity * -1;

   issue_trans_rec_ := Inventory_Transaction_Hist_API.Get(transaction_id_issue_);

   IF (Mpccom_Accounting_API.Check_Credit_Str_Code_Exist(issue_trans_rec_.accounting_id, 'M10') = 1) THEN
      Error_SYS.Record_General(lu_name_, 'NOREVCONS: Reversal of an issue is not allowed when the credit type posting account is M10.');
   END IF;

   connected_transaction_id_tab_ := Invent_Trans_Interconnect_API.Get_All_Connected_Transactions( transaction_id_issue_,
                                                                                                  'CONSIGNMENT CONSUMPTION');
   IF (connected_transaction_id_tab_.COUNT <= 0) THEN
      RAISE exit_procedure_;
   END IF;

   qty_remaining_ := unissue_trans_rec_.quantity;

   FOR i IN connected_transaction_id_tab_.FIRST..connected_transaction_id_tab_.LAST LOOP
      IF (qty_remaining_ = 0) THEN
          EXIT;
      ELSE
         connected_trans_rec_ := Inventory_Transaction_Hist_API.Get(connected_transaction_id_tab_(i));
         qty_reversed_        := connected_trans_rec_.quantity - connected_trans_rec_.qty_reversed;

         IF (qty_reversed_ > 0) THEN
            IF qty_reversed_ > qty_remaining_ THEN
               qty_reversed_ := qty_remaining_;
            END IF;

            $IF Component_Purch_SYS.INSTALLED $THEN               
               Purchase_Receipt_API.Undo_Possible_Consignment_Qty( qty_reversed_,
                                                                   connected_trans_rec_.source_ref1,
                                                                   connected_trans_rec_.source_ref2,
                                                                   connected_trans_rec_.source_ref3,
                                                                   connected_trans_rec_.source_ref4 );               
            $ELSE
               RAISE exit_procedure_;
            $END

            qty_remaining_ := qty_remaining_ - qty_reversed_;

            IF (qty_reversed_ > 0) THEN
               Inventory_Transaction_Hist_API.Reverse_Transaction( reverse_cons_trans_id_,
                                                                   'COUNSUCONS',
                                                                   NULL,
                                                                   NULL,
                                                                   qty_reversed_,
                                                                   NULL,
                                                                   connected_transaction_id_tab_(i),
                                                                   source_ );

               Inventory_Transaction_Hist_API.Set_Original_Transaction_Id(reverse_cons_trans_id_,
                                                                          connected_transaction_id_tab_(i) );

               Inventory_Transaction_Hist_API.Set_Previous_Ownership( reverse_cons_trans_id_,
                                                                      issue_trans_rec_.part_ownership,
                                                                      issue_trans_rec_.owning_customer_no,
                                                                      issue_trans_rec_.owning_vendor_no );
            END IF;
         END IF;
      END IF;
   END LOOP;

   IF qty_remaining_ > 0 THEN
      Error_SYS.Record_General(lu_name_, 'NOENOUGHQTY: The difference between the received consignment quanitity and the remaining consignment quantity is not sufficient to reverse this transaction');
   END IF;
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
   WHEN OTHERS THEN
      RAISE;
END Undo_Consignment_Consum___;


PROCEDURE Set_Correct_Owner___ (
   owning_customer_no_ IN OUT VARCHAR2,
   owning_vendor_no_   IN OUT VARCHAR2,
   part_ownership_db_  IN     VARCHAR2 )
IS
BEGIN
   -- Sets the owning_customer_no columns null when part_ownership is not customer owned.
   IF (part_ownership_db_ NOT IN  (Part_Ownership_API.DB_CUSTOMER_OWNED)) THEN
      owning_customer_no_ := NULL;
   END IF;

   -- Sets the owning_vendor_no null when part_ownership is not consignment, supplier loaned, supplier owned and supplier rented.
   IF (part_ownership_db_ NOT IN (Part_Ownership_API.DB_CONSIGNMENT,
                                  Part_Ownership_API.DB_SUPPLIER_LOANED,
                                  Part_Ownership_API.DB_SUPPLIER_OWNED,
                                  Part_Ownership_API.DB_SUPPLIER_RENTED)) THEN
      owning_vendor_no_ := NULL;
   END IF;
END Set_Correct_Owner___;


PROCEDURE Handle_Owning_Cust_Change___(
   oldrec_                       IN INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   newrec_                       IN INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   ownership_transfer_reason_id_ IN VARCHAR2)
IS
   stmt_           VARCHAR2(2000);
   company_        COMPANY_INVENT_INFO_TAB.company%TYPE;
   transaction_id_ NUMBER;
   dummy_number_   NUMBER;
BEGIN
   --Create Custumer Part Acquisition Value
   stmt_ :='BEGIN
               Cust_Part_Acq_Value_API.Transfer_Cust_Part_Acq_Value(:to_customer_no,
                                                                    :part_no,
                                                                    :serial_no,
                                                                    :lot_batch_no,
                                                                    :configuration_id,
                                                                    :contract,
                                                                    :owning_customer_no);
            END;';
   @ApproveDynamicStatement(2010-06-14,maralk)
   EXECUTE IMMEDIATE stmt_
      USING
         IN newrec_.owning_customer_no,
         IN newrec_.part_no,
         IN newrec_.serial_no,
         IN newrec_.lot_batch_no,
         IN newrec_.configuration_id,
         IN newrec_.contract,
         IN oldrec_.owning_customer_no;

   company_ := Site_API.Get_Company(newrec_.contract);

   --Create Inventory Transaction History record for transaction 'XO-TR-OUT'
   Inventory_Transaction_Hist_API.New(transaction_id_               => transaction_id_,
                                      accounting_id_                => dummy_number_,
                                      value_                        => dummy_number_,
                                      transaction_code_             => 'XO-TR-OUT',
                                      contract_                     => newrec_.contract,
                                      part_no_                      => newrec_.part_no,
                                      configuration_id_             => newrec_.configuration_id,
                                      location_no_                  => newrec_.location_no,
                                      lot_batch_no_                 => newrec_.lot_batch_no,
                                      serial_no_                    => newrec_.serial_no,
                                      waiv_dev_rej_no_              => newrec_.waiv_dev_rej_no,
                                      eng_chg_level_                => newrec_.eng_chg_level,
                                      activity_seq_                 => newrec_.activity_seq,
                                      handling_unit_id_             => newrec_.handling_unit_id,
                                      project_id_                   => NULL,
                                      source_ref1_                  => NULL,
                                      source_ref2_                  => NULL,
                                      source_ref3_                  => NULL,
                                      source_ref4_                  => NULL,
                                      source_ref5_                  => NULL,
                                      reject_code_                  => NULL,
                                      price_                        => 0,
                                      quantity_                     => newrec_.qty_onhand,
                                      qty_reversed_                 => 0,
                                      catch_quantity_               => NULL,
                                      source_                       => NULL,
                                      source_ref_type_              => NULL,
                                      owning_vendor_no_             => NULL,
                                      condition_code_               => NULL,
                                      location_group_               => NULL,
                                      part_ownership_db_            => 'CUSTOMER OWNED',
                                      owning_customer_no_           => oldrec_.owning_customer_no,
                                      ownership_transfer_reason_id_ => ownership_transfer_reason_id_);

   Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                         company_,
                                                         'N',
                                                         NULL);
                                                         
    --Create Inventory Transaction History record for transaction 'XO-TR-IN'
   Inventory_Transaction_Hist_API.New(transaction_id_               => transaction_id_,
                                      accounting_id_                => dummy_number_,
                                      value_                        => dummy_number_,
                                      transaction_code_             => 'XO-TR-IN',
                                      contract_                     => newrec_.contract,
                                      part_no_                      => newrec_.part_no,
                                      configuration_id_             => newrec_.configuration_id,
                                      location_no_                  => newrec_.location_no,
                                      lot_batch_no_                 => newrec_.lot_batch_no,
                                      serial_no_                    => newrec_.serial_no,
                                      waiv_dev_rej_no_              => newrec_.waiv_dev_rej_no,
                                      eng_chg_level_                => newrec_.eng_chg_level,
                                      activity_seq_                 => newrec_.activity_seq,
                                      handling_unit_id_             => newrec_.handling_unit_id,
                                      project_id_                   => NULL,
                                      source_ref1_                  => NULL,
                                      source_ref2_                  => NULL,
                                      source_ref3_                  => NULL,
                                      source_ref4_                  => NULL,
                                      source_ref5_                  => NULL,
                                      reject_code_                  => NULL,
                                      price_                        => 0,
                                      quantity_                     => newrec_.qty_onhand,
                                      qty_reversed_                 => 0,
                                      catch_quantity_               => NULL,
                                      source_                       => NULL,
                                      source_ref_type_              => NULL,
                                      owning_vendor_no_             => NULL,
                                      condition_code_               => NULL,
                                      location_group_               => NULL,
                                      part_ownership_db_            => 'CUSTOMER OWNED',
                                      owning_customer_no_           => newrec_.owning_customer_no,
                                      ownership_transfer_reason_id_ => ownership_transfer_reason_id_);

   Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                         company_,
                                                         'N',
                                                         NULL);
                                                         
   Inventory_Transaction_Hist_API.Set_Previous_Ownership(transaction_id_,
                                                         newrec_.part_ownership,
                                                         oldrec_.owning_customer_no,
                                                         NULL);
END Handle_Owning_Cust_Change___;


PROCEDURE Raise_Rotable_Pool_Error___
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock','INROTABLEPOOL: Transfer of ownership is not allowed for parts that are in a rotable pool.');
END Raise_Rotable_Pool_Error___;


PROCEDURE Raise_Loc_Type_Reserv_Error___ (
   location_type_db_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'NOARRIVALRES: Reservations are not allowed on location type :P1.', Inventory_Location_Type_API.Decode(location_type_db_));
END Raise_Loc_Type_Reserv_Error___;


FUNCTION Get_Part_Catalog_Rec___ (
   part_no_          IN VARCHAR2,
   part_catalog_rec_ IN Part_Catalog_API.Public_Rec ) RETURN Part_Catalog_API.Public_Rec
IS
   local_part_catalog_rec_ Part_Catalog_API.Public_Rec;
BEGIN
   IF (part_catalog_rec_.unit_code IS NULL) THEN
      -- Unit code is a mandatory attribute so if it is NULL then the complete record must be empty
      local_part_catalog_rec_ := Part_Catalog_API.Get(part_no_);
   ELSE      
      local_part_catalog_rec_ := part_catalog_rec_;
   END IF;

   RETURN (local_part_catalog_rec_);
END Get_Part_Catalog_Rec___;


PROCEDURE Remove_Empty_Tracked_Record___ (
   oldrec_           IN INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   newrec_           IN INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   part_catalog_rec_ IN Part_Catalog_API.Public_Rec,
   objid_            IN VARCHAR2,
   by_keys_          IN BOOLEAN )
IS
   local_part_catalog_rec_        Part_Catalog_API.Public_Rec;
   local_objid_                   INVENTORY_PART_IN_STOCK.OBJID%TYPE;
   objversion_                    INVENTORY_PART_IN_STOCK.OBJVERSION%TYPE; 
   unconfirmed_count_report_line_ VARCHAR2(5);
BEGIN
   IF (((newrec_.qty_onhand     != oldrec_.qty_onhand) OR
        (newrec_.qty_in_transit != oldrec_.qty_in_transit) OR
        (newrec_.freeze_flag    != oldrec_.freeze_flag)) AND
       (newrec_.qty_onhand     = 0)  AND
       (newrec_.qty_in_transit = 0)  AND
       (newrec_.freeze_flag    = Inventory_Part_Freeze_Code_API.DB_NOT_FROZEN) AND
       (newrec_.serial_no     != '*')) THEN
      local_part_catalog_rec_ := Get_Part_Catalog_Rec___(newrec_.part_no, part_catalog_rec_);

      IF ((local_part_catalog_rec_.receipt_issue_serial_track = db_true_) AND
          (local_part_catalog_rec_.serial_tracking_code       = db_not_serial_tracking_)) THEN
         unconfirmed_count_report_line_:= Counting_Report_Line_API.Check_Unconfirmed_Part_Loc(newrec_.contract,
                                                                                              newrec_.part_no,
                                                                                              newrec_.configuration_id,
                                                                                              newrec_.location_no,
                                                                                              newrec_.lot_batch_no,
                                                                                              newrec_.serial_no,
                                                                                              newrec_.eng_chg_level,
                                                                                              newrec_.waiv_dev_rej_no,
                                                                                              newrec_.activity_seq,
                                                                                              newrec_.handling_unit_id);
         IF (unconfirmed_count_report_line_ = Fnd_Boolean_API.DB_FALSE) THEN                                                                                     
            -- No need to keep this record since there will still be a record with serial_no = '*' left
            -- that indicates the latest storage location for this part.
            Check_Delete___(newrec_);
            IF (by_keys_) THEN
               Get_Id_Version_By_Keys___(local_objid_,
                                         objversion_,
                                         newrec_.contract,
                                         newrec_.part_no,
                                         newrec_.configuration_id,
                                         newrec_.location_no,
                                         newrec_.lot_batch_no,
                                         newrec_.serial_no,
                                         newrec_.eng_chg_level,
                                         newrec_.waiv_dev_rej_no,
                                         newrec_.activity_seq,
                                         newrec_.handling_unit_id);
            ELSE
               local_objid_ := objid_;
            END IF;
            Delete___(local_objid_, newrec_);
         END IF;
      END IF;
   END IF;
END Remove_Empty_Tracked_Record___;

PROCEDURE Check_And_Insert_By_Keys___ (
   newrec_                       IN OUT inventory_part_in_stock_tab%ROWTYPE,
   part_catalog_rec_             IN     Part_Catalog_API.Public_Rec DEFAULT NULL,
   check_mandatory_expire_date_  IN     BOOLEAN                     DEFAULT TRUE,
   set_default_avail_control_id_ IN     BOOLEAN                     DEFAULT TRUE,
   validate_hu_struct_position_  IN     BOOLEAN                     DEFAULT TRUE )
IS
   objid_                  INVENTORY_PART_IN_STOCK.objid%TYPE;
   objversion_             INVENTORY_PART_IN_STOCK.objversion%TYPE;
   local_part_catalog_rec_ Part_Catalog_API.Public_Rec;
   indrec_                 Indicator_Rec;
   attr_                   VARCHAR2(32000);
BEGIN
   local_part_catalog_rec_ := Get_Part_Catalog_Rec___(newrec_.part_no, part_catalog_rec_);
   indrec_ := Get_Indicator_Rec___(newrec_);

   Check_Insert___(newrec_, indrec_, attr_, local_part_catalog_rec_, check_mandatory_expire_date_);

   Insert___(objid_, objversion_, newrec_, attr_, set_default_avail_control_id_, validate_hu_struct_position_);
END Check_And_Insert_By_Keys___;

PROCEDURE Check_And_Update_By_Keys___ (
   oldrec_                       IN     INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   newrec_                       IN OUT INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   remove_unit_cost_             IN     BOOLEAN                     DEFAULT TRUE,
   counting_result_              IN     BOOLEAN                     DEFAULT FALSE,
   part_catalog_rec_             IN     Part_Catalog_API.Public_Rec DEFAULT NULL,
   set_default_avail_control_id_ IN     BOOLEAN                     DEFAULT TRUE,
   refill_this_location_         IN     BOOLEAN                     DEFAULT TRUE,
   validate_hu_struct_position_  IN     BOOLEAN                     DEFAULT TRUE,
   prevent_hu_snapshot_refresh_  IN     BOOLEAN                     DEFAULT FALSE,
   check_mandatory_expire_date_  IN     BOOLEAN                     DEFAULT TRUE,
   ownership_transfer_reason_id_ IN     VARCHAR2                    DEFAULT NULL)
IS
   objid_                  INVENTORY_PART_IN_STOCK.objid%TYPE;
   objversion_             INVENTORY_PART_IN_STOCK.objversion%TYPE;
   local_part_catalog_rec_ Part_Catalog_API.Public_Rec;
   indrec_                 Indicator_Rec;
   attr_                   VARCHAR2(32000);
BEGIN
   local_part_catalog_rec_ := Get_Part_Catalog_Rec___(oldrec_.part_no, part_catalog_rec_);
   indrec_                 := Get_Indicator_Rec___(oldrec_, newrec_);
   Check_Update___(oldrec_, newrec_, indrec_, attr_, counting_result_, part_catalog_rec_, check_mandatory_expire_date_ => check_mandatory_expire_date_);

   Update___(objid_                        => objid_,
             oldrec_                       => oldrec_,
             newrec_                       => newrec_,
             attr_                         => attr_,
             objversion_                   => objversion_,
             by_keys_                      => TRUE,
             remove_unit_cost_             => remove_unit_cost_,
             part_catalog_rec_             => part_catalog_rec_,
             set_default_avail_control_id_ => set_default_avail_control_id_,
             refill_this_location_         => refill_this_location_,
             validate_hu_struct_position_  => validate_hu_struct_position_,
             prevent_hu_snapshot_refresh_  => prevent_hu_snapshot_refresh_,
             ownership_transfer_reason_id_ => ownership_transfer_reason_id_);
END Check_And_Update_By_Keys___;


PROCEDURE Scrap_Part___ (
   catch_quantity_     IN OUT NUMBER,
   contract_           IN     VARCHAR2,
   part_no_            IN     VARCHAR2,
   configuration_id_   IN     VARCHAR2,
   location_no_        IN     VARCHAR2,
   lot_batch_no_       IN     VARCHAR2,
   serial_no_          IN     VARCHAR2,
   eng_chg_level_      IN     VARCHAR2,
   waiv_dev_rej_no_    IN     VARCHAR2,
   activity_seq_       IN     NUMBER,
   handling_unit_id_   IN     NUMBER,
   quantity_           IN     NUMBER,
   scrap_cause_        IN     VARCHAR2,
   scrap_note_         IN     VARCHAR2,
   order_no_           IN     VARCHAR2,
   release_no_         IN     VARCHAR2,
   sequence_no_        IN     VARCHAR2,
   line_item_no_       IN     VARCHAR2,
   order_type_         IN     VARCHAR2 )
IS
   newrec_              inventory_part_in_stock_tab%ROWTYPE;
   oldrec_              inventory_part_in_stock_tab%ROWTYPE;
   location_type_db_    VARCHAR2(20);
   inv_price_           NUMBER;
   transaction_id_      NUMBER;
   accounting_id_       NUMBER := 0;
   trans_value_         NUMBER := 0;
   transaction_         VARCHAR2(10);   
BEGIN
   IF (scrap_cause_ IS NOT NULL) THEN
      Scrapping_Cause_API.Exist(scrap_cause_, TRUE);
   END IF;
   inv_price_ := 0;
   -- Always 'MODIFY'
   oldrec_ := Lock_By_Keys___(contract_,
                              part_no_,
                              configuration_id_,
                              location_no_,
                              lot_batch_no_,
                              serial_no_,
                              eng_chg_level_,
                              waiv_dev_rej_no_,
                              activity_seq_,
                              handling_unit_id_);
   newrec_ := oldrec_;
   -- Check for frozen part
   IF oldrec_.freeze_flag = 'Y' THEN
      Error_SYS.Record_General(lu_name_, 'PART_IS_FROZEN: Inventory part :P1 on location :P2 is blocked for inventory transactions because of counting.', part_no_, location_no_);
   END IF;
   -- Check with part availability control for part scrap control
   IF Part_Availability_Control_API.Check_Scrap_Control(oldrec_.availability_control_id) != 'SCRAPPABLE' THEN
      Error_SYS.Record_General(lu_name_, 'AVAILCONTROLNOTSCRAP: Parts with Availability Control :P1 can not be scrapped.', oldrec_.availability_control_id);
   END IF;
   IF ((oldrec_.qty_onhand - oldrec_.qty_reserved) < quantity_) THEN
      Error_SYS.Record_General(lu_name_, 'NOTAVAILFORSCRAP: The quantity of part :P1 available for scrapping on location :P2 is :P3.', oldrec_.part_no, oldrec_.location_no, oldrec_.qty_onhand - oldrec_.qty_reserved);      
   END IF;

   location_type_db_ := Inventory_Location_API.Get_Location_Type_db(contract_, location_no_);
   IF location_type_db_ = Inventory_Location_Type_API.DB_SHIPMENT THEN
      transaction_ := 'PICKSCRAP';
   ELSE
      transaction_ := 'INVSCRAP';
   END IF;

   IF (quantity_ = oldrec_.qty_onhand) THEN
      catch_quantity_ := NVL(catch_quantity_, oldrec_.catch_qty_onhand);
   END IF;
   
   Inventory_Transaction_Hist_API.NEW (transaction_id_     => transaction_id_,
                                       accounting_id_      => accounting_id_,
                                       value_              => trans_value_,
                                       transaction_code_   => transaction_,
                                       contract_           => contract_,
                                       part_no_            => part_no_,
                                       configuration_id_   => configuration_id_,
                                       location_no_        => location_no_,
                                       lot_batch_no_       => lot_batch_no_,
                                       serial_no_          => serial_no_,
                                       waiv_dev_rej_no_    => waiv_dev_rej_no_,
                                       eng_chg_level_      => eng_chg_level_,
                                       activity_seq_       => activity_seq_,
                                       handling_unit_id_   => handling_unit_id_,
                                       project_id_         => oldrec_.project_id,
                                       source_ref1_        => order_no_,
                                       source_ref2_        => release_no_,
                                       source_ref3_        => sequence_no_,
                                       source_ref4_        => line_item_no_,
                                       source_ref5_        => NULL,
                                       reject_code_        => scrap_cause_,
                                       price_              => inv_price_,
                                       quantity_           => quantity_,
                                       qty_reversed_       => 0,
                                       catch_quantity_     => catch_quantity_,
                                       source_             => scrap_note_,
                                       source_ref_type_    => order_type_,
                                       owning_vendor_no_   => oldrec_.owning_vendor_no,
                                       part_ownership_db_  => oldrec_.part_ownership,
                                       owning_customer_no_ => oldrec_.owning_customer_no,
                                       expiration_date_    => oldrec_.expiration_date);

   newrec_.qty_onhand       := oldrec_.qty_onhand - quantity_;
   newrec_.catch_qty_onhand := oldrec_.catch_qty_onhand - catch_quantity_;
   IF (transaction_id_ IS NOT NULL) THEN
      newrec_.latest_transaction_id := transaction_id_;
   END IF;

   Check_And_Update_By_Keys___(oldrec_ => oldrec_, newrec_ => newrec_);

   Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                         Site_API.Get_Company(contract_),
                                                         'N',
                                                         NULL);

   $IF Component_Purch_SYS.INSTALLED $THEN
      IF (order_no_ IS NULL) AND (release_no_ IS NULL) AND (sequence_no_ IS NULL) AND (line_item_no_ IS NULL) THEN         
         Receive_Purchase_Order_API.Create_Consignment_Transaction(transaction_id_);                   
      ELSE        
         Receive_Purchase_Order_API.Scrap_Consignment_On_Receipt(transaction_id_);                   
      END IF;
   $END   
   
END Scrap_Part___;


FUNCTION Ownership_Conflict_Exists___ (
   contract_           IN VARCHAR2,
   part_no_            IN VARCHAR2,
   configuration_id_   IN VARCHAR2,
   location_no_        IN VARCHAR2,
   lot_batch_no_       IN VARCHAR2,
   serial_no_          IN VARCHAR2,
   eng_chg_level_      IN VARCHAR2,
   waiv_dev_rej_no_    IN VARCHAR2,
   activity_seq_       IN NUMBER,
   handling_unit_id_   IN NUMBER,
   part_ownership_db_  IN VARCHAR2,
   owning_customer_no_ IN VARCHAR2,
   owning_vendor_no_   IN VARCHAR2 ) RETURN BOOLEAN
IS
   db_consignment_            CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_CONSIGNMENT;
   db_supplier_loaned_        CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_SUPPLIER_LOANED;
   db_supplier_owned_         CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_SUPPLIER_OWNED;
   db_customer_owned_         CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_CUSTOMER_OWNED;
   db_supplier_rented_        CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_SUPPLIER_RENTED;
   ownership_conflict_exists_ BOOLEAN := FALSE;
   record_exists_             BOOLEAN;
   lu_rec_                    INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
BEGIN
   record_exists_ := Check_Exist___(contract_,
                                    part_no_,
                                    configuration_id_,
                                    location_no_,
                                    lot_batch_no_,
                                    serial_no_,
                                    eng_chg_level_,
                                    waiv_dev_rej_no_,
                                    activity_seq_,
                                    handling_unit_id_);
   IF (record_exists_) THEN
      lu_rec_ := Lock_By_Keys___(contract_,
                                 part_no_,
                                 configuration_id_,
                                 location_no_,
                                 lot_batch_no_,
                                 serial_no_,
                                 eng_chg_level_,
                                 waiv_dev_rej_no_,
                                 activity_seq_,
                                 handling_unit_id_);
                  
      IF ((lu_rec_.qty_onhand != 0) OR (lu_rec_.qty_in_transit != 0)) THEN
         IF ((NVL(part_ownership_db_ , string_null_) != NVL(lu_rec_.part_ownership    , string_null_))   OR
             ((part_ownership_db_ IN (db_consignment_, db_supplier_loaned_, db_supplier_owned_, db_supplier_rented_)) AND
             (NVL(owning_vendor_no_  , string_null_) != NVL(lu_rec_.owning_vendor_no  , string_null_)))  OR
             ((part_ownership_db_ = db_customer_owned_) AND
             (NVL(owning_customer_no_, string_null_) != NVL(lu_rec_.owning_customer_no, string_null_)))) THEN

            ownership_conflict_exists_ := TRUE;
         END IF;
      END IF;
   END IF;

   RETURN (ownership_conflict_exists_);
END Ownership_Conflict_Exists___;


PROCEDURE Refill_Other_Locations___ (
   location_type_db_        IN VARCHAR2,
   freeze_flag_db_          IN VARCHAR2,
   qty_onhand_              IN NUMBER,
   qty_reserved_            IN NUMBER,
   rotable_part_pool_id_    IN VARCHAR2,
   availability_control_id_ IN VARCHAR2,
   expiration_date_         IN DATE,
   contract_                IN VARCHAR2,
   part_no_                 IN VARCHAR2,
   location_no_             IN VARCHAR2,
   today_                   IN DATE)
IS
   last_calendar_date_ DATE := Database_Sys.last_calendar_date_;
BEGIN
   -- Below are the final checks to make sure this record is really a candidate in all aspects to refill other locations .
   IF ((Stock_Location___(location_type_db_)) AND
       (freeze_flag_db_ = 'N') AND
       ((qty_onhand_ - qty_reserved_) > 0) AND 
       (rotable_part_pool_id_ IS NULL) AND
       (Part_Availability_Control_API.Check_Part_Movement_Control(availability_control_id_) =
        Part_Movement_Control_API.DB_ALL_ALLOWED) AND
       (Part_Availability_Control_API.Check_Putaw_Zone_Refill_Source(availability_control_id_) =
        Fnd_Boolean_API.DB_TRUE) AND  
       (NVL(expiration_date_, last_calendar_date_) > today_)) THEN
      -- This record has a free quantity that can be used to refill locations with better zone ranking.
      Inventory_Refill_Manager_API.Refill_Other_Locations(contract_,
                                                          part_no_,
                                                          location_no_);
   END IF;
END Refill_Other_Locations___;


FUNCTION Check_Part_Revision_Exist___ (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   eng_chg_level_    IN NUMBER ) RETURN BOOLEAN
IS
   CURSOR check_part_rev IS
      SELECT 1
        FROM INVENTORY_PART_IN_STOCK_TAB
       WHERE part_no = part_no_
         AND contract = contract_
         AND eng_chg_level = eng_chg_level_;

   dummy_ NUMBER;
BEGIN
   OPEN check_part_rev;
   FETCH check_part_rev INTO dummy_;
   IF (check_part_rev%FOUND) THEN
      CLOSE check_part_rev;
      RETURN TRUE;
   END IF;
   CLOSE check_part_rev;
   RETURN FALSE;
END Check_Part_Revision_Exist___;


PROCEDURE Check_Quantity_Reserved___ (
   oldrec_  IN INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   newrec_  IN INVENTORY_PART_IN_STOCK_TAB%ROWTYPE )
IS
BEGIN
   IF (newrec_.qty_reserved < 0) THEN
      Raise_Qty_Neg_Error___(newrec_);
   END IF;
   IF (newrec_.qty_reserved > 0) THEN
      IF newrec_.qty_onhand < newrec_.qty_reserved THEN
         IF (newrec_.qty_onhand < NVL(oldrec_.qty_onhand, 0)) THEN
            Raise_Over_Issue_Error___(newrec_);
         ELSE
            Error_SYS.Record_General(lu_name_, 'OVERRESERVATION: The quantity reserved for part :P1 on site :P2 at location :P3 cannot be greater than the quantity on hand.', 
                                                                  newrec_.part_no, newrec_.contract, newrec_.location_no);
         END IF;
      END IF;
   END IF;
END Check_Quantity_Reserved___;

   
PROCEDURE Raise_Qty_Neg_Error___ (
   rec_  IN INVENTORY_PART_IN_STOCK_TAB%ROWTYPE )
IS
BEGIN
   Error_SYS.Record_General(lu_name_, 'RESERVEDLESSZERO: The quantity reserved for part :P1 on site :P2 at location :P3 should not be negative.', rec_.part_no, rec_.contract, rec_.location_no);
END Raise_Qty_Neg_Error___;

   
PROCEDURE Raise_Over_Issue_Error___ (
   rec_  IN INVENTORY_PART_IN_STOCK_TAB%ROWTYPE )
IS
BEGIN
   Error_SYS.Record_General(lu_name_, 'ONHLESSAVAIL: The quantity issued for part :P1 on site :P2 at location :P3 should not be greater than the available quantity.', rec_.part_no, rec_.contract, rec_.location_no);
END Raise_Over_Issue_Error___;


@Override
-- Raise_Record_Removed___
--    Raises error for: The database row is no longer present.
PROCEDURE Raise_Record_Removed___ (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_no_      IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER )
IS
BEGIN
   Raise_Record_Not_Exist___(contract_, part_no_, configuration_id_, location_no_, lot_batch_no_, serial_no_, eng_chg_level_, waiv_dev_rej_no_, activity_seq_, handling_unit_id_);
   super(contract_, part_no_, configuration_id_, location_no_, lot_batch_no_, serial_no_, eng_chg_level_, waiv_dev_rej_no_, activity_seq_, handling_unit_id_);
END Raise_Record_Removed___;


@Override
PROCEDURE Prepare_Insert___ (
   attr_ IN OUT VARCHAR2 )
IS
BEGIN
   super(attr_);
   Client_SYS.Add_To_Attr( 'COUNT_VARIANCE'       , 0, attr_);
   Client_SYS.Add_To_Attr( 'QTY_RESERVED'         , 0, attr_);
   Client_SYS.Add_To_Attr( 'QTY_IN_TRANSIT'       , 0, attr_);
   Client_SYS.Add_To_Attr( 'QTY_ONHAND'           , 0, attr_);
   Client_SYS.Add_To_Attr( 'AVG_UNIT_TRANSIT_COST', 0, attr_);
   Client_SYS.Add_To_Attr( 'FREEZE_FLAG'          , Inventory_Part_Freeze_Code_API.Decode('N'), attr_);
   Client_SYS.Add_To_Attr( 'ACTIVITY_SEQ'         , 0, attr_);
   Client_SYS.Add_To_Attr( 'HANDLING_UNIT_ID'     , 0, attr_);
END Prepare_Insert___;


@Override
PROCEDURE Insert___ (
   objid_                          OUT    VARCHAR2,
   objversion_                     OUT    VARCHAR2,
   newrec_                         IN OUT INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   attr_                           IN OUT VARCHAR2,
   set_default_avail_control_id_   IN     BOOLEAN DEFAULT TRUE,
   validate_hu_struct_position_    IN     BOOLEAN DEFAULT TRUE )
IS
   inventory_location_rec_ Inventory_Location_API.Public_Rec;
   site_date_              DATE;
BEGIN
   site_date_                 := Site_API.Get_Site_Date(newrec_.contract);
   newrec_.create_date        := trunc(site_date_);
   newrec_.last_activity_date := site_date_;

   inventory_location_rec_ := Inventory_Location_API.Get(newrec_.contract, newrec_.location_no);
   newrec_.warehouse       := inventory_location_rec_.warehouse;
   newrec_.bay_no          := inventory_location_rec_.bay_no;
   newrec_.row_no          := inventory_location_rec_.row_no;
   newrec_.tier_no         := inventory_location_rec_.tier_no;
   newrec_.bin_no          := inventory_location_rec_.bin_no;
   newrec_.expiration_date := TRUNC(newrec_.expiration_date);

   -- Sets the ownership columns null qty_onhand = 0 and qty_in_transit = 0
   IF ((newrec_.qty_onhand = 0) AND (newrec_.qty_in_transit = 0)) THEN
      newrec_.part_ownership     := NULL;
      newrec_.owning_customer_no := NULL;
      newrec_.owning_vendor_no   := NULL;
      newrec_.expiration_date    := NULL;
      IF (set_default_avail_control_id_) THEN
         newrec_.availability_control_id := NULL;
      END IF;
   ELSE
      IF ((newrec_.availability_control_id IS NULL) AND (set_default_avail_control_id_)) THEN
         newrec_.availability_control_id := Get_Default_Avail_Ctrl_Id___(newrec_.part_no,
                                                                         newrec_.serial_no,
                                                                         newrec_.lot_batch_no,
                                                                         newrec_.contract,
                                                                         newrec_.warehouse,
                                                                         newrec_.bay_no,
                                                                         newrec_.tier_no,
                                                                         newrec_.row_no,
                                                                         newrec_.bin_no);
      END IF;      
   END IF;

   -- Sets the owning_customer_no columns null when part_ownership is not customer owned.
   -- Sets the owning_vendor_no null when part_ownership is not consignment, supplier loaned and supplier owned.
   Set_Correct_Owner___(newrec_.owning_customer_no,
                        newrec_.owning_vendor_no,
                        newrec_.part_ownership);

   IF (newrec_.last_count_date IS NULL) THEN
      newrec_.last_count_date := Counting_Result_API.Get_Last_Completed_Count_Date(contract_         => newrec_.contract,
                                                                                   part_no_          => newrec_.part_no,
                                                                                   configuration_id_ => newrec_.configuration_id,
                                                                                   location_no_      => newrec_.location_no,
                                                                                   lot_batch_no_     => newrec_.lot_batch_no,
                                                                                   serial_no_        => newrec_.serial_no,
                                                                                   eng_chg_level_    => newrec_.eng_chg_level,
                                                                                   waiv_dev_rej_no_  => newrec_.waiv_dev_rej_no,
                                                                                   activity_seq_     => newrec_.activity_seq,
                                                                                   handling_unit_id_ => newrec_.handling_unit_id);
   END IF;

   super(objid_, objversion_, newrec_, attr_);

   Manage_Handling_Unit___(handling_unit_id_            => newrec_.handling_unit_id,
                           contract_                    => newrec_.contract,
                           location_no_                 => newrec_.location_no,
                           old_qty_onhand_              => 0,
                           old_qty_in_transit_          => 0,
                           old_qty_reserved_            => 0,
                           new_qty_onhand_              => newrec_.qty_onhand,
                           new_qty_in_transit_          => newrec_.qty_in_transit,
                           new_qty_reserved_            => newrec_.qty_reserved,
                           validate_structure_position_ => validate_hu_struct_position_);

   Inventory_Part_API.Set_Avail_Activity_Status(newrec_.contract, newrec_.part_no);

   Refill_Other_Locations___(newrec_.location_type,
                             newrec_.freeze_flag,
                             newrec_.qty_onhand,
                             newrec_.qty_reserved,
                             newrec_.rotable_part_pool_id,
                             newrec_.availability_control_id,
                             newrec_.expiration_date,
                             newrec_.contract,
                             newrec_.part_no,
                             newrec_.location_no,
                             TRUNC(site_date_));

   Client_SYS.Clear_Attr(attr_);
   Client_SYS.Add_To_Attr( 'QTY_ONHAND', newrec_.qty_onhand, attr_);
   Client_SYS.Add_To_Attr('LAST_ACTIVITY_DATE', newrec_.last_activity_date, attr_);
EXCEPTION
   WHEN dup_val_on_index THEN
      Error_SYS.Record_Exist(lu_name_);
END Insert___;


@Override
PROCEDURE Update___ (
   objid_                          IN     VARCHAR2,
   oldrec_                         IN     INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   newrec_                         IN OUT INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   attr_                           IN OUT VARCHAR2,
   objversion_                     IN OUT VARCHAR2,
   by_keys_                        IN     BOOLEAN                     DEFAULT FALSE,
   remove_unit_cost_               IN     BOOLEAN                     DEFAULT TRUE,
   part_catalog_rec_               IN     Part_Catalog_API.Public_Rec DEFAULT NULL,
   set_default_avail_control_id_   IN     BOOLEAN                     DEFAULT TRUE,
   refill_this_location_           IN     BOOLEAN                     DEFAULT TRUE,
   validate_hu_struct_position_    IN     BOOLEAN                     DEFAULT TRUE,
   prevent_hu_snapshot_refresh_    IN     BOOLEAN                     DEFAULT FALSE,
   ownership_transfer_reason_id_   IN     VARCHAR2                    DEFAULT NULL)
IS
   local_part_catalog_rec_ Part_Catalog_API.Public_Rec;
   today_                  DATE;
   last_calendar_date_     DATE         := Database_Sys.last_calendar_date_;
BEGIN

   newrec_.last_activity_date := Site_API.Get_Site_Date(newrec_.contract);
   today_                     := TRUNC(newrec_.last_activity_date);
   local_part_catalog_rec_    := Get_Part_Catalog_Rec___(newrec_.part_no, part_catalog_rec_);

   -- source is not relevant if there is no qty in transit
   IF ((newrec_.qty_in_transit  = 0)  AND
       (oldrec_.qty_in_transit != 0)) THEN
      newrec_.source := NULL;
   END IF;

   newrec_.expiration_date := TRUNC(newrec_.expiration_date);
   
   -- Sets the ownership columns null qty_onhand = 0 and qty_in_transit = 0
   -- expiration date is not relevant if there is no qty on hand and no qty in transit.
   IF ((newrec_.qty_onhand = 0) AND (newrec_.qty_in_transit = 0)) THEN
      newrec_.part_ownership     := NULL;
      newrec_.owning_customer_no := NULL;
      newrec_.owning_vendor_no   := NULL;
      newrec_.expiration_date    := NULL;
      IF (set_default_avail_control_id_) THEN
         newrec_.availability_control_id := NULL;
      END IF;
   ELSE
      IF ((oldrec_.qty_onhand = 0) AND (oldrec_.qty_in_transit = 0)) THEN
         IF ((newrec_.availability_control_id IS NULL) AND (set_default_avail_control_id_)) THEN

            newrec_.availability_control_id := Get_Default_Avail_Ctrl_Id___(newrec_.part_no,
                                                                            newrec_.serial_no,
                                                                            newrec_.lot_batch_no,
                                                                            newrec_.contract,
                                                                            newrec_.warehouse,
                                                                            newrec_.bay_no,
                                                                            newrec_.tier_no,
                                                                            newrec_.row_no,
                                                                            newrec_.bin_no);
         END IF;
      END IF;
   END IF;

   -- Sets the owning_customer_no columns null when part_ownership is not customer owned.
   -- Sets the owning_vendor_no null when part_ownership is not consignment, supplier loaned and supplier owned.
   Set_Correct_Owner___(newrec_.owning_customer_no,
                        newrec_.owning_vendor_no,
                        newrec_.part_ownership);

   super(objid_, oldrec_, newrec_, attr_, objversion_, by_keys_);

   Manage_Handling_Unit___(handling_unit_id_            => newrec_.handling_unit_id,
                           contract_                    => newrec_.contract,
                           location_no_                 => newrec_.location_no,
                           old_qty_onhand_              => oldrec_.qty_onhand,
                           old_qty_in_transit_          => oldrec_.qty_in_transit,
                           old_qty_reserved_            => oldrec_.qty_reserved,
                           new_qty_onhand_              => newrec_.qty_onhand,
                           new_qty_in_transit_          => newrec_.qty_in_transit,
                           new_qty_reserved_            => newrec_.qty_reserved,
                           validate_structure_position_ => validate_hu_struct_position_,
                           prevent_hu_snapshot_refresh_ => prevent_hu_snapshot_refresh_);

   IF (newrec_.qty_onhand - newrec_.qty_reserved != oldrec_.qty_onhand - oldrec_.qty_reserved) THEN
      Inventory_Part_API.Set_Avail_Activity_Status(newrec_.contract, newrec_.part_no);
   END IF;

   IF ((newrec_.qty_onhand < oldrec_.qty_onhand) AND (Stock_Location___(newrec_.location_type)) AND refill_this_location_) THEN
      Inventory_Refill_Manager_API.Refill_This_Location(newrec_.contract,
                                                        newrec_.part_no,
                                                        newrec_.location_no);
   END IF;

   IF (((newrec_.qty_onhand - newrec_.qty_reserved) > (oldrec_.qty_onhand - oldrec_.qty_reserved)) OR
       (NVL(newrec_.expiration_date, last_calendar_date_) > NVL(oldrec_.expiration_date, last_calendar_date_)) OR
       (newrec_.rotable_part_pool_id IS NULL AND oldrec_.rotable_part_pool_id IS NOT NULL) OR
       (newrec_.freeze_flag = 'N' AND oldrec_.freeze_flag = 'Y') OR
       ((Part_Availability_Control_API.Check_Part_Movement_Control(newrec_.availability_control_id) =
           Part_Movement_Control_API.DB_ALL_ALLOWED) AND 
        (Part_Availability_Control_API.Check_Part_Movement_Control(oldrec_.availability_control_id) =
           Part_Movement_Control_API.DB_NOT_ALLOWED)) OR
       ((Part_Availability_Control_API.Get_Putaway_Zone_Refill_Src_Db(newrec_.availability_control_id) =
         Fnd_Boolean_API.DB_TRUE) AND 
        (Part_Availability_Control_API.Get_Putaway_Zone_Refill_Src_Db(oldrec_.availability_control_id) =
         Fnd_Boolean_API.DB_FALSE))) THEN
      -- At least one thing has been changed in a favorable direction which changes this record into 
      -- being a candidate for serving as a refill source for a location in a better ranked zone.
      Refill_Other_Locations___(newrec_.location_type,
                                newrec_.freeze_flag,
                                newrec_.qty_onhand,
                                newrec_.qty_reserved,
                                newrec_.rotable_part_pool_id,
                                newrec_.availability_control_id,
                                newrec_.expiration_date,
                                newrec_.contract,
                                newrec_.part_no,
                                newrec_.location_no,
                                today_);
   END IF;

   Client_SYS.Add_To_Attr('QTY_IN_TRANSIT', newrec_.qty_in_transit, attr_);
   Client_SYS.Add_To_Attr('QTY_ONHAND', newrec_.qty_onhand, attr_);
   Client_SYS.Add_To_Attr('QTY_RESERVED', newrec_.qty_reserved, attr_);
   Client_SYS.Add_To_Attr('LAST_ACTIVITY_DATE', newrec_.last_activity_date, attr_);

   -- In case a change is made to the rotable_part_pool_id and the inventory part is
   -- not in a fixed asset pool, we should fire a corresponding event, notifying the
   -- subscriber.
   IF (nvl(newrec_.rotable_part_pool_id, 'DuMmY1') !=
       nvl(oldrec_.rotable_part_pool_id, 'DuMmY1')) THEN
      IF (newrec_.rotable_part_pool_id IS NULL) THEN
         IF (Rotable_Part_Pool_API.Get_Rotable_Pool_Asset_Type_Db(oldrec_.rotable_part_pool_id)
                                    = 'INVENTORY ASSET') THEN
            Invent_Event_Creation_API.Individual_Removed_From_Pool(newrec_.contract,
                                                                   oldrec_.rotable_part_pool_id,
                                                                   newrec_.part_no,
                                                                   newrec_.serial_no );
         END IF;
      ELSE
         IF (Rotable_Part_Pool_API.Get_Rotable_Pool_Asset_Type_Db(newrec_.rotable_part_pool_id)
                                    = 'INVENTORY ASSET') THEN
            Invent_Event_Creation_API.Individual_Added_To_Pool(newrec_.contract,
                                                               newrec_.rotable_part_pool_id,
                                                               newrec_.part_no,
                                                               newrec_.serial_no );
         END IF;
      END IF;
   END IF;
   
   IF (((newrec_.qty_onhand     != oldrec_.qty_onhand) OR
        (newrec_.qty_in_transit != oldrec_.qty_in_transit)) AND
       (newrec_.qty_onhand     = 0)  AND
       (newrec_.qty_in_transit = 0)  AND
       ((newrec_.lot_batch_no != '*') OR (newrec_.serial_no != '*')) AND
       (remove_unit_cost_)) THEN
         Inventory_Part_Unit_Cost_API.Remove(newrec_.contract,
                                             newrec_.part_no,
                                             newrec_.configuration_id,
                                             newrec_.lot_batch_no,
                                             newrec_.serial_no);
   END IF;

   Remove_Empty_Tracked_Record___(oldrec_, newrec_, local_part_catalog_rec_, objid_, by_keys_);
  
   IF ((oldrec_.part_ownership      = Part_Ownership_API.DB_CUSTOMER_OWNED)  AND
       (newrec_.part_ownership      = Part_Ownership_API.DB_CUSTOMER_OWNED)  AND
       (oldrec_.owning_customer_no != newrec_.owning_customer_no          )) THEN
      Handle_Owning_Cust_Change___(oldrec_, newrec_,ownership_transfer_reason_id_);     
   END IF; 
   
   IF ((newrec_.lot_batch_no != '*') AND (oldrec_.expiration_date IS NULL) AND (newrec_.expiration_date IS NOT NULL) AND (local_part_catalog_rec_.lot_tracking_code != Part_Lot_Tracking_API.DB_NOT_LOT_TRACKING)) THEN      
      Lot_Batch_Master_API.Modify_Expiration_Date(newrec_.part_no, newrec_.lot_batch_no, newrec_.expiration_date, newrec_.contract);    
   END IF; 
   
   
   
EXCEPTION
   WHEN dup_val_on_index THEN
      Error_SYS.Record_Exist(lu_name_);
END Update___;


@Override
PROCEDURE Check_Delete___ (
   remrec_ IN INVENTORY_PART_IN_STOCK_TAB%ROWTYPE )
IS
BEGIN
   IF ((remrec_.qty_onhand != 0) OR (remrec_.qty_reserved   != 0) OR (remrec_.qty_in_transit != 0)) THEN
      Error_SYS.Record_General(lu_name_, 'QTYEXISTS: A stock record for part :P1 on location :P2 on site :P3 cannot remove while quantities exist for On Hand, Reserved or In Transit.', remrec_.part_no, remrec_.location_no, remrec_.contract);
   END IF;
   IF (remrec_.freeze_flag = 'Y') THEN
      Error_SYS.Record_General(lu_name_, 'QTYFREEZED: A stock record for part :P1 on location :P2 on site :P3 is frozen for counting and cannot be removed.', remrec_.part_no, remrec_.location_no, remrec_.contract);
   END IF;
   IF (Counting_Report_Line_API.Check_Unconfirmed_Part_Loc( remrec_.contract,
                                                            remrec_.part_no,
                                                            remrec_.configuration_id,
                                                            remrec_.location_no,
                                                            remrec_.lot_batch_no,
                                                            remrec_.serial_no,
                                                            remrec_.eng_chg_level,
                                                            remrec_.waiv_dev_rej_no,
                                                            remrec_.activity_seq,
                                                            remrec_.handling_unit_id) = Fnd_Boolean_API.DB_TRUE) THEN
      Error_SYS.Record_General(lu_name_, 'UNCONFIRMEDPARTLOC: Unconfirmed count report exists for part :P1 in location :P2.', remrec_.part_no, remrec_.location_no );
   END IF;
   super(remrec_);
END Check_Delete___;


FUNCTION Get_Consumed_Hu_Quantity___ (
   available_stock_tab_ IN Available_Stock_Tab,
   avail_stock_index_   IN PLS_INTEGER,
   keys_and_qty_tab_    IN Keys_And_Qty_Tab ) RETURN NUMBER 
IS
   consumed_hu_quantity_ NUMBER := 0;
BEGIN
   IF (available_stock_tab_.COUNT > 0) THEN
      FOR i IN available_stock_tab_.FIRST..available_stock_tab_.LAST LOOP
         IF available_stock_tab_(i).homogeneous_handling_unit_id = available_stock_tab_(avail_stock_index_).homogeneous_handling_unit_id THEN
            -- We investigate if the stock content of the curren homogeneous handling unit has already been taken into account as part of
            -- another homogeneous handling unit. This happens if we have a multilevel homogeneous handling unit structure like a pallet with boxes on it.
            IF (keys_and_qty_tab_.COUNT > 0) THEN
               FOR j IN keys_and_qty_tab_.FIRST..keys_and_qty_tab_.LAST LOOP
                  IF ((available_stock_tab_(i).part_no          = keys_and_qty_tab_(j).part_no         ) AND 
                      (available_stock_tab_(i).configuration_id = keys_and_qty_tab_(j).configuration_id) AND 
                      (available_stock_tab_(i).location_no      = keys_and_qty_tab_(j).location_no     ) AND 
                      (available_stock_tab_(i).lot_batch_no     = keys_and_qty_tab_(j).lot_batch_no    ) AND 
                      (available_stock_tab_(i).serial_no        = keys_and_qty_tab_(j).serial_no       ) AND 
                      (available_stock_tab_(i).eng_chg_level    = keys_and_qty_tab_(j).eng_chg_level   ) AND 
                      (available_stock_tab_(i).waiv_dev_rej_no  = keys_and_qty_tab_(j).waiv_dev_rej_no ) AND 
                      (available_stock_tab_(i).activity_seq     = keys_and_qty_tab_(j).activity_seq    ) AND 
                      (available_stock_tab_(i).handling_unit_id = keys_and_qty_tab_(j).handling_unit_id)) THEN
                     consumed_hu_quantity_ := consumed_hu_quantity_ + keys_and_qty_tab_(j).quantity;
                     EXIT;
                  END IF;
               END LOOP;
            END IF;
         END IF;
      END LOOP;
   END IF;

   RETURN (consumed_hu_quantity_);
END Get_Consumed_Hu_Quantity___;


PROCEDURE Check_Consume_From_This_Rec___ (
   consume_from_this_homogene_hu_ IN OUT BOOLEAN,
   consume_from_this_record_      IN OUT BOOLEAN,
   prev_homogen_handling_unit_id_ IN OUT NUMBER,
   prioritize_large_handl_units_  IN     BOOLEAN,
   available_stock_tab_           IN     Available_Stock_Tab,
   avail_stock_index_             IN     PLS_INTEGER,
   qty_left_to_find_              IN     NUMBER,
   keys_and_qty_tab_              IN     Keys_And_Qty_Tab )
IS
   consumed_homogeneous_hu_qty_  NUMBER;
   available_homogeneous_hu_qty_ NUMBER;
BEGIN
   IF (prioritize_large_handl_units_) THEN
      -- In this case we have received an available_stock_tab_ from Invent_Part_Putaway_Zone_API.Get_Zone_And_Fifo_Sorted_Stock
      -- which has information about homogeneous_hu_node_qty and homogeneous_handling_unit_id so we can use that in order to 
      -- make sure that we only consume FULL homogeneous topmost node handling units.
      IF (available_stock_tab_(avail_stock_index_).handling_unit_id = 0) THEN
         -- This is an unpacked stock record, so no need to bother about any handling unit logic.
         consume_from_this_record_ := TRUE;
      ELSE
         IF (available_stock_tab_(avail_stock_index_).homogeneous_handling_unit_id = 0) THEN
            -- The full quantity of the handling unit is not available to be reserved for this demand.
            consume_from_this_record_ := FALSE;
         ELSE
            IF (available_stock_tab_(avail_stock_index_).homogeneous_handling_unit_id != prev_homogen_handling_unit_id_) THEN
               -- We need to check if some parts of this HU has already been "consumed". This can happen if we have a multilevel HU structure
               -- and some inner packaging has already been taken into account before an other packaging comes into play. Or the other way around,
               -- that we already consumed a full pallet, and now we find the same stock records but this time connected to the inner packing. 
               consumed_homogeneous_hu_qty_  := Get_Consumed_Hu_Quantity___(available_stock_tab_, avail_stock_index_, keys_and_qty_tab_);
               available_homogeneous_hu_qty_ := available_stock_tab_(avail_stock_index_).homogeneous_hu_node_qty - consumed_homogeneous_hu_qty_;

               IF ((available_homogeneous_hu_qty_ > 0) AND (available_homogeneous_hu_qty_ <= qty_left_to_find_)) THEN
                  -- This homogeneous hu seems to have a suitable qty to be picked. Some parts of it might already have been consumed but
                  -- the remaining fits the demand.
                  consume_from_this_homogene_hu_ := TRUE;
               ELSE
                  consume_from_this_homogene_hu_ := FALSE;
               END IF;
               prev_homogen_handling_unit_id_ := available_stock_tab_(avail_stock_index_).homogeneous_handling_unit_id;
            END IF;
            IF (consume_from_this_homogene_hu_) THEN
               consume_from_this_record_ := TRUE;
               IF (keys_and_qty_tab_.COUNT > 0) THEN
                  FOR i IN keys_and_qty_tab_.FIRST..keys_and_qty_tab_.LAST LOOP
                     IF ((available_stock_tab_(avail_stock_index_).part_no          = keys_and_qty_tab_(i).part_no         ) AND 
                         (available_stock_tab_(avail_stock_index_).configuration_id = keys_and_qty_tab_(i).configuration_id) AND 
                         (available_stock_tab_(avail_stock_index_).location_no      = keys_and_qty_tab_(i).location_no     ) AND 
                         (available_stock_tab_(avail_stock_index_).lot_batch_no     = keys_and_qty_tab_(i).lot_batch_no    ) AND 
                         (available_stock_tab_(avail_stock_index_).serial_no        = keys_and_qty_tab_(i).serial_no       ) AND 
                         (available_stock_tab_(avail_stock_index_).eng_chg_level    = keys_and_qty_tab_(i).eng_chg_level   ) AND 
                         (available_stock_tab_(avail_stock_index_).waiv_dev_rej_no  = keys_and_qty_tab_(i).waiv_dev_rej_no ) AND 
                         (available_stock_tab_(avail_stock_index_).activity_seq     = keys_and_qty_tab_(i).activity_seq    ) AND 
                         (available_stock_tab_(avail_stock_index_).handling_unit_id = keys_and_qty_tab_(i).handling_unit_id)) THEN
                        -- It seems like the lowest level hu has already been consumed. 
                        consume_from_this_record_ := FALSE;
                        EXIT;
                     END IF;
                  END LOOP;
               END IF;
            ELSE
               consume_from_this_record_ := FALSE;
            END IF;
         END IF;
      END IF;
   END IF;
END Check_Consume_From_This_Rec___;


-- Find_Part___
--   Find locations with a quantity available.
FUNCTION Find_Part___ (
   available_record_was_skipped_  OUT BOOLEAN,
   location_no_                   IN  VARCHAR2,
   lot_batch_no_                  IN  VARCHAR2,
   serial_no_                     IN  VARCHAR2,
   eng_chg_level_                 IN  VARCHAR2,
   waiv_dev_rej_no_               IN  VARCHAR2,
   configuration_id_              IN  VARCHAR2,
   activity_seq_                  IN  NUMBER,
   handling_unit_id_              IN  NUMBER,
   contract_                      IN  VARCHAR2,
   part_no_                       IN  VARCHAR2,
   location_type_db_              IN  VARCHAR2,
   auto_reservation_db_           IN  VARCHAR2,
   order_issue_db_                IN  VARCHAR2,
   project_id_                    IN  VARCHAR2,
   condition_code_                IN  VARCHAR2,
   part_ownership_db_             IN  VARCHAR2,
   owning_vendor_no_              IN  VARCHAR2,
   owning_customer_no_            IN  VARCHAR2,
   only_one_lot_allowed_          IN  BOOLEAN,
   many_records_allowed_          IN  BOOLEAN,
   qty_to_find_                   IN  NUMBER,
   expiration_control_date_       IN  DATE,
   include_temp_table_locs_       IN  BOOLEAN,
   warehouse_id_                  IN  VARCHAR2,
   ignore_this_avail_control_id_  IN  VARCHAR2,
   consume_partial_handling_unit_ IN  BOOLEAN,
   part_movement_control_db_      IN  VARCHAR2,
   location_group_                IN  VARCHAR2 ) RETURN Keys_And_Qty_Tab
IS
   today_                         DATE := TRUNC(Site_API.Get_Site_Date(contract_));
   char_null_                     VARCHAR2(12) := 'VARCHAR2NULL';
   keys_and_qty_tab_              Keys_And_Qty_Tab;
   index_                         PLS_INTEGER := 1;
   qty_found_                     NUMBER := 0;
   local_lot_batch_no_            INVENTORY_PART_IN_STOCK_TAB.lot_batch_no%TYPE;
   find_one_lot_with_enough_qty_  BOOLEAN;
   include_tmp_locations_         VARCHAR2(5) := db_false_;
   exclude_tmp_locations_         VARCHAR2(5) := db_false_;
   available_stock_tab_           Available_Stock_Tab;
   last_calendar_date_            DATE := Database_Sys.last_calendar_date_;
   prev_homogen_handling_unit_id_ NUMBER  := -999999999;
   consume_from_this_record_      BOOLEAN := TRUE;
   prioritize_large_handl_units_  BOOLEAN := FALSE;
   consume_from_this_homogene_hu_ BOOLEAN;
   dummy_                         NUMBER;
   -- gelr:access_ctrl_for_inv_reserv, start
   include_tmp_warehouses_        VARCHAR2(5) := db_false_;
   
   CURSOR get_warehouse_tmp IS
      SELECT 1
      FROM warehouse_id_tmp;
   -- gelr:access_ctrl_for_inv_reserv, end
   
   CURSOR get_location_tmp IS
      SELECT 1
      FROM inventory_location_tmp;

   CURSOR get_location IS
      SELECT part_no,
             location_no,         
             lot_batch_no,
             serial_no,
             eng_chg_level,
             waiv_dev_rej_no,
             configuration_id,
             activity_seq,
             handling_unit_id,
             qty_onhand - qty_reserved   qty_available,
             warehouse,
             bay_no,
             tier_no,
             row_no,
             bin_no,
             expiration_date,
             receipt_date,
             warehouse_route_order,
             bay_route_order,
             row_route_order,
             tier_route_order,
             bin_route_order,
             NULL,
             NULL
        FROM INVENTORY_PART_IN_STOCK_TOTAL ipist
       WHERE (((part_reservation_control_db     = auto_reservation_db_      OR auto_reservation_db_      IS NULL)
               AND (part_order_issue_control_db = order_issue_db_           OR order_issue_db_           IS NULL)
               AND (part_movement_control_db    = part_movement_control_db_ OR part_movement_control_db_ IS NULL))
               OR (availability_control_id      = ignore_this_avail_control_id_))         
         AND (condition_code = condition_code_ OR condition_code_ IS NULL)
         AND ((part_ownership_db  = Part_Ownership_API.DB_COMPANY_OWNED        AND part_ownership_db_ = Part_Ownership_API.DB_COMPANY_OWNED)
          OR  (part_ownership_db  = Part_Ownership_API.DB_COMPANY_OWNED        AND part_ownership_db_ = 'COMPANY OWNED NOT CONSIGNMENT')
          OR  (part_ownership_db  = Part_Ownership_API.DB_CONSIGNMENT          AND part_ownership_db_ = Part_Ownership_API.DB_COMPANY_OWNED)
          OR  (part_ownership_db  = Part_Ownership_API.DB_CONSIGNMENT          AND part_ownership_db_ = Part_Ownership_API.DB_CONSIGNMENT     AND
               owning_vendor_no   = NVL(owning_vendor_no_,char_null_))
          OR  (part_ownership_db  = Part_Ownership_API.DB_SUPPLIER_LOANED      AND part_ownership_db_ = Part_Ownership_API.DB_SUPPLIER_LOANED AND
               owning_vendor_no   = NVL(owning_vendor_no_,char_null_))
          OR  (part_ownership_db  = Part_Ownership_API.DB_CUSTOMER_OWNED       AND part_ownership_db_ = Part_Ownership_API.DB_CUSTOMER_OWNED  AND
               owning_customer_no = NVL(owning_customer_no_,char_null_))
          OR  (part_ownership_db  = Part_Ownership_API.DB_SUPPLIER_RENTED      AND part_ownership_db_ = Part_Ownership_API.DB_SUPPLIER_RENTED AND
               (owning_vendor_no_ IS NULL OR owning_vendor_no = owning_vendor_no_))
          OR  (part_ownership_db  = Part_Ownership_API.DB_COMPANY_RENTAL_ASSET AND part_ownership_db_ = Part_Ownership_API.DB_COMPANY_RENTAL_ASSET))
         AND NVL(expiration_date, last_calendar_date_) > NVL(expiration_control_date_, today_)
         AND qty_onhand - qty_reserved > 0
         AND location_type_db IN (Inventory_Location_Type_API.DB_PICKING,
                                  Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                  Inventory_Location_Type_API.DB_PRODUCTION_LINE)
         AND (location_type_db = location_type_db_   OR location_type_db_   IS NULL)
         AND (location_group   = location_group_     OR location_group_     IS NULL)
         AND (eng_chg_level    = eng_chg_level_      OR eng_chg_level_      IS NULL)
         AND (serial_no        = serial_no_          OR serial_no_          IS NULL)
         AND (lot_batch_no NOT IN (SELECT tmp1.lot_batch_no FROM disqualified_lot_batch_no_tmp tmp1))
         AND (lot_batch_no     = local_lot_batch_no_ OR local_lot_batch_no_ IS NULL)
         AND ((location_no     IN (SELECT tmp2.location_no FROM inventory_location_tmp tmp2)) OR (include_tmp_locations_ = db_false_))
         AND ((location_no NOT IN (SELECT tmp2.location_no FROM inventory_location_tmp tmp2)) OR (exclude_tmp_locations_ = db_false_))
         AND (location_no      = location_no_        OR location_no_        IS NULL)
         AND ((warehouse       IN (SELECT tmp3.warehouse_id FROM warehouse_id_tmp tmp3)) OR (include_tmp_warehouses_ = db_false_))
         AND (warehouse        = warehouse_id_       OR warehouse_id_       IS NULL)         
         AND (waiv_dev_rej_no  = waiv_dev_rej_no_    OR waiv_dev_rej_no_    IS NULL)
         AND (configuration_id = configuration_id_   OR configuration_id_   IS NULL)
         AND (activity_seq     = activity_seq_       OR activity_seq_       IS NULL)
         AND (handling_unit_id = handling_unit_id_   OR handling_unit_id_   IS NULL)
         AND (NVL(project_id, char_null_) = NVL(project_id_, char_null_) OR activity_seq_ IS NOT NULL)
         AND part_no           = part_no_
         AND contract          = contract_
         AND NOT EXISTS (SELECT 1
                           FROM inventory_part_in_stock_tmp tmp3
                          WHERE tmp3.contract         = ipist.contract
                            AND tmp3.part_no          = ipist.part_no
                            AND tmp3.configuration_id = ipist.configuration_id
                            AND tmp3.location_no      = ipist.location_no
                            AND tmp3.lot_batch_no     = ipist.lot_batch_no
                            AND tmp3.serial_no        = ipist.serial_no
                            AND tmp3.eng_chg_level    = ipist.eng_chg_level
                            AND tmp3.waiv_dev_rej_no  = ipist.waiv_dev_rej_no
                            AND tmp3.activity_seq     = ipist.activity_seq
                            AND tmp3.handling_unit_id = ipist.handling_unit_id)
      ORDER BY location_no, handling_unit_id;
BEGIN
   local_lot_batch_no_           := lot_batch_no_;
   available_record_was_skipped_ := FALSE;

   DELETE FROM disqualified_lot_batch_no_tmp;
  
   -- gelr:access_ctrl_for_inv_reserv, start
   OPEN get_warehouse_tmp;
   FETCH get_warehouse_tmp INTO dummy_;
      IF get_warehouse_tmp%FOUND THEN
         include_tmp_warehouses_ := db_true_;
      END IF;
   CLOSE get_warehouse_tmp;
   -- gelr:access_ctrl_for_inv_reserv, end

   OPEN get_location_tmp;
   FETCH get_location_tmp INTO dummy_;
      IF get_location_tmp%FOUND THEN
         IF (include_temp_table_locs_) THEN
            include_tmp_locations_ := db_true_;
         ELSE
            exclude_tmp_locations_ := db_true_;
         END IF;
      END IF;
   CLOSE get_location_tmp;

   IF ((only_one_lot_allowed_) AND
       (many_records_allowed_) AND
       (lot_batch_no_ IS NULL) AND
       (qty_to_find_ IS NOT NULL)) THEN
      find_one_lot_with_enough_qty_ := TRUE;
   ELSE
      find_one_lot_with_enough_qty_ := FALSE;
   END IF;

   IF (((auto_reservation_db_      = Part_Reservation_Control_API.DB_AUTO_RESERVATION) OR
        (part_movement_control_db_ = Part_Movement_Control_API.DB_ALL_ALLOWED        ) OR
        (order_issue_db_           = Part_Order_Issue_Control_API.DB_ORDER_ISSUE     )) AND 
       (many_records_allowed_) AND (NOT consume_partial_handling_unit_) AND (qty_to_find_ IS NOT NULL)) THEN
      IF (Site_Invent_Info_API.Get_Auto_Reserve_Hu_Optim_Db(contract_) = Fnd_Boolean_API.DB_TRUE) THEN
         -- Since we are in an automatic reservation context and we have a qty to find and many records should be returned
         -- then we should find available stock records in a way that optimizes the usage of handling units. If consume_partial_handling_unit_
         -- is TRUE then it means we are in the second attempt, where we need to break handling units and pick individual items out of a HU.
         prioritize_large_handl_units_ := TRUE; 
      END IF;
   END IF;

   IF (find_one_lot_with_enough_qty_) THEN
      LOOP
         OPEN  get_location;
         FETCH get_location BULK COLLECT INTO available_stock_tab_;
         CLOSE get_location;

         IF (available_stock_tab_.COUNT = 0) THEN
            EXIT;
         END IF;

         available_stock_tab_ := Invent_Part_Putaway_Zone_API.Get_Zone_And_Fifo_Sorted_Stock(contract_,
                                                                                             part_no_,
                                                                                             available_stock_tab_,
                                                                                             prioritize_large_handl_units_,
                                                                                             consume_partial_handling_unit_,
                                                                                             qty_to_find_);
         local_lot_batch_no_ := available_stock_tab_(1).lot_batch_no;

         OPEN  get_location;
         FETCH get_location BULK COLLECT INTO available_stock_tab_;
         CLOSE get_location;

         available_stock_tab_ := Invent_Part_Putaway_Zone_API.Get_Zone_And_Fifo_Sorted_Stock(contract_,
                                                                                             part_no_,
                                                                                             available_stock_tab_,
                                                                                             prioritize_large_handl_units_,
                                                                                             consume_partial_handling_unit_,
                                                                                             qty_to_find_);
         qty_found_ := 0;

         IF (available_stock_tab_.COUNT > 0) THEN
            FOR i IN available_stock_tab_.FIRST..available_stock_tab_.LAST LOOP

               Check_Consume_From_This_Rec___(consume_from_this_homogene_hu_,
                                              consume_from_this_record_,
                                              prev_homogen_handling_unit_id_,
                                              prioritize_large_handl_units_,
                                              available_stock_tab_,
                                              i,
                                              qty_to_find_ - qty_found_,
                                              keys_and_qty_tab_);

               IF (consume_from_this_record_) THEN
                  keys_and_qty_tab_(index_).contract         := contract_;
                  keys_and_qty_tab_(index_).part_no          := part_no_;
                  keys_and_qty_tab_(index_).configuration_id := available_stock_tab_(i).configuration_id;
                  keys_and_qty_tab_(index_).location_no      := available_stock_tab_(i).location_no;
                  keys_and_qty_tab_(index_).lot_batch_no     := available_stock_tab_(i).lot_batch_no;
                  keys_and_qty_tab_(index_).serial_no        := available_stock_tab_(i).serial_no;
                  keys_and_qty_tab_(index_).eng_chg_level    := available_stock_tab_(i).eng_chg_level;
                  keys_and_qty_tab_(index_).waiv_dev_rej_no  := available_stock_tab_(i).waiv_dev_rej_no;
                  keys_and_qty_tab_(index_).activity_seq     := available_stock_tab_(i).activity_seq;
                  keys_and_qty_tab_(index_).handling_unit_id := available_stock_tab_(i).handling_unit_id;
                  keys_and_qty_tab_(index_).quantity         := LEAST(available_stock_tab_(i).qty_available, (qty_to_find_ - qty_found_));

                  qty_found_ := qty_found_ + available_stock_tab_(i).qty_available;

                  EXIT WHEN (qty_found_ >= qty_to_find_);
                  index_ := index_ + 1;
               ELSE
                  available_record_was_skipped_ := TRUE;
               END IF;
            END LOOP;
         END IF;

         EXIT WHEN (qty_found_ >= qty_to_find_);

         INSERT INTO disqualified_lot_batch_no_tmp ( lot_batch_no ) VALUES (local_lot_batch_no_);
         local_lot_batch_no_ := NULL;
         keys_and_qty_tab_.DELETE;
         index_ := 1;
      END LOOP;
   ELSE
      OPEN  get_location;
      FETCH get_location BULK COLLECT INTO available_stock_tab_;
      CLOSE get_location;

      available_stock_tab_ := Invent_Part_Putaway_Zone_API.Get_Zone_And_Fifo_Sorted_Stock(contract_,
                                                                                          part_no_,
                                                                                          available_stock_tab_,
                                                                                          prioritize_large_handl_units_,
                                                                                          consume_partial_handling_unit_,
                                                                                          qty_to_find_);
      IF (available_stock_tab_.COUNT > 0) THEN
         FOR i IN available_stock_tab_.FIRST..available_stock_tab_.LAST LOOP
            
            Check_Consume_From_This_Rec___(consume_from_this_homogene_hu_,
                                           consume_from_this_record_,
                                           prev_homogen_handling_unit_id_,
                                           prioritize_large_handl_units_,
                                           available_stock_tab_,
                                           i,
                                           qty_to_find_ - qty_found_,
                                           keys_and_qty_tab_);
                                                                                 
            IF (consume_from_this_record_) THEN
               keys_and_qty_tab_(index_).contract         := contract_;
               keys_and_qty_tab_(index_).part_no          := part_no_;
               keys_and_qty_tab_(index_).configuration_id := available_stock_tab_(i).configuration_id;
               keys_and_qty_tab_(index_).location_no      := available_stock_tab_(i).location_no;
               keys_and_qty_tab_(index_).lot_batch_no     := available_stock_tab_(i).lot_batch_no;
               keys_and_qty_tab_(index_).serial_no        := available_stock_tab_(i).serial_no;
               keys_and_qty_tab_(index_).eng_chg_level    := available_stock_tab_(i).eng_chg_level;
               keys_and_qty_tab_(index_).waiv_dev_rej_no  := available_stock_tab_(i).waiv_dev_rej_no;
               keys_and_qty_tab_(index_).activity_seq     := available_stock_tab_(i).activity_seq;
               keys_and_qty_tab_(index_).handling_unit_id := available_stock_tab_(i).handling_unit_id;

               IF (qty_to_find_ IS NULL) THEN
                  keys_and_qty_tab_(index_).quantity := available_stock_tab_(i).qty_available;

                  EXIT WHEN (NOT many_records_allowed_);
               ELSE
                  keys_and_qty_tab_(index_).quantity := LEAST(available_stock_tab_(i).qty_available,
                                                              (qty_to_find_ - qty_found_));
                  qty_found_ := qty_found_ + available_stock_tab_(i).qty_available;

                  EXIT WHEN (NOT many_records_allowed_);
                  EXIT WHEN (qty_found_ >= qty_to_find_);
               END IF;

               index_ := index_ + 1;
            ELSE
               available_record_was_skipped_ := TRUE;
            END IF;
         END LOOP;
      END IF;
   END IF;

   RETURN (keys_and_qty_tab_);
END Find_Part___;


PROCEDURE Issue_Part_With_Posting___ (
   contract_            IN VARCHAR2,
   part_no_             IN VARCHAR2,
   configuration_id_    IN VARCHAR2,
   location_no_         IN VARCHAR2,
   lot_batch_no_        IN VARCHAR2,
   serial_no_           IN VARCHAR2,
   eng_chg_level_       IN VARCHAR2,
   waiv_dev_rej_no_     IN VARCHAR2,
   activity_seq_        IN NUMBER,
   handling_unit_id_    IN NUMBER,
   transaction_         IN VARCHAR2,
   quantity_            IN NUMBER,
   catch_quantity_      IN NUMBER,
   account_no_          IN VARCHAR2,
   code_b_              IN VARCHAR2,
   code_c_              IN VARCHAR2,
   code_d_              IN VARCHAR2,
   code_e_              IN VARCHAR2,
   code_f_              IN VARCHAR2,
   code_g_              IN VARCHAR2,
   code_h_              IN VARCHAR2,
   code_i_              IN VARCHAR2,
   code_j_              IN VARCHAR2,
   source_              IN VARCHAR2,
   delivery_reason_id_  IN VARCHAR2 DEFAULT NULL)
IS
   transaction_id_        NUMBER;
   pre_accounting_id_     NUMBER;
   accounting_id_         NUMBER;
   trans_value_           NUMBER;
   company_               VARCHAR2(20);
   source_identifier_     VARCHAR2(200);
   pre_posting_exist_     BOOLEAN := FALSE;
   error_desc_            VARCHAR2(2000);
   lurec_                 INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   posting_type_          VARCHAR2(4);
   catch_qty_             NUMBER;
   empty_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;   
BEGIN
   IF (transaction_ = 'COTOCRA-') THEN 
      posting_type_ := 'M259';
   ELSE   
      posting_type_ := 'M110';
   END IF;
   
   IF (activity_seq_ != 0) THEN
      Error_SYS.Record_General('InventoryPartInStock', 'ACTSEQNOTALLOW2: Direct issue is not allowed for Project Inventory parts');
   END IF;

   company_ := Site_API.Get_Company(contract_);
   lurec_   := Get_Object_By_Keys___(contract_,
                                     part_no_,
                                     configuration_id_,
                                     location_no_,
                                     lot_batch_no_,
                                     serial_no_,
                                     eng_chg_level_,
                                     waiv_dev_rej_no_,
                                     activity_seq_,
                                     handling_unit_id_);

   IF NOT (Part_Availability_Control_API.Noorder_Issue_Allowed(lurec_.availability_control_id)) THEN              
      Error_SYS.Record_General(lu_name_, 'AVAILNOTNONORDISSUE: Parts with Availability Control :P1 cannot be issued.', lurec_.availability_control_id);    
   END IF;  

   IF lurec_.location_type NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                   Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                   Inventory_Location_Type_API.DB_PRODUCTION_LINE) THEN
      Error_SYS.Record_General('InventoryPartInStock','LOCTYPER2: Direct issue of part is not allowed from location type :P1',Inventory_Location_Type_API.Decode(lurec_.location_type));
   END IF;

   catch_qty_ := catch_quantity_;
   
   Issue_Part_Impl___(transaction_id_               =>  transaction_id_,
                      accounting_id_                =>  accounting_id_,
                      trans_value_                  =>  trans_value_,
                      catch_quantity_               =>  catch_qty_,
                      contract_                     =>  contract_,
                      part_no_                      =>  part_no_,
                      configuration_id_             =>  configuration_id_,
                      location_no_                  =>  location_no_,
                      lot_batch_no_                 =>  lot_batch_no_,
                      serial_no_                    =>  serial_no_,
                      eng_chg_level_                =>  eng_chg_level_,
                      waiv_dev_rej_no_              =>  waiv_dev_rej_no_,
                      activity_seq_                 =>  activity_seq_,
                      handling_unit_id_             =>  handling_unit_id_,
                      transaction_                  =>  transaction_,
                      quantity_                     =>  quantity_,
                      quantity_reserved_            =>  0,
                      source_ref1_                  =>  NULL,
                      source_ref2_                  =>  NULL,
                      source_ref3_                  =>  NULL,
                      source_ref4_                  =>  NULL,
                      source_ref5_                  =>  NULL,
                      source_                       =>  source_,
                      unreceive_                    =>  FALSE,
                      forced_                       =>  FALSE,
                      cost_detail_tab_              =>  empty_cost_detail_tab_,
                      source_ref_type_              =>  NULL,
                      reject_code_                  =>  NULL,
                      remove_unit_cost_             =>  TRUE,
                      make_transaction_             =>  TRUE,
                      transit_location_group_       =>  NULL,
                      report_earned_value_db_       =>  NULL,
                      part_catalog_rec_             =>  NULL,
                      original_transaction_id_      =>  NULL,
                      prevent_fifo_action_          =>  FALSE,
                      ownership_transfer_reason_id_ =>  NULL,
                      delivery_reason_id_           =>  delivery_reason_id_);

   @ApproveTransactionStatement(2012-01-25,GanNLK)
   SAVEPOINT before_accounting_issue_;

   pre_accounting_id_ := Inventory_Transaction_Hist_API.Get_Pre_Accounting_Id(transaction_id_);

   IF ((account_no_  IS NOT NULL) OR
       (code_b_      IS NOT NULL) OR
       (code_c_      IS NOT NULL) OR
       (code_d_      IS NOT NULL) OR
       (code_e_      IS NOT NULL) OR
       (code_f_      IS NOT NULL) OR
       (code_g_      IS NOT NULL) OR
       (code_h_      IS NOT NULL) OR
       (code_i_      IS NOT NULL) OR
       (code_j_      IS NOT NULL)) THEN
      Pre_Accounting_API.New(pre_accounting_id_,
                             account_no_,
                             code_b_,
                             code_c_,
                             code_d_,
                             code_e_,
                             code_f_,
                             code_g_,
                             code_h_,
                             code_i_,
                             code_j_,
                             company_,
                             posting_type_,
                             contract_);
      pre_posting_exist_ := TRUE;
   END IF;
   
   IF (lurec_.part_ownership IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                 Part_Ownership_API.DB_CONSIGNMENT)) THEN
      -- Check that Pre Posting is made if it is mandatory
      -- The identifier have to be translated BEFORE it is passed on.
      source_identifier_ := Language_SYS.Translate_Constant(lu_name_, 'SOURCEIDENTIFIERISS: this issue.');
      Pre_Accounting_API.Check_Mandatory_Code_Parts(pre_accounting_id_, posting_type_, company_, source_identifier_);
   END IF;

   Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                         company_,
                                                         'N',
                                                         NULL);

   IF Mpccom_Accounting_API.Accounting_Have_Errors(accounting_id_, TRUE) AND (pre_posting_exist_) THEN

      error_desc_ := Mpccom_Accounting_API.Get_A_Pre_Posting_Error_Desc(accounting_id_);
      -- The posting was performed with errors.
      -- Check if that error depends on the pre posting or if it depends on the posting control.
      -- This is due to the fact that we would like to give an immediate response to the user
      -- before this posting is to be completed.
      @ApproveTransactionStatement(2012-01-25,GanNLK)
      ROLLBACK TO before_accounting_issue_;
      -- Do the accounting without the pre posting.
      Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                            company_,
                                                            'N',
                                                            NULL);

      -- Check if the accounting still have errors.
      IF Mpccom_Accounting_API.Accounting_Have_Errors(accounting_id_, TRUE) THEN
         -- The error depended on the posting control and we could let it pass trough
         -- the normal way, meaning it will get status_code = '99' instead of an hard error.
         -- The original posrting has to be done all over from the beginning including both
         -- ordinary posting control and pre posting.
         @ApproveTransactionStatement(2012-01-25,GanNLK)
         ROLLBACK TO before_accounting_issue_;
         Pre_Accounting_API.New(pre_accounting_id_,
                                account_no_,
                                code_b_,
                                code_c_,
                                code_d_,
                                code_e_,
                                code_f_,
                                code_g_,
                                code_h_,
                                code_i_,
                                code_j_,
                                company_,
                                posting_type_,
                                contract_);
         Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                               company_,
                                                               'N',
                                                               NULL);
      ELSE
         -- The error depended on the pre posting.
         -- An hard error is to be raised to immediately inform the user.
         -- error_desc_ is already translated.
         Raise_Pre_Posting_Not_Acc_Error___(error_desc_);
      END IF;
   END IF;

   $IF Component_Purch_SYS.INSTALLED $THEN      
      Receive_Purchase_Order_API.Create_Consignment_Transaction(transaction_id_);                
   $END 
END Issue_Part_With_Posting___;


PROCEDURE Check_Split_Into_Serials___ (
   stock_rec_ IN INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   serial_no_ IN VARCHAR2 )
IS
   part_serial_rec_   Part_Serial_Catalog_API.Public_Rec;
   
BEGIN
   Temporary_Part_Tracking_API.Validate_Serial(stock_rec_.contract, stock_rec_.part_no, serial_no_);

   IF (Invent_Part_Quantity_Util_API.Check_Individual_Exist(stock_rec_.part_no, serial_no_) = 1) THEN
      Error_SYS.Record_General(lu_name_, 'SPLITSERINV: Serial :P1 already exists on a specific stock, transit or at customer record.', stock_rec_.part_no||','||serial_no_);
   END IF;

   part_serial_rec_ := Part_Serial_Catalog_API.Get(stock_rec_.part_no, serial_no_);

   IF (part_serial_rec_.configuration_id != stock_rec_.configuration_id) THEN
      Error_SYS.Record_General(lu_name_, 'SPLITSERCONF: Serial :P1 is of Configuration :P2 while the stock record holds quantities of Configuration :P3.', stock_rec_.part_no||','||serial_no_, part_serial_rec_.configuration_id, stock_rec_.configuration_id);
   END IF;

   IF (part_serial_rec_.part_ownership = stock_rec_.part_ownership) THEN
      IF (NVL(part_serial_rec_.owning_vendor_no, string_null_) !=
          NVL(stock_rec_      .owning_vendor_no, string_null_)) THEN
         Error_SYS.Record_General(lu_name_, 'SPLITSERVENDOR: Serial :P1 is owned by supplier :P2 while the stock record holds quantities that are owned by supplier :P3.', stock_rec_.part_no||','||serial_no_, part_serial_rec_.owning_vendor_no, stock_rec_.owning_vendor_no);
      END IF;

      IF (NVL(part_serial_rec_.owning_customer_no, string_null_) !=
          NVL(stock_rec_      .owning_customer_no, string_null_)) THEN
         Error_SYS.Record_General(lu_name_, 'SPLITSERCUSTOMER: Serial :P1 is owned by customer :P2 while the stock record holds quantities that are owned by customer :P3.', stock_rec_.part_no||','||serial_no_, part_serial_rec_.owning_customer_no, stock_rec_.owning_customer_no);
      END IF;
   ELSE
      Error_SYS.Record_General(lu_name_, 'SPLITSEROWNER: Serial :P1 is :P2 while the stock record holds quantities that are :P3.', stock_rec_.part_no||','||serial_no_, Part_Ownership_API.Decode(part_serial_rec_.part_ownership), Part_Ownership_API.Decode(stock_rec_.part_ownership));
   END IF;

   IF (NVL(part_serial_rec_.lot_batch_no, stock_rec_.lot_batch_no) != stock_rec_.lot_batch_no) THEN
      Error_SYS.Record_General(lu_name_, 'SPLITSERLOT: Serial :P1 belongs to Lot/Batch :P2 while the stock record holds quantities of Lot/Batch :P3.', stock_rec_.part_no||','||serial_no_, part_serial_rec_.lot_batch_no, stock_rec_.lot_batch_no);
   END IF;
   
END Check_Split_Into_Serials___;


PROCEDURE Fill_Part_Stock_Owner_Tmp___ (
   transfer_tab_ IN Inv_Part_Ownership_Manager_API.ownership_transfer_table )
IS
   CURSOR get_part_locations IS
      SELECT DISTINCT contract, part_no, location_no, part_ownership, owning_customer_no, owning_vendor_no
        FROM inventory_part_stock_owner_tmp;
BEGIN

   IF transfer_tab_.COUNT > 0 THEN
      -- Inserting all part, location and ownership info from transfer_tab_ into a temporary tab
      -- The content of the temporary table describes the ownership situation before Receipt_In_Place.
      FORALL i IN transfer_tab_.FIRST..transfer_tab_.LAST
         INSERT
            INTO inventory_part_stock_owner_tmp(contract,
                                                part_no,
                                                location_no,
                                                part_ownership,
                                                owning_customer_no,
                                                owning_vendor_no,
                                                breaking_ownership_mix_rule)
            VALUES (transfer_tab_(i).contract,
                    transfer_tab_(i).part_no,
                    transfer_tab_(i).location_no,
                    transfer_tab_(i).part_ownership,
                    CASE transfer_tab_(i).part_ownership
                       WHEN Part_Ownership_API.DB_CUSTOMER_OWNED THEN transfer_tab_(i).owner
                       ELSE NULL END,
                    CASE transfer_tab_(i).part_ownership
                       WHEN Part_Ownership_API.DB_CONSIGNMENT     THEN transfer_tab_(i).owner
                       WHEN Part_Ownership_API.DB_SUPPLIER_LOANED THEN transfer_tab_(i).owner
                       WHEN Part_Ownership_API.DB_SUPPLIER_OWNED  THEN transfer_tab_(i).owner
                       WHEN Part_Ownership_API.DB_SUPPLIER_RENTED THEN transfer_tab_(i).owner
                       ELSE NULL END,
                    db_false_);
   END IF;

   FOR rec_ IN get_part_locations LOOP
      -- Looping over all distinct combinatons of contract, part, location and owner
      -- To check if the ownership mix validation rule has already been broken for the given
      -- inventory part and location combination. This can be the result because of reversed issues
      -- or if the Allow Ownership Mix checkbox has recently been unchecked on site level. 
      BEGIN
         Check_Allow_Ownership_Mix(contract_           => rec_.contract,
                                   part_no_            => rec_.part_no,
                                   location_no_        => rec_.location_no,
                                   part_ownership_db_  => rec_.part_ownership,
                                   owning_customer_no_ => rec_.owning_customer_no,
                                   owning_vendor_no_   => rec_.owning_vendor_no);
      EXCEPTION
         WHEN OTHERS THEN
            -- IF the Ownership Mix rule is already broken then we store information about this in
            -- the temporary table. This is important because we should not execute the "post-receipt-in-place"
            -- ownership mix validation for those part/location combinations. We cannot give the user running the
            -- Receipt In Place functionality an error message related to an already existing Ownership Mix rule violation.
            UPDATE inventory_part_stock_owner_tmp
               SET breaking_ownership_mix_rule = db_true_
               WHERE contract    = rec_.contract
                 AND part_no     = rec_.part_no
                 AND location_no = rec_.location_no;
      END;
   END LOOP;
END Fill_Part_Stock_Owner_Tmp___;


PROCEDURE Validate_Ownership_Mix___ (
   part_ownership_db_  IN VARCHAR2)   
IS
   CURSOR get_part_locations IS
      SELECT DISTINCT contract, part_no, location_no
        FROM inventory_part_stock_owner_tmp
       WHERE breaking_ownership_mix_rule = db_false_;
BEGIN
   FOR rec_ IN get_part_locations LOOP
      -- We are now selecting all the part and location combinations that did NOT have an
      -- existing violation of the Ownership Mix rul from the temporary table and perform the 
      -- Ownership Mix validation once again for these records. Since we know that the rule was not
      -- broken before the change of ownership that is done by the Receipt_In_Place/Rental_Asset_transfer
      -- methods then we should raise a hard error if transfer of ownership now has created such 
      -- an invalid situation.
      Check_Allow_Ownership_Mix(contract_           => rec_.contract,
                                part_no_            => rec_.part_no,
                                location_no_        => rec_.location_no,
                                part_ownership_db_  => part_ownership_db_,
                                owning_customer_no_ => NULL,
                                owning_vendor_no_   => NULL);
   END LOOP;
END Validate_Ownership_Mix___;


PROCEDURE Putaway___ (
   info_               OUT VARCHAR2,
   contract_           IN  VARCHAR2,
   part_no_            IN  VARCHAR2,
   configuration_id_   IN  VARCHAR2,
   location_no_        IN  VARCHAR2,
   lot_batch_no_       IN  VARCHAR2,
   serial_no_tab_      IN  Part_Serial_Catalog_API.Serial_No_Tab,
   eng_chg_level_      IN  VARCHAR2,
   waiv_dev_rej_no_    IN  VARCHAR2,
   activity_seq_       IN  NUMBER,
   handling_unit_id_   IN  NUMBER, 
   calling_process_    IN  VARCHAR2,
   to_warehouse_id_    IN  VARCHAR2 DEFAULT NULL,
   to_bay_id_          IN  VARCHAR2 DEFAULT NULL )
IS
   part_rec_            INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   quantity_            NUMBER;
   number_of_serials_   NUMBER;
   local_serial_no_tab_ Part_Serial_Catalog_API.Serial_No_Tab;
BEGIN

   number_of_serials_   := serial_no_tab_.COUNT;

   IF (number_of_serials_ = 0) THEN
      local_serial_no_tab_(1).serial_no := '*';
   ELSE
      local_serial_no_tab_ := serial_no_tab_;
   END IF;

   FOR i IN local_serial_no_tab_.FIRST..local_serial_no_tab_.LAST LOOP
      part_rec_ := Lock_By_Keys___(contract_,
                                   part_no_,
                                   configuration_id_,
                                   location_no_,
                                   lot_batch_no_,
                                   local_serial_no_tab_(i).serial_no,
                                   eng_chg_level_,
                                   waiv_dev_rej_no_,
                                   activity_seq_,
                                   handling_unit_id_);

      IF part_rec_.qty_onhand = part_rec_.qty_reserved THEN
         Error_SYS.Record_General ('InventoryPartInStock', 'NOQTYAVAIL: There is no available quantity to perform putaway on.');
      END IF;

      IF part_rec_.location_type NOT IN (Inventory_Location_Type_API.DB_PICKING, 
                                         Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                         Inventory_Location_Type_API.DB_PRODUCTION_LINE) THEN
         Raise_Putaway_Locat_Type_Error(part_rec_.location_type);
      END IF;

      IF part_rec_.freeze_flag = 'Y' THEN
         Raise_Freeze_Flag_Error(part_no_, location_no_);
      END IF;

      Part_Availability_Control_API.Check_Part_Movement_Allowed(part_no_, part_rec_.availability_control_id);

      IF part_rec_.rotable_part_pool_id IS NOT NULL THEN
         Raise_Rotable_Pool_Move_Error(part_no_, part_rec_.rotable_part_pool_id);
      END IF;
   END LOOP;

   IF (number_of_serials_ = 0) THEN
      quantity_ := part_rec_.qty_onhand - part_rec_.qty_reserved; 
   END IF;

   Inventory_Putaway_Manager_API.Putaway_Part(info_                 => info_,
                                              contract_             => contract_,
                                              part_no_              => part_no_,
                                              configuration_id_     => configuration_id_,
                                              location_no_          => location_no_,
                                              lot_batch_no_         => lot_batch_no_,
                                              serial_no_tab_        => serial_no_tab_,
                                              eng_chg_level_        => eng_chg_level_,
                                              waiv_dev_rej_no_      => waiv_dev_rej_no_,
                                              activity_seq_         => activity_seq_,
                                              handling_unit_id_     => handling_unit_id_,
                                              quantity_             => quantity_,
                                              source_ref1_          => NULL,
                                              source_ref2_          => NULL,
                                              source_ref3_          => NULL,
                                              source_ref4_          => NULL,
                                              source_ref_type_db_   => NULL,
                                              calling_process_      => calling_process_,
                                              to_warehouse_id_      => to_warehouse_id_,
                                              to_bay_id_            => to_bay_id_);
END Putaway___;

FUNCTION Get_Default_Avail_Ctrl_Id___ (
   part_no_      IN VARCHAR2,
   serial_no_    IN VARCHAR2,
   lot_batch_no_ IN VARCHAR2,
   contract_     IN VARCHAR2,
   warehouse_id_ IN VARCHAR2,
   bay_id_       IN VARCHAR2,
   tier_id_      IN VARCHAR2,
   row_id_       IN VARCHAR2,
   bin_id_       IN VARCHAR2 ) RETURN VARCHAR2
IS
   condition_code_          VARCHAR2(10);
   availability_control_id_ INVENTORY_PART_IN_STOCK_TAB.availability_control_id%TYPE;
BEGIN
   condition_code_ := Condition_Code_Manager_API.Get_Condition_Code(part_no_,
                                                                    serial_no_,
                                                                    lot_batch_no_);
   IF (condition_code_ IS NOT NULL) THEN
      availability_control_id_ := Condition_Code_API.Get_Default_Avail_Control_Id(condition_code_);
   END IF;

   IF (availability_control_id_ IS NULL) THEN
      availability_control_id_ := Warehouse_Bay_Bin_API.Get_Availability_Control_Id(contract_,
                                                                                    warehouse_id_,
                                                                                    bay_id_,
                                                                                    tier_id_,
                                                                                    row_id_,
                                                                                    bin_id_);
   END IF;

   RETURN (availability_control_id_);
END Get_Default_Avail_Ctrl_Id___;

@Override
PROCEDURE Check_Insert___ (
   newrec_                      IN OUT inventory_part_in_stock_tab%ROWTYPE,
   indrec_                      IN OUT Indicator_Rec,
   attr_                        IN OUT VARCHAR2,
   part_catalog_rec_            IN     Part_Catalog_API.Public_Rec DEFAULT NULL,
   check_mandatory_expire_date_ IN     BOOLEAN DEFAULT TRUE,
   allow_empty_serial_record_   IN     BOOLEAN DEFAULT FALSE)
IS
   name_                   VARCHAR2(30);
   value_                  VARCHAR2(2000);
   inventory_part_rec_     Inventory_Part_API.Public_Rec;
   inv_part_status_rec_    Inventory_Part_Status_Par_API.Public_Rec;   
   site_check_             NUMBER;
   oldrec_                 INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   local_part_catalog_rec_ Part_Catalog_API.Public_Rec;
   stock_location_         BOOLEAN;
BEGIN

   IF NOT indrec_.receipt_date THEN 
      newrec_.receipt_date   := Site_API.Get_Site_Date(newrec_.contract);
   END IF;
   IF NOT indrec_.count_variance THEN 
      newrec_.count_variance := 0;
   END IF;
   IF NOT indrec_.qty_reserved THEN 
      newrec_.qty_reserved   := 0;
   END IF;
   IF NOT indrec_.qty_in_transit THEN 
      newrec_.qty_in_transit := 0;
   END IF;
   IF NOT indrec_.avg_unit_transit_cost THEN 
      newrec_.avg_unit_transit_cost := 0;
   END IF;
   IF NOT indrec_.qty_onhand THEN 
      newrec_.qty_onhand     := 0;
   END IF;
   IF NOT indrec_.freeze_flag THEN 
      newrec_.freeze_flag    := 'N';
   END IF;
   
   newrec_.location_type   := Inventory_Location_API.Get_Location_Type_Db(newrec_.contract, newrec_.location_no);
   stock_location_         := Stock_Location___(newrec_.location_type);
   local_part_catalog_rec_ := Get_Part_Catalog_Rec___(newrec_.part_no, part_catalog_rec_);
   
   IF (newrec_.activity_seq != 0) THEN
      $IF Component_Proj_SYS.INSTALLED $THEN            
         Activity_API.Exist(newrec_.activity_seq);
      $ELSE
         Error_SYS.Record_General(lu_name_, 'NOACTIVITY: Activity Seq cannot have value since Module Project is not installed');
      $END
   END IF; 
   
   super(newrec_, indrec_, attr_);
   Error_SYS.Check_Not_Null(lu_name_, 'ACTIVITY_SEQ', newrec_.activity_seq);

   Error_SYS.Check_Valid_Key_String('WAIV_DEV_REJ_NO', newrec_.waiv_dev_rej_no);

   inventory_part_rec_ := Inventory_Part_API.Get(newrec_.contract, newrec_.part_no);

   Check_Ownership___(oldrec_,
                      newrec_,
                      inventory_part_rec_.inventory_valuation_method);

  IF (local_part_catalog_rec_.lot_tracking_code IN ('LOT TRACKING','ORDER BASED')) THEN
      IF (newrec_.lot_batch_no = '*') THEN
            IF (local_part_catalog_rec_.condition_code_usage  != 'NOT_ALLOW_COND_CODE') THEN
               Raise_Lot_Bat_Req_Error___(newrec_.part_no);
            END IF;
            IF (stock_location_) THEN
               Raise_Lot_Bat_Req_Error___(newrec_.part_no);
            END IF;
            IF (inventory_part_rec_.inventory_part_cost_level NOT IN ('COST PER PART',
                                                                      'COST PER CONFIGURATION')) THEN
               Raise_Lot_Bat_Req_Error___(newrec_.part_no);
            END IF;
      END IF;
   ELSE
      IF (newrec_.lot_batch_no != '*') THEN
         Raise_Lot_Bat_Not_Req_Error___(newrec_.part_no);
      END IF;
   END IF;

   IF ((newrec_.qty_onhand     != 0)  OR
       (newrec_.qty_reserved   != 0)  OR
       (newrec_.qty_in_transit != 0)) THEN
      IF (local_part_catalog_rec_.receipt_issue_serial_track = db_true_) THEN
         IF (newrec_.serial_no = '*') THEN
            IF (local_part_catalog_rec_.serial_tracking_code = db_serial_tracking_) THEN
               IF (local_part_catalog_rec_.condition_code_usage  != 'NOT_ALLOW_COND_CODE') THEN
                  Raise_Serial_Req_Error___(newrec_.part_no);
               END IF;

               IF (stock_location_) THEN
                  Raise_Loc_Type_Serial_Error___(newrec_.part_no, newrec_.location_type);
               END IF;

               IF (inventory_part_rec_.inventory_part_cost_level NOT IN ('COST PER PART',
                                                                         'COST PER CONFIGURATION')) THEN
                  Raise_Serial_Req_Error___(newrec_.part_no);
               END IF;
            ELSE
               IF (newrec_.handling_unit_id != 0) THEN
                  IF (stock_location_) THEN
                     Raise_Loc_Hu_Serial_Error___(newrec_.part_no, newrec_.location_type, newrec_.handling_unit_id);
                  END IF;
               END IF;
            END IF;
         END IF;
      ELSE
         IF (newrec_.serial_no != '*') THEN
            Raise_Serial_Not_Req_Error___(newrec_.part_no);
         END IF;
      END IF;

      IF (stock_location_ AND inventory_part_rec_.mandatory_expiration_date = Fnd_Boolean_API.DB_TRUE AND check_mandatory_expire_date_) THEN
         Error_SYS.Check_Not_Null(lu_name_, 'EXPIRATION_DATE', newrec_.expiration_date);
      END IF;
   END IF;

   IF (newrec_.serial_no != '*') THEN
      IF ((newrec_.qty_onhand = 1 AND newrec_.qty_in_transit = 0)
         OR (newrec_.qty_onhand = 0 AND newrec_.qty_in_transit = 1)
         OR (newrec_.qty_onhand = 0 AND newrec_.qty_in_transit = 0 AND allow_empty_serial_record_) )THEN
         NULL;
      ELSE
         Raise_Serial_Qty_1_Error___;
      END IF;
   END IF;
   
   Inventory_Part_Revision_API.Exist(newrec_.contract, newrec_.part_no, newrec_.eng_chg_level);

   IF (inventory_part_rec_.negative_on_hand = 'NEG ONHAND NOT OK') THEN
      IF (newrec_.qty_onhand < 0) THEN
        Error_SYS.Record_General('InventoryPartInStock', 'NEGONHNOTALLOWED: A negative quantity on hand is not allowed.');
      END IF;
   END IF;

   -- Base items cannot be stored in inventory
   IF ( (local_part_catalog_rec_.configurable = 'CONFIGURED') AND (newrec_.configuration_id = '*') )THEN
      Error_SYS.Record_General('InventoryPartInStock','ISCONFIGURED: This part is configurable and needs a configuration before being stored in inventory.');
   END IF;

   IF (newrec_.qty_onhand != 0 OR newrec_.qty_in_transit != 0) THEN
      inv_part_status_rec_ := Inventory_Part_Status_Par_API.Get(inventory_part_rec_.part_status);
      IF (inv_part_status_rec_.onhand_flag = 'N') THEN
         Error_SYS.Record_General('InventoryPartInStock', 'ONHAQTYNOTALLOWI: Inventory part :P1 on site :P2 has part status :P3 which does not allow quantity on hand.', newrec_.part_no, newrec_.contract, Inventory_Part_Status_Par_API.Get_Description(inventory_part_rec_.part_status));
      END IF;
   END IF;

   -- Assign correct Project ID and check if parts are allowed here
   $IF Component_Proj_SYS.INSTALLED $THEN
      IF (newrec_.activity_seq != 0) THEN      
         newrec_.project_id := Activity_API.Get_Project_Id(newrec_.activity_seq);     
      END IF;
      IF (newrec_.project_id IS NOT NULL) THEN
         site_check_ := Project_Site_API.Project_Site_Exist(newrec_.project_id,newrec_.contract);
         IF site_check_ = 0 THEN
            Error_SYS.Record_General(lu_name_,'NOTPRJSITE: Site :P1 is not a valid project site for project :P2.',newrec_.contract,newrec_.project_id);
         END IF;
      END IF;      
   $END  

   --Validation if the part is Catch Unit enabled.
   Check_Catch_Unit_Insert___(newrec_,
                              local_part_catalog_rec_);

EXCEPTION
   WHEN value_error THEN
      Error_SYS.Item_Format(lu_name_, name_, value_);
END Check_Insert___;

@Override
PROCEDURE Check_Update___ (
   oldrec_                      IN     inventory_part_in_stock_tab%ROWTYPE,
   newrec_                      IN OUT inventory_part_in_stock_tab%ROWTYPE,
   indrec_                      IN OUT Indicator_Rec,
   attr_                        IN OUT VARCHAR2,
   counting_result_             IN     BOOLEAN DEFAULT FALSE,
   part_catalog_rec_            IN     Part_Catalog_API.Public_Rec DEFAULT NULL,
   check_mandatory_expire_date_ IN     BOOLEAN                     DEFAULT TRUE )
IS
   name_                   VARCHAR2(30);
   value_                  VARCHAR2(2000);
   inventory_part_rec_     Inventory_Part_API.Public_Rec;
   inventory_part_fetched_ BOOLEAN := FALSE;
   inv_part_status_rec_    Inventory_Part_Status_Par_API.Public_Rec;
   number_null_            NUMBER  := -999999999999;   
   local_part_catalog_rec_ Part_Catalog_API.Public_Rec;
   stock_location_         BOOLEAN;
BEGIN
   
   inventory_part_fetched_ := FALSE;
   local_part_catalog_rec_ := Get_Part_Catalog_Rec___(newrec_.part_no, part_catalog_rec_);
   stock_location_         := Stock_Location___(newrec_.location_type);
   
   super(oldrec_, newrec_, indrec_, attr_);

   IF ((    newrec_.qty_onhand                        != oldrec_.qty_onhand                           )  OR
       (    newrec_.qty_in_transit                    != oldrec_.qty_in_transit                       )  OR
       (NVL(newrec_.part_ownership    , string_null_) != NVL(oldrec_.part_ownership    , string_null_))  OR
       (NVL(newrec_.owning_vendor_no  , string_null_) != NVL(oldrec_.owning_vendor_no  , string_null_))  OR
       (NVL(newrec_.owning_customer_no, string_null_) != NVL(oldrec_.owning_customer_no, string_null_))) THEN

       IF NOT (inventory_part_fetched_) THEN
               inventory_part_rec_     := Inventory_Part_API.Get(newrec_.contract, newrec_.part_no);
               inventory_part_fetched_ := TRUE;
       END IF;
      
      Check_Ownership___(oldrec_,
                         newrec_,
                         inventory_part_rec_.inventory_valuation_method);
   END IF;
   
   -- Checks whether change of availability_control_id is valid
   IF (NVL(newrec_.availability_control_id, 'NULL') != NVL(oldrec_.availability_control_id, 'NULL')) THEN
      IF ((newrec_.qty_onhand = 0) AND  (newrec_.qty_in_transit = 0)) THEN
         Error_SYS.Record_General(lu_name_, 'NOQTYPAC: Part Availability Control ID cannot be set since no quantity exists on this stock record.');
      END IF;
   
      IF Transport_Task_Manager_API.Inbound_Or_Outbound_Task_Exist (contract_                     => oldrec_.contract,
                                                                    part_no_                      => oldrec_.part_no,
                                                                    configuration_id_             => oldrec_.configuration_id,
                                                                    location_no_                  => oldrec_.location_no,
                                                                    lot_batch_no_                 => oldrec_.lot_batch_no,
                                                                    serial_no_                    => oldrec_.serial_no,
                                                                    eng_chg_level_                => oldrec_.eng_chg_level,
                                                                    waiv_dev_rej_no_              => oldrec_.waiv_dev_rej_no,
                                                                    activity_seq_                 => oldrec_.activity_seq,
                                                                    handling_unit_id_             => oldrec_.handling_unit_id,
                                                                    ignore_pac_id_on_inbound_     => TRUE,
                                                                    part_availability_control_id_ => newrec_.availability_control_id) THEN
         Error_SYS.Record_General(lu_name_, 'INVALIDPACID: A transport task is pending for this part on this location. Perform the transport task prior to modifying the part availability control.');
      END IF;
   END IF;

   -- make sure that the location_type still correspond to location_no
   IF newrec_.location_type != Inventory_Location_API.Get_Location_Type_Db(newrec_.contract, newrec_.location_no) THEN
      Error_SYS.Record_General(lu_name_, 'WRONGLOCATIONTYPE: Inconsistency between the Location Type given :P1 and the Location Type given by default :P2.',
                               Inventory_Location_Type_API.Decode(newrec_.location_type),
                               Inventory_Location_API.Get_Location_Type(newrec_.contract, newrec_.location_no));
   END IF;

   IF (newrec_.serial_no != '*') THEN
      IF   (newrec_.qty_onhand = 1 AND newrec_.qty_in_transit = 0)
        OR (newrec_.qty_onhand = 0 AND newrec_.qty_in_transit = 1)
        OR (newrec_.qty_onhand = 0 AND newrec_.qty_in_transit = 0) THEN
           NULL;
      ELSE
         Raise_Serial_Qty_1_Error___;
      END IF;
   END IF;

   IF (nvl(newrec_.rotable_part_pool_id, 'DuMmY1')    != nvl(oldrec_.rotable_part_pool_id, 'DuMmY1')) OR
      (newrec_.qty_onhand              != oldrec_.qty_onhand)           OR
      (newrec_.qty_in_transit          != oldrec_.qty_in_transit)       OR
      (newrec_.qty_reserved            != oldrec_.qty_reserved)         OR
      (nvl(newrec_.availability_control_id, 'DuMmY1') != nvl(oldrec_.availability_control_id, 'DuMmY1'))   THEN

      Validate_Rotable_Part_Pool___(newrec_,
                                    oldrec_,
                                    local_part_catalog_rec_);

   END IF;

   IF (((newrec_.qty_onhand     != oldrec_.qty_onhand)     OR
        (newrec_.qty_in_transit != oldrec_.qty_in_transit) OR
        (newrec_.qty_reserved   != oldrec_.qty_reserved))  AND
       ((newrec_.qty_onhand     != 0)   OR
        (newrec_.qty_reserved   != 0)   OR
        (newrec_.qty_in_transit != 0))) THEN

      IF (local_part_catalog_rec_.receipt_issue_serial_track = db_true_) THEN
         IF (newrec_.serial_no = '*') THEN
            IF (local_part_catalog_rec_.serial_tracking_code = db_serial_tracking_) THEN
               IF (local_part_catalog_rec_.condition_code_usage  != 'NOT_ALLOW_COND_CODE') THEN
                  Raise_Serial_Req_Error___(newrec_.part_no);
               END IF;

               IF (stock_location_) THEN
                  Raise_Loc_Type_Serial_Error___(newrec_.part_no, newrec_.location_type);
               END IF;

               IF NOT (inventory_part_fetched_) THEN
                  inventory_part_rec_     := Inventory_Part_API.Get(newrec_.contract, newrec_.part_no);
                  inventory_part_fetched_ := TRUE;
               END IF;
               IF (inventory_part_rec_.inventory_part_cost_level NOT IN ('COST PER PART',
                                                                         'COST PER CONFIGURATION')) THEN
                  Raise_Serial_Req_Error___(newrec_.part_no);
               END IF;
            ELSE
               IF (newrec_.handling_unit_id != 0) THEN
                  IF (stock_location_) THEN
                     Raise_Loc_Hu_Serial_Error___(newrec_.part_no, newrec_.location_type, newrec_.handling_unit_id);
                  END IF;
               END IF;
            END IF;
         END IF;
      ELSE
         IF (newrec_.serial_no != '*') THEN
            Raise_Serial_Not_Req_Error___(newrec_.part_no);
         END IF;
      END IF;

      IF (local_part_catalog_rec_.lot_tracking_code IN ('LOT TRACKING','ORDER BASED')) THEN
         IF (newrec_.lot_batch_no = '*') THEN
            IF (local_part_catalog_rec_.condition_code_usage  != 'NOT_ALLOW_COND_CODE') THEN
               Raise_Lot_Bat_Req_Error___(newrec_.part_no);
            END IF;
            IF (stock_location_) THEN
               Raise_Lot_Bat_Req_Error___(newrec_.part_no);
            END IF;
            IF NOT (inventory_part_fetched_) THEN
               inventory_part_rec_     := Inventory_Part_API.Get(newrec_.contract, newrec_.part_no);
               inventory_part_fetched_ := TRUE;
            END IF;
            IF (inventory_part_rec_.inventory_part_cost_level NOT IN ('COST PER PART',
                                                                      'COST PER CONFIGURATION')) THEN
               Raise_Lot_Bat_Req_Error___(newrec_.part_no);
            END IF;
         END IF;
      ELSE
         IF (newrec_.lot_batch_no != '*') THEN
         Raise_Lot_Bat_Not_Req_Error___(newrec_.part_no);
         END IF;
      END IF;
   END IF;

   IF ((newrec_.qty_onhand != oldrec_.qty_onhand) AND
       (newrec_.qty_onhand < 0)) THEN
      IF NOT (inventory_part_fetched_) THEN
         inventory_part_rec_     := Inventory_Part_API.Get(newrec_.contract, newrec_.part_no);
         inventory_part_fetched_ := TRUE;
      END IF;
      IF (inventory_part_rec_.negative_on_hand = 'NEG ONHAND NOT OK') THEN
         Error_SYS.Record_General('InventoryPartInStock', 'NEGONHNOTALLOWED: A negative quantity on hand is not allowed.');
      END IF;
   END IF;

   -- cannot change expiration date when qty reserved >0
   IF (Validate_SYS.Is_Different(Trunc(newrec_.expiration_date), Trunc(oldrec_.expiration_date))) THEN
      IF (newrec_.qty_onhand = 0 AND  newrec_.qty_in_transit = 0) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'NOQOH: Expiration date cannot be set since no quantity on hand exists for this part.');
      END IF;
      IF (newrec_.qty_reserved > 0) THEN
         IF (newrec_.handling_unit_id = 0) THEN
            Error_SYS.Record_General('InventoryPartInStock', 'CHANGEEXPDATE: Expiration date cannot be changed since reserved qty(:P1) exists for part :P2.',newrec_.qty_reserved, newrec_.part_no);
         ELSE
            Error_SYS.Record_General('InventoryPartInStock', 'CHANGEEXPDATEHU: Expiration date cannot be changed since reserved qty(:P1) exists for part :P2 in handling unit :P3.',newrec_.qty_reserved, newrec_.part_no, newrec_.handling_unit_id);
         END IF;
      END IF;
   END IF;

   IF ((oldrec_.qty_onhand != newrec_.qty_onhand) OR (oldrec_.qty_in_transit != newrec_.qty_in_transit)) THEN
      IF (newrec_.qty_onhand != 0 OR newrec_.qty_in_transit != 0) THEN
         IF NOT (inventory_part_fetched_) THEN
            inventory_part_rec_     := Inventory_Part_API.Get(newrec_.contract, newrec_.part_no);
            inventory_part_fetched_ := TRUE;
         END IF;
         inv_part_status_rec_ := Inventory_Part_Status_Par_API.Get(inventory_part_rec_.part_status);
         IF (inv_part_status_rec_.onhand_flag = 'N') THEN
            Raise_Qty_Onhand_Error___(newrec_.part_no, newrec_.contract, Inventory_Part_Status_Par_API.Get_Description(inventory_part_rec_.part_status));
         END IF;
      END IF;
   END IF;

   --Catch Unit Validation
   IF ((newrec_.qty_onhand     != oldrec_.qty_onhand)                               OR
       (newrec_.qty_in_transit != NVL(oldrec_.qty_in_transit, number_null_))        OR
       (NVL(newrec_.catch_qty_onhand, number_null_)
                               != NVL(oldrec_.catch_qty_onhand, number_null_))      OR
       (NVL(newrec_.catch_qty_in_transit, number_null_)
                               != NVL(oldrec_.catch_qty_in_transit, number_null_))) THEN
      Check_Catch_Unit_Update___(newrec_,
                                 oldrec_,
                                 local_part_catalog_rec_,
                                 counting_result_);
   END IF;

   IF check_mandatory_expire_date_ THEN
      IF ((Validate_SYS.Is_Changed(newrec_.expiration_date, oldrec_.expiration_date)) OR
          (Validate_SYS.Is_Changed(newrec_.qty_onhand     , oldrec_.qty_onhand     )) OR 
          (Validate_SYS.Is_Changed(newrec_.qty_in_transit , oldrec_.qty_in_transit ))) THEN
         IF ((newrec_.expiration_date IS NULL) AND (stock_location_) AND ((newrec_.qty_onhand > 0) OR (newrec_.qty_in_transit > 0))) THEN
            IF NOT (inventory_part_fetched_) THEN
               inventory_part_rec_     := Inventory_Part_API.Get(newrec_.contract, newrec_.part_no);
               inventory_part_fetched_ := TRUE;
            END IF;
            IF (inventory_part_rec_.mandatory_expiration_date = Fnd_Boolean_API.DB_TRUE) THEN
               Error_SYS.Check_Not_Null(lu_name_, 'EXPIRATION_DATE', newrec_.expiration_date);
            END IF;
         END IF;
      END IF;
   END IF;

EXCEPTION
   WHEN value_error THEN
      Error_SYS.Item_Format(lu_name_, name_, value_);
END Check_Update___;


@Override
PROCEDURE Check_Common___ (
   oldrec_ IN     inventory_part_in_stock_tab%ROWTYPE,
   newrec_ IN OUT inventory_part_in_stock_tab%ROWTYPE,
   indrec_ IN OUT Indicator_Rec,
   attr_   IN OUT VARCHAR2 )
IS
   shipment_id_ NUMBER;
BEGIN
   --Add pre-processing code here

   IF (newrec_.handling_unit_id > 0 AND ((newrec_.qty_onhand + newrec_.qty_in_transit) != 0)) THEN
      -- There will be a stock record quantity attached to a handling unit
      IF ((NVL(oldrec_.handling_unit_id, 0) != newrec_.handling_unit_id) OR
          ((newrec_.qty_onhand + newrec_.qty_in_transit) > (NVL(oldrec_.qty_onhand,0) + NVL(oldrec_.qty_in_transit,0)))) THEN
         -- Either the stock record quantity has been increased or it has been attached to a handling unit.
         IF (newrec_.location_type != Inventory_Location_Type_API.DB_SHIPMENT) THEN
            shipment_id_ := Handling_Unit_API.Get_Shipment_Id(newrec_.handling_unit_id);
            IF (shipment_id_ IS NOT NULL) THEN
               Error_SYS.Record_General('InventoryPartInStock', 'SHIPMENTHU: Handling Unit :P1 is connected to Shipment :P2. A quantity in stock cannot be attached to a handling unit which is connected to a shipment.', newrec_.handling_unit_id, shipment_id_);
            END IF;
         END IF;
      END IF;
   END IF;

   super(oldrec_, newrec_, indrec_, attr_);

   Check_Quantity_Reserved___(oldrec_, newrec_);

END Check_Common___;
   
PROCEDURE Check_Owning_Cust_No_Ref___ (
   newrec_ IN OUT inventory_part_in_stock_tab%ROWTYPE )
IS
BEGIN
   Check_Owning_Customer_No___(newrec_.owning_customer_no);
END Check_Owning_Cust_No_Ref___;

PROCEDURE Check_Owning_Vendor_No_Ref___ (
   newrec_ IN OUT inventory_part_in_stock_tab%ROWTYPE )
IS
BEGIN
  Check_Owning_Vendor_No___(newrec_.owning_vendor_no);
END Check_Owning_Vendor_No_Ref___;

FUNCTION Get_Move_Dest_Avail_Ctrl_Id___ (
   fromrec_        IN inventory_part_in_stock_tab%ROWTYPE,
   torec_          IN inventory_part_in_stock_tab%ROWTYPE,
   to_contract_    IN VARCHAR2,
   to_location_no_ IN VARCHAR2,
   new_record_     IN BOOLEAN ) RETURN inventory_part_in_stock_tab.availability_control_id%TYPE 
IS
   move_dest_avail_control_id_    inventory_part_in_stock_tab.availability_control_id%TYPE; 
   from_default_avail_control_id_ inventory_part_in_stock_tab.availability_control_id%TYPE; 
   to_default_avail_control_id_   inventory_part_in_stock_tab.availability_control_id%TYPE;
   to_warehouse_id_               inventory_part_in_stock_tab.warehouse%TYPE;
   to_bay_id_                     inventory_part_in_stock_tab.bay_no%TYPE;
   to_tier_id_                    inventory_part_in_stock_tab.tier_no%TYPE;
   to_row_id_                     inventory_part_in_stock_tab.row_no%TYPE;
   to_bin_id_                     inventory_part_in_stock_tab.bin_no%TYPE;
BEGIN
   IF ((new_record_) OR (torec_.qty_onhand = 0 AND torec_.qty_in_transit = 0)) THEN
      -- Below we have one logic for changin location, and one other for changing of other keys like part_no, serial_no, waiv_dev_rej_no, activity_seq.
      IF ((to_contract_ = fromrec_.contract) AND (to_location_no_ = fromrec_.location_no)) THEN
         -- Change of waiv_dev_rej_no, activity_seq, part_no, serial_no, lot_batch_no or handling_unit_id.
         move_dest_avail_control_id_ := fromrec_.availability_control_id;
      ELSE
         -- Change of location (contract, location_no).
         -- There is no destination stock record, or the destination stock record is empty (no quantities).
         -- We should either use the availability_control_id on the source record, or the default availability
         -- control ID on the destination location.
         from_default_avail_control_id_ := Warehouse_Bay_Bin_API.Get_Availability_Control_Id(fromrec_.contract,
                                                                                             fromrec_.warehouse,
                                                                                             fromrec_.bay_no,
                                                                                             fromrec_.tier_no,
                                                                                             fromrec_.row_no,
                                                                                             fromrec_.bin_no);
         IF (new_record_) THEN
            Warehouse_Bay_Bin_API.Get_Location_Strings(to_warehouse_id_,
                                                       to_bay_id_,
                                                       to_tier_id_,
                                                       to_row_id_,
                                                       to_bin_id_,
                                                       to_contract_,
                                                       to_location_no_);
         ELSE
            to_warehouse_id_ := torec_.warehouse;
            to_bay_id_       := torec_.bay_no;
            to_tier_id_      := torec_.tier_no;
            to_row_id_       := torec_.row_no;
            to_bin_id_       := torec_.bin_no;
         END IF;
         to_default_avail_control_id_ := Warehouse_Bay_Bin_API.Get_Availability_Control_Id(to_contract_,
                                                                                           to_warehouse_id_,
                                                                                           to_bay_id_,
                                                                                           to_tier_id_,
                                                                                           to_row_id_,
                                                                                           to_bin_id_);
         IF (NVL(  to_default_avail_control_id_, string_null_) =
             NVL(from_default_avail_control_id_, string_null_)) THEN
            -- There is no difference in default PAC ID between source and destination,
            -- so the PAC ID of the source stock record should be transferred to the destination stock record.
            move_dest_avail_control_id_ := fromrec_.availability_control_id;
         ELSE
            IF (NVL(fromrec_.availability_control_id,string_null_)  = NVL(from_default_avail_control_id_,string_null_)) THEN
               --  The PAC ID of the source stock record is the same as the default PAC ID of the source location.
               -- So it should be ignored since the destination location has a different default PAC ID.
               move_dest_avail_control_id_ := to_default_avail_control_id_;
            ELSE
               --  The PAC ID of the source stock record is the different from the default PAC ID of the source location.
               -- So we should keep it for the new destination record.
               move_dest_avail_control_id_ := fromrec_.availability_control_id;
            END IF;            
         END IF;
      END IF;
   ELSE
      -- There is a destination stock record with quantities. So it should keep its PAC ID even after moving
      -- more quantity to it.
      move_dest_avail_control_id_ := torec_.availability_control_id;
   END IF;
   
   RETURN(move_dest_avail_control_id_);
END Get_Move_Dest_Avail_Ctrl_Id___;

PROCEDURE Check_Transfer_To_Own_Stock___ (
   rec_                    IN INVENTORY_PART_IN_STOCK_TAB%ROWTYPE,
   quantity_               IN NUMBER,
   order_type_             IN VARCHAR2)
IS 
   
BEGIN
   IF(NOT (rec_.qty_onhand > 0) ) THEN
      Error_SYS.Record_General(lu_name_, 'ONHANDQTY: Transfer of ownership is allowed only when on hand qty exists.');
   END IF;
   --Check whether any reserved qty exists
   IF(rec_.qty_reserved != 0) THEN
      Error_SYS.Record_General(lu_name_, 'RESERVEDQTYEXISTLOC: Transfer of Ownership is not allowed when reserved parts exist.');
   END IF;

   --Check whether any qty exists in transit
   IF(rec_.qty_in_transit != 0) THEN
      Error_SYS.Record_General(lu_name_, 'QTYINTRANSITEXISTLOC: Transfer of Ownership is not allowed when parts exist in transit.');
   END IF;
   
 
   IF(rec_.qty_onhand != quantity_ AND NVL(order_type_, string_null_) != Order_Type_API.DB_COMPONENT_REPAIR_EXCHANGE) THEN
      Error_SYS.Record_General(lu_name_, 'PARTQTY: Transfer of Ownership is allowed only when the whole quantity is transferred.');
   END IF;
   
   IF NOT (Stock_Location___(rec_.location_type)) THEN
      Error_SYS.Record_General(lu_name_, 'INVALIDLOCTYPE: Transfer of ownership is not allowed for parts that exist in :P1 locations.',
                               Inventory_Location_Type_API.Decode(rec_.location_type));
   END IF; 
   IF (rec_.freeze_flag = 'Y') THEN
      Error_SYS.Record_General(lu_name_, 'FROZENPARTLINE: Transfer of ownership is not allowed for parts that are Frozen for Counting.');
   END IF;
   IF (rec_.rotable_part_pool_id IS NOT NULL) THEN
      Raise_Rotable_Pool_Error___;
   END IF;
END Check_Transfer_To_Own_Stock___;

PROCEDURE Check_Handling_Unit___ (
   handling_unit_id_            IN NUMBER,
   old_qty_onhand_              IN NUMBER,
   old_qty_in_transit_          IN NUMBER,
   new_qty_onhand_              IN NUMBER,
   new_qty_in_transit_          IN NUMBER,
   validate_structure_position_ IN BOOLEAN )
IS
BEGIN
   IF ((handling_unit_id_ != 0)) THEN
      IF ((old_qty_onhand_     = 0) AND
          (old_qty_in_transit_ = 0) AND
          ((new_qty_onhand_ != 0) OR (new_qty_in_transit_ != 0))) THEN
         -- Check mixing flags on handling unit as soon as any new quantity appears on a stock record.
         Handling_Unit_API.Check_Allow_Mix(handling_unit_id_);
      END IF;

      IF ((old_qty_onhand_     = 0 AND new_qty_onhand_     != 0) OR
          (old_qty_in_transit_ = 0 AND new_qty_in_transit_ != 0)) THEN
         IF (validate_structure_position_) THEN
            -- Check structure position as soon as any new quantity appears either On Hand or In Transit on a stock record. 
            Handling_Unit_API.Validate_Structure_Position(handling_unit_id_);
         END IF;
      END IF;
   END IF;
END Check_Handling_Unit___;


PROCEDURE Manage_Handling_Unit___ (
   handling_unit_id_            IN NUMBER,
   contract_                    IN VARCHAR2,
   location_no_                 IN VARCHAR2,
   old_qty_onhand_              IN NUMBER,
   old_qty_in_transit_          IN NUMBER,
   old_qty_reserved_            IN NUMBER,
   new_qty_onhand_              IN NUMBER,
   new_qty_in_transit_          IN NUMBER,
   new_qty_reserved_            IN NUMBER,
   validate_structure_position_ IN BOOLEAN,
   prevent_hu_snapshot_refresh_ IN BOOLEAN DEFAULT FALSE )
IS
BEGIN
   IF (handling_unit_id_ != 0) THEN
      -- Lock the handling unit to make sure no other process is dealing with this HU at the same time (like Putaway or similar process).
      Handling_Unit_API.Lock_By_Keys(handling_unit_id_);
      IF ((old_qty_onhand_        = 0) AND
          (old_qty_in_transit_    = 0) AND
          ((new_qty_onhand_      != 0) OR
           (new_qty_in_transit_  != 0))) THEN
         -- A new receipt of the Handling Unit into this stock record. Make sure that we have the correct location info on the Handling Unit.
         Handling_Unit_API.Set_Stock_Location(handling_unit_id_, contract_, location_no_);
      ELSIF ((new_qty_onhand_        = 0) AND
             (new_qty_in_transit_    = 0) AND
             ((old_qty_onhand_      != 0) OR
              (old_qty_in_transit_  != 0))) THEN
         -- Nothing left on this stock record for the Handling Unit. CONTRACT and LOCATION_NO information maybe should be removed.
         Handling_Unit_API.Clear_Stock_Location(handling_unit_id_);
      END IF;

      IF ((old_qty_reserved_  = 0) AND
          (new_qty_reserved_ != 0)) THEN
         -- A new reservation of the Handling Unit on this stock record. Attribute HasStockReservation on the HandlingUnit should be set to 'TRUE'.
         Handling_Unit_API.Set_Stock_Reservation(handling_unit_id_);
      ELSIF ((new_qty_reserved_  = 0) AND
             (old_qty_reserved_ != 0)) THEN
         -- No reservation left on this stock record for the Handling Unit. Attribute HasStockReservation on the HandlingUnit should maybe be set to 'FALSE'.
         Handling_Unit_API.Clear_Stock_Reservation(handling_unit_id_);
      END IF;
      
      -- Check if any quantity change has happened, if quantity is added or removed invalidate the current manual weight.
      -- Check validate_structure_position_ to see if this is done on a complete handling unit, if FALSE we do not want to remove manual weight and volume
      IF (((old_qty_onhand_ + old_qty_in_transit_) != (new_qty_onhand_ + new_qty_in_transit_)) AND validate_structure_position_) THEN
         Handling_Unit_API.Clear_Manual_Weight_And_Volume(handling_unit_id_);
      END IF;
   END IF;

   Check_Handling_Unit___(handling_unit_id_            => handling_unit_id_,
                          old_qty_onhand_              => old_qty_onhand_, 
                          old_qty_in_transit_          => old_qty_in_transit_, 
                          new_qty_onhand_              => new_qty_onhand_, 
                          new_qty_in_transit_          => new_qty_in_transit_,
                          validate_structure_position_ => validate_structure_position_);

   IF ((handling_unit_id_ != 0) AND (new_qty_onhand_ != old_qty_onhand_) AND (NOT prevent_hu_snapshot_refresh_)) THEN
      Handling_Unit_For_Refresh_API.New(handling_unit_id_);
   END IF;
END Manage_Handling_Unit___;


PROCEDURE Cleanup_Handl_Unit_Struct___ (
   handling_unit_id_             IN NUMBER,
   discon_zero_stock_handl_unit_ IN BOOLEAN )
IS
BEGIN
   IF ((handling_unit_id_ > 0) AND (discon_zero_stock_handl_unit_)) THEN
      -- The quantity that was issued was connected to a handling unit, and we are supposed to disconnect this handling unit
      -- from its parent handling unit (if such exist) in case no stock is lefter in this handling unit.
      IF NOT (Handling_Unit_Exist(handling_unit_id_)) THEN
         -- No stock left in this particular handling unit. Call the structure cleanup routine which will disconnect this handling unit
         -- from any handling unit structure in case its parent still is directly or indirectly connected to at least one stock record.
         Handling_Unit_API.Disconnect_Zero_Stock_In_Struc(handling_unit_id_);
      END IF;
   END IF;
END Cleanup_Handl_Unit_Struct___;

   
PROCEDURE Print_Serviceability_Tag___ (
   part_no_   IN VARCHAR2,
   serial_no_ IN VARCHAR2,
   quantity_  IN VARCHAR2)
IS
   printer_id_      VARCHAR2(100);
   print_attr_      VARCHAR2(200);
   report_attr_     VARCHAR2(2000);
   parameter_attr_  VARCHAR2(2000);
   result_key_      NUMBER;
   print_job_id_    NUMBER;
   printer_id_list_ VARCHAR2(32000);
   info_            VARCHAR2(2000);
BEGIN
      -- Generate a new print job id
      printer_id_ := Printer_Connection_API.Get_Default_Printer(Fnd_Session_API.Get_Fnd_User, 'SERVICEABILITY_TAG_REP');
      Client_SYS.Clear_Attr(print_attr_);
      Client_SYS.Add_To_Attr('PRINTER_ID', printer_id_, print_attr_);
      Print_Job_API.New(print_job_id_, print_attr_);
      
      -- Create the report
      Client_SYS.Clear_Attr(report_attr_);
      Client_SYS.Add_To_Attr('REPORT_ID', 'SERVICEABILITY_TAG_REP', report_attr_);
      Client_SYS.Clear_Attr(parameter_attr_);
      Client_SYS.Add_To_Attr('PART_NO', part_no_, parameter_attr_);
      Client_SYS.Add_To_Attr('SERIAL_NO', serial_no_, parameter_attr_);
      Client_SYS.Add_To_Attr('QUANTITY', quantity_, parameter_attr_);
      Client_SYS.Add_To_Attr('STATUS', 'SCRAPPED', parameter_attr_);
      Archive_API.New_Instance(result_key_, report_attr_, parameter_attr_);
      Client_SYS.Clear_Attr(print_attr_);
      -- Connect the created report to a print job id
      Client_SYS.Clear_Attr(print_attr_);
      Client_SYS.Add_To_Attr('PRINT_JOB_ID', print_job_id_, print_attr_);
      Client_SYS.Add_To_Attr('RESULT_KEY', result_key_, print_attr_);
      Client_SYS.Add_To_Attr('OPTIONS',      'COPIES(1)',   print_attr_);

      Print_Job_Contents_API.New_Instance(print_attr_);
      
      -- Send the print job to the printer.
      Logical_Printer_API.Enumerate_Printer_Id(printer_id_list_);
      IF (printer_id_list_ IS NOT NULL) THEN
         IF (print_job_id_ IS NOT NULL) THEN
            Print_Job_API.Print(print_job_id_);
         END IF;
      END IF;

      info_ := Language_SYS.Translate_Constant(lu_name_, 'SCRAPREPORT: The scrap inventory part report was created successfully. The report key is :P1.', NULL, result_key_);

      Transaction_SYS.Set_Progress_Info(info_);
      
END Print_Serviceability_Tag___;


-- Count_Part___
--   Inserts or modifies a counted part by calling Inventory Part.
PROCEDURE Count_Part___ (
   contract_             IN VARCHAR2,
   part_no_              IN VARCHAR2,
   configuration_id_     IN VARCHAR2,
   location_no_          IN VARCHAR2,
   lot_batch_no_         IN VARCHAR2,
   serial_no_            IN VARCHAR2,
   eng_chg_level_        IN VARCHAR2,
   waiv_dev_rej_no_      IN VARCHAR2,
   activity_seq_         IN NUMBER,
   handling_unit_id_     IN NUMBER,
   qty_difference_       IN NUMBER,
   catch_qty_difference_ IN NUMBER,
   unit_cost_            IN NUMBER   DEFAULT NULL,
   condition_code_       IN VARCHAR2 DEFAULT NULL,
   note_text_            IN VARCHAR2 DEFAULT NULL,
   cost_detail_id_       IN NUMBER   DEFAULT NULL,
   inv_list_no_          IN VARCHAR2 DEFAULT '*',
   seq_no_               IN NUMBER   DEFAULT 0 )
IS
   new_record_                   BOOLEAN;
   newrec_                       INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   oldrec_                       INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   local_unit_cost_              NUMBER;
   abs_diff_                     NUMBER;
   catch_diff_                   NUMBER;
   qty_counted_                  NUMBER;
   catch_qty_counted_            NUMBER;
   transaction_id_               NUMBER;
   transaction_                  VARCHAR2(20);
   accounting_id_                NUMBER := 0;
   trans_value_                  NUMBER := 0;
   qty_in_transit_               NUMBER:=0;
   part_rec_                     Inventory_Part_API.Public_Rec;
   part_catalog_rec_             Part_Catalog_API.Public_Rec;
   cost_detail_tab_              Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;   
   location_type_db_             INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   serial_no_for_stock_          INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE;
   check_mandatory_expire_date_  BOOLEAN := TRUE;
   expiration_date_              DATE;
   latest_transaction_id_        NUMBER;
BEGIN

   part_catalog_rec_    := Part_Catalog_API.Get(part_no_);
   location_type_db_    := Inventory_Location_API.Get_Location_Type_Db(contract_,location_no_);
   IF (Check_Exist___(contract_,
                      part_no_,
                      configuration_id_,
                      location_no_,
                      lot_batch_no_,
                      serial_no_,
                      eng_chg_level_,
                      waiv_dev_rej_no_,
                      activity_seq_,
                      handling_unit_id_)) THEN
      serial_no_for_stock_ := serial_no_;   
   ELSE
      serial_no_for_stock_ := Get_Serial_No_For_Stock(part_no_, serial_no_, part_catalog_rec_, location_type_db_, handling_unit_id_);
   END IF;
   
   IF (Check_Exist___(contract_,
                      part_no_,
                      configuration_id_,
                      location_no_,
                      lot_batch_no_,
                      serial_no_for_stock_,
                      eng_chg_level_,
                      waiv_dev_rej_no_,
                      activity_seq_,
                      handling_unit_id_)) THEN

      oldrec_ := Lock_By_Keys___(contract_,
                                 part_no_,
                                 configuration_id_,
                                 location_no_,
                                 lot_batch_no_,
                                 serial_no_for_stock_,
                                 eng_chg_level_,
                                 waiv_dev_rej_no_,
                                 activity_seq_,
                                 handling_unit_id_);
      newrec_     := oldrec_;
      new_record_ := FALSE;
   ELSE
      new_record_ := TRUE;
      -- To perform checks using these values. newrec_.qty_onhand will be set to counted qty further down.
      newrec_.qty_onhand    := 0;
      newrec_.location_type := location_type_db_;
   END IF;

   qty_counted_       := newrec_.qty_onhand + qty_difference_;
   catch_qty_counted_ := NVL(newrec_.catch_qty_onhand, 0) + catch_qty_difference_;

   IF (qty_counted_ < 0) THEN
      Error_SYS.Record_General('InventoryPartInStock', '142: Counted quantity must be greater than 0.');
   END IF;

   IF (configuration_id_ = '*') THEN
      IF newrec_.location_type NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                       Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                       Inventory_Location_Type_API.DB_PRODUCTION_LINE) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'WRONGCOUNTLOCTYPE: Locations of type :P1 or :P2 or :P3 are not valid for counting',
                                                             Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_QUALITY_ASSURANCE),
                                                             Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_SHIPMENT));
      END IF;
   ELSE
      IF newrec_.location_type NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                       Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                       Inventory_Location_Type_API.DB_PRODUCTION_LINE) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'CONFIGCOUNT: Only locations of type :P1 and :P2 and :P3 are valid when counting configured parts.',
                                                             Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_PICKING),
                                                             Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_FLOOR_STOCK),
                                                             Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_PRODUCTION_LINE));
      END IF;
   END IF;

   IF (cost_detail_id_ IS NULL) THEN
      IF (unit_cost_ IS NULL) THEN
         cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Get_Cost_Details_By_Method(
                                                                                 contract_,
                                                                                 part_no_,
                                                                                 configuration_id_,
                                                                                 lot_batch_no_,
                                                                                 serial_no_);
         IF (new_record_) THEN
         -- First transaction is counting
            local_unit_cost_ := Inventory_Part_Unit_Cost_API.Get_Total_Unit_Cost(cost_detail_tab_);

            IF (local_unit_cost_ = 0) THEN
               qty_in_transit_ := Get_Total_Qty_In_Transit(contract_,
                                                           part_no_,
                                                           configuration_id_)  +
                                  Inventory_Part_In_Transit_API.Get_Total_Qty_In_Order_Transit(
                                                                              contract_,
                                                                              part_no_,
                                                                              configuration_id_);
               IF (qty_in_transit_ = 0) THEN
                  part_rec_ := Inventory_Part_API.Get(contract_, part_no_);
                  IF ((part_rec_.zero_cost_flag = 'N') AND
                      (part_rec_.inventory_valuation_method IN ('AV','FIFO','LIFO'))) THEN

                     local_unit_cost_ := Inventory_Part_Config_API.Get_Estimated_Material_Cost(
                                                                                contract_,
                                                                                part_no_,
                                                                                configuration_id_);
                     cost_detail_tab_.DELETE;
                  END IF;
               END IF;
            END IF;
         END IF;
      ELSE
         local_unit_cost_ := unit_cost_;
      END IF;
   ELSE
      cost_detail_tab_ := Temporary_Part_Cost_Detail_API.Get_Details(cost_detail_id_);
   END IF;

   IF (qty_difference_ < 0) THEN
      transaction_       := 'COUNT-OUT';
      abs_diff_          := qty_difference_ * -1;
   ELSE
      transaction_       := 'COUNT-IN';
      abs_diff_          := qty_difference_;
   END IF;
     
   IF (SIGN(qty_difference_) != SIGN(catch_qty_difference_)) THEN
      catch_diff_ := ABS(catch_qty_difference_) * -1;
   ELSE
      catch_diff_ := ABS(catch_qty_difference_);
   END IF;
   
   IF (newrec_.qty_onhand > 0)  THEN
      expiration_date_ := newrec_.expiration_date;
   END IF; 
   
   latest_transaction_id_  := Part_Serial_History_API.Get_Latest_Inv_Transaction_Id(newrec_.part_no, newrec_.serial_no);
   
   IF (qty_difference_ != 0) THEN
      Inventory_Transaction_Hist_API.NEW(transaction_id_     => transaction_id_,
                                         accounting_id_      => accounting_id_,
                                         value_              => trans_value_,
                                         transaction_code_   => transaction_,
                                         contract_           => contract_,
                                         part_no_            => part_no_,
                                         configuration_id_   => configuration_id_,
                                         location_no_        => location_no_,
                                         lot_batch_no_       => lot_batch_no_,
                                         serial_no_          => serial_no_,
                                         waiv_dev_rej_no_    => waiv_dev_rej_no_,
                                         eng_chg_level_      => eng_chg_level_,
                                         activity_seq_       => activity_seq_,
                                         handling_unit_id_	 => handling_unit_id_,
                                         project_id_         => NULL,
                                         source_ref1_        => NVL(inv_list_no_, '*'),
                                         source_ref2_        => NULL,
                                         source_ref3_        => NULL,
                                         source_ref4_        => NVL(seq_no_, 0),
                                         source_ref5_        => NULL,
                                         reject_code_        => NULL,
                                         cost_detail_tab_    => cost_detail_tab_,
                                         unit_cost_          => local_unit_cost_,
                                         quantity_           => abs_diff_,
                                         qty_reversed_       => 0,
                                         catch_quantity_     => catch_diff_,
                                         source_             => note_text_,
                                         source_ref_type_    => Order_Type_API.Decode('COUNTING'),
                                         owning_vendor_no_   => newrec_.owning_vendor_no,
                                         condition_code_     => condition_code_,
                                         location_group_     => NULL,
                                         part_ownership_db_  => NVL(newrec_.part_ownership, Part_Ownership_API.DB_COMPANY_OWNED),
                                         owning_customer_no_ => newrec_.owning_customer_no,
                                         expiration_date_    => expiration_date_);
   END IF;

   -- Create the new record or update the one present
   IF (transaction_id_ IS NOT NULL) THEN
      newrec_.latest_transaction_id := transaction_id_ ;
   END IF;
   IF new_record_ THEN
      newrec_.contract         := contract_           ;
      newrec_.part_no          := part_no_            ;
      newrec_.configuration_id := configuration_id_   ;
      newrec_.location_no      := location_no_        ;
      newrec_.lot_batch_no     := lot_batch_no_       ;
      newrec_.serial_no        := serial_no_for_stock_;
      newrec_.eng_chg_level    := eng_chg_level_      ;
      newrec_.waiv_dev_rej_no  := waiv_dev_rej_no_    ;
      newrec_.activity_seq     := activity_seq_       ;
      newrec_.handling_unit_id := handling_unit_id_   ;
      newrec_.qty_onhand       := qty_counted_        ;
      newrec_.location_type    := NULL                ;

      IF (catch_qty_counted_ IS NOT NULL) THEN
         newrec_.catch_qty_onhand := catch_qty_counted_;
      END IF;
      newrec_.count_variance        := qty_difference_                         ;
      newrec_.last_count_date       := Trunc(Site_API.Get_Site_Date(contract_));
      newrec_.avg_unit_transit_cost := 0                                       ;
      newrec_.part_ownership        := Part_Ownership_API.DB_COMPANY_OWNED;
      IF (newrec_.lot_batch_no != '*') THEN
         newrec_.expiration_date := Lot_Batch_Master_API.Get_Expiration_Date(newrec_.part_no, newrec_.lot_batch_no);
      END IF;

   Check_And_Insert_By_Keys___(newrec_                      => newrec_,
                               part_catalog_rec_            => part_catalog_rec_,
                               check_mandatory_expire_date_ => FALSE);
   ELSE
      newrec_.qty_onhand := qty_counted_;
      IF (catch_qty_counted_ IS NOT NULL) THEN
         newrec_.catch_qty_onhand := catch_qty_counted_;
      END IF;
      newrec_.count_variance        := qty_difference_;
      newrec_.last_count_date       := Trunc(Site_API.Get_Site_Date(contract_));
      newrec_.avg_unit_transit_cost := 0;

      IF (oldrec_.part_ownership IS NULL) THEN
         newrec_.part_ownership := Part_Ownership_API.DB_COMPANY_OWNED;
      END IF;

      IF (newrec_.lot_batch_no != '*' AND qty_counted_ != 0) THEN
         IF (oldrec_.expiration_date IS NULL) THEN   
            newrec_.expiration_date := Lot_Batch_Master_API.Get_Expiration_Date(newrec_.part_no, newrec_.lot_batch_no);
         END IF;
      END IF;
      
      IF (newrec_.serial_no != '*' AND qty_counted_ != 0) THEN
         IF (oldrec_.expiration_date IS NULL) THEN
            newrec_.expiration_date := Inventory_Transaction_Hist_API.Get_Expiration_Date(latest_transaction_id_);
         END IF;
      END IF;

      IF (oldrec_.qty_onhand = 0 AND oldrec_.qty_in_transit = 0 AND qty_counted_ != 0) THEN
         check_mandatory_expire_date_ := FALSE;
      END IF;
      
      Check_And_Update_By_Keys___(oldrec_                       => oldrec_,
                                  newrec_                       => newrec_,
                                  counting_result_              => TRUE,
                                  check_mandatory_expire_date_  => check_mandatory_expire_date_);

      Cleanup_Handl_Unit_Struct___(handling_unit_id_              => oldrec_.handling_unit_id, 
                                   discon_zero_stock_handl_unit_  => TRUE);
   END IF;

   IF (qty_difference_ != 0) THEN
      Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                Site_API.Get_Company(contract_),
                                                'N',
                                                NULL);
      $IF Component_Purch_SYS.INSTALLED $THEN
         Receive_Purchase_Order_API.Create_Consignment_Transaction(transaction_id_);                   
      $END
   END IF;

   Inventory_Part_API.Modify_Counted_Part(contract_, part_no_, qty_difference_);
END Count_Part___;


PROCEDURE Change_Source_Handl_Unit_Id___(
   contract_                     IN VARCHAR2,
   part_no_                      IN VARCHAR2,
   configuration_id_             IN VARCHAR2,
   location_no_                  IN VARCHAR2,
   lot_batch_no_                 IN VARCHAR2,
   serial_no_                    IN VARCHAR2,
   eng_chg_level_                IN VARCHAR2,
   waiv_dev_rej_no_              IN VARCHAR2,
   activity_seq_                 IN NUMBER,
   old_handling_unit_id_         IN NUMBER,
   new_handling_unit_id_         IN NUMBER,
   quantity_                     IN NUMBER,
   catch_quantity_               IN NUMBER,
   source_ref1_                  IN VARCHAR2,
   source_ref2_                  IN VARCHAR2,
   source_ref3_                  IN VARCHAR2,
   source_ref4_                  IN VARCHAR2,
   inv_trans_source_ref_type_db_ IN VARCHAR2 ) 
IS
   rec_order_source_ref_type_db_  VARCHAR2(20);
BEGIN
   IF (inv_trans_source_ref_type_db_ IN (Order_Type_API.DB_PURCHASE_ORDER, Order_Type_API.DB_SHIPMENT_ORDER)) THEN 
      $IF Component_Rceipt_SYS.INSTALLED $THEN
         rec_order_source_ref_type_db_ := Receive_Order_API.Get_Source_Ref_Type_Db(inv_trans_source_ref_type_db_);
         Receive_Order_API.Change_Handling_Unit_Id(contract_                => contract_,
                                                   part_no_                 => part_no_,
                                                   configuration_id_        => configuration_id_,
                                                   location_no_             => location_no_,
                                                   lot_batch_no_            => lot_batch_no_,
                                                   serial_no_               => serial_no_,
                                                   eng_chg_level_           => eng_chg_level_,
                                                   waiv_dev_rej_no_         => waiv_dev_rej_no_,
                                                   activity_seq_            => activity_seq_,
                                                   old_handling_unit_id_    => old_handling_unit_id_,
                                                   new_handling_unit_id_    => new_handling_unit_id_,
                                                   inv_quantity_            => quantity_,
                                                   source_quantity_         => NULL,   
                                                   catch_quantity_          => catch_quantity_,
                                                   source_ref1_             => source_ref1_,
                                                   source_ref2_             => source_ref2_,
                                                   source_ref3_             => source_ref3_,
                                                   source_ref4_             => NULL,
                                                   source_ref_type_db_      => rec_order_source_ref_type_db_,
                                                   receipt_no_              => source_ref4_); 
      $ELSE
         Error_SYS.Component_Not_Exist('RCEIPT');
      $END
   END IF;   
END Change_Source_Handl_Unit_Id___;


PROCEDURE Find_And_Reserve_Or_Issue___ (
   keys_and_qty_tab_             OUT Keys_And_Qty_Tab,
   action_                       IN  VARCHAR2,
   location_no_                  IN  VARCHAR2,
   lot_batch_no_                 IN  VARCHAR2,
   serial_no_                    IN  VARCHAR2,
   eng_chg_level_                IN  VARCHAR2,
   waiv_dev_rej_no_              IN  VARCHAR2,
   configuration_id_             IN  VARCHAR2,
   activity_seq_                 IN  NUMBER,
   handling_unit_id_             IN  NUMBER,
   contract_                     IN  VARCHAR2,
   part_no_                      IN  VARCHAR2,
   location_type_db_             IN  VARCHAR2,
   qty_to_reserve_or_issue_      IN  NUMBER,
   project_id_                   IN  VARCHAR2,
   condition_code_               IN  VARCHAR2,
   part_ownership_db_            IN  VARCHAR2,
   owning_vendor_no_             IN  VARCHAR2,
   owning_customer_no_           IN  VARCHAR2,
   only_one_lot_allowed_         IN  BOOLEAN,
   many_records_allowed_         IN  BOOLEAN,
   expiration_control_date_      IN  DATE,
   warehouse_id_                 IN  VARCHAR2,
   ignore_this_avail_control_id_ IN  VARCHAR2,
   include_temp_table_locs_      IN  BOOLEAN,
   transaction_code_             IN  VARCHAR2 DEFAULT NULL,
   source_ref1_                  IN  VARCHAR2 DEFAULT NULL,
   source_ref2_                  IN  VARCHAR2 DEFAULT NULL,
   source_ref3_                  IN  VARCHAR2 DEFAULT NULL,
   source_ref4_                  IN  NUMBER   DEFAULT NULL,
   source_ref_type_              IN  VARCHAR2 DEFAULT NULL,
   source_                       IN  VARCHAR2 DEFAULT NULL,
   location_group_               IN  VARCHAR2 DEFAULT NULL,
   reserve_from_transp_task_db_  IN  VARCHAR2 DEFAULT Reserve_From_Transp_Task_API.DB_USE_INVENTORY_DEFAULT)
IS
   total_reserved_or_issued_qty_  NUMBER := 0;
   available_record_was_skipped_  BOOLEAN;
   local_qty_to_reserve_or_issue_ NUMBER;
   consume_partial_handling_unit_ BOOLEAN := FALSE;
   local_keys_and_qty_tab_        Keys_And_Qty_Tab;
   local_keys_and_qty_counter_    NUMBER;
   auto_reservation_db_           VARCHAR2(20);
   order_issue_db_                VARCHAR2(20);
   part_movement_control_db_      VARCHAR2(20);
   removed_transp_task_line_tab_  Transport_Task_Line_API.Public_Rec_Tab;
   reserve_from_transp_task_inv_  VARCHAR2(30);
BEGIN
   local_qty_to_reserve_or_issue_ := NVL(qty_to_reserve_or_issue_, 0);
   auto_reservation_db_           := CASE action_ WHEN reserve_            THEN Part_Reservation_Control_API.DB_AUTO_RESERVATION ELSE NULL END;
   order_issue_db_                := CASE action_ WHEN issue_              THEN Part_Order_Issue_Control_API.DB_ORDER_ISSUE      ELSE NULL END;
   part_movement_control_db_      := CASE action_ WHEN find_for_transport_ THEN Part_Movement_Control_API.DB_ALL_ALLOWED         ELSE NULL END;

   Inventory_Event_Manager_API.Start_Session;
   
   -- gelr:access_ctrl_for_inv_reserv, start
   User_Warehouse_Access_API.Find_User_Access_Warehouses(contract_, action_);
   -- gelr:access_ctrl_for_inv_reserv, end
   
   IF (action_ = reserve_ AND many_records_allowed_) THEN
      IF (reserve_from_transp_task_db_ = Reserve_From_Transp_Task_API.DB_USE_INVENTORY_DEFAULT) THEN
         reserve_from_transp_task_inv_:= Site_Invent_Info_API.Get_Reserv_From_Transp_Task_Db(contract_);
      ELSE
         reserve_from_transp_task_inv_ := reserve_from_transp_task_db_;
      END IF;
                                       
      IF reserve_from_transp_task_inv_ = Reserve_From_Transp_Task_API.DB_YES THEN      
         Transport_Task_Line_API.Find_And_Remove(removed_rec_tab_               => removed_transp_task_line_tab_,
                                                 from_location_no_              => location_no_                 ,
                                                 lot_batch_no_                  => lot_batch_no_                ,
                                                 serial_no_                     => serial_no_                   ,
                                                 eng_chg_level_                 => eng_chg_level_               ,
                                                 waiv_dev_rej_no_               => waiv_dev_rej_no_             ,
                                                 configuration_id_              => configuration_id_            ,
                                                 activity_seq_                  => activity_seq_                ,
                                                 handling_unit_id_              => handling_unit_id_            ,
                                                 from_contract_                 => contract_                    ,
                                                 part_no_                       => part_no_                     ,
                                                 from_location_type_db_         => location_type_db_            ,
                                                 auto_reservation_db_           => auto_reservation_db_         ,
                                                 order_issue_db_                => order_issue_db_              ,
                                                 project_id_                    => project_id_                  ,
                                                 condition_code_                => condition_code_              ,
                                                 part_ownership_db_             => part_ownership_db_           ,
                                                 owning_vendor_no_              => owning_vendor_no_            ,
                                                 owning_customer_no_            => owning_customer_no_          ,
                                                 expiration_control_date_       => expiration_control_date_     ,
                                                 include_temp_table_locs_       => include_temp_table_locs_     ,
                                                 warehouse_id_                  => warehouse_id_                ,
                                                 ignore_this_avail_control_id_  => ignore_this_avail_control_id_ );
      END IF;      
   END IF;

   LOOP
      keys_and_qty_tab_ := Find_And_Lock_Part(available_record_was_skipped_,
                                              location_no_,
                                              lot_batch_no_,
                                              serial_no_,
                                              eng_chg_level_,
                                              waiv_dev_rej_no_,
                                              configuration_id_,
                                              activity_seq_,
                                              handling_unit_id_,
                                              contract_,
                                              part_no_,
                                              location_type_db_,
                                              auto_reservation_db_           => auto_reservation_db_,
                                              order_issue_db_                => order_issue_db_,
                                              project_id_                    => project_id_,
                                              condition_code_                => condition_code_,
                                              part_ownership_db_             => part_ownership_db_,
                                              owning_vendor_no_              => owning_vendor_no_,
                                              owning_customer_no_            => owning_customer_no_,
                                              only_one_lot_allowed_          => only_one_lot_allowed_,
                                              many_records_allowed_          => many_records_allowed_,
                                              qty_to_find_and_lock_          => local_qty_to_reserve_or_issue_,
                                              expiration_control_date_       => expiration_control_date_,
                                              include_temp_table_locs_       => include_temp_table_locs_,
                                              warehouse_id_                  => warehouse_id_,
                                              ignore_this_avail_control_id_  => ignore_this_avail_control_id_,
                                              consume_partial_handling_unit_ => consume_partial_handling_unit_,
                                              part_movement_control_db_      => part_movement_control_db_,
                                              location_group_                => location_group_);

      IF (keys_and_qty_tab_.COUNT > 0) THEN
         FOR i IN keys_and_qty_tab_.FIRST..keys_and_qty_tab_.LAST LOOP
            IF (action_ IN (reserve_, find_for_transport_)) THEN
               Reserve_Part(keys_and_qty_tab_(i).catch_quantity,
                            keys_and_qty_tab_(i).contract,
                            keys_and_qty_tab_(i).part_no,
                            keys_and_qty_tab_(i).configuration_id,
                            keys_and_qty_tab_(i).location_no,
                            keys_and_qty_tab_(i).lot_batch_no,
                            keys_and_qty_tab_(i).serial_no,
                            keys_and_qty_tab_(i).eng_chg_level,
                            keys_and_qty_tab_(i).waiv_dev_rej_no,
                            keys_and_qty_tab_(i).activity_seq,
                            keys_and_qty_tab_(i).handling_unit_id,
                            keys_and_qty_tab_(i).quantity);
            ELSIF (action_ = issue_) THEN
               Issue_Part( transaction_id_               => keys_and_qty_tab_(i).transaction_id,
                           catch_quantity_               => keys_and_qty_tab_(i).catch_quantity,
                           contract_                     => keys_and_qty_tab_(i).contract,
                           part_no_                      => keys_and_qty_tab_(i).part_no,
                           configuration_id_             => keys_and_qty_tab_(i).configuration_id,
                           location_no_                  => keys_and_qty_tab_(i).location_no,
                           lot_batch_no_                 => keys_and_qty_tab_(i).lot_batch_no,
                           serial_no_                    => keys_and_qty_tab_(i).serial_no,
                           eng_chg_level_                => keys_and_qty_tab_(i).eng_chg_level,
                           waiv_dev_rej_no_              => keys_and_qty_tab_(i).waiv_dev_rej_no,
                           activity_seq_                 => keys_and_qty_tab_(i).activity_seq,
                           handling_unit_id_             => keys_and_qty_tab_(i).handling_unit_id,
                           transaction_                  => transaction_code_,
                           quantity_                     => keys_and_qty_tab_(i).quantity,
                           quantity_reserved_            => 0,
                           source_ref1_                  => source_ref1_,
                           source_ref2_                  => source_ref2_,
                           source_ref3_                  => source_ref3_,
                           source_ref4_                  => source_ref4_,
                           source_ref5_                  => NULL,
                           source_                       => source_,
                           source_ref_type_              => source_ref_type_,
                           dest_contract_                => NULL,        
                           ignore_this_avail_control_id_ => ignore_this_avail_control_id_);
            ELSE
              Error_Sys.Record_General('InventoryPartInStock', 'FINDACTIONERROR: Action :P1 is not supported in Find_And_Reserve_Or_Issue___.', action_);
            END IF;

            total_reserved_or_issued_qty_ := total_reserved_or_issued_qty_ + keys_and_qty_tab_(i).quantity;
         END LOOP;
      END IF;

      IF ((total_reserved_or_issued_qty_ < local_qty_to_reserve_or_issue_) AND available_record_was_skipped_) THEN
         local_qty_to_reserve_or_issue_ := local_qty_to_reserve_or_issue_ - total_reserved_or_issued_qty_;
         consume_partial_handling_unit_ := TRUE;
         local_keys_and_qty_tab_ := keys_and_qty_tab_;
      ELSE
         EXIT;
      END IF;
   END LOOP;
   local_keys_and_qty_counter_ := local_keys_and_qty_tab_.COUNT;
   IF (local_keys_and_qty_counter_ > 0) THEN
      -- There is a collection saved from the attempt to reserve or issue complete handling units
      IF (keys_and_qty_tab_.COUNT > 0) THEN
         -- There was also a collection found when attempting to reserve or issue partial handling units
         FOR i IN keys_and_qty_tab_.FIRST..keys_and_qty_tab_.LAST LOOP
            local_keys_and_qty_tab_(local_keys_and_qty_counter_ + i) := keys_and_qty_tab_(i);
         END LOOP;
      END IF;
      keys_and_qty_tab_ := local_keys_and_qty_tab_;
   END IF;

   Transport_Task_Line_API.Handle_Stock_Reservat_Result(keys_and_qty_tab_, removed_transp_task_line_tab_);

   -- gelr:access_ctrl_for_inv_reserv, start
   Clear_Warehouse_Id_Tmp___;
   -- gelr:access_ctrl_for_inv_reserv, end
   
   Inventory_Event_Manager_API.Finish_Session;
     
END Find_And_Reserve_Or_Issue___;


-- Receive_Part_On_Order___
--   Inserts quantities of inventory parts into inventory due to order arrivals.
PROCEDURE Receive_Part_On_Order___ (
   contract_                     IN VARCHAR2,
   part_no_                      IN VARCHAR2,
   configuration_id_             IN VARCHAR2,
   location_no_                  IN VARCHAR2,
   lot_batch_no_                 IN VARCHAR2,
   serial_no_                    IN VARCHAR2,
   eng_chg_level_                IN VARCHAR2,
   waiv_dev_rej_no_              IN VARCHAR2,
   activity_seq_                 IN NUMBER,
   from_handling_unit_id_        IN NUMBER,
   to_handling_unit_id_          IN NUMBER,
   transaction_                  IN VARCHAR2,
   expiration_date_              IN DATE,
   delivering_warehouse_id_      IN VARCHAR2,
   receiving_warehouse_id_       IN VARCHAR2,
   qty_received_                 IN NUMBER,
   catch_qty_received_           IN NUMBER,
   source_ref1_                  IN VARCHAR2,
   source_ref2_                  IN VARCHAR2,
   source_ref3_                  IN VARCHAR2,
   source_ref4_                  IN VARCHAR2,
   source_ref5_                  IN VARCHAR2,
   source_ref_type_              IN VARCHAR2,
   receipt_no_                   IN VARCHAR2,
   vendor_no_                    IN VARCHAR2,
   receipt_date_                 IN DATE,
   price_                        IN NUMBER,
   cost_detail_tab_              IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   part_ownership_               IN VARCHAR2,
   owning_customer_no_           IN VARCHAR2,
   condition_code_               IN VARCHAR2,
   sender_contract_              IN VARCHAR2,
   remove_default_qty_           IN VARCHAR2,
   transit_eng_chg_level_        IN VARCHAR2 ,
   operational_condition_db_     IN VARCHAR2,
   comp_cost_transaction_id_     IN NUMBER,
   validate_hu_struct_position_  IN BOOLEAN,
   supplier_del_note_no_         IN VARCHAR2 DEFAULT NULL,
   del_note_date_                IN DATE     DEFAULT NULL )
IS
   inventory_part_rec_           Inventory_Part_API.Public_Rec;
   part_catalog_rec_             Part_Catalog_API.Public_Rec;
   location_type_db_             INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   qty_onhand_                   INVENTORY_PART_IN_STOCK_TAB.qty_onhand%TYPE;
   serial_no_for_stock_          INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE;
   local_source_ref3_            VARCHAR2(50) := source_ref3_;
   local_source_ref4_            VARCHAR2(50) := source_ref4_;
   dummy_char_                   VARCHAR2(2000);
   eng_chg_in_transit_           VARCHAR2(6);
   transaction_id_               NUMBER;
   accounting_id_                NUMBER;
   trans_value_                  NUMBER;
   revised_price_                NUMBER;
   ownership_conflict_           BOOLEAN;
BEGIN

   location_type_db_    := Inventory_Location_API.Get_Location_Type_Db(contract_,location_no_);
   part_catalog_rec_    := Part_Catalog_API.Get(part_no_);
   serial_no_for_stock_ := Get_Serial_No_For_Stock(part_no_, serial_no_, part_catalog_rec_, location_type_db_, to_handling_unit_id_);

   IF (serial_no_for_stock_ != serial_no_) THEN
      ownership_conflict_ := Ownership_Conflict_Exists___(contract_,
                                                          part_no_,
                                                          configuration_id_,
                                                          location_no_,
                                                          lot_batch_no_,
                                                          serial_no_for_stock_,
                                                          eng_chg_level_,
                                                          waiv_dev_rej_no_,
                                                          activity_seq_,
                                                          to_handling_unit_id_,
                                                          part_ownership_,
                                                          owning_customer_no_,
                                                          vendor_no_);
      IF (ownership_conflict_) THEN
         serial_no_for_stock_ := serial_no_;
      END IF;
   END IF;

   IF transaction_ != 'SHIPODWHS+' AND (part_catalog_rec_.receipt_issue_serial_track = db_true_) AND 
      Stock_Location___(location_type_db_) AND (serial_no_ = '*') THEN
      -- This error is added to make sure that user has specified serial numbers for this receipt
      -- IF "In Inventory" serial tracking is disabled the stock records will still be created without 
      -- specific serial numbers, but we will create the serials in PartSerialCatalog.
      Raise_Loc_Type_Serial_Error___(part_no_, location_type_db_);
   END IF;

   IF NOT (location_type_db_ IN (Inventory_Location_Type_API.DB_PICKING,
                                 Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                 Inventory_Location_Type_API.DB_PRODUCTION_LINE,
                                 Inventory_Location_Type_API.DB_ARRIVAL) OR 
          (location_type_db_ IN (Inventory_Location_Type_API.DB_QUALITY_ASSURANCE) AND source_ref_type_ != Order_Type_API.DB_SHIPMENT_ORDER)) THEN
      Error_SYS.Record_General('InventoryPartInStock', 'WRONGRECLOCTYPENOPA5: Location type :P1 is not valid for order :P2 with part :P3', Inventory_Location_Type_API.Decode(location_type_db_), source_ref1_, part_no_);
   END IF;

   Check_Waiv_Dev_Rej_No___(contract_             => contract_,
                            part_no_              => part_no_,
                            configuration_id_     => configuration_id_,
                            location_no_          => location_no_,
                            lot_batch_no_         => lot_batch_no_,
                            serial_no_            => serial_no_for_stock_,
                            eng_chg_level_        => eng_chg_level_,
                            waiv_dev_rej_no_      => waiv_dev_rej_no_,
                            activity_seq_         => activity_seq_,
                            handling_unit_id_     => to_handling_unit_id_,
                            check_during_receipt_ => FALSE,
                            part_catalog_rec_     => part_catalog_rec_,
                            location_type_db_     => location_type_db_,
                            part_ownership_db_    => part_ownership_,
                            owning_customer_no_   => owning_customer_no_,
                            owning_vendor_no_     => vendor_no_);

   revised_price_ := price_ ;

   IF (price_ != 0) THEN

      inventory_part_rec_ := Inventory_Part_API.Get(contract_,part_no_);

      IF ((inventory_part_rec_.zero_cost_flag             = 'O' ) AND
          (inventory_part_rec_.inventory_valuation_method = 'ST')) THEN

         qty_onhand_ := Get_Qty_Onhand(contract_,
                                       part_no_,
                                       configuration_id_,
                                       location_no_,
                                       lot_batch_no_,
                                       serial_no_for_stock_,
                                       eng_chg_level_,
                                       waiv_dev_rej_no_,
                                       activity_seq_,
                                       to_handling_unit_id_);
         IF (NVL(qty_onhand_,0) = 0) THEN
            revised_price_ := 0 ;
         END IF;
      END IF;
   END IF;
   
   IF source_ref3_ IS NULL THEN 
      local_source_ref3_ := receipt_no_;
   ELSIF source_ref4_ IS NULL THEN 
      local_source_ref4_ := receipt_no_;
   END IF;
   
   Receive_Part_Impl___(transaction_id_               =>  transaction_id_,
                        accounting_id_                =>  accounting_id_,
                        trans_value_                  =>  trans_value_,
                        contract_                     =>  contract_,
                        part_no_                      =>  part_no_,
                        configuration_id_             =>  configuration_id_,
                        location_no_                  =>  location_no_,
                        lot_batch_no_                 =>  lot_batch_no_,
                        serial_no_                    =>  serial_no_,
                        eng_chg_level_                =>  eng_chg_level_,
                        waiv_dev_rej_no_              =>  waiv_dev_rej_no_,
                        activity_seq_                 =>  activity_seq_,
                        handling_unit_id_             =>  to_handling_unit_id_,
                        transaction_                  =>  transaction_,
                        expiration_date_              =>  expiration_date_,
                        quantity_                     =>  qty_received_,
                        quantity_reserved_            =>  0,
                        catch_quantity_               =>  catch_qty_received_,
                        source_ref1_                  =>  source_ref1_,
                        source_ref2_                  =>  source_ref2_,
                        source_ref3_                  =>  local_source_ref3_,
                        source_ref4_                  =>  local_source_ref4_,
                        source_ref5_                  =>  source_ref5_,
                        source_                       =>  NULL,
                        unissue_                      =>  FALSE,
                        unit_cost_                    =>  revised_price_,
                        source_ref_type_              =>  Order_Type_API.Decode(source_ref_type_),
                        vendor_no_                    =>  vendor_no_,
                        receipt_date_                 =>  receipt_date_,
                        condition_code_               =>  condition_code_,
                        part_ownership_               =>  part_ownership_,
                        owning_customer_no_           =>  owning_customer_no_,
                        cost_detail_tab_              =>  cost_detail_tab_,
                        set_qty_reversed_             =>  FALSE,
                        issue_transaction_id_         =>  NULL,
                        operational_condition_db_     =>  operational_condition_db_,
                        part_catalog_rec_             =>  part_catalog_rec_,
                        availability_control_id_      =>  NULL,
                        validate_hu_struct_position_  =>  FALSE,
                        ownership_transfer_reason_id_ =>  NULL,
                        del_note_no_                  => supplier_del_note_no_, 
                        del_note_date_                => del_note_date_);

   Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                         Site_API.Get_Company(contract_),
                                                         'N',
                                                         NULL,
                                                         FALSE,
                                                         NULL );

   IF (source_ref_type_ = Order_Type_API.DB_PURCHASE_ORDER AND comp_cost_transaction_id_ IS NOT NULL) THEN
      Invent_Trans_Interconnect_API.Connect_Transactions(transaction_id_, comp_cost_transaction_id_, 'PURCH COMPONENT COST');
   END IF;

   IF (TRUNC(receipt_date_)!= TRUNC(Site_API.Get_Site_Date(contract_))) THEN
      Inventory_Transaction_Hist_API.Modify_Date_Applied(dummy_char_, transaction_id_, TRUNC(receipt_date_));
   END IF;

   IF ( transit_eng_chg_level_ IS NOT NULL AND transit_eng_chg_level_ != eng_chg_level_ ) THEN
      IF ( Inventory_Part_Barcode_API.Check_Inv_Part_Barcode_Exist( contract_,
                                                                    part_no_,
                                                                    configuration_id_,
                                                                    lot_batch_no_,
                                                                    serial_no_,
                                                                    transit_eng_chg_level_,
                                                                    waiv_dev_rej_no_,
                                                                    activity_seq_ ) = Fnd_Boolean_API.DB_TRUE ) THEN
         Inventory_Part_Barcode_API.Change_Eng_Chg_Level( contract_,
                                                          part_no_,
                                                          configuration_id_,
                                                          lot_batch_no_,
                                                          serial_no_,
                                                          transit_eng_chg_level_,
                                                          waiv_dev_rej_no_,
                                                          activity_seq_,
                                                          eng_chg_level_ );
      END IF;
   END IF;

   IF ((sender_contract_ IS NOT NULL) AND ((part_ownership_ = Part_Ownership_API.DB_COMPANY_OWNED) OR 
        ((source_ref_type_ = Order_Type_API.DB_SHIPMENT_ORDER) AND (part_ownership_ IN (Part_Ownership_API.DB_CUSTOMER_OWNED,
                                                                                        Part_Ownership_API.DB_SUPPLIER_LOANED,
                                                                                        Part_Ownership_API.DB_SUPPLIER_RENTED, 
                                                                                        Part_Ownership_API.DB_COMPANY_RENTAL_ASSET))))) THEN
                                                                   
      IF (Site_API.Get_Company(sender_contract_) = Site_API.Get_Company(contract_)) THEN
         IF (transit_eng_chg_level_ IS NOT NULL) THEN
            eng_chg_in_transit_ := transit_eng_chg_level_;
         ELSE
            eng_chg_in_transit_ := eng_chg_level_;
         END IF;
         IF (remove_default_qty_ = db_false_) THEN

            Inventory_Part_In_Transit_API.Remove_From_Order_Transit( delivering_contract_       => sender_contract_,
                                                                     contract_                  => contract_,
                                                                     part_no_                   => part_no_,
                                                                     configuration_id_          => configuration_id_,
                                                                     lot_batch_no_              => lot_batch_no_,
                                                                     serial_no_                 => serial_no_,
                                                                     eng_chg_level_             => eng_chg_in_transit_,
                                                                     waiv_dev_rej_no_           => waiv_dev_rej_no_,
                                                                     handling_unit_id_          => from_handling_unit_id_,
                                                                     expiration_date_           => expiration_date_,
                                                                     delivering_warehouse_id_   => delivering_warehouse_id_,
                                                                     receiving_warehouse_id_    => receiving_warehouse_id_,
                                                                     activity_seq_              => activity_seq_,
                                                                     part_ownership_db_         => part_ownership_,
                                                                     owning_customer_no_        => NVL(owning_customer_no_, '*'),
                                                                     owning_vendor_no_          => CASE source_ref_type_ WHEN (Order_Type_API.DB_PURCHASE_ORDER) THEN '*' ELSE NVL(vendor_no_, '*') END,
                                                                     deliv_no_                  => 0,
                                                                     shipment_id_               => 0,
                                                                     shipment_line_no_          => 0,
                                                                     qty_to_remove_             => qty_received_,
                                                                     catch_qty_to_remove_       => catch_qty_received_,
                                                                     remove_unit_cost_          => FALSE );
         ELSIF (remove_default_qty_ = db_true_) THEN
            -- Only used in the Split Receipt functionality of Internal Order Transit
            Inventory_Part_In_Transit_API.Remove_From_Order_Transit( delivering_contract_       => sender_contract_,
                                                                     contract_                  => contract_,
                                                                     part_no_                   => part_no_,
                                                                     configuration_id_          => configuration_id_,
                                                                     lot_batch_no_              => '*',
                                                                     serial_no_                 => '*',
                                                                     eng_chg_level_             => eng_chg_in_transit_,
                                                                     waiv_dev_rej_no_           => waiv_dev_rej_no_,
                                                                     handling_unit_id_          => from_handling_unit_id_,
                                                                     expiration_date_           => expiration_date_,
                                                                     delivering_warehouse_id_   => delivering_warehouse_id_,
                                                                     receiving_warehouse_id_    => receiving_warehouse_id_,
                                                                     activity_seq_              => activity_seq_,
                                                                     part_ownership_db_         => part_ownership_,
                                                                     owning_customer_no_        => NVL(owning_customer_no_, '*'),
                                                                     owning_vendor_no_          => CASE source_ref_type_ WHEN (Order_Type_API.DB_PURCHASE_ORDER) THEN '*' ELSE NVL(vendor_no_, '*') END,
                                                                     deliv_no_                  => 0,
                                                                     shipment_id_               => 0,
                                                                     shipment_line_no_          => 0,
                                                                     qty_to_remove_             => qty_received_,
                                                                     catch_qty_to_remove_       => catch_qty_received_);
         END IF;
      END IF;
   END IF;
   
   IF (validate_hu_struct_position_) THEN
      Handling_Unit_API.Validate_Structure_Position(from_handling_unit_id_);
      Handling_Unit_API.Validate_Structure_Position(to_handling_unit_id_);
   END IF;
END Receive_Part_On_Order___;


-------------------- LU SPECIFIC PRIVATE METHODS ----------------------------
           
-- Receive_Part_On_Order__
--   Inserts quantities of inventory parts into inventory due to order arrivals.
PROCEDURE Receive_Part_On_Order__ (
   unattached_from_handling_unit_  OUT VARCHAR2,
   contract_                        IN VARCHAR2,
   part_no_                         IN VARCHAR2,
   configuration_id_                IN VARCHAR2,
   location_no_                     IN VARCHAR2,
   lot_batch_no_                    IN VARCHAR2,
   serial_no_                       IN VARCHAR2,
   eng_chg_level_                   IN VARCHAR2,
   waiv_dev_rej_no_                 IN VARCHAR2,
   activity_seq_                    IN NUMBER,
   handling_unit_id_                IN NUMBER,
   transaction_                     IN VARCHAR2,
   expiration_date_                 IN DATE,
   delivering_warehouse_id_         IN VARCHAR2,
   receiving_warehouse_id_          IN VARCHAR2,
   qty_received_                    IN NUMBER,
   catch_qty_received_              IN NUMBER,
   source_ref1_                     IN VARCHAR2,
   source_ref2_                     IN VARCHAR2,
   source_ref3_                     IN VARCHAR2,
   source_ref4_                     IN VARCHAR2,
   source_ref5_                     IN VARCHAR2,
   source_ref_type_                 IN VARCHAR2,
   receipt_no_                      IN VARCHAR2,
   vendor_no_                       IN VARCHAR2,
   receipt_date_                    IN DATE,
   price_                           IN NUMBER,
   cost_detail_tab_                 IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   part_ownership_                  IN VARCHAR2,
   owning_customer_no_              IN VARCHAR2,
   condition_code_                  IN VARCHAR2,
   sender_contract_                 IN VARCHAR2,
   remove_default_qty_              IN VARCHAR2,
   transit_eng_chg_level_           IN VARCHAR2,
   operational_condition_db_        IN VARCHAR2,
   comp_cost_transaction_id_        IN NUMBER,
   validate_hu_struct_position_     IN BOOLEAN  DEFAULT TRUE,
   transit_handling_unit_id_        IN VARCHAR2 DEFAULT NULL,
   supplier_del_note_no_            IN VARCHAR2 DEFAULT NULL,
   del_note_date_                   IN DATE     DEFAULT NULL)
IS   
   receive_succeeded_               BOOLEAN := FALSE;
BEGIN
   unattached_from_handling_unit_ := Fnd_Boolean_API.DB_FALSE;
   IF ((handling_unit_id_ != 0) AND (validate_hu_struct_position_)) THEN
      -- Set savepoint so that we can rollback if structure validation gives error.
      -- We need to have the structure validation after the Receive_Part_On_Order___ because of Split Into Serials. 
      @ApproveTransactionStatement(2017-01-12,Chfose)
      SAVEPOINT before_rec_part_handl_unit_;
   END IF;
   -- Do the initial receipt attempt while keeping the HU ID if such one is used. Do not include HU Structure Validation.
   Receive_Part_On_Order___(contract_                      => contract_,
                            part_no_                       => part_no_,
                            configuration_id_              => configuration_id_,
                            location_no_                   => location_no_,
                            lot_batch_no_                  => lot_batch_no_,
                            serial_no_                     => serial_no_,
                            eng_chg_level_                 => eng_chg_level_,
                            waiv_dev_rej_no_               => waiv_dev_rej_no_,
                            activity_seq_                  => activity_seq_,
                            from_handling_unit_id_         => NVL(transit_handling_unit_id_, handling_unit_id_),
                            to_handling_unit_id_           => handling_unit_id_,
                            transaction_                   => transaction_,
                            expiration_date_               => expiration_date_,
                            delivering_warehouse_id_       => delivering_warehouse_id_,
                            receiving_warehouse_id_        => receiving_warehouse_id_,
                            qty_received_                  => qty_received_,
                            catch_qty_received_            => catch_qty_received_,
                            source_ref1_                   => source_ref1_,
                            source_ref2_                   => source_ref2_,
                            source_ref3_                   => source_ref3_,
                            source_ref4_                   => source_ref4_,
                            source_ref5_                   => source_ref5_,
                            source_ref_type_               => source_ref_type_,
                            receipt_no_                    => receipt_no_,
                            vendor_no_                     => vendor_no_,
                            receipt_date_                  => receipt_date_,
                            price_                         => price_,
                            cost_detail_tab_               => cost_detail_tab_,
                            part_ownership_                => part_ownership_,
                            owning_customer_no_            => owning_customer_no_,
                            condition_code_                => condition_code_,
                            sender_contract_               => sender_contract_,
                            remove_default_qty_            => remove_default_qty_,
                            transit_eng_chg_level_         => transit_eng_chg_level_,
                            operational_condition_db_      => operational_condition_db_,
                            comp_cost_transaction_id_      => comp_cost_transaction_id_,
                            validate_hu_struct_position_   => FALSE,
                            supplier_del_note_no_          => supplier_del_note_no_,
                            del_note_date_                 => del_note_date_);

   IF ((handling_unit_id_ = 0) OR (NOT validate_hu_struct_position_)) THEN
      -- If we are not dealing with a handling unit or if the handling unit structure position should not be validated then we are done now.
      receive_succeeded_ := TRUE;
   ELSE
      -- receive of a quantity connected to a handling unit requires additional validations.
      DECLARE
         structure_error EXCEPTION;
         PRAGMA          EXCEPTION_INIT(structure_error,-20110);
      BEGIN
         -- Do the HU structure validation
         Handling_Unit_API.Validate_Structure_Position(handling_unit_id_);
         receive_succeeded_ := TRUE;
      EXCEPTION
         WHEN structure_error THEN
            -- The structure validation proves that the receipt was not sucessful. So we rollback everything.
            @ApproveTransactionStatement(2017-01-12,Chfose)
            ROLLBACK TO before_rec_part_handl_unit_;
            -- Now since the structure validation threw an error we check if this HU is connected to a parent HU.
            -- If so then we disconnect the HU from the parent and try again to perform the receipt of the HU.
            IF (Handling_Unit_API.Get_Parent_Handling_Unit_Id(handling_unit_id_) IS NOT NULL) THEN
               -- Set savepoint so that we can rollback if structure validation gives error.
               -- We need to have the structure validation after the Receive_Part_On_Order___ because of Split Into Serials. 
               @ApproveTransactionStatement(2017-01-12,Chfose)
               SAVEPOINT before_rec_part_handl_unit_;
               Handling_Unit_API.Modify_Parent_Handling_Unit_Id(handling_unit_id_         => handling_unit_id_, 
                                                                parent_handling_unit_id_  => NULL);
               -- Do a second receipt attempt while keeping the HU ID, now disconnected from its parent. Do not include HU Structure Validation.
               Receive_Part_On_Order___(contract_                      => contract_,
                                        part_no_                       => part_no_,
                                        configuration_id_              => configuration_id_,
                                        location_no_                   => location_no_,
                                        lot_batch_no_                  => lot_batch_no_,
                                        serial_no_                     => serial_no_,
                                        eng_chg_level_                 => eng_chg_level_,
                                        waiv_dev_rej_no_               => waiv_dev_rej_no_,
                                        activity_seq_                  => activity_seq_,
                                        from_handling_unit_id_         => NVL(transit_handling_unit_id_, handling_unit_id_),
                                        to_handling_unit_id_           => handling_unit_id_,
                                        transaction_                   => transaction_,
                                        expiration_date_               => expiration_date_,
                                        delivering_warehouse_id_       => delivering_warehouse_id_,
                                        receiving_warehouse_id_        => receiving_warehouse_id_,
                                        qty_received_                  => qty_received_,
                                        catch_qty_received_            => catch_qty_received_,
                                        source_ref1_                   => source_ref1_,
                                        source_ref2_                   => source_ref2_,
                                        source_ref3_                   => source_ref3_,
                                        source_ref4_                   => source_ref4_,
                                        source_ref5_                   => source_ref5_,
                                        source_ref_type_               => source_ref_type_,
                                        receipt_no_                    => receipt_no_,
                                        vendor_no_                     => vendor_no_,
                                        receipt_date_                  => receipt_date_,
                                        price_                         => price_,
                                        cost_detail_tab_               => cost_detail_tab_,
                                        part_ownership_                => part_ownership_,
                                        owning_customer_no_            => owning_customer_no_,
                                        condition_code_                => condition_code_,
                                        sender_contract_               => sender_contract_,
                                        remove_default_qty_            => remove_default_qty_,
                                        transit_eng_chg_level_         => transit_eng_chg_level_,
                                        operational_condition_db_      => operational_condition_db_,
                                        comp_cost_transaction_id_      => comp_cost_transaction_id_,
                                        validate_hu_struct_position_   => FALSE);
               BEGIN
                  -- Do the HU structure validation to see if the disconnection of the HU from the parent means that we can receive the HU.
                  Handling_Unit_API.Validate_Structure_Position(handling_unit_id_);
                  receive_succeeded_ := TRUE;
               EXCEPTION
                  WHEN structure_error THEN
                     -- The structure validation proves that the receipt was not sucessful. So we rollback everything.
                     @ApproveTransactionStatement(2017-01-12,Chfose)
                     ROLLBACK TO before_rec_part_handl_unit_;
               END;
            END IF;
            IF NOT (receive_succeeded_) THEN
               -- Try to receive again with the quantity unattached from the handling unit.
               Receive_Part_On_Order___(contract_                      => contract_,
                                        part_no_                       => part_no_,
                                        configuration_id_              => configuration_id_,
                                        location_no_                   => location_no_,
                                        lot_batch_no_                  => lot_batch_no_,
                                        serial_no_                     => serial_no_,
                                        eng_chg_level_                 => eng_chg_level_,
                                        waiv_dev_rej_no_               => waiv_dev_rej_no_,
                                        activity_seq_                  => activity_seq_,
                                        from_handling_unit_id_         => NVL(transit_handling_unit_id_, handling_unit_id_),
                                        to_handling_unit_id_           => 0,
                                        transaction_                   => transaction_,
                                        expiration_date_               => expiration_date_,
                                        delivering_warehouse_id_       => delivering_warehouse_id_,
                                        receiving_warehouse_id_        => receiving_warehouse_id_,
                                        qty_received_                  => qty_received_,
                                        catch_qty_received_            => catch_qty_received_,
                                        source_ref1_                   => source_ref1_,
                                        source_ref2_                   => source_ref2_,
                                        source_ref3_                   => source_ref3_,
                                        source_ref4_                   => source_ref4_,
                                        source_ref5_                   => source_ref5_,
                                        source_ref_type_               => source_ref_type_,
                                        receipt_no_                    => receipt_no_,
                                        vendor_no_                     => vendor_no_,
                                        receipt_date_                  => receipt_date_,
                                        price_                         => price_,
                                        cost_detail_tab_               => cost_detail_tab_,
                                        part_ownership_                => part_ownership_,
                                        owning_customer_no_            => owning_customer_no_,
                                        condition_code_                => condition_code_,
                                        sender_contract_               => sender_contract_,
                                        remove_default_qty_            => remove_default_qty_,
                                        transit_eng_chg_level_         => transit_eng_chg_level_,
                                        operational_condition_db_      => operational_condition_db_,
                                        comp_cost_transaction_id_      => comp_cost_transaction_id_,
                                        validate_hu_struct_position_   => TRUE);
               -- Indicate that the receipt lead to an unattachment of the quantity received from the Handling Unit.
               unattached_from_handling_unit_ := Fnd_Boolean_API.DB_TRUE;
            END IF;
      END;
   END IF;
END Receive_Part_On_Order__;


-- Create_Count_Report__
--   Used for create count report. This method just make a deferred call.
PROCEDURE Create_Count_Report__ (
   attrib_ IN VARCHAR2 )
IS
   ptr_                          NUMBER;
   name_                         VARCHAR2(30);
   value_                        VARCHAR2(2000);
   user_                         VARCHAR2(30);
   contract_                     VARCHAR2(5);
   inv_list_no_                  VARCHAR2(15);
   second_commodity_             VARCHAR2(5);
   max_qty_onhand_               NUMBER;
   exclude_since_                NUMBER;
   cycle_code_db_                VARCHAR2(50);
   freeze_code_db_               VARCHAR2(50);
   include_all_qty_db_           VARCHAR2(20);
   process_count_                NUMBER;
   info_                         VARCHAR2(2000);
   printer_id_                   VARCHAR2(100);
   print_attr_                   VARCHAR2(200);
   report_attr_                  VARCHAR2(2000);
   parameter_attr_               VARCHAR2(2000);
   detailed_result_key_          NUMBER;
   aggregated_result_key_        NUMBER;
   print_job_id_                 NUMBER;
   printer_id_list_              VARCHAR2(32000);
   exclude_customer_owned_       VARCHAR2(20);
   exclude_supplier_loaned_      VARCHAR2(20);
   exclude_consignment_          VARCHAR2(20);
   exclude_company_owned_        VARCHAR2(20);
   exclude_rotable_pool_         VARCHAR2(10);
   exclude_fa_rotable_pool_      VARCHAR2(10);
   exclude_project_inventory_    VARCHAR2(20);
   exclude_standard_inventory_   VARCHAR2(20);
   exclude_supplier_rented_      VARCHAR2(20);
   exclude_company_rental_asset_ VARCHAR2(20);
   warehouse_id_                 VARCHAR2(15);
   bay_id_                       VARCHAR2(5);
   row_id_                       VARCHAR2(5);
   tier_id_                      VARCHAR2(5); 
   bin_id_                       VARCHAR2(5);
   storage_zone_id_              VARCHAR2(30);
   part_no_                      VARCHAR2(2000);
   project_id_                   INVENTORY_PART_IN_STOCK_TAB.project_id%type;
   location_group_               VARCHAR2(5);
   abc_class_                    VARCHAR2(1);
   frequency_class_db_           VARCHAR2(20);
   lifecycle_stage_db_           VARCHAR2(20);
   print_count_report_db_        VARCHAR2(20);
   handling_unit_type_id_        VARCHAR2(25);
   top_handling_unit_type_id_    VARCHAR2(25);
   handling_category_type_id_    VARCHAR2(25);
   top_handling_category_type_id_   VARCHAR2(25);
   include_full_qty_of_hu_db_    VARCHAR2(1) := 'N';
   exclude_attached_to_hu_       VARCHAR2(1) := 'N';
   exclude_not_attached_to_hu_   VARCHAR2(1) := 'N';
BEGIN
   --
   -- Unpack attribute string
   --
   WHILE (Client_SYS.Get_Next_From_Attr(attrib_, ptr_, name_, value_)) LOOP
      IF (name_ = 'BATCH_USER') THEN
         user_ := value_;
      ELSIF (name_ = 'CONTRACT') THEN
         contract_ := value_;
      ELSIF (name_ = 'SECOND_COMMODITY') THEN
         second_commodity_:= value_;
      ELSIF (name_ = 'MAX_QTY_ONHAND') THEN
         max_qty_onhand_ := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'EXCLUDE_SINCE') THEN
         exclude_since_ := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'CYCLE_CODE_DB') THEN
         cycle_code_db_ := value_;
      ELSIF (name_ = 'FREEZE_CODE_DB') THEN
         freeze_code_db_ := value_;
      ELSIF (name_ = 'PROCESS_COUNT') THEN
         process_count_ := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'EXCLUDE_CUSTOMER_OWNED') THEN
         exclude_customer_owned_ := value_;
      ELSIF (name_ = 'EXCLUDE_SUPPLIER_LOANED') THEN
         exclude_supplier_loaned_ := value_;
      ELSIF (name_ = 'EXCLUDE_CONSIGNMENT') THEN
         exclude_consignment_ := value_;
      ELSIF (name_ = 'EXCLUDE_COMPANY_OWNED') THEN
         exclude_company_owned_ := value_;
      ELSIF (name_ = 'INCLUDE_ALL_QTY_DB') THEN
         include_all_qty_db_ := value_;
      ELSIF (name_ = 'EXCLUDE_ROTABLE_POOL') THEN
         exclude_rotable_pool_ := value_;
      ELSIF (name_ = 'EXCLUDE_FA_ROTABLE_POOL') THEN
         exclude_fa_rotable_pool_ := value_;
      ELSIF (name_ = 'EXCLUDE_PROJECT_INVENTORY') THEN
         exclude_project_inventory_ := value_;
      ELSIF (name_ = 'EXCLUDE_STANDARD_INVENTORY') THEN
         exclude_standard_inventory_ := value_;
      ELSIF (name_ = 'EXCLUDE_SUPPLIER_RENTED') THEN
         exclude_supplier_rented_ := value_;
      ELSIF (name_ = 'EXCLUDE_COMPANY_RENTAL_ASSET') THEN
         exclude_company_rental_asset_ := value_;
      ELSIF (name_ = 'EXCLUDE_ATTACHED_TO_HU') THEN
         exclude_attached_to_hu_ := value_;
      ELSIF (name_ = 'EXCLUDE_NOT_ATTACHED_TO_HU') THEN
         exclude_not_attached_to_hu_ := value_;
      ELSIF (name_ = 'PROJECT_ID') THEN
         project_id_ := value_;
      ELSIF (name_ = 'WAREHOUSE_ID') THEN
         warehouse_id_ := value_;
      ELSIF (name_ = 'BAY_ID') THEN
         bay_id_:= value_;
      ELSIF (name_ = 'ROW_ID') THEN
         row_id_ := value_;
      ELSIF (name_ = 'TIER_ID') THEN
         tier_id_ := value_;
      ELSIF (name_ = 'BIN_ID') THEN
         bin_id_ := value_;
      ELSIF (name_ = 'STORAGE_ZONE_ID') THEN
         storage_zone_id_ := value_;
      ELSIF (name_ = 'PART_NO') THEN
         part_no_ := value_;  
      ELSIF (name_ = 'LOCATION_GROUP') THEN
         location_group_ := value_;         
      ELSIF (name_ = 'ABC_CLASS') THEN
         abc_class_ := value_;         
      ELSIF (name_ = 'FREQUENCY_CLASS_DB') THEN
         frequency_class_db_ := value_;         
      ELSIF (name_ = 'LIFECYCLE_STAGE_DB') THEN
         lifecycle_stage_db_ := value_;  
      ELSIF (name_ = 'PRINT_COUNT_REPORT_DB') THEN
         print_count_report_db_ := value_;
      ELSIF (name_ = 'INCLUDE_FULL_QTY_OF_HU_DB') THEN
         include_full_qty_of_hu_db_ := value_;
      ELSIF (name_ = 'HANDLING_UNIT_TYPE_ID') THEN
         handling_unit_type_id_ := value_;
      ELSIF (name_ = 'TOP_HANDLING_UNIT_TYPE_ID') THEN
         top_handling_unit_type_id_ := value_;
      ELSIF (name_ = 'HANDLING_CATEGORY_TYPE_ID') THEN
         handling_category_type_id_ := value_;
      ELSIF (name_ = 'TOP_HANDLING_CATEGORY_TYPE_ID') THEN
         top_handling_category_type_id_ := value_;   
      ELSE
         Error_SYS.Item_Not_Exist(lu_name_, name_, value_);
      END IF;
   END LOOP;

   Create_Count_Report___(inv_list_no_,
                          contract_,
                          warehouse_id_,
                          bay_id_ ,
                          row_id_,
                          tier_id_, 
                          bin_id_, 
                          storage_zone_id_,
                          second_commodity_,
                          part_no_,                          
                          max_qty_onhand_,
                          exclude_since_,
                          cycle_code_db_,
                          freeze_code_db_,
                          process_count_,
                          project_id_,
                          include_all_qty_db_,
                          exclude_customer_owned_,
                          exclude_supplier_loaned_,
                          exclude_consignment_,
                          exclude_company_owned_,
                          exclude_rotable_pool_,
                          exclude_fa_rotable_pool_,
                          exclude_project_inventory_,
                          exclude_standard_inventory_,                          
                          exclude_supplier_rented_,
                          exclude_company_rental_asset_,
                          exclude_attached_to_hu_,
                          exclude_not_attached_to_hu_,
                          location_group_,
                          abc_class_,
                          frequency_class_db_,
                          lifecycle_stage_db_,
                          include_full_qty_of_hu_db_,                     
                          handling_unit_type_id_,
                          top_handling_unit_type_id_,
                          handling_category_type_id_,
                          top_handling_category_type_id_);


   IF (inv_list_no_ IS NULL) THEN
      info_ := Language_SYS.Translate_Constant(lu_name_, 'NOCOUNTREP: No data found for entered search criteria. Count Report not created.');
      --
      -- Logg the error in F1
      --
      Transaction_SYS.Set_Status_Info(info_);
   ELSE
      

      IF print_count_report_db_ IN (Invent_Report_Print_Option_API.DB_DETAILED, Invent_Report_Print_Option_API.DB_BOTH) THEN
         -- Generate a new print job id
         printer_id_ := Printer_Connection_API.Get_Default_Printer(Fnd_Session_API.Get_Fnd_User, 'COUNTING_REPORT_PRINT_REP');
         Client_SYS.Clear_Attr(print_attr_);
         Client_SYS.Add_To_Attr('PRINTER_ID', printer_id_, print_attr_);
         Print_Job_API.New(print_job_id_, print_attr_); 

         -- Create the report
         Client_SYS.Clear_Attr(report_attr_);
         Client_SYS.Add_To_Attr('REPORT_ID', 'COUNTING_REPORT_PRINT_REP', report_attr_);
         Client_SYS.Clear_Attr(parameter_attr_);
         Client_SYS.Add_To_Attr('INV_LIST_NO', inv_list_no_, parameter_attr_);
         Archive_API.New_Instance(detailed_result_key_, report_attr_, parameter_attr_);
   
         -- Connect the created report to a print job id
         Client_SYS.Clear_Attr(print_attr_);
         Client_SYS.Add_To_Attr('PRINT_JOB_ID', print_job_id_, print_attr_);
         Client_SYS.Add_To_Attr('RESULT_KEY',   detailed_result_key_,   print_attr_);
         Client_SYS.Add_To_Attr('OPTIONS',      'COPIES(1)',   print_attr_);
         Print_Job_Contents_API.New_Instance(print_attr_);
   
         -- Send the print job to the printer.
         Logical_Printer_API.Enumerate_Printer_Id(printer_id_list_);
         IF (printer_id_list_ IS NOT NULL) THEN
            IF (print_job_id_ IS NOT NULL) THEN
               Print_Job_API.Print(print_job_id_);
            END IF;
         END IF;
         print_job_id_ := NULL;
      END IF;


      IF print_count_report_db_ IN (Invent_Report_Print_Option_API.DB_AGGREGATED, Invent_Report_Print_Option_API.DB_BOTH) THEN
         -- Generate a new print job id
         printer_id_ := Printer_Connection_API.Get_Default_Printer(Fnd_Session_API.Get_Fnd_User, 'COUNTING_REPORT_HU_REP');
         Client_SYS.Clear_Attr(print_attr_);
         Client_SYS.Add_To_Attr('PRINTER_ID', printer_id_, print_attr_);
         Print_Job_API.New(print_job_id_, print_attr_);
   
         -- Create the report for aggregated handling units 
         Client_SYS.Clear_Attr(report_attr_);
         Client_SYS.Add_To_Attr('REPORT_ID', 'COUNTING_REPORT_HU_REP', report_attr_);
         Client_SYS.Clear_Attr(parameter_attr_);
         Client_SYS.Add_To_Attr('INV_LIST_NO', inv_list_no_, parameter_attr_);
         Archive_API.New_Instance(aggregated_result_key_, report_attr_, parameter_attr_);
   
         -- Connect the created report to a print job id
         Client_SYS.Clear_Attr(print_attr_);
         Client_SYS.Add_To_Attr('PRINT_JOB_ID', print_job_id_, print_attr_);
         Client_SYS.Add_To_Attr('RESULT_KEY',   aggregated_result_key_,   print_attr_);
         -- Copies set to 2, just to avoid issues with 'Unable to register new print job. The Same report is already being processed in the print job [x]. Please allow more time for it to finish.'
         -- when print_count_report_db_ is BOTH. So COPIES don't seem to have anything to do with the no of copies that the name otherways would imply or is it just luck that it solved this issue.
         Client_SYS.Add_To_Attr('OPTIONS',      'COPIES(2)',   print_attr_);   
         Print_Job_Contents_API.New_Instance(print_attr_);
   
         -- Send the print job to the printer.
         Logical_Printer_API.Enumerate_Printer_Id(printer_id_list_);
         IF (printer_id_list_ IS NOT NULL) THEN
            IF (print_job_id_ IS NOT NULL) THEN
               Print_Job_API.Print(print_job_id_);
            END IF;
         END IF;
      END IF;

      IF print_count_report_db_ = Invent_Report_Print_Option_API.DB_BOTH THEN
         info_ := Language_SYS.Translate_Constant(lu_name_, 'COUNTREPORT2: The Counting Reports was created successfully. The Report Keys are :P1 and :P2.', NULL, detailed_result_key_, aggregated_result_key_);
      ELSIF print_count_report_db_ IN (Invent_Report_Print_Option_API.DB_AGGREGATED, Invent_Report_Print_Option_API.DB_DETAILED) THEN
         info_ := Language_SYS.Translate_Constant(lu_name_, 'COUNTREPORT: The Counting Report was created successfully. The Report Key is :P1.', NULL, NVL(detailed_result_key_, aggregated_result_key_));
      ELSE
         info_ := Language_SYS.Translate_Constant(lu_name_, 'COUNTREPORT3: The Counting Report was created successfully.', NULL);
      END IF;

      Transaction_SYS.Set_Progress_Info(info_);
   END IF;
END Create_Count_Report__;


PROCEDURE Optimize_Using_Putaway__ (
   message_ IN VARCHAR2 )
IS
   count_                           NUMBER;
   name_arr_                        Message_SYS.name_table;
   value_arr_                       Message_SYS.line_table;
   available_stock_tab_             Available_Stock_Tab;
   dummy_                           VARCHAR2(2000);
   contract_                        INVENTORY_PART_IN_STOCK_TAB.contract%TYPE;
   part_no_                         INVENTORY_PART_IN_STOCK_TAB.part_no%TYPE := '%';
   warehouse_id_                    INVENTORY_PART_IN_STOCK_TAB.warehouse%TYPE := '%';
   bay_id_                          INVENTORY_PART_IN_STOCK_TAB.bay_no%TYPE := '%';
   tier_id_                         INVENTORY_PART_IN_STOCK_TAB.tier_no%TYPE := '%';
   row_id_                          INVENTORY_PART_IN_STOCK_TAB.row_no%TYPE := '%';
   location_type_db_                INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE := '%';
   location_group_                  warehouse_bay_bin_tab.location_group%TYPE := '%';
   today_                           DATE;
   expiration_control_              VARCHAR2(11);
   serial_counter_                  PLS_INTEGER;
   previous_serial_part_no_         INVENTORY_PART_IN_STOCK_TAB.part_no%TYPE;
   previous_serial_config_id_       INVENTORY_PART_IN_STOCK_TAB.configuration_id%TYPE;
   previous_serial_location_no_     INVENTORY_PART_IN_STOCK_TAB.location_no%TYPE;
   previous_serial_lot_batch_no_    INVENTORY_PART_IN_STOCK_TAB.lot_batch_no%TYPE;
   previous_serial_eng_chg_level_   INVENTORY_PART_IN_STOCK_TAB.lot_batch_no%TYPE;
   previous_serial_wdr_no_          INVENTORY_PART_IN_STOCK_TAB.waiv_dev_rej_no%TYPE;
   previous_serial_activity_seq_    INVENTORY_PART_IN_STOCK_TAB.activity_seq%TYPE;
   previous_serial_handl_unit_id_   INVENTORY_PART_IN_STOCK_TAB.handling_unit_id%TYPE;
   serial_no_tab_                   Part_Serial_Catalog_API.Serial_No_Tab;
   putaway_previous_serials_        BOOLEAN;
   putaway_current_record_          BOOLEAN;
   add_current_serial_              BOOLEAN;
   part_has_operative_zone_         BOOLEAN;
   last_calendar_date_              DATE         := Database_Sys.last_calendar_date_;
   
   CURSOR get_location IS
      SELECT ipis.part_no,
             ipis.location_no,         
             ipis.lot_batch_no,
             ipis.serial_no,
             ipis.eng_chg_level,
             ipis.waiv_dev_rej_no,
             ipis.configuration_id,
             ipis.activity_seq,
             ipis.handling_unit_id,
             ipis.qty_onhand - ipis.qty_reserved   qty_available,
             ipis.warehouse,
             ipis.bay_no,
             ipis.tier_no,
             ipis.row_no,
             ipis.bin_no,
             ipis.expiration_date,
             ipis.receipt_date,
             ipis.warehouse_route_order,
             ipis.bay_route_order,
             ipis.row_route_order,
             ipis.tier_route_order,
             ipis.bin_route_order,
             NULL,
             NULL
        FROM inventory_part_in_stock_avail ipis,
             warehouse_bay_bin_tab         wbb
       WHERE ipis.contract  = wbb.contract
         AND ipis.warehouse = wbb.warehouse_id
         AND ipis.bay_no    = wbb.bay_id
         AND ipis.row_no    = wbb.row_id
         AND ipis.tier_no   = wbb.tier_id
         AND ipis.bin_no    = wbb.bin_id
         AND ipis.part_movement_control_db  = Part_Movement_Control_API.DB_ALL_ALLOWED
         AND ipis.location_type_db IN (Inventory_Location_Type_API.DB_PICKING,
                                       Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                       Inventory_Location_Type_API.DB_PRODUCTION_LINE)
         AND ipis.freeze_flag_db = 'N'
         AND ((NVL(ipis.expiration_date, last_calendar_date_) > today_
                 AND expiration_control_ = 'NOT EXPIRED')
             OR (NVL(ipis.expiration_date, last_calendar_date_) <= today_
                 AND expiration_control_ = 'EXPIRED'))
         AND ipis.qty_onhand - ipis.qty_reserved > 0
         AND ipis.rotable_part_pool_id IS NULL
         AND ipis.contract         =    contract_
         AND ipis.part_no          LIKE part_no_
         AND ipis.warehouse        LIKE warehouse_id_
         AND ipis.bay_no           LIKE bay_id_
         AND ipis.tier_no          LIKE tier_id_
         AND ipis.row_no           LIKE row_id_
         AND ipis.location_type_db LIKE location_type_db_
         AND wbb.location_group    LIKE location_group_
      ORDER BY part_no, location_no;
BEGIN

   Message_SYS.Get_Attributes(message_, count_, name_arr_, value_arr_);

   FOR n_ IN 1..count_ LOOP
      IF (name_arr_(n_) = 'CONTRACT') THEN
         contract_ := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'PART_NO') THEN
         part_no_ := NVL(value_arr_(n_),'%');
      ELSIF (name_arr_(n_) = 'WAREHOUSE_ID') THEN
         warehouse_id_ := NVL(value_arr_(n_),'%');
      ELSIF (name_arr_(n_) = 'BAY_ID') THEN
         bay_id_ := NVL(value_arr_(n_),'%');
      ELSIF (name_arr_(n_) = 'TIER_ID') THEN
         tier_id_ := NVL(value_arr_(n_),'%');
      ELSIF (name_arr_(n_) = 'ROW_ID') THEN
         row_id_ := NVL(value_arr_(n_),'%');
      ELSIF (name_arr_(n_) = 'LOCATION_TYPE') THEN
         location_type_db_ := NVL(value_arr_(n_),'%');
      ELSIF (name_arr_(n_) = 'LOCATION_GROUP') THEN
         location_group_ := NVL(value_arr_(n_),'%');
      ELSE
         Error_SYS.Record_General(lu_name_, 'INCORRECT_MESSAGE: Item :P1 can not be used in method Optimize_Using_Putaway__.');
      END IF;
   END LOOP;
   today_              := TRUNC(Site_API.Get_Site_Date(contract_));
   
   Inventory_Event_Manager_API.Start_Session;
   FOR i IN 1..2 LOOP
      IF (i = 1) THEN
         expiration_control_ := 'NOT EXPIRED';
      ELSE
         expiration_control_ := 'EXPIRED';
      END IF;

      OPEN  get_location;
      FETCH get_location BULK COLLECT INTO available_stock_tab_;
      CLOSE get_location;

      available_stock_tab_ := Invent_Part_Putaway_Zone_API.Get_Zone_And_Fifo_Sorted_Stock(contract_,
                                                                                          available_stock_tab_);
      serial_no_tab_.DELETE;
      serial_counter_                := 0;
      previous_serial_part_no_       := string_null_;
      previous_serial_config_id_     := string_null_;
      previous_serial_location_no_   := string_null_;
      previous_serial_lot_batch_no_  := string_null_;
      previous_serial_eng_chg_level_ := string_null_;
      previous_serial_wdr_no_        := string_null_;
      previous_serial_activity_seq_  := -99999999999;
      previous_serial_handl_unit_id_ := -99999999999;

      IF (available_stock_tab_.COUNT > 0) THEN
         FOR i IN available_stock_tab_.FIRST..available_stock_tab_.LAST LOOP

            part_has_operative_zone_ := Invent_Part_Putaway_Zone_API.Part_Has_Operative_Zone(contract_,
                                                                                             available_stock_tab_(i).part_no);
            IF (part_has_operative_zone_) THEN
               putaway_previous_serials_ := FALSE;
               putaway_current_record_   := FALSE;
               add_current_serial_       := FALSE;

               IF (available_stock_tab_(i).serial_no = '*') THEN
                  -- Putaway should be called immediately for any non-serial-tracked record.
                  -- But first need to perform Putaway for all earlier collected serials in serial_no_tab_.
                  putaway_previous_serials_ := TRUE;
                  putaway_current_record_   := TRUE;
               ELSE
                  -- Current record is serial tracked
                  IF ((available_stock_tab_(i).part_no          != previous_serial_part_no_      ) OR
                      (available_stock_tab_(i).configuration_id != previous_serial_config_id_    ) OR
                      (available_stock_tab_(i).location_no      != previous_serial_location_no_  ) OR
                      (available_stock_tab_(i).lot_batch_no     != previous_serial_lot_batch_no_ ) OR
                      (available_stock_tab_(i).eng_chg_level    != previous_serial_eng_chg_level_) OR
                      (available_stock_tab_(i).waiv_dev_rej_no  != previous_serial_wdr_no_       ) OR
                      (available_stock_tab_(i).activity_seq     != previous_serial_activity_seq_ ) OR 
                      (available_stock_tab_(i).handling_unit_id != previous_serial_handl_unit_id_)) THEN
                     -- Current record has different keys that previously collected serials. To call
                     -- Putaway for the preiously collected serials.
                     putaway_previous_serials_ := TRUE;
                  END IF;
                  -- Add current serial to the collection. 
                  add_current_serial_ := TRUE;
               END IF;

               IF (putaway_previous_serials_) THEN
                  IF (serial_no_tab_.COUNT > 0) THEN
                     Putaway___(dummy_,
                                contract_,
                                previous_serial_part_no_,
                                previous_serial_config_id_,
                                previous_serial_location_no_,
                                previous_serial_lot_batch_no_,
                                serial_no_tab_,
                                previous_serial_eng_chg_level_,
                                previous_serial_wdr_no_,
                                previous_serial_activity_seq_,
                                previous_serial_handl_unit_id_,
                                'PUTAWAY');
                     serial_no_tab_.DELETE;
                     serial_counter_ := 0;
                  END IF;
               END IF;
               IF (putaway_current_record_) THEN
                  Putaway___(dummy_,
                             contract_,
                             available_stock_tab_(i).part_no,
                             available_stock_tab_(i).configuration_id,
                             available_stock_tab_(i).location_no,
                             available_stock_tab_(i).lot_batch_no,
                             serial_no_tab_,
                             available_stock_tab_(i).eng_chg_level,
                             available_stock_tab_(i).waiv_dev_rej_no,
                             available_stock_tab_(i).activity_seq,
                             available_stock_tab_(i).handling_unit_id,
                             'PUTAWAY');
               END IF;
               IF (add_current_serial_) THEN
                  serial_counter_ := serial_counter_ + 1;
                  serial_no_tab_(serial_counter_).serial_no := available_stock_tab_(i).serial_no;
                  previous_serial_part_no_       := available_stock_tab_(i).part_no;
                  previous_serial_config_id_     := available_stock_tab_(i).configuration_id;
                  previous_serial_location_no_   := available_stock_tab_(i).location_no;
                  previous_serial_lot_batch_no_  := available_stock_tab_(i).lot_batch_no;
                  previous_serial_eng_chg_level_ := available_stock_tab_(i).eng_chg_level;
                  previous_serial_wdr_no_        := available_stock_tab_(i).waiv_dev_rej_no;
                  previous_serial_activity_seq_  := available_stock_tab_(i).activity_seq;
                  previous_serial_handl_unit_id_ := available_stock_tab_(i).handling_unit_id;
               END IF;
            END IF; -- part has putaway zone(s)
         END LOOP;
         IF (serial_no_tab_.COUNT > 0) THEN
            Putaway___(dummy_,
                       contract_,
                       previous_serial_part_no_,
                       previous_serial_config_id_,
                       previous_serial_location_no_,
                       previous_serial_lot_batch_no_,
                       serial_no_tab_,
                       previous_serial_eng_chg_level_,
                       previous_serial_wdr_no_,
                       previous_serial_activity_seq_,
                       previous_serial_handl_unit_id_,
                       'PUTAWAY');
         END IF;
      END IF;
   END LOOP;
   Inventory_Event_Manager_API.Finish_Session;
END Optimize_Using_Putaway__;


-- Undo_Move_To_Order_Transit___
--   Use when undo the return rework and undo the delivery in intersite flow. 
--   This will create reverse transactions and remove goods from transit.
PROCEDURE Undo_Move_To_Order_Transit___ (
   undo_move_to_order_transit_   OUT BOOLEAN,
   return_cor_transaction_id_    OUT NUMBER,
   return_transaction_rec_       OUT Inventory_Transaction_Hist_API.Public_Rec,   
   unissue_transaction_          IN  VARCHAR2,
   catch_quantity_               IN  NUMBER,   
   quantity_                     IN  NUMBER,
   transaction_id_issue_         IN  NUMBER )
IS
   connected_transaction_id_     NUMBER;   
   quantity_undo_                NUMBER;
   reverse_cor_transaction_      VARCHAR2(10);   
   issue_transaction_rec_        Inventory_Transaction_Hist_API.Public_Rec;
   dest_contract_                INVENTORY_PART_IN_STOCK_TAB.contract%TYPE;
   dest_warehouse_id_            INVENTORY_PART_IN_STOCK_TAB.warehouse%TYPE;
   delivering_warehouse_id_      INVENTORY_PART_IN_STOCK_TAB.warehouse%TYPE;
BEGIN
   -- Fetch information on the original transaction to be reversed i.e. RETWORKINT, SHIPTRAN
   issue_transaction_rec_ := Inventory_Transaction_Hist_API.Get(transaction_id_issue_);   
   
   IF (unissue_transaction_ != 'UND-SHPODW') THEN
      -- Finding the corresponding 'RINTORDTR' transaction which is connected to original transaction RETWORKINT and reversing it using 'RINTOTRCOR'
      -- Finding the corresponding 'INTORDTR' transaction which is connected to original transaction SHIPTRAN and reversing it using 'UNINTORDTR'   
      connected_transaction_id_  := Invent_Trans_Interconnect_API.Get_Connected_Transaction_Id(transaction_id_issue_, 'INTERSITE TRANSFER');
      return_transaction_rec_    := Inventory_Transaction_Hist_API.Get(connected_transaction_id_);   
   END IF;
   
   -- Handle RINTOTRCOR and UNINTORDTR in a different way to other reverse transactions
   IF (unissue_transaction_ IN ('RETCORWINT', 'UNSHIPTRAN', 'COUNSHPTRN', 'UNSHIPDIR', 'COUNSHPDIR', 'UNINPODRIM', 'UNPODRINEM', 'UND-SHPODS')) THEN       
      IF return_transaction_rec_.transaction_code IN ('RINTORDTR', 'RINTORDTRX') THEN
         reverse_cor_transaction_ := 'RINTOTRCOR';
      END IF;
      IF return_transaction_rec_.transaction_code IN ('INTORDTR') THEN
         reverse_cor_transaction_ := 'UNINTORDTR';
      END IF;

      -- convert qty to the correct inv uom
      quantity_undo_ :=Inventory_Part_API.Get_Site_Converted_Qty(issue_transaction_rec_.contract,
                                                                 return_transaction_rec_.part_no,
                                                                 return_transaction_rec_.contract,
                                                                 quantity_,
                                                                 'ADD');

      -- Reverse 'RINTORDTR', 'INTORDTR' and update Transit Object
      Inventory_Transaction_Hist_API.Reverse_Transaction(transaction_id_        => return_cor_transaction_id_,
                                                         transaction_           => reverse_cor_transaction_,
                                                         pos_diff_transaction_  => 'INVREVTR-',
                                                         neg_diff_transaction_  => 'INVREVTR+',
                                                         quantity_              => quantity_undo_,
                                                         catch_quantity_        => catch_quantity_,
                                                         old_transaction_id_    => connected_transaction_id_,
                                                         source_                => NULL );
      
      IF (return_cor_transaction_id_ IS NOT NULL) THEN
         Inventory_Transaction_Hist_API.Set_Original_Transaction_Id(return_cor_transaction_id_,
                                                                    connected_transaction_id_);
      END IF;
      undo_move_to_order_transit_ := TRUE;
   ELSIF (unissue_transaction_ = 'UND-SHPODW') THEN
      $IF (Component_Shpmnt_SYS.INSTALLED) $THEN
         Shipment_API.Get_Sender_Rece_Contract_Whse(dest_contract_, dest_warehouse_id_, delivering_warehouse_id_, issue_transaction_rec_.source_ref5);
      $ELSE
         Error_SYS.Component_Not_Exist('SHPMNT');
      $END         
      
      Inventory_Part_In_Transit_API.Remove_From_Order_Transit(delivering_contract_     => issue_transaction_rec_.contract,
                                                              contract_                => dest_contract_,
                                                              part_no_                 => issue_transaction_rec_.part_no,
                                                              configuration_id_        => issue_transaction_rec_.configuration_id,
                                                              lot_batch_no_            => issue_transaction_rec_.lot_batch_no,
                                                              serial_no_               => issue_transaction_rec_.serial_no,
                                                              eng_chg_level_           => issue_transaction_rec_.eng_chg_level,
                                                              waiv_dev_rej_no_         => issue_transaction_rec_.waiv_dev_rej_no,
                                                              handling_unit_id_        => issue_transaction_rec_.handling_unit_id,
                                                              expiration_date_         => issue_transaction_rec_.expiration_date,
                                                              delivering_warehouse_id_ => delivering_warehouse_id_,
                                                              receiving_warehouse_id_  => dest_warehouse_id_,
                                                              activity_seq_            => issue_transaction_rec_.activity_seq,
                                                              part_ownership_db_       => issue_transaction_rec_.part_ownership,
                                                              owning_customer_no_      => NVL(issue_transaction_rec_.owning_customer_no, '*'),
                                                              owning_vendor_no_        => NVL(issue_transaction_rec_.owning_vendor_no, '*'),
                                                              deliv_no_                => 0,
                                                              shipment_id_             => 0,
                                                              shipment_line_no_        => 0,
                                                              qty_to_remove_           => quantity_ ,
                                                              catch_qty_to_remove_     => catch_quantity_);
      undo_move_to_order_transit_ := FALSE;
   END IF;
END Undo_Move_To_Order_Transit___;

-- Revalue_Int_Order_Transit___
--   Use when undo the return rework, undo the delivery in intersite flow and undo the delivery in shipment flow.
--   This will do the M4 revaluation.
PROCEDURE Revalue_Int_Order_Transit___ (   
   transaction_id_               IN  NUMBER,
   unissue_transaction_          IN  VARCHAR2,
   return_cor_transaction_id_    IN  NUMBER,
   return_transaction_rec_       IN  Inventory_Transaction_Hist_API.Public_Rec )
IS   
   inv_valuation_method_         VARCHAR2(50);
   company_                      VARCHAR2(20);   
   return_cor_transaction_rec_   Inventory_Transaction_Hist_API.Public_Rec;
   transaction_rec_              Inventory_Transaction_Hist_API.Public_Rec;
   rintotrcor_m4_value_det_tab_  Mpccom_Accounting_API.Value_Detail_Tab;
   retcorwint_m4_value_det_tab_  Mpccom_Accounting_API.Value_Detail_Tab;
   m4_pos_diff_value_det_tab_    Mpccom_Accounting_API.Value_Detail_Tab;
   m4_neg_diff_value_det_tab_    Mpccom_Accounting_API.Value_Detail_Tab;
BEGIN
   -- Handle RINTOTRCOR, UNINTORDTR in different way to other reverse transactions
   IF ((unissue_transaction_ = 'RETCORWINT') AND (return_transaction_rec_.transaction_code IN ('RINTORDTR', 'RINTORDTRX'))) 
       OR
      ((unissue_transaction_ IN ('UNSHIPTRAN', 'COUNSHPTRN', 'UNSHIPDIR', 'COUNSHPDIR', 'UNINPODRIM', 'UNPODRINEM', 'UND-SHPODS')) AND (return_transaction_rec_.transaction_code = 'INTORDTR')) THEN
      
      return_cor_transaction_rec_ := Inventory_Transaction_Hist_API.Get(return_cor_transaction_id_);
      transaction_rec_ := Inventory_Transaction_Hist_API.Get(transaction_id_);

      inv_valuation_method_ := Inventory_Part_API.Get_Invent_Valuation_Method_Db(
                                                                         transaction_rec_.contract,
                                                                         transaction_rec_.part_no);

      company_ := Site_API.Get_Company(return_transaction_rec_.contract);

      IF inv_valuation_method_ = 'ST' THEN

         rintotrcor_m4_value_det_tab_ := Mpccom_Accounting_API.Get_Sum_Value_Details(
                                                         return_cor_transaction_rec_.accounting_id,
                                                         'M4');
         retcorwint_m4_value_det_tab_ := Mpccom_Accounting_API.Get_Sum_Value_Details(
                                                                    transaction_rec_.accounting_id,
                                                                    'M4');
         retcorwint_m4_value_det_tab_ := Mpccom_Accounting_API.Get_Sign_Shifted_Value_Tab(
                                                                     retcorwint_m4_value_det_tab_);

         Mpccom_Accounting_API.Create_Value_Diff_Tables(m4_pos_diff_value_det_tab_,
                                                        m4_neg_diff_value_det_tab_,
                                                        rintotrcor_m4_value_det_tab_,
                                                        retcorwint_m4_value_det_tab_);

         IF (m4_neg_diff_value_det_tab_.COUNT > 0) THEN
            Inventory_Transaction_Hist_API.Do_Booking(return_cor_transaction_id_,
                                                      company_,
                                                      'ORDTREVAL-',
                                                      'N',
                                                      m4_neg_diff_value_det_tab_);
         END IF;
         IF (m4_pos_diff_value_det_tab_.COUNT > 0) THEN
            Inventory_Transaction_Hist_API.Do_Booking(return_cor_transaction_id_,
                                                      company_,
                                                      'ORDTREVAL+',
                                                      'N',
                                                      m4_pos_diff_value_det_tab_);
         END IF;
      END IF;
   END IF;
END Revalue_Int_Order_Transit___;

-- gelr:access_ctrl_for_inv_reserv, start
-- Clear_Warehouse_Id_Tmp___
-- Clears the temporary table warehouse_id_tmp
PROCEDURE Clear_Warehouse_Id_Tmp___
IS
BEGIN
   DELETE FROM warehouse_id_tmp;
END Clear_Warehouse_Id_Tmp___;
-- gelr:access_ctrl_for_inv_reserv, end
-------------------- LU SPECIFIC PROTECTED METHODS --------------------------

-------------------- LU SPECIFIC PUBLIC METHODS -----------------------------


PROCEDURE Receive_Part_From_Transit (
   unattached_from_handling_unit_      OUT VARCHAR2,
   info_                               OUT VARCHAR2,
   contract_                           IN  VARCHAR2,
   part_no_                            IN  VARCHAR2,
   configuration_id_                   IN  VARCHAR2,
   location_no_                        IN  VARCHAR2,
   lot_batch_no_                       IN  VARCHAR2,
   serial_no_                          IN  VARCHAR2,
   eng_chg_level_                      IN  VARCHAR2,
   waiv_dev_rej_no_                    IN  VARCHAR2,
   activity_seq_                       IN  NUMBER,
   handling_unit_id_                   IN  NUMBER,
   quantity_                           IN  NUMBER,
   catch_quantity_                     IN  NUMBER,
   validate_hu_struct_position_        IN  BOOLEAN DEFAULT TRUE )
IS   
   receive_succeeded_      BOOLEAN := FALSE;
BEGIN
   unattached_from_handling_unit_ := Fnd_Boolean_API.DB_FALSE;
   IF ((handling_unit_id_ != 0) AND (validate_hu_struct_position_)) THEN
      -- Set savepoint so that we can rollback if structure validation gives error.
      @ApproveTransactionStatement(2016-11-22,Chfose)
      SAVEPOINT before_rec_part_handl_unit_;
   END IF;
   -- Do the initial receive attempt while keeping the HU ID if such one is used. Do not include HU Structure Validation.
   Receive_Part_From_Transit(info_                          => info_,
                             contract_                      => contract_,
                             part_no_                       => part_no_,
                             configuration_id_              => configuration_id_,
                             location_no_                   => location_no_,
                             lot_batch_no_                  => lot_batch_no_,
                             serial_no_                     => serial_no_,
                             eng_chg_level_                 => eng_chg_level_,
                             waiv_dev_rej_no_               => waiv_dev_rej_no_,
                             activity_seq_                  => activity_seq_,
                             handling_unit_id_              => handling_unit_id_,
                             quantity_                      => quantity_,
                             catch_quantity_                => catch_quantity_,
                             validate_hu_struct_position_   => FALSE);

   IF ((handling_unit_id_ = 0) OR (NOT validate_hu_struct_position_)) THEN
      -- If we are not dealing with a handling unit or if the handling unit structure position should not be validated then we are done now.
      receive_succeeded_ := TRUE;
   ELSE
      -- receive of a quantity connected to a handling unit requires additional validations.
      DECLARE
         structure_error EXCEPTION;
         PRAGMA          EXCEPTION_INIT(structure_error,-20110);
      BEGIN
         -- Do the HU structure validation
         Handling_Unit_API.Validate_Structure_Position(handling_unit_id_);
         receive_succeeded_ := TRUE;
      EXCEPTION
         WHEN structure_error THEN
            -- The structure validation proves that the receive was not sucessful. So we rollback everything.
            @ApproveTransactionStatement(2016-11-22,Chfose)
            ROLLBACK TO before_rec_part_handl_unit_;
            -- Now since the structure validation threw an error we check if this HU is connected to a parent HU.
            -- If so then we disconnect the HU from the parent and try again to perform the receive of the HU.
            IF (Handling_Unit_API.Get_Parent_Handling_Unit_Id(handling_unit_id_) IS NOT NULL) THEN
               -- Set savepoint so that we can rollback if structure validation gives error.
               @ApproveTransactionStatement(2016-11-22,Chfose)
               SAVEPOINT before_rec_part_handl_unit_;
               Handling_Unit_API.Modify_Parent_Handling_Unit_Id(handling_unit_id_         => handling_unit_id_, 
                                                                parent_handling_unit_id_  => NULL);
               -- Do a second receive attempt while keeping the HU ID, now disconnected from its parent. Do not include HU Structure Validation.
               Receive_Part_From_Transit(info_                          => info_,
                                         contract_                      => contract_,
                                         part_no_                       => part_no_,
                                         configuration_id_              => configuration_id_,
                                         location_no_                   => location_no_,
                                         lot_batch_no_                  => lot_batch_no_,
                                         serial_no_                     => serial_no_,
                                         eng_chg_level_                 => eng_chg_level_,
                                         waiv_dev_rej_no_               => waiv_dev_rej_no_,
                                         activity_seq_                  => activity_seq_,
                                         handling_unit_id_              => handling_unit_id_,
                                         quantity_                      => quantity_,
                                         catch_quantity_                => catch_quantity_,
                                         validate_hu_struct_position_   => FALSE);
               BEGIN
                  -- Do the HU structure validation to see if the disconnection of the HU from the parent means that we can receive the HU.
                  Handling_Unit_API.Validate_Structure_Position(handling_unit_id_);
                  receive_succeeded_ := TRUE;
               EXCEPTION
                  WHEN structure_error THEN
                     -- The structure validation proves that the receive was not sucessful. So we rollback everything.
                     @ApproveTransactionStatement(2015-11-22,Chfose)
                     ROLLBACK TO before_rec_part_handl_unit_;
               END;
            END IF;
            IF NOT (receive_succeeded_) THEN
               -- Try to receive again with the quantity unattached from the handling unit.
               Receive_Part_From_Transit(info_                          => info_,
                                         contract_                      => contract_,
                                         part_no_                       => part_no_,
                                         configuration_id_              => configuration_id_,
                                         location_no_                   => location_no_,
                                         lot_batch_no_                  => lot_batch_no_,
                                         serial_no_                     => serial_no_,
                                         eng_chg_level_                 => eng_chg_level_,
                                         waiv_dev_rej_no_               => waiv_dev_rej_no_,
                                         activity_seq_                  => activity_seq_,
                                         handling_unit_id_              => handling_unit_id_,
                                         quantity_                      => quantity_,
                                         catch_quantity_                => catch_quantity_,
                                         validate_hu_struct_position_   => FALSE);
                                         
               -- Unattach the quantity from the handling unit after the receive since we need to have qty onhand before changing the
               -- handling unit id.
               Change_Handling_Unit_Id(contract_                      => contract_,
                                       part_no_                       => part_no_,
                                       configuration_id_              => configuration_id_,
                                       location_no_                   => location_no_,
                                       lot_batch_no_                  => lot_batch_no_,
                                       serial_no_                     => serial_no_,
                                       eng_chg_level_                 => eng_chg_level_,
                                       waiv_dev_rej_no_               => waiv_dev_rej_no_,
                                       activity_seq_                  => activity_seq_,
                                       old_handling_unit_id_          => handling_unit_id_,
                                       new_handling_unit_id_          => 0,
                                       quantity_                      => quantity_,
                                       catch_quantity_                => catch_quantity_);
               
               -- Do the validate to make sure that the handling unit still only exists on the original location.
               Handling_Unit_API.Validate_Structure_Position(handling_unit_id_);
               
               -- Indicate that the receive lead to an unattachment of the quantity received from the Handling Unit.
               unattached_from_handling_unit_ := Fnd_Boolean_API.DB_TRUE;
            END IF;
      END;
   END IF;
END Receive_Part_From_Transit;


-- Receive_Part_From_Transit
--   Modifies Qty_In_transit.
PROCEDURE Receive_Part_From_Transit (
   info_                           OUT VARCHAR2,
   contract_                       IN  VARCHAR2,
   part_no_                        IN  VARCHAR2,
   configuration_id_               IN  VARCHAR2,
   location_no_                    IN  VARCHAR2,
   lot_batch_no_                   IN  VARCHAR2,
   serial_no_                      IN  VARCHAR2,
   eng_chg_level_                  IN  VARCHAR2,
   waiv_dev_rej_no_                IN  VARCHAR2,
   activity_seq_                   IN  NUMBER,
   handling_unit_id_               IN  NUMBER,
   quantity_                       IN  NUMBER,
   catch_quantity_                 IN  NUMBER,
   validate_hu_struct_position_    IN  BOOLEAN  DEFAULT TRUE )
IS
   accounting_id_         NUMBER;
   transaction_id_        NUMBER;
   trans_value_           NUMBER;
   catch_qty_received_    NUMBER;
   location_type_db_      INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   empty_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   record_                INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
BEGIN

   record_ := Lock_By_Keys___ (contract_,
                               part_no_,
                               configuration_id_,
                               location_no_,
                               lot_batch_no_,
                               serial_no_,
                               eng_chg_level_,
                               waiv_dev_rej_no_,
                               activity_seq_,
                               handling_unit_id_);

   --Used record_.qty_in_transit and record_.catch_qty_in_transit in relevant places.
   IF (record_.qty_in_transit < quantity_) THEN
      Error_SYS.Record_General(lu_name_, 'QTYTRANSLESS: The quantity received may not be greater than the quantity in transit.');
   END IF;

   IF (record_.qty_in_transit = quantity_) AND (catch_quantity_ IS NULL) THEN
      catch_qty_received_ := record_.catch_qty_in_transit;
   ELSE
      catch_qty_received_ := catch_quantity_;
   END IF;

   location_type_db_    := Inventory_Location_API.Get_Location_Type_Db(contract_,location_no_);

   IF location_type_db_ NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                Inventory_Location_Type_API.DB_PRODUCTION_LINE) THEN
      Error_SYS.Record_General('InventoryPartInStock', 'WRONGRECLOCTYPENOPA1: Location type :P1 is not valid for part :P2 from transit', Inventory_Location_Type_API.Decode(location_type_db_), part_no_);
   END IF;

   IF (Warehouse_Bay_Bin_API.Get_Receipts_Blocked_Db(contract_, record_.warehouse, record_.bay_no, record_.tier_no, record_.row_no, record_.bin_no) = Fnd_Boolean_API.db_true) THEN
      Client_SYS.Add_Info('InventoryPartInStock', 'LOCRECEIPTSBLOCKED: Parts from transit are received into a location (:P1) that is blocked for receipts. Please consider if additional move of part is necessary.', location_no_);
   END IF;
   info_ := Client_SYS.Get_All_Info;  -- info is cleared later in this flow so we cant have Get_All_Info in the end of this method
   
   Receive_Part_Impl___(transaction_id_               =>  transaction_id_,
                        accounting_id_                =>  accounting_id_,
                        trans_value_                  =>  trans_value_,
                        contract_                     =>  contract_,
                        part_no_                      =>  part_no_,
                        location_no_                  =>  location_no_,
                        configuration_id_             =>  configuration_id_,
                        lot_batch_no_                 =>  lot_batch_no_,
                        serial_no_                    =>  serial_no_,
                        eng_chg_level_                =>  eng_chg_level_,
                        waiv_dev_rej_no_              =>  waiv_dev_rej_no_,
                        activity_seq_                 =>  activity_seq_,
                        handling_unit_id_             =>  handling_unit_id_,
                        transaction_                  =>  'INVREC',
                        expiration_date_              =>  NULL,
                        quantity_                     =>  quantity_,
                        quantity_reserved_            =>  0,
                        catch_quantity_               =>  catch_qty_received_,
                        source_ref1_                  =>  NULL,
                        source_ref2_                  =>  NULL,
                        source_ref3_                  =>  NULL,
                        source_ref4_                  =>  NULL,
                        source_ref5_                  =>  NULL,
                        source_                       =>  NULL,
                        unissue_                      =>  FALSE,
                        unit_cost_                    =>  NULL,
                        source_ref_type_              =>  NULL,
                        vendor_no_                    =>  record_.owning_vendor_no,
                        receipt_date_                 =>  NULL,
                        condition_code_               =>  NULL,
                        part_ownership_               =>  NVL(record_.part_ownership, Part_Ownership_API.DB_COMPANY_OWNED),
                        owning_customer_no_           =>  record_.owning_customer_no,
                        cost_detail_tab_              =>  empty_cost_detail_tab_,
                        set_qty_reversed_             =>  FALSE,
                        issue_transaction_id_         =>  NULL ,
                        operational_condition_db_     =>  NULL,
                        part_catalog_rec_             =>  NULL,
                        availability_control_id_      =>  NULL,
                        validate_hu_struct_position_  =>  validate_hu_struct_position_,
                        ownership_transfer_reason_id_ =>  NULL);

   Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                          Site_API.Get_Company(contract_),
                                                          'N',
                                                          NULL);
END Receive_Part_From_Transit;

@UncheckedAccess
FUNCTION Activity_Has_Parts_In_Stock (
   activity_seq_   IN NUMBER ) RETURN BOOLEAN
IS
   CURSOR exist_control IS
      SELECT 1
        FROM INVENTORY_PART_IN_STOCK_TAB
       WHERE activity_seq = activity_seq_
         AND (qty_onhand != 0 OR qty_in_transit != 0);
   
   temp_ NUMBER;
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO temp_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RETURN (TRUE);
   END IF;
   CLOSE exist_control;
   RETURN (FALSE);
END Activity_Has_Parts_In_Stock;

-- Create_Count_Report
--   Used for Create count report.
PROCEDURE Create_Count_Report (
   attrib_ IN VARCHAR2 )
IS
   batch_desc_                   VARCHAR2(100);
   batch_desc_per_wh_            VARCHAR2(100);
   contract_                     INVENTORY_PART_IN_STOCK_TAB.contract%TYPE;
   warehouse_id_                 INVENTORY_PART_IN_STOCK_TAB.warehouse%TYPE;
   bay_id_                       INVENTORY_PART_IN_STOCK_TAB.bay_no%TYPE;
   row_id_                       INVENTORY_PART_IN_STOCK_TAB.row_no%TYPE;
   tier_id_                      INVENTORY_PART_IN_STOCK_TAB.tier_no%TYPE;
   bin_id_                       INVENTORY_PART_IN_STOCK_TAB.bin_no%TYPE;
   storage_zone_id_              VARCHAR2(30);
   one_report_per_warehouse_     VARCHAR2(1) := 'N';
   attr_                         VARCHAR2(32000);
   location_no_tab_              Warehouse_Bay_Bin_API.Location_No_Tab;
   
   CURSOR get_distinctive_warehouses IS
      SELECT DISTINCT warehouse_id
      FROM warehouse_bay_bin_tab 
      WHERE contract = contract_
      AND ((UPPER(warehouse_id) LIKE UPPER(warehouse_id_)) OR warehouse_id_ IS NULL)
      AND ((UPPER(bay_id)    LIKE UPPER(bay_id_)) OR bay_id_ IS NULL)
      AND ((UPPER(row_id)    LIKE UPPER(row_id_)) OR row_id_ IS NULL)
      AND ((UPPER(tier_id)   LIKE UPPER(tier_id_)) OR tier_id_ IS NULL)
      AND ((UPPER(bin_id)    LIKE UPPER(bin_id_)) OR bin_id_ IS NULL)
      AND (location_no IN (SELECT * FROM TABLE(location_no_tab_)) OR (storage_zone_id_ IS NULL));
      
BEGIN
   
   one_report_per_warehouse_ := Client_SYS.Get_Item_Value( 'ONE_REPORT_PER_WAREHOUSE', attrib_ );   
   attr_ := Client_SYS.Remove_Attr('ONE_REPORT_PER_WAREHOUSE', attrib_);
   contract_   := Client_SYS.Get_Item_Value( 'CONTRACT', attr_ );

   IF one_report_per_warehouse_ = 'Y' THEN
      bay_id_            := Client_SYS.Get_Item_Value( 'BAY_ID', attr_ );
      row_id_            := Client_SYS.Get_Item_Value( 'ROW_ID', attr_ );
      tier_id_           := Client_SYS.Get_Item_Value( 'TIER_ID', attr_ );
      bin_id_            := Client_SYS.Get_Item_Value( 'BIN_ID', attr_ );
      storage_zone_id_   := Client_SYS.Get_Item_Value( 'STORAGE_ZONE_ID', attr_ );

      IF (storage_zone_id_ IS NOT NULL) THEN
         location_no_tab_ := Warehouse_Bay_Bin_API.Get_Storage_Zone_Locations(contract_, storage_zone_id_);
      END IF;
      
      FOR rec_ IN get_distinctive_warehouses LOOP
         attr_ := Client_SYS.Remove_Attr('WAREHOUSE_ID', attr_);
         Client_SYS.Set_Item_Value('WAREHOUSE_ID', rec_.warehouse_id, attr_);
         batch_desc_per_wh_ := Language_SYS.Translate_Constant(lu_name_,'BDESCCCR_PER_WH: Create Count Report on Site :P1 for Warehouse :P2', NULL, contract_, rec_.warehouse_id);
         Transaction_SYS.Deferred_Call('Inventory_Part_In_Stock_API.Create_Count_Report__',attr_,batch_desc_per_wh_);  
      END LOOP; 
      
   ELSE
      IF (Transaction_SYS.Is_Session_Deferred()) THEN
         Create_Count_Report__(attr_);
      ELSE
         batch_desc_:= Language_SYS.Translate_Constant(lu_name_,'BDESCCCR: Create Count Report on Site :P1', NULL, contract_);
         Transaction_SYS.Deferred_Call('Inventory_Part_In_Stock_API.Create_Count_Report__',attr_,batch_desc_);  
      END IF;
   END IF;
END Create_Count_Report;


@UncheckedAccess
FUNCTION Get_Sum_Catch_Qty_Onhand (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_no_      IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER ) RETURN NUMBER
IS
   temp_ INVENTORY_PART_IN_STOCK_TAB.catch_qty_onhand%TYPE;
   TYPE Get_Sum IS REF CURSOR;
   get_sum_   Get_Sum;
   stmt_      VARCHAR2(32000);  
BEGIN
   IF (configuration_id_ IS NOT NULL AND location_no_ IS NOT NULL AND lot_batch_no_ IS NOT NULL
       AND serial_no_ IS NOT NULL AND eng_chg_level_ IS NOT NULL AND waiv_dev_rej_no_ IS NOT NULL
       AND activity_seq_ IS NOT NULL AND handling_unit_id_ IS NOT NULL ) THEN
      temp_ := Get_Catch_Qty_Onhand(contract_,
                                    part_no_,
                                    configuration_id_,
                                    location_no_,
                                    lot_batch_no_,
                                    serial_no_,
                                    eng_chg_level_,
                                    waiv_dev_rej_no_,
                                    activity_seq_,
                                    handling_unit_id_);
   ELSE
      stmt_ := 'SELECT SUM(catch_qty_onhand)
                  FROM INVENTORY_PART_IN_STOCK_TAB
                  WHERE contract = :contract_
                  AND   part_no  = :part_no_';
      IF (configuration_id_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND configuration_id = :configuration_id_ ';
      ELSE
         stmt_ := stmt_ || ' AND :configuration_id_ IS NULL ';
      END IF;
      IF (location_no_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND location_no = :location_no_ ';
      ELSE
         stmt_ := stmt_ || ' AND :location_no_ IS NULL ';
      END IF;
      IF (lot_batch_no_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND lot_batch_no = :lot_batch_no_ ';
      ELSE
         stmt_ := stmt_ || ' AND :lot_batch_no_ IS NULL ';
      END IF;
       IF (serial_no_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND serial_no = :serial_no_ ';
      ELSE
         stmt_ := stmt_ || ' AND :serial_no_ IS NULL ';
      END IF;
      IF (eng_chg_level_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND eng_chg_level = :eng_chg_level_ ';
      ELSE
         stmt_ := stmt_ || ' AND :eng_chg_level_ IS NULL ';
      END IF;
      IF (waiv_dev_rej_no_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND waiv_dev_rej_no = :waiv_dev_rej_no_ ';
      ELSE
         stmt_ := stmt_ || ' AND :waiv_dev_rej_no_ IS NULL ';
      END IF;
      IF (activity_seq_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND activity_seq = :activity_seq_ ';
      ELSE
         stmt_ := stmt_ || ' AND :activity_seq_ IS NULL ';
      END IF;
      IF (handling_unit_id_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND handling_unit_id = :handling_unit_id_ ';
      ELSE
         stmt_ := stmt_ || ' AND :handling_unit_id_ IS NULL ';
      END IF;

      @ApproveDynamicStatement(2020-01-20,KiSalk)
      OPEN get_sum_ FOR stmt_ USING contract_,
                                    part_no_,
                                    configuration_id_,
                                    location_no_,
                                    lot_batch_no_,
                                    serial_no_,
                                    eng_chg_level_,
                                    waiv_dev_rej_no_,
                                    activity_seq_,
                                    handling_unit_id_;
      FETCH get_sum_ INTO temp_;
      CLOSE get_sum_;
   END IF;
   RETURN NVL(temp_,0);
END Get_Sum_Catch_Qty_Onhand;


PROCEDURE Move_Part (
   unattached_from_handling_unit_    OUT VARCHAR2,
   catch_quantity_                IN OUT NUMBER,
   contract_                      IN     VARCHAR2,
   part_no_                       IN     VARCHAR2,
   configuration_id_              IN     VARCHAR2,
   location_no_                   IN     VARCHAR2,
   lot_batch_no_                  IN     VARCHAR2,
   serial_no_                     IN     VARCHAR2,
   eng_chg_level_                 IN     VARCHAR2,
   waiv_dev_rej_no_               IN     VARCHAR2,
   activity_seq_                  IN     NUMBER,
   handling_unit_id_              IN     NUMBER,
   expiration_date_               IN     DATE,
   to_contract_                   IN     VARCHAR2,
   to_location_no_                IN     VARCHAR2,
   to_destination_                IN     VARCHAR2,
   quantity_                      IN     NUMBER,
   quantity_reserved_             IN     NUMBER,
   move_comment_                  IN     VARCHAR2,
   order_no_                      IN     VARCHAR2 DEFAULT NULL,
   release_no_                    IN     VARCHAR2 DEFAULT NULL,
   sequence_no_                   IN     VARCHAR2 DEFAULT NULL,
   line_item_no_                  IN     VARCHAR2 DEFAULT NULL,
   source_ref5_                   IN     VARCHAR2 DEFAULT NULL,
   order_type_                    IN     VARCHAR2 DEFAULT NULL,
   consume_consignment_stock_     IN     VARCHAR2 DEFAULT NULL,
   to_waiv_dev_rej_no_            IN     VARCHAR2 DEFAULT NULL,
   part_tracking_session_id_      IN     NUMBER   DEFAULT NULL,
   transport_task_id_             IN     NUMBER   DEFAULT NULL,
   validate_hu_struct_position_   IN     BOOLEAN  DEFAULT TRUE,
   move_part_shipment_            IN     BOOLEAN  DEFAULT FALSE,
   availability_ctrl_id_          IN     VARCHAR2 DEFAULT NULL)
IS
   move_succeeded_                BOOLEAN := FALSE;
   dummy_number_                  NUMBER;
   availability_control_id_       inventory_part_in_stock_tab.availability_control_id%TYPE;
   local_serial_no_               VARCHAR2(50) := serial_no_;
   local_waiv_dev_rej_no_         inventory_part_in_stock_tab.waiv_dev_rej_no%TYPE := waiv_dev_rej_no_;
BEGIN
   IF (waiv_dev_rej_no_ != NVL(to_waiv_dev_rej_no_, waiv_dev_rej_no_)) THEN
      -- Added error to raise if reserved quantity greater than 0.
      IF (quantity_reserved_ > 0)THEN
         Error_SYS.Record_General('InventoryPartInStock','MOVERESANDCHANGEWDR: W/D/R No cannot be changed when moving reserved quantity');
      END IF;
      Change_Waiv_Dev_Rej_No(contract_            => contract_,
                             part_no_             => part_no_,
                             configuration_id_    => configuration_id_,
                             location_no_         => location_no_,
                             lot_batch_no_        => lot_batch_no_,
                             serial_no_           => serial_no_,
                             eng_chg_level_       => eng_chg_level_,
                             waiv_dev_rej_no_     => waiv_dev_rej_no_,
                             activity_seq_        => activity_seq_,
                             handling_unit_id_    => handling_unit_id_,
                             to_waiv_dev_rej_no_  => to_waiv_dev_rej_no_,
                             quantity_            => quantity_,
                             catch_quantity_      => catch_quantity_,
                             order_no_            => order_no_,
                             release_no_          => release_no_,
                             sequence_no_         => sequence_no_,
                             line_item_no_        => line_item_no_,
                             order_type_          => order_type_);
                             
      local_waiv_dev_rej_no_ := to_waiv_dev_rej_no_;
   END IF;
   
   unattached_from_handling_unit_ := Fnd_Boolean_API.DB_FALSE;
   IF ((handling_unit_id_ != 0) AND (validate_hu_struct_position_)) THEN
      -- Set savepoint so that we can rollback if structure validation gives error.
      -- We need to have the structure validation after the Move_Part because of Split Into Serials. 
      @ApproveTransactionStatement(2015-12-08,LePeSe)
      SAVEPOINT before_move_part_handl_unit_;
   END IF;
   -- Do the initial move attempt while keeping the HU ID if such one is used. Do not include HU Structure Validation.
   Move_Part(catch_quantity_              => catch_quantity_,
             contract_                    => contract_,
             part_no_                     => part_no_,
             configuration_id_            => configuration_id_,
             location_no_                 => location_no_,
             lot_batch_no_                => lot_batch_no_,
             serial_no_                   => serial_no_,
             eng_chg_level_               => eng_chg_level_,
             waiv_dev_rej_no_             => local_waiv_dev_rej_no_,
             activity_seq_                => activity_seq_,
             handling_unit_id_            => handling_unit_id_,
             expiration_date_             => expiration_date_,
             to_contract_                 => to_contract_,
             to_location_no_              => to_location_no_,
             to_destination_              => to_destination_,
             quantity_                    => quantity_,
             quantity_reserved_           => quantity_reserved_,
             move_comment_                => move_comment_,
             order_no_                    => order_no_,
             release_no_                  => release_no_,
             sequence_no_                 => sequence_no_,
             line_item_no_                => line_item_no_,
             source_ref5_                 => source_ref5_,
             order_type_                  => order_type_,
             consume_consignment_stock_   => consume_consignment_stock_,
             to_waiv_dev_rej_no_          => NULL,
             part_tracking_session_id_    => part_tracking_session_id_,
             transport_task_id_           => transport_task_id_,
             validate_hu_struct_position_ => FALSE,
             move_part_shipment_          => move_part_shipment_,
             availability_ctrl_id_        => availability_ctrl_id_);

   IF ((handling_unit_id_ = 0) OR (NOT validate_hu_struct_position_)) THEN
      -- If we are not dealing with a handling unit or if the handling unit structure position should not be validated then we are done now.
      move_succeeded_ := TRUE;
   ELSE
      -- move of a quantity connected to a handling unit requires additional validations.
      DECLARE
         structure_error EXCEPTION;
         PRAGMA          EXCEPTION_INIT(structure_error,-20110);
      BEGIN
         -- Do the HU structure validation
         Handling_Unit_API.Validate_Structure_Position(handling_unit_id_);
         move_succeeded_ := TRUE;
      EXCEPTION
         WHEN structure_error THEN
            -- The structure validation proves that the move was not sucessful. So we rollback everything.
            @ApproveTransactionStatement(2015-12-08,LePeSe)
            ROLLBACK TO before_move_part_handl_unit_;
            -- Now since the structure validation threw an error we check if this HU is connected to a parent HU.
            -- If so then we disconnect the HU from the parent and try again to perform the move of the HU.
            IF (Handling_Unit_API.Get_Parent_Handling_Unit_Id(handling_unit_id_) IS NOT NULL) THEN
               -- Set savepoint so that we can rollback if structure validation gives error.
               -- We need to have the structure validation after the Move_Part because of Split Into Serials. 
               @ApproveTransactionStatement(2015-12-08,LePeSe)
               SAVEPOINT before_move_part_handl_unit_;
               Handling_Unit_API.Modify_Parent_Handling_Unit_Id(handling_unit_id_         => handling_unit_id_, 
                                                                parent_handling_unit_id_  => NULL);
               -- Do a second move attempt while keeping the HU ID, now disconnected from its parent. Do not include HU Structure Validation.
               Move_Part(catch_quantity_              => catch_quantity_,
                         contract_                    => contract_,
                         part_no_                     => part_no_,
                         configuration_id_            => configuration_id_,
                         location_no_                 => location_no_,
                         lot_batch_no_                => lot_batch_no_,
                         serial_no_                   => serial_no_,
                         eng_chg_level_               => eng_chg_level_,
                         waiv_dev_rej_no_             => local_waiv_dev_rej_no_,
                         activity_seq_                => activity_seq_,
                         handling_unit_id_            => handling_unit_id_,
                         expiration_date_             => expiration_date_,
                         to_contract_                 => to_contract_,
                         to_location_no_              => to_location_no_,
                         to_destination_              => to_destination_,
                         quantity_                    => quantity_,
                         quantity_reserved_           => quantity_reserved_,
                         move_comment_                => move_comment_,
                         order_no_                    => order_no_,
                         release_no_                  => release_no_,
                         sequence_no_                 => sequence_no_,
                         line_item_no_                => line_item_no_,
                         source_ref5_                 => source_ref5_,
                         order_type_                  => order_type_,
                         consume_consignment_stock_   => consume_consignment_stock_,
                         to_waiv_dev_rej_no_          => NULL,
                         part_tracking_session_id_    => part_tracking_session_id_,
                         transport_task_id_           => transport_task_id_,
                         validate_hu_struct_position_ => FALSE,
                         move_part_shipment_          => move_part_shipment_,
                         availability_ctrl_id_        => availability_ctrl_id_);
               BEGIN
                  -- Do the HU structure validation to see if the disconnection of the HU from the parent means that we can move the HU.
                  Handling_Unit_API.Validate_Structure_Position(handling_unit_id_);
                  move_succeeded_ := TRUE;
               EXCEPTION
                  WHEN structure_error THEN
                     -- The structure validation proves that the move was not sucessful. So we rollback everything.
                     @ApproveTransactionStatement(2015-12-08,LePeSe)
                     ROLLBACK TO before_move_part_handl_unit_;
               END;
            END IF;
            IF NOT (move_succeeded_) THEN
               -- Unattach the quantity from the handling unit before the move.
               IF (quantity_reserved_ != 0) THEN
                  -- Need to unreserve before changing Handling Unit ID.
                  availability_control_id_ := Get_Availability_Control_Id(contract_,
                                                                          part_no_,
                                                                          configuration_id_,
                                                                          location_no_,
                                                                          lot_batch_no_,
                                                                          serial_no_,
                                                                          eng_chg_level_,
                                                                          local_waiv_dev_rej_no_,
                                                                          activity_seq_,
                                                                          handling_unit_id_);
                  Reserve_Part(catch_quantity_               => dummy_number_,
                               contract_                     => contract_,
                               part_no_                      => part_no_,
                               configuration_id_             => configuration_id_,
                               location_no_                  => location_no_,
                               lot_batch_no_                 => lot_batch_no_,
                               serial_no_                    => serial_no_, 
                               eng_chg_level_                => eng_chg_level_,
                               waiv_dev_rej_no_              => local_waiv_dev_rej_no_,
                               activity_seq_                 => activity_seq_,
                               handling_unit_id_             => handling_unit_id_,
                               quantity_                     => quantity_reserved_ * -1,
                               ignore_this_avail_control_id_ => availability_control_id_);
               END IF;
               Change_Handling_Unit_Id(contract_                      => contract_,
                                       part_no_                       => part_no_,
                                       configuration_id_              => configuration_id_,
                                       location_no_                   => location_no_,
                                       lot_batch_no_                  => lot_batch_no_,
                                       serial_no_                     => serial_no_,
                                       eng_chg_level_                 => eng_chg_level_,
                                       waiv_dev_rej_no_               => local_waiv_dev_rej_no_,
                                       activity_seq_                  => activity_seq_,
                                       old_handling_unit_id_          => handling_unit_id_,
                                       new_handling_unit_id_          => 0,
                                       quantity_                      => quantity_,
                                       catch_quantity_                => catch_quantity_,
                                       source_ref1_                   => order_no_,
                                       source_ref2_                   => release_no_,
                                       source_ref3_                   => sequence_no_,
                                       source_ref4_                   => line_item_no_, 
                                       inv_trans_source_ref_type_db_  => Order_Type_API.Encode(order_type_),
                                       always_preserve_serial_no_     => move_part_shipment_);
                                       
               -- This check is useful when moving reserved stock (if new location is not shipment location) in combination with serial tracking only at 
               -- receipt and issue and when unpacking the serial meaning that handling unit ID goes to zero and serial resets to *. 
               IF ((serial_no_ != '*') AND 
                   (NOT move_part_shipment_) AND 
                   (Inventory_Part_In_Stock_API.Check_Individual_Exist(part_no_, serial_no_) = 0)) THEN 
                  local_serial_no_ := '*';
               END IF ;

               -- Try to move again with the quantity unattached from the handling unit.
               Move_Part(catch_quantity_              => catch_quantity_,
                         contract_                    => contract_,
                         part_no_                     => part_no_,
                         configuration_id_            => configuration_id_,
                         location_no_                 => location_no_,
                         lot_batch_no_                => lot_batch_no_,
                         serial_no_                   => local_serial_no_,
                         eng_chg_level_               => eng_chg_level_,
                         waiv_dev_rej_no_             => local_waiv_dev_rej_no_,
                         activity_seq_                => activity_seq_,
                         handling_unit_id_            => 0,
                         expiration_date_             => NVL(expiration_date_, Get_Expiration_Date(contract_         => to_contract_,
                                                                                                   part_no_          => part_no_,
                                                                                                   configuration_id_ => configuration_id_,
                                                                                                   location_no_      => to_location_no_,
                                                                                                   lot_batch_no_     => lot_batch_no_,
                                                                                                   serial_no_        => local_serial_no_,
                                                                                                   eng_chg_level_    => eng_chg_level_,
                                                                                                   waiv_dev_rej_no_  => local_waiv_dev_rej_no_,
                                                                                                   activity_seq_     => activity_seq_,
                                                                                                   handling_unit_id_ => 0)),
                         to_contract_                 => to_contract_,
                         to_location_no_              => to_location_no_,
                         to_destination_              => to_destination_,
                         quantity_                    => quantity_,
                         quantity_reserved_           => 0,
                         move_comment_                => move_comment_,
                         order_no_                    => order_no_,
                         release_no_                  => release_no_,
                         sequence_no_                 => sequence_no_,
                         line_item_no_                => line_item_no_,
                         source_ref5_                 => source_ref5_,
                         order_type_                  => order_type_,
                         consume_consignment_stock_   => consume_consignment_stock_,
                         to_waiv_dev_rej_no_          => NULL,
                         part_tracking_session_id_    => part_tracking_session_id_,
                         transport_task_id_           => transport_task_id_,
                         validate_hu_struct_position_ => TRUE,
                         move_part_shipment_          => move_part_shipment_,
                         availability_ctrl_id_        => availability_ctrl_id_);
               -- Indicate that the move lead to an unattachment of the quantity moved from the Handling Unit.
               unattached_from_handling_unit_ := Fnd_Boolean_API.DB_TRUE;
            END IF;
      END;
   END IF;
END Move_Part;


-- Move_Part
--   Moves a part to a new location. Shipment location not treated here.
PROCEDURE Move_Part (
   catch_quantity_              IN OUT NUMBER,
   contract_                    IN     VARCHAR2,
   part_no_                     IN     VARCHAR2,
   configuration_id_            IN     VARCHAR2,
   location_no_                 IN     VARCHAR2,
   lot_batch_no_                IN     VARCHAR2,
   serial_no_                   IN     VARCHAR2,
   eng_chg_level_               IN     VARCHAR2,
   waiv_dev_rej_no_             IN     VARCHAR2,
   activity_seq_                IN     NUMBER,
   handling_unit_id_            IN     NUMBER,
   expiration_date_             IN     DATE,
   to_contract_                 IN     VARCHAR2,
   to_location_no_              IN     VARCHAR2,
   to_destination_              IN     VARCHAR2,
   quantity_                    IN     NUMBER,
   quantity_reserved_           IN     NUMBER,
   move_comment_                IN     VARCHAR2,
   order_no_                    IN     VARCHAR2 DEFAULT NULL,
   release_no_                  IN     VARCHAR2 DEFAULT NULL,
   sequence_no_                 IN     VARCHAR2 DEFAULT NULL,
   line_item_no_                IN     VARCHAR2 DEFAULT NULL,
   source_ref5_                 IN     VARCHAR2 DEFAULT NULL,
   order_type_                  IN     VARCHAR2 DEFAULT NULL,
   consume_consignment_stock_   IN     VARCHAR2 DEFAULT NULL,
   to_waiv_dev_rej_no_          IN     VARCHAR2 DEFAULT NULL,
   part_tracking_session_id_    IN     NUMBER   DEFAULT NULL,
   transport_task_id_           IN     NUMBER   DEFAULT NULL,
   validate_hu_struct_position_ IN     BOOLEAN  DEFAULT TRUE,
   move_part_shipment_          IN     BOOLEAN  DEFAULT FALSE,
   availability_ctrl_id_        IN     VARCHAR2 DEFAULT NULL)
IS
   to_location_type_db_       INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   from_location_type_db_     INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   consume_cons_stock_        BOOLEAN := FALSE;
   serial_catch_tab_          Serial_Catch_Table;
   local_quantity_            NUMBER;
   local_quantity_reserved_   NUMBER;
   local_catch_quantity_      NUMBER;
   total_serial_catch_qty_    NUMBER := 0;
   total_actual_catch_qty_    NUMBER := 0;
   part_catalog_rec_          Part_Catalog_API.Public_Rec;
   reservation_               BOOLEAN;
BEGIN
   Inventory_Part_Destination_API.Exist(to_destination_);

   from_location_type_db_ := Inventory_Location_API.Get_Location_Type_db(contract_,location_no_);
   to_location_type_db_   := Inventory_Location_API.Get_Location_Type_db(to_contract_,to_location_no_);
   part_catalog_rec_      := Part_Catalog_API.Get(part_no_);

   IF (NOT move_part_shipment_ AND (from_location_type_db_ = Inventory_Location_Type_API.DB_SHIPMENT OR 
                                    to_location_type_db_   = Inventory_Location_Type_API.DB_SHIPMENT)) THEN
      IF (order_type_ IS NULL OR Order_Type_API.Encode(order_type_) != Order_Type_API.DB_PURCH_RECEIPT_RETURN) THEN
         Error_SYS.Record_General('InventoryPartInStock','NOTMOVESHIPMENT: Cannot move to or from a shipment location.');
      END IF;
   END IF;

   IF NOT Inventory_Part_API.Check_Exist(to_contract_, part_no_) THEN
      Error_SYS.Record_General('InventoryPartInStock', 'PARTNOTEXIST: Inventory part :P1 does not exist on site :P2. Register the part on the new site before moving it.', part_no_, to_contract_);
   END IF;

   IF (NVL(consume_consignment_stock_, 'N') = 'Y') THEN
      consume_cons_stock_ := TRUE;
   END IF;
   
   Inventory_Event_Manager_API.Start_Session;

   IF (part_tracking_session_id_ IS NULL) THEN
      serial_catch_tab_(1).serial_no := serial_no_;
      local_catch_quantity_          := catch_quantity_;
      local_quantity_                := quantity_;
      local_quantity_reserved_       := quantity_reserved_;
   ELSE
      Temporary_Part_Tracking_API.Get_Serials_And_Remove_Session(serial_catch_tab_,part_tracking_session_id_);

      IF (serial_catch_tab_.COUNT = 0) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'MOVENOSERIAL: No serials have been identified to move.');
      END IF;

      IF (serial_catch_tab_.COUNT != quantity_) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'MOVESERCOUNT: The quantity to be moved is :P1 but the number of identified serials is :P2', quantity_, serial_catch_tab_.COUNT);
      END IF;

      IF (contract_ = to_contract_) AND (NOT consume_cons_stock_) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'MOVESERSPLIT: The Split Into Serials option is pointless when moving within a single site unless you are consuming supplier consignment stock.');
      END IF;

      IF (NVL(quantity_reserved_,0) = 0 ) THEN
         reservation_             := FALSE;
         local_quantity_reserved_ := 0;
      ELSIF (quantity_reserved_ = quantity_) THEN
         reservation_             := TRUE;
         local_quantity_reserved_ := 1;
      ELSE
         Error_SYS.Record_General('InventoryPartInStock', 'MOVEQTYERR: Mismatch between Quantity to be moved and Reserved Quantity to be moved. The first is :P1 and the second is :P2.', quantity_, quantity_reserved_);
      END IF;

      Split_Into_Serials(contract_,
                         part_no_,
                         configuration_id_,
                         location_no_,
                         lot_batch_no_,
                         eng_chg_level_,
                         waiv_dev_rej_no_,
                         activity_seq_,
                         handling_unit_id_,
                         serial_catch_tab_,
                         reservation_);

      local_quantity_       := 1;
      local_catch_quantity_ := NULL;
   END IF;
   
   FOR i IN serial_catch_tab_.FIRST..serial_catch_tab_.LAST LOOP

      Move_Part_Impl___(catch_quantity_                => local_catch_quantity_,
                        contract_                      => contract_,
                        part_no_                       => part_no_,
                        configuration_id_              => configuration_id_,
                        location_no_                   => location_no_,
                        lot_batch_no_                  => lot_batch_no_,
                        serial_no_                     => serial_catch_tab_(i).serial_no,
                        eng_chg_level_                 => eng_chg_level_,
                        waiv_dev_rej_no_               => waiv_dev_rej_no_,
                        activity_seq_                  => activity_seq_,
                        handling_unit_id_              => handling_unit_id_,
                        expiration_date_               => expiration_date_,
                        to_contract_                   => to_contract_,
                        to_part_no_                    => part_no_,
                        to_location_no_                => to_location_no_,
                        to_destination_db_             => Inventory_Part_Destination_API.Encode(to_destination_),
                        to_waiv_dev_rej_no_            => NVL(to_waiv_dev_rej_no_, waiv_dev_rej_no_),
                        to_lot_batch_no_               => lot_batch_no_,
                        to_serial_no_                  => serial_catch_tab_(i).serial_no,
                        to_activity_seq_               => activity_seq_,
                        to_handling_unit_id_           => handling_unit_id_,
                        quantity_                      => local_quantity_,
                        quantity_reserved_             => NVL(local_quantity_reserved_,0),
                        move_comment_                  => move_comment_,
                        order_no_                      => order_no_,
                        line_no_                       => release_no_,
                        release_no_                    => sequence_no_,
                        line_item_no_                  => line_item_no_,
                        source_ref5_                   => source_ref5_,
                        order_type_                    => order_type_,
                        consume_consignment_stock_     => consume_cons_stock_,
                        make_transaction_and_postings_ => TRUE,
                        report_earned_value_db_        => NULL,
                        from_part_catalog_rec_         => part_catalog_rec_,
                        to_part_catalog_rec_           => part_catalog_rec_,
                        transport_task_id_             => transport_task_id_,
                        validate_hu_struct_position_   => validate_hu_struct_position_,
                        availability_ctrl_id_          => availability_ctrl_id_,
                        always_preserve_serial_no_     => FALSE,
                        ownership_transfer_reason_id_  => NULL);

      total_actual_catch_qty_ := total_actual_catch_qty_ + local_catch_quantity_;
      local_catch_quantity_   := NULL;
      total_serial_catch_qty_ := total_serial_catch_qty_ + serial_catch_tab_(i).catch_qty;
   END LOOP;
   
   Inventory_Event_Manager_API.Finish_Session; 
   
   IF (total_serial_catch_qty_ != catch_quantity_) THEN
      Error_SYS.Record_General('InventoryPartInStock', 'MOVESERCATCH: The total catch quantity to be moved is :P1 but the accumulated catch quantity on the serials is entered as :P2.', catch_quantity_, total_serial_catch_qty_);
   END IF;

   catch_quantity_ := total_actual_catch_qty_;
END Move_Part;


-- Check_Exist
--   Returns Check_Exist___.
@UncheckedAccess
FUNCTION Check_Exist (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_no_      IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER ) RETURN BOOLEAN
IS
BEGIN
   RETURN Check_Exist___(contract_,part_no_,configuration_id_,
                         location_no_,lot_batch_no_,serial_no_,
                         eng_chg_level_,waiv_dev_rej_no_,activity_seq_, handling_unit_id_);
END Check_Exist;


@UncheckedAccess
FUNCTION Check_Part_Exist (
   contract_       IN VARCHAR2,
   part_no_        IN VARCHAR2,
   skip_qty_check_ IN BOOLEAN DEFAULT FALSE ) RETURN BOOLEAN
IS
   qty_check_  VARCHAR2(5);
   CURSOR check_part_loc IS
      SELECT 'x'
      FROM   INVENTORY_PART_IN_STOCK_TAB
      WHERE part_no = part_no_
      AND  contract = contract_
      AND ((qty_onhand <> 0 OR qty_in_transit <> 0) OR qty_check_ = db_false_);

   dummy_ VARCHAR2(1);
   exist_ BOOLEAN;
BEGIN
   IF (skip_qty_check_)THEN
      qty_check_ := db_false_; 
   ELSE
      qty_check_ := db_true_;
   END IF;

   OPEN check_part_loc;
   FETCH check_part_loc INTO dummy_;
   exist_ := check_part_loc%FOUND;
   CLOSE check_part_loc;
   RETURN(exist_);
END Check_Part_Exist;


@UncheckedAccess
FUNCTION Get_Arrival_Location (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   location_no_  INVENTORY_PART_IN_STOCK_TAB.location_no%TYPE := NULL;
BEGIN
   location_no_ := Inventory_Part_Def_Loc_API.Get_Location_No(contract_, part_no_);

   IF (location_no_ IS NULL) THEN
      location_no_ := Get_Latest_Receipt_Location(contract_,
                                                  part_no_,
                                                  configuration_id_,
                                                  Inventory_Location_Type_API.DB_PICKING,
                                                  Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                                  Inventory_Location_Type_API.DB_PRODUCTION_LINE);
   END IF;
   RETURN location_no_;
END Get_Arrival_Location;


-- Get_Inventory_Qty_Rejected
--   Returns the sum of quantity rejected for a part.
@UncheckedAccess
FUNCTION Get_Inventory_Qty_Rejected (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   project_id_       IN VARCHAR2 ) RETURN NUMBER
IS
   include_standard_ VARCHAR2(10);
BEGIN
   IF project_id_ IS NULL THEN
      include_standard_ := db_true_;
   ELSE
      include_standard_ := db_false_;
   END IF;
   RETURN Get_Inventory_Quantity(contract_             => contract_,
                                 part_no_              => part_no_,
                                 configuration_id_     => configuration_id_,
                                 qty_type_             => 'ONHAND',
                                 supply_control_db_    => 'NOT NETTABLE',
                                 ownership_type1_db_   => Part_Ownership_API.DB_COMPANY_OWNED,
                                 ownership_type2_db_   => Part_Ownership_API.DB_CONSIGNMENT,
                                 ownership_type3_db_   => Part_Ownership_API.DB_SUPPLIER_LOANED,
                                 ownership_type4_db_   => Part_Ownership_API.DB_CUSTOMER_OWNED,
                                 ownership_type5_db_   => Part_Ownership_API.DB_SUPPLIER_RENTED,
                                 ownership_type6_db_   => Part_Ownership_API.DB_COMPANY_RENTAL_ASSET,
                                 location_type1_db_    => Inventory_Location_Type_API.DB_PICKING,
                                 location_type2_db_    => Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                 location_type3_db_    => Inventory_Location_Type_API.DB_SHIPMENT,
                                 location_type4_db_    => Inventory_Location_Type_API.DB_PRODUCTION_LINE,
                                 include_standard_     => include_standard_,
                                 include_project_      => db_true_,
                                 project_id_           => project_id_);
END Get_Inventory_Qty_Rejected;


@UncheckedAccess
FUNCTION Get_Total_Qty_Onhand_Loc_Type (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_type_    IN VARCHAR2 ) RETURN NUMBER
IS
   qty_onhand_       NUMBER;
   location_type_db_ INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   CURSOR get_data IS
      SELECT SUM(qty_onhand)
      FROM  INVENTORY_PART_IN_STOCK_TAB
      WHERE (configuration_id = configuration_id_ OR configuration_id_ IS NULL)
      AND   part_no           = part_no_
      AND   contract          = contract_
      AND   location_type     = location_type_db_;
BEGIN
   qty_onhand_ := 0;
   location_type_db_ := Inventory_Location_Type_API.Encode(location_type_);

   OPEN get_data;
   FETCH get_data INTO qty_onhand_;
   CLOSE get_data;
   RETURN NVL(qty_onhand_, 0);
END Get_Total_Qty_Onhand_Loc_Type;


-- Get_Total_Qty_In_Transit
--   Returns the sum of qty reserved for a part.
@UncheckedAccess
FUNCTION Get_Total_Qty_In_Transit (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2 DEFAULT NULL,
   serial_no_        IN VARCHAR2 DEFAULT NULL ) RETURN NUMBER
IS
   qty_in_transit_  NUMBER;

   CURSOR get_qty IS
      SELECT SUM(qty_in_transit)
      FROM   INVENTORY_PART_IN_STOCK_TAB
      WHERE contract         = contract_
      AND   part_no          = part_no_
      AND  (configuration_id = configuration_id_ OR configuration_id_ IS NULL)
      AND  (lot_batch_no     = lot_batch_no_     OR lot_batch_no_     IS NULL)
      AND  (serial_no        = serial_no_        OR serial_no_        IS NULL);
BEGIN
   OPEN get_qty;
   FETCH get_qty INTO qty_in_transit_;
   CLOSE get_qty;
   RETURN NVL(qty_in_transit_, 0);
END Get_Total_Qty_In_Transit;


-- Get_Inventory_Qty_Expired
--   Returns sum of the parts of which the expiration date has expired.
@UncheckedAccess
FUNCTION Get_Inventory_Qty_Expired (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   RETURN Get_Inventory_Quantity(contract_             => contract_,
                                 part_no_              => part_no_,
                                 configuration_id_     => configuration_id_,
                                 qty_type_             => 'ONHAND',
                                 expiration_control_   => 'EXPIRED',
                                 ownership_type1_db_   => Part_Ownership_API.DB_COMPANY_OWNED,
                                 ownership_type2_db_   => Part_Ownership_API.DB_CONSIGNMENT,
                                 ownership_type3_db_   => Part_Ownership_API.DB_SUPPLIER_LOANED,
                                 ownership_type4_db_   => Part_Ownership_API.DB_CUSTOMER_OWNED,
                                 location_type1_db_    => Inventory_Location_Type_API.DB_PICKING,
                                 location_type2_db_    => Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                 location_type3_db_    => Inventory_Location_Type_API.DB_SHIPMENT,
                                 location_type4_db_    => Inventory_Location_Type_API.DB_PRODUCTION_LINE);
END Get_Inventory_Qty_Expired;


@UncheckedAccess
FUNCTION Get_Plannable_Qty_Onhand (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   RETURN Get_Avail_Plan_Qty_Loc_Type(contract_          => contract_,
                                      part_no_           => part_no_,
                                      configuration_id_  => configuration_id_,
                                      activity_seq_      => NULL,
                                      qty_type_          => 'ONHAND',
                                      date_requested_    => NULL,
                                      location_type1_db_ => Inventory_Location_Type_API.DB_PICKING,
                                      location_type2_db_ => Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                      location_type3_db_ => Inventory_Location_Type_API.DB_SHIPMENT,
                                      location_type4_db_ => Inventory_Location_Type_API.DB_PRODUCTION_LINE);
END Get_Plannable_Qty_Onhand;


@UncheckedAccess
FUNCTION Get_Plannable_Qty_Reserved (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   RETURN Get_Avail_Plan_Qty_Loc_Type(contract_          => contract_,
                                      part_no_           => part_no_,
                                      configuration_id_  => configuration_id_,
                                      activity_seq_      => NULL,
                                      qty_type_          => 'RESERVED',
                                      date_requested_    => NULL,
                                      location_type1_db_ => Inventory_Location_Type_API.DB_PICKING,
                                      location_type2_db_ => Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                      location_type3_db_ => Inventory_Location_Type_API.DB_SHIPMENT,
                                      location_type4_db_ => Inventory_Location_Type_API.DB_PRODUCTION_LINE);
END Get_Plannable_Qty_Reserved;


@UncheckedAccess
FUNCTION Get_Shop_Plannable_Qty_Onhand (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   RETURN Get_Avail_Plan_Qty_Loc_Type(contract_          => contract_,
                                      part_no_           => part_no_,
                                      configuration_id_  => configuration_id_,
                                      activity_seq_      => NULL,
                                      qty_type_          => 'ONHAND',
                                      date_requested_    => NULL,
                                      location_type1_db_ => Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                      location_type2_db_ => Inventory_Location_Type_API.DB_PRODUCTION_LINE);
END Get_Shop_Plannable_Qty_Onhand;


@UncheckedAccess
FUNCTION Get_Shop_Plannable_Qty_Res (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   RETURN Get_Avail_Plan_Qty_Loc_Type(contract_          => contract_,
                                      part_no_           => part_no_,
                                      configuration_id_  => configuration_id_,
                                      activity_seq_      => NULL,
                                      qty_type_          => 'RESERVED',
                                      date_requested_    => NULL,
                                      location_type1_db_ => Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                      location_type2_db_ => Inventory_Location_Type_API.DB_PRODUCTION_LINE);
END Get_Shop_Plannable_Qty_Res;


@UncheckedAccess
FUNCTION Get_Sales_Plannable_Qty_Onhand (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   RETURN Get_Avail_Plan_Qty_Loc_Type(contract_          => contract_,
                                      part_no_           => part_no_,
                                      configuration_id_  => configuration_id_,
                                      activity_seq_      => NULL,
                                      qty_type_          => 'ONHAND',
                                      date_requested_    => NULL,
                                      location_type1_db_ => Inventory_Location_Type_API.DB_PICKING,
                                      location_type2_db_ => Inventory_Location_Type_API.DB_SHIPMENT);
END Get_Sales_Plannable_Qty_Onhand;


@UncheckedAccess
FUNCTION Get_Sales_Plannable_Qty_Res (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   RETURN Get_Avail_Plan_Qty_Loc_Type(contract_          => contract_,
                                      part_no_           => part_no_,
                                      configuration_id_  => configuration_id_,
                                      activity_seq_      => NULL,
                                      qty_type_          => 'RESERVED',
                                      date_requested_    => NULL,
                                      location_type1_db_ => Inventory_Location_Type_API.DB_PICKING,
                                      location_type2_db_ => Inventory_Location_Type_API.DB_SHIPMENT);
END Get_Sales_Plannable_Qty_Res;


-- Get_Starting_Balance
--   Returns the total currently available quantity (qty_onhand - qty_reserved)
--   for an inventory part. The parameter include_floor_stock_ control what
--   location types that are to be included. 'FALSE' will exclude stock that
--   is intended for production and 'TRUE' will include it in the calculation
@UncheckedAccess
FUNCTION Get_Starting_Balance (
   contract_            IN VARCHAR2,
   part_no_             IN VARCHAR2,
   configuration_id_    IN VARCHAR2,
   include_standard_    IN VARCHAR2,   
   include_project_     IN VARCHAR2,   
   project_id_          IN VARCHAR2,
   activity_seq_        IN NUMBER,
   include_floor_stock_ IN VARCHAR2 ) RETURN NUMBER
IS
   today_plus_planning_days_  DATE;
   temp_                      NUMBER;
   last_calendar_date_        DATE         := Database_Sys.last_calendar_date_;
   
   CURSOR get_balance_with_floor IS
      SELECT Sum(qty_onhand - qty_reserved + qty_in_transit)
      FROM INVENTORY_PART_IN_STOCK_AVAIL
      WHERE    part_supply_control_db = 'NETTABLE'
      AND      NVL(expiration_date, last_calendar_date_) > today_plus_planning_days_
      AND      location_type_db IN (Inventory_Location_Type_API.DB_PICKING,
                                    Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                    Inventory_Location_Type_API.DB_PRODUCTION_LINE)
      AND      part_ownership_db IN ('COMPANY OWNED', 'CONSIGNMENT')
      AND      contract = contract_
      AND      part_no = part_no_
      AND     (configuration_id  = configuration_id_ OR configuration_id_ IS NULL)
      AND    ((include_standard_ = db_true_  AND project_id    IS NULL)
         OR   (include_project_  = db_true_  AND project_id    IS NOT NULL
         AND  (project_id    = project_id_   OR  project_id_   IS NULL)
         AND ((activity_seq = activity_seq_  OR  activity_seq_ IS NULL) OR activity_seq_ = 0)))
      GROUP BY part_no, contract;

   CURSOR get_balance_not_floor IS
      SELECT Sum(qty_onhand - qty_reserved + qty_in_transit)
      FROM INVENTORY_PART_IN_STOCK_AVAIL
      WHERE    part_supply_control_db = 'NETTABLE'
      AND      NVL(expiration_date, last_calendar_date_) > today_plus_planning_days_
      AND      location_type_db = Inventory_Location_Type_API.DB_PICKING
      AND      part_ownership_db IN ('COMPANY OWNED', 'CONSIGNMENT')
      AND      contract = contract_
      AND      part_no = part_no_
      AND     (configuration_id  = configuration_id_ OR configuration_id_ IS NULL)
      AND    ((include_standard_ = db_true_  AND project_id    IS NULL)
         OR   (include_project_  = db_true_  AND project_id    IS NOT NULL
         AND  (project_id    = project_id_   OR  project_id_   IS NULL)
         AND ((activity_seq = activity_seq_  OR  activity_seq_ IS NULL) OR activity_seq_ = 0)))
      GROUP BY part_no, contract;

BEGIN
   today_plus_planning_days_ := Trunc(Site_API.Get_Site_Date(contract_)) +
                                Inventory_Part_API.Get_Min_Durab_Days_Planning(contract_, part_no_);

   IF include_floor_stock_ = db_true_ THEN
      OPEN get_balance_with_floor;
      FETCH get_balance_with_floor INTO temp_;
      CLOSE get_balance_with_floor;
   ELSIF include_floor_stock_ = db_false_ THEN
      OPEN get_balance_not_floor;
      FETCH get_balance_not_floor INTO temp_;
      CLOSE get_balance_not_floor;
   END IF;
   RETURN nvl(temp_,0);
END Get_Starting_Balance;

-- Get_Gross_Expired_Date_And_Qty
--   Returns an array of future expiration dates and quantities for an inventory part. 
--   min_durab_days_planning_ acts as an offset and is added to today_ in the search criteria, so that
--   lot expirations in the very near future are not considered.
--   The parameter include_floor_stock_ control which location types that are to be included.
--   'FALSE' will exclude stock that is intended for production and 'TRUE' will include it in the calculation.
--   include_standard_  : values are 'TRUE' or 'FALSE'
--   include_project_   : values are 'TRUE' or 'FALSE'
--   qty_type_          : values are 'ONHAND' or 'AVAILABLE' or 'AVAILTRANSIT'

@UncheckedAccess
FUNCTION Get_Gross_Expired_Date_And_Qty (
   contract_                  IN VARCHAR2,
   part_no_                   IN VARCHAR2,
   configuration_id_          IN VARCHAR2,
   include_standard_          IN VARCHAR2,   
   include_project_           IN VARCHAR2,   
   project_id_                IN VARCHAR2,
   activity_seq_              IN NUMBER,
   include_floor_stock_       IN VARCHAR2,
   qty_type_                  IN VARCHAR2,
   today_                     IN DATE,
   min_durab_days_planning_   IN NUMBER,
   stop_analysis_date_        IN DATE DEFAULT NULL) RETURN Expired_Date_Qty_Tab
IS
   last_calendar_date_              DATE := Database_Sys.last_calendar_date_;
   loc_type_floor_                  VARCHAR2(20);
   loc_type_production_             VARCHAR2(20);
   row_index_                       PLS_INTEGER := 1;
   expired_date_qty_tab_            Expired_Date_Qty_Tab;
   
   -- select records with onhand > 0, and with an expiration date
   CURSOR get_expired_qty IS
      SELECT expiration_date, configuration_id, activity_seq, lot_batch_no,
             SUM(qty_onhand) qty_onhand, SUM(qty_reserved) qty_reserved, SUM(qty_in_transit) qty_in_transit
      FROM INVENTORY_PART_IN_STOCK_AVAIL
      WHERE    part_supply_control_db = 'NETTABLE'
      AND      expiration_date > (TRUNC(today_) + min_durab_days_planning_)
      AND      expiration_date <= NVL(stop_analysis_date_, last_calendar_date_)
      AND     (qty_onhand + qty_in_transit) > 0
      AND      location_type_db IN (Inventory_Location_Type_API.DB_PICKING,
                                    loc_type_floor_,
                                    loc_type_production_)
      AND      part_ownership_db IN ('COMPANY OWNED', 'CONSIGNMENT')
      AND      contract = contract_
      AND      part_no = part_no_
      AND     (configuration_id  = configuration_id_ OR configuration_id_ IS NULL)
      AND    ((include_standard_ = db_true_  AND project_id    IS NULL)
         OR   (include_project_  = db_true_  AND project_id    IS NOT NULL
         AND  (project_id    = project_id_   OR  project_id_   IS NULL)
         AND ((activity_seq = activity_seq_  OR  activity_seq_ IS NULL) OR activity_seq_ = 0)))
      GROUP BY expiration_date, configuration_id, activity_seq, lot_batch_no
      ORDER BY expiration_date, configuration_id, activity_seq, lot_batch_no;

BEGIN
   IF qty_type_ NOT IN ('ONHAND', 'AVAILABLE', 'AVAILTRANSIT') THEN 
      RETURN expired_date_qty_tab_;
   END IF;
   IF include_floor_stock_ = db_true_ THEN
      loc_type_floor_ := Inventory_Location_Type_API.DB_FLOOR_STOCK;
      loc_type_production_ := Inventory_Location_Type_API.DB_PRODUCTION_LINE;
   ELSE
      loc_type_floor_ := 'DuMmY';
      loc_type_production_ := 'DuMmY';
   END IF;
   FOR rec_ IN get_expired_qty LOOP
      expired_date_qty_tab_(row_index_).expiration_date  := rec_.expiration_date;
      expired_date_qty_tab_(row_index_).contract         := contract_;
      expired_date_qty_tab_(row_index_).part_no          := part_no_;
      expired_date_qty_tab_(row_index_).configuration_id := rec_.configuration_id;
      expired_date_qty_tab_(row_index_).activity_seq     := rec_.activity_seq;
      expired_date_qty_tab_(row_index_).lot_batch_no     := rec_.lot_batch_no;
      IF qty_type_ = 'ONHAND' THEN
         expired_date_qty_tab_(row_index_).qty_expired := rec_.qty_onhand;
      ELSIF qty_type_ = 'AVAILABLE' THEN
         expired_date_qty_tab_(row_index_).qty_expired := rec_.qty_onhand - rec_.qty_reserved;
      ELSE
         expired_date_qty_tab_(row_index_).qty_expired := rec_.qty_onhand - rec_.qty_reserved + rec_.qty_in_transit;
      END IF;
      row_index_ := row_index_ + 1;
   END LOOP; 
   
   RETURN expired_date_qty_tab_;
END Get_Gross_Expired_Date_And_Qty;


PROCEDURE Modify_Expiration_Date (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_no_      IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER,
   expiration_date_  IN DATE )
IS
   oldrec_ INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   newrec_ INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
BEGIN
   oldrec_ := Lock_By_Keys___(contract_,
                              part_no_,
                              configuration_id_,
                              location_no_,
                              lot_batch_no_,
                              serial_no_,
                              eng_chg_level_,
                              waiv_dev_rej_no_,
                              activity_seq_,
                              handling_unit_id_);

   newrec_                 := oldrec_;
   newrec_.expiration_date := expiration_date_;

   Check_And_Update_By_Keys___(oldrec_ => oldrec_, newrec_ => newrec_);
END Modify_Expiration_Date;


-- Modify_Exp_Date_By_Lot_No
--   Modify expiration date by Lot
PROCEDURE Modify_Exp_Date_By_Lot_No (
   part_no_         IN VARCHAR2,
   lot_batch_no_    IN VARCHAR2,
   expiration_date_ IN DATE )
IS
   CURSOR get_rec_by_lot IS
      SELECT contract, part_no, configuration_id, location_no, lot_batch_no, serial_no, eng_chg_level, waiv_dev_rej_no, activity_seq, handling_unit_id
      FROM   INVENTORY_PART_IN_STOCK_TAB
      WHERE  part_no      = part_no_
      AND    lot_batch_no = lot_batch_no_
      AND    (qty_onhand != 0 OR qty_in_transit != 0);
BEGIN
   FOR rec_ IN get_rec_by_lot LOOP
      Modify_Expiration_Date( rec_.contract,
                              rec_.part_no, 
                              rec_.configuration_id, 
                              rec_.location_no, 
                              rec_.lot_batch_no, 
                              rec_.serial_no, 
                              rec_.eng_chg_level, 
                              rec_.waiv_dev_rej_no, 
                              rec_.activity_seq, 
                              rec_.handling_unit_id,
                              expiration_date_ );
   END LOOP;
END Modify_Exp_Date_By_Lot_No;


-- Find_And_Reserve_Part
--   Find a location with a quantity available and reserve parts.
PROCEDURE Find_And_Reserve_Part (
   reserved_qty_                 OUT    NUMBER,
   reserved_catch_qty_           OUT    NUMBER,
   location_no_                  IN OUT VARCHAR2,
   lot_batch_no_                 IN OUT VARCHAR2,
   serial_no_                    IN OUT VARCHAR2,
   eng_chg_level_                IN OUT VARCHAR2,
   waiv_dev_rej_no_              IN OUT VARCHAR2,
   configuration_id_             IN OUT VARCHAR2,
   activity_seq_                 IN OUT NUMBER,
   handling_unit_id_             IN OUT NUMBER,
   contract_                     IN     VARCHAR2,
   part_no_                      IN     VARCHAR2,
   location_type_                IN     VARCHAR2,
   quantity_                     IN     NUMBER,
   project_id_                   IN     VARCHAR2,
   condition_code_               IN     VARCHAR2 DEFAULT NULL,
   part_ownership_               IN     VARCHAR2 DEFAULT 'COMPANY OWNED',
   owning_vendor_no_             IN     VARCHAR2 DEFAULT NULL,
   owning_customer_no_           IN     VARCHAR2 DEFAULT NULL,
   expiration_control_date_      IN     DATE DEFAULT NULL,
   warehouse_id_                 IN     VARCHAR2 DEFAULT NULL,
   ignore_this_avail_control_id_ IN     VARCHAR2 DEFAULT NULL )
IS
   keys_and_qty_tab_ Keys_And_Qty_Tab;
   location_type_db_ INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;

BEGIN

   location_type_db_ := Inventory_Location_Type_API.Encode(location_type_);

   Find_And_Reserve_Part(keys_and_qty_tab_,
                         location_no_,
                         lot_batch_no_,
                         serial_no_,
                         eng_chg_level_,
                         waiv_dev_rej_no_,
                         configuration_id_,
                         activity_seq_,
                         handling_unit_id_,
                         contract_,
                         part_no_,
                         location_type_db_,
                         quantity_,
                         project_id_,
                         condition_code_,
                         part_ownership_,
                         owning_vendor_no_,
                         owning_customer_no_,
                         only_one_lot_allowed_         => FALSE,
                         many_records_allowed_         => FALSE,
                         expiration_control_date_      => expiration_control_date_,
                         warehouse_id_                 => warehouse_id_,
                         ignore_this_avail_control_id_ => ignore_this_avail_control_id_);

   IF (keys_and_qty_tab_.COUNT > 0) THEN
      reserved_qty_       := keys_and_qty_tab_(1).quantity;
      reserved_catch_qty_ := keys_and_qty_tab_(1).catch_quantity;
      location_no_        := keys_and_qty_tab_(1).location_no;
      lot_batch_no_       := keys_and_qty_tab_(1).lot_batch_no;
      serial_no_          := keys_and_qty_tab_(1).serial_no;
      eng_chg_level_      := keys_and_qty_tab_(1).eng_chg_level;
      waiv_dev_rej_no_    := keys_and_qty_tab_(1).waiv_dev_rej_no;
      configuration_id_   := keys_and_qty_tab_(1).configuration_id;
      activity_seq_       := keys_and_qty_tab_(1).activity_seq;
      handling_unit_id_   := keys_and_qty_tab_(1).handling_unit_id;
   ELSE
      reserved_qty_       := 0;
      reserved_catch_qty_ := 0;
      location_no_        := NULL;
      lot_batch_no_       := NULL;
      serial_no_          := NULL;
      eng_chg_level_      := NULL;
      waiv_dev_rej_no_    := NULL;
      configuration_id_   := NULL;
      activity_seq_       := NULL;
      handling_unit_id_   := NULL;
   END IF;

END Find_And_Reserve_Part;


-- Find_And_Reserve_Part
--   Find a location with a quantity available and reserve parts.
PROCEDURE Find_And_Reserve_Part (
   keys_and_qty_tab_             OUT Keys_And_Qty_Tab,
   location_no_                  IN  VARCHAR2,
   lot_batch_no_                 IN  VARCHAR2,
   serial_no_                    IN  VARCHAR2,
   eng_chg_level_                IN  VARCHAR2,
   waiv_dev_rej_no_              IN  VARCHAR2,
   configuration_id_             IN  VARCHAR2,
   activity_seq_                 IN  NUMBER,
   handling_unit_id_             IN  NUMBER,
   contract_                     IN  VARCHAR2,
   part_no_                      IN  VARCHAR2,
   location_type_db_             IN  VARCHAR2,
   qty_to_reserve_               IN  NUMBER,
   project_id_                   IN  VARCHAR2,
   condition_code_               IN  VARCHAR2,
   part_ownership_db_            IN  VARCHAR2,
   owning_vendor_no_             IN  VARCHAR2,
   owning_customer_no_           IN  VARCHAR2,
   only_one_lot_allowed_         IN  BOOLEAN,
   many_records_allowed_         IN  BOOLEAN,
   expiration_control_date_      IN  DATE     DEFAULT NULL,
   warehouse_id_                 IN  VARCHAR2 DEFAULT NULL,
   ignore_this_avail_control_id_ IN  VARCHAR2 DEFAULT NULL,
   include_temp_table_locs_      IN  BOOLEAN  DEFAULT TRUE,
   reserve_from_transp_task_db_  IN  VARCHAR2 DEFAULT Reserve_From_Transp_Task_API.DB_USE_INVENTORY_DEFAULT)
IS
BEGIN
   Find_And_Reserve_Or_Issue___(keys_and_qty_tab_             => keys_and_qty_tab_,
                                action_                       => reserve_,
                                location_no_                  => location_no_,
                                lot_batch_no_                 => lot_batch_no_,
                                serial_no_                    => serial_no_,
                                eng_chg_level_                => eng_chg_level_,
                                waiv_dev_rej_no_              => waiv_dev_rej_no_,
                                configuration_id_             => configuration_id_,
                                activity_seq_                 => activity_seq_,
                                handling_unit_id_             => handling_unit_id_,
                                contract_                     => contract_,
                                part_no_                      => part_no_,
                                location_type_db_             => location_type_db_,
                                qty_to_reserve_or_issue_      => qty_to_reserve_,
                                project_id_                   => project_id_,
                                condition_code_               => condition_code_,
                                part_ownership_db_            => part_ownership_db_,
                                owning_vendor_no_             => owning_vendor_no_,
                                owning_customer_no_           => owning_customer_no_,
                                only_one_lot_allowed_         => only_one_lot_allowed_,
                                many_records_allowed_         => many_records_allowed_,
                                expiration_control_date_      => expiration_control_date_,
                                warehouse_id_                 => warehouse_id_,
                                ignore_this_avail_control_id_ => ignore_this_avail_control_id_,
                                include_temp_table_locs_      => include_temp_table_locs_,
                                reserve_from_transp_task_db_  => reserve_from_transp_task_db_);
END Find_And_Reserve_Part;


PROCEDURE Find_For_Transport (
   keys_and_qty_tab_ OUT Keys_And_Qty_Tab,
   location_no_      IN  VARCHAR2,
   contract_         IN  VARCHAR2,
   part_no_          IN  VARCHAR2,
   location_group_   IN  VARCHAR2,
   qty_to_find_      IN  NUMBER )
IS
BEGIN
   -- Based on action find_for_transport this call will make stock reservations. This is necessary for the Handling Unit Optimization.
   Find_And_Reserve_Or_Issue___(keys_and_qty_tab_             => keys_and_qty_tab_,
                                action_                       => find_for_transport_,
                                location_no_                  => location_no_,
                                lot_batch_no_                 => NULL,
                                serial_no_                    => NULL,
                                eng_chg_level_                => NULL,
                                waiv_dev_rej_no_              => NULL,
                                configuration_id_             => '*',
                                activity_seq_                 => NULL,
                                handling_unit_id_             => NULL,
                                contract_                     => contract_,
                                part_no_                      => part_no_,
                                location_type_db_             => Inventory_Location_Group_API.Get_Inventory_Location_Type_Db(location_group_),
                                qty_to_reserve_or_issue_      => qty_to_find_,
                                project_id_                   => NULL,
                                condition_code_               => NULL,
                                part_ownership_db_            => Part_Ownership_API.DB_COMPANY_OWNED,
                                owning_vendor_no_             => NULL,
                                owning_customer_no_           => NULL,
                                only_one_lot_allowed_         => FALSE,
                                many_records_allowed_         => TRUE,
                                expiration_control_date_      => NULL,
                                warehouse_id_                 => NULL,
                                ignore_this_avail_control_id_ => NULL,
                                include_temp_table_locs_      => TRUE,
                                location_group_               => location_group_);

   IF (keys_and_qty_tab_.COUNT > 0) THEN
      FOR i IN keys_and_qty_tab_.FIRST..keys_and_qty_tab_.LAST LOOP
         -- Unreserve again. Reservation was needed for getting the Handling Unit optimization to work.
         -- But now we do not need the reservations, only the output in form of the keys_and_qty_tab_. 
         Reserve_Part(keys_and_qty_tab_(i).catch_quantity,
                      keys_and_qty_tab_(i).contract,
                      keys_and_qty_tab_(i).part_no,
                      keys_and_qty_tab_(i).configuration_id,
                      keys_and_qty_tab_(i).location_no,
                      keys_and_qty_tab_(i).lot_batch_no,
                      keys_and_qty_tab_(i).serial_no,
                      keys_and_qty_tab_(i).eng_chg_level,
                      keys_and_qty_tab_(i).waiv_dev_rej_no,
                      keys_and_qty_tab_(i).activity_seq,
                      keys_and_qty_tab_(i).handling_unit_id,
                      keys_and_qty_tab_(i).quantity * -1);
      END LOOP;
   END IF;
END Find_For_Transport;


PROCEDURE Reserve_Part (
   catch_quantity_               OUT NUMBER,
   contract_                     IN  VARCHAR2,
   part_no_                      IN  VARCHAR2,
   configuration_id_             IN  VARCHAR2,
   location_no_                  IN  VARCHAR2,
   lot_batch_no_                 IN  VARCHAR2,
   serial_no_                    IN  VARCHAR2,
   eng_chg_level_                IN  VARCHAR2,
   waiv_dev_rej_no_              IN  VARCHAR2,
   activity_seq_                 IN  NUMBER,
   handling_unit_id_             IN  NUMBER,
   quantity_                     IN  NUMBER,
   manual_reservation_           IN  BOOLEAN DEFAULT FALSE,
   ignore_this_avail_control_id_ IN  VARCHAR2 DEFAULT NULL,
   source_ref_type_db_           IN  VARCHAR2 DEFAULT NULL )
IS
   newrec_              INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   oldrec_              INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   to_rec_              INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   part_catalog_rec_    Part_Catalog_API.Public_Rec;
   expiration_date_     INVENTORY_PART_IN_STOCK_TAB.expiration_date%TYPE;
   serial_no_for_stock_ INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE;
   location_type_db_    INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   serial_catch_tab_    Serial_Catch_Table;
   ownership_conflict_  BOOLEAN;
   last_calendar_date_  DATE := Database_Sys.last_calendar_date_;
BEGIN
   Inventory_Event_Manager_API.Start_Session;
   part_catalog_rec_ := Part_Catalog_API.Get(part_no_);

   IF ((serial_no_ != '*') AND (quantity_ = 1)) THEN
      -- This is an attempt to reserve a serial from Inventory
      IF NOT (Check_Exist___(contract_,
                             part_no_,
                             configuration_id_,
                             location_no_,
                             lot_batch_no_,
                             serial_no_,
                             eng_chg_level_,
                             waiv_dev_rej_no_,
                             activity_seq_,
                             handling_unit_id_)) THEN
         -- The serial does not exist in Inventory on the given stock record
         location_type_db_    := Inventory_Location_API.Get_Location_Type_Db(contract_,location_no_);
         serial_no_for_stock_ := Get_Serial_No_For_Stock(part_no_, serial_no_, part_catalog_rec_, location_type_db_, handling_unit_id_);

         IF (serial_no_for_stock_ = '*') THEN
            -- It is clear now that this part is not serial tracked in inventory at this location type.
            -- So in order to be able to proceed with the reservation we must first create a stock record with
            -- this specific serial_no. It is done by running the generic split method. From there on the 
            -- logic can be execute as normal because now the serial exist in the expected stock location.
            serial_catch_tab_(1).serial_no := serial_no_;

            Split_Into_Serials(contract_           => contract_,
                               part_no_            => part_no_,
                               configuration_id_   => configuration_id_,
                               location_no_        => location_no_,
                               lot_batch_no_       => lot_batch_no_,
                               eng_chg_level_      => eng_chg_level_,
                               waiv_dev_rej_no_    => waiv_dev_rej_no_,
                               activity_seq_       => activity_seq_,
                               handling_unit_id_   => handling_unit_id_,
                               serial_catch_tab_   => serial_catch_tab_,
                               reservation_        => FALSE);
         END IF;
      END IF;
   END IF;

   oldrec_ := Lock_By_Keys___(contract_,
                              part_no_,
                              configuration_id_,
                              location_no_,
                              lot_batch_no_,
                              serial_no_,
                              eng_chg_level_,
                              waiv_dev_rej_no_,
                              activity_seq_,
                              handling_unit_id_);
  
   -- gelr:access_ctrl_for_inv_reserv, start
   User_Warehouse_Access_API.Check_Stock_Reserv_Allowed(Fnd_Session_API.Get_Fnd_User, oldrec_.contract, oldrec_.warehouse);
   -- gelr:access_ctrl_for_inv_reserv, end

   IF (Inventory_Location_API.Arrival_Or_Quality_Location(oldrec_.location_type) = db_true_)
      AND (nvl(source_ref_type_db_, string_null_) != Inv_Part_Res_Source_Type_API.DB_PURCH_RECEIPT_RETURN)THEN
      Raise_Loc_Type_Reserv_Error___(oldrec_.location_type);
   END IF;
   newrec_ := oldrec_;
   IF (newrec_.qty_onhand = quantity_) THEN
      catch_quantity_ := newrec_.catch_qty_onhand;
   ELSE
      catch_quantity_ := NULL;
   END IF;
   IF (manual_reservation_) THEN
      IF ((oldrec_.availability_control_id IS NULL) OR
         (ignore_this_avail_control_id_    IS NULL) OR
         (oldrec_.availability_control_id != ignore_this_avail_control_id_)) THEN
         IF (Part_Availability_Control_API.Check_Man_Reservation_Control(oldrec_.availability_control_id) != 'MANUAL_RESERV') THEN
            Error_SYS.Record_General(lu_name_, 'NOMANRES: Part :P1 has Availability Control ID :P2 on Location :P3 and cannot be manually reserved.', part_no_, oldrec_.availability_control_id, oldrec_.location_no);
         END IF;
      END IF;
   END IF;
   newrec_.qty_reserved := oldrec_.qty_reserved + quantity_;

   Check_And_Update_By_Keys___(oldrec_             => oldrec_,
                               newrec_             => newrec_,
                               part_catalog_rec_   => part_catalog_rec_);

   IF ((oldrec_.qty_reserved = 1  ) AND
       (newrec_.qty_reserved = 0  ) AND
       (oldrec_.serial_no   != '*')) THEN

      location_type_db_    := Inventory_Location_API.Get_Location_Type_Db(oldrec_.contract, oldrec_.location_no);
      serial_no_for_stock_ := Get_Serial_No_For_Stock(oldrec_.part_no,
                                                      oldrec_.serial_no,
                                                      part_catalog_rec_,
                                                      location_type_db_,
                                                      oldrec_.handling_unit_id);

      IF (serial_no_for_stock_ != oldrec_.serial_no) THEN

         ownership_conflict_ := Ownership_Conflict_Exists___(oldrec_.contract,
                                                             oldrec_.part_no,
                                                             oldrec_.configuration_id,
                                                             oldrec_.location_no,
                                                             oldrec_.lot_batch_no,
                                                             serial_no_for_stock_,
                                                             oldrec_.eng_chg_level,
                                                             oldrec_.waiv_dev_rej_no,
                                                             oldrec_.activity_seq,
                                                             oldrec_.handling_unit_id,
                                                             oldrec_.part_ownership,
                                                             oldrec_.owning_customer_no,
                                                             oldrec_.owning_vendor_no);
         IF (ownership_conflict_) THEN
            -- Changing the serial number will create an ownership conflict that results in an error message.
            -- So instead we keep the serial number as it is in InventoryPartInStock and indicate the serial
            -- as being tracked in inventory although it is only set as receipt and issue tracking in PartCatalog.
            serial_no_for_stock_ := oldrec_.serial_no;
            Part_Serial_Catalog_API.Set_Tracked_In_Inventory(oldrec_.part_no, oldrec_.serial_no);
         END IF;
      END IF;

      IF (serial_no_for_stock_ = '*') THEN
      -- The part is configured for Receipt and Issue serial tracking but not for Inventory serial tracking.
      -- Therefore, since this is an "unreservation" of a serial, we should transform this serial-specific stock record
      -- into a stock record with serial_no = '*'.

         expiration_date_ := oldrec_.expiration_date;

         IF (Check_Exist___(oldrec_.contract,
                            oldrec_.part_no,
                            oldrec_.configuration_id,
                            oldrec_.location_no,
                            oldrec_.lot_batch_no,
                            serial_no_for_stock_,
                            oldrec_.eng_chg_level,
                            oldrec_.waiv_dev_rej_no,
                            oldrec_.activity_seq,
                            oldrec_.handling_unit_id)) THEN

            to_rec_:= Lock_By_Keys___(oldrec_.contract,
                                      oldrec_.part_no,
                                      oldrec_.configuration_id,
                                      oldrec_.location_no,
                                      oldrec_.lot_batch_no,
                                      serial_no_for_stock_,
                                      oldrec_.eng_chg_level,
                                      oldrec_.waiv_dev_rej_no,
                                      oldrec_.activity_seq,
                                      oldrec_.handling_unit_id);

            IF (NVL(to_rec_.expiration_date, last_calendar_date_) <
                  NVL(oldrec_.expiration_date, last_calendar_date_)) THEN
               expiration_date_ := to_rec_.expiration_date;
            END IF;
         END IF;

         Move_Part_Impl___(catch_quantity_                => newrec_.catch_qty_onhand,
                           contract_                      => newrec_.contract,
                           part_no_                       => newrec_.part_no,
                           configuration_id_              => newrec_.configuration_id,
                           location_no_                   => newrec_.location_no,
                           lot_batch_no_                  => newrec_.lot_batch_no,
                           serial_no_                     => newrec_.serial_no,
                           eng_chg_level_                 => newrec_.eng_chg_level,
                           waiv_dev_rej_no_               => newrec_.waiv_dev_rej_no,
                           activity_seq_                  => newrec_.activity_seq,
                           handling_unit_id_              => newrec_.handling_unit_id,
                           expiration_date_               => expiration_date_,
                           to_contract_                   => newrec_.contract,
                           to_part_no_                    => newrec_.part_no,
                           to_location_no_                => newrec_.location_no,
                           to_destination_db_             => 'N',
                           to_waiv_dev_rej_no_            => newrec_.waiv_dev_rej_no,
                           to_lot_batch_no_               => newrec_.lot_batch_no,
                           to_serial_no_                  => serial_no_for_stock_,
                           to_activity_seq_               => newrec_.activity_seq,
                           to_handling_unit_id_           => newrec_.handling_unit_id,
                           quantity_                      => 1,
                           quantity_reserved_             => 0,
                           move_comment_                  => NULL,
                           order_no_                      => NULL,
                           line_no_                       => NULL,
                           release_no_                    => NULL,
                           line_item_no_                  => NULL,
                           source_ref5_                   => NULL,
                           order_type_                    => NULL,
                           consume_consignment_stock_     => FALSE,
                           make_transaction_and_postings_ => FALSE,
                           report_earned_value_db_        => NULL,
                           from_part_catalog_rec_         => part_catalog_rec_,
                           to_part_catalog_rec_           => part_catalog_rec_,
                           transport_task_id_             => NULL,
                           validate_hu_struct_position_   => FALSE,
                           availability_ctrl_id_          => NULL,
                           always_preserve_serial_no_     => FALSE,
                           ownership_transfer_reason_id_  => NULL);
      END IF;
   END IF;
   Inventory_Event_Manager_API.Finish_Session;
END Reserve_Part;


-- Reserve_For_Transport
--   Reserves a part for a transport task. Generic scrapping method
PROCEDURE Reserve_For_Transport (
   quantity_reserved_ OUT NUMBER,
   contract_          IN  VARCHAR2,
   part_no_           IN  VARCHAR2,
   configuration_id_  IN  VARCHAR2,
   location_no_       IN  VARCHAR2,
   lot_batch_no_      IN  VARCHAR2,
   serial_no_         IN  VARCHAR2,
   eng_chg_level_     IN  VARCHAR2,
   waiv_dev_rej_no_   IN  VARCHAR2,
   activity_seq_      IN  NUMBER,
   handling_unit_id_  IN  NUMBER,
   quantity_          IN  NUMBER )
IS
   qty_available_  NUMBER;
   qty_to_reserve_ NUMBER;
   oldrec_         inventory_part_in_stock_tab%ROWTYPE;
   newrec_         inventory_part_in_stock_tab%ROWTYPE;
BEGIN

   oldrec_ := Lock_By_Keys___(contract_,
                              part_no_,
                              configuration_id_,
                              location_no_,
                              lot_batch_no_,
                              serial_no_,
                              eng_chg_level_,
                              waiv_dev_rej_no_,
                              activity_seq_,
                              handling_unit_id_);

   -- gelr:access_ctrl_for_inv_reserv, start
   User_Warehouse_Access_API.Check_Stock_Reserv_Allowed(Fnd_Session_API.Get_Fnd_User, oldrec_.contract, oldrec_.warehouse);
   -- gelr:access_ctrl_for_inv_reserv, end
   
   IF (oldrec_.location_type = Inventory_Location_Type_API.DB_SHIPMENT) THEN
      Error_SYS.Record_General(lu_name_, 'RFSNOLOCTYPE: Reservations for transport task are not allowed on location type :P1.', Inventory_Location_Type_API.Decode(oldrec_.location_type));
   END IF;

   IF (oldrec_.qty_onhand > 0) THEN
      newrec_              := oldrec_;
      qty_available_       := (oldrec_.qty_onhand - oldrec_.qty_reserved);
      qty_to_reserve_      := LEAST(qty_available_, quantity_);
      newrec_.qty_reserved := oldrec_.qty_reserved + qty_to_reserve_;

      Check_And_Update_By_Keys___(oldrec_ => oldrec_,newrec_ => newrec_);

      quantity_reserved_ := qty_to_reserve_;
   ELSE
      quantity_reserved_ := 0;
   END IF;
END Reserve_For_Transport;


-- Scrap_Part
--   Generic scrapping method.
PROCEDURE Scrap_Part (
   catch_quantity_               IN OUT NUMBER,
   contract_                     IN     VARCHAR2,
   part_no_                      IN     VARCHAR2,
   configuration_id_             IN     VARCHAR2,
   location_no_                  IN     VARCHAR2,
   lot_batch_no_                 IN     VARCHAR2,
   serial_no_                    IN     VARCHAR2,
   eng_chg_level_                IN     VARCHAR2,
   waiv_dev_rej_no_              IN     VARCHAR2,
   activity_seq_                 IN     NUMBER,
   handling_unit_id_             IN     NUMBER,
   quantity_                     IN     NUMBER,
   scrap_cause_                  IN     VARCHAR2,
   scrap_note_                   IN     VARCHAR2,
   order_no_                     IN     VARCHAR2 DEFAULT NULL,
   release_no_                   IN     VARCHAR2 DEFAULT NULL,
   sequence_no_                  IN     VARCHAR2 DEFAULT NULL,
   line_item_no_                 IN     VARCHAR2 DEFAULT NULL,
   order_type_                   IN     VARCHAR2 DEFAULT NULL,
   part_tracking_session_id_     IN     NUMBER   DEFAULT NULL,
   discon_zero_stock_handl_unit_ IN     BOOLEAN  DEFAULT TRUE,
   print_serviceability_tag_db_  IN     VARCHAR2 DEFAULT Gen_Yes_No_API.DB_NO )
IS
   serial_catch_tab_          Serial_Catch_Table;
   local_quantity_            NUMBER;
   local_catch_quantity_      NUMBER;
   total_serial_catch_qty_    NUMBER := 0;
   total_actual_catch_qty_    NUMBER := 0;
BEGIN
   Inventory_Event_Manager_API.Start_Session;

   IF (part_tracking_session_id_ IS NULL) THEN
      serial_catch_tab_(1).serial_no := serial_no_;
      local_catch_quantity_          := catch_quantity_;
      local_quantity_                := quantity_;
   ELSE
      Temporary_Part_Tracking_API.Get_Serials_And_Remove_Session(serial_catch_tab_,part_tracking_session_id_);

      IF (serial_catch_tab_.COUNT = 0) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'SCRAPNOSERIAL: No serials have been identified to scrap.');
      END IF;

      IF (serial_catch_tab_.COUNT != quantity_) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'SCRAPSERCOUNT: The quantity to be scrapped is :P1 but the number of identified serials is :P2', quantity_, serial_catch_tab_.COUNT);
      END IF;

      Split_Into_Serials(contract_           => contract_,
                         part_no_            => part_no_,
                         configuration_id_   => configuration_id_,
                         location_no_        => location_no_,
                         lot_batch_no_       => lot_batch_no_,
                         eng_chg_level_      => eng_chg_level_,
                         waiv_dev_rej_no_    => waiv_dev_rej_no_,
                         activity_seq_       => activity_seq_,
                         handling_unit_id_   => handling_unit_id_,
                         serial_catch_tab_   => serial_catch_tab_,
                         reservation_        => FALSE);

      local_quantity_       := 1;
      local_catch_quantity_ := NULL;
   END IF;

   FOR i IN serial_catch_tab_.FIRST..serial_catch_tab_.LAST LOOP
      Scrap_Part___(local_catch_quantity_,
                    contract_,
                    part_no_,
                    configuration_id_,
                    location_no_,
                    lot_batch_no_,
                    serial_catch_tab_(i).serial_no,
                    eng_chg_level_,
                    waiv_dev_rej_no_,
                    activity_seq_,
                    handling_unit_id_,
                    local_quantity_,
                    scrap_cause_,
                    scrap_note_,
                    order_no_,
                    release_no_,
                    sequence_no_,
                    line_item_no_,
                    order_type_);

      total_actual_catch_qty_ := total_actual_catch_qty_ + local_catch_quantity_;
      local_catch_quantity_   := NULL;
      total_serial_catch_qty_ := total_serial_catch_qty_ + serial_catch_tab_(i).catch_qty;

      IF (print_serviceability_tag_db_ = Gen_Yes_No_API.DB_YES) THEN
         Print_Serviceability_Tag___(part_no_ , serial_catch_tab_(i).serial_no, quantity_);
      END IF;
   END LOOP;
   
   IF (total_serial_catch_qty_ != catch_quantity_) THEN
      Error_SYS.Record_General('InventoryPartInStock', 'SCRAPSERCATCH: The total catch quantity to be scrapped is :P1 but the accumulated catch quantity on the serials is entered as :P2.', catch_quantity_, total_serial_catch_qty_);
   END IF;

   catch_quantity_ := total_actual_catch_qty_;

   Cleanup_Handl_Unit_Struct___(handling_unit_id_, discon_zero_stock_handl_unit_);
   Inventory_Event_Manager_API.Finish_Session;
END Scrap_Part;


-- Return_Rework
--   Generic method used to return parts to the delivery for rework.
PROCEDURE Return_Rework (
   catch_quantity_   IN OUT NUMBER,
   contract_         IN     VARCHAR2,
   part_no_          IN     VARCHAR2,
   configuration_id_ IN     VARCHAR2,
   location_no_      IN     VARCHAR2,
   lot_batch_no_     IN     VARCHAR2,
   serial_no_        IN     VARCHAR2,
   eng_chg_level_    IN     VARCHAR2,
   waiv_dev_rej_no_  IN     VARCHAR2,
   activity_seq_     IN     NUMBER,
   handling_unit_id_ IN     NUMBER, 
   quantity_         IN     NUMBER,
   return_cause_     IN     VARCHAR2,
   return_note_      IN     VARCHAR2,
   order_no_         IN     VARCHAR2 DEFAULT NULL,
   release_no_       IN     VARCHAR2 DEFAULT NULL,
   sequence_no_      IN     VARCHAR2 DEFAULT NULL,
   line_item_no_     IN     NUMBER   DEFAULT NULL,
   order_type_       IN     VARCHAR2 DEFAULT NULL )
IS
   transaction_id_            NUMBER;
   dummy_number_              NUMBER;
   transaction_               VARCHAR2(10) := 'RETWORK';
   acquisition_site_          INVENTORY_PART_IN_STOCK_TAB.contract%TYPE;
   acquisition_company_       VARCHAR2(20);
   this_company_              VARCHAR2(20);
   expiration_date_           DATE;
   empty_cost_detail_tab_     Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   internal_transit_delivery_ BOOLEAN;
   location_type_db_          INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   quantity_reserved_         NUMBER;

   CURSOR get_arrtran_expiration_date IS
      SELECT expiration_date
      FROM   inventory_transaction_hist_pub
      WHERE  source_ref_type    =  'PUR ORDER'
      AND    source_ref1        =  order_no_
      AND    source_ref2        =  release_no_
      AND    source_ref3        =  sequence_no_
      AND    NVL(source_ref4,0) =  NVL(line_item_no_,0)
      AND    transaction_code   = 'ARRTRAN';
BEGIN
   location_type_db_ := Inventory_Location_API.Get_Location_Type_Db(contract_,location_no_);

   this_company_              := Site_API.Get_Company(contract_);
   internal_transit_delivery_ := Is_Internal_Transit_Deliv___(order_no_,
                                                              release_no_,
                                                              sequence_no_);
   IF (internal_transit_delivery_) THEN
      acquisition_site_    := Get_Acquisition_Site___(order_no_);
      acquisition_company_ := Site_API.Get_Company(acquisition_site_);

      IF (acquisition_company_ = this_company_) THEN
         transaction_ := 'RETWORKINT';
      END IF;
   END IF;
   -- For Quality or Arrival location types, no inventory reservations exist for supplier shipment, 
   -- therefore reserved qty should not be reduced. For any other allowed location type, 
   -- inventory reservation exist for supplier shipment hence the reserved qty should be reduced.
   IF (location_type_db_ IN (Inventory_Location_Type_API.DB_QUALITY_ASSURANCE, 
                             Inventory_Location_Type_API.DB_ARRIVAL)) THEN
      quantity_reserved_ := 0;
   ELSE
      quantity_reserved_ := quantity_;
   END IF;
 
   Issue_Part_Impl___(transaction_id_               =>  transaction_id_,
                      accounting_id_                =>  dummy_number_,
                      trans_value_                  =>  dummy_number_,
                      catch_quantity_               =>  catch_quantity_,
                      contract_                     =>  contract_,
                      part_no_                      =>  part_no_,
                      configuration_id_             =>  configuration_id_,
                      location_no_                  =>  location_no_,
                      lot_batch_no_                 =>  lot_batch_no_,
                      serial_no_                    =>  serial_no_,
                      eng_chg_level_                =>  eng_chg_level_,
                      waiv_dev_rej_no_              =>  waiv_dev_rej_no_,
                      activity_seq_                 =>  activity_seq_,
                      handling_unit_id_             =>  handling_unit_id_,
                      transaction_                  =>  transaction_,
                      quantity_                     =>  quantity_,
                      quantity_reserved_            =>  quantity_reserved_,
                      source_ref1_                  =>  order_no_,
                      source_ref2_                  =>  release_no_,
                      source_ref3_                  =>  sequence_no_,
                      source_ref4_                  =>  line_item_no_,
                      source_ref5_                  =>  NULL,
                      source_                       =>  return_note_,
                      unreceive_                    =>  FALSE,
                      forced_                       =>  FALSE,
                      cost_detail_tab_              =>  empty_cost_detail_tab_,
                      source_ref_type_              =>  order_type_,
                      reject_code_                  =>  return_cause_,
                      remove_unit_cost_             =>  TRUE,
                      make_transaction_             =>  TRUE,
                      transit_location_group_       =>  NULL,
                      report_earned_value_db_       =>  NULL,
                      part_catalog_rec_             =>  NULL,
                      original_transaction_id_      =>  NULL,
                      prevent_fifo_action_          =>  FALSE,
                      ownership_transfer_reason_id_ =>  NULL);

   Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                         this_company_,
                                                         'N',
                                                         NULL);
      
   OPEN  get_arrtran_expiration_date;
   FETCH get_arrtran_expiration_date INTO expiration_date_;
   CLOSE get_arrtran_expiration_date;

   IF (transaction_ = 'RETWORKINT') THEN
      Inventory_Part_In_Transit_API.Move_Into_Order_Transit(delivering_contract_     => contract_,
                                                            contract_                => acquisition_site_,
                                                            part_no_                 => part_no_,
                                                            configuration_id_        => configuration_id_,
                                                            lot_batch_no_            => lot_batch_no_,
                                                            serial_no_               => serial_no_,
                                                            eng_chg_level_           => eng_chg_level_,
                                                            waiv_dev_rej_no_         => waiv_dev_rej_no_,
                                                            handling_unit_id_        => handling_unit_id_,
                                                            expiration_date_         => expiration_date_,
                                                            delivering_warehouse_id_ => '*',
                                                            receiving_warehouse_id_  => '*',
                                                            activity_seq_            => 0 ,
                                                            part_ownership_db_       => Part_Ownership_API.DB_COMPANY_OWNED ,
                                                            owning_customer_no_      => '*',
                                                            owning_vendor_no_        => '*',
                                                            deliv_no_                => 0,
                                                            shipment_id_             => 0,
                                                            shipment_line_no_        => 0,
                                                            quantity_                => quantity_,
                                                            catch_quantity_          => catch_quantity_,
                                                            transaction_id_          => transaction_id_,
                                                            trans_order_no_          => order_no_,
                                                            trans_line_no_           => release_no_,
                                                            trans_rel_no_            => sequence_no_,
                                                            trans_line_item_no_      => line_item_no_);
   END IF;
END Return_Rework;


-- Undo_Return_Rework
--   Unissue and Reverse the Transactions, RINTORDTR is handled differently
PROCEDURE Undo_Return_Rework (
   transaction_id_       OUT NUMBER,
   unissue_transaction_  IN  VARCHAR2,
   pos_diff_transaction_ IN  VARCHAR2,
   neg_diff_transaction_ IN  VARCHAR2,
   quantity_             IN  NUMBER,
   catch_quantity_       IN  NUMBER,
   transaction_id_issue_ IN  NUMBER,
   source_               IN  VARCHAR2 )
IS   
BEGIN   
   Unissue_Part(transaction_id_,
                unissue_transaction_,
                pos_diff_transaction_,
                neg_diff_transaction_,
                quantity_,
                catch_quantity_,
                transaction_id_issue_,
                source_);
END Undo_Return_Rework;


-- Return_Credit
--   Generic method for returning parts to supplier and get credit for it.
PROCEDURE Return_Credit (
   catch_quantity_   IN OUT NUMBER,
   contract_         IN     VARCHAR2,
   part_no_          IN     VARCHAR2,
   configuration_id_ IN     VARCHAR2,
   location_no_      IN     VARCHAR2,
   lot_batch_no_     IN     VARCHAR2,
   serial_no_        IN     VARCHAR2,
   eng_chg_level_    IN     VARCHAR2,
   waiv_dev_rej_no_  IN     VARCHAR2,
   activity_seq_     IN     NUMBER,
   handling_unit_id_ IN     NUMBER, 
   quantity_         IN     NUMBER,
   return_cause_     IN     VARCHAR2,
   return_note_      IN     VARCHAR2,
   order_no_         IN     VARCHAR2 DEFAULT NULL,
   release_no_       IN     VARCHAR2 DEFAULT NULL,
   sequence_no_      IN     VARCHAR2 DEFAULT NULL,
   line_item_no_     IN     NUMBER   DEFAULT NULL,
   order_type_       IN     VARCHAR2 DEFAULT NULL )
IS
   transaction_id_            NUMBER;
   dummy_number_              NUMBER;
   this_company_              VARCHAR2(20);
   acquisition_company_       VARCHAR2(20);
   acquisition_site_          INVENTORY_PART_IN_STOCK_TAB.contract%TYPE;
   empty_cost_detail_tab_     Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   internal_transit_delivery_ BOOLEAN;
   location_type_db_          INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   quantity_reserved_         NUMBER;
BEGIN
   location_type_db_          := Inventory_Location_API.Get_Location_Type_Db(contract_,location_no_);
   this_company_              := Site_API.Get_Company(contract_);
   internal_transit_delivery_ := Is_Internal_Transit_Deliv___(order_no_,
                                                              release_no_,
                                                              sequence_no_);
   IF (internal_transit_delivery_) THEN
      acquisition_site_    := Get_Acquisition_Site___(order_no_);
      acquisition_company_ := Site_API.Get_Company(acquisition_site_);

      IF (acquisition_company_ = this_company_) THEN
         Error_SYS.Record_General(lu_name_, 'INTERNTRANSIT: When internal order supply is used it''s not allowed to return for credit if demand and supply site belong to the same company.');
      END IF;
   END IF;
   
   -- For Quality or Arrival location types, no inventory reservations exist for supplier shipment, 
   -- therefore reserved qty should not be reduced. For any other allowed location type, 
   -- inventory reservation exist for supplier shipment hence the reserved qty should be reduced.
   IF (location_type_db_ IN (Inventory_Location_Type_API.DB_QUALITY_ASSURANCE, 
                             Inventory_Location_Type_API.DB_ARRIVAL)) THEN
      quantity_reserved_ := 0;
   ELSE
      quantity_reserved_ := quantity_;
   END IF;

   Issue_Part_Impl___(transaction_id_               =>  transaction_id_,
                      accounting_id_                =>  dummy_number_,
                      trans_value_                  =>  dummy_number_,
                      catch_quantity_               =>  catch_quantity_,
                      contract_                     =>  contract_,
                      part_no_                      =>  part_no_,
                      configuration_id_             =>  configuration_id_,
                      location_no_                  =>  location_no_,
                      lot_batch_no_                 =>  lot_batch_no_,
                      serial_no_                    =>  serial_no_,
                      eng_chg_level_                =>  eng_chg_level_,
                      waiv_dev_rej_no_              =>  waiv_dev_rej_no_,
                      activity_seq_                 =>  activity_seq_,
                      handling_unit_id_             =>  handling_unit_id_,
                      transaction_                  =>  'RETCREDIT',
                      quantity_                     =>  quantity_,
                      quantity_reserved_            =>  quantity_reserved_,
                      source_ref1_                  =>  order_no_,
                      source_ref2_                  =>  release_no_,
                      source_ref3_                  =>  sequence_no_,
                      source_ref4_                  =>  line_item_no_,
                      source_ref5_                  =>  NULL,
                      source_                       =>  return_note_,
                      unreceive_                    =>  FALSE,
                      forced_                       =>  FALSE,
                      cost_detail_tab_              =>  empty_cost_detail_tab_,
                      source_ref_type_              =>  order_type_,
                      reject_code_                  =>  return_cause_,
                      remove_unit_cost_             =>  TRUE,
                      make_transaction_             =>  TRUE,
                      transit_location_group_       =>  NULL,
                      report_earned_value_db_       =>  NULL,
                      part_catalog_rec_             =>  NULL,
                      original_transaction_id_      =>  NULL,
                      prevent_fifo_action_          =>  FALSE,
                      ownership_transfer_reason_id_ =>  NULL);

   Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                         this_company_,
                                                         'N',
                                                         NULL);
END Return_Credit;


-- Issue_Part
--   Generic issue method.
--   Generic issue method.
PROCEDURE Issue_Part (
   catch_quantity_               IN OUT NUMBER,
   contract_                     IN     VARCHAR2,
   part_no_                      IN     VARCHAR2,
   configuration_id_             IN     VARCHAR2,
   location_no_                  IN     VARCHAR2,
   lot_batch_no_                 IN     VARCHAR2,
   serial_no_                    IN     VARCHAR2,
   eng_chg_level_                IN     VARCHAR2,
   waiv_dev_rej_no_              IN     VARCHAR2,
   activity_seq_                 IN     NUMBER,
   handling_unit_id_             IN     NUMBER,
   transaction_                  IN     VARCHAR2,
   quantity_                     IN     NUMBER,
   quantity_reserved_            IN     NUMBER,
   source_ref1_                  IN     VARCHAR2,
   source_ref2_                  IN     VARCHAR2,
   source_ref3_                  IN     VARCHAR2,
   source_ref4_                  IN     VARCHAR2,
   source_ref5_                  IN     VARCHAR2,
   source_                       IN     VARCHAR2,
   source_ref_type_              IN     VARCHAR2 DEFAULT NULL,
   dest_contract_                IN     VARCHAR2 DEFAULT NULL,
   ignore_this_avail_control_id_ IN     VARCHAR2 DEFAULT NULL,
   destination_warehouse_id_     IN     VARCHAR2 DEFAULT NULL )
IS
   transaction_id_                NUMBER;
   original_transaction_id_       NUMBER;
   prevent_fifo_action_           BOOLEAN := FALSE;
   allow_exceeding_available_qty_ BOOLEAN := FALSE;
   empty_cost_detail_tab_         Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
BEGIN
   Issue_Part(transaction_id_                => transaction_id_,
              catch_quantity_                => catch_quantity_,
              issue_correction_              => NULL,
              issue_corr_cost_detail_tab_    => empty_cost_detail_tab_,
              contract_                      => contract_,
              part_no_                       => part_no_,
              configuration_id_              => configuration_id_,
              location_no_                   => location_no_,
              lot_batch_no_                  => lot_batch_no_,
              serial_no_                     => serial_no_,
              eng_chg_level_                 => eng_chg_level_,
              waiv_dev_rej_no_               => waiv_dev_rej_no_,
              activity_seq_                  => activity_seq_,
              handling_unit_id_              => handling_unit_id_,
              transaction_                   => transaction_,
              quantity_                      => quantity_,
              quantity_reserved_             => quantity_reserved_,
              source_ref1_                   => source_ref1_,
              source_ref2_                   => source_ref2_,
              source_ref3_                   => source_ref3_,
              source_ref4_                   => source_ref4_,
              source_ref5_                   => source_ref5_,
              source_                        => source_,
              source_ref_type_               => source_ref_type_,
              dest_contract_                 => dest_contract_,
              destination_warehouse_id_      => destination_warehouse_id_, 
              original_transaction_id_       => original_transaction_id_,
              prevent_fifo_action_           => prevent_fifo_action_,
              allow_exceeding_available_qty_ => allow_exceeding_available_qty_,
              ignore_this_avail_control_id_  => ignore_this_avail_control_id_ );
END Issue_Part;


-- Issue_Part
--   Generic issue method.
--   Generic issue method.
PROCEDURE Issue_Part (
   transaction_id_               OUT    NUMBER,
   catch_quantity_               IN OUT NUMBER,
   contract_                     IN     VARCHAR2,
   part_no_                      IN     VARCHAR2,
   configuration_id_             IN     VARCHAR2,
   location_no_                  IN     VARCHAR2,
   lot_batch_no_                 IN     VARCHAR2,
   serial_no_                    IN     VARCHAR2,
   eng_chg_level_                IN     VARCHAR2,
   waiv_dev_rej_no_              IN     VARCHAR2,
   activity_seq_                 IN     NUMBER,
   handling_unit_id_             IN     NUMBER,
   transaction_                  IN     VARCHAR2,
   quantity_                     IN     NUMBER,
   quantity_reserved_            IN     NUMBER,
   source_ref1_                  IN     VARCHAR2,
   source_ref2_                  IN     VARCHAR2,
   source_ref3_                  IN     VARCHAR2,
   source_ref4_                  IN     VARCHAR2,
   source_ref5_                  IN     VARCHAR2,
   source_                       IN     VARCHAR2,
   source_ref_type_              IN     VARCHAR2,
   dest_contract_                IN     VARCHAR2 DEFAULT NULL,
   ignore_this_avail_control_id_ IN     VARCHAR2 DEFAULT NULL,
   validate_hu_struct_position_  IN     BOOLEAN DEFAULT TRUE,
   destination_warehouse_id_     IN     VARCHAR2 DEFAULT NULL,
   reject_code_                  IN     VARCHAR2 DEFAULT NULL)
IS
   original_transaction_id_       NUMBER;
   prevent_fifo_action_           BOOLEAN := FALSE;
   allow_exceeding_available_qty_ BOOLEAN := FALSE;
   empty_cost_detail_tab_         Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
BEGIN

   Issue_Part(transaction_id_                => transaction_id_,
              catch_quantity_                => catch_quantity_,
              issue_correction_              => NULL,
              issue_corr_cost_detail_tab_    => empty_cost_detail_tab_,
              contract_                      => contract_,
              part_no_                       => part_no_,
              configuration_id_              => configuration_id_,
              location_no_                   => location_no_,
              lot_batch_no_                  => lot_batch_no_,
              serial_no_                     => serial_no_,
              eng_chg_level_                 => eng_chg_level_,
              waiv_dev_rej_no_               => waiv_dev_rej_no_,
              activity_seq_                  => activity_seq_,
              handling_unit_id_              => handling_unit_id_,
              transaction_                   => transaction_,
              quantity_                      => quantity_,
              quantity_reserved_             => quantity_reserved_,
              source_ref1_                   => source_ref1_,
              source_ref2_                   => source_ref2_,
              source_ref3_                   => source_ref3_,
              source_ref4_                   => source_ref4_,
              source_ref5_                   => source_ref5_,
              source_                        => source_,
              source_ref_type_               => source_ref_type_,
              dest_contract_                 => dest_contract_,
              destination_warehouse_id_      => destination_warehouse_id_, 
              original_transaction_id_       => original_transaction_id_,
              prevent_fifo_action_           => prevent_fifo_action_,
              allow_exceeding_available_qty_ => allow_exceeding_available_qty_,
              ignore_this_avail_control_id_  => ignore_this_avail_control_id_,
              validate_hu_struct_position_   => validate_hu_struct_position_,
              reject_code_                   =>  reject_code_);
END Issue_Part;


-- Issue_Part
--   Generic issue method.
--   Generic issue method.
PROCEDURE Issue_Part (
   transaction_id_                   OUT NUMBER,
   catch_quantity_                IN OUT NUMBER,
   issue_correction_              IN     VARCHAR2,
   issue_corr_cost_detail_tab_    IN     Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   contract_                      IN     VARCHAR2,
   part_no_                       IN     VARCHAR2,
   configuration_id_              IN     VARCHAR2,
   location_no_                   IN     VARCHAR2,
   lot_batch_no_                  IN     VARCHAR2,
   serial_no_                     IN     VARCHAR2,
   eng_chg_level_                 IN     VARCHAR2,
   waiv_dev_rej_no_               IN     VARCHAR2,
   activity_seq_                  IN     NUMBER,
   handling_unit_id_              IN     NUMBER, 
   transaction_                   IN     VARCHAR2,
   quantity_                      IN     NUMBER,
   quantity_reserved_             IN     NUMBER,
   source_ref1_                   IN     VARCHAR2,
   source_ref2_                   IN     VARCHAR2,
   source_ref3_                   IN     VARCHAR2,
   source_ref4_                   IN     VARCHAR2,
   source_ref5_                   IN     VARCHAR2,
   source_                        IN     VARCHAR2,
   source_ref_type_               IN     VARCHAR2,
   dest_contract_                 IN     VARCHAR2,
   destination_warehouse_id_      IN     VARCHAR2,
   original_transaction_id_       IN     NUMBER,
   prevent_fifo_action_           IN     BOOLEAN,
   allow_exceeding_available_qty_ IN     BOOLEAN,
   ignore_this_avail_control_id_  IN     VARCHAR2 DEFAULT NULL,
   validate_hu_struct_position_   IN     BOOLEAN  DEFAULT TRUE,
   reject_code_                   IN     VARCHAR2 DEFAULT NULL)
IS
   transaction_id_tmp_           NUMBER;
   accounting_id_                NUMBER;
   trans_value_                  NUMBER;
   dummy_number_                 NUMBER;
   unreceive_                    BOOLEAN;
   lurec_                        INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   company_                      VARCHAR2(20);
   dummy_date_                   DATE;
   dummy_string_                 VARCHAR2(100);
   remove_unit_cost_             BOOLEAN := TRUE;
   receiving_warehouse_id_       VARCHAR2(15);
   source_ref_type_db_           VARCHAR2(50);
   expiration_date_              DATE;
   
   CURSOR get_arrtran_expiration_date IS
      SELECT expiration_date
      FROM   inventory_transaction_hist_pub
      WHERE  source_ref_type    =  'PUR ORDER'
      AND    source_ref1        =  source_ref1_
      AND    source_ref2        =  source_ref2_
      AND    source_ref3        =  source_ref3_
      AND    NVL(source_ref4,0) =  NVL(source_ref4_,0)
      AND    transaction_code   = 'ARRTRAN';
BEGIN
       
   lurec_ := Get_Object_By_Keys___(contract_,
                                   part_no_,
                                   configuration_id_,
                                   location_no_,
                                   lot_batch_no_,
                                   serial_no_,
                                   eng_chg_level_,
                                   waiv_dev_rej_no_,
                                   activity_seq_,
                                   handling_unit_id_);
                   
   IF lurec_.location_type NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                   Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                   Inventory_Location_Type_API.DB_SHIPMENT,
                                   Inventory_Location_Type_API.DB_PRODUCTION_LINE) THEN
      Error_SYS.Record_General('InventoryPartInStock','LOCTYPEERR: Issue of part is not allowed from location type :P1',Inventory_Location_Type_API.Decode(lurec_.location_type));
   END IF;

   IF (NVL(issue_correction_, 'NO') = 'NO') THEN
      unreceive_ := FALSE;
   ELSE
      unreceive_ := TRUE;
   END IF;

   IF (unreceive_) THEN
      NULL; -- Don't make availability check when making a correction,
            -- called from InventoryTransactionHist ReverseTransaction
   ELSE      
      IF ((lurec_.availability_control_id IS NULL) OR
         (ignore_this_avail_control_id_   IS NULL) OR
         (lurec_.availability_control_id != ignore_this_avail_control_id_)) THEN
            IF (Part_Availability_Control_API.Check_Order_Issue_Control(lurec_.availability_control_id)
                                                       != 'ORDER ISSUE') THEN
               Error_SYS.Record_General(lu_name_, 'AVAILIDORDISSUE: Part :P1 with availability control id :P2 cannot be issued', part_no_, lurec_.availability_control_id);
            END IF;
      END IF;
   END IF;

   --Make ONE call to fetch company.
   company_ := Site_API.Get_Company(contract_);
   
   IF (transaction_ IN ('CRO-EXD-OU', 'CO-DELV-OU', 'DELCONF-OU')) THEN
      remove_unit_cost_ := FALSE;
   END IF;

   Issue_Part_Impl___(transaction_id_               =>  transaction_id_tmp_,
                      accounting_id_                =>  accounting_id_,
                      trans_value_                  =>  trans_value_,
                      catch_quantity_               =>  catch_quantity_,
                      contract_                     =>  contract_,
                      part_no_                      =>  part_no_,
                      configuration_id_             =>  configuration_id_,
                      location_no_                  =>  location_no_,
                      lot_batch_no_                 =>  lot_batch_no_,
                      serial_no_                    =>  serial_no_,
                      eng_chg_level_                =>  eng_chg_level_,
                      waiv_dev_rej_no_              =>  waiv_dev_rej_no_,
                      activity_seq_                 =>  activity_seq_,
                      handling_unit_id_             =>  handling_unit_id_,
                      transaction_                  =>  transaction_,
                      quantity_                     =>  quantity_,
                      quantity_reserved_            =>  quantity_reserved_,
                      source_ref1_                  =>  source_ref1_,
                      source_ref2_                  =>  source_ref2_,
                      source_ref3_                  =>  source_ref3_,
                      source_ref4_                  =>  source_ref4_,
                      source_ref5_                  =>  source_ref5_,
                      source_                       =>  source_,
                      unreceive_                    =>  unreceive_,
                      forced_                       =>  allow_exceeding_available_qty_,
                      cost_detail_tab_              =>  issue_corr_cost_detail_tab_,
                      source_ref_type_              =>  source_ref_type_,
                      reject_code_                  =>  reject_code_,
                      remove_unit_cost_             =>  remove_unit_cost_,
                      make_transaction_             =>  TRUE,
                      transit_location_group_       =>  NULL,
                      report_earned_value_db_       =>  NULL,
                      part_catalog_rec_             =>  NULL,
                      original_transaction_id_      =>  original_transaction_id_,
                      prevent_fifo_action_          =>  prevent_fifo_action_,
                      ownership_transfer_reason_id_ =>  NULL,
                      validate_hu_struct_position_  =>  validate_hu_struct_position_);

   IF (unreceive_) THEN
      NULL; -- Don't make accountings when making a correction,
            -- called from InventoryTransactionHist ReverseTransaction
   ELSE
      Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_tmp_,
                                                            company_,
                                                            'N',
                                                            NULL);
   END IF;

   $IF Component_Purch_SYS.INSTALLED $THEN      
      Receive_Purchase_Order_API.Create_Consignment_Transaction(transaction_id_tmp_);                
   $END

   transaction_id_ := transaction_id_tmp_;

   IF transaction_ = 'CO-DELV-OU' THEN
      IF (configuration_id_ != '*') THEN
         Error_SYS.Record_General(lu_name_, 'CONFCUSTCONS: Delivery to consignment stock at customer is not allowed for configured parts.');
      END IF;

      $IF (Component_Order_SYS.INSTALLED) $THEN
         Customer_Consignment_Stock_API.Increase_Consignment_Stock_Qty (contract_                     => contract_,
                                                                        part_no_                      => part_no_,
                                                                        configuration_id_             => configuration_id_,
                                                                        lot_batch_no_                 => lot_batch_no_,
                                                                        serial_no_                    => serial_no_,
                                                                        eng_chg_level_                => eng_chg_level_,
                                                                        waiv_dev_rej_no_              => waiv_dev_rej_no_,
                                                                        activity_seq_                 => activity_seq_,
                                                                        handling_unit_id_             => handling_unit_id_,
                                                                        expiration_date_              => lurec_.expiration_date,
                                                                        transaction_id_               => transaction_id_tmp_,
                                                                        transaction_code_             => 'CO-DELV-IN',
                                                                        project_id_                   => lurec_.project_id,
                                                                        order_no_                     => source_ref1_,
                                                                        release_no_                   => source_ref2_,
                                                                        sequence_no_                  => source_ref3_,
                                                                        line_item_no_                 => source_ref4_,
                                                                        deliv_no_                     => source_ref5_,
                                                                        quantity_                     => quantity_,
                                                                        catch_quantity_               => catch_quantity_,
                                                                        validate_hu_struct_position_  => validate_hu_struct_position_);
      $END
   END IF;

   IF transaction_ = 'DELCONF-OU' THEN
      IF (configuration_id_ != '*') THEN
         Error_SYS.Record_General(lu_name_, 'CONFIGDELCONFIRM: Delivery confirmation is not allowed for configured parts.');
      END IF;

      Inventory_Part_At_Customer_API.Increase_Our_Qty_At_Customer ( contract_         => contract_,
                                                                    part_no_          => part_no_,
                                                                    configuration_id_ => dummy_string_,
                                                                    lot_batch_no_     => dummy_string_,
                                                                    serial_no_        => dummy_string_,
                                                                    eng_chg_level_    => dummy_string_,
                                                                    waiv_dev_rej_no_  => dummy_string_,
                                                                    activity_seq_     => dummy_number_,
                                                                    handling_unit_id_ => dummy_number_,
                                                                    customer_no_      => dummy_string_,
                                                                    addr_no_          => dummy_string_,
                                                                    expiration_date_  => dummy_date_,
                                                                    process_type_db_  => Stock_At_Cust_Process_Type_API.DB_DELIVERY_CONFIRMATION,
                                                                    transaction_id_   => transaction_id_tmp_,
                                                                    transaction_code_ => 'DELCONF-IN',
                                                                    project_id_       => lurec_.project_id,
                                                                    source_ref1_      => source_ref1_,
                                                                    source_ref2_      => source_ref2_,
                                                                    source_ref3_      => source_ref3_,
                                                                    source_ref4_      => source_ref4_,
                                                                    source_ref5_      => source_ref5_,
                                                                    quantity_         => quantity_,
                                                                    catch_quantity_   => catch_quantity_);  
   END IF;
   
   IF transaction_ = 'CRO-EXD-OU' THEN        
      Inventory_Part_At_Customer_API.Increase_Our_Qty_At_Customer ( contract_         => contract_,
                                                                    part_no_          => part_no_,
                                                                    configuration_id_ => configuration_id_,
                                                                    lot_batch_no_     => lot_batch_no_,
                                                                    serial_no_        => serial_no_,
                                                                    eng_chg_level_    => eng_chg_level_,
                                                                    waiv_dev_rej_no_  => waiv_dev_rej_no_,
                                                                    activity_seq_     => activity_seq_,
                                                                    handling_unit_id_ => handling_unit_id_,
                                                                    customer_no_      => dummy_string_,
                                                                    addr_no_          => dummy_string_,
                                                                    expiration_date_  => lurec_.expiration_date,
                                                                    process_type_db_  => Stock_At_Cust_Process_Type_API.DB_PART_EXCHANGE,
                                                                    transaction_id_   => transaction_id_tmp_,
                                                                    transaction_code_ => 'CRO-EXD-IN',
                                                                    project_id_       => lurec_.project_id,
                                                                    source_ref1_      => source_ref1_,
                                                                    source_ref2_      => source_ref2_,
                                                                    source_ref3_      => source_ref3_,
                                                                    source_ref4_      => source_ref4_,
                                                                    source_ref5_      => source_ref5_,
                                                                    quantity_         => quantity_,
                                                                    catch_quantity_   => catch_quantity_);
   END IF;

   IF (transaction_ IN ('SHIPTRAN', 'SHIPDIR', 'PURTRAN', 'SHIPODSIT-', 'SHIPODWHS-', 'RETWORKINT')) AND (dest_contract_ IS NOT NULL) THEN
      IF ((lurec_.part_ownership IN (Part_Ownership_API.DB_COMPANY_OWNED, Part_Ownership_API.DB_CONSIGNMENT))
         OR ((transaction_ IN ('SHIPODSIT-', 'SHIPODWHS-')) AND (lurec_.part_ownership IN (Part_Ownership_API.DB_CUSTOMER_OWNED,
              Part_Ownership_API.DB_SUPPLIER_LOANED, Part_Ownership_API.DB_SUPPLIER_RENTED, Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)))) THEN
         
         source_ref_type_db_ := Order_Type_API.Encode(source_ref_type_);
         IF ((source_ref_type_db_ = Order_Type_API.DB_SHIPMENT_ORDER) AND
             (Warehouse_API.Get_Remote_Warehouse_Db(contract_, lurec_.warehouse)) = Fnd_Boolean_API.DB_TRUE) THEN
            receiving_warehouse_id_ := lurec_.warehouse;
         ELSE   
            receiving_warehouse_id_ := '*';
         END IF;
         
         IF (transaction_ = 'RETWORKINT') THEN 
            OPEN  get_arrtran_expiration_date;
            FETCH get_arrtran_expiration_date INTO expiration_date_;
            CLOSE get_arrtran_expiration_date;
         ELSE 
            expiration_date_ := lurec_.expiration_date;
         END IF;
         
         Inventory_Part_In_Transit_API.Move_Into_Order_Transit(delivering_contract_         => contract_,
                                                               contract_                    => dest_contract_,
                                                               part_no_                     => part_no_,
                                                               configuration_id_            => configuration_id_,
                                                               lot_batch_no_                => lot_batch_no_,
                                                               serial_no_                   => serial_no_,
                                                               eng_chg_level_               => eng_chg_level_,
                                                               waiv_dev_rej_no_             => waiv_dev_rej_no_,
                                                               handling_unit_id_            => handling_unit_id_,
                                                               expiration_date_             => expiration_date_,
                                                               delivering_warehouse_id_     => receiving_warehouse_id_,
                                                               receiving_warehouse_id_      => destination_warehouse_id_,
                                                               activity_seq_                => activity_seq_,
                                                               part_ownership_db_           => NVL(lurec_.part_ownership, Part_Ownership_API.DB_COMPANY_OWNED), 
                                                               owning_customer_no_          => NVL(lurec_.owning_customer_no, '*'),
                                                               owning_vendor_no_            => NVL(lurec_.owning_vendor_no, '*'),
                                                               deliv_no_                    => 0,
                                                               shipment_id_                 => 0,
                                                               shipment_line_no_            => 0,
                                                               quantity_                    => quantity_,
                                                               catch_quantity_              => catch_quantity_,
                                                               transaction_id_              => transaction_id_tmp_,
                                                               trans_order_no_              => source_ref1_,
                                                               trans_line_no_               => source_ref2_,
                                                               trans_rel_no_                => source_ref3_,
                                                               trans_line_item_no_          => source_ref4_,
                                                               validate_hu_struct_position_ => validate_hu_struct_position_);
                                                               
         IF (transaction_ IN ('SHIPTRAN', 'SHIPDIR', 'PURTRAN')) THEN                                                      
            $IF Component_Order_SYS.INSTALLED $THEN
               Intersite_Profit_Manager_API.Create_Intersite_Transactions( contract_,
                                                                           dest_contract_,
                                                                           part_no_,
                                                                           configuration_id_,
                                                                           lot_batch_no_,
                                                                           serial_no_,
                                                                           eng_chg_level_,
                                                                           waiv_dev_rej_no_,
                                                                           quantity_,
                                                                           company_,
                                                                           source_ref1_,
                                                                           source_ref2_,
                                                                           source_ref3_,
                                                                           source_ref4_,
                                                                           transaction_id_tmp_,
                                                                           source_ref5_);       
            $ELSE
               NULL; 
            $END
         END IF;
      END IF;
   END IF;
END Issue_Part;


-- Find_And_Issue_Part
--   Find a location with a quantity available and issue parts.
--   Find a location with a quantity available and issue parts.
--   Generic Find and Issue method. It also returns the Transaction ID.
--   Find a location with a keys and quantity available and issue parts.
PROCEDURE Find_And_Issue_Part (
   quantity_                     OUT    NUMBER,
   location_no_                  IN OUT VARCHAR2,
   lot_batch_no_                 IN OUT VARCHAR2,
   serial_no_                    IN OUT VARCHAR2,
   eng_chg_level_                IN OUT VARCHAR2,
   waiv_dev_rej_no_              IN OUT VARCHAR2,
   configuration_id_             IN OUT VARCHAR2,
   activity_seq_                 IN OUT NUMBER,
   handling_unit_id_             IN OUT NUMBER,
   contract_                     IN     VARCHAR2,
   part_no_                      IN     VARCHAR2,
   location_type_                IN     VARCHAR2,
   issue_quantity_               IN     NUMBER,
   transaction_                  IN     VARCHAR2,
   order_no_                     IN     VARCHAR2,
   line_no_                      IN     VARCHAR2,
   release_no_                   IN     VARCHAR2,
   line_item_no_                 IN     NUMBER,
   source_                       IN     VARCHAR2,
   project_id_                   IN     VARCHAR2,
   condition_code_               IN     VARCHAR2 DEFAULT NULL,
   part_ownership_               IN     VARCHAR2 DEFAULT 'COMPANY OWNED',
   owning_vendor_no_             IN     VARCHAR2 DEFAULT NULL,
   owning_customer_no_           IN     VARCHAR2 DEFAULT NULL,
   warehouse_id_                 IN 	 VARCHAR2 DEFAULT NULL,
   ignore_this_avail_control_id_ IN 	 VARCHAR2 DEFAULT NULL )
IS
   transaction_id_ NUMBER;
   catch_quantity_ NUMBER := NULL;
BEGIN
   Find_And_Issue_Part(quantity_                     => quantity_,
                       catch_quantity_               => catch_quantity_,
                       transaction_id_               => transaction_id_,
                       location_no_                  => location_no_,
                       lot_batch_no_                 => lot_batch_no_,
                       serial_no_                    => serial_no_,
                       eng_chg_level_                => eng_chg_level_,
                       waiv_dev_rej_no_              => waiv_dev_rej_no_,
                       configuration_id_             => configuration_id_,
                       activity_seq_                 => activity_seq_,
                       handling_unit_id_             => handling_unit_id_,
                       contract_                     => contract_,
                       part_no_                      => part_no_,
                       location_type_                => location_type_,
                       issue_quantity_               => issue_quantity_,
                       transaction_                  => transaction_,
                       order_no_                     => order_no_,
                       line_no_                      => line_no_,
                       release_no_                   => release_no_,
                       line_item_no_                 => line_item_no_,
                       source_                       => source_,
                       project_id_                   => project_id_,
                       condition_code_               => condition_code_,
                       part_ownership_               => part_ownership_,
                       owning_vendor_no_             => owning_vendor_no_,
                       owning_customer_no_           => owning_customer_no_,
                       warehouse_id_                 => warehouse_id_,
                       ignore_this_avail_control_id_ => ignore_this_avail_control_id_ );

END Find_And_Issue_Part;


-- Find_And_Issue_Part
--   Find a location with a quantity available and issue parts.
--   Find a location with a quantity available and issue parts.
--   Generic Find and Issue method. It also returns the Transaction ID.
--   Find a location with a keys and quantity available and issue parts.
PROCEDURE Find_And_Issue_Part (
   quantity_                     OUT    NUMBER,
   catch_quantity_               OUT    NUMBER,
   transaction_id_               OUT    NUMBER,
   location_no_                  IN OUT VARCHAR2,
   lot_batch_no_                 IN OUT VARCHAR2,
   serial_no_                    IN OUT VARCHAR2,
   eng_chg_level_                IN OUT VARCHAR2,
   waiv_dev_rej_no_              IN OUT VARCHAR2,
   configuration_id_             IN OUT VARCHAR2,
   activity_seq_                 IN OUT NUMBER,
   handling_unit_id_             IN OUT NUMBER,
   contract_                     IN     VARCHAR2,
   part_no_                      IN     VARCHAR2,
   location_type_                IN     VARCHAR2,
   issue_quantity_               IN     NUMBER,
   transaction_                  IN     VARCHAR2,
   order_no_                     IN     VARCHAR2,
   line_no_                      IN     VARCHAR2,
   release_no_                   IN     VARCHAR2,
   line_item_no_                 IN     NUMBER,
   source_                       IN     VARCHAR2,
   project_id_                   IN     VARCHAR2,
   condition_code_               IN     VARCHAR2 DEFAULT NULL,
   part_ownership_               IN     VARCHAR2 DEFAULT 'COMPANY OWNED',
   owning_vendor_no_             IN     VARCHAR2 DEFAULT NULL,
   owning_customer_no_           IN     VARCHAR2 DEFAULT NULL,
   warehouse_id_                 IN 	 VARCHAR2 DEFAULT NULL,
   ignore_this_avail_control_id_ IN 	 VARCHAR2 DEFAULT NULL )
IS
   keys_and_qty_tab_ Keys_And_Qty_Tab;
   location_type_db_ INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;

BEGIN
   location_type_db_ := Inventory_Location_Type_API.Encode(location_type_);

   Find_And_Issue_Part(keys_and_qty_tab_             => keys_and_qty_tab_,
                       location_no_                  => location_no_,
                       lot_batch_no_                 => lot_batch_no_,
                       serial_no_                    => serial_no_,
                       eng_chg_level_                => eng_chg_level_,
                       waiv_dev_rej_no_              => waiv_dev_rej_no_,
                       configuration_id_             => configuration_id_,
                       activity_seq_                 => activity_seq_,
                       handling_unit_id_             => handling_unit_id_,
                       contract_                     => contract_,
                       part_no_                      => part_no_,
                       location_type_db_             => location_type_db_,
                       qty_to_issue_                 => issue_quantity_,
                       transaction_code_             => transaction_,
                       source_ref1_                  => order_no_,
                       source_ref2_                  => line_no_,
                       source_ref3_                  => release_no_,
                       source_ref4_                  => line_item_no_,
                       source_ref_type_              => NULL,
                       source_                       => source_,
                       project_id_                   => project_id_,
                       condition_code_               => condition_code_,
                       part_ownership_db_            => part_ownership_,
                       owning_vendor_no_             => owning_vendor_no_,
                       owning_customer_no_           => owning_customer_no_,
                       only_one_lot_allowed_         => FALSE,
                       many_records_allowed_         => FALSE,
                       warehouse_id_                 => warehouse_id_,
                       ignore_this_avail_control_id_ => ignore_this_avail_control_id_);

   IF (keys_and_qty_tab_.COUNT > 0) THEN
      quantity_         := keys_and_qty_tab_(1).quantity;
      catch_quantity_   := keys_and_qty_tab_(1).catch_quantity;
      location_no_      := keys_and_qty_tab_(1).location_no;
      lot_batch_no_     := keys_and_qty_tab_(1).lot_batch_no;
      serial_no_        := keys_and_qty_tab_(1).serial_no;
      eng_chg_level_    := keys_and_qty_tab_(1).eng_chg_level;
      waiv_dev_rej_no_  := keys_and_qty_tab_(1).waiv_dev_rej_no;
      configuration_id_ := keys_and_qty_tab_(1).configuration_id;
      activity_seq_     := keys_and_qty_tab_(1).activity_seq;
      handling_unit_id_ := keys_and_qty_tab_(1).handling_unit_id;
      transaction_id_   := keys_and_qty_tab_(1).transaction_id;
   ELSE
      quantity_         := 0;
      catch_quantity_   := 0;
      location_no_      := NULL;
      lot_batch_no_     := NULL;
      serial_no_        := NULL;
      eng_chg_level_    := NULL;
      waiv_dev_rej_no_  := NULL;
      configuration_id_ := NULL;
      activity_seq_     := NULL;
      handling_unit_id_ := NULL;
   END IF;
END Find_And_Issue_Part;


-- Find_And_Issue_Part
--   Find a location with a quantity available and issue parts.
--   Find a location with a quantity available and issue parts.
--   Generic Find and Issue method. It also returns the Transaction ID.
--   Find a location with a keys and quantity available and issue parts.
PROCEDURE Find_And_Issue_Part (
   keys_and_qty_tab_             OUT Keys_And_Qty_Tab,
   location_no_                  IN  VARCHAR2,
   lot_batch_no_                 IN  VARCHAR2,
   serial_no_                    IN  VARCHAR2,
   eng_chg_level_                IN  VARCHAR2,
   waiv_dev_rej_no_              IN  VARCHAR2,
   configuration_id_             IN  VARCHAR2,
   activity_seq_                 IN  NUMBER,
   handling_unit_id_             IN  NUMBER, 
   contract_                     IN  VARCHAR2,
   part_no_                      IN  VARCHAR2,
   location_type_db_             IN  VARCHAR2,
   qty_to_issue_                 IN  NUMBER,
   transaction_code_             IN  VARCHAR2,
   source_ref1_                  IN  VARCHAR2,
   source_ref2_                  IN  VARCHAR2,
   source_ref3_                  IN  VARCHAR2,
   source_ref4_                  IN  NUMBER,
   source_ref_type_              IN  VARCHAR2,
   source_                       IN  VARCHAR2,
   project_id_                   IN  VARCHAR2,
   condition_code_               IN  VARCHAR2,
   part_ownership_db_            IN  VARCHAR2,
   owning_vendor_no_             IN  VARCHAR2,
   owning_customer_no_           IN  VARCHAR2,
   only_one_lot_allowed_         IN  BOOLEAN,
   many_records_allowed_         IN  BOOLEAN,
   include_temp_table_locs_      IN  BOOLEAN  DEFAULT TRUE,
   warehouse_id_                 IN  VARCHAR2 DEFAULT NULL,
   ignore_this_avail_control_id_ IN  VARCHAR2 DEFAULT NULL )
IS
BEGIN
   Find_And_Reserve_Or_Issue___(keys_and_qty_tab_             => keys_and_qty_tab_,                     
                                action_                       => issue_,                               
                                location_no_                  => location_no_,                          
                                lot_batch_no_                 => lot_batch_no_,                         
                                serial_no_                    => serial_no_,                            
                                eng_chg_level_                => eng_chg_level_,                        
                                waiv_dev_rej_no_              => waiv_dev_rej_no_,                      
                                configuration_id_             => configuration_id_,                     
                                activity_seq_                 => activity_seq_,                         
                                handling_unit_id_             => handling_unit_id_,                     
                                contract_                     => contract_,                             
                                part_no_                      => part_no_,                              
                                location_type_db_             => location_type_db_,                               
                                qty_to_reserve_or_issue_      => NVL(qty_to_issue_,0),                             
                                project_id_                   => project_id_,                               
                                condition_code_               => condition_code_,                           
                                part_ownership_db_            => part_ownership_db_,                        
                                owning_vendor_no_             => owning_vendor_no_,                         
                                owning_customer_no_           => owning_customer_no_,                       
                                only_one_lot_allowed_         => only_one_lot_allowed_,                     
                                many_records_allowed_         => many_records_allowed_,          
                                expiration_control_date_      => NULL,       
                                warehouse_id_                 => warehouse_id_,                  
                                ignore_this_avail_control_id_ => ignore_this_avail_control_id_,  
                                include_temp_table_locs_      => include_temp_table_locs_,
                                transaction_code_             => transaction_code_,   
                                source_ref1_                  => source_ref1_,
                                source_ref2_                  => source_ref2_,
                                source_ref3_                  => source_ref3_,
                                source_ref4_                  => source_ref4_,
                                source_ref_type_              => source_ref_type_,
                                source_                       => source_);
END Find_And_Issue_Part;


-- Find_And_Issue_Part_Neg
--   Find a location with a reserved quantity equal to zero and makes an issue
--   of the specified quantity.This can make the quantity on hand negative.
--   Returns the issued quantity if an location could be found else it returns
--   zero. It also returns the Transaction ID.
--   Find a location with a reserved quantity equal to zero and makes an issue
--   of the specified quantity.This can make the quantity on hand negative.
--   Returns the issued quantity if an location could be found else it returns zero.
--   It also returns the Transaction ID.
PROCEDURE Find_And_Issue_Part_Neg (
   quantity_                        OUT NUMBER,
   waiv_dev_rej_no_                 OUT VARCHAR2,
   handling_unit_id_                OUT NUMBER,
   location_no_                  IN OUT VARCHAR2,
   lot_batch_no_                 IN OUT VARCHAR2,
   serial_no_                    IN OUT VARCHAR2,
   eng_chg_level_                IN OUT VARCHAR2,
   configuration_id_             IN OUT VARCHAR2,
   activity_seq_                 IN OUT NUMBER,
   contract_                     IN     VARCHAR2,
   part_no_                      IN     VARCHAR2,
   location_type_                IN     VARCHAR2,
   issue_quantity_               IN     NUMBER,
   transaction_                  IN     VARCHAR2,
   order_no_                     IN     VARCHAR2,
   line_no_                      IN     VARCHAR2,
   release_no_                   IN     VARCHAR2,
   line_item_no_                 IN     NUMBER,
   source_                       IN     VARCHAR2,
   project_id_                   IN     VARCHAR2,
   condition_code_               IN     VARCHAR2 DEFAULT NULL,
   part_ownership_               IN     VARCHAR2 DEFAULT 'COMPANY OWNED',
   owning_vendor_no_             IN     VARCHAR2 DEFAULT NULL,
   owning_customer_no_           IN     VARCHAR2 DEFAULT NULL,
   ignore_this_avail_control_id_ IN     VARCHAR2 DEFAULT NULL)
IS
   dummy_number_ NUMBER;
BEGIN
   Find_And_Issue_Part_Neg(quantity_                     => quantity_,
                           transaction_id_               => dummy_number_,
                           waiv_dev_rej_no_              => waiv_dev_rej_no_,
                           handling_unit_id_             => handling_unit_id_,
                           location_no_                  => location_no_,
                           lot_batch_no_                 => lot_batch_no_,
                           serial_no_                    => serial_no_,
                           eng_chg_level_                => eng_chg_level_,
                           configuration_id_             => configuration_id_,
                           activity_seq_                 => activity_seq_,
                           contract_                     => contract_,
                           part_no_                      => part_no_,
                           location_type_                => location_type_,
                           issue_quantity_               => issue_quantity_,
                           transaction_                  => transaction_,
                           order_no_                     => order_no_,
                           line_no_                      => line_no_,
                           release_no_                   => release_no_,
                           line_item_no_                 => line_item_no_,
                           source_                       => source_,
                           project_id_                   => project_id_,
                           condition_code_               => condition_code_,
                           part_ownership_               => part_ownership_,
                           owning_vendor_no_             => owning_vendor_no_,
                           owning_customer_no_           => owning_customer_no_,
                           include_temp_table_locs_      => TRUE,
                           ignore_this_avail_control_id_ => ignore_this_avail_control_id_);
END Find_And_Issue_Part_Neg;


-- Find_And_Issue_Part_Neg
--   Find a location with a reserved quantity equal to zero and makes an issue
--   of the specified quantity.This can make the quantity on hand negative.
--   Returns the issued quantity if an location could be found else it returns
--   zero. It also returns the Transaction ID.
--   Find a location with a reserved quantity equal to zero and makes an issue
--   of the specified quantity.This can make the quantity on hand negative.
--   Returns the issued quantity if an location could be found else it returns zero.
--   It also returns the Transaction ID.
PROCEDURE Find_And_Issue_Part_Neg (
   quantity_                        OUT NUMBER,
   transaction_id_                  OUT NUMBER,
   waiv_dev_rej_no_                 OUT VARCHAR2,
   handling_unit_id_                OUT NUMBER,
   location_no_                  IN OUT VARCHAR2,
   lot_batch_no_                 IN OUT VARCHAR2,
   serial_no_                    IN OUT VARCHAR2,
   eng_chg_level_                IN OUT VARCHAR2,
   configuration_id_             IN OUT VARCHAR2,
   activity_seq_                 IN OUT NUMBER,
   contract_                     IN     VARCHAR2,
   part_no_                      IN     VARCHAR2,
   location_type_                IN     VARCHAR2,
   issue_quantity_               IN     NUMBER,
   transaction_                  IN     VARCHAR2,
   order_no_                     IN     VARCHAR2,
   line_no_                      IN     VARCHAR2,
   release_no_                   IN     VARCHAR2,
   line_item_no_                 IN     NUMBER,
   source_                       IN     VARCHAR2,
   project_id_                   IN     VARCHAR2,
   condition_code_               IN     VARCHAR2 DEFAULT NULL,
   part_ownership_               IN     VARCHAR2 DEFAULT 'COMPANY OWNED',
   owning_vendor_no_             IN     VARCHAR2 DEFAULT NULL,
   owning_customer_no_           IN     VARCHAR2 DEFAULT NULL,
   include_temp_table_locs_      IN     BOOLEAN  DEFAULT TRUE,
   ignore_this_avail_control_id_ IN     VARCHAR2 DEFAULT NULL )
IS
   location_type_db_            INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   i_location_no_               INVENTORY_PART_IN_STOCK_TAB.location_no%TYPE;
   i_lot_batch_no_              INVENTORY_PART_IN_STOCK_TAB.lot_batch_no%TYPE;
   i_serial_no_                 INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE;
   i_eng_chg_level_             INVENTORY_PART_IN_STOCK_TAB.eng_chg_level%TYPE;
   i_waiv_dev_rej_no_           INVENTORY_PART_IN_STOCK_TAB.waiv_dev_rej_no%TYPE;
   i_configuration_id_          INVENTORY_PART_IN_STOCK_TAB.configuration_id%TYPE;
   i_activity_seq_              INVENTORY_PART_IN_STOCK_TAB.activity_seq%TYPE;
   i_handling_unit_id_          INVENTORY_PART_IN_STOCK_TAB.handling_unit_id%TYPE;
   i_issued_qty_                NUMBER;
   serial_tracking_             VARCHAR2(30);
   lot_tracking_                VARCHAR2(30);
   part_catalog_rec_            Part_Catalog_API.Public_Rec;
   trans_value_                 NUMBER;
   accounting_id_               NUMBER;
   today_                       DATE := Trunc(Site_API.Get_Site_Date(contract_));
   char_null_                   VARCHAR2(12) := 'VARCHAR2NULL';
   catch_quantity_              NUMBER := NULL;
   include_tmp_locations_       VARCHAR2(5) := db_false_;
   exclude_tmp_locations_       VARCHAR2(5) := db_false_;
   empty_cost_detail_tab_       Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;   
   record_                      INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   location_found_              BOOLEAN := FALSE;
   local_eng_chg_level_         INVENTORY_PART_IN_STOCK_TAB.eng_chg_level%TYPE;
   default_location_no_         INVENTORY_PART_IN_STOCK_TAB.location_no%TYPE;
   last_calendar_date_          DATE         := Database_Sys.last_calendar_date_;
   dummy_                       NUMBER;
   -- gelr:access_ctrl_for_inv_reserv, start
   include_tmp_warehouses_        VARCHAR2(5) := db_false_;
   
   CURSOR get_warehouse_tmp IS
      SELECT 1
      FROM warehouse_id_tmp;
   -- gelr:access_ctrl_for_inv_reserv, end
   
   CURSOR get_location_tmp IS
      SELECT 1
      FROM inventory_location_tmp;

   CURSOR get_location IS
      SELECT location_no,
             lot_batch_no,
             serial_no,
             eng_chg_level,
             waiv_dev_rej_no,
             configuration_id,
             activity_seq,
             handling_unit_id
      FROM INVENTORY_PART_IN_STOCK_TOTAL
      WHERE  ((part_order_issue_control_db   = 'ORDER ISSUE') OR
              (availability_control_id       = ignore_this_avail_control_id_))
         AND NVL(condition_code, char_null_) = NVL(condition_code_, char_null_)
         AND ((part_ownership_db  = Part_Ownership_API.DB_COMPANY_OWNED        AND part_ownership_ = Part_Ownership_API.DB_COMPANY_OWNED)
          OR  (part_ownership_db  = Part_Ownership_API.DB_CONSIGNMENT          AND part_ownership_ = Part_Ownership_API.DB_COMPANY_OWNED)
          OR  (part_ownership_db  = Part_Ownership_API.DB_CONSIGNMENT          AND part_ownership_ = Part_Ownership_API.DB_CONSIGNMENT     AND
               owning_vendor_no   = NVL(owning_vendor_no_,char_null_))
          OR  (part_ownership_db  = Part_Ownership_API.DB_SUPPLIER_LOANED      AND part_ownership_ = Part_Ownership_API.DB_SUPPLIER_LOANED AND
               owning_vendor_no   = NVL(owning_vendor_no_,char_null_))
          OR  (part_ownership_db  = Part_Ownership_API.DB_CUSTOMER_OWNED       AND part_ownership_ = Part_Ownership_API.DB_CUSTOMER_OWNED  AND
               owning_customer_no = NVL(owning_customer_no_,char_null_))
          OR  (part_ownership_db  = Part_Ownership_API.DB_SUPPLIER_RENTED      AND part_ownership_ = Part_Ownership_API.DB_SUPPLIER_RENTED AND
               owning_vendor_no   = NVL(owning_vendor_no_,char_null_))
          OR  (part_ownership_db  = Part_Ownership_API.DB_COMPANY_RENTAL_ASSET AND part_ownership_ = Part_Ownership_API.DB_COMPANY_RENTAL_ASSET))
         AND qty_reserved     = 0
         AND handling_unit_id = 0
         AND NVL(expiration_date, last_calendar_date_) > today_
         AND location_type_db IN (Inventory_Location_Type_API.DB_PICKING,
                                  Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                  Inventory_Location_Type_API.DB_PRODUCTION_LINE)
         AND (location_type_db = location_type_db_ OR location_type_db_ IS NULL)
         AND (eng_chg_level    = local_eng_chg_level_ )
         AND (serial_no        = serial_no_        OR serial_no_        IS NULL)
         AND   ((serial_no     = '*' AND serial_tracking_ = db_not_serial_tracking_)
         OR    (serial_no     != '*' AND serial_tracking_ = db_serial_tracking_))
         AND (lot_batch_no     = lot_batch_no_     OR lot_batch_no_     IS NULL)
         AND   ((lot_batch_no  = '*' AND lot_tracking_ = 'NOT LOT TRACKING')
         OR    (lot_batch_no  != '*' AND lot_tracking_ IN ('LOT TRACKING','ORDER BASED')))
         AND ((location_no     IN (SELECT tmp.location_no FROM inventory_location_tmp tmp)) OR (include_tmp_locations_ = db_false_))
         AND ((location_no NOT IN (SELECT tmp.location_no FROM inventory_location_tmp tmp)) OR (exclude_tmp_locations_ = db_false_))
         AND ((warehouse       IN (SELECT tmp2.warehouse_id FROM warehouse_id_tmp tmp2)) OR (include_tmp_warehouses_ = db_false_))
         AND (location_no      = location_no_      OR location_no_      IS NULL)
         AND (configuration_id = configuration_id_ OR configuration_id_ IS NULL)
         AND (activity_seq     = activity_seq_     OR activity_seq_     IS NULL)
         AND (NVL(project_id, char_null_) = NVL(project_id_, char_null_) OR activity_seq_ IS NOT NULL)
         AND contract = contract_
         AND part_no = part_no_
      ORDER BY expiration_date, receipt_date;
BEGIN
   part_catalog_rec_    := Part_Catalog_API.Get(part_no_);
   serial_tracking_     := part_catalog_rec_.serial_tracking_code;
   lot_tracking_        := part_catalog_rec_.lot_tracking_code;
   local_eng_chg_level_ := NVL(eng_chg_level_, Inventory_Part_Revision_API.Get_Latest_Eng_Chg_Level(contract_, part_no_));
   location_type_db_    := Inventory_Location_Type_API.Encode(location_type_);
   
   -- gelr:access_ctrl_for_inv_reserv, start
   User_Warehouse_Access_API.Find_User_Access_Warehouses(contract_, issue_);
   -- gelr:access_ctrl_for_inv_reserv, end

   IF NOT (Check_Part_Revision_Exist___(contract_, part_no_, local_eng_chg_level_))THEN
      default_location_no_ := Inventory_Part_Def_Loc_API.Get_Location_No(contract_, part_no_, location_type_db_);
      IF (default_location_no_ IS NOT NULL) THEN
         IF ((part_catalog_rec_.serial_tracking_code   = db_not_serial_tracking_) AND 
             (part_catalog_rec_.lot_tracking_code      = 'NOT LOT TRACKING') AND 
             (part_catalog_rec_.configurable           = 'NOT CONFIGURED')) THEN
            Create_Empty_Stock_Record(contract_, part_no_, default_location_no_);
         END IF;
      END IF;
   END IF;
   
   -- gelr:access_ctrl_for_inv_reserv, start
   OPEN get_warehouse_tmp;
   FETCH get_warehouse_tmp INTO dummy_;
      IF get_warehouse_tmp%FOUND THEN
         include_tmp_warehouses_ := db_true_;
      END IF;
   CLOSE get_warehouse_tmp;
   -- gelr:access_ctrl_for_inv_reserv, end
   
   OPEN get_location_tmp;
   FETCH get_location_tmp INTO dummy_;
      IF get_location_tmp%FOUND THEN
         IF (include_temp_table_locs_) THEN
            include_tmp_locations_ := db_true_;
         ELSE
            exclude_tmp_locations_ := db_true_;
         END IF;
      END IF;
   CLOSE get_location_tmp;

   LOOP
      OPEN get_location;
      FETCH get_location INTO i_location_no_,
                              i_lot_batch_no_,
                              i_serial_no_,
                              i_eng_chg_level_,
                              i_waiv_dev_rej_no_,
                              i_configuration_id_,
                              i_activity_seq_,
                              i_handling_unit_id_;

      IF (get_location%NOTFOUND) THEN
         CLOSE get_location;
         location_found_ := FALSE;
         EXIT;
      END IF;
      CLOSE get_location;
      location_found_ := TRUE;

      record_ := Lock_By_Keys___(contract_,
                                 part_no_,
                                 i_configuration_id_,
                                 i_location_no_,
                                 i_lot_batch_no_,
                                 i_serial_no_,
                                 i_eng_chg_level_,
                                 i_waiv_dev_rej_no_,
                                 i_activity_seq_,
                                 i_handling_unit_id_);

      EXIT WHEN record_.qty_reserved = 0;

   END LOOP;

   IF (location_found_) THEN
      i_issued_qty_ := issue_quantity_;
      
      Issue_Part_Impl___(transaction_id_               =>  transaction_id_,
                         accounting_id_                =>  accounting_id_,
                         trans_value_                  =>  trans_value_,
                         catch_quantity_               =>  catch_quantity_,
                         contract_                     =>  contract_,
                         part_no_                      =>  part_no_,
                         configuration_id_             =>  i_configuration_id_,
                         location_no_                  =>  i_location_no_,
                         lot_batch_no_                 =>  i_lot_batch_no_,
                         serial_no_                    =>  i_serial_no_,
                         eng_chg_level_                =>  i_eng_chg_level_,
                         waiv_dev_rej_no_              =>  i_waiv_dev_rej_no_,
                         activity_seq_                 =>  i_activity_seq_,
                         handling_unit_id_             =>  i_handling_unit_id_,
                         transaction_                  =>  transaction_,
                         quantity_                     =>  i_issued_qty_,
                         quantity_reserved_            =>  0,
                         source_ref1_                  =>  order_no_,
                         source_ref2_                  =>  line_no_,
                         source_ref3_                  =>  release_no_,
                         source_ref4_                  =>  line_item_no_,
                         source_ref5_                  =>  NULL,
                         source_                       =>  source_,
                         unreceive_                    =>  FALSE,
                         forced_                       =>  TRUE,
                         cost_detail_tab_              =>  empty_cost_detail_tab_,
                         source_ref_type_              =>  NULL,
                         reject_code_                  =>  NULL,
                         remove_unit_cost_             =>  TRUE,
                         make_transaction_             =>  TRUE,
                         transit_location_group_       =>  NULL,
                         report_earned_value_db_       =>  NULL,
                         part_catalog_rec_             =>  part_catalog_rec_,
                         original_transaction_id_      =>  NULL,
                         prevent_fifo_action_          =>  FALSE,
                         ownership_transfer_reason_id_ =>  NULL);

       Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                             Site_API.Get_Company(contract_),
                                                             'N',
                                                             NULL);
      $IF Component_Purch_SYS.INSTALLED $THEN
         Receive_Purchase_Order_API.Create_Consignment_Transaction(transaction_id_);         
      $END
   ELSE
      i_issued_qty_ := 0;
   END IF;

   quantity_         := i_issued_qty_;
   location_no_      := i_location_no_;
   lot_batch_no_     := i_lot_batch_no_;
   serial_no_        := i_serial_no_;
   eng_chg_level_    := i_eng_chg_level_;
   waiv_dev_rej_no_  := i_waiv_dev_rej_no_;
   configuration_id_ := i_configuration_id_;
   activity_seq_     := i_activity_seq_;
   handling_unit_id_ := i_handling_unit_id_;

   -- gelr:access_ctrl_for_inv_reserv, start
   Clear_Warehouse_Id_Tmp___;
   -- gelr:access_ctrl_for_inv_reserv, end
END Find_And_Issue_Part_Neg;


-- Unissue_Part
--   Generic unissue method. Will be removed in 10.6
--   Generic unissue method.
PROCEDURE Unissue_Part (
   transaction_id_               OUT NUMBER,
   contract_                     IN  VARCHAR2,
   part_no_                      IN  VARCHAR2,
   configuration_id_             IN  VARCHAR2,
   location_no_                  IN  VARCHAR2,
   lot_batch_no_                 IN  VARCHAR2,
   serial_no_                    IN  VARCHAR2,
   eng_chg_level_                IN  VARCHAR2,
   waiv_dev_rej_no_              IN  VARCHAR2,
   activity_seq_                 IN  NUMBER,
   handling_unit_id_             IN  NUMBER,
   transaction_                  IN  VARCHAR2,
   expiration_date_              IN  DATE,
   accounting_id_issue_          IN  NUMBER,
   quantity_issued_              IN  NUMBER,
   quantity_                     IN  NUMBER,
   catch_quantity_               IN  NUMBER,
   order_no_                     IN  VARCHAR2,
   line_no_                      IN  VARCHAR2,
   release_no_                   IN  VARCHAR2,
   line_item_no_                 IN  NUMBER,
   source_                       IN  VARCHAR2,
   order_type_                   IN  VARCHAR2,
   transaction_id_issue_         IN  NUMBER,
   cost_detail_tab_              IN  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   validate_hu_struct_position_  IN  BOOLEAN DEFAULT TRUE )
IS
   new_transaction_id_    NUMBER;
   accounting_id_         NUMBER;
   trans_value_           NUMBER;
   transaction_id_iss_    NUMBER;
   location_type_db_      INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   transaction_code_      VARCHAR2(10);
   inv_trans_hist_rec_    Inventory_Transaction_Hist_API.Public_Rec;
BEGIN

   transaction_code_ := transaction_;

   IF transaction_id_issue_ IS NULL THEN
      transaction_id_iss_ := Inventory_Transaction_Hist_API.Get_Transaction_Id_For_Accting(accounting_id_issue_);
   ELSE
      transaction_id_iss_ := transaction_id_issue_;
   END IF;

   location_type_db_ := Inventory_Location_API.Get_Location_Type_Db(contract_,location_no_);

   IF location_type_db_ NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                Inventory_Location_Type_API.DB_PRODUCTION_LINE,
                                Inventory_Location_Type_API.DB_ARRIVAL,
                                Inventory_Location_Type_API.DB_QUALITY_ASSURANCE) THEN
      Raise_Invalid_Loc_Type_Error___(part_no_, location_type_db_);
   END IF;

   inv_trans_hist_rec_ := Inventory_Transaction_Hist_API.Get( transaction_id_iss_ );
   
   Receive_Part_Impl___(transaction_id_               => new_transaction_id_,
                        accounting_id_                => accounting_id_,
                        trans_value_                  => trans_value_,
                        contract_                     => contract_,
                        part_no_                      => part_no_,
                        configuration_id_             => configuration_id_,
                        location_no_                  => location_no_,
                        lot_batch_no_                 => lot_batch_no_,
                        serial_no_                    => serial_no_,
                        eng_chg_level_                => eng_chg_level_,
                        waiv_dev_rej_no_              => waiv_dev_rej_no_,
                        activity_seq_                 => activity_seq_,
                        handling_unit_id_             => handling_unit_id_,
                        transaction_                  => transaction_code_,
                        expiration_date_              => expiration_date_,
                        quantity_                     => quantity_,
                        quantity_reserved_            => 0,
                        catch_quantity_               => catch_quantity_,
                        source_ref1_                  => order_no_,
                        source_ref2_                  => line_no_,
                        source_ref3_                  => release_no_,
                        source_ref4_                  => line_item_no_,
                        source_ref5_                  => NULL,
                        source_                       => source_,
                        unissue_                      => TRUE,
                        unit_cost_                    => NULL,
                        source_ref_type_              => order_type_,
                        vendor_no_                    => inv_trans_hist_rec_.owning_vendor_no,
                        receipt_date_                 => NULL,
                        condition_code_               => NULL,
                        part_ownership_               => inv_trans_hist_rec_.part_ownership,
                        owning_customer_no_           => inv_trans_hist_rec_.owning_customer_no,
                        cost_detail_tab_              => cost_detail_tab_,
                        set_qty_reversed_             => TRUE,
                        issue_transaction_id_         => transaction_id_iss_ ,
                        operational_condition_db_     => NULL,
                        part_catalog_rec_             => NULL,
                        availability_control_id_      => NULL,
                        validate_hu_struct_position_  => validate_hu_struct_position_,
                        ownership_transfer_reason_id_ =>  NULL);

   IF (transaction_id_issue_ IS NOT NULL) THEN
      Inventory_Transaction_Hist_API.Set_Original_Transaction_Id (new_transaction_id_,
                                                                  transaction_id_issue_);
   END IF;

   Inventory_Transaction_Hist_API.Reverse_Accounting(new_transaction_id_,
                                                     transaction_id_issue_);

   Inventory_Transaction_Hist_Api.Modify_Qty_Reversed(transaction_id_iss_,
      Inventory_Transaction_Hist_Api.Get_Qty_Reversed(transaction_id_iss_) + quantity_);

   Undo_Consignment_Consum___( transaction_id_issue_, new_transaction_id_, source_ );

   transaction_id_ := new_transaction_id_;
END Unissue_Part;


-- Unissue_Part
--   Generic unissue method. Will be removed in 10.6
--   Generic unissue method.
PROCEDURE Unissue_Part (
   transaction_id_               OUT NUMBER,
   unissue_transaction_          IN  VARCHAR2,
   pos_diff_transaction_         IN  VARCHAR2,
   neg_diff_transaction_         IN  VARCHAR2,
   quantity_                     IN  NUMBER,
   catch_quantity_               IN  NUMBER,
   transaction_id_issue_         IN  NUMBER,
   source_                       IN  VARCHAR2,
   validate_hu_struct_position_  IN  BOOLEAN DEFAULT TRUE )
IS
   transaction_id_tmp_           NUMBER;
   inv_trans_hist_rec_           Inventory_Transaction_Hist_API.Public_Rec;
   dummy_number_                 NUMBER;
   dummy_date_                   DATE;
   dummy_string_                 VARCHAR2(100);
   return_cor_transaction_id_    NUMBER := 0;   
   undo_move_to_order_transit_   BOOLEAN := FALSE;   
   return_transaction_rec_       Inventory_Transaction_Hist_API.Public_Rec;
BEGIN
   Undo_Move_To_Order_Transit___(undo_move_to_order_transit_,
                                 return_cor_transaction_id_,
                                 return_transaction_rec_,                                 
                                 unissue_transaction_,
                                 catch_quantity_,   
                                 quantity_,
                                 transaction_id_issue_);
   
   Inventory_Transaction_Hist_API.Reverse_Transaction(transaction_id_              => transaction_id_tmp_,
                                                      transaction_                 => unissue_transaction_,
                                                      pos_diff_transaction_        => pos_diff_transaction_,
                                                      neg_diff_transaction_        => neg_diff_transaction_,
                                                      quantity_                    => quantity_,
                                                      catch_quantity_              => catch_quantity_,
                                                      old_transaction_id_          => transaction_id_issue_,
                                                      source_                      => source_,
                                                      validate_hu_struct_position_ => validate_hu_struct_position_); 

   Inventory_Transaction_Hist_API.Set_Original_Transaction_Id(transaction_id_tmp_,
                                                              transaction_id_issue_);
   
   IF undo_move_to_order_transit_ THEN
      -- Create connections between:
      --    UNSHIPTRAN and UNINTORDTR
      --    COUNSHPTRN and UNINTORDTR      
      --    UNSHIPDIR and UNINTORDTR
      --    COUNSHPDIR and UNINTORDTR
      --    UNINPODRIM and UNINTORDTR
      --    UNPODRINEM and UNINTORDTR
      --    UND-SHPODS and UNINTORDTR
      IF (unissue_transaction_ IN ('UNSHIPTRAN', 'COUNSHPTRN', 'UNSHIPDIR', 'COUNSHPDIR', 'UNINPODRIM', 'UNPODRINEM', 'UND-SHPODS')) THEN         
         Invent_Trans_Interconnect_API.Connect_Transactions(transaction_id_tmp_,
                                                            return_cor_transaction_id_,
                                                            Invent_Trans_Conn_Reason_API.DB_INTERSITE_TRANSFER);
      END IF;
      
      Revalue_Int_Order_Transit___(transaction_id_tmp_,
                                   unissue_transaction_,
                                   return_cor_transaction_id_,
                                   return_transaction_rec_);
      
      -- Reverse Intersite Profitability related transactions
      $IF (Component_Order_SYS.INSTALLED) $THEN
         Intersite_Profit_Manager_API.Reverse_Intersite_Transactions(transaction_id_issue_, transaction_id_tmp_, quantity_, catch_quantity_);
      $ELSE
         Error_SYS.Component_Not_Exist('ORDER');
      $END
   END IF;
   Undo_Consignment_Consum___(transaction_id_issue_, transaction_id_tmp_, source_);

   transaction_id_ := transaction_id_tmp_;

   IF unissue_transaction_ = 'UNCODELVOU' THEN
      $IF (Component_Order_SYS.INSTALLED) $THEN
      inv_trans_hist_rec_ := Inventory_Transaction_Hist_API.Get(transaction_id_tmp_);
      
      Customer_Consignment_Stock_API.Decrease_Consignment_Stock_Qty(contract_         => inv_trans_hist_rec_.contract,
                                                                    part_no_          => inv_trans_hist_rec_.part_no,
                                                                    configuration_id_ => inv_trans_hist_rec_.configuration_id,
                                                                    lot_batch_no_     => inv_trans_hist_rec_.lot_batch_no,
                                                                    serial_no_        => inv_trans_hist_rec_.serial_no,
                                                                    eng_chg_level_    => inv_trans_hist_rec_.eng_chg_level,
                                                                    waiv_dev_rej_no_  => inv_trans_hist_rec_.waiv_dev_rej_no,
                                                                    activity_seq_     => inv_trans_hist_rec_.activity_seq,
                                                                    handling_unit_id_ => inv_trans_hist_rec_.handling_unit_id,
                                                                    expiration_date_  => inv_trans_hist_rec_.expiration_date,
                                                                    transaction_code_ => 'UNCODELVOU',
                                                                    project_id_       => inv_trans_hist_rec_.project_id,
                                                                    order_no_         => inv_trans_hist_rec_.source_ref1,
                                                                    release_no_       => inv_trans_hist_rec_.source_ref2,
                                                                    sequence_no_      => inv_trans_hist_rec_.source_ref3,
                                                                    line_item_no_     => inv_trans_hist_rec_.source_ref4,
                                                                    deliv_no_         => inv_trans_hist_rec_.source_ref5,
                                                                    quantity_         => inv_trans_hist_rec_.quantity,
                                                                    catch_quantity_   => inv_trans_hist_rec_.catch_quantity );
      $ELSE
         NULL;
      $END
   END IF;

   IF unissue_transaction_ = 'UNDELCONOU' THEN
      inv_trans_hist_rec_ := Inventory_Transaction_Hist_API.Get(transaction_id_tmp_);
      
      Inventory_Part_At_Customer_API.Decrease_Our_Qty_At_Customer ( transaction_id_   => transaction_id_tmp_,
                                                                    contract_         => inv_trans_hist_rec_.contract,
                                                                    part_no_          => inv_trans_hist_rec_.part_no,
                                                                    configuration_id_ => dummy_string_,
                                                                    lot_batch_no_     => dummy_string_,
                                                                    serial_no_        => dummy_string_,
                                                                    eng_chg_level_    => dummy_string_,
                                                                    waiv_dev_rej_no_  => dummy_string_,
                                                                    activity_seq_     => dummy_number_,
                                                                    handling_unit_id_ => dummy_number_,
                                                                    customer_no_      => dummy_string_,
                                                                    addr_no_          => dummy_string_,
                                                                    expiration_date_  => dummy_date_,
                                                                    process_type_db_  => Stock_At_Cust_Process_Type_API.DB_DELIVERY_CONFIRMATION,
                                                                    transaction_code_ => 'UNDELCONOU',
                                                                    project_id_       => inv_trans_hist_rec_.project_id,
                                                                    source_ref1_      => inv_trans_hist_rec_.source_ref1,
                                                                    source_ref2_      => inv_trans_hist_rec_.source_ref2,
                                                                    source_ref3_      => inv_trans_hist_rec_.source_ref3,
                                                                    source_ref4_      => inv_trans_hist_rec_.source_ref4,
                                                                    source_ref5_      => inv_trans_hist_rec_.source_ref5,
                                                                    quantity_         => inv_trans_hist_rec_.quantity,
                                                                    catch_quantity_   => inv_trans_hist_rec_.catch_quantity,
                                                                    scrap_cause_      => NULL,
                                                                    scrap_note_       => NULL);  
   END IF;

END Unissue_Part;


-- Issue_Part_With_Posting
--   Issues a part with posting information.
--   Issues a part with posting information.
PROCEDURE Issue_Part_With_Posting (
   contract_                     IN VARCHAR2,
   part_no_                      IN VARCHAR2,
   configuration_id_             IN VARCHAR2,
   location_no_                  IN VARCHAR2,
   lot_batch_no_                 IN VARCHAR2,
   serial_no_                    IN VARCHAR2,
   eng_chg_level_                IN VARCHAR2,
   waiv_dev_rej_no_              IN VARCHAR2,
   activity_seq_                 IN NUMBER,
   handling_unit_id_             IN NUMBER,
   transaction_                  IN VARCHAR2,
   quantity_                     IN NUMBER,
   catch_quantity_               IN NUMBER,
   account_no_                   IN VARCHAR2,
   code_b_                       IN VARCHAR2,
   code_c_                       IN VARCHAR2,
   code_d_                       IN VARCHAR2,
   code_e_                       IN VARCHAR2,
   code_f_                       IN VARCHAR2,
   code_g_                       IN VARCHAR2,
   code_h_                       IN VARCHAR2,
   code_i_                       IN VARCHAR2,
   code_j_                       IN VARCHAR2,
   source_                       IN VARCHAR2,
   part_tracking_session_id_     IN NUMBER,
   discon_zero_stock_handl_unit_ IN BOOLEAN DEFAULT TRUE,
   delivery_reason_id_           IN VARCHAR2 DEFAULT NULL)
IS
   serial_catch_tab_          Serial_Catch_Table;
   accumulated_catch_qty_     NUMBER := 0;
   local_quantity_            NUMBER;
BEGIN
   Inventory_Event_Manager_API.Start_Session;

   IF (part_tracking_session_id_ IS NULL) THEN
      serial_catch_tab_(1).serial_no := serial_no_;
      serial_catch_tab_(1).catch_qty := catch_quantity_;
      local_quantity_                := quantity_;
   ELSE
      Temporary_Part_Tracking_API.Get_Serials_And_Remove_Session(serial_catch_tab_, part_tracking_session_id_);

      IF (serial_catch_tab_.COUNT = 0) THEN
         Raise_No_Serials_Error___;
      END IF;

      IF (serial_catch_tab_.COUNT != quantity_) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'ISSPOSTSERCOUNT: The quantity to be issued is :P1 but the number of identified serials is :P2', quantity_, serial_catch_tab_.COUNT);
      END IF;

      Split_Into_Serials(contract_           => contract_,
                         part_no_            => part_no_,
                         configuration_id_   => configuration_id_,
                         location_no_        => location_no_,
                         lot_batch_no_       => lot_batch_no_,
                         eng_chg_level_      => eng_chg_level_,
                         waiv_dev_rej_no_    => waiv_dev_rej_no_,
                         activity_seq_       => activity_seq_,
                         handling_unit_id_   => handling_unit_id_,
                         serial_catch_tab_   => serial_catch_tab_,
                         reservation_        => FALSE);
      local_quantity_ := 1;
   END IF;

   FOR i IN serial_catch_tab_.FIRST..serial_catch_tab_.LAST LOOP
      Issue_Part_With_Posting___(contract_           => contract_,
                                 part_no_            => part_no_,
                                 configuration_id_   => configuration_id_,
                                 location_no_        => location_no_,
                                 lot_batch_no_       => lot_batch_no_,
                                 serial_no_          => serial_catch_tab_(i).serial_no,
                                 eng_chg_level_      => eng_chg_level_,
                                 waiv_dev_rej_no_    => waiv_dev_rej_no_,
                                 activity_seq_       => activity_seq_,
                                 handling_unit_id_   => handling_unit_id_,
                                 transaction_        => transaction_,
                                 quantity_           => local_quantity_,
                                 catch_quantity_     => serial_catch_tab_(i).catch_qty,
                                 account_no_         => account_no_,
                                 code_b_             => code_b_,
                                 code_c_             => code_c_,
                                 code_d_             => code_d_,
                                 code_e_             => code_e_,
                                 code_f_             => code_f_,
                                 code_g_             => code_g_,
                                 code_h_             => code_h_,
                                 code_i_             => code_i_,
                                 code_j_             => code_j_,
                                 source_             => source_,
                                 delivery_reason_id_ => delivery_reason_id_);

      accumulated_catch_qty_ := accumulated_catch_qty_ + NVL(serial_catch_tab_(i).catch_qty,0);
   END LOOP;

   IF (accumulated_catch_qty_ != NVL(catch_quantity_,0)) THEN
      Error_SYS.Record_General('InventoryPartInStock', 'ISSPOSTSERCATCH: The total catch quantity to be issued is :P1 but the accumulated catch quantity on the serials is entered as :P2.', catch_quantity_, accumulated_catch_qty_);
   END IF;

   Cleanup_Handl_Unit_Struct___(handling_unit_id_, discon_zero_stock_handl_unit_);
   Inventory_Event_Manager_API.Finish_Session;
END Issue_Part_With_Posting;


-- Receive_Part
--   Generic Receive method.
PROCEDURE Receive_Part (
   transaction_id_              OUT NUMBER,
   contract_                    IN  VARCHAR2,
   part_no_                     IN  VARCHAR2,
   configuration_id_            IN  VARCHAR2,
   location_no_                 IN  VARCHAR2,
   lot_batch_no_                IN  VARCHAR2,
   serial_no_                   IN  VARCHAR2,
   eng_chg_level_               IN  VARCHAR2,
   waiv_dev_rej_no_             IN  VARCHAR2,
   activity_seq_                IN  NUMBER,
   handling_unit_id_            IN  NUMBER,
   transaction_                 IN  VARCHAR2,
   expiration_date_             IN  DATE,
   quantity_                    IN  NUMBER,
   catch_quantity_              IN  NUMBER,
   quantity_reserved_           IN  NUMBER,
   order_no_                    IN  VARCHAR2,
   line_no_                     IN  VARCHAR2,
   release_no_                  IN  VARCHAR2,
   line_item_no_                IN  NUMBER,
   source_                      IN  VARCHAR2,
   value_                       IN  NUMBER,
   cost_detail_tab_             IN  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   order_type_                  IN  VARCHAR2,
   receive_correction_          IN  VARCHAR2 DEFAULT NULL,
   owning_vendor_no_            IN  VARCHAR2 DEFAULT NULL,
   condition_code_              IN  VARCHAR2 DEFAULT NULL,
   part_ownership_              IN  VARCHAR2 DEFAULT 'COMPANY OWNED',
   owning_customer_no_          IN  VARCHAR2 DEFAULT NULL,
   receipt_date_                IN  DATE DEFAULT NULL,
   issue_transaction_id_        IN  NUMBER DEFAULT NULL,
   perform_putaway_db_          IN  VARCHAR2 DEFAULT Fnd_Boolean_API.db_false,
   operational_condition_db_    IN  VARCHAR2 DEFAULT NULL,
   availability_control_id_     IN  VARCHAR2 DEFAULT NULL,
   deliv_no_                    IN  NUMBER   DEFAULT NULL,
   validate_hu_struct_position_ IN  BOOLEAN  DEFAULT TRUE,   
   del_reason_id_               IN  VARCHAR2  DEFAULT NULL,
   del_note_no_                 IN  VARCHAR2  DEFAULT NULL,
   del_note_date_               IN  DATE      DEFAULT NULL )
IS
   info_ VARCHAR2(2000);
BEGIN
   Receive_Part(info_                        => info_,
                transaction_id_              => transaction_id_,
                contract_                    => contract_,
                part_no_                     => part_no_,
                configuration_id_            => configuration_id_,
                location_no_                 => location_no_,
                lot_batch_no_                => lot_batch_no_,
                serial_no_                   => serial_no_,
                eng_chg_level_               => eng_chg_level_,
                waiv_dev_rej_no_             => waiv_dev_rej_no_,
                activity_seq_                => activity_seq_,
                handling_unit_id_            => handling_unit_id_,
                transaction_                 => transaction_,
                expiration_date_             => expiration_date_,
                quantity_                    => quantity_,
                catch_quantity_              => catch_quantity_,
                quantity_reserved_           => quantity_reserved_,
                order_no_                    => order_no_,
                line_no_                     => line_no_,
                release_no_                  => release_no_,
                line_item_no_                => line_item_no_,
                source_                      => source_,
                value_                       => value_,
                cost_detail_tab_             => cost_detail_tab_,
                order_type_                  => order_type_,
                receive_correction_          => receive_correction_,
                owning_vendor_no_            => owning_vendor_no_,
                condition_code_              => condition_code_,
                part_ownership_              => part_ownership_,
                owning_customer_no_          => owning_customer_no_,
                receipt_date_                => receipt_date_,
                issue_transaction_id_        => issue_transaction_id_,
                perform_putaway_db_          => perform_putaway_db_,
                operational_condition_db_    => operational_condition_db_,
                availability_control_id_     => availability_control_id_,
                deliv_no_                    => deliv_no_,
                validate_hu_struct_position_ => validate_hu_struct_position_,
                del_reason_id_               => del_reason_id_,
                del_note_no_                 => del_note_no_,
                del_note_date_               => del_note_date_);

END Receive_Part;


-- Receive_Part
--   Generic Receive method.
PROCEDURE Receive_Part (
   info_                        OUT VARCHAR2,
   transaction_id_              OUT NUMBER,
   contract_                    IN  VARCHAR2,
   part_no_                     IN  VARCHAR2,
   configuration_id_            IN  VARCHAR2,
   location_no_                 IN  VARCHAR2,
   lot_batch_no_                IN  VARCHAR2,
   serial_no_                   IN  VARCHAR2,
   eng_chg_level_               IN  VARCHAR2,
   waiv_dev_rej_no_             IN  VARCHAR2,
   activity_seq_                IN  NUMBER,
   handling_unit_id_            IN  NUMBER,
   transaction_                 IN  VARCHAR2,
   expiration_date_             IN  DATE,
   quantity_                    IN  NUMBER,
   catch_quantity_              IN  NUMBER,
   quantity_reserved_           IN  NUMBER,
   order_no_                    IN  VARCHAR2,
   line_no_                     IN  VARCHAR2,
   release_no_                  IN  VARCHAR2,
   line_item_no_                IN  NUMBER,
   source_                      IN  VARCHAR2,
   value_                       IN  NUMBER,
   cost_detail_tab_             IN  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   order_type_                  IN  VARCHAR2,
   receive_correction_          IN  VARCHAR2 DEFAULT NULL,
   owning_vendor_no_            IN  VARCHAR2 DEFAULT NULL,
   condition_code_              IN  VARCHAR2 DEFAULT NULL,
   part_ownership_              IN  VARCHAR2 DEFAULT 'COMPANY OWNED',
   owning_customer_no_          IN  VARCHAR2 DEFAULT NULL,
   receipt_date_                IN  DATE     DEFAULT NULL,
   issue_transaction_id_        IN  NUMBER   DEFAULT NULL,
   perform_putaway_db_          IN  VARCHAR2 DEFAULT Fnd_Boolean_API.db_false,
   operational_condition_db_    IN  VARCHAR2 DEFAULT NULL,
   availability_control_id_     IN  VARCHAR2 DEFAULT NULL,
   deliv_no_                    IN  NUMBER   DEFAULT NULL,
   validate_hu_struct_position_ IN  BOOLEAN  DEFAULT TRUE,        
   del_reason_id_               IN  VARCHAR2  DEFAULT NULL,
   del_note_no_                 IN  VARCHAR2  DEFAULT NULL,
   del_note_date_               IN  DATE      DEFAULT NULL )
IS
   transaction_id_tmp_  NUMBER;
   accounting_id_       NUMBER;
   trans_value_         NUMBER;
   location_type_db_    INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   receive_corr_        VARCHAR2(10);
   order_type_db_       VARCHAR2(20);
   unissue_             BOOLEAN := FALSE;
   part_catalog_rec_    Part_Catalog_API.Public_Rec;  
   dummy_string_        VARCHAR2(10);
   cost_detail_tab_tmp_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
BEGIN

   receive_corr_        := NVL(receive_correction_,'NO');
   location_type_db_    := Inventory_Location_API.Get_Location_Type_Db(contract_,location_no_);
   order_type_db_       := NVL(Order_Type_API.Encode(order_type_),'DUMMYdummyDUMMYdummy');
   part_catalog_rec_    := Part_Catalog_API.Get(part_no_);
   cost_detail_tab_tmp_ := cost_detail_tab_;

   IF (receive_corr_ = 'NO') THEN
      IF ((location_type_db_ NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                     Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                     Inventory_Location_Type_API.DB_PRODUCTION_LINE) AND order_type_db_ NOT IN (Order_Type_API.DB_PURCHASE_ORDER, Order_Type_API.DB_SHIPMENT_ORDER)) OR
          (order_type_db_ = Order_Type_API.DB_PURCHASE_ORDER AND location_type_db_ NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                                                                           Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                                                                           Inventory_Location_Type_API.DB_PRODUCTION_LINE,
                                                                                           Inventory_Location_Type_API.DB_QUALITY_ASSURANCE,
                                                                                           Inventory_Location_Type_API.DB_ARRIVAL)) OR 
          (order_type_db_ = Order_Type_API.DB_SHIPMENT_ORDER AND location_type_db_ NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                                                                           Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                                                                           Inventory_Location_Type_API.DB_PRODUCTION_LINE,
                                                                                           Inventory_Location_Type_API.DB_ARRIVAL))) THEN
         Raise_Invalid_Loc_Type_Error___(part_no_, location_type_db_);                                                                      
      END IF;
   END IF;

   IF (receive_corr_ = 'YES') THEN
      unissue_ := TRUE;
   END IF;

   Check_Waiv_Dev_Rej_No___(contract_             => contract_,
                            part_no_              => part_no_,
                            configuration_id_     => configuration_id_,
                            location_no_          => location_no_,
                            lot_batch_no_         => lot_batch_no_,
                            serial_no_            => serial_no_,
                            eng_chg_level_        => eng_chg_level_,
                            waiv_dev_rej_no_      => waiv_dev_rej_no_,
                            activity_seq_         => activity_seq_,
                            handling_unit_id_     => handling_unit_id_,
                            check_during_receipt_ => TRUE,
                            part_catalog_rec_     => part_catalog_rec_,
                            location_type_db_     => location_type_db_,
                            part_ownership_db_    => part_ownership_,
                            owning_customer_no_   => owning_customer_no_,
                            owning_vendor_no_     => owning_vendor_no_);
   
   IF (transaction_ = 'CRO-EXR-IN') THEN        
      -- To decrease from the inventory part at customer    
      Inventory_Part_At_Customer_API.Decrease_Our_Qty_At_Customer ( transaction_id_   => transaction_id_tmp_,
                                                                    contract_         => contract_,
                                                                    part_no_          => part_no_,
                                                                    configuration_id_ => configuration_id_,
                                                                    lot_batch_no_     => lot_batch_no_,
                                                                    serial_no_        => serial_no_,
                                                                    eng_chg_level_    => eng_chg_level_,
                                                                    waiv_dev_rej_no_  => waiv_dev_rej_no_,
                                                                    activity_seq_     => activity_seq_,
                                                                    handling_unit_id_ => handling_unit_id_,
                                                                    customer_no_      => dummy_string_,
                                                                    addr_no_          => dummy_string_,
                                                                    expiration_date_  => expiration_date_,
                                                                    process_type_db_  => Stock_At_Cust_Process_Type_API.DB_PART_EXCHANGE,                                                                   
                                                                    transaction_code_ => 'CRO-EXR-OU',
                                                                    project_id_       => dummy_string_,
                                                                    source_ref1_      =>  order_no_,
                                                                    source_ref2_      =>  line_no_,
                                                                    source_ref3_      =>  release_no_,
                                                                    source_ref4_      =>  line_item_no_,
                                                                    source_ref5_      =>  deliv_no_,
                                                                    quantity_         => quantity_,
                                                                    catch_quantity_   => catch_quantity_,
                                                                    scrap_cause_      => NULL,
                                                                    scrap_note_       => NULL);
      
      cost_detail_tab_tmp_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(transaction_id_tmp_);
   END IF; 
   
   Receive_Part_Impl___(transaction_id_               =>  transaction_id_tmp_,
                        accounting_id_                =>  accounting_id_,
                        trans_value_                  =>  trans_value_,
                        contract_                     =>  contract_,
                        part_no_                      =>  part_no_,
                        configuration_id_             =>  configuration_id_,
                        location_no_                  =>  location_no_,
                        lot_batch_no_                 =>  lot_batch_no_,
                        serial_no_                    =>  serial_no_,
                        eng_chg_level_                =>  eng_chg_level_,
                        waiv_dev_rej_no_              =>  waiv_dev_rej_no_,
                        activity_seq_                 =>  activity_seq_,
                        handling_unit_id_             =>  handling_unit_id_,
                        transaction_                  =>  transaction_,
                        expiration_date_              =>  expiration_date_,
                        quantity_                     =>  quantity_,
                        quantity_reserved_            =>  quantity_reserved_,
                        catch_quantity_               =>  catch_quantity_,
                        source_ref1_                  =>  order_no_,
                        source_ref2_                  =>  line_no_,
                        source_ref3_                  =>  release_no_,
                        source_ref4_                  =>  line_item_no_,
                        source_ref5_                  =>  deliv_no_,
                        source_                       =>  source_,
                        unissue_                      =>  unissue_,
                        unit_cost_                    =>  value_,
                        source_ref_type_              =>  order_type_,
                        vendor_no_                    =>  owning_vendor_no_,
                        receipt_date_                 =>  receipt_date_,
                        condition_code_               =>  condition_code_,
                        part_ownership_               =>  part_ownership_,
                        owning_customer_no_           =>  owning_customer_no_,
                        cost_detail_tab_              =>  cost_detail_tab_tmp_,
                        set_qty_reversed_             =>  FALSE,
                        issue_transaction_id_         =>  issue_transaction_id_ ,
                        operational_condition_db_     =>  operational_condition_db_,
                        part_catalog_rec_             =>  part_catalog_rec_,
                        availability_control_id_      =>  availability_control_id_,
                        validate_hu_struct_position_  =>  validate_hu_struct_position_,
                        ownership_transfer_reason_id_ =>  NULL,
                        delivery_reason_id_           => del_reason_id_,
                        del_note_no_                  => del_note_no_,
                        del_note_date_                => del_note_date_ );

   IF receive_corr_ = 'YES' THEN
      NULL; -- Don't make accountings when making a correction,
            -- called from InventoryTransactionHist ReverseTransaction
   ELSE
      Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_tmp_,
                                                            Site_API.Get_Company(contract_),
                                                            'N',
                                                            NULL);
   END IF;
   transaction_id_ := transaction_id_tmp_;

   IF perform_putaway_db_ = Fnd_Boolean_API.db_true THEN
      Inventory_Putaway_Manager_API.Putaway_Part(info_               => info_,
                                                 contract_           => contract_,
                                                 part_no_            => part_no_,
                                                 configuration_id_   => configuration_id_,
                                                 location_no_        => location_no_,
                                                 lot_batch_no_       => lot_batch_no_,
                                                 serial_no_          => serial_no_,
                                                 eng_chg_level_      => eng_chg_level_,
                                                 waiv_dev_rej_no_    => waiv_dev_rej_no_,
                                                 activity_seq_       => activity_seq_,
                                                 handling_unit_id_   => handling_unit_id_,
                                                 quantity_           => quantity_,
                                                 source_ref1_        => order_no_,
                                                 source_ref2_        => line_no_,
                                                 source_ref3_        => release_no_,
                                                 source_ref4_        => line_item_no_,
                                                 source_ref_type_db_ => order_type_db_);
   END IF;
END Receive_Part;


-- Unreceive_Part
--   Generic Unreceive part method. (Calls Issue...) will be removed in 10.6
--   Generic Unreceive part method. (Calls Issue...)
PROCEDURE Unreceive_Part (
   transaction_id_               OUT NUMBER,
   contract_                     IN  VARCHAR2,
   part_no_                      IN  VARCHAR2,
   configuration_id_             IN  VARCHAR2,
   location_no_                  IN  VARCHAR2,
   lot_batch_no_                 IN  VARCHAR2,
   serial_no_                    IN  VARCHAR2,
   eng_chg_level_                IN  VARCHAR2,
   waiv_dev_rej_no_              IN  VARCHAR2,
   activity_seq_                 IN  NUMBER,
   handling_unit_id_             IN  NUMBER,
   org_transaction_id_           IN  NUMBER,
   transaction_                  IN  VARCHAR2,
   quantity_                     IN  NUMBER,
   old_quantity_                 IN  NUMBER,
   catch_quantity_               IN  NUMBER,
   order_no_                     IN  VARCHAR2,
   line_no_                      IN  VARCHAR2,
   release_no_                   IN  VARCHAR2,
   line_item_no_                 IN  NUMBER,
   source_                       IN  VARCHAR2,
   cost_detail_tab_              IN  Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   order_type_                   IN  VARCHAR2,
   remove_unit_cost_             IN  BOOLEAN,
   prevent_fifo_action_          IN  BOOLEAN,
   validate_hu_struct_position_  IN  BOOLEAN DEFAULT TRUE )
IS
   i_transaction_id_   NUMBER;
   accounting_id_      NUMBER;
   trans_value_        NUMBER;
   new_catch_quantity_ NUMBER;
BEGIN

   new_catch_quantity_ := catch_quantity_;

   Issue_Part_Impl___(transaction_id_               => i_transaction_id_,
                      accounting_id_                => accounting_id_,
                      trans_value_                  => trans_value_,
                      catch_quantity_               => new_catch_quantity_,
                      contract_                     => contract_,
                      part_no_                      => part_no_,
                      configuration_id_             => configuration_id_,
                      location_no_                  => location_no_,
                      lot_batch_no_                 => lot_batch_no_,
                      serial_no_                    => serial_no_,
                      eng_chg_level_                => eng_chg_level_,
                      waiv_dev_rej_no_              => waiv_dev_rej_no_,
                      activity_seq_                 => activity_seq_,
                      handling_unit_id_             => handling_unit_id_,
                      transaction_                  => transaction_,
                      quantity_                     => quantity_,
                      quantity_reserved_            => 0,
                      source_ref1_                  => order_no_,
                      source_ref2_                  => line_no_,
                      source_ref3_                  => release_no_,
                      source_ref4_                  => line_item_no_,
                      source_ref5_                  => NULL,
                      source_                       => source_,
                      unreceive_                    => TRUE,
                      forced_                       => FALSE,
                      cost_detail_tab_              => cost_detail_tab_,
                      source_ref_type_              => order_type_,
                      reject_code_                  => NULL,
                      remove_unit_cost_             => remove_unit_cost_,
                      make_transaction_             => TRUE,
                      transit_location_group_       => NULL,
                      report_earned_value_db_       => NULL,
                      part_catalog_rec_             => NULL,
                      original_transaction_id_      => org_transaction_id_,
                      prevent_fifo_action_          => prevent_fifo_action_,
                      ownership_transfer_reason_id_ => NULL,
                      validate_hu_struct_position_  => validate_hu_struct_position_);

   Inventory_Transaction_Hist_API.Set_Original_Transaction_Id(i_transaction_id_,
                                                              org_transaction_id_);

   Inventory_Transaction_Hist_API.Reverse_Accounting(i_transaction_id_,
                                                     org_transaction_id_);

   transaction_id_ := i_transaction_id_;
END Unreceive_Part;


-- Unreceive_Part
--   Generic Unreceive part method. (Calls Issue...) will be removed in 10.6
--   Generic Unreceive part method. (Calls Issue...)
PROCEDURE Unreceive_Part (
   transaction_id_         OUT NUMBER,
   unreceive_transaction_  IN  VARCHAR2,
   pos_diff_transaction_   IN  VARCHAR2,
   neg_diff_transaction_   IN  VARCHAR2,
   quantity_               IN  NUMBER,
   catch_quantity_         IN  NUMBER,
   transaction_id_receive_ IN  NUMBER,
   source_                 IN  VARCHAR2 )
IS
   transaction_id_tmp_ NUMBER;
BEGIN

   Inventory_Transaction_Hist_API.Reverse_Transaction(transaction_id_tmp_,
                                                      unreceive_transaction_,
                                                      pos_diff_transaction_,
                                                      neg_diff_transaction_,
                                                      quantity_,
                                                      catch_quantity_,
                                                      transaction_id_receive_,
                                                      source_);

   Inventory_Transaction_Hist_API.Set_Original_Transaction_Id (transaction_id_tmp_,
                                                               transaction_id_receive_);

   transaction_id_ := transaction_id_tmp_;

END Unreceive_Part;

-- Receive_Part_With_Posting
--   Receives part with posting information.
PROCEDURE Receive_Part_With_Posting (
   contract_                  IN VARCHAR2,
   part_no_                   IN VARCHAR2,
   configuration_id_          IN VARCHAR2,
   location_no_               IN VARCHAR2,
   lot_batch_no_              IN VARCHAR2,
   serial_no_                 IN VARCHAR2,
   eng_chg_level_             IN VARCHAR2,
   waiv_dev_rej_no_           IN VARCHAR2,
   activity_seq_              IN NUMBER,
   handling_unit_id_          IN NUMBER,
   transaction_               IN VARCHAR2,
   expiration_date_           IN DATE,
   quantity_                  IN NUMBER,
   quantity_reserved_         IN NUMBER,
   catch_quantity_            IN NUMBER,
   account_no_                IN VARCHAR2,
   code_b_                    IN VARCHAR2,
   code_c_                    IN VARCHAR2,
   code_d_                    IN VARCHAR2,
   code_e_                    IN VARCHAR2,
   code_f_                    IN VARCHAR2,
   code_g_                    IN VARCHAR2,
   code_h_                    IN VARCHAR2,
   code_i_                    IN VARCHAR2,
   code_j_                    IN VARCHAR2,
   source_                    IN VARCHAR2,
   price_                     IN NUMBER,
   cost_detail_id_            IN NUMBER,
   condition_code_            IN VARCHAR2,
   part_ownership_db_         IN VARCHAR2,
   delivery_reason_id_        IN VARCHAR2 DEFAULT NULL)
IS
   transaction_id_            NUMBER;
   accounting_id_             NUMBER;
   pre_accounting_id_         NUMBER;
   dummy_number_              NUMBER;
   company_                   VARCHAR2(20);
   source_identifier_         VARCHAR2(200);
   pre_posting_exist_         BOOLEAN := FALSE;
   error_desc_                VARCHAR2(2000);
   location_type_db_          INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   posting_type_              VARCHAR2(4);
   cost_detail_tab_           Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   part_catalog_rec_          Part_Catalog_API.Public_Rec;
   local_part_ownership_db_   INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE;
   local_lot_batch_no_        INVENTORY_PART_IN_STOCK_TAB.lot_batch_no%TYPE;
   apply_default_condition_   BOOLEAN := FALSE;
BEGIN
   IF (transaction_= 'CRATOCO+') THEN 
      posting_type_ := 'M260';
   ELSE   
      posting_type_ := 'M111';
   END IF;

   IF (activity_seq_ != 0) THEN
      Error_SYS.Record_General('InventoryPartInStock', 'ACTSEQNOTALLOW1: Manual receipt is not allowed for Project Inventory parts');
   END IF;

   company_          := Site_API.Get_Company(contract_);
   location_type_db_ := Inventory_Location_API.Get_Location_Type_Db(contract_,location_no_);
   part_catalog_rec_ := Part_Catalog_API.Get(part_no_);
   
   IF (part_catalog_rec_.condition_code_usage = Condition_Code_Usage_API.db_allow_condition_code) THEN
      -- Part is Condition Code enabled
      IF (part_catalog_rec_.receipt_issue_serial_track = db_true_) THEN
         -- Part is serial tracked
         IF (Part_Serial_Catalog_API.Check_Exist(part_no_, serial_no_ ) = db_true_) THEN
            -- The received serial already exists in Part Serial Catalog
            IF (Part_Serial_Catalog_API.Get_Condition_Code(part_no_, serial_no_) IS NULL) THEN
               -- The received serial does not have a Condition Code defined for it
               apply_default_condition_ := TRUE;
            END IF;
         END IF;
      ELSIF (part_catalog_rec_.lot_tracking_code != Part_Lot_Tracking_API.DB_NOT_LOT_TRACKING) THEN
         -- Part is Lot/Batch tracked
         IF (Lot_Batch_Master_API.Check_Exist(part_no_, lot_batch_no_ ) = db_true_) THEN
            -- The received lot already exists in Lot Batch Master
            IF (Lot_Batch_Master_API.Get_Condition_Code(part_no_, lot_batch_no_) IS NULL) THEN
               -- The received lot does not have a Condition Code defined for it
               apply_default_condition_ := TRUE;
            END IF;
         END IF;
      END IF;
      IF (apply_default_condition_) THEN
         Condition_Code_Manager_API.Modify_Condition_Code(part_no_, serial_no_, lot_batch_no_, Condition_Code_API.Get_Default_Condition_Code);
      END IF;
   END IF;

   IF location_type_db_ NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                Inventory_Location_Type_API.DB_PRODUCTION_LINE) THEN
      Raise_Invalid_Loc_Type_Error___(part_no_, location_type_db_);
   END IF;

   local_lot_batch_no_ := lot_batch_no_;
   IF (local_lot_batch_no_ != UPPER(local_lot_batch_no_)) THEN
      IF (Lot_Batch_Master_API.Check_Exist(part_no_, local_lot_batch_no_ ) = 'FALSE') THEN
         local_lot_batch_no_ := UPPER(local_lot_batch_no_);
      END IF;
   END IF;
   local_part_ownership_db_ := Get_Part_Ownership_Db(contract_,
                                                      part_no_,
                                                      configuration_id_,
                                                      location_no_,
                                                      local_lot_batch_no_,
                                                      serial_no_,
                                                      eng_chg_level_,
                                                      waiv_dev_rej_no_,
                                                      activity_seq_,
                                                      handling_unit_id_);
   IF (local_part_ownership_db_ IS NULL) THEN 
      --no on hand qty exists. 
      local_part_ownership_db_ := part_ownership_db_; 
   ELSE
      IF (local_part_ownership_db_ !=  NVL(part_ownership_db_, string_null_)) THEN
         Error_SYS.Record_General(lu_name_, 'OWNERSHIPMISMATCH: The quantity on the stock record is :P1. You are trying to perform a transaction with ownership :P2 on the same record.', 
                                  Part_Ownership_API.Decode(local_part_ownership_db_), 
                                  Part_Ownership_API.Decode(part_ownership_db_));
      END IF;
   END IF;

   IF (local_part_ownership_db_ NOT IN (Part_Ownership_API.DB_COMPANY_OWNED, Part_Ownership_API.DB_COMPANY_RENTAL_ASSET)) THEN
      Error_SYS.Record_General(lu_name_, 'WRONGOWNERSHIP: You are only allowed to receive parts into :P1 or :P2 stock records.', 
                                Part_Ownership_API.Decode(Part_Ownership_API.DB_COMPANY_OWNED),
                                Part_Ownership_API.Decode(Part_Ownership_API.DB_COMPANY_RENTAL_ASSET));
   END IF;

   Check_Waiv_Dev_Rej_No___(contract_             => contract_,
                            part_no_              => part_no_,
                            configuration_id_     => configuration_id_,
                            location_no_          => location_no_,
                            lot_batch_no_         => local_lot_batch_no_,
                            serial_no_            => serial_no_,
                            eng_chg_level_        => eng_chg_level_,
                            waiv_dev_rej_no_      => waiv_dev_rej_no_,
                            activity_seq_         => activity_seq_,
                            handling_unit_id_     => handling_unit_id_,
                            check_during_receipt_ => TRUE,
                            part_catalog_rec_     => part_catalog_rec_,
                            location_type_db_     => location_type_db_,
                            part_ownership_db_    => local_part_ownership_db_, 
                            owning_customer_no_   => NULL,
                            owning_vendor_no_     => NULL);

   IF (cost_detail_id_ IS NOT NULL) THEN
      Temporary_Part_Cost_Detail_API.Get_And_Remove_Details(cost_detail_tab_,
                                                            cost_detail_id_);
   END IF;

   Receive_Part_Impl___(transaction_id_               =>  transaction_id_,
                        accounting_id_                =>  accounting_id_,
                        trans_value_                  =>  dummy_number_,
                        contract_                     =>  contract_,
                        part_no_                      =>  part_no_,
                        configuration_id_             =>  configuration_id_,
                        location_no_                  =>  location_no_,
                        lot_batch_no_                 =>  local_lot_batch_no_,
                        serial_no_                    =>  serial_no_,
                        eng_chg_level_                =>  eng_chg_level_,
                        waiv_dev_rej_no_              =>  waiv_dev_rej_no_,
                        activity_seq_                 =>  activity_seq_,
                        handling_unit_id_             =>  handling_unit_id_,
                        transaction_                  =>  transaction_,
                        expiration_date_              =>  expiration_date_,
                        quantity_                     =>  quantity_,
                        quantity_reserved_            =>  quantity_reserved_,
                        catch_quantity_               =>  catch_quantity_,
                        source_ref1_                  =>  NULL,
                        source_ref2_                  =>  NULL,
                        source_ref3_                  =>  NULL,
                        source_ref4_                  =>  NULL,
                        source_ref5_                  =>  NULL,
                        source_                       =>  source_,
                        unissue_                      =>  FALSE,
                        unit_cost_                    =>  price_,
                        source_ref_type_              =>  NULL,
                        vendor_no_                    =>  NULL,
                        receipt_date_                 =>  NULL,
                        condition_code_               =>  condition_code_,
                        part_ownership_               =>  local_part_ownership_db_, 
                        owning_customer_no_           =>  NULL,
                        cost_detail_tab_              =>  cost_detail_tab_,
                        set_qty_reversed_             =>  FALSE,
                        issue_transaction_id_         =>  NULL,
                        operational_condition_db_     =>  NULL,
                        part_catalog_rec_             =>  part_catalog_rec_,
                        availability_control_id_      =>  NULL,
                        validate_hu_struct_position_  =>  TRUE,
                        ownership_transfer_reason_id_ =>  NULL,
                        delivery_reason_id_              =>  delivery_reason_id_);
   
   @ApproveTransactionStatement(2012-01-25,GanNLK)
   SAVEPOINT before_accounting_receive_;

   pre_accounting_id_ := Inventory_Transaction_Hist_API.Get_Pre_Accounting_Id(transaction_id_);

   IF ((account_no_  IS NOT NULL) OR
       (code_b_      IS NOT NULL) OR
       (code_c_      IS NOT NULL) OR
       (code_d_      IS NOT NULL) OR
       (code_e_      IS NOT NULL) OR
       (code_f_      IS NOT NULL) OR
       (code_g_      IS NOT NULL) OR
       (code_h_      IS NOT NULL) OR
       (code_i_      IS NOT NULL) OR
       (code_j_      IS NOT NULL)) THEN
      Pre_Accounting_API.New(pre_accounting_id_,
                             account_no_,
                             code_b_,
                             code_c_,
                             code_d_,
                             code_e_,
                             code_f_,
                             code_g_,
                             code_h_,
                             code_i_,
                             code_j_,
                             company_,
                             posting_type_,
                             contract_);
      pre_posting_exist_ := TRUE;
   END IF;
     
   IF (local_part_ownership_db_ IN (Part_Ownership_API.DB_COMPANY_OWNED,
                                    Part_Ownership_API.DB_CONSIGNMENT)) THEN
      -- Check that Pre Posting is made if it is mandatory
      -- The identifier have to be translated BEFORE it is passed on.
      source_identifier_ := Language_SYS.Translate_Constant(lu_name_, 'SOURCEIDENTIFIERREC: this receipt.');
      Pre_Accounting_API.Check_Mandatory_Code_Parts(pre_accounting_id_, posting_type_, company_, source_identifier_);
   END IF;

   Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                         company_,
                                                         'N',
                                                         NULL);

   IF Mpccom_Accounting_API.Accounting_Have_Errors(accounting_id_, TRUE) AND (pre_posting_exist_) THEN

      error_desc_ := Mpccom_Accounting_API.Get_A_Pre_Posting_Error_Desc(accounting_id_);
      -- The posting was performed with errors.
      -- Check if that error depends on the pre posting or if it depends on the posting control.
      -- This is due to the fact that we would like to give an immediate response to the user
      -- before this posting is to be completed.
      @ApproveTransactionStatement(2012-01-25,GanNLK)
      ROLLBACK TO before_accounting_receive_;
      -- Do the accounting without the pre posting.
      Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                            company_,
                                                            'N',
                                                            NULL);

      -- Check if the accounting still have errors.
      IF Mpccom_Accounting_API.Accounting_Have_Errors(accounting_id_, TRUE) THEN
         -- The error depended on the posting control and we could let it pass trough
         -- the normal way, meaning it will get status_code = '99' instead of an hard error.
         -- The original posrting has to be done all over from the beginning including both
         -- ordinary posting control and pre posting.
         @ApproveTransactionStatement(2012-01-25,GanNLK)
         ROLLBACK TO before_accounting_receive_;
         Pre_Accounting_API.New(pre_accounting_id_,
                                account_no_,
                                code_b_,
                                code_c_,
                                code_d_,
                                code_e_,
                                code_f_,
                                code_g_,
                                code_h_,
                                code_i_,
                                code_j_,
                                company_,
                                posting_type_,
                                contract_);
         Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                               company_,
                                                               'N',
                                                               NULL);
      ELSE
         -- The error depended on the pre posting.
         -- An hard error is to be raised to immediately inform the user.
         -- error_desc_ is already translated.
         Raise_Pre_Posting_Not_Acc_Error___(error_desc_);
      END IF;
   END IF;
END Receive_Part_With_Posting;


-- Receive_Part_On_Purchase_Order
--   Inserts quantities of inventory parts into inventory due to purchase arrivals.
PROCEDURE Receive_Part_On_Purchase_Order (
   unattached_from_handling_unit_  OUT VARCHAR2,
   contract_                        IN VARCHAR2,
   part_no_                         IN VARCHAR2,
   configuration_id_                IN VARCHAR2,
   location_no_                     IN VARCHAR2,
   lot_batch_no_                    IN VARCHAR2,
   serial_no_                       IN VARCHAR2,
   eng_chg_level_                   IN VARCHAR2,
   waiv_dev_rej_no_                 IN VARCHAR2,
   activity_seq_                    IN NUMBER,
   handling_unit_id_                IN NUMBER,
   transaction_                     IN VARCHAR2,
   expiration_date_                 IN DATE,
   qty_received_                    IN NUMBER,
   catch_qty_received_              IN NUMBER,
   order_no_                        IN VARCHAR2,
   line_no_                         IN VARCHAR2,
   release_no_                      IN VARCHAR2,
   receipt_no_                      IN VARCHAR2,
   vendor_no_                       IN VARCHAR2,
   receipt_date_                    IN DATE,
   price_                           IN NUMBER,
   cost_detail_tab_                 IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab,
   part_ownership_                  IN VARCHAR2,
   owning_customer_no_              IN VARCHAR2,
   condition_code_                  IN VARCHAR2,
   supplier_contract_               IN VARCHAR2,
   remove_default_qty_              IN VARCHAR2,
   transit_eng_chg_level_           IN VARCHAR2,
   operational_condition_db_        IN VARCHAR2,
   comp_cost_transaction_id_        IN NUMBER,
   validate_hu_struct_position_     IN BOOLEAN  DEFAULT TRUE,
   transit_handling_unit_id_        IN VARCHAR2 DEFAULT NULL,
   supplier_del_note_no_            IN VARCHAR2 DEFAULT NULL,
   del_note_date_                   IN DATE     DEFAULT NULL)
IS
BEGIN
   Receive_Part_On_Order__(unattached_from_handling_unit_ => unattached_from_handling_unit_,
                           contract_                      => contract_,
                           part_no_                       => part_no_,
                           configuration_id_              => configuration_id_,
                           location_no_                   => location_no_,
                           lot_batch_no_                  => lot_batch_no_,
                           serial_no_                     => serial_no_,
                           eng_chg_level_                 => eng_chg_level_,
                           waiv_dev_rej_no_               => waiv_dev_rej_no_,
                           activity_seq_                  => activity_seq_,
                           handling_unit_id_              => handling_unit_id_,
                           transaction_                   => transaction_,
                           expiration_date_               => expiration_date_,
                           delivering_warehouse_id_       => '*',
                           receiving_warehouse_id_        => '*',
                           qty_received_                  => qty_received_,
                           catch_qty_received_            => catch_qty_received_,
                           source_ref1_                   => order_no_,
                           source_ref2_                   => line_no_,
                           source_ref3_                   => release_no_,
                           source_ref4_                   => NULL,
                           source_ref5_                   => NULL,
                           source_ref_type_               => Order_Type_API.DB_PURCHASE_ORDER,
                           receipt_no_                    => receipt_no_,
                           vendor_no_                     => vendor_no_,
                           receipt_date_                  => receipt_date_,
                           price_                         => price_,
                           cost_detail_tab_               => cost_detail_tab_,
                           part_ownership_                => part_ownership_,
                           owning_customer_no_            => owning_customer_no_,
                           condition_code_                => condition_code_,
                           sender_contract_               => supplier_contract_,
                           remove_default_qty_            => remove_default_qty_,
                           transit_eng_chg_level_         => transit_eng_chg_level_,
                           operational_condition_db_      => operational_condition_db_,
                           comp_cost_transaction_id_      => comp_cost_transaction_id_,
                           validate_hu_struct_position_   => validate_hu_struct_position_,
                           transit_handling_unit_id_      => transit_handling_unit_id_,
                           supplier_del_note_no_          => supplier_del_note_no_,
                           del_note_date_                 => del_note_date_);

END Receive_Part_On_Purchase_Order;


-- Receive_Part_On_Shipment_Order
--   Inserts quantities of inventory parts into inventory due to shipment arrivals.
PROCEDURE Receive_Part_On_Shipment_Order (
   unattached_from_handling_unit_  OUT VARCHAR2,
   contract_                        IN VARCHAR2,
   part_no_                         IN VARCHAR2,
   configuration_id_                IN VARCHAR2,
   location_no_                     IN VARCHAR2,
   lot_batch_no_                    IN VARCHAR2,
   serial_no_                       IN VARCHAR2,
   eng_chg_level_                   IN VARCHAR2,
   waiv_dev_rej_no_                 IN VARCHAR2,
   activity_seq_                    IN NUMBER,
   handling_unit_id_                IN NUMBER,
   transaction_                     IN VARCHAR2,
   expiration_date_                 IN DATE,
   delivering_warehouse_id_         IN VARCHAR2,
   receiving_warehouse_id_          IN VARCHAR2,
   qty_received_                    IN NUMBER,
   catch_qty_received_              IN NUMBER,
   shipment_order_id_               IN VARCHAR2,
   line_no_                         IN VARCHAR2,
   receipt_no_                      IN VARCHAR2,
   receipt_date_                    IN DATE,
   part_ownership_                  IN VARCHAR2,
   owning_vendor_no_                IN VARCHAR2,
   owning_customer_no_              IN VARCHAR2,
   condition_code_                  IN VARCHAR2,
   sender_contract_                 IN VARCHAR2,
   remove_default_qty_              IN VARCHAR2,
   transit_eng_chg_level_           IN VARCHAR2,
   operational_condition_db_        IN VARCHAR2,
   validate_hu_struct_position_     IN BOOLEAN  DEFAULT TRUE,
   transit_handling_unit_id_        IN VARCHAR2 DEFAULT NULL)
IS
   price_                           NUMBER;
   cost_detail_tab_                 Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   
BEGIN
   
   Receive_Part_On_Order__(unattached_from_handling_unit_ => unattached_from_handling_unit_,
                           contract_                      => contract_,
                           part_no_                       => part_no_,
                           configuration_id_              => configuration_id_,
                           location_no_                   => location_no_,
                           lot_batch_no_                  => lot_batch_no_,
                           serial_no_                     => serial_no_,
                           eng_chg_level_                 => eng_chg_level_,
                           waiv_dev_rej_no_               => waiv_dev_rej_no_,
                           activity_seq_                  => activity_seq_,
                           handling_unit_id_              => handling_unit_id_,
                           transaction_                   => transaction_,
                           expiration_date_               => expiration_date_,
                           delivering_warehouse_id_       => delivering_warehouse_id_,
                           receiving_warehouse_id_        => receiving_warehouse_id_,
                           qty_received_                  => qty_received_,
                           catch_qty_received_            => catch_qty_received_,
                           source_ref1_                   => shipment_order_id_,
                           source_ref2_                   => line_no_,
                           source_ref3_                   => NULL,
                           source_ref4_                   => NULL,
                           source_ref5_                   => NULL,
                           source_ref_type_               => Order_Type_API.DB_SHIPMENT_ORDER,
                           receipt_no_                    => receipt_no_,
                           vendor_no_                     => owning_vendor_no_,
                           receipt_date_                  => receipt_date_,
                           price_                         => price_,
                           cost_detail_tab_               => cost_detail_tab_,
                           part_ownership_                => part_ownership_,
                           owning_customer_no_            => owning_customer_no_,
                           condition_code_                => condition_code_,
                           sender_contract_               => sender_contract_,
                           remove_default_qty_            => remove_default_qty_,
                           transit_eng_chg_level_         => transit_eng_chg_level_,
                           operational_condition_db_      => operational_condition_db_,
                           comp_cost_transaction_id_      => NULL,
                           validate_hu_struct_position_   => validate_hu_struct_position_,
                           transit_handling_unit_id_      => transit_handling_unit_id_);

END Receive_Part_On_Shipment_Order;


PROCEDURE Make_Onhand_Analysis (
   result_                      IN OUT VARCHAR2,
   qty_possible_                IN OUT NUMBER,
   next_analysis_date_          IN OUT DATE,
   planned_delivery_date_       IN OUT DATE,
   planned_due_date_            IN OUT DATE,
   contract_                    IN     VARCHAR2,
   part_no_                     IN     VARCHAR2,
   configuration_id_            IN     VARCHAR2,
   include_standard_            IN     VARCHAR2,   
   include_project_             IN     VARCHAR2,   
   project_id_                  IN     VARCHAR2,
   activity_seq_                IN     NUMBER,
   row_id_                      IN     VARCHAR2,
   qty_desired_                 IN     NUMBER,
   picking_leadtime_            IN     NUMBER DEFAULT NULL,
   part_ownership_              IN     VARCHAR2 DEFAULT 'COMPANY OWNED',
   owning_vendor_no_            IN     VARCHAR2 DEFAULT NULL,
   owning_customer_no_          IN     VARCHAR2 DEFAULT NULL,
   detect_supplies_not_allowed_ IN     BOOLEAN DEFAULT FALSE )
IS
   qty_earliest_     NUMBER;
BEGIN

   Make_Onhand_Analysis_Impl___(result_,
                                qty_possible_,
                                qty_earliest_,
                                next_analysis_date_,
                                planned_delivery_date_,
                                planned_due_date_,
                                contract_,
                                part_no_,
                                configuration_id_,
                                include_standard_,
                                include_project_,
                                project_id_,
                                activity_seq_,
                                row_id_,
                                qty_desired_,
                                picking_leadtime_,
                                TRUE,
                                part_ownership_,
                                owning_vendor_no_,
                                owning_customer_no_,
                                detect_supplies_not_allowed_,
                                TRUE); 
END Make_Onhand_Analysis;


-- Make_Onhand_Analysis_Shpord
--   A version of the original MakeOnhandAnalysis that conditionally uses
--   the pick_lead_time and returns a quantity parameter Qty_Earliest.
--   Used from Shop Order to conditionally use pick leadtime.
PROCEDURE Make_Onhand_Analysis_Shpord (
   result_                IN OUT VARCHAR2,
   qty_possible_          IN OUT NUMBER,
   qty_earliest_          IN OUT NUMBER,
   next_analysis_date_    IN OUT DATE,
   planned_delivery_date_ IN OUT DATE,
   planned_due_date_      IN OUT DATE,
   contract_              IN     VARCHAR2,
   part_no_               IN     VARCHAR2,
   configuration_id_      IN     VARCHAR2,
   include_standard_      IN     VARCHAR2,   
   include_project_       IN     VARCHAR2,   
   project_id_            IN     VARCHAR2,
   activity_seq_          IN     NUMBER,
   row_id_                IN     VARCHAR2,
   qty_desired_           IN     NUMBER,
   use_pick_leadtime_     IN     BOOLEAN  DEFAULT NULL,
   part_ownership_        IN     VARCHAR2 DEFAULT 'COMPANY OWNED',
   owning_vendor_no_      IN     VARCHAR2 DEFAULT NULL,
   owning_customer_no_    IN     VARCHAR2 DEFAULT NULL )
IS
BEGIN
   Make_Onhand_Analysis_Impl___(result_,
                                qty_possible_,
                                qty_earliest_,
                                next_analysis_date_,
                                planned_delivery_date_,
                                planned_due_date_,
                                contract_,
                                part_no_,
                                configuration_id_,
                                include_standard_,
                                include_project_,
                                project_id_,
                                activity_seq_,
                                row_id_,
                                qty_desired_,
                                NULL,
                                use_pick_leadtime_,
                                part_ownership_,
                                owning_vendor_no_,
                                owning_customer_no_,
                                FALSE,
                                FALSE); 
END Make_Onhand_Analysis_Shpord;

-- Make_Onhand_Analysis_B2b_Vmi
-- A version of the original MakeOnhandAnalysis that 
-- only returns the qty_possible, used by B2B display VMI.
-- (And we must use functions, which returns single values, due to current limitations in UXX FW)
FUNCTION Make_Onhand_Analysis_B2b_Vmi (   
   contract_                    IN     VARCHAR2,
   part_no_                     IN     VARCHAR2,
   configuration_id_            IN     VARCHAR2,
   include_standard_            IN     VARCHAR2,   
   include_project_             IN     VARCHAR2,   
   project_id_                  IN     VARCHAR2,
   activity_seq_                IN     NUMBER,
   row_id_                      IN     VARCHAR2,
   qty_desired_                 IN     NUMBER,
   picking_leadtime_            IN     NUMBER DEFAULT NULL,
   part_ownership_              IN     VARCHAR2 DEFAULT 'COMPANY OWNED',
   owning_vendor_no_            IN     VARCHAR2 DEFAULT NULL,
   owning_customer_no_          IN     VARCHAR2 DEFAULT NULL,
   detect_supplies_not_allowed_ IN     BOOLEAN DEFAULT FALSE ) RETURN NUMBER
IS
   result_                VARCHAR2(20);
   qty_possible_          NUMBER;
   qty_earliest_          NUMBER;
   next_analysis_date_    DATE;
   planned_delivery_date_ DATE;
   planned_due_date_      DATE := Site_API.Get_Site_Date(contract_);
BEGIN
   Make_Onhand_Analysis_Impl___(result_,
                                qty_possible_,
                                qty_earliest_,
                                next_analysis_date_,
                                planned_delivery_date_,
                                planned_due_date_,
                                contract_,
                                part_no_,
                                configuration_id_,
                                include_standard_,
                                include_project_,
                                project_id_,
                                activity_seq_,
                                row_id_,
                                qty_desired_,
                                picking_leadtime_,
                                TRUE,
                                part_ownership_,
                                owning_vendor_no_,
                                owning_customer_no_,
                                detect_supplies_not_allowed_,
                                TRUE); 
   RETURN qty_possible_;
END Make_Onhand_Analysis_B2b_Vmi;


PROCEDURE Move_Part_Project (
   contract_                     IN VARCHAR2,
   part_no_                      IN VARCHAR2,
   configuration_id_             IN VARCHAR2,
   location_no_                  IN VARCHAR2,
   lot_batch_no_                 IN VARCHAR2,
   serial_no_                    IN VARCHAR2,
   eng_chg_level_                IN VARCHAR2,
   waiv_dev_rej_no_              IN VARCHAR2,
   activity_seq_                 IN NUMBER,
   handling_unit_id_             IN NUMBER,
   expiration_date_              IN DATE,
   to_activity_seq_              IN NUMBER,
   quantity_                     IN NUMBER,
   quantity_reserved_            IN NUMBER,
   move_comment_                 IN VARCHAR2,
   report_earned_value_db_       IN VARCHAR2,
   ownership_transfer_reason_id_ IN VARCHAR2,
   catch_quantity_               IN NUMBER DEFAULT NULL )
IS
   temp_catch_quantity_           NUMBER := NULL;
   to_expiration_date_            INVENTORY_PART_IN_STOCK_TAB.expiration_date%TYPE;
   from_expiration_date_          INVENTORY_PART_IN_STOCK_TAB.expiration_date%TYPE;
   from_availability_control_id_  INVENTORY_PART_IN_STOCK_TAB.availability_control_id%TYPE;
   to_availability_control_id_    INVENTORY_PART_IN_STOCK_TAB.availability_control_id%TYPE;
   to_location_exist_             BOOLEAN;
   make_transaction_and_postings_ BOOLEAN := TRUE;
   company_                       VARCHAR2(20);
   proj_company_                  VARCHAR2(20);
   project_id_                    VARCHAR2(10);   
   to_rec_                        INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   last_calendar_date_            DATE         := Database_Sys.last_calendar_date_;
BEGIN

   company_ := Site_API.Get_Company(contract_);
   
   $IF Component_Proj_SYS.INSTALLED $THEN      
      proj_company_ := Project_API.Get_Company(Activity_API.Get_Project_Id(to_activity_seq_));
      project_id_ := Activity_API.Get_Project_Id(to_activity_seq_);     
   $END

   IF (proj_company_ IS NOT NULL) THEN
      IF (company_ != proj_company_) THEN
         Error_SYS.Record_General('InventoryPartInStock','DIFFPROJCOMPANY: Project :P1 related to activity sequence :P2 is not associated with company :P3.',project_id_, to_activity_seq_, company_);
      END IF;
   END IF;

   IF (Mpccom_System_Parameter_API.Get_Parameter_Value1('TRANSACTIONS_PROJECT_TRANSFERS') = 'N') THEN
      make_transaction_and_postings_ := FALSE;
   END IF;

   from_availability_control_id_ := Get_Availability_Control_Id(contract_,
                                                               part_no_,
                                                               configuration_id_,
                                                               location_no_,
                                                               lot_batch_no_,
                                                               serial_no_,
                                                               eng_chg_level_,
                                                               waiv_dev_rej_no_,
                                                               activity_seq_,
                                                               handling_unit_id_);

   to_rec_ := Get_Object_By_Keys___(contract_,
                                    part_no_,
                                    configuration_id_,
                                    location_no_,
                                    lot_batch_no_,
                                    serial_no_,
                                    eng_chg_level_,
                                    waiv_dev_rej_no_,
                                    to_activity_seq_,
                                    handling_unit_id_);

   IF (to_rec_.part_no IS NULL) THEN
      to_location_exist_ := FALSE;
   ELSE
      to_location_exist_ := TRUE;
      to_availability_control_id_ := to_rec_.availability_control_id;
      to_expiration_date_        := to_rec_.expiration_date;
   END IF;

   IF (NVL(from_availability_control_id_, 'DuMmY') != NVL(to_availability_control_id_, 'DuMmY') AND to_location_exist_ 
      AND  (to_rec_.qty_onhand != 0 OR  to_rec_.qty_in_transit != 0)) THEN
      Error_SYS.Record_General('InventoryPartInStock','AVCTRLDIFFERS: Cannot move to a location with different Availability Control ID.');
   END IF;

   from_expiration_date_ := expiration_date_;

   IF (NVL(to_expiration_date_, last_calendar_date_) <
         NVL(from_expiration_date_, last_calendar_date_)) THEN
      from_expiration_date_ := to_expiration_date_;
   END IF;

   -- We re-assign the catch quantity to a local variable since we can not use a IN
   -- parameter as INOUT parameter in call to Move_Part_Impl___.
   temp_catch_quantity_ := catch_quantity_;

   Move_Part_Impl___(catch_quantity_                => temp_catch_quantity_,
                     contract_                      => contract_,
                     part_no_                       => part_no_,
                     configuration_id_              => configuration_id_,
                     location_no_                   => location_no_,
                     lot_batch_no_                  => lot_batch_no_,
                     serial_no_                     => serial_no_,
                     eng_chg_level_                 => eng_chg_level_,
                     waiv_dev_rej_no_               => waiv_dev_rej_no_,
                     activity_seq_                  => activity_seq_,
                     handling_unit_id_              => handling_unit_id_,
                     expiration_date_               => from_expiration_date_,
                     to_contract_                   => contract_,
                     to_part_no_                    => part_no_,
                     to_location_no_                => location_no_,
                     to_destination_db_             => 'N',
                     to_waiv_dev_rej_no_            => waiv_dev_rej_no_,
                     to_lot_batch_no_               => lot_batch_no_,
                     to_serial_no_                  => serial_no_,
                     to_activity_seq_               => to_activity_seq_,
                     to_handling_unit_id_           => handling_unit_id_,
                     quantity_                      => quantity_,
                     quantity_reserved_             => quantity_reserved_,
                     move_comment_                  => move_comment_,
                     order_no_                      => NULL,
                     line_no_                       => NULL,
                     release_no_                    => NULL,
                     line_item_no_                  => NULL,
                     source_ref5_                   => NULL,
                     order_type_                    => NULL,
                     consume_consignment_stock_     => FALSE,
                     make_transaction_and_postings_ => make_transaction_and_postings_,
                     report_earned_value_db_        => report_earned_value_db_,
                     from_part_catalog_rec_         => NULL,
                     to_part_catalog_rec_           => NULL,
                     transport_task_id_             => NULL,
                     validate_hu_struct_position_   => FALSE,
                     availability_ctrl_id_          => NULL,
                     always_preserve_serial_no_     => FALSE,
                     ownership_transfer_reason_id_  => ownership_transfer_reason_id_);

   IF (NOT to_location_exist_ AND from_availability_control_id_ IS NOT NULL) THEN
      Modify_Availability_Control_Id(contract_,
                                     part_no_,
                                     configuration_id_,
                                     location_no_,
                                     lot_batch_no_,
                                     serial_no_,
                                     eng_chg_level_,
                                     waiv_dev_rej_no_,
                                     to_activity_seq_,
                                     handling_unit_id_,
                                     from_availability_control_id_);

   END IF;
END Move_Part_Project;


-- Handle_Lot_Condition_Change
--   This public method must only be used from InventConditionCodeUtil in
--   Inventory when the condition code has been changed on a LotBatchMaster record.
--   The methods updates Availability Control Id when changing condition code.
PROCEDURE Handle_Lot_Condition_Change (
   part_no_            IN VARCHAR2,
   lot_batch_no_       IN VARCHAR2,
   new_condition_code_ IN VARCHAR2 )
IS
   new_avail_control_id_  INVENTORY_PART_IN_STOCK_TAB.availability_control_id%TYPE;

   CURSOR get_records (part_no_      IN VARCHAR2,
                       lot_batch_no_ IN VARCHAR2) IS
      SELECT contract,
             configuration_id,
             location_no,
             serial_no,
             eng_chg_level,
             waiv_dev_rej_no,
             activity_seq,
             handling_unit_id
      FROM   INVENTORY_PART_IN_STOCK_TAB
      WHERE part_no      = part_no_
        AND lot_batch_no = lot_batch_no_
        AND (qty_onhand != 0 OR qty_in_transit != 0)
      FOR UPDATE;

BEGIN
   new_avail_control_id_ := Condition_Code_API.Get_Default_Avail_Control_Id(new_condition_code_);

   IF new_avail_control_id_ IS NOT NULL THEN
      FOR rec_ IN get_records(part_no_, lot_batch_no_) LOOP
         Modify_Availability_Control_Id(rec_.contract,
                                        part_no_,
                                        rec_.configuration_id,
                                        rec_.location_no,
                                        lot_batch_no_,
                                        rec_.serial_no,
                                        rec_.eng_chg_level,
                                        rec_.waiv_dev_rej_no,
                                        rec_.activity_seq,
                                        rec_.handling_unit_id,
                                        new_avail_control_id_);
      END LOOP;
   END IF;
END Handle_Lot_Condition_Change;


-- Move_Part_Shipment
--   Handle shipment location movements.
PROCEDURE Move_Part_Shipment (
   unattached_from_handling_unit_      OUT VARCHAR2,
   catch_quantity_                  IN OUT NUMBER,
   contract_                        IN     VARCHAR2,
   part_no_                         IN     VARCHAR2,
   configuration_id_                IN     VARCHAR2,
   location_no_                     IN     VARCHAR2,
   lot_batch_no_                    IN     VARCHAR2,
   serial_no_                       IN     VARCHAR2,
   eng_chg_level_                   IN     VARCHAR2,
   waiv_dev_rej_no_                 IN     VARCHAR2,
   activity_seq_                    IN     NUMBER,
   handling_unit_id_                IN     NUMBER,
   expiration_date_                 IN     DATE,
   to_contract_                     IN     VARCHAR2,
   to_location_no_                  IN     VARCHAR2,
   quantity_                        IN     NUMBER,
   quantity_reserved_               IN     NUMBER,
   move_comment_                    IN     VARCHAR2,
   order_no_                        IN     VARCHAR2,
   line_no_                         IN     VARCHAR2,
   release_no_                      IN     VARCHAR2,
   line_item_no_                    IN     VARCHAR2,
   source_ref5_                     IN     VARCHAR2,
   order_type_                      IN     VARCHAR2, 
   transport_task_id_               IN     NUMBER  DEFAULT NULL,
   validate_hu_struct_position_     IN     BOOLEAN DEFAULT TRUE )
IS
   to_location_type_db_    VARCHAR2(20) := Inventory_Location_API.Get_Location_Type_db(to_contract_,to_location_no_);
   from_location_type_db_  VARCHAR2(20) := Inventory_Location_API.Get_Location_Type_db(contract_,location_no_);
   order_type_db_          VARCHAR2(50);
BEGIN

   IF (contract_ != to_contract_) THEN
      Error_SYS.Record_General('InventoryPartInStock','SHIPSAMESITE: Move quantity to or from shipment location only allowed within same site.');
   END IF;

   order_type_db_ := NVL(Order_Type_API.Encode(order_type_), '*');
   
   IF (order_type_db_ != Order_Type_API.DB_PURCH_RECEIPT_RETURN) THEN
      IF (from_location_type_db_ NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                         Inventory_Location_Type_API.DB_SHIPMENT,
                                         Inventory_Location_Type_API.DB_PRODUCTION_LINE,
                                         Inventory_Location_Type_API.DB_FLOOR_STOCK)) THEN
         Error_SYS.Record_General('InventoryPartInStock','NOTCORRECTLOCFROM: From location is not a Picking,Shipment,Production Line or Floor Stock location.');
      END IF; 
   END IF;
   
   IF (order_type_db_ != Order_Type_API.DB_PURCH_RECEIPT_RETURN) THEN
      IF (to_location_type_db_ NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                       Inventory_Location_Type_API.DB_SHIPMENT,
                                       Inventory_Location_Type_API.DB_PRODUCTION_LINE,
                                       Inventory_Location_Type_API.DB_FLOOR_STOCK)) THEN
         Error_SYS.Record_General('InventoryPartInStock','NOTCORRECTLOCTO: To location is not a Picking,Shipment,Production Line or Floor Stock location.');
      END IF;
   END IF;

   IF ((from_location_type_db_ != Inventory_Location_Type_API.DB_SHIPMENT) AND
       (to_location_type_db_   != Inventory_Location_Type_API.DB_SHIPMENT)) THEN
      Error_SYS.Record_General('InventoryPartInStock','SHIPLOCMISS: One of the locations must be a Shipment Location.');
   END IF;

   Move_Part(unattached_from_handling_unit_ => unattached_from_handling_unit_,
             catch_quantity_                => catch_quantity_,
             contract_                      => contract_,
             part_no_                       => part_no_,
             configuration_id_              => configuration_id_,
             location_no_                   => location_no_,
             lot_batch_no_                  => lot_batch_no_,
             serial_no_                     => serial_no_,
             eng_chg_level_                 => eng_chg_level_,
             waiv_dev_rej_no_               => waiv_dev_rej_no_,
             activity_seq_                  => activity_seq_,
             handling_unit_id_              => handling_unit_id_,
             expiration_date_               => expiration_date_,
             to_contract_                   => to_contract_,
             to_location_no_                => to_location_no_,
             to_destination_                => Inventory_Part_Destination_API.Decode('N'),
             quantity_                      => quantity_,
             quantity_reserved_             => quantity_reserved_,
             move_comment_                  => move_comment_,
             order_no_                      => order_no_,
             release_no_                    => line_no_,
             sequence_no_                   => release_no_,
             line_item_no_                  => line_item_no_,
             source_ref5_                   => source_ref5_,
             order_type_                    => order_type_,
             transport_task_id_             => transport_task_id_,
             validate_hu_struct_position_   => validate_hu_struct_position_,
             move_part_shipment_            => TRUE);
             
END Move_Part_Shipment;


-- Quantity_Exists
--   Returns TRUE if there are records with qty_onhand or qty_in_transit
--   not equal to zero for records having the specified serial_tracking option.
--   Otherwise returns FALSE.
@UncheckedAccess
FUNCTION Quantity_Exists (
   part_no_        IN VARCHAR2,
   serial_tracked_ IN BOOLEAN ) RETURN BOOLEAN
IS
   dummy_               NUMBER;
   quantity_exists_     BOOLEAN     := FALSE;
   serial_tracked_char_ VARCHAR2(5) := db_false_;

   CURSOR exist_control IS
      SELECT 1
      FROM INVENTORY_PART_IN_STOCK_TAB
      WHERE ((serial_no != '*' AND serial_tracked_char_ = db_true_) OR
             (serial_no  = '*' AND serial_tracked_char_ = db_false_))
      AND part_no = part_no_
      AND (qty_onhand != 0 OR qty_in_transit != 0);
BEGIN
   IF (serial_tracked_) THEN
      serial_tracked_char_ := db_true_;
   END IF;

   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      quantity_exists_ := TRUE;
   END IF;
   CLOSE exist_control;

   RETURN(quantity_exists_);
END Quantity_Exists;


-- Get_Lot_Batch_Track_Status
--   Returns the present usage of lot batch tracking in InventoryPartLocation.
--   If there are no '*' used then Lot Tracking is returned
--   If there are just '*' used then Not Lot Tracking is returned
--   If there is no part in InventoryPartLocation then NULL is returned
@UncheckedAccess
FUNCTION Get_Lot_Batch_Track_Status (
   part_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   dummy_         NUMBER;
   default_value_ BOOLEAN := FALSE;
   other_value_   BOOLEAN := FALSE;
   return_string_ VARCHAR2(20);

   CURSOR get_defaults IS
      SELECT 1
      FROM INVENTORY_PART_IN_STOCK_TAB
      WHERE lot_batch_no = '*'
      AND part_no = part_no_
      AND (qty_onhand != 0 OR qty_in_transit != 0);

   CURSOR get_not_defaults IS
      SELECT 1
      FROM INVENTORY_PART_IN_STOCK_TAB
      WHERE lot_batch_no != '*'
      AND part_no = part_no_
      AND (qty_onhand != 0 OR qty_in_transit != 0);
BEGIN
   OPEN get_defaults;
   FETCH get_defaults INTO dummy_;
   IF get_defaults%FOUND THEN
      default_value_ := TRUE;
   END IF;
   CLOSE get_defaults;

   OPEN get_not_defaults;
   FETCH get_not_defaults INTO dummy_;
   IF get_not_defaults%FOUND THEN
      other_value_ := TRUE;
   END IF;
   CLOSE get_not_defaults;

   IF other_value_ AND NOT default_value_ THEN
      return_string_ := 'LOT TRACKING';
   ELSIF default_value_ AND NOT other_value_ THEN
      return_string_ := 'NOT LOT TRACKING';
   ELSIF default_value_ AND other_value_ THEN
      return_string_ := 'BOTH';
   ELSIF NOT default_value_ AND NOT other_value_ THEN
      return_string_ := NULL;
   END IF;
   RETURN return_string_;
END Get_Lot_Batch_Track_Status;


-- Check_Individual_Exist
--   Checks if there is a quantity on hand for this individual in the inventory.
--   Return 1 if there is a quantity otherwise 0
@UncheckedAccess
FUNCTION Check_Individual_Exist (
   part_no_    IN VARCHAR2,
   serial_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   CURSOR check_part_loc IS
      SELECT 1
      FROM INVENTORY_PART_IN_STOCK_TAB
      WHERE part_no = part_no_
      AND serial_no = serial_no_
      AND (qty_onhand != 0 OR qty_in_transit != 0);

   exist_   NUMBER := 1;
BEGIN
   OPEN check_part_loc;
   FETCH check_part_loc INTO exist_;
   IF check_part_loc%NOTFOUND THEN
      exist_ := 0;
   END IF;
   CLOSE check_part_loc;
   RETURN(exist_);
END Check_Individual_Exist;


-- Count_Part
--   Inserts or modifies a counted part by calling Inventory_Part.
--   This method does only accept counting on location types Picking and
--   Floor stock and Manufacturing cell.
PROCEDURE Count_Part (
   contract_                 IN VARCHAR2,
   part_no_                  IN VARCHAR2,
   configuration_id_         IN VARCHAR2,
   location_no_              IN VARCHAR2,
   lot_batch_no_             IN VARCHAR2,
   serial_no_                IN VARCHAR2,
   eng_chg_level_            IN VARCHAR2,
   waiv_dev_rej_no_          IN VARCHAR2,
   activity_seq_             IN NUMBER,
   handling_unit_id_         IN NUMBER,
   qty_difference_           IN NUMBER,
   catch_qty_difference_     IN NUMBER,
   unit_cost_                IN NUMBER,
   condition_code_           IN VARCHAR2,
   note_text_                IN VARCHAR2,
   cost_detail_id_           IN NUMBER,
   part_tracking_session_id_ IN NUMBER,
   inv_list_no_              IN VARCHAR2,
   seq_no_                   IN NUMBER )
IS
   lurec_                            inventory_part_in_stock_tab%ROWTYPE;
   oldrec_                           inventory_part_in_stock_tab%ROWTYPE;
   newrec_                           inventory_part_in_stock_tab%ROWTYPE;
   qty_counted_                      NUMBER;
   catch_qty_counted_                NUMBER;
   serial_catch_tab_                 Serial_Catch_Table;
   local_qty_difference_             NUMBER;
   local_catch_qty_difference_       NUMBER;
   number_of_serials_                NUMBER;
   existing_serial_location_no_      inventory_part_in_stock_tab.location_no%TYPE;
   existing_expiration_date_         inventory_part_in_stock_tab.expiration_date%TYPE; 
   existing_receipt_date_            inventory_part_in_stock_tab.receipt_date%TYPE; 
   existing_availability_control_id_ inventory_part_in_stock_tab.availability_control_id%TYPE; 
   existing_rotable_part_pool_id_    inventory_part_in_stock_tab.rotable_part_pool_id%TYPE; 
   existing_catch_qty_onhand_        inventory_part_in_stock_tab.catch_qty_onhand%TYPE;  
   existing_part_ownership_          inventory_part_in_stock_tab.part_ownership%TYPE; 
   existing_owning_customer_no_      inventory_part_in_stock_tab.owning_customer_no%TYPE; 
   existing_owning_vendor_no_        inventory_part_in_stock_tab.owning_vendor_no%TYPE; 
   existing_serial_rec_              inventory_part_in_stock_tab%ROWTYPE;
   note_text_for_count_out_          VARCHAR2(2000);
   inv_part_in_stock_tab_            Public_Tab; 
   serial_exist_in_different_loc_    BOOLEAN := FALSE;
BEGIN

   lurec_ := Get_Object_By_Keys___(contract_,
                                   part_no_,
                                   configuration_id_,
                                   location_no_,
                                   lot_batch_no_,
                                   serial_no_,
                                   eng_chg_level_,
                                   waiv_dev_rej_no_,
                                   activity_seq_,
                                   handling_unit_id_);
                                   
   -- This is to count out the serial part from the existing location before count in the same serial part in
   -- another location.
   IF serial_no_ != '*' AND qty_difference_ > 0  THEN
      inv_part_in_stock_tab_ := Get_Other_Stock_Loc_Onhand(contract_,
                                                           part_no_,
                                                           configuration_id_,
                                                           location_no_,
                                                           lot_batch_no_,
                                                           serial_no_,
                                                           eng_chg_level_,
                                                           waiv_dev_rej_no_,
                                                           activity_seq_,
                                                           handling_unit_id_);
      -- A particular serial should be in one location. Therefore, here only the first record is considered.          
      IF inv_part_in_stock_tab_.COUNT = 1  THEN        
         serial_exist_in_different_loc_ := TRUE;
         existing_serial_location_no_      := inv_part_in_stock_tab_(1).location_no;
         existing_expiration_date_         := inv_part_in_stock_tab_(1).expiration_date;
         existing_receipt_date_            := inv_part_in_stock_tab_(1).receipt_date;
         existing_availability_control_id_ := inv_part_in_stock_tab_(1).availability_control_id;
         existing_rotable_part_pool_id_    := inv_part_in_stock_tab_(1).rotable_part_pool_id;
         existing_catch_qty_onhand_        := inv_part_in_stock_tab_(1).catch_qty_onhand;
         existing_part_ownership_          := inv_part_in_stock_tab_(1).part_ownership;
         existing_owning_customer_no_      := inv_part_in_stock_tab_(1).owning_customer_no;
         existing_owning_vendor_no_        := inv_part_in_stock_tab_(1).owning_vendor_no; 
      ELSIF inv_part_in_stock_tab_.COUNT > 1 THEN
         Error_SYS.Record_General(lu_name_,'INCOSSERIALLOC: Inconsistency found in Serial Location. Contact System Support.');      
      END IF; 
   
      IF existing_serial_location_no_ IS NOT NULL THEN                                                    
         existing_serial_rec_ := Lock_By_Keys___(contract_,
                                                 part_no_,
                                                 configuration_id_,
                                                 existing_serial_location_no_,
                                                 lot_batch_no_,
                                                 serial_no_,
                                                 eng_chg_level_,
                                                 waiv_dev_rej_no_,
                                                 activity_seq_,
                                                 handling_unit_id_);
                                                 
         note_text_for_count_out_ := Language_SYS.Translate_Constant(lu_name_, 'NONEXISTSERIALATLOC: Counting out physically non-existing serial at location :P1.', NULL, existing_serial_location_no_);

         Inventory_Part_In_Stock_API.Count_Part(contract_                 => existing_serial_rec_.contract,
                                                part_no_                  => existing_serial_rec_.part_no,
                                                configuration_id_         => existing_serial_rec_.configuration_id,
                                                location_no_              => existing_serial_rec_.location_no,
                                                lot_batch_no_             => existing_serial_rec_.lot_batch_no,
                                                serial_no_                => existing_serial_rec_.serial_no,
                                                eng_chg_level_            => existing_serial_rec_.eng_chg_level,
                                                waiv_dev_rej_no_          => existing_serial_rec_.waiv_dev_rej_no,
                                                activity_seq_             => existing_serial_rec_.activity_seq,
                                                handling_unit_id_         => existing_serial_rec_.handling_unit_id,
                                                qty_difference_           => -1,
                                                catch_qty_difference_     => 0,
                                                unit_cost_                => unit_cost_,
                                                condition_code_           => NULL,
                                                note_text_                => note_text_for_count_out_,
                                                cost_detail_id_           => NULL,
                                                part_tracking_session_id_ => NULL,
                                                inv_list_no_              => '*',
                                                seq_no_                   => NULL);
      END IF;                                       
   END IF;
   
   qty_counted_       := lurec_.qty_onhand + qty_difference_;
   catch_qty_counted_ := NVL(lurec_.catch_qty_onhand, 0) + catch_qty_difference_;

   Validate_Count_Part(contract_,
                       part_no_,
                       configuration_id_,
                       location_no_,
                       lot_batch_no_,
                       serial_no_,
                       eng_chg_level_,
                       waiv_dev_rej_no_,
                       activity_seq_,
                       handling_unit_id_,
                       qty_counted_,
                       catch_qty_counted_,
                       qty_difference_,
                       part_tracking_session_id_,
                       ignore_serial_in_different_loc_ => FALSE);

   IF (part_tracking_session_id_ IS NOT NULL) THEN
      Temporary_Part_Tracking_API.Get_Serials_And_Remove_Session(serial_catch_tab_,part_tracking_session_id_);
   END IF;

   number_of_serials_ := serial_catch_tab_.COUNT;

   IF (number_of_serials_ = 0) THEN
      serial_catch_tab_(1).serial_no := serial_no_;
      number_of_serials_             := 1;
   END IF;

   local_qty_difference_       := qty_difference_       / number_of_serials_;
   local_catch_qty_difference_ := catch_qty_difference_ / number_of_serials_;

   Inventory_Event_Manager_API.Start_Session;
   FOR i IN serial_catch_tab_.FIRST..serial_catch_tab_.LAST LOOP
      Count_Part___(contract_             => contract_,
                    part_no_              => part_no_,
                    configuration_id_     => configuration_id_,
                    location_no_          => location_no_,
                    lot_batch_no_         => lot_batch_no_,
                    serial_no_            => serial_catch_tab_(i).serial_no,
                    eng_chg_level_        => eng_chg_level_,
                    waiv_dev_rej_no_      => waiv_dev_rej_no_,
                    activity_seq_         => activity_seq_,
                    handling_unit_id_     => handling_unit_id_,
                    qty_difference_       => local_qty_difference_,
                    catch_qty_difference_ => local_catch_qty_difference_,
                    unit_cost_            => unit_cost_,
                    condition_code_       => condition_code_,
                    note_text_            => note_text_,
                    cost_detail_id_       => cost_detail_id_, 
                    inv_list_no_          => inv_list_no_,
                    seq_no_               => seq_no_);
   END LOOP;
   Inventory_Event_Manager_API.Finish_Session;

   IF (cost_detail_id_ IS NOT NULL) THEN
      Temporary_Part_Cost_Detail_API.Remove_Details(cost_detail_id_);
   END IF;
   
   -- Update the important attributes from the existing stock record if serial exist in a different location.
   IF serial_exist_in_different_loc_ THEN          
      oldrec_ := Get_Object_By_Keys___(contract_,
                                       part_no_,
                                       configuration_id_,
                                       location_no_,
                                       lot_batch_no_,
                                       serial_no_,
                                       eng_chg_level_,
                                       waiv_dev_rej_no_,
                                       activity_seq_,
                                       handling_unit_id_);
      newrec_ := oldrec_;
      newrec_.expiration_date         := existing_expiration_date_;
      newrec_.receipt_date            := existing_receipt_date_;
      newrec_.availability_control_id := existing_availability_control_id_;
      newrec_.rotable_part_pool_id    := existing_rotable_part_pool_id_;
      newrec_.catch_qty_onhand        := existing_catch_qty_onhand_;
      newrec_.part_ownership          := existing_part_ownership_;
      newrec_.owning_customer_no      := existing_owning_customer_no_;
      newrec_.owning_vendor_no        := existing_owning_vendor_no_;
      Check_And_Update_By_Keys___(oldrec_ => oldrec_, newrec_ => newrec_);
   END IF; 
   
END Count_Part;


-- Make_Individuals
--   This method makes individuals of the specified quantity.
--   Breaks a instance of InventoryPartLocation into several instances.
PROCEDURE Make_Individuals (
   contract_                 IN VARCHAR2,
   part_no_                  IN VARCHAR2,
   configuration_id_         IN VARCHAR2,
   location_no_              IN VARCHAR2,
   lot_batch_no_             IN VARCHAR2,
   eng_chg_level_            IN VARCHAR2,
   waiv_dev_rej_no_          IN VARCHAR2,
   activity_seq_             IN NUMBER,
   handling_unit_id_         IN NUMBER, 
   order_no_                 IN VARCHAR2,
   line_no_                  IN VARCHAR2,
   release_no_               IN VARCHAR2,
   line_item_no_             IN NUMBER,
   order_type_               IN VARCHAR2,
   qty_                      IN NUMBER,
   serial_catch_tab_         IN Serial_Catch_Table ,
   operational_condition_db_ IN VARCHAR2 )
IS
   size_                     NUMBER := 0;
   transaction_id_           NUMBER;
   accounting_id_            NUMBER := 0;
   trans_value_              NUMBER := 0;
   price_                    NUMBER := 0;
   fromrec_                  INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   torec_                    INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   newrec_                   INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   issue_msg_                VARCHAR2(50);
   receive_msg_              VARCHAR2(25);
   in_transaction_           VARCHAR2(10);
   out_transaction_          VARCHAR2(10);
   company_                  VARCHAR2(20) := Site_API.Get_Company(contract_);
   new_record_               BOOLEAN;
   catch_quantity_           NUMBER;
   cost_detail_tab_          Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   part_catalog_rec_         Part_Catalog_API.Public_Rec;
   pur_receipt_serial_count_ NUMBER;
   sum_qty_received_         NUMBER;
   order_type_db_            VARCHAR2(50);
BEGIN

   part_catalog_rec_ := Part_Catalog_API.Get(part_no_);
   order_type_db_    := Order_Type_API.Encode(order_type_);
   fromrec_          := Get_Object_By_Keys___(contract_,
                                              part_no_,
                                              configuration_id_,
                                              location_no_,
                                              lot_batch_no_,
                                              '*',
                                              eng_chg_level_,
                                              waiv_dev_rej_no_,
                                              activity_seq_,
                                              handling_unit_id_);

   IF fromrec_.contract IS NULL THEN -- No record found!
      Error_SYS.Record_General(lu_name_, 'NORECORD: The record is not found in method Inventory_Part_In_Stock_API.Make_Individuals');
   END IF;

   IF (Stock_Location___(fromrec_.location_type)) THEN
      Error_SYS.Record_General('InventoryPartInStock', 'MKINDSTOCK: This operation is not allowed on location type :P1.', Inventory_Location_Type_API.Decode(fromrec_.location_type));
   END IF;

   in_transaction_  := 'SERIAL-IN';
   out_transaction_ := 'SERIAL-OUT';

   IF (serial_catch_tab_ IS NOT NULL) THEN
      size_ := serial_catch_tab_.COUNT;
   END IF;

   IF size_ != qty_ THEN
      Error_SYS.Record_General('InventoryPartInStock', 'MKINDSIZEQTY: The given quantity (:P1) and the number of serial no (:P2) is not equal', qty_, size_);
   END IF;

   IF fromrec_.qty_onhand - fromrec_.qty_reserved < qty_ THEN
      Error_SYS.Record_General('InventoryPartInStock', 'MKINDONHANDQTY: The specified quantity (:P1) is greater the available quantity (:P2)', qty_, fromrec_.qty_onhand - fromrec_.qty_reserved);
   END IF;

   IF (order_type_db_ = Order_Type_API.DB_PURCHASE_ORDER) THEN
      pur_receipt_serial_count_ := Inventory_Transaction_Hist_API.Get_Order_Receipt_Serial_Count(order_no_,
                                                                                                 line_no_,
                                                                                                 release_no_,
                                                                                                 line_item_no_,
                                                                                                 order_type_db_);

      sum_qty_received_ := Inventory_Transaction_Hist_API.Get_Sum_Qty_Received(source_ref1_        => order_no_,
                                                                               source_ref2_        => line_no_,
                                                                               source_ref3_        => release_no_,
                                                                               source_ref4_        => line_item_no_,
                                                                               source_ref_type_db_ => order_type_db_,
                                                                               contract_           => NULL,
                                                                               part_no_            => NULL,
                                                                               configuration_id_   => NULL,
                                                                               lot_batch_no_       => NULL);
      IF (pur_receipt_serial_count_ >= sum_qty_received_) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'ALLSERIALSIN: All :P1 serial numbers required for Purchase Receipt :P2 have already been defined.', pur_receipt_serial_count_, order_no_||' '||line_no_||' '||release_no_||' '||line_item_no_);
      END IF;

      IF (qty_ > (sum_qty_received_ - pur_receipt_serial_count_)) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'MORESERIALSIN: There are only :P1 serial numbers left to define for Purchase Receipt :P2.', (sum_qty_received_ - pur_receipt_serial_count_), order_no_||' '||line_no_||' '||release_no_||' '||line_item_no_);
      END IF;
   END IF;

   issue_msg_          := Language_SYS.Translate_Constant(lu_name_, 'MKINDSERIAL: Issue for making serial');
   Inventory_Event_Manager_API.Start_Session;

   --Get the total catch qty
   catch_quantity_ := 0;
   FOR index_ IN serial_catch_tab_.FIRST .. serial_catch_tab_.LAST LOOP
      catch_quantity_ := catch_quantity_ + serial_catch_tab_(index_).catch_qty;
   END LOOP;

   Issue_Part_Impl___(transaction_id_               =>  transaction_id_,
                      accounting_id_                =>  accounting_id_,
                      trans_value_                  =>  trans_value_,
                      catch_quantity_               =>  catch_quantity_,
                      contract_                     =>  fromrec_.contract,
                      part_no_                      =>  fromrec_.part_no,
                      configuration_id_             =>  fromrec_.configuration_id,
                      location_no_                  =>  fromrec_.location_no,
                      lot_batch_no_                 =>  fromrec_.lot_batch_no,
                      serial_no_                    =>  fromrec_.serial_no,
                      eng_chg_level_                =>  fromrec_.eng_chg_level,
                      waiv_dev_rej_no_              =>  fromrec_.waiv_dev_rej_no,
                      activity_seq_                 =>  fromrec_.activity_seq,
                      handling_unit_id_             =>  fromrec_.handling_unit_id,
                      transaction_                  =>  out_transaction_,
                      quantity_                     =>  qty_,
                      quantity_reserved_            =>  0,
                      source_ref1_                  =>  order_no_,
                      source_ref2_                  =>  line_no_,
                      source_ref3_                  =>  release_no_,
                      source_ref4_                  =>  line_item_no_,
                      source_ref5_                  =>  NULL,
                      source_                       =>  issue_msg_,
                      unreceive_                    =>  FALSE,
                      forced_                       =>  FALSE,
                      cost_detail_tab_              =>  cost_detail_tab_,
                      source_ref_type_              =>  order_type_,
                      reject_code_                  =>  NULL,
                      remove_unit_cost_             =>  TRUE,
                      make_transaction_             =>  TRUE,
                      transit_location_group_       =>  NULL,
                      report_earned_value_db_       =>  NULL,
                      part_catalog_rec_             =>  part_catalog_rec_,
                      original_transaction_id_      =>  NULL,
                      prevent_fifo_action_          =>  FALSE,
                      ownership_transfer_reason_id_ =>  NULL);

   Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                         company_,
                                                         'N',
                                                         NULL);

   price_ := trans_value_ / qty_;
   receive_msg_ := Language_SYS.Translate_Constant(lu_name_, 'RECEIVESERIAL: Receive serial');

   -- IF destination location is a consignment stock, or destination is a "not consignment
   -- inventory" location but isn't going to be consumed.

   IF (Inventory_Part_API.Get_Invent_Valuation_Method_Db(fromrec_.contract, fromrec_.part_no) IN ('AV', 'FIFO', 'LIFO')) THEN
      cost_detail_tab_ := Inventory_Transaction_Hist_API.Get_Transaction_Cost_Details(transaction_id_);   
   END IF;

   FOR index_ IN serial_catch_tab_.FIRST .. serial_catch_tab_.LAST LOOP

      IF (order_type_db_ = Order_Type_API.DB_PURCHASE_ORDER) THEN
         IF (Inventory_Transaction_Hist_API.Serial_Is_On_Purchase_Receipt(fromrec_.part_no,
                                                                          serial_catch_tab_(index_).serial_no,
                                                                          order_no_,
                                                                          line_no_,
                                                                          release_no_,
                                                                          line_item_no_)) THEN
            Error_SYS.Record_General('InventoryPartInStock', 'SERIALDEFINED: Serial :P1 has already been defined for Purchase Receipt :P2.', fromrec_.part_no||' '||serial_catch_tab_(index_).serial_no, order_no_||' '||line_no_||' '||release_no_||' '||line_item_no_);
         END IF;
      END IF;

      Inventory_Transaction_Hist_API.NEW(transaction_id_           => transaction_id_,
                                         accounting_id_            => accounting_id_,
                                         value_                    => price_,
                                         transaction_code_         => in_transaction_,
                                         contract_                 => fromrec_.contract,
                                         part_no_                  => fromrec_.part_no,
                                         configuration_id_         => fromrec_.configuration_id,
                                         location_no_              => fromrec_.location_no,
                                         lot_batch_no_             => fromrec_.lot_batch_no,
                                         serial_no_                => serial_catch_tab_(index_).serial_no,
                                         waiv_dev_rej_no_          => fromrec_.waiv_dev_rej_no,
                                         eng_chg_level_            => fromrec_.eng_chg_level,
                                         activity_seq_             => fromrec_.activity_seq,
                                         handling_unit_id_         => fromrec_.handling_unit_id,
                                         project_id_               => fromrec_.project_id,
                                         source_ref1_              => order_no_,
                                         source_ref2_              => line_no_,
                                         source_ref3_              => release_no_,
                                         source_ref4_              => line_item_no_,
                                         source_ref5_              => NULL,
                                         reject_code_              => NULL,
                                         cost_detail_tab_          => cost_detail_tab_,
                                         unit_cost_                => price_,
                                         quantity_                 => 1,
                                         qty_reversed_             => 0,
                                         catch_quantity_           => serial_catch_tab_(index_).catch_qty,
                                         source_                   => receive_msg_,
                                         source_ref_type_          => order_type_,
                                         owning_vendor_no_         => fromrec_.owning_vendor_no,
                                         condition_code_           => NULL,
                                         location_group_           => NULL,
                                         part_ownership_db_        => fromrec_.part_ownership,
                                         owning_customer_no_       => fromrec_.owning_customer_no,
                                         expiration_date_          => NULL,
                                         operational_condition_db_ => operational_condition_db_);

      Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                            company_,
                                                            'N',
                                                            NULL);

      IF Check_Exist(fromrec_.contract,
                     fromrec_.part_no,
                     fromrec_.configuration_id,
                     fromrec_.location_no,
                     fromrec_.lot_batch_no,
                     serial_catch_tab_(index_).serial_no,
                     fromrec_.eng_chg_level,
                     fromrec_.waiv_dev_rej_no,
                     fromrec_.activity_seq,
                     fromrec_.handling_unit_id) THEN

         torec_ := Lock_By_Keys___(fromrec_.contract,
                                   fromrec_.part_no,
                                   fromrec_.configuration_id,
                                   fromrec_.location_no,
                                   fromrec_.lot_batch_no,
                                   serial_catch_tab_(index_).serial_no,
                                   fromrec_.eng_chg_level,
                                   fromrec_.waiv_dev_rej_no,
                                   fromrec_.activity_seq,
                                   fromrec_.handling_unit_id);
         IF (torec_.qty_onhand     != 0 OR
             torec_.qty_reserved   != 0 OR
             torec_.qty_in_transit != 0) THEN
            Error_SYS.Record_General('InventoryPartInStock', 'SERIALNOTNEW: Part no :P1 serial no :P2 is already in store.',torec_.part_no, torec_.serial_no);
         END IF;
         new_record_ := FALSE;
         newrec_     := torec_;
      ELSE
         new_record_ := TRUE;
         newrec_     := NULL; -- For safety reasons...
      END IF;

      IF new_record_ = TRUE THEN
         newrec_.contract         := fromrec_.contract                  ;
         newrec_.part_no          := fromrec_.part_no                   ;
         newrec_.configuration_id := fromrec_.configuration_id          ;
         newrec_.location_no      := fromrec_.location_no               ;
         newrec_.lot_batch_no     := fromrec_.lot_batch_no              ;
         newrec_.serial_no        := serial_catch_tab_(index_).serial_no;
         newrec_.eng_chg_level    := fromrec_.eng_chg_level             ;
         newrec_.waiv_dev_rej_no  := fromrec_.waiv_dev_rej_no           ;
         newrec_.activity_seq     := fromrec_.activity_seq              ;
         newrec_.handling_unit_id := fromrec_.handling_unit_id          ;
      END IF;

      newrec_.qty_onhand              := 1                                  ;
      newrec_.catch_qty_onhand        := serial_catch_tab_(index_).catch_qty;
      newrec_.expiration_date         := fromrec_.expiration_date           ;
      newrec_.receipt_date            := fromrec_.receipt_date              ;
      newrec_.availability_control_id := fromrec_.availability_control_id   ;

      IF (fromrec_.part_ownership IS NOT NULL) THEN
         newrec_.part_ownership := fromrec_.part_ownership;
      END IF;

      IF (fromrec_.owning_vendor_no IS NOT NULL) THEN
         newrec_.owning_vendor_no := fromrec_.owning_vendor_no;
      END IF;

      IF (fromrec_.owning_customer_no IS NOT NULL) THEN
         newrec_.owning_customer_no := fromrec_.owning_customer_no;
      END IF;
      IF (transaction_id_ IS NOT NULL) THEN
         newrec_.latest_transaction_id := transaction_id_;
      END IF;
      
      IF new_record_ = TRUE THEN
         Check_And_Insert_By_Keys___(newrec_                       => newrec_,
                                     part_catalog_rec_             => part_catalog_rec_,
                                     set_default_avail_control_id_  => FALSE);
      ELSE
         Check_And_Update_By_Keys___(oldrec_                        => torec_,
                                     newrec_                        => newrec_,
                                     part_catalog_rec_              => part_catalog_rec_,
                                     set_default_avail_control_id_  => FALSE);
      END IF;
   END LOOP;
   Inventory_Event_Manager_API.Finish_Session;
END Make_Individuals;


-- Connect_To_Lot_Batch
--   This method connects the qty on a specified instance of InventoryPartLocation
--   to the specified lot batch number.
PROCEDURE Connect_To_Lot_Batch (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_no_      IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER,
   order_no_         IN VARCHAR2,
   line_no_          IN VARCHAR2,
   release_no_       IN VARCHAR2,
   line_item_no_     IN NUMBER,
   order_type_       IN VARCHAR2,
   to_lot_batch_no_  IN VARCHAR2,
   quantity_         IN NUMBER,
   catch_quantity_   IN NUMBER )
IS
   lot_batch_no_     INVENTORY_PART_IN_STOCK_TAB.lot_batch_no%TYPE;
   qty_available_    INVENTORY_PART_IN_STOCK_TAB.qty_onhand%TYPE;
   location_type_db_ INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   expiration_date_  INVENTORY_PART_IN_STOCK_TAB.expiration_date%TYPE;
   catch_qty_        NUMBER;

   CURSOR get_attr IS
      SELECT (qty_onhand - qty_reserved) qty_available, location_type, expiration_date
      FROM   INVENTORY_PART_IN_STOCK_TAB
      WHERE  contract         = contract_
      AND    part_no          = part_no_
      AND    configuration_id = configuration_id_
      AND    location_no      = location_no_
      AND    lot_batch_no     = lot_batch_no_
      AND    serial_no        = serial_no_
      AND    eng_chg_level    = eng_chg_level_
      AND    waiv_dev_rej_no  = waiv_dev_rej_no_
      AND    activity_seq     = activity_seq_
      AND    handling_unit_id = handling_unit_id_;
BEGIN

   -- Set old lot_batch_no_. Always '*' since you only allowed to change those.
   lot_batch_no_ := '*';
   catch_qty_    := catch_quantity_;

   IF to_lot_batch_no_ IS NULL THEN
      Error_SYS.Record_General('InventoryPartInStock','LBNNONULL: Lot Batch No must have a value.');
   END IF;

   OPEN  get_attr;
   FETCH get_attr INTO qty_available_, location_type_db_, expiration_date_;
   IF (get_attr%NOTFOUND) THEN
      Error_SYS.Record_Not_Exist(lu_name_);
   END IF;
   CLOSE get_attr;

   IF (quantity_ > qty_available_) THEN
      Error_SYS.Record_General ('InventoryPartInStock','GREATQTY: The specified quantity to change is greater than the available quantity.');
   END IF;

   IF (to_lot_batch_no_ != lot_batch_no_) THEN
      Move_Part_Impl___(catch_quantity_                => catch_qty_,
                        contract_                      => contract_,
                        part_no_                       => part_no_,
                        configuration_id_              => configuration_id_,
                        location_no_                   => location_no_,
                        lot_batch_no_                  => lot_batch_no_,
                        serial_no_                     => serial_no_,
                        eng_chg_level_                 => eng_chg_level_,
                        waiv_dev_rej_no_               => waiv_dev_rej_no_,
                        activity_seq_                  => activity_seq_,
                        handling_unit_id_              => handling_unit_id_,
                        expiration_date_               => expiration_date_,
                        to_contract_                   => contract_,
                        to_part_no_                    => part_no_,
                        to_location_no_                => location_no_,
                        to_destination_db_             => 'N',
                        to_waiv_dev_rej_no_            => waiv_dev_rej_no_,
                        to_lot_batch_no_               => to_lot_batch_no_,
                        to_serial_no_                  => serial_no_,
                        to_activity_seq_               => activity_seq_,
                        to_handling_unit_id_           => handling_unit_id_,
                        quantity_                      => quantity_,
                        quantity_reserved_             => 0,
                        move_comment_                  => NULL,
                        order_no_                      => order_no_,
                        line_no_                       => line_no_,
                        release_no_                    => release_no_,
                        line_item_no_                  => line_item_no_,
                        source_ref5_                   => NULL,
                        order_type_                    => order_type_,
                        consume_consignment_stock_     => FALSE,
                        make_transaction_and_postings_ => TRUE,
                        report_earned_value_db_        => NULL,
                        from_part_catalog_rec_         => NULL,
                        to_part_catalog_rec_           => NULL,
                        transport_task_id_             => NULL,
                        validate_hu_struct_position_   => FALSE,
                        availability_ctrl_id_          => NULL,
                        always_preserve_serial_no_     => FALSE,
                        ownership_transfer_reason_id_  => NULL);
   END IF;
END Connect_To_Lot_Batch;


-- Handle_Serial_Condition_Change
--   This public method must only be used from InventConditionCodeUtil in
--   Invent when the condition code has been changed on a PartSerialCatalog record.
--   The methods updates Availability Control Id when changing condition code.
PROCEDURE Handle_Serial_Condition_Change (
   part_no_            IN VARCHAR2,
   serial_no_          IN VARCHAR2,
   new_condition_code_ IN VARCHAR2 )
IS
   new_avail_control_id_ INVENTORY_PART_IN_STOCK_TAB.availability_control_id%TYPE;

   CURSOR get_records (part_no_   IN VARCHAR2,
                       serial_no_ IN VARCHAR2) IS
      SELECT contract,
             configuration_id,
             location_no,
             lot_batch_no,
             eng_chg_level,
             waiv_dev_rej_no,
             activity_seq,
             handling_unit_id
      FROM  INVENTORY_PART_IN_STOCK_TAB
      WHERE part_no   = part_no_
        AND serial_no = serial_no_
        AND (qty_onhand != 0 OR qty_in_transit != 0)
      FOR UPDATE;
BEGIN

   new_avail_control_id_ := Condition_Code_API.Get_Default_Avail_Control_Id(new_condition_code_);

   FOR rec_ IN get_records(part_no_, serial_no_) LOOP
      Modify_Availability_Control_Id(rec_.contract,
                                  part_no_,
                                  rec_.configuration_id,
                                  rec_.location_no,
                                  rec_.lot_batch_no,
                                  serial_no_,
                                  rec_.eng_chg_level,
                                  rec_.waiv_dev_rej_no,
                                  rec_.activity_seq,
                                  rec_.handling_unit_id,
                                  new_avail_control_id_);
   END LOOP;
END Handle_Serial_Condition_Change;


-- Get_Latest_Receipt_Location
--   Returns a location number for the specified location type.
--   The location number will be the location where the last receipt was done.
--   If location type is NULL then the location number will be selected
--   without any concern of the location type.
--   If there is no location number found then NULL is returned.
@UncheckedAccess
FUNCTION Get_Latest_Receipt_Location (
   contract_          IN VARCHAR2,
   part_no_           IN VARCHAR2,
   configuration_id_  IN VARCHAR2,
   location_type1_db_ IN VARCHAR2,
   location_type2_db_ IN VARCHAR2 DEFAULT NULL,
   location_type3_db_ IN VARCHAR2 DEFAULT NULL,
   location_type4_db_ IN VARCHAR2 DEFAULT NULL,
   warehouse_id_      IN VARCHAR2 DEFAULT NULL ) RETURN VARCHAR2
IS
   location_no_         INVENTORY_PART_IN_STOCK_TAB.location_no%TYPE := NULL;
   receipts_blocked_db_ VARCHAR2(20);

   CURSOR get_latest_receipt_location IS
      SELECT location_no, warehouse, bay_no, row_no, tier_no, bin_no
      FROM INVENTORY_PART_IN_STOCK_TAB
      WHERE part_no           = part_no_
      AND   contract          = contract_
      AND  (configuration_id  = configuration_id_ OR configuration_id_ IS NULL)
      AND  (warehouse         = warehouse_id_ OR warehouse_id_ IS NULL)
      AND   freeze_flag       = 'N'
      AND  (   (location_type = location_type1_db_)
            OR (location_type = NVL(location_type2_db_, location_type1_db_))
            OR (location_type = NVL(location_type3_db_, location_type1_db_))
            OR (location_type = NVL(location_type4_db_, location_type1_db_)))
      ORDER BY receipt_date DESC;
BEGIN
   FOR receipt_rec_ IN get_latest_receipt_location LOOP
      receipts_blocked_db_ := Warehouse_Bay_Bin_API.Get_Receipts_Blocked_Db(contract_,
                                                                            receipt_rec_.warehouse,
                                                                            receipt_rec_.bay_no,
                                                                            receipt_rec_.tier_no,
                                                                            receipt_rec_.row_no,
                                                                            receipt_rec_.bin_no);
      IF (receipts_blocked_db_ = db_false_) THEN
         IF (NOT (warehouse_id_ IS NULL AND (Warehouse_API.Is_Remote(contract_, receipt_rec_.warehouse) = 'TRUE'))) THEN
            location_no_ := receipt_rec_.location_no;
            EXIT;
         END IF;   
      END IF;
   END LOOP;

   RETURN location_no_;
END Get_Latest_Receipt_Location;


-- Get_Aggregate_Qty_Onhand
--   Returns the sum of qty_onhand for a part available at all locations.
@UncheckedAccess
FUNCTION Get_Aggregate_Qty_Onhand (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2 DEFAULT NULL,
   serial_no_        IN VARCHAR2 DEFAULT NULL ) RETURN NUMBER
IS
   qty_onhand_  NUMBER;

   CURSOR get_qty IS
    SELECT SUM(qty_onhand)
    FROM   INVENTORY_PART_IN_STOCK_TAB
    WHERE contract         = contract_
    AND   part_no          = part_no_
    AND  (configuration_id = configuration_id_ OR configuration_id_ IS NULL)
    AND  (lot_batch_no     = lot_batch_no_     OR lot_batch_no_     IS NULL)
    AND  (serial_no        = serial_no_        OR serial_no_        IS NULL);
BEGIN
   OPEN get_qty;
   FETCH get_qty INTO qty_onhand_;
   CLOSE get_qty;
   RETURN NVL(qty_onhand_, 0);
END Get_Aggregate_Qty_Onhand;


-- Get_Inventory_Qty_Onhand
--   Returns the sum of qty_onhand for a part available at the location types
--   Picking,Floor Stock, Shipment, Manufacturing.
@UncheckedAccess
FUNCTION Get_Inventory_Qty_Onhand (
   contract_               IN VARCHAR2,
   part_no_                IN VARCHAR2,
   configuration_id_       IN VARCHAR2,
   unit_of_measure_type_   IN VARCHAR2 DEFAULT 'INVENTORY' ) RETURN NUMBER 
IS
BEGIN
   RETURN Get_Inventory_Quantity(contract_             => contract_,
                                 part_no_              => part_no_,
                                 configuration_id_     => configuration_id_,
                                 qty_type_             => 'ONHAND',
                                 ownership_type1_db_   => Part_Ownership_API.DB_COMPANY_OWNED,
                                 ownership_type2_db_   => Part_Ownership_API.DB_CONSIGNMENT,
                                 ownership_type3_db_   => Part_Ownership_API.DB_SUPPLIER_LOANED,
                                 ownership_type4_db_   => Part_Ownership_API.DB_CUSTOMER_OWNED,
                                 ownership_type5_db_   => Part_Ownership_API.DB_SUPPLIER_RENTED,
                                 ownership_type6_db_   => Part_Ownership_API.DB_COMPANY_RENTAL_ASSET,
                                 location_type1_db_    => Inventory_Location_Type_API.DB_PICKING,
                                 location_type2_db_    => Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                 location_type3_db_    => Inventory_Location_Type_API.DB_SHIPMENT,
                                 location_type4_db_    => Inventory_Location_Type_API.DB_PRODUCTION_LINE,
                                 unit_of_measure_type_ => unit_of_measure_type_);
END Get_Inventory_Qty_Onhand;


-- Get_Inventory_Qty_Reserved
--   Returns the sum of qty_reserved for a part for the location types Picking,
--   Floor Stock, Shipment, Manufacturing.
@UncheckedAccess
FUNCTION Get_Inventory_Qty_Reserved (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2 ) RETURN NUMBER
IS
BEGIN
   RETURN Get_Inventory_Quantity(contract_             => contract_,
                                 part_no_              => part_no_,
                                 configuration_id_     => configuration_id_,
                                 qty_type_             => 'RESERVED',
                                 ownership_type1_db_   => Part_Ownership_API.DB_COMPANY_OWNED,
                                 ownership_type2_db_   => Part_Ownership_API.DB_CONSIGNMENT,
                                 ownership_type3_db_   => Part_Ownership_API.DB_SUPPLIER_LOANED,
                                 ownership_type4_db_   => Part_Ownership_API.DB_CUSTOMER_OWNED,
                                 ownership_type5_db_   => Part_Ownership_API.DB_SUPPLIER_RENTED,
                                 ownership_type6_db_   => Part_Ownership_API.DB_COMPANY_RENTAL_ASSET,
                                 location_type1_db_    => Inventory_Location_Type_API.DB_PICKING,
                                 location_type2_db_    => Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                 location_type3_db_    => Inventory_Location_Type_API.DB_SHIPMENT,
                                 location_type4_db_    => Inventory_Location_Type_API.DB_PRODUCTION_LINE);
END Get_Inventory_Qty_Reserved;


-- Get_Qty_At_Dock
--   Returns the qty at dock for a part.
@UncheckedAccess
FUNCTION Get_Qty_At_Dock (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2 ) RETURN NUMBER
IS
   qty_at_dock_ NUMBER;

   CURSOR get_qty IS
      SELECT SUM(qty_onhand)
      FROM   INVENTORY_PART_IN_STOCK_TAB
      WHERE  part_no = part_no_
      AND    contract = contract_
      AND   (configuration_id = configuration_id_ OR configuration_id_ IS NULL)
      AND   location_type = Inventory_Location_Type_API.DB_ARRIVAL;
BEGIN
   OPEN get_qty;
   FETCH get_qty INTO qty_at_dock_;
   CLOSE get_qty;
   RETURN Nvl(qty_at_dock_,0);
END Get_Qty_At_Dock;


-- Get_Qty_In_Quality_Control
--   Returns the qty_in_qc for a part at a particular site.
@UncheckedAccess
FUNCTION Get_Qty_In_Quality_Control (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   project_id_       IN VARCHAR2 ) RETURN NUMBER
IS
   qty_in_qc_ NUMBER;

   CURSOR get_qty IS
      SELECT SUM(qty_onhand)
      FROM   INVENTORY_PART_IN_STOCK_TAB
      WHERE  part_no  = part_no_
      AND    contract = contract_
      AND   (configuration_id = configuration_id_ OR configuration_id_ IS NULL)
      AND   (project_id       = project_id_       OR project_id_       IS NULL)
      AND   location_type = Inventory_Location_Type_API.DB_QUALITY_ASSURANCE;
BEGIN
   OPEN get_qty;
   FETCH get_qty INTO qty_in_qc_;
   CLOSE get_qty;
   RETURN Nvl(qty_in_qc_,0);
END Get_Qty_In_Quality_Control;


-- Get_Sum_Qty_Plannable
--   This function will summarize all the qty_onhand for a specific
--   part_no and contract. Which location and types that will be added
--   depends on which arguments that are NULL.
@UncheckedAccess
FUNCTION Get_Sum_Qty_Plannable (
   location_no_      IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_type_    IN VARCHAR2 ) RETURN NUMBER
IS
   location_type_db_ INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   include_standard_ VARCHAR2(10);
   include_project_  VARCHAR2(10);

BEGIN
   IF activity_seq_ IS NULL THEN
      include_standard_ := db_true_;
      include_project_  := db_true_;
   ELSIF activity_seq_ = 0 THEN
      include_standard_ := db_true_;
      include_project_  := db_false_;
   ELSE
      include_standard_ := db_false_;
      include_project_  := db_true_;
   END IF;

   IF location_type_ IS NOT NULL THEN
      location_type_db_ := Inventory_Location_Type_API.Encode(location_type_);
      IF location_type_db_ IN (Inventory_Location_Type_API.DB_PICKING,
                               Inventory_Location_Type_API.DB_FLOOR_STOCK,
                               Inventory_Location_Type_API.DB_PRODUCTION_LINE) THEN
         RETURN Get_Inventory_Quantity(contract_             => contract_,
                                       part_no_              => part_no_,
                                       configuration_id_     => configuration_id_,
                                       qty_type_             => 'AVAILABLE',
                                       expiration_control_   => 'NOT EXPIRED',
                                       supply_control_db_    => 'NETTABLE',
                                       ownership_type1_db_   => Part_Ownership_API.DB_COMPANY_OWNED,
                                       ownership_type2_db_   => Part_Ownership_API.DB_CONSIGNMENT,
                                       ownership_type3_db_   => Part_Ownership_API.DB_SUPPLIER_LOANED,
                                       ownership_type4_db_   => Part_Ownership_API.DB_CUSTOMER_OWNED,
                                       location_type1_db_    => location_type_db_,
                                       lot_batch_no_         => lot_batch_no_,
                                       serial_no_            => serial_no_,
                                       eng_chg_level_        => eng_chg_level_,
                                       waiv_dev_rej_no_      => waiv_dev_rej_no_,
                                       include_standard_     => include_standard_,
                                       include_project_      => include_project_,
                                       activity_seq_         => activity_seq_,
                                       location_no_          => location_no_);
      ELSE
         RETURN 0;
      END IF;
   ELSE
      RETURN Get_Inventory_Quantity(contract_             => contract_,
                                    part_no_              => part_no_,
                                    configuration_id_     => configuration_id_,
                                    qty_type_             => 'AVAILABLE',
                                    expiration_control_   => 'NOT EXPIRED',
                                    supply_control_db_    => 'NETTABLE',
                                    ownership_type1_db_   => Part_Ownership_API.DB_COMPANY_OWNED,
                                    ownership_type2_db_   => Part_Ownership_API.DB_CONSIGNMENT,
                                    ownership_type3_db_   => Part_Ownership_API.DB_SUPPLIER_LOANED,
                                    ownership_type4_db_   => Part_Ownership_API.DB_CUSTOMER_OWNED,
                                    location_type1_db_    => Inventory_Location_Type_API.DB_PICKING,
                                    location_type2_db_    => Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                    location_type3_db_    => Inventory_Location_Type_API.DB_PRODUCTION_LINE,
                                    lot_batch_no_         => lot_batch_no_,
                                    serial_no_            => serial_no_,
                                    eng_chg_level_        => eng_chg_level_,
                                    waiv_dev_rej_no_      => waiv_dev_rej_no_,
                                    include_standard_     => include_standard_,
                                    include_project_      => include_project_,
                                    activity_seq_         => activity_seq_,
                                    location_no_          => location_no_);
   END IF;
END Get_Sum_Qty_Plannable;


-- Get_Avail_Plan_Qty_Loc_Type
--   Returns the sum of valid, plannable qty_onhand for a part for one or
--   several location types. The location types are DB-values!
@UncheckedAccess
FUNCTION Get_Avail_Plan_Qty_Loc_Type (
   contract_                    IN VARCHAR2,
   part_no_                     IN VARCHAR2,
   configuration_id_            IN VARCHAR2,       
   activity_seq_                IN NUMBER,         
   qty_type_                    IN VARCHAR2,       
   date_requested_              IN DATE,           
   location_type1_db_           IN VARCHAR2,
   location_type2_db_           IN VARCHAR2 DEFAULT NULL,
   location_type3_db_           IN VARCHAR2 DEFAULT NULL,
   location_type4_db_           IN VARCHAR2 DEFAULT NULL,
   add_min_durab_days_planning_ IN BOOLEAN DEFAULT TRUE ) RETURN NUMBER
IS
   loc_type1_db_ VARCHAR2(200);
   loc_type2_db_ VARCHAR2(200);
   loc_type3_db_ VARCHAR2(200);
   loc_type4_db_ VARCHAR2(200);

   qty_onhand_     NUMBER;
   qty_reserved_   NUMBER;
   date_req_       DATE;
   qty_in_transit_ NUMBER;

   CURSOR get_qty IS
      SELECT NVL(SUM(qty_onhand),0), NVL(SUM(qty_reserved),0), NVL(SUM(qty_in_transit),0)
      FROM INVENTORY_PART_IN_STOCK_AVAIL
      WHERE part_supply_control_db = 'NETTABLE'
      AND   NVL(expiration_date, (date_req_ + 1)) > date_req_
      AND   (location_type_db = loc_type1_db_
             OR location_type_db = loc_type2_db_
             OR location_type_db = loc_type3_db_
             OR location_type_db = loc_type4_db_)
      AND   location_type_db IN (Inventory_Location_Type_API.DB_PICKING,
                                 Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                 Inventory_Location_Type_API.DB_PRODUCTION_LINE,
                                 Inventory_Location_Type_API.DB_SHIPMENT)
      AND  (configuration_id = configuration_id_ OR configuration_id_ IS NULL)
      AND  (activity_seq     = activity_seq_     OR activity_seq_ IS NULL)
      AND   part_ownership_db IN ('COMPANY OWNED', 'CONSIGNMENT')
      AND   contract = contract_
      AND   part_no = part_no_;
BEGIN
   -- To avoid using parameters that are not stated. The first one have to be stated.
   loc_type1_db_ := location_type1_db_;
   loc_type2_db_ := NVL(location_type2_db_, location_type1_db_);
   loc_type3_db_ := NVL(location_type3_db_, location_type1_db_);
   loc_type4_db_ := NVL(location_type4_db_, location_type1_db_);

   date_req_ := TRUNC(NVL(date_requested_,Site_API.Get_Site_Date(contract_)));
   IF add_min_durab_days_planning_ THEN
      date_req_ := date_req_ + Inventory_Part_API.Get_Min_Durab_Days_Planning(contract_, part_no_);
   END IF;

   OPEN get_qty;
   FETCH get_qty INTO qty_onhand_, qty_reserved_, qty_in_transit_;
   CLOSE get_qty;

   IF    (qty_type_ = 'ONHAND')    THEN
      RETURN (qty_onhand_ + qty_in_transit_);
   ELSIF (qty_type_ = 'RESERVED')  THEN
      RETURN (qty_reserved_);
   ELSIF (qty_type_ = 'AVAILABLE') THEN
      RETURN (qty_onhand_ - qty_reserved_+ qty_in_transit_);
   ELSE
      RETURN (-9999999999); -- To indicate illegal value of inparameter qty_type_.
   END IF;
END Get_Avail_Plan_Qty_Loc_Type;


-- Find_Part
--   Find a location with a quantity available.
PROCEDURE Find_Part (
   qty_available_           OUT    NUMBER,
   location_no_             IN OUT VARCHAR2,
   lot_batch_no_            IN OUT VARCHAR2,
   serial_no_               IN OUT VARCHAR2,
   eng_chg_level_           IN OUT VARCHAR2,
   waiv_dev_rej_no_         IN OUT VARCHAR2,
   configuration_id_        IN OUT VARCHAR2,
   activity_seq_            IN OUT NUMBER,
   handling_unit_id_        IN OUT NUMBER,
   contract_                IN     VARCHAR2,
   part_no_                 IN     VARCHAR2,
   location_type_           IN     VARCHAR2,
   auto_reservation_        IN     VARCHAR2,
   order_issue_             IN     VARCHAR2,
   project_id_              IN     VARCHAR2,
   condition_code_          IN     VARCHAR2 DEFAULT NULL,
   part_ownership_          IN     VARCHAR2 DEFAULT 'COMPANY OWNED',
   owning_vendor_no_        IN     VARCHAR2 DEFAULT NULL,
   owning_customer_no_      IN     VARCHAR2 DEFAULT NULL,
   expiration_control_date_ IN     DATE     DEFAULT NULL )
IS
   keys_and_qty_tab_    Keys_And_Qty_Tab;
   auto_reservation_db_ VARCHAR2(50);
   order_issue_db_      VARCHAR2(50);
   location_type_db_    INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   dummy_boolean_       BOOLEAN;
BEGIN

   location_type_db_    := Inventory_Location_Type_API.Encode(location_type_);
   auto_reservation_db_ := Part_Reservation_Control_API.Encode(auto_reservation_);
   order_issue_db_      := Part_Order_Issue_Control_API.Encode(order_issue_);

   keys_and_qty_tab_ := Find_Part___(available_record_was_skipped_  => dummy_boolean_,
                                     location_no_                   => location_no_,
                                     lot_batch_no_                  => lot_batch_no_,
                                     serial_no_                     => serial_no_,
                                     eng_chg_level_                 => eng_chg_level_,
                                     waiv_dev_rej_no_               => waiv_dev_rej_no_,
                                     configuration_id_              => configuration_id_,
                                     activity_seq_                  => activity_seq_,
                                     handling_unit_id_              => handling_unit_id_,
                                     contract_                      => contract_,
                                     part_no_                       => part_no_,
                                     location_type_db_              => location_type_db_,
                                     auto_reservation_db_           => auto_reservation_db_,
                                     order_issue_db_                => order_issue_db_,
                                     project_id_                    => project_id_,
                                     condition_code_                => condition_code_,
                                     part_ownership_db_             => part_ownership_,
                                     owning_vendor_no_              => owning_vendor_no_,
                                     owning_customer_no_            => owning_customer_no_,
                                     only_one_lot_allowed_          => FALSE,
                                     many_records_allowed_          => FALSE,
                                     qty_to_find_                   => NULL,
                                     expiration_control_date_       => expiration_control_date_,
                                     include_temp_table_locs_       => TRUE,
                                     warehouse_id_                  => NULL,
                                     ignore_this_avail_control_id_  => NULL,
                                     consume_partial_handling_unit_ => TRUE,
                                     part_movement_control_db_      => NULL,
                                     location_group_                => NULL);

   IF (keys_and_qty_tab_.COUNT > 0) THEN
      qty_available_    := keys_and_qty_tab_(1).quantity;
      location_no_      := keys_and_qty_tab_(1).location_no;
      lot_batch_no_     := keys_and_qty_tab_(1).lot_batch_no;
      serial_no_        := keys_and_qty_tab_(1).serial_no;
      eng_chg_level_    := keys_and_qty_tab_(1).eng_chg_level;
      waiv_dev_rej_no_  := keys_and_qty_tab_(1).waiv_dev_rej_no;
      configuration_id_ := keys_and_qty_tab_(1).configuration_id;
      activity_seq_     := keys_and_qty_tab_(1).activity_seq;
      handling_unit_id_ := keys_and_qty_tab_(1).handling_unit_id;
   ELSE
      qty_available_    := 0;
      location_no_      := NULL;
      lot_batch_no_     := NULL;
      serial_no_        := NULL;
      eng_chg_level_    := NULL;
      waiv_dev_rej_no_  := NULL;
      configuration_id_ := NULL;
      activity_seq_     := NULL;
      handling_unit_id_ := NULL;
   END IF;
END Find_Part;


-- Get_Inventory_Quantity
--   Very flexible function to get quantities in inventory.
--   Possible combinations: Configuration, Onhand/Reserved/Available quantities,
--   Expiration, Ownership, Inventory locations, Availability controls.
--   Very flexible function to get quantities in inventory.
--   Possible combinations: Configuration, Onhand/Reserved/Available quantities, Expiration, Ownership, Inventory locations, Availability controls.
--   catch qty if set to 'CATCH'.
@UncheckedAccess
FUNCTION Get_Inventory_Quantity (
   contract_                     IN VARCHAR2,
   part_no_                      IN VARCHAR2,
   configuration_id_             IN VARCHAR2,
   qty_type_                     IN VARCHAR2,
   expiration_control_           IN VARCHAR2 DEFAULT NULL,
   supply_control_db_            IN VARCHAR2 DEFAULT NULL,
   ownership_type1_db_           IN VARCHAR2 DEFAULT NULL,
   ownership_type2_db_           IN VARCHAR2 DEFAULT NULL,
   ownership_type3_db_           IN VARCHAR2 DEFAULT NULL,
   ownership_type4_db_           IN VARCHAR2 DEFAULT NULL,
   ownership_type5_db_           IN VARCHAR2 DEFAULT NULL,
   ownership_type6_db_           IN VARCHAR2 DEFAULT NULL,
   owning_customer_no_           IN VARCHAR2 DEFAULT NULL,
   owning_vendor_no_             IN VARCHAR2 DEFAULT NULL,
   location_type1_db_            IN VARCHAR2 DEFAULT NULL,
   location_type2_db_            IN VARCHAR2 DEFAULT NULL,
   location_type3_db_            IN VARCHAR2 DEFAULT NULL,
   location_type4_db_            IN VARCHAR2 DEFAULT NULL,
   lot_batch_no_                 IN VARCHAR2 DEFAULT NULL,
   serial_no_                    IN VARCHAR2 DEFAULT NULL,
   eng_chg_level_                IN VARCHAR2 DEFAULT NULL,
   waiv_dev_rej_no_              IN VARCHAR2 DEFAULT NULL,
   include_standard_             IN VARCHAR2 DEFAULT 'TRUE',   
   include_project_              IN VARCHAR2 DEFAULT 'TRUE',   
   activity_seq_                 IN NUMBER DEFAULT NULL,
   project_id_                   IN VARCHAR2 DEFAULT NULL,
   location_no_                  IN VARCHAR2 DEFAULT NULL,
   order_issue_control_db_       IN VARCHAR2 DEFAULT NULL,
   automat_reserv_ctrl_db_       IN VARCHAR2 DEFAULT NULL,
   manual_reserv_ctrl_db_        IN VARCHAR2 DEFAULT NULL,
   condition_code_               IN VARCHAR2 DEFAULT NULL,
   unit_of_measure_type_         IN VARCHAR2 DEFAULT 'INVENTORY',
   expiration_control_date_      IN DATE DEFAULT NULL,
   warehouse_id_                 IN VARCHAR2 DEFAULT NULL,
   ignore_this_avail_control_id_ IN VARCHAR2 DEFAULT NULL,
   handling_unit_id_             IN NUMBER   DEFAULT NULL ) RETURN NUMBER
IS
   qty_onhand_     NUMBER;
   qty_reserved_   NUMBER;
   qty_in_transit_ NUMBER;
BEGIN
   Get_Inventory_Quantity(qty_onhand_                   => qty_onhand_                  ,
                          qty_reserved_                 => qty_reserved_                ,
                          qty_in_transit_               => qty_in_transit_              ,
                          contract_                     => contract_                    ,
                          part_no_                      => part_no_                     ,
                          configuration_id_             => configuration_id_            ,
                          expiration_control_           => expiration_control_          ,
                          supply_control_db_            => supply_control_db_           ,
                          ownership_type1_db_           => ownership_type1_db_          ,
                          ownership_type2_db_           => ownership_type2_db_          ,
                          ownership_type3_db_           => ownership_type3_db_          ,
                          ownership_type4_db_           => ownership_type4_db_          ,
                          ownership_type5_db_           => ownership_type5_db_          ,
                          ownership_type6_db_           => ownership_type6_db_          ,
                          owning_customer_no_           => owning_customer_no_          ,
                          owning_vendor_no_             => owning_vendor_no_            ,
                          location_type1_db_            => location_type1_db_           ,
                          location_type2_db_            => location_type2_db_           ,
                          location_type3_db_            => location_type3_db_           ,
                          location_type4_db_            => location_type4_db_           ,
                          lot_batch_no_                 => lot_batch_no_                ,
                          serial_no_                    => serial_no_                   ,
                          eng_chg_level_                => eng_chg_level_               ,
                          waiv_dev_rej_no_              => waiv_dev_rej_no_             ,
                          include_standard_             => include_standard_            ,
                          include_project_              => include_project_             ,
                          activity_seq_                 => activity_seq_                ,
                          project_id_                   => project_id_                  ,
                          location_no_                  => location_no_                 ,
                          order_issue_control_db_       => order_issue_control_db_      ,
                          automat_reserv_ctrl_db_       => automat_reserv_ctrl_db_      ,
                          manual_reserv_ctrl_db_        => manual_reserv_ctrl_db_       ,
                          condition_code_               => condition_code_              ,
                          unit_of_measure_type_         => unit_of_measure_type_        ,
                          expiration_control_date_      => expiration_control_date_     ,
                          warehouse_id_                 => warehouse_id_                ,
                          ignore_this_avail_control_id_ => ignore_this_avail_control_id_,
                          handling_unit_id_             => handling_unit_id_            );

   IF    (qty_type_ = 'ONHAND')    THEN
      RETURN (NVL(qty_onhand_,0));
   ELSIF (qty_type_ = 'RESERVED')  THEN
      RETURN (NVL(qty_reserved_,0));
   ELSIF (qty_type_ = 'AVAILABLE') THEN
      RETURN (NVL(qty_onhand_ - qty_reserved_,0));
   ELSIF (qty_type_ = 'TRANSIT') THEN
      RETURN (NVL(qty_in_transit_,0));
   ELSIF (qty_type_ = 'AVAILTRANSIT') THEN
      RETURN (NVL(qty_onhand_ - qty_reserved_ + qty_in_transit_,0));
   ELSIF (qty_type_ = 'ONHAND_PLUS_TRANSIT') THEN
      RETURN (NVL(qty_onhand_,0) + NVL(qty_in_transit_,0));
   ELSE
      RETURN (-9999999999); -- To indicate illegal value of inparameter qty_type_.
   END IF;
END Get_Inventory_Quantity;


-- Get_Inventory_Quantity
--   Very flexible function to get quantities in inventory.
--   Possible combinations: Configuration, Onhand/Reserved/Available quantities,
--   Expiration, Ownership, Inventory locations, Availability controls.
--   Very flexible function to get quantities in inventory.
--   Possible combinations: Configuration, Onhand/Reserved/Available quantities, Expiration, Ownership, Inventory locations, Availability controls.
--   catch qty if set to 'CATCH'.
@UncheckedAccess
PROCEDURE Get_Inventory_Quantity (
   qty_onhand_                   OUT NUMBER,
   qty_reserved_                 OUT NUMBER,
   qty_in_transit_               OUT NUMBER,
   contract_                     IN  VARCHAR2,
   part_no_                      IN  VARCHAR2,
   configuration_id_             IN  VARCHAR2,
   expiration_control_           IN  VARCHAR2 DEFAULT NULL,
   supply_control_db_            IN  VARCHAR2 DEFAULT NULL,
   ownership_type1_db_           IN  VARCHAR2 DEFAULT NULL,
   ownership_type2_db_           IN  VARCHAR2 DEFAULT NULL,
   ownership_type3_db_           IN  VARCHAR2 DEFAULT NULL,
   ownership_type4_db_           IN  VARCHAR2 DEFAULT NULL,
   ownership_type5_db_           IN  VARCHAR2 DEFAULT NULL,
   ownership_type6_db_           IN  VARCHAR2 DEFAULT NULL,
   owning_customer_no_           IN  VARCHAR2 DEFAULT NULL,
   owning_vendor_no_             IN  VARCHAR2 DEFAULT NULL,
   location_type1_db_            IN  VARCHAR2 DEFAULT NULL,
   location_type2_db_            IN  VARCHAR2 DEFAULT NULL,
   location_type3_db_            IN  VARCHAR2 DEFAULT NULL,
   location_type4_db_            IN  VARCHAR2 DEFAULT NULL,
   lot_batch_no_                 IN  VARCHAR2 DEFAULT NULL,
   serial_no_                    IN  VARCHAR2 DEFAULT NULL,
   eng_chg_level_                IN  VARCHAR2 DEFAULT NULL,
   waiv_dev_rej_no_              IN  VARCHAR2 DEFAULT NULL,
   include_standard_             IN  VARCHAR2 DEFAULT 'TRUE',   
   include_project_              IN  VARCHAR2 DEFAULT 'TRUE',   
   activity_seq_                 IN  NUMBER   DEFAULT NULL,
   project_id_                   IN  VARCHAR2 DEFAULT NULL,
   location_no_                  IN  VARCHAR2 DEFAULT NULL,
   order_issue_control_db_       IN  VARCHAR2 DEFAULT NULL,
   automat_reserv_ctrl_db_       IN  VARCHAR2 DEFAULT NULL,
   manual_reserv_ctrl_db_        IN  VARCHAR2 DEFAULT NULL,
   condition_code_               IN  VARCHAR2 DEFAULT NULL,
   unit_of_measure_type_         IN  VARCHAR2 DEFAULT 'INVENTORY',
   expiration_control_date_      IN  DATE     DEFAULT NULL,
   warehouse_id_                 IN  VARCHAR2 DEFAULT NULL,
   ignore_this_avail_control_id_ IN  VARCHAR2 DEFAULT NULL,
   handling_unit_id_             IN  NUMBER   DEFAULT NULL )
IS
   loc_type1_                     VARCHAR2(200);
   loc_type2_                     VARCHAR2(200);
   loc_type3_                     VARCHAR2(200);
   loc_type4_                     VARCHAR2(200);
   owner_type1_                   VARCHAR2(200);
   owner_type2_                   VARCHAR2(200);
   owner_type3_                   VARCHAR2(200);
   owner_type4_                   VARCHAR2(200);
   owner_type5_                   VARCHAR2(200);
   owner_type6_                   VARCHAR2(200);
   min_durab_days_planning_       NUMBER;
   local_expiration_control_date_ DATE;
   max_date_                      DATE := Database_Sys.last_calendar_date_;
   loc_type_specified_            BOOLEAN;
   ownership_specified_           BOOLEAN;
   invent_qty_onhand_             INVENTORY_PART_IN_STOCK_TAB.qty_onhand%TYPE;
   invent_qty_reserved_           INVENTORY_PART_IN_STOCK_TAB.qty_reserved%TYPE;
   invent_qty_in_transit_         INVENTORY_PART_IN_STOCK_TAB.qty_in_transit%TYPE;
   catch_qty_onhand_              INVENTORY_PART_IN_STOCK_TAB.catch_qty_onhand%TYPE;
   catch_qty_reserved_            INVENTORY_PART_IN_STOCK_TAB.qty_reserved%TYPE;
   catch_qty_in_transit_          INVENTORY_PART_IN_STOCK_TAB.catch_qty_in_transit%TYPE;
   -- Cursor to use when location is specified but not ownership, condition code, location type, etc.
   CURSOR get_qty_loc IS
      SELECT SUM(qty_onhand), SUM(qty_reserved), SUM(qty_in_transit), SUM(catch_qty_onhand), SUM(catch_qty_in_transit)
      FROM INVENTORY_PART_IN_STOCK_TAB
      WHERE (   (NVL(expiration_date, max_date_) > local_expiration_control_date_
                 AND expiration_control_ = 'NOT EXPIRED')
             OR (NVL(expiration_date, max_date_) <= local_expiration_control_date_
                 AND expiration_control_ = 'EXPIRED')
             OR (expiration_control_ IS NULL))
      AND  (warehouse        = warehouse_id_     OR warehouse_id_     IS NULL)
      AND  (configuration_id = configuration_id_ OR configuration_id_ IS NULL)
      AND  (lot_batch_no     = lot_batch_no_     OR lot_batch_no_     IS NULL)
      AND  (serial_no        = serial_no_        OR serial_no_        IS NULL)
      AND  (eng_chg_level    = eng_chg_level_    OR eng_chg_level_    IS NULL)
      AND  (waiv_dev_rej_no  = waiv_dev_rej_no_  OR waiv_dev_rej_no_  IS NULL)
      AND  (handling_unit_id = handling_unit_id_ OR handling_unit_id_ IS NULL)
      AND    ((include_standard_ = db_true_  AND project_id    IS NULL)
         OR   (include_project_  = db_true_  AND project_id    IS NOT NULL
         AND  (project_id    = project_id_   OR  project_id_   IS NULL)
         AND ((activity_seq = activity_seq_  OR  activity_seq_ IS NULL) OR activity_seq_ = 0)))
      AND   location_no = location_no_
      AND   contract = contract_
      AND   part_no = part_no_;

   -- Cursor to use when condition code is not specified.
   CURSOR get_qty IS
      SELECT SUM(qty_onhand), SUM(qty_reserved), SUM(qty_in_transit), SUM(catch_qty_onhand), SUM(catch_qty_in_transit)
      FROM INVENTORY_PART_IN_STOCK_AVAIL
      WHERE (   (NVL(expiration_date, max_date_) > local_expiration_control_date_
                 AND expiration_control_ = 'NOT EXPIRED')
             OR (NVL(expiration_date, max_date_) <= local_expiration_control_date_
                 AND expiration_control_ = 'EXPIRED')
             OR (expiration_control_ IS NULL))
      AND   (   (    (part_supply_control_db      = supply_control_db_      OR supply_control_db_      IS NULL)
                 AND (part_order_issue_control_db = order_issue_control_db_ OR order_issue_control_db_ IS NULL)
                 AND (part_reservation_control_db = automat_reserv_ctrl_db_ OR automat_reserv_ctrl_db_ IS NULL)
                 AND (part_manual_reserv_ctrl_db  = manual_reserv_ctrl_db_  OR manual_reserv_ctrl_db_  IS NULL))
             OR (availability_control_id = ignore_this_avail_control_id_))
      AND   (   location_type_db = loc_type1_
             OR location_type_db = loc_type2_
             OR location_type_db = loc_type3_
             OR location_type_db = loc_type4_)
      AND   location_type_db IN (Inventory_Location_Type_API.DB_PICKING,
                                 Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                 Inventory_Location_Type_API.DB_PRODUCTION_LINE,
                                 Inventory_Location_Type_API.DB_SHIPMENT)
      AND   (   part_ownership_db = owner_type1_
             OR part_ownership_db = owner_type2_
             OR part_ownership_db = owner_type3_
             OR part_ownership_db = owner_type4_
             OR part_ownership_db = owner_type5_
             OR part_ownership_db = owner_type6_)
      AND  (   (part_ownership_db IN ('CONSIGNMENT','SUPPLIER LOANED', 'SUPPLIER RENTED')
                AND (owning_vendor_no = owning_vendor_no_ OR owning_vendor_no_ IS NULL))
            OR (part_ownership_db = 'CUSTOMER OWNED'
                AND (owning_customer_no = owning_customer_no_ OR owning_customer_no_ IS NULL))
            OR (part_ownership_db IN ('COMPANY OWNED', 'COMPANY RENTAL ASSET')) )
      AND  (warehouse        = warehouse_id_     OR warehouse_id_     IS NULL)      
      AND  (configuration_id = configuration_id_ OR configuration_id_ IS NULL)
      AND  (lot_batch_no     = lot_batch_no_     OR lot_batch_no_     IS NULL)
      AND  (serial_no        = serial_no_        OR serial_no_        IS NULL)
      AND  (eng_chg_level    = eng_chg_level_    OR eng_chg_level_    IS NULL)
      AND  (waiv_dev_rej_no  = waiv_dev_rej_no_  OR waiv_dev_rej_no_  IS NULL)
      AND  (handling_unit_id = handling_unit_id_ OR handling_unit_id_ IS NULL)
      AND    ((include_standard_ = db_true_  AND project_id    IS NULL)
         OR   (include_project_  = db_true_  AND project_id    IS NOT NULL
         AND  (project_id    = project_id_   OR  project_id_   IS NULL)
         AND ((activity_seq = activity_seq_  OR  activity_seq_ IS NULL) OR activity_seq_ = 0)))
      AND  (location_no      = location_no_      OR location_no_      IS NULL)
      AND   contract = contract_
      AND   part_no = part_no_;

   -- Cursor to use when condition code is specified.
   CURSOR get_qty_cc IS
      SELECT SUM(qty_onhand), SUM(qty_reserved), SUM(qty_in_transit), SUM(catch_qty_onhand), SUM(catch_qty_in_transit)
      FROM INVENTORY_PART_IN_STOCK_TOTAL
      WHERE (   (NVL(expiration_date, max_date_) > local_expiration_control_date_
                 AND expiration_control_ = 'NOT EXPIRED')
             OR (NVL(expiration_date, max_date_) <= local_expiration_control_date_
                 AND expiration_control_ = 'EXPIRED')
             OR (expiration_control_ IS NULL))
      AND   (   (    (part_supply_control_db      = supply_control_db_      OR supply_control_db_      IS NULL)
                 AND (part_order_issue_control_db = order_issue_control_db_ OR order_issue_control_db_ IS NULL)
                 AND (part_reservation_control_db = automat_reserv_ctrl_db_ OR automat_reserv_ctrl_db_ IS NULL)
                 AND (part_manual_reserv_ctrl_db  = manual_reserv_ctrl_db_  OR manual_reserv_ctrl_db_  IS NULL))
             OR (availability_control_id = ignore_this_avail_control_id_))
      AND   (   location_type_db = loc_type1_
             OR location_type_db = loc_type2_
             OR location_type_db = loc_type3_
             OR location_type_db = loc_type4_)
      AND   location_type_db IN (Inventory_Location_Type_API.DB_PICKING,
                                 Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                 Inventory_Location_Type_API.DB_PRODUCTION_LINE,
                                 Inventory_Location_Type_API.DB_SHIPMENT)
      AND   (   part_ownership_db = owner_type1_
             OR part_ownership_db = owner_type2_
             OR part_ownership_db = owner_type3_
             OR part_ownership_db = owner_type4_
             OR part_ownership_db = owner_type5_
             OR part_ownership_db = owner_type6_)
      AND  (   (part_ownership_db IN ('CONSIGNMENT','SUPPLIER LOANED', 'SUPPLIER RENTED')
                AND (owning_vendor_no = owning_vendor_no_ OR owning_vendor_no_ IS NULL))
            OR (part_ownership_db = 'CUSTOMER OWNED'
                AND (owning_customer_no = owning_customer_no_ OR owning_customer_no_ IS NULL))
            OR (part_ownership_db IN ('COMPANY OWNED', 'COMPANY RENTAL ASSET')) )
      AND  (warehouse        = warehouse_id_     OR warehouse_id_     IS NULL)      
      AND  (configuration_id = configuration_id_ OR configuration_id_ IS NULL)
      AND  (condition_code   = condition_code_   OR condition_code_   IS NULL)
      AND  (lot_batch_no     = lot_batch_no_     OR lot_batch_no_     IS NULL)
      AND  (serial_no        = serial_no_        OR serial_no_        IS NULL)
      AND  (eng_chg_level    = eng_chg_level_    OR eng_chg_level_    IS NULL)
      AND  (waiv_dev_rej_no  = waiv_dev_rej_no_  OR waiv_dev_rej_no_  IS NULL)
      AND  (handling_unit_id = handling_unit_id_ OR handling_unit_id_ IS NULL)
      AND    ((include_standard_ = db_true_  AND project_id    IS NULL)
         OR   (include_project_  = db_true_  AND project_id    IS NOT NULL
         AND  (project_id    = project_id_   OR  project_id_   IS NULL)
         AND ((activity_seq = activity_seq_  OR  activity_seq_ IS NULL) OR activity_seq_ = 0)))
      AND  (location_no      = location_no_      OR location_no_      IS NULL)
      AND  contract = contract_
      AND  part_no = part_no_;
BEGIN
   loc_type_specified_ := FALSE;

   IF (location_type1_db_ IS NOT NULL) THEN
      loc_type1_ := location_type1_db_;
      loc_type_specified_ := TRUE;
   ELSIF (location_type2_db_ IS NOT NULL) THEN
      loc_type1_ := location_type2_db_;
      loc_type_specified_ := TRUE;
   ELSIF (location_type3_db_ IS NOT NULL) THEN
      loc_type1_ := location_type3_db_;
      loc_type_specified_ := TRUE;
   ELSIF (location_type4_db_ IS NOT NULL) THEN
      loc_type1_ := location_type4_db_;
      loc_type_specified_ := TRUE;
   END IF;

   IF (loc_type_specified_) THEN
      loc_type1_ := NVL(location_type1_db_, loc_type1_);
      loc_type2_ := NVL(location_type2_db_, loc_type1_);
      loc_type3_ := NVL(location_type3_db_, loc_type1_);
      loc_type4_ := NVL(location_type4_db_, loc_type1_);
   ELSE
      loc_type1_ := Inventory_Location_Type_API.DB_PICKING;
      loc_type2_ := Inventory_Location_Type_API.DB_FLOOR_STOCK;
      loc_type3_ := Inventory_Location_Type_API.DB_PRODUCTION_LINE;
      loc_type4_ := Inventory_Location_Type_API.DB_SHIPMENT;
   END IF;

   ownership_specified_ := FALSE;

   IF (ownership_type1_db_ IS NOT NULL) THEN
      owner_type1_ := ownership_type1_db_;
      ownership_specified_ := TRUE;
   ELSIF (ownership_type2_db_ IS NOT NULL) THEN
      owner_type1_ := ownership_type2_db_;
      ownership_specified_ := TRUE;
   ELSIF (ownership_type3_db_ IS NOT NULL) THEN
      owner_type1_ := ownership_type3_db_;
      ownership_specified_ := TRUE;
   ELSIF (ownership_type4_db_ IS NOT NULL) THEN
      owner_type1_ := ownership_type4_db_;
      ownership_specified_ := TRUE;
   ELSIF (ownership_type5_db_ IS NOT NULL) THEN
      owner_type1_ := ownership_type5_db_;
      ownership_specified_ := TRUE;
   ELSIF (ownership_type6_db_ IS NOT NULL) THEN
      owner_type1_ := ownership_type6_db_;
      ownership_specified_ := TRUE;
   END IF;

   IF (ownership_specified_) THEN
      owner_type1_ := NVL(ownership_type1_db_, owner_type1_);
      owner_type2_ := NVL(ownership_type2_db_, owner_type1_);
      owner_type3_ := NVL(ownership_type3_db_, owner_type1_);
      owner_type4_ := NVL(ownership_type4_db_, owner_type1_);
      owner_type5_ := NVL(ownership_type5_db_, owner_type1_);
      owner_type6_ := NVL(ownership_type6_db_, owner_type1_);
   ELSE
      owner_type1_ := 'CONSIGNMENT';
      owner_type2_ := 'SUPPLIER LOANED';
      owner_type3_ := 'CUSTOMER OWNED';
      owner_type4_ := 'COMPANY OWNED';
      owner_type5_ := 'SUPPLIER RENTED';
      owner_type6_ := 'COMPANY RENTAL ASSET';
   END IF;

   IF (expiration_control_ IS NOT NULL) THEN
      local_expiration_control_date_ := NVL(expiration_control_date_, TRUNC(Site_API.Get_Site_Date(contract_)));

      IF (supply_control_db_ IS NOT NULL) THEN
         min_durab_days_planning_ := Inventory_Part_API.Get_Min_Durab_Days_Planning(contract_, part_no_);

         IF (expiration_control_ = 'NOT EXPIRED') THEN
            local_expiration_control_date_ := local_expiration_control_date_ + min_durab_days_planning_;
         ELSE
            local_expiration_control_date_ := local_expiration_control_date_ - min_durab_days_planning_;
         END IF;
      END IF;
   END IF;

   -- Call the cursor with the best performance based on parameters needed.
   IF (location_no_ IS NOT NULL AND
       NOT loc_type_specified_ AND
       NOT ownership_specified_ AND
       supply_control_db_ IS NULL AND
       order_issue_control_db_ IS NULL AND
       automat_reserv_ctrl_db_ IS NULL AND
       manual_reserv_ctrl_db_ IS NULL AND
       condition_code_ IS NULL) THEN
      OPEN get_qty_loc;
      FETCH get_qty_loc INTO
         invent_qty_onhand_, 
         invent_qty_reserved_,
         invent_qty_in_transit_,
         catch_qty_onhand_,
         catch_qty_in_transit_;
      CLOSE get_qty_loc;
   ELSIF condition_code_ IS NULL THEN
      OPEN get_qty;
      FETCH get_qty INTO 
         invent_qty_onhand_,
         invent_qty_reserved_,
         invent_qty_in_transit_,
         catch_qty_onhand_,
         catch_qty_in_transit_;
      CLOSE get_qty;
   ELSE
      OPEN get_qty_cc;
      FETCH get_qty_cc INTO 
         invent_qty_onhand_, 
         invent_qty_reserved_, 
         invent_qty_in_transit_, 
         catch_qty_onhand_, 
         catch_qty_in_transit_;
      CLOSE get_qty_cc;
   END IF;
   
   -- Assignment of return quantities.
   IF (invent_qty_onhand_ IS NULL) THEN
      invent_qty_onhand_     := 0;
      invent_qty_reserved_   := 0;
      invent_qty_in_transit_ := 0;
      catch_qty_onhand_      := 0;
      catch_qty_in_transit_  := 0;
   END IF;
   
   IF ((invent_qty_reserved_ = 0) OR (catch_qty_onhand_ = 0)) THEN
      catch_qty_reserved_ := 0;
   ELSIF (invent_qty_onhand_ = invent_qty_reserved_) THEN
      catch_qty_reserved_ := catch_qty_onhand_;
   ELSE
      catch_qty_reserved_ := NULL;
   END IF;

   IF (unit_of_measure_type_ = 'INVENTORY') THEN
      qty_onhand_     := invent_qty_onhand_;
      qty_reserved_   := invent_qty_reserved_;
      qty_in_transit_ := invent_qty_in_transit_;
   ELSIF (unit_of_measure_type_ = 'CATCH') THEN
      qty_onhand_     := catch_qty_onhand_;
      qty_reserved_   := catch_qty_reserved_;
      qty_in_transit_ := catch_qty_in_transit_;
   END IF;
   IF (expiration_control_     IS NULL AND
       supply_control_db_      IS NULL AND
       order_issue_control_db_ IS NULL AND
       automat_reserv_ctrl_db_ IS NULL AND
       manual_reserv_ctrl_db_  IS NULL AND
       location_no_            IS NULL AND
       warehouse_id_           IS NULL AND
       NOT loc_type_specified_ AND
       ( owner_type1_ = 'COMPANY OWNED' OR
         owner_type2_ = 'COMPANY OWNED' OR
         owner_type3_ = 'COMPANY OWNED' OR
         owner_type4_ = 'COMPANY OWNED' OR
         owner_type5_ = 'COMPANY OWNED' OR
         owner_type6_ = 'COMPANY OWNED'))  THEN
      qty_in_transit_ := qty_in_transit_ + 
                         Inventory_Part_In_Transit_API.Get_Total_Qty_In_Order_Transit(contract_             => contract_,
                                                                                      part_no_              => part_no_,
                                                                                      configuration_id_     => configuration_id_,
                                                                                      lot_batch_no_         => lot_batch_no_,
                                                                                      serial_no_            => serial_no_,
                                                                                      eng_chg_level_        => eng_chg_level_,
                                                                                      waiv_dev_rej_no_      => waiv_dev_rej_no_,
                                                                                      handling_unit_id_     => handling_unit_id_,
                                                                                      expiration_date_      => NULL,
                                                                                      condition_code_       => condition_code_,
                                                                                      unit_of_measure_type_ => unit_of_measure_type_);

   END IF;
END Get_Inventory_Quantity;


-- Modify_Availability_Control_Id
--   Modifies availability_control_id on an Inventory Part Location record.
PROCEDURE Modify_Availability_Control_Id (
   contract_                IN VARCHAR2,
   part_no_                 IN VARCHAR2,
   configuration_id_        IN VARCHAR2,
   location_no_             IN VARCHAR2,
   lot_batch_no_            IN VARCHAR2,
   serial_no_               IN VARCHAR2,
   eng_chg_level_           IN VARCHAR2,
   waiv_dev_rej_no_         IN VARCHAR2,
   activity_seq_            IN NUMBER,
   handling_unit_id_        IN NUMBER,
   availability_control_id_ IN VARCHAR2 )
IS
   oldrec_ inventory_part_in_stock_tab%ROWTYPE;
   newrec_ inventory_part_in_stock_tab%ROWTYPE;
BEGIN
   oldrec_ := Lock_By_Keys___(contract_,
                              part_no_,
                              configuration_id_,
                              location_no_,
                              lot_batch_no_,
                              serial_no_,
                              eng_chg_level_,
                              waiv_dev_rej_no_,
                              activity_seq_,
                              handling_unit_id_);

   IF (Validate_SYS.Is_Changed(oldrec_.availability_control_id, availability_control_id_)) THEN
      newrec_                         := oldrec_;
      newrec_.availability_control_id := availability_control_id_;

      Check_And_Update_By_Keys___(oldrec_ => oldrec_, newrec_ => newrec_);
   END IF;
END Modify_Availability_Control_Id;


-- Change_Waiv_Dev_Rej_No
--   Changes waiv_dev_rej_no on an Inventory Part Location record.
PROCEDURE Change_Waiv_Dev_Rej_No (
   contract_           IN VARCHAR2,
   part_no_            IN VARCHAR2,
   configuration_id_   IN VARCHAR2,
   location_no_        IN VARCHAR2,
   lot_batch_no_       IN VARCHAR2,
   serial_no_          IN VARCHAR2,
   eng_chg_level_      IN VARCHAR2,
   waiv_dev_rej_no_    IN VARCHAR2,
   activity_seq_       IN NUMBER,
   handling_unit_id_   IN NUMBER,
   to_waiv_dev_rej_no_ IN VARCHAR2,
   quantity_           IN NUMBER,
   catch_quantity_     IN NUMBER,
   order_no_           IN VARCHAR2 DEFAULT NULL,
   release_no_         IN VARCHAR2 DEFAULT NULL,
   sequence_no_        IN VARCHAR2 DEFAULT NULL,
   line_item_no_       IN NUMBER   DEFAULT NULL,
   order_type_         IN VARCHAR2 DEFAULT NULL )
IS
   qty_available_        INVENTORY_PART_IN_STOCK_TAB.qty_onhand%TYPE;
   location_type_db_     INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   expiration_date_      INVENTORY_PART_IN_STOCK_TAB.expiration_date%TYPE;
   to_expiration_date_   INVENTORY_PART_IN_STOCK_TAB.expiration_date%TYPE;
   dummy_catch_quantity_ NUMBER := catch_quantity_;
   part_catalog_rec_     Part_Catalog_API.Public_Rec;
   last_calendar_date_   DATE := Database_Sys.last_calendar_date_;
   
   CURSOR get_attr IS
      SELECT (qty_onhand - qty_reserved) qty_available, location_type, expiration_date
      FROM   INVENTORY_PART_IN_STOCK_TAB
      WHERE  contract         = contract_
      AND    part_no          = part_no_
      AND    configuration_id = configuration_id_
      AND    location_no      = location_no_
      AND    lot_batch_no     = lot_batch_no_
      AND    serial_no        = serial_no_
      AND    eng_chg_level    = eng_chg_level_
      AND    waiv_dev_rej_no  = waiv_dev_rej_no_
      AND    activity_seq     = activity_seq_
      AND    handling_unit_id = handling_unit_id_;
BEGIN
   part_catalog_rec_ := Part_Catalog_API.Get(part_no_);

   IF to_waiv_dev_rej_no_ IS NULL THEN
      Error_SYS.Record_General('InventoryPartInStock','WDRNONULL: W/D/R No must have a value.');
   END IF;

   IF ((dummy_catch_quantity_ IS NOT NULL) AND (part_catalog_rec_.catch_unit_enabled = db_false_)) THEN
      Error_SYS.Record_General(lu_name_,'CATCHQTYNOTALLOWED: Not allowed to enter catch quantity because the part is not a catch unit enabled part.');
   END IF;

   OPEN  get_attr;
   FETCH get_attr INTO qty_available_, location_type_db_, expiration_date_;
   IF (get_attr%NOTFOUND) THEN
      Error_SYS.Record_Not_Exist(lu_name_);
   END IF;
   CLOSE get_attr;

   Check_Waiv_Dev_Rej_No___(contract_             => contract_,
                            part_no_              => part_no_,
                            configuration_id_     => configuration_id_,
                            location_no_          => location_no_,
                            lot_batch_no_         => lot_batch_no_,
                            serial_no_            => serial_no_,
                            eng_chg_level_        => eng_chg_level_,
                            waiv_dev_rej_no_      => to_waiv_dev_rej_no_,
                            activity_seq_         => activity_seq_,
                            handling_unit_id_     => handling_unit_id_,
                            check_during_receipt_ => FALSE,
                            part_catalog_rec_     => part_catalog_rec_,
                            location_type_db_     => location_type_db_,
                            part_ownership_db_    => NULL,
                            owning_customer_no_   => NULL,
                            owning_vendor_no_     => NULL);

   IF (quantity_ > qty_available_) THEN
      Error_SYS.Record_General ('InventoryPartInStock','GREATAV: The specified quantity is greater than the available quantity.');
   END IF;

   to_expiration_date_ := Get_Expiration_Date(contract_,
                                              part_no_,
                                              configuration_id_,
                                              location_no_,
                                              lot_batch_no_,
                                              serial_no_,
                                              eng_chg_level_,
                                              to_waiv_dev_rej_no_,
                                              activity_seq_,
                                              handling_unit_id_);

   IF (Nvl(to_expiration_date_, last_calendar_date_) <
       Nvl(expiration_date_,    last_calendar_date_)) THEN
      expiration_date_ := to_expiration_date_;
   END IF;

   IF (to_waiv_dev_rej_no_ != waiv_dev_rej_no_) THEN
      Move_Part_Impl___(catch_quantity_                => dummy_catch_quantity_,
                        contract_                      => contract_,
                        part_no_                       => part_no_,
                        configuration_id_              => configuration_id_,
                        location_no_                   => location_no_,
                        lot_batch_no_                  => lot_batch_no_,
                        serial_no_                     => serial_no_,
                        eng_chg_level_                 => eng_chg_level_,
                        waiv_dev_rej_no_               => waiv_dev_rej_no_,
                        activity_seq_                  => activity_seq_,
                        handling_unit_id_              => handling_unit_id_,
                        expiration_date_               => expiration_date_,
                        to_contract_                   => contract_,
                        to_part_no_                    => part_no_,
                        to_location_no_                => location_no_,
                        to_destination_db_             => 'N',
                        to_waiv_dev_rej_no_            => to_waiv_dev_rej_no_,
                        to_lot_batch_no_               => lot_batch_no_,
                        to_serial_no_                  => serial_no_,
                        to_activity_seq_               => activity_seq_,
                        to_handling_unit_id_           => handling_unit_id_,
                        quantity_                      => quantity_,
                        quantity_reserved_             => 0,
                        move_comment_                  => NULL,
                        order_no_                      => order_no_,
                        line_no_                       => release_no_,
                        release_no_                    => sequence_no_,
                        line_item_no_                  => line_item_no_,
                        source_ref5_                   => NULL,
                        order_type_                    => order_type_,
                        consume_consignment_stock_     => FALSE,
                        make_transaction_and_postings_ => TRUE,
                        report_earned_value_db_        => NULL,
                        from_part_catalog_rec_         => part_catalog_rec_,
                        to_part_catalog_rec_           => part_catalog_rec_,
                        transport_task_id_             => NULL,
                        validate_hu_struct_position_   => FALSE,
                        availability_ctrl_id_          => NULL,
                        always_preserve_serial_no_     => FALSE,
                        ownership_transfer_reason_id_  => NULL);
   END IF;

END Change_Waiv_Dev_Rej_No;


PROCEDURE Check_Valid_Move_Combinations (
   from_contract_         IN VARCHAR2,
   from_location_type_db_ IN VARCHAR2,
   to_contract_           IN VARCHAR2,
   to_location_type_db_   IN VARCHAR2,
   to_destination_db_     IN VARCHAR2,
   order_ref1_            IN VARCHAR2,
   order_type_db_         IN VARCHAR2,
   from_part_no_          IN VARCHAR2,
   to_part_no_            IN VARCHAR2 )
IS
   to_status_rec_ Inventory_Part_Status_Par_API.Public_Rec;
   error_text_    VARCHAR2(2000);   
BEGIN
   IF (to_location_type_db_ IN (Inventory_Location_Type_API.DB_QUALITY_ASSURANCE,
                                Inventory_Location_Type_API.DB_ARRIVAL)) THEN
      IF (from_location_type_db_ NOT IN (Inventory_Location_Type_API.DB_ARRIVAL,
                                         Inventory_Location_Type_API.DB_QUALITY_ASSURANCE,
                                         Inventory_Location_Type_API.DB_PICKING,
                                         Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                         Inventory_Location_Type_API.DB_PRODUCTION_LINE)) THEN
         IF (order_type_db_ IS NULL OR order_type_db_ != Order_Type_API.DB_PURCH_RECEIPT_RETURN) THEN
            Error_SYS.Record_General(lu_name_,'TOQAERR: Parts cannot be moved from locations of type :P1 to locations of type :P2.',
                                     Inventory_Location_Type_API.Decode(from_location_type_db_),
                                     Inventory_Location_Type_API.Decode(to_location_type_db_));
         END IF;
      END IF;
   END IF;

   IF (from_contract_ != to_contract_) THEN
      IF (from_location_type_db_ NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                         Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                         Inventory_Location_Type_API.DB_PRODUCTION_LINE)) THEN
         Error_SYS.Record_General(lu_name_,'CHANGESITEFROM: Parts can be moved to locations on a different site only from locations of types :P1, :P2 and :P3.',
                                  Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_PICKING),
                                  Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_FLOOR_STOCK),
                                  Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_PRODUCTION_LINE));
      END IF;
      IF (to_location_type_db_ NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                         Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                         Inventory_Location_Type_API.DB_PRODUCTION_LINE)) THEN
         Error_SYS.Record_General(lu_name_,'CHANGESITETO: Parts can only be moved to locations of types :P1, :P2 and :P3 when moved to a different site.',
                                  Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_PICKING),
                                  Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_FLOOR_STOCK),
                                  Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_PRODUCTION_LINE));
      END IF;
   END IF;

   IF ((from_contract_ != to_contract_) OR (from_part_no_ != to_part_no_)) THEN
      to_status_rec_ := Inventory_Part_Status_Par_API.Get(Inventory_Part_API.Get_Part_Status(to_contract_, to_part_no_));

      IF (to_status_rec_.onhand_flag = 'N') THEN
         Raise_Qty_Onhand_Error___(to_part_no_, to_contract_, Inventory_Part_Status_Par_API.Get_Description(Inventory_Part_API.Get_Part_Status(to_contract_, to_part_no_)));
      END IF;
   END IF;

   IF (to_destination_db_ = 'Y') THEN
      IF (from_location_type_db_ NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                         Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                         Inventory_Location_Type_API.DB_PRODUCTION_LINE)) THEN
         Error_SYS.Record_General(lu_name_,'TOTRANSITFROM: Parts can be moved to transit only from locations of types :P1, :P2 and :P3.',
                                  Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_PICKING),
                                  Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_FLOOR_STOCK),
                                  Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_PRODUCTION_LINE));
      END IF;
      IF (to_location_type_db_ NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                         Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                         Inventory_Location_Type_API.DB_PRODUCTION_LINE)) THEN
         Error_SYS.Record_General(lu_name_,'TOTRANSITTO: Parts can only be moved to locations of types :P1, :P2 and :P3 when moved to transit.',
                                  Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_PICKING),
                                  Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_FLOOR_STOCK),
                                  Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_PRODUCTION_LINE));
      END IF;
   END IF;

   IF (from_location_type_db_ = Inventory_Location_Type_API.DB_QUALITY_ASSURANCE) THEN
      IF ((order_ref1_     IS NULL) OR
          (order_type_db_  IS NULL) OR
          (order_type_db_  NOT IN (Order_Type_API.DB_PURCHASE_ORDER, Order_Type_API.DB_PURCH_RECEIPT_RETURN))) THEN
         Error_SYS.Record_General('InventoryPartInStock','FROMNOPURORDERRETURN: Cannot move from location type :P1 when not connected to a :P2 or :P3.', 
                                   INVENTORY_LOCATION_TYPE_API.Decode(from_location_type_db_), Order_Type_API.Decode(Order_Type_API.DB_PURCHASE_ORDER), Order_Type_API.Decode(Order_Type_API.DB_PURCH_RECEIPT_RETURN));
      END IF;
   END IF;
   
   IF (from_location_type_db_ = Inventory_Location_Type_API.DB_ARRIVAL) THEN
      IF ((order_ref1_     IS NULL) OR
          (order_type_db_  IS NULL) OR
          (order_type_db_  NOT IN (Order_Type_API.DB_PURCHASE_ORDER, Order_Type_API.DB_SHIPMENT_ORDER, Order_Type_API.DB_PURCH_RECEIPT_RETURN))) THEN
         error_text_  := Language_SYS.Translate_Constant('InventoryPartInStock', 'FROMNOPURSHIPODRETURN: :P1 when not connected to a :P2 or :P3 or :P4.', 
                                                         Language_SYS.Get_Language, INVENTORY_LOCATION_TYPE_API.Decode(from_location_type_db_), Order_Type_API.Decode(Order_Type_API.DB_PURCHASE_ORDER), Order_Type_API.Decode(Order_Type_API.DB_SHIPMENT_ORDER));
         error_text_ := replace(error_text_, ':P4', Order_Type_API.Decode(Order_Type_API.DB_PURCH_RECEIPT_RETURN)); 
         Error_SYS.Record_General('InventoryPartInStock', 'FROMNOPURSHIPODRETURN1: Cannot move from location type '||error_text_);
      END IF;
   END IF;

   IF (to_location_type_db_ = Inventory_Location_Type_API.DB_QUALITY_ASSURANCE) THEN
      IF ((order_ref1_     IS NULL) OR
          (order_type_db_  IS NULL) OR
          (order_type_db_  NOT IN (Order_Type_API.DB_PURCHASE_ORDER, Order_Type_API.DB_PURCH_RECEIPT_RETURN))) THEN
         Error_SYS.Record_General('InventoryPartInStock','TONOPURORDER: Cannot move to location type :P1 when not connected to a :P2 or :P3.', INVENTORY_LOCATION_TYPE_API.Decode(to_location_type_db_), Order_Type_API.Decode(Order_Type_API.DB_PURCHASE_ORDER),
                                                                        Order_Type_API.Decode(Order_Type_API.DB_PURCH_RECEIPT_RETURN));
      END IF;
   END IF;

   IF (to_location_type_db_ = Inventory_Location_Type_API.DB_ARRIVAL) THEN
      IF ((order_ref1_     IS NULL) OR
          (order_type_db_  IS NULL) OR
          (order_type_db_  NOT IN (Order_Type_API.DB_PURCHASE_ORDER, Order_Type_API.DB_SHIPMENT_ORDER, Order_Type_API.DB_PURCH_RECEIPT_RETURN))) THEN
         error_text_  := Language_SYS.Translate_Constant('InventoryPartInStock', 'TONOPURSHIPODRETURN: :P1 when not connected to a :P2 or :P3 or :P4.', 
                                                         Language_SYS.Get_Language, INVENTORY_LOCATION_TYPE_API.Decode(to_location_type_db_), Order_Type_API.Decode(Order_Type_API.DB_PURCHASE_ORDER), Order_Type_API.Decode(Order_Type_API.DB_SHIPMENT_ORDER));
         error_text_ := replace(error_text_, ':P4', Order_Type_API.Decode(Order_Type_API.DB_PURCH_RECEIPT_RETURN)); 
         Error_SYS.Record_General('InventoryPartInStock', 'TONOPURSHIPODRETURN1: Cannot move to location type '||error_text_);
      END IF;
   END IF;
   
   IF ((order_type_db_ IN (Order_Type_API.DB_WORK_ORDER, Order_Type_API.DB_WORK_TASK,
                           Order_Type_API.DB_MATERIAL_REQUISITION) AND to_location_type_db_ != Inventory_Location_Type_API.DB_PICKING) OR
       (order_type_db_ IN (Order_Type_API.DB_CUSTOMER_ORDER,
                           Order_Type_API.DB_PROJECT_DELIVERABLES)
                           AND to_location_type_db_ NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                                                                              Inventory_Location_Type_API.DB_SHIPMENT))) THEN
      Raise_Move_To_Location_Error(order_type_db_, to_location_type_db_);     
   END IF;
END Check_Valid_Move_Combinations;


-- Get_Aggregate_Qty_Consignment
--   Returns the sum of qty_onhand for a part available at all
--   Consignment Stock locations.
@UncheckedAccess
FUNCTION Get_Aggregate_Qty_Consignment (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2 DEFAULT NULL,
   serial_no_        IN VARCHAR2 DEFAULT NULL ) RETURN NUMBER
IS
BEGIN
   RETURN ( Get_Externally_Owned_Inventory(contract_,
                                           part_no_,
                                           configuration_id_,
                                           lot_batch_no_,
                                           serial_no_,
                                           'CONSIGNMENT'));
END Get_Aggregate_Qty_Consignment;


-- Set_Freeze_Flag
--   Sets the attribute Freeze_Flag to frozen.
PROCEDURE Set_Freeze_Flag (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_no_      IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER )
IS
   oldrec_ inventory_part_in_stock_tab%ROWTYPE;
   newrec_ inventory_part_in_stock_tab%ROWTYPE;
BEGIN
   oldrec_ := Lock_By_Keys___(contract_,
                              part_no_,
                              configuration_id_,
                              location_no_,
                              lot_batch_no_,
                              serial_no_,
                              eng_chg_level_,
                              waiv_dev_rej_no_,
                              activity_seq_,
                              handling_unit_id_);

   IF oldrec_.freeze_flag != 'Y' THEN
      newrec_             := oldrec_;
      newrec_.freeze_flag := 'Y';
      Check_And_Update_By_Keys___(oldrec_ => oldrec_, newrec_ => newrec_);
   END IF;
END Set_Freeze_Flag;


-- Reset_Freeze_Flag
--   Resets the attribute FreezeFlag to not frozen.
PROCEDURE Reset_Freeze_Flag (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_no_      IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER )
IS
   oldrec_ inventory_part_in_stock_tab%ROWTYPE;
   newrec_ inventory_part_in_stock_tab%ROWTYPE;
BEGIN
   IF (Check_Exist___ (contract_,
                       part_no_,
                       configuration_id_,
                       location_no_,
                       lot_batch_no_,
                       serial_no_,
                       eng_chg_level_,
                       waiv_dev_rej_no_,
                       activity_seq_,
                       handling_unit_id_)) THEN
      oldrec_ := Lock_By_Keys___(contract_,
                                 part_no_,
                                 configuration_id_,
                                 location_no_,
                                 lot_batch_no_,
                                 serial_no_,
                                 eng_chg_level_,
                                 waiv_dev_rej_no_,
                                 activity_seq_,
                                 handling_unit_id_);
   
      IF oldrec_.freeze_flag != 'N' THEN
         newrec_ := oldrec_;
         newrec_.freeze_flag := 'N';
         Check_And_Update_By_Keys___(oldrec_ => oldrec_, newrec_ => newrec_);
      END IF;
   END IF;
END Reset_Freeze_Flag;


-- Get_Next_Count_Date
--   Gets the next count date for the inventory part location record
--   if the inventory part uses cycle counting.
@UncheckedAccess
FUNCTION Get_Next_Count_Date (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_no_      IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER ) RETURN DATE
IS
   part_rec_         Inventory_Part_API.Public_Rec;
   next_count_date_  DATE;
   start_date_       DATE;
   lurec_            INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
BEGIN
   next_count_date_ := NULL;
   part_rec_        := Inventory_Part_API.Get(contract_, part_no_);

   IF (part_rec_.cycle_code = 'Y') THEN
      lurec_ := Get_Object_By_Keys___(contract_,
                                      part_no_,
                                      configuration_id_,
                                      location_no_,
                                      lot_batch_no_,
                                      serial_no_,
                                      eng_chg_level_,
                                      waiv_dev_rej_no_,
                                      activity_seq_, 
                                      handling_unit_id_);
      IF (lurec_.location_type IN (Inventory_Location_Type_API.DB_PICKING,
                                   Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                   Inventory_Location_Type_API.DB_PRODUCTION_LINE)) THEN

         IF (lurec_.last_count_date IS NULL) THEN
            start_date_ := lurec_.receipt_date;
         ELSE
            start_date_ := lurec_.last_count_date;
         END IF;
         next_count_date_ := Work_Time_Calendar_API.Get_End_Date(
                                                  Site_API.Get_Dist_Calendar_Id(contract_),
                                                  start_date_,
                                                  part_rec_.cycle_period);
         next_count_date_ := trunc(next_count_date_);
      END IF;
   END IF;
   RETURN (next_count_date_);
END Get_Next_Count_Date;


-- Validate_Count_Part
--   This procedure validates an InventoryPartLocation record regarding counting.
PROCEDURE Validate_Count_Part (
   contract_                       IN VARCHAR2,
   part_no_                        IN VARCHAR2,
   configuration_id_               IN VARCHAR2,
   location_no_                    IN VARCHAR2,
   lot_batch_no_                   IN VARCHAR2,
   serial_no_                      IN VARCHAR2,
   eng_chg_level_                  IN VARCHAR2,
   waiv_dev_rej_no_                IN VARCHAR2,
   activity_seq_                   IN NUMBER,
   handling_unit_id_               IN NUMBER,
   qty_counted_                    IN NUMBER,
   catch_qty_counted_              IN NUMBER,
   qty_difference_                 IN NUMBER,
   part_tracking_session_id_       IN NUMBER,
   ignore_serial_in_different_loc_ IN BOOLEAN)
IS
   lurec_                        INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   location_type_db_             INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   picking_                      INVENTORY_PART_IN_STOCK.location_type%TYPE;
   f_                            INVENTORY_PART_IN_STOCK.location_type%TYPE;
   manufacturing_                INVENTORY_PART_IN_STOCK.location_type%TYPE;
   part_catalog_rec_             Part_Catalog_API.Public_Rec;
   latest_transaction_            VARCHAR2(200);
   error_serial_no_              INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE;
   order_ref1_                   VARCHAR2(25);
   order_ref2_                   VARCHAR2(25);
   order_ref3_                   VARCHAR2(25);
   order_ref4_                   NUMBER;
   source_                       VARCHAR2(100);
   serial_no_exist_              VARCHAR2(5) := db_false_;
   planning_method_              VARCHAR2(1);
   number_of_identified_serials_ NUMBER;
   serial_catch_tab_             Serial_Catch_Table;
   count_serial_exist_           EXCEPTION;
   part_rese_exist_              EXCEPTION;
BEGIN
   lurec_ := Get_Object_By_Keys___(contract_,part_no_,configuration_id_,
                                   location_no_,lot_batch_no_,serial_no_,
                                   eng_chg_level_,waiv_dev_rej_no_,activity_seq_, handling_unit_id_);

   IF (qty_counted_ < 0) THEN
      Error_SYS.Record_General('InventoryPartInStock', 'QTYCOUNTPOSITIVE: The counted quantity for the part :P1 at the location :P2 cannot be negative.', part_no_, location_no_);
   END IF;

   part_catalog_rec_ := Part_Catalog_API.Get(part_no_);

   IF (qty_counted_ != 0) THEN
      IF (part_catalog_rec_.lot_tracking_code IN ('LOT TRACKING','ORDER BASED')) THEN
         IF (lot_batch_no_ = '*') THEN
            Raise_Lot_Bat_Req_Error___(part_no_);
         END IF;
      ELSE
         IF (lot_batch_no_ != '*') THEN
            Raise_Lot_Bat_Not_Req_Error___(part_no_);
         END IF;
      END IF;

      IF (part_catalog_rec_.serial_tracking_code = db_serial_tracking_) THEN
         IF (serial_no_ = '*') THEN
            Raise_Serial_Req_Error___(part_no_);
         END IF;
      ELSE
         IF ((serial_no_ != '*') AND (part_catalog_rec_.receipt_issue_serial_track = db_false_)) THEN
            Raise_Serial_Not_Req_Error___(part_no_);
         END IF;
      END IF;
   END IF;
   
   IF ((part_catalog_rec_.serial_tracking_code       = db_not_serial_tracking_) AND 
      (part_catalog_rec_.receipt_issue_serial_track = db_true_) AND (serial_no_ = '*')) THEN
      -- Serial tracked at receipt and issue but not in inventory.
      serial_catch_tab_             := Temporary_Part_Tracking_API.Get_Serials(part_tracking_session_id_);
      number_of_identified_serials_ := serial_catch_tab_.COUNT;

      IF (number_of_identified_serials_ != ABS(qty_difference_)) THEN
         -- there must be as many serial numbers identified as the counting difference.
         Error_SYS.Record_General(lu_name_, 'SERIALCOUNTDIFF: The counting difference is :P1 but :P2 serials has been identified for the difference.', qty_difference_, number_of_identified_serials_);
      END IF;

      IF (number_of_identified_serials_ > 0) THEN
         FOR i IN serial_catch_tab_.FIRST..serial_catch_tab_.LAST LOOP
            IF (qty_difference_ > 0) THEN
               -- A serial is about to be put into Inventory
               IF (Part_Serial_Catalog_API.Check_Exist(part_no_, serial_catch_tab_(i).serial_no) = db_true_) THEN
                  -- The serial exists in PartSerialCatalog
                  IF (Part_Serial_Catalog_API.Is_Issued(part_no_, serial_catch_tab_(i).serial_no) = db_false_) THEN
                     -- IF the serial is not in state Issued then it cannot be put into Inventory as a positive counting difference
                     error_serial_no_    := serial_catch_tab_(i).serial_no;
                     RAISE count_serial_exist_;
                  END IF;
               ELSE
                  -- The serial number does not exist in PartSerialCatalog
                  Error_SYS.Check_Valid_Key_String('SERIAL_NO', serial_catch_tab_(i).serial_no);
                  IF (serial_catch_tab_(i).serial_no = '*') THEN
                     Error_SYS.Record_General(lu_name_,'NOTSERIALNO: The Serial Number must not be an asterisk.');
                  END IF;
                  IF (UPPER(serial_catch_tab_(i).serial_no) != serial_catch_tab_(i).serial_no) THEN
                     Error_SYS.Record_General(lu_name_,'SERIALUPPER: The Serial Number must be entered in uppercase.');
                  END IF;
                  IF (Serial_No_Reservation_API.Check_Exist(part_no_, serial_catch_tab_(i).serial_no) = db_true_) THEN
                     -- The serial number is reserved for an order and cannot be put into inventory as a positive counting difference
                     error_serial_no_    := serial_catch_tab_(i).serial_no;
                     RAISE part_rese_exist_;
                  END IF;
               END IF;
            ELSE
               -- A serial is about to be issued from Inventory
               Check_Split_Into_Serials___(lurec_, serial_catch_tab_(i).serial_no);
            END IF;
         END LOOP;
      END IF;
   END IF;

   IF (part_catalog_rec_.catch_unit_enabled = db_true_) THEN
      IF (catch_qty_counted_ IS NULL)  THEN
         Error_SYS.Record_General('InventoryPartInStock', 'CATCHQTYNEEDED: Part :P1 uses catch unit :P2 and catch quantity must be entered.',part_no_, Inventory_Part_API.Get_Catch_Unit_Meas(contract_, part_no_));
      END IF;

      IF (catch_qty_counted_ < 0) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'CATCHNONEGATIVE: The catch quantity counted must not be negative.');
      END IF;

      IF  ((qty_counted_ > 0) AND (catch_qty_counted_ = 0)) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'CATCHQTYPOSCOUNT: The catch quantity counted must be greater than zero when the quantity counted is greater than zero.');
      END IF;

      IF (qty_counted_ = 0) THEN
         IF (catch_qty_counted_ != 0) THEN
            Error_SYS.Record_General('InventoryPartInStock', 'CATCHQTYAVIL: The catch quantity counted must be zero when the quantity counted is zero.');
         END IF;
      END IF;
   END IF;

   IF (serial_no_ != '*') THEN
      IF (qty_counted_ NOT IN (0, 1)) THEN
         Error_SYS.Record_General('InventoryPartInStock', '761: The quantity may only be 0 or 1 when serial numbers are being used');
      END IF;

      serial_no_exist_ := Part_Serial_Catalog_API.Check_Exist(part_no_, serial_no_);

      IF (serial_no_exist_ = db_true_) THEN
         IF ((NVL(lurec_.qty_onhand,0) = 0) AND (NVL(qty_counted_, 0) != 0)) THEN
            IF (ignore_serial_in_different_loc_ AND Get_Other_Stock_Loc_Onhand(contract_,
                                                                               part_no_,
                                                                               configuration_id_,
                                                                               location_no_,
                                                                               lot_batch_no_,
                                                                               serial_no_,
                                                                               eng_chg_level_,
                                                                               waiv_dev_rej_no_,
                                                                               activity_seq_,
                                                                               handling_unit_id_).COUNT = 1)  THEN
               NULL;
            ELSIF (Part_Serial_Catalog_API.Is_Issued(part_no_, serial_no_) = db_false_) THEN 
               error_serial_no_    := serial_no_;
               RAISE count_serial_exist_;
            END IF;
         END IF;
      ELSE
         IF (Serial_No_Reservation_API.Check_Exist(part_no_, serial_no_) = db_true_) THEN
            error_serial_no_ := serial_no_;
            RAISE part_rese_exist_;
         END IF;
      END IF;
   END IF;

   Inventory_Part_Revision_API.Exist(contract_, part_no_, eng_chg_level_);

   IF (NVL(lurec_.qty_reserved,0) > qty_counted_) THEN
         Error_SYS.Record_General('InventoryPartInStock', '753: Counted on-hand quantity :P1 for part :P2 is less than the allocations at location :P3.', qty_counted_, part_no_, lurec_.location_no);
   END IF;

   location_type_db_ := lurec_.location_type;
   IF location_type_db_ IS NULL THEN
      location_type_db_ := Inventory_Location_API.Get_Location_Type_Db(contract_,location_no_);
   END IF;

   IF location_type_db_ NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                Inventory_Location_Type_API.DB_PRODUCTION_LINE) THEN
      picking_       := Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_PICKING);
      f_             := Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_FLOOR_STOCK);
      manufacturing_ := Inventory_Location_Type_API.Decode(Inventory_Location_Type_API.DB_PRODUCTION_LINE);
      Error_SYS.Record_General('InventoryPartInStock', 'COUNTLOCTYPE: Counting is only allowed on locations of type :P1 or :P2 or :P3', picking_, f_, manufacturing_);
   END IF;

   planning_method_ := Inventory_Part_Planning_API.Get_Planning_Method(contract_, part_no_);
   IF (planning_method_ IN ('O','K','T')) THEN
      Error_SYS.Record_General('InventoryPartInStock', 'INVALIDMRPCODE: Inventory Transactions are not permitted for parts having Planning Method :P1', planning_method_);
   END IF;
EXCEPTION
   WHEN count_serial_exist_ THEN
      latest_transaction_ := Part_Serial_Catalog_API.Get_Latest_Transaction(part_no_, error_serial_no_);
      Error_SYS.Record_General(lu_name_, 'COUNTSERIALEXIST: Not possible to count serial :P1, the current position is :P2 and the latest transaction identified for this serial is :P3', part_no_||' '||error_serial_no_, Part_Serial_Catalog_API.Get_State(part_no_, error_serial_no_), latest_transaction_);
   WHEN part_rese_exist_ THEN
      Serial_No_Reservation_API.Get_Reservation_Info(order_ref1_,
                                                     order_ref2_,
                                                     order_ref3_,
                                                     order_ref4_,
                                                     source_,
                                                     part_no_,
                                                     error_serial_no_);
      Error_SYS.Record_General(lu_name_, 'PARTRESEEXIST: Not possible to use serial number :P1 for part :P2. It is reserved for order no :P3', error_serial_no_, part_no_, order_ref1_);
END Validate_Count_Part;


-- Unissue_And_Move_Part
--   This will unissue inventory parts issued in a previous transaction
--   and move them into the destination location.
PROCEDURE Unissue_And_Move_Part (
   transaction_id_       OUT NUMBER,
   unissue_transaction_  IN  VARCHAR2,
   pos_diff_transaction_ IN  VARCHAR2,
   neg_diff_transaction_ IN  VARCHAR2,
   quantity_             IN  NUMBER,
   catch_quantity_       IN  NUMBER,
   transaction_id_issue_ IN  NUMBER,
   source_               IN  VARCHAR2,
   destination_location_ IN  VARCHAR2,
   new_handling_unit_id_ IN  NUMBER DEFAULT NULL )
IS
   invtrans_rec_                Inventory_Transaction_Hist_API.Public_Rec;
   serial_catch_tab_            Serial_Catch_Table;
   expiration_date_             DATE;
   local_catch_quantity_        NUMBER;
   local_handling_unit_id_      NUMBER;
   serial_no_for_stock_         INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE;
   location_type_db_            INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   part_catalog_rec_            Part_Catalog_API.Public_Rec;
   deviating_handling_unit_id_  BOOLEAN := FALSE;
   deviating_location_no_       BOOLEAN := FALSE;
   validate_hu_struct_position_ BOOLEAN := TRUE;
   local_order_no_              VARCHAR2(50);
   local_order_type_            VARCHAR2(50);
BEGIN
   local_catch_quantity_          := catch_quantity_;
   invtrans_rec_                  := Inventory_Transaction_Hist_API.get(transaction_id_issue_);
   invtrans_rec_.activity_seq     := NVL(invtrans_rec_.activity_seq, 0);
   invtrans_rec_.handling_unit_id := NVL(invtrans_rec_.handling_unit_id, 0);
   Inventory_Event_Manager_API.Start_Session;

   IF ((new_handling_unit_id_ IS NOT NULL) AND (new_handling_unit_id_ != invtrans_rec_.handling_unit_id)) THEN
      -- The stock qty will be put back into stock on another handling unit ID than it was issued from.
      deviating_handling_unit_id_ := TRUE;
   END IF;

   IF ((destination_location_ IS NOT NULL) AND (destination_location_ != invtrans_rec_.location_no)) THEN
      -- The stock qty will be put back into stock on another location no than it was issued from.
      deviating_location_no_ := TRUE;
   END IF;

   IF (deviating_handling_unit_id_ OR deviating_location_no_) THEN

      validate_hu_struct_position_ := FALSE;
      part_catalog_rec_            := Part_Catalog_API.Get(invtrans_rec_.part_no);
      location_type_db_            := Inventory_Location_API.Get_Location_Type_db(invtrans_rec_.contract,invtrans_rec_.location_no);
      local_handling_unit_id_      := NVL(new_handling_unit_id_, invtrans_rec_.handling_unit_id);
      serial_no_for_stock_         := Get_Serial_No_For_Stock(invtrans_rec_.part_no,
                                                              invtrans_rec_.serial_no,
                                                              part_catalog_rec_,
                                                              location_type_db_,
                                                              invtrans_rec_.handling_unit_id);
   END IF;

   Unissue_Part(transaction_id_              => transaction_id_,
                unissue_transaction_         => unissue_transaction_,
                pos_diff_transaction_        => pos_diff_transaction_,
                neg_diff_transaction_        => neg_diff_transaction_,
                quantity_                    => quantity_,
                catch_quantity_              => local_catch_quantity_,
                transaction_id_issue_        => transaction_id_issue_,
                source_                      => source_,
                validate_hu_struct_position_ => validate_hu_struct_position_);

   IF (deviating_handling_unit_id_) THEN

      IF ((invtrans_rec_.handling_unit_id  = 0  ) AND
          (invtrans_rec_.serial_no        != '*') AND 
          (serial_no_for_stock_            = '*')) THEN
         -- The issue was for an unpacked serial which is not tracked in inventory. So we have received it back into a stock record
         -- having serial_no = '*'.
         serial_no_for_stock_ := Get_Serial_No_For_Stock(invtrans_rec_.part_no,
                                                         invtrans_rec_.serial_no,
                                                         part_catalog_rec_,
                                                         location_type_db_,
                                                         new_handling_unit_id_);
         IF (serial_no_for_stock_ != '*') THEN
            -- Now since we are going to pack it into a handling unit we need to get back to the serial-specific stock record again,
            -- since it is not allowed to pack serial tracked parts into handling units wihtout specifying the serial number. 

            serial_catch_tab_(1).serial_no := invtrans_rec_.serial_no;
            serial_catch_tab_(1).catch_qty := invtrans_rec_.catch_quantity;

            Split_Into_Serials(contract_           => invtrans_rec_.contract,         
                               part_no_            => invtrans_rec_.part_no,          
                               configuration_id_   => invtrans_rec_.configuration_id, 
                               location_no_        => invtrans_rec_.location_no,      
                               lot_batch_no_       => invtrans_rec_.lot_batch_no,     
                               eng_chg_level_      => invtrans_rec_.eng_chg_level,     
                               waiv_dev_rej_no_    => invtrans_rec_.waiv_dev_rej_no,   
                               activity_seq_       => invtrans_rec_.activity_seq,      
                               handling_unit_id_   => invtrans_rec_.handling_unit_id,
                               serial_catch_tab_   => serial_catch_tab_,
                               reservation_        => FALSE);
         END IF;
      END IF;

      Change_Handling_Unit_Id(contract_                    => invtrans_rec_.contract,        
                              part_no_                     => invtrans_rec_.part_no,         
                              configuration_id_            => invtrans_rec_.configuration_id,
                              location_no_                 => invtrans_rec_.location_no,     
                              lot_batch_no_                => invtrans_rec_.lot_batch_no,    
                              serial_no_                   => serial_no_for_stock_,          
                              eng_chg_level_               => invtrans_rec_.eng_chg_level,   
                              waiv_dev_rej_no_             => invtrans_rec_.waiv_dev_rej_no, 
                              activity_seq_                => invtrans_rec_.activity_seq,    
                              old_handling_unit_id_        => invtrans_rec_.handling_unit_id,
                              new_handling_unit_id_        => new_handling_unit_id_,
                              quantity_                    => quantity_,
                              catch_quantity_              => local_catch_quantity_,
                              validate_hu_struct_position_ => NOT deviating_location_no_); -- No point in validating structure now if Move_Part is called below
   END IF;

   IF (deviating_location_no_) THEN

      expiration_date_ := Get_Expiration_Date(invtrans_rec_.contract,
                                              invtrans_rec_.part_no,
                                              invtrans_rec_.configuration_id,
                                              invtrans_rec_.location_no,
                                              invtrans_rec_.lot_batch_no,
                                              serial_no_for_stock_,
                                              invtrans_rec_.eng_chg_level,
                                              invtrans_rec_.waiv_dev_rej_no,
                                              invtrans_rec_.activity_seq,
                                              local_handling_unit_id_);
      
      IF invtrans_rec_.alt_source_ref_type = Order_Type_API.DB_PURCH_RECEIPT_RETURN THEN
         local_order_type_ := Order_Type_API.Decode(invtrans_rec_.alt_source_ref_type);
         local_order_no_   := invtrans_rec_.alt_source_ref1;
      END IF;
      
      Move_Part(catch_quantity_              => local_catch_quantity_,
                contract_                    => invtrans_rec_.contract,
                part_no_                     => invtrans_rec_.part_no,
                configuration_id_            => invtrans_rec_.configuration_id,
                location_no_                 => invtrans_rec_.location_no,
                lot_batch_no_                => invtrans_rec_.lot_batch_no,
                serial_no_                   => serial_no_for_stock_,
                eng_chg_level_               => invtrans_rec_.eng_chg_level,
                waiv_dev_rej_no_             => invtrans_rec_.waiv_dev_rej_no,
                activity_seq_                => invtrans_rec_.activity_seq,
                handling_unit_id_            => local_handling_unit_id_,
                expiration_date_             => expiration_date_,
                to_contract_                 => invtrans_rec_.contract,
                to_location_no_              => destination_location_,
                to_destination_              => Inventory_Part_Destination_API.Decode('N'),
                quantity_                    => quantity_,
                quantity_reserved_           => 0,
                move_comment_                => NULL,
                validate_hu_struct_position_ => TRUE,
                order_no_                    => local_order_no_,
                order_type_                  => local_order_type_);
   END IF;

   Inventory_Event_Manager_API.Finish_Session;

END Unissue_And_Move_Part;


--  *********************  NOTE!  ******************************
--  *                                                          *
--  *  THIS METHOD MUST NOT UNDER ANY CIRCUMSTANCES BE CALLED  *
--  *  FROM ANYWHERE ELSE THAN FROM PART_SERIAL_CATALOG_API.   *
--  *                                                          *
--  ************************************************************
--  This Method changes the serial_no of an individual placed in inventory.
PROCEDURE Rename_Serial (
   part_no_       IN VARCHAR2,
   serial_no_     IN VARCHAR2,
   new_part_no_   IN VARCHAR2,
   new_serial_no_ IN VARCHAR2 )
IS
   is_in_inventory_           VARCHAR2(10);
   catch_quantity_            NUMBER := NULL;
   rec_                       INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   serial_catch_tab_          Serial_Catch_Table;
   old_serial_rec_            Part_Serial_Catalog_API.Public_Rec;
   old_part_rec_              Part_Catalog_API.Public_Rec;
   latest_inv_transaction_id_ NUMBER;
   inv_trans_hist_rec_        Inventory_Transaction_Hist_API.Public_Rec;
   check_location_            VARCHAR2(5);

   CURSOR get_rec IS
      SELECT *
      FROM  INVENTORY_PART_IN_STOCK_TAB
      WHERE  part_no        = part_no_
        AND  serial_no      = serial_no_
        AND (qty_onhand     = 1
         OR  qty_in_transit = 1);
   
   CURSOR get_alt_rec IS
      SELECT *
      FROM  INVENTORY_PART_IN_STOCK_TAB
      WHERE      part_no                           =     part_no_
        AND      contract                          =     inv_trans_hist_rec_.contract
        AND      serial_no                         =     '*'
        AND      configuration_id                  =     old_serial_rec_.configuration_id
        AND      lot_batch_no                      = NVL(old_serial_rec_.lot_batch_no      , lot_batch_no)
        AND      part_ownership                    =     old_serial_rec_.part_ownership
        AND  NVL(owning_customer_no, string_null_) = NVL(old_serial_rec_.owning_customer_no, string_null_)
        AND  NVL(owning_vendor_no  , string_null_) = NVL(old_serial_rec_.owning_vendor_no  , string_null_)
        AND     (qty_onhand - qty_reserved)       >=     1
        AND      location_type                    IN    (Inventory_Location_Type_API.DB_PICKING,
                                                         Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                                         Inventory_Location_Type_API.DB_PRODUCTION_LINE)
        AND     (location_no                      = inv_trans_hist_rec_.location_no OR check_location_ = db_false_);
BEGIN
   IF part_no_ IS NULL THEN
      Error_SYS.Record_General('InventoryPartInStock','RSNPNULL: Old Part No must have a value.');
   END IF;

   IF serial_no_ IS NULL THEN
      Error_SYS.Record_General('InventoryPartInStock','RSNOSNULL: Old Serial No must have a value.');
   END IF;

   IF new_part_no_ IS NULL THEN
      Error_SYS.Record_General('InventoryPartInStock','RSOPNULL: New Part No must have a value.');
   END IF;

   IF new_serial_no_ IS NULL THEN
      Error_SYS.Record_General('InventoryPartInStock','RSNPSNULL: New Serial No must have a value.');
   END IF;

   is_in_inventory_ := Part_Serial_Catalog_API.Is_In_Inventory(part_no_, serial_no_);

   IF (is_in_inventory_ = db_false_) THEN
      Raise_Inconsistency_Error___;
   END IF;

   Invent_Part_Serial_Manager_API.Check_Rename(part_no_,
                                               serial_no_,
                                               new_part_no_,
                                               new_serial_no_);


   Inventory_Event_Manager_API.Start_Session;
   IF (Check_Individual_Exist(part_no_, serial_no_) = 0) THEN

      old_part_rec_ := Part_Catalog_API.Get(part_no_);

      IF (old_part_rec_.serial_tracking_code = db_not_serial_tracking_) THEN
         latest_inv_transaction_id_ := Part_Serial_History_API.Get_Latest_Inv_Transaction_Id(part_no_, serial_no_);
         inv_trans_hist_rec_        := Inventory_Transaction_Hist_API.Get(latest_inv_transaction_id_);
         old_serial_rec_            := Part_Serial_Catalog_API.Get(part_no_, serial_no_);
         check_location_            := db_true_;

         OPEN  get_alt_rec;
         FETCH get_alt_rec INTO rec_;
         IF (get_alt_rec%FOUND) THEN
            CLOSE get_alt_rec;
         ELSE
            CLOSE get_alt_rec;
            check_location_ := db_false_;
            OPEN get_alt_rec;
            FETCH get_alt_rec INTO rec_;
            CLOSE get_alt_rec;
         END IF;
      END IF;

      serial_catch_tab_(1).serial_no := serial_no_;

      Split_Into_Serials(contract_           => rec_.contract,
                         part_no_            => rec_.part_no,
                         configuration_id_   => rec_.configuration_id,
                         location_no_        => rec_.location_no,
                         lot_batch_no_       => rec_.lot_batch_no,
                         eng_chg_level_      => rec_.eng_chg_level,
                         waiv_dev_rej_no_    => rec_.waiv_dev_rej_no,
                         activity_seq_       => rec_.activity_seq,
                         handling_unit_id_   => rec_.handling_unit_id,
                         serial_catch_tab_   => serial_catch_tab_,
                         reservation_        => FALSE);
   END IF;

   OPEN get_rec;
   FETCH get_rec INTO rec_;
   CLOSE get_rec;

   IF (Invent_Part_Quantity_Util_API.Check_Individual_Exist(new_part_no_, new_serial_no_) = 1) THEN
      -- When this code is excuted, the to serial part cannot exists in Inventory (InInventory), in Transit (UnderTransportation) or at customer since the Part Serial Catalog suggests that the to serial part is in state Unlocated
      Raise_Inconsistency_Error___;
   END IF;

   IF NVL(rec_.part_ownership, Part_Ownership_API.DB_COMPANY_OWNED) NOT IN ('COMPANY OWNED',
                                                                            'CUSTOMER OWNED',
                                                                            'SUPPLIER LOANED') THEN
      Error_SYS.Record_General('InventoryPartInStock','RSINVALIDOWNERSHIP: Serial <:P1> in Site :P2, may not be renamed when the Ownership is :P3', part_no_||','||serial_no_, rec_.contract, Part_Ownership_API.Decode(NVL(rec_.part_ownership, Part_Ownership_API.DB_COMPANY_OWNED)));
   END IF;

   IF (rec_.qty_in_transit > 0) THEN
      Error_SYS.Record_General('InventoryPartInStock','RSNTRANSIT: Serial <:P1> is currently under transportation to location :P2, renamed not allowed.', part_no_||','||serial_no_, rec_.contract||' - '||rec_.location_no);
   END IF;
   IF (Inventory_Part_In_Transit_API.Check_Individual_Exist(part_no_, serial_no_) = db_true_) THEN
      Error_SYS.Record_General('InventoryPartInStock','RSNORDERTRANSIT: Serial <:P1> is currently under order transit, renamed not allowed.', part_no_||','||serial_no_);
   END IF;

   IF (rec_.qty_reserved > 0) THEN
      Error_SYS.Record_General('InventoryPartInStock','RSNRESERVE: Serial <:P1> is reserved in inventory, renamed not allowed.', part_no_||','||serial_no_);
   END IF;

   IF (rec_.location_type NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                  Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                  Inventory_Location_Type_API.DB_PRODUCTION_LINE)) THEN
      Error_SYS.Record_General('InventoryPartInStock','RSNLOCTYPE: A serial cannot be renamed when stored on an inventory location of type :P1', Inventory_Location_Type_API.Decode(rec_.location_type));
   END IF;

   IF (part_no_ != new_part_no_) OR (serial_no_ != new_serial_no_) THEN
      Move_Part_Impl___(catch_quantity_                => catch_quantity_,
                        contract_                      => rec_.contract,
                        part_no_                       => rec_.part_no,
                        configuration_id_              => rec_.configuration_id,
                        location_no_                   => rec_.location_no,
                        lot_batch_no_                  => rec_.lot_batch_no,
                        serial_no_                     => rec_.serial_no,
                        eng_chg_level_                 => rec_.eng_chg_level,
                        waiv_dev_rej_no_               => rec_.waiv_dev_rej_no,
                        activity_seq_                  => rec_.activity_seq,
                        handling_unit_id_              => rec_.handling_unit_id,
                        expiration_date_               => rec_.expiration_date,
                        to_contract_                   => rec_.contract,
                        to_part_no_                    => new_part_no_,
                        to_location_no_                => rec_.location_no,
                        to_destination_db_             => 'N',
                        to_waiv_dev_rej_no_            => rec_.waiv_dev_rej_no,
                        to_lot_batch_no_               => rec_.lot_batch_no,
                        to_serial_no_                  => new_serial_no_,
                        to_activity_seq_               => rec_.activity_seq,
                        to_handling_unit_id_           => rec_.handling_unit_id,
                        quantity_                      => rec_.qty_onhand,
                        quantity_reserved_             => 0,
                        move_comment_                  => NULL,
                        order_no_                      => NULL,
                        line_no_                       => NULL,
                        release_no_                    => NULL,
                        line_item_no_                  => NULL,
                        source_ref5_                   => NULL,
                        order_type_                    => NULL,
                        consume_consignment_stock_     => FALSE,
                        make_transaction_and_postings_ => TRUE,
                        report_earned_value_db_        => NULL,
                        from_part_catalog_rec_         => NULL,
                        to_part_catalog_rec_           => NULL,
                        transport_task_id_             => NULL,
                        validate_hu_struct_position_   => FALSE,
                        availability_ctrl_id_          => NULL,
                        always_preserve_serial_no_     => FALSE,
                        ownership_transfer_reason_id_  => NULL);
   END IF;
   Inventory_Event_Manager_API.Finish_Session;
END Rename_Serial;


-- Is_Reserved_At_Any_Location
--   This will return db_true_ if an inventory part with a given serial
--   and lot batch no is reserved at any location. 'FALSE' otherwise.
--   EBALL-37, Modified method by removing call to Inventory_Part_In_Transit_API
@UncheckedAccess
FUNCTION Is_Reserved_At_Any_Location (
   part_no_      IN VARCHAR2,
   serial_no_    IN VARCHAR2,
   lot_batch_no_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_ NUMBER;
   CURSOR check_reserved IS
      SELECT 1
      FROM INVENTORY_PART_IN_STOCK_TAB
      WHERE  part_no      = part_no_
        AND (serial_no    = serial_no_    OR serial_no_    IS NULL)
        AND (lot_batch_no = lot_batch_no_ OR lot_batch_no_ IS NULL)
        AND  qty_reserved != 0;
BEGIN
   OPEN check_reserved;
   FETCH check_reserved INTO dummy_;
   IF (check_reserved%FOUND) THEN
      CLOSE check_reserved;
      RETURN(TRUE);
   END IF;
   CLOSE check_reserved;
   RETURN(FALSE);
END Is_Reserved_At_Any_Location;


-- Check_Lot_Batch_Exist
--   Checks if there is a quantity on hand for this LotBatch in the inventory.
--   Return 1 if there is a quantity otherwise 0
@UncheckedAccess
FUNCTION Check_Lot_Batch_Exist (
   part_no_      IN VARCHAR2,
   lot_batch_no_ IN VARCHAR2 ) RETURN NUMBER
IS
   CURSOR check_part_loc IS
      SELECT 1
      FROM INVENTORY_PART_IN_STOCK_TAB
      WHERE part_no      = part_no_
        AND lot_batch_no = lot_batch_no_
        AND (qty_onhand != 0 OR qty_in_transit != 0);

   exist_   NUMBER;
BEGIN
   OPEN check_part_loc;
   FETCH check_part_loc INTO exist_;
   IF check_part_loc%NOTFOUND THEN
      exist_ := 0;
   END IF;
   CLOSE check_part_loc;
   RETURN(exist_);
END Check_Lot_Batch_Exist;


-- Modify_Rotable_Part_Pool_Id
--   This will update the Rotable Pool ID and the Availability Control Id
--   of an inventory part given in a specific inventory part location.
PROCEDURE Modify_Rotable_Part_Pool_Id (
   contract_                     IN VARCHAR2,
   part_no_                      IN VARCHAR2,
   configuration_id_             IN VARCHAR2,
   location_no_                  IN VARCHAR2,
   lot_batch_no_                 IN VARCHAR2,
   serial_no_                    IN VARCHAR2,
   eng_chg_level_                IN VARCHAR2,
   waiv_dev_rej_no_              IN VARCHAR2,
   activity_seq_                 IN NUMBER,
   handling_unit_id_             IN NUMBER,
   rotable_part_pool_id_         IN VARCHAR2 DEFAULT NULL,
   part_availability_control_id_ IN VARCHAR2 DEFAULT NULL )
IS
   oldrec_ INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   newrec_ INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
BEGIN
   IF activity_seq_ > 0 THEN
      Error_SYS.Record_General(lu_name_, 'PINOTALLOWED: Project inventory parts are not allowed to be added to the rotable pool.');
   END IF;

   oldrec_ := Lock_By_Keys___(contract_,
                              part_no_,
                              configuration_id_,
                              location_no_,
                              lot_batch_no_,
                              serial_no_,
                              eng_chg_level_,
                              waiv_dev_rej_no_,
                              activity_seq_,
                              handling_unit_id_);

   newrec_                         := oldrec_;
   newrec_.rotable_part_pool_id    := rotable_part_pool_id_;
   newrec_.availability_control_id := part_availability_control_id_;

   Check_And_Update_By_Keys___(oldrec_ => oldrec_, newrec_ => newrec_);
END Modify_Rotable_Part_Pool_Id;


-- Get_Rotable_Part_Pool_Qty
--   Get the total quantity on hand for a given Rotable Part Pool ID
@UncheckedAccess
FUNCTION Get_Rotable_Part_Pool_Qty (
   rotable_part_pool_id_ IN VARCHAR2 ) RETURN NUMBER
IS
   actual_ NUMBER;
   CURSOR pool_count IS
      SELECT SUM(qty_onhand)
      FROM   INVENTORY_PART_IN_STOCK_TAB
      WHERE  rotable_part_pool_id = rotable_part_pool_id_;
BEGIN
   OPEN pool_count;
   FETCH pool_count INTO actual_;
   CLOSE pool_count;
   RETURN NVL(actual_, 0);
END Get_Rotable_Part_Pool_Qty;


FUNCTION Is_Part_In_Fa_Rotable_Pool (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN NUMBER
IS
   dummy_   NUMBER;

   CURSOR check_exist IS
      SELECT 1
      FROM INVENTORY_PART_IN_STOCK_TAB i, ROTABLE_PART_POOL_TAB r
      WHERE i.contract = contract_
      AND   i.part_no = part_no_
      AND   r.rotable_pool_asset_type = 'FIXED ASSET'
      AND   i.rotable_part_pool_id IS NOT NULL
      AND   i.rotable_part_pool_id = r.rotable_part_pool_id;
BEGIN
   OPEN check_exist;
   FETCH check_exist INTO dummy_;
   IF (check_exist%FOUND) THEN
      CLOSE check_exist;
      RETURN 1;
   END IF;
   CLOSE check_exist;
   RETURN 0;
END Is_Part_In_Fa_Rotable_Pool;


@UncheckedAccess
PROCEDURE Get_Company_Owned_Inventory (
   qty_onhand_       OUT NUMBER,
   qty_in_transit_   OUT NUMBER,
   contract_         IN  VARCHAR2,
   part_no_          IN  VARCHAR2,
   configuration_id_ IN  VARCHAR2,
   lot_batch_no_     IN  VARCHAR2 DEFAULT NULL,
   serial_no_        IN  VARCHAR2 DEFAULT NULL )
IS
   CURSOR get_qty_in_details IS
      SELECT SUM(qty_onhand), SUM(qty_in_transit)
      FROM   inventory_part_in_stock_tab ips, rotable_part_pool_tab rpp
      WHERE  ips.contract         = contract_
        AND  ips.part_no          = part_no_
        AND  ips.configuration_id = configuration_id_
        AND  ips.lot_batch_no     = lot_batch_no_
        AND  ips.serial_no        = serial_no_
        AND  ips.rotable_part_pool_id    = rpp.rotable_part_pool_id (+)
        AND (rpp.rotable_pool_asset_type = 'INVENTORY ASSET' OR rpp.rotable_pool_asset_type IS NULL )
        AND (ips.part_ownership          = 'COMPANY OWNED'   OR ips.part_ownership IS NULL );

   CURSOR get_qty IS
      SELECT SUM(qty_onhand), SUM(qty_in_transit)
      FROM   inventory_part_in_stock_tab ips, rotable_part_pool_tab rpp
      WHERE  ips.contract          = contract_
        AND  ips.part_no           = part_no_
        AND  (ips.configuration_id = configuration_id_ OR configuration_id_ IS NULL)
        AND  (ips.lot_batch_no     = lot_batch_no_     OR lot_batch_no_     IS NULL)
        AND  (ips.serial_no        = serial_no_        OR serial_no_        IS NULL)
        AND  ips.rotable_part_pool_id     = rpp.rotable_part_pool_id (+)
        AND  (rpp.rotable_pool_asset_type = 'INVENTORY ASSET' OR rpp.rotable_pool_asset_type IS NULL )
        AND (ips.part_ownership           = 'COMPANY OWNED'   OR ips.part_ownership IS NULL );
BEGIN
   IF(configuration_id_ IS NOT NULL AND lot_batch_no_ IS NOT NULL AND serial_no_ IS NOT NULL) THEN
      OPEN get_qty_in_details;
      FETCH get_qty_in_details INTO qty_onhand_, qty_in_transit_;
      CLOSE get_qty_in_details;
   ELSE
      OPEN get_qty;
      FETCH get_qty INTO qty_onhand_, qty_in_transit_;
      CLOSE get_qty;
   END IF;

   qty_onhand_ := NVL(qty_onhand_, 0);
   qty_in_transit_ := NVL(qty_in_transit_, 0);
END Get_Company_Owned_Inventory;


@UncheckedAccess
FUNCTION Get_Company_Owned_Inventory (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2) RETURN Config_Lot_Serial_Tab
IS
   stock_tab_   Config_Lot_Serial_Tab;
   
   CURSOR Get_Company_Owned_Inventory IS 
      SELECT ipis.configuration_id                             configuration_id,
             ipis.lot_batch_no                                 lot_batch_no,
             ipis.serial_no                                    serial_no,
             SUM(ipis.qty_onhand + ipis.qty_in_transit)        sum_quantity
      FROM   inventory_part_in_stock_tab  ipis
      WHERE  ipis.contract          = contract_
        AND  ipis.part_no           = part_no_
        AND  (ipis.configuration_id = configuration_id_ OR configuration_id_ IS NULL)
        AND  NOT EXISTS (SELECT 1
                         FROM  rotable_part_pool_tab rpp
                         WHERE rpp.rotable_part_pool_id    = ipis.rotable_part_pool_id
                         AND   rpp.rotable_pool_asset_type = 'FIXED ASSET')
        AND ipis.part_ownership = 'COMPANY OWNED' 
        AND (ipis.qty_onhand != 0 OR ipis.qty_in_transit != 0)
   GROUP BY ipis.configuration_id, ipis.lot_batch_no,ipis.serial_no;

BEGIN
   OPEN  Get_Company_Owned_Inventory;
   FETCH Get_Company_Owned_Inventory BULK COLLECT INTO stock_tab_;
   CLOSE Get_Company_Owned_Inventory;

   RETURN (stock_tab_);
END Get_Company_Owned_Inventory;


@UncheckedAccess
FUNCTION Get_Externally_Owned_Inventory (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2 DEFAULT NULL,
   serial_no_        IN VARCHAR2 DEFAULT NULL,
   part_ownership_   IN VARCHAR2 DEFAULT NULL ) RETURN NUMBER
IS
   qty_onhand_     NUMBER;
   qty_in_transit_ NUMBER;

   CURSOR get_qty IS
      SELECT SUM(qty_onhand), SUM(qty_in_transit)
      FROM   INVENTORY_PART_IN_STOCK_TAB
      WHERE  part_no  = part_no_
      AND  contract = contract_
      AND (configuration_id    = configuration_id_ OR configuration_id_ IS NULL)
      AND (lot_batch_no        = lot_batch_no_     OR lot_batch_no_     IS NULL)
      AND (serial_no           = serial_no_        OR serial_no_        IS NULL)
      AND (part_ownership      = part_ownership_   OR part_ownership_   IS NULL)
      AND (NVL(part_ownership, Part_Ownership_API.DB_COMPANY_OWNED)     != 'COMPANY OWNED');
BEGIN
   OPEN get_qty;
   FETCH get_qty INTO qty_onhand_, qty_in_transit_;
   CLOSE get_qty;
   RETURN NVL(qty_onhand_ + qty_in_transit_, 0);
END Get_Externally_Owned_Inventory;


-- Check_Quantity_Exist
--   Checks whether qty on hand exists for specific owner types
@UncheckedAccess
FUNCTION Check_Quantity_Exist (
   contract_                      IN VARCHAR2,
   part_no_                       IN VARCHAR2,
   configuration_id_              IN VARCHAR2,
   lot_batch_no_                  IN VARCHAR2 DEFAULT NULL,
   serial_no_                     IN VARCHAR2 DEFAULT NULL,
   exclude_customer_owned_stock_  IN VARCHAR2 DEFAULT 'FALSE',
   exclude_supplier_loaned_stock_ IN VARCHAR2 DEFAULT 'FALSE',
   exclude_consignment_stock_     IN VARCHAR2 DEFAULT 'FALSE',
   exclude_supplier_owned_stock_  IN VARCHAR2 DEFAULT 'FALSE',
   exclude_company_owned_         IN VARCHAR2 DEFAULT 'FALSE',
   exclude_supplier_rented_stock_ IN VARCHAR2 DEFAULT 'FALSE',
   exclude_company_rental_stock_  IN VARCHAR2 DEFAULT 'FALSE',
   exclude_fixed_asset_pool_      IN VARCHAR2 DEFAULT 'FALSE' ) RETURN VARCHAR2
IS
   dummy_                   NUMBER;
   qty_found_               BOOLEAN;
   db_company_owned_        CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_COMPANY_OWNED;
   db_consignment_          CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_CONSIGNMENT;
   db_supplier_loaned_      CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_SUPPLIER_LOANED;
   db_supplier_owned_       CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_SUPPLIER_OWNED;
   db_customer_owned_       CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_CUSTOMER_OWNED;
   db_company_rental_asset_ CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_COMPANY_RENTAL_ASSET;
   db_supplier_rented_      CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_SUPPLIER_RENTED;

   CURSOR check_exist IS
      SELECT 1
      FROM   INVENTORY_PART_IN_STOCK_TAB ips, rotable_part_pool_tab rpp
      WHERE (ips.qty_onhand != 0    OR ips.qty_in_transit != 0)
        AND ips.contract     = contract_
        AND ips.part_no      = part_no_
        AND ((NVL(ips.part_ownership, db_company_owned_) = db_supplier_loaned_       AND exclude_supplier_loaned_stock_  = db_false_)
          OR (NVL(ips.part_ownership, db_company_owned_) = db_customer_owned_        AND exclude_customer_owned_stock_   = db_false_)
          OR (NVL(ips.part_ownership, db_company_owned_) = db_consignment_           AND exclude_consignment_stock_      = db_false_)
          OR (NVL(ips.part_ownership, db_company_owned_) = db_supplier_owned_        AND exclude_supplier_owned_stock_   = db_false_)
          OR (NVL(ips.part_ownership, db_company_owned_) = db_company_owned_         AND exclude_company_owned_          = db_false_)
          OR (NVL(ips.part_ownership, db_company_owned_) = db_supplier_rented_       AND exclude_supplier_rented_stock_  = db_false_)
          OR (NVL(ips.part_ownership, db_company_owned_) = db_company_rental_asset_  AND exclude_company_rental_stock_   = db_false_))
        AND ips.rotable_part_pool_id = rpp.rotable_part_pool_id (+)
        AND ((NVL(rpp.rotable_pool_asset_type,'INVENTORY ASSET') = 'FIXED ASSET' AND exclude_fixed_asset_pool_ = db_false_) OR (ips.rotable_part_pool_id IS NULL))
        AND (ips.configuration_id = configuration_id_ OR configuration_id_ IS NULL)
        AND (ips.lot_batch_no     = lot_batch_no_     OR lot_batch_no_     IS NULL)
        AND (ips.serial_no        = serial_no_        OR serial_no_        IS NULL);
BEGIN
   OPEN check_exist;
   FETCH check_exist INTO dummy_;
   IF (check_exist%FOUND) THEN
      qty_found_ := TRUE;
   ELSE
      qty_found_ := FALSE;
   END IF;
   CLOSE check_exist;

   IF (qty_found_) THEN
      RETURN db_true_;
   ELSE
      RETURN db_false_;
   END IF;
END Check_Quantity_Exist;


-- Receipt_In_Place
--   Used to Create Receipt(s) in Place for corresponding Inventory Part
--   In Stock lines connected to a Purchase Order Line that is used for
--   the Transfer of Ownership.
PROCEDURE Receipt_In_Place (
   transfer_tab_   IN Inv_Part_Ownership_Manager_API.ownership_transfer_table,
   cost_detail_id_ IN NUMBER DEFAULT NULL)
IS
   transaction_id_        NUMBER;
   transaction_code_      VARCHAR2(10);
   dummy_number_          NUMBER;
   oldrec_                INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   newrec_                INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   empty_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   message_               VARCHAR2(500);
   has_single_ownership_  VARCHAR2(10);
   serial_catch_tab_      Serial_Catch_Table;
   local_quantity_        NUMBER;
   cost_detail_tab_       Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   part_catalog_rec_      Part_Catalog_API.Public_Rec;
   quantity_              INVENTORY_PART_IN_STOCK_TAB.QTY_ONHAND%TYPE;
   order_type_db_         VARCHAR2(20);
BEGIN
   Fill_Part_Stock_Owner_Tmp___(transfer_tab_);
   Inventory_Event_Manager_API.Start_Session;

   FOR index_ IN transfer_tab_.FIRST..transfer_tab_.LAST LOOP
      serial_catch_tab_.DELETE;

      IF (transfer_tab_(index_).part_tracking_session_id IS NULL) THEN
         serial_catch_tab_(1).serial_no := transfer_tab_(index_).serial_no;
         local_quantity_                := transfer_tab_(index_).qty;
      ELSE
         Temporary_Part_Tracking_API.Get_Serials_And_Remove_Session(serial_catch_tab_,
                                                                    transfer_tab_(index_).part_tracking_session_id);

         IF (serial_catch_tab_.COUNT = 0) THEN
            Error_SYS.Record_General('InventoryPartInStock', 'REINPLNOSERIAL: No serials have been identified for the ownership transfer.');
         END IF;

         IF (serial_catch_tab_.COUNT != transfer_tab_(index_).qty) THEN
            Error_SYS.Record_General('InventoryPartInStock', 'REINPLSERCOUNTQO: The quantity of the ownership transfer is :P1 but the number of identified serials is :P2', transfer_tab_(index_).qty, serial_catch_tab_.COUNT);
         END IF;

         Split_Into_Serials(contract_           => transfer_tab_(index_).contract,
                            part_no_            => transfer_tab_(index_).part_no,
                            configuration_id_   => transfer_tab_(index_).configuration_id,
                            location_no_        => transfer_tab_(index_).location_no,
                            lot_batch_no_       => transfer_tab_(index_).lot_batch_no,
                            eng_chg_level_      => transfer_tab_(index_).eng_chg_level,
                            waiv_dev_rej_no_    => transfer_tab_(index_).waiv_dev_rej_no,
                            activity_seq_       => transfer_tab_(index_).activity_seq,
                            handling_unit_id_   => transfer_tab_(index_).handling_unit_id,
                            serial_catch_tab_   => serial_catch_tab_,
                            reservation_        => FALSE);
         local_quantity_ := 1;
      END IF;

      FOR i IN serial_catch_tab_.FIRST..serial_catch_tab_.LAST LOOP
         oldrec_ := Lock_By_Keys___(transfer_tab_(index_).contract,
                                    transfer_tab_(index_).part_no,
                                    transfer_tab_(index_).configuration_id,
                                    transfer_tab_(index_).location_no,
                                    transfer_tab_(index_).lot_batch_no,
                                    serial_catch_tab_(i).serial_no,
                                    transfer_tab_(index_).eng_chg_level,
                                    transfer_tab_(index_).waiv_dev_rej_no,
                                    transfer_tab_(index_).activity_seq,
                                    transfer_tab_(index_).handling_unit_id);

         Check_Transfer_To_Own_Stock___(oldrec_,
                                        local_quantity_,
                                        transfer_tab_(index_).order_type);                           
         IF(oldrec_.part_ownership != transfer_tab_(index_).part_ownership ) THEN
            Error_SYS.Record_General(lu_name_, 'OWNERSHIPNOTSAME: Transfer of Ownership to Company is allowed only when transferring data ownership info is matching with ownership info on the stock record.');
         END IF;

         IF (oldrec_.part_ownership = Part_Ownership_API.DB_SUPPLIER_LOANED) THEN
            IF(oldrec_.owning_vendor_no != transfer_tab_(index_).owner) THEN
               Error_SYS.Record_General(lu_name_, 'VENDORMISMATCH: Transfer of Ownership to Company is allowed only when transferring owner is same as the vendor in the stock record.');
            END IF;
         ELSIF (oldrec_.part_ownership = Part_Ownership_API.DB_CUSTOMER_OWNED) THEN
            IF(oldrec_.owning_customer_no != transfer_tab_(index_).owner) THEN
               Error_SYS.Record_General(lu_name_, 'CUSTOMERMISMATCH: Transfer of Ownership to Company is allowed only when transferring owner is same as the customer in the stock record.');
            END IF;
         ELSE
            Raise_Trf_Ownership_Error___(oldrec_.part_ownership);
         END IF;
          -- Check Structure Ownership for serial tracked parts
         IF (oldrec_.serial_no != '*') THEN
            Inv_Part_Ownership_Manager_API.Check_Structure_Ownership__(message_              => message_,
                                                                       has_single_ownership_ => has_single_ownership_,
                                                                       part_no_              => oldrec_.part_no,
                                                                       lot_batch_no_         => oldrec_.lot_batch_no,
                                                                       serial_no_            => oldrec_.serial_no,
                                                                       top_ownership_db_     => oldrec_.part_ownership,
                                                                       top_customer_no_      => transfer_tab_(index_).owner,
                                                                       top_vendor_no_        => transfer_tab_(index_).owner,
                                                                       transfer_to_company_  => 'YES');

            IF (has_single_ownership_ = 'FALSE') THEN
               Error_SYS.Record_General(lu_name_,'RECEVIEDMESSAGE: :P1 .',message_);
            END IF;
         END IF;
            
         -- Update Qty Onhand to zero.
         newrec_            := oldrec_;
         newrec_.qty_onhand := 0;

         Check_And_Update_By_Keys___(oldrec_ => oldrec_, newrec_ => newrec_, remove_unit_cost_ => FALSE);
         
         -- Get the corresponding cost_detail_tab_ from the cost_detail_id_.
         IF (cost_detail_id_ IS NOT NULL) THEN
            Temporary_Part_Cost_Detail_API.Get_And_Remove_Details(cost_detail_tab_, cost_detail_id_);                                                           
         END IF;
         
         IF (transfer_tab_(index_).order_type = Order_Type_API.DB_COMPONENT_REPAIR_EXCHANGE) THEN
            transaction_code_ := 'CRO-EX-ARR';
            quantity_         := transfer_tab_(index_).qty;
            order_type_db_    := Order_Type_API.DB_COMPONENT_REPAIR_EXCHANGE;
            
            IF (oldrec_.serial_no != '*') THEN
               part_catalog_rec_ := Part_Catalog_API.Get(oldrec_.part_no);
               IF ((part_catalog_rec_.receipt_issue_serial_track = db_true_) AND
                   (part_catalog_rec_.serial_tracking_code       = db_not_serial_tracking_)) THEN
                  IF (Part_Serial_Catalog_API.Get_Tracked_In_Inventory_Db(oldrec_.part_no, oldrec_.serial_no) = db_true_) THEN
                     -- No need to keep this serial as tracked in inventory when ownership goes from customer to company.
                     Part_Serial_Catalog_API.Reset_Tracked_In_Inventory(oldrec_.part_no, oldrec_.serial_no);
                  END IF;
               END IF;
            END IF;            
         ELSE            
            transaction_code_ := 'XO-ARRIVAL';
            quantity_         := oldrec_.qty_onhand;
            order_type_db_    := Order_Type_API.DB_PURCHASE_ORDER;
            cost_detail_tab_  := empty_cost_detail_tab_;
         END IF;
         Receive_Part_Impl___(transaction_id_               =>  transaction_id_,
                              accounting_id_                =>  dummy_number_,
                              trans_value_                  =>  dummy_number_,
                              contract_                     =>  oldrec_.contract,
                              part_no_                      =>  oldrec_.part_no,
                              configuration_id_             =>  oldrec_.configuration_id,
                              location_no_                  =>  oldrec_.location_no,
                              lot_batch_no_                 =>  oldrec_.lot_batch_no,
                              serial_no_                    =>  oldrec_.serial_no,
                              eng_chg_level_                =>  oldrec_.eng_chg_level,
                              waiv_dev_rej_no_              =>  oldrec_.waiv_dev_rej_no,
                              activity_seq_                 =>  oldrec_.activity_seq,
                              handling_unit_id_             =>  oldrec_.handling_unit_id,
                              transaction_                  =>  transaction_code_,   
                              expiration_date_              =>  NULL,
                              quantity_                     =>  quantity_,  
                              quantity_reserved_            =>  0,
                              catch_quantity_               =>  oldrec_.catch_qty_onhand,
                              source_ref1_                  =>  transfer_tab_(index_).order_no,
                              source_ref2_                  =>  transfer_tab_(index_).line_no,
                              source_ref3_                  =>  transfer_tab_(index_).release_no,
                              source_ref4_                  =>  transfer_tab_(index_).receipt_no,
                              source_ref5_                  =>  NULL,
                              source_                       =>  NULL,
                              unissue_                      =>  FALSE,
                              unit_cost_                    =>  transfer_tab_(index_).price,
                              source_ref_type_              =>  Order_Type_API.Decode(order_type_db_),   
                              vendor_no_                    =>  NULL,
                              receipt_date_                 =>  NULL,
                              condition_code_               =>  transfer_tab_(index_).condition_code,
                              part_ownership_               =>  Part_Ownership_API.DB_COMPANY_OWNED,
                              owning_customer_no_           =>  NULL,
                              cost_detail_tab_              =>  cost_detail_tab_,
                              set_qty_reversed_             =>  FALSE,
                              issue_transaction_id_         =>  NULL,
                              operational_condition_db_     =>  NULL,
                              part_catalog_rec_             =>  part_catalog_rec_,
                              availability_control_id_      =>  NULL,
                              validate_hu_struct_position_  =>  TRUE,
                              ownership_transfer_reason_id_ =>  transfer_tab_(index_).ownership_transfer_reason_id);
                                 
         Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                               Site_API.Get_Company(oldrec_.contract),
                                                               'N',
                                                               NULL);

         Inventory_Transaction_Hist_API.Set_Previous_Ownership(transaction_id_              => transaction_id_,
                                                               previous_part_ownership_     => transfer_tab_(index_).part_ownership,
                                                               previous_owning_customer_no_ => CASE transfer_tab_(index_).part_ownership
                                                                                                  WHEN Part_Ownership_API.DB_CUSTOMER_OWNED
                                                                                                     THEN transfer_tab_(index_).owner
                                                                                                  ELSE NULL END,
                                                               previous_owning_vendor_no_   => CASE transfer_tab_(index_).part_ownership
                                                                                                  WHEN Part_Ownership_API.DB_CONSIGNMENT
                                                                                                     THEN transfer_tab_(index_).owner
                                                                                                  WHEN Part_Ownership_API.DB_SUPPLIER_LOANED
                                                                                                        THEN transfer_tab_(index_).owner
                                                                                                  WHEN Part_Ownership_API.DB_SUPPLIER_OWNED
                                                                                                           THEN transfer_tab_(index_).owner
                                                                                                  ELSE NULL END);
      END LOOP;
   END LOOP;

   Validate_Ownership_Mix___(Part_Ownership_API.DB_COMPANY_OWNED);
   Inventory_Event_Manager_API.Finish_Session;
END Receipt_In_Place;


-- Cancel_Receipt_In_Place
--   Reverses the Inventory Transaction used for the Transfer of Ownership
--   to Company after validating it. Transaction Code XO-UNRCPT is used for
--   canceling the PO Receipt.
PROCEDURE Cancel_Receipt_In_Place (
   cancel_receipt_in_place_tab_ IN Inv_Part_Ownership_Manager_API.cancel_receipt_in_place_table)
IS
   new_trans_                 NUMBER := 0;   
   transaction_code_          VARCHAR2(10); 
   oldrec_                    INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   newrec_                    INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   home_company_              VARCHAR2(20) := NULL; 
   part_inv_value_method_     VARCHAR2(50);    
   inventory_value_           NUMBER := NULL; 
   old_trans_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab; 
   transaction_cost_          NUMBER := 0; 
   total_quantity_            NUMBER := 0; 
   transaction_value_         NUMBER := 0;
   transaction_id_            NUMBER := 0;
   diff_transaction_cost_     NUMBER := 0; 
   currency_rounding_         NUMBER := 0; 
   rec_rows_                  BINARY_INTEGER := 0;
   contract_                  INVENTORY_PART_IN_STOCK_TAB.contract%TYPE;
   part_no_                   INVENTORY_PART_IN_STOCK_TAB.part_no%TYPE;  
   configuration_id_          INVENTORY_PART_IN_STOCK_TAB.configuration_id%TYPE;  
   lot_batch_no_              INVENTORY_PART_IN_STOCK_TAB.lot_batch_no%TYPE; 
   serial_no_                 INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE;  
   serial_no_for_stock_       INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE;  
   location_type_db_          INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   part_rec_                  Inventory_Part_API.Public_Rec; 
   condition_code_            VARCHAR2(10); 
   has_single_ownership_      VARCHAR2(10);
   dummy_number_              NUMBER;
   dummy_string_              VARCHAR2(32000);
   part_catalog_rec_          Part_Catalog_API.Public_Rec;
   dummy_                     BOOLEAN;
   empty_cost_detail_tab_     Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;

   TYPE Condition_Rec IS RECORD
       (condition_code    INVENTORY_PART_IN_STOCK_TOTAL.condition_code%TYPE,
       value              INVENTORY_PART_IN_STOCK_TOTAL.avg_unit_transit_cost%TYPE,
       quantity           INVENTORY_PART_IN_STOCK_TOTAL.qty_onhand%TYPE);

   TYPE Condition_Rec_Table IS TABLE OF Condition_Rec
     INDEX BY BINARY_INTEGER;

   condition_rec_table_     Condition_Rec_Table;

   CURSOR get_transactions ( order_no_   VARCHAR2,
                             line_no_    VARCHAR2,
                             release_no_ VARCHAR2,
                             receipt_no_ NUMBER) IS
      SELECT *
      FROM   INVENTORY_TRANSACTION_HIST_PUB
      WHERE  source_ref1      = order_no_
      AND    source_ref2      = line_no_
      AND    source_ref3      = release_no_
      AND    source_ref4      = receipt_no_
      AND    source_ref_type = 'PUR ORDER'
      AND    (quantity - qty_reversed) > 0
      AND    transaction_code = 'XO-ARRIVAL'
      ORDER BY transaction_id DESC;
BEGIN
   FOR index_ IN cancel_receipt_in_place_tab_.FIRST..cancel_receipt_in_place_tab_.LAST LOOP
      FOR transaction_ IN get_transactions(cancel_receipt_in_place_tab_(index_).order_no,
                                           cancel_receipt_in_place_tab_(index_).line_no,
                                           cancel_receipt_in_place_tab_(index_).release_no,
                                           cancel_receipt_in_place_tab_(index_).receipt_no)  LOOP

         serial_no_for_stock_          := transaction_.serial_no;
         transaction_.handling_unit_id := NVL(transaction_.handling_unit_id, 0);

         IF (serial_no_for_stock_ != '*') THEN
            IF NOT (Check_Exist(transaction_.contract,          
                                transaction_.part_no,           
                                transaction_.configuration_id,  
                                transaction_.location_no,       
                                transaction_.lot_batch_no,      
                                serial_no_for_stock_,         
                                transaction_.eng_chg_level,     
                                transaction_.waiv_dev_rej_no,   
                                transaction_.activity_seq,
                                transaction_.handling_unit_id)) THEN

               location_type_db_    := Inventory_Location_API.Get_Location_Type_Db(transaction_.contract, transaction_.location_no);
               part_catalog_rec_    := Part_Catalog_API.Get(transaction_.part_no);
               serial_no_for_stock_ := Get_Serial_No_For_Stock(transaction_.part_no,
                                                               serial_no_for_stock_,
                                                               part_catalog_rec_,
                                                               location_type_db_,
                                                               transaction_.handling_unit_id);
            END IF;
         END IF;

         -- Validations per inventory part in stock record         
         oldrec_ := Lock_By_Keys___(transaction_.contract,
                                    transaction_.part_no,
                                    transaction_.configuration_id,
                                    transaction_.location_no,
                                    transaction_.lot_batch_no,
                                    serial_no_for_stock_,
                                    transaction_.eng_chg_level,
                                    transaction_.waiv_dev_rej_no,
                                    transaction_.activity_seq,
                                    transaction_.handling_unit_id);

         IF (oldrec_.qty_in_transit != 0) THEN
            Error_SYS.Record_General(lu_name_, 'QTYINTRANSITCANCEL: Cancellation of Purchase Receipt for Transfer of Ownership is not allowed when parts exist in transit.' );
         END IF;

         IF (oldrec_.qty_reserved != 0) THEN
            Error_SYS.Record_General(lu_name_, 'RESERVEDQTYCANCEL: Cancellation of Purchase Receipt for Transfer of Ownership is not allowed when reserved parts exist.');
         END IF;

         IF (oldrec_.freeze_flag = 'Y') THEN
            Error_SYS.Record_General(lu_name_, 'FROZENPARTCANCEL: Cancellation of Purchase Receipt for Transfer of ownership is not allowed when parts are Frozen for Counting.');
         END IF;

         IF (oldrec_.rotable_part_pool_id IS NOT NULL) THEN
            Error_SYS.Record_General(lu_name_, 'ROTABLEPARTCANCEL: Cancellation of Purchase Receipt for Transfer of ownership is not allowed when parts are assigned to a rotable pool.');
         END IF;

         IF (NVL(oldrec_.part_ownership, Part_Ownership_API.DB_COMPANY_OWNED) != Part_Ownership_API.DB_COMPANY_OWNED) THEN
            Error_SYS.Record_General(lu_name_, 'DIFFERENTOWNERSHIP: Transaction cannot be reversed when Ownership Type is different to :P1 stock for Transaction :P2.',
                                                Part_Ownership_API.Decode(Part_Ownership_API.DB_COMPANY_OWNED), transaction_.transaction_id);
         END IF;
         
         IF (oldrec_.qty_onhand < transaction_.quantity) THEN
            Error_SYS.Record_General(lu_name_, 'AVLQTYMOVED: Received quantity is no longer available at :P1 in :P2. To cancel the receipt, the parts need to be available in the location where they were finally stored during the purchase receipt process.', 
                                                              transaction_.location_no, transaction_.contract);
         END IF;

         IF (transaction_.serial_no != '*') THEN
            Part_Serial_Catalog_API.Get_Structure_Ownership(has_single_ownership_     => has_single_ownership_,
                                                            contains_company_owned_   => dummy_string_,
                                                            contains_supplier_loaned_ => dummy_string_,
                                                            contains_customer_owned_  => dummy_string_,
                                                            owning_vendor_no_list_    => dummy_string_,
                                                            owning_customer_no_list_  => dummy_string_,
                                                            part_no_                  => transaction_.part_no,
                                                            serial_no_                => transaction_.serial_no,
                                                            top_part_ownership_db_    => Part_Ownership_API.DB_COMPANY_OWNED,
                                                            top_owning_vendor_no_     => NULL,
                                                            top_owning_customer_no_   => NULL);
            IF has_single_ownership_='FALSE' THEN
               Error_SYS.Record_General(lu_name_, 'SERIALWITHDIFFOWNER: Part :P1, Serial No. :P2 has components with different owners.', transaction_.part_no, transaction_.serial_no);
            END IF;
         END IF;

         IF transaction_.direction = '+' THEN
            part_rec_ :=  Inventory_Part_API.Get(transaction_.contract,
                                                 transaction_.part_no);

            old_trans_cost_detail_tab_ := Inventory_Transaction_Cost_API.Get_Transaction_Cost_Details(
                                                                            transaction_.transaction_id);
            IF (part_rec_.inventory_valuation_method = 'AV') THEN

               IF ( (part_rec_.inventory_part_cost_level != 'COST PER CONDITION')
                  AND (inventory_value_ IS NULL) ) THEN
                  inventory_value_ := Inventory_Part_Unit_Cost_API.Get_Inventory_Value_By_Method(
                                                                   transaction_.contract,
                                                                   transaction_.part_no,
                                                                   transaction_.configuration_id,
                                                                   transaction_.lot_batch_no,
                                                                   transaction_.serial_no);
               END IF;

               contract_         := transaction_.contract;
               part_no_          := transaction_.part_no;
               configuration_id_ := transaction_.configuration_id;
               lot_batch_no_     := transaction_.lot_batch_no;
               serial_no_        := serial_no_for_stock_;
               total_quantity_   := total_quantity_ + transaction_.quantity;
               transaction_cost_ := Inventory_Transaction_Cost_API.Get_Sum_Unit_Cost(
                                                                   transaction_.transaction_id);

               IF (part_rec_.inventory_part_cost_level = 'COST PER CONDITION') THEN
                  condition_code_ := Condition_Code_Manager_API.Get_Condition_Code (
                                                                transaction_.part_no,
                                                                transaction_.serial_no,
                                                                transaction_.lot_batch_no);
                  IF (condition_rec_table_.COUNT = 0) THEN
                     condition_rec_table_(0).condition_code := condition_code_;
                     condition_rec_table_(0).value := Inventory_Part_Unit_Cost_API.Get_Inventory_Value_By_Method(
                                                                                   transaction_.contract,
                                                                                   transaction_.part_no,
                                                                                   transaction_.configuration_id,
                                                                                   transaction_.lot_batch_no,
                                                                                   transaction_.serial_no);
                     condition_rec_table_(0).quantity := transaction_.quantity;
                  ELSE
                     FOR i IN condition_rec_table_.FIRST..condition_rec_table_.LAST LOOP
                        IF (condition_code_ != condition_rec_table_(i).condition_code) THEN
                           IF (i = condition_rec_table_.LAST) THEN
                              rec_rows_ := i + 1;
                              condition_rec_table_(rec_rows_).condition_code := condition_code_;
                              condition_rec_table_(rec_rows_).value := Inventory_Part_Unit_Cost_API.Get_Inventory_Value_By_Method(
                                                                                                    transaction_.contract,
                                                                                                    transaction_.part_no,
                                                                                                    transaction_.configuration_id,
                                                                                                    transaction_.lot_batch_no,
                                                                                                    transaction_.serial_no);
                              condition_rec_table_(rec_rows_).quantity := transaction_.quantity;
                           END IF;
                        ELSE
                           condition_rec_table_(i).quantity :=  condition_rec_table_(i).quantity + transaction_.quantity;
                           EXIT;
                        END IF;
                     END LOOP;
                  END IF;
               END IF;
            END IF;

            -- Do the Transaction just like a usual UNRCPT- Transaction since its necessary to
            -- indicate a decrease in Inventory Cost due to the decrease in Company Owned Stock
            -- during the transfer of ownership back to the previous owner.
            transaction_code_ := 'XO-UNRCPT';
            Inventory_Transaction_Hist_API.New(transaction_id_     => new_trans_,
                                               accounting_id_      => dummy_number_,
                                               value_              => dummy_number_,
                                               transaction_code_   => transaction_code_,
                                               contract_           => transaction_.contract,
                                               part_no_            => transaction_.part_no,
                                               configuration_id_   => transaction_.configuration_id,
                                               location_no_        => transaction_.location_no,
                                               lot_batch_no_       => transaction_.lot_batch_no,
                                               serial_no_          => transaction_.serial_no,
                                               waiv_dev_rej_no_    => transaction_.waiv_dev_rej_no,
                                               eng_chg_level_      => transaction_.eng_chg_level,
                                               activity_seq_       => transaction_.activity_seq,
                                               handling_unit_id_   => transaction_.handling_unit_id,
                                               project_id_         => transaction_.project_id,
                                               source_ref1_        => transaction_.source_ref1,
                                               source_ref2_        => transaction_.source_ref2,
                                               source_ref3_        => transaction_.source_ref3,
                                               source_ref4_        => transaction_.source_ref4,
                                               source_ref5_        => transaction_.source_ref5,
                                               reject_code_        => NULL,
                                               cost_detail_tab_    => old_trans_cost_detail_tab_,
                                               unit_cost_          => NULL,
                                               quantity_           => transaction_.quantity,
                                               qty_reversed_       => transaction_.quantity,
                                               catch_quantity_     => NULL,
                                               source_             => transaction_.source,
                                               source_ref_type_    => Order_Type_API.Decode(transaction_.source_ref_type),
                                               owning_vendor_no_   => NULL,
                                               condition_code_     => transaction_.condition_code,
                                               location_group_     => transaction_.location_group,
                                               part_ownership_db_  => Part_Ownership_API.DB_COMPANY_OWNED,
                                               owning_customer_no_ => NULL,
                                               expiration_date_    => NULL);

            Inventory_Transaction_Hist_API.Reverse_Accounting(new_trans_,
                                                              transaction_.transaction_id);

            Inventory_Transaction_Hist_API.Set_Original_Transaction_Id (new_trans_,
                                                                        transaction_.transaction_id);

            -- The previous ownership information is set to the same as the original transaction
            Inventory_Transaction_Hist_API.Set_Previous_Ownership(new_trans_,
                                                                  transaction_.previous_part_ownership,
                                                                  transaction_.previous_owning_customer_no,
                                                                  transaction_.previous_owning_vendor_no );

            -- Inventory Revalution Handling
            part_inv_value_method_ := Inventory_Part_API.Get_Invent_Valuation_Method_Db(transaction_.contract,
                                                                                        transaction_.part_no);

            IF (part_inv_value_method_ IN ('FIFO','LIFO')) THEN
               Inventory_Transaction_Hist_API.Remove_Fifo_Lifo_Cost(dummy_,
                                                                    transaction_.transaction_id,
                                                                    transaction_.quantity,
                                                                    new_trans_);
            ELSIF (part_inv_value_method_ = 'ST') THEN
               -- Inventory Valuation Method is Standard Cost
               Inventory_Transaction_Hist_API.Reval_Cancel_Receipt_In_Place(transaction_.transaction_id,
                                                                            new_trans_);
            END IF;

            -- The Inventory Quantity is updated to simulate the physical removal of parts
            -- so that the Inventory Valuation Calculation can take place correctly
            
            -- The Qty Onhand cannot go below zero during the transfer of Ownership, exceptions will not be handled
            IF ((oldrec_.qty_onhand - transaction_.quantity) >= 0) THEN
               newrec_            := oldrec_;
               newrec_.qty_onhand := (oldrec_.qty_onhand - transaction_.quantity);
               Check_And_Update_By_Keys___(oldrec_                        => oldrec_,
                                           newrec_                        => newrec_,
                                           set_default_avail_control_id_  => FALSE,
                                           prevent_hu_snapshot_refresh_   => TRUE);
            END IF;

            -- Persistant Ownership is handled here over-riding the usual Call_Part_Serial_Catalog___ method
            -- It is necessary to make this call when the part does not physically exist in Inventory
            IF (transaction_.serial_no != '*') THEN
               IF (transaction_.quantity != 1) THEN
                  Error_SYS.Record_General(lu_name_, 'INDJUSTONE: The quantity may only be one when working with serials.');
               END IF;

               Part_Serial_Catalog_API.Set_Serial_Ownership(transaction_.part_no,
                                                            transaction_.serial_no,
                                                            transaction_.previous_part_ownership,
                                                            transaction_.previous_owning_vendor_no,
                                                            transaction_.previous_owning_customer_no,
                                                            db_true_,
                                                            db_false_);
            END IF;
         ELSE
            Error_SYS.Record_General(lu_name_, 'CANCELDIRERROR: Direction error for transaction :P1', transaction_.transaction_id);
         END IF;
      END LOOP;
   END LOOP;
   
   IF (part_rec_.inventory_valuation_method = 'AV') THEN
      home_company_ := Site_API.Get_Company(contract_);
      IF (part_rec_.inventory_part_cost_level = 'COST PER CONDITION') THEN
         FOR i IN condition_rec_table_.FIRST..condition_rec_table_.LAST LOOP
            IF (Invent_Part_Quantity_Util_API.Check_Qty_For_Condition(contract_, part_no_, configuration_id_,
                                                                      condition_rec_table_(i).condition_code,
                                                                      Part_Ownership_API.DB_COMPANY_OWNED) = 0 )THEN
               IF (condition_rec_table_(i).value <> transaction_cost_) THEN
                 diff_transaction_cost_ := (condition_rec_table_(i).value - transaction_cost_);
                 currency_rounding_ := Currency_Code_API.Get_Currency_Rounding(
                                          home_company_,
                                          Company_Finance_API.Get_Currency_Code(home_company_));
                 IF (round(abs(condition_rec_table_(i).quantity * diff_transaction_cost_),
                    currency_rounding_) > 0) THEN
                    IF (diff_transaction_cost_ > 0) THEN
                        transaction_code_ := 'INVREVAL-';
                    ELSIF (diff_transaction_cost_ < 0) THEN
                        transaction_code_ := 'INVREVAL+';
                    END IF;

                    Inventory_Transaction_Hist_API.New(transaction_id_     => transaction_id_,
                                                       accounting_id_      => dummy_number_,
                                                       value_              => transaction_value_,
                                                       transaction_code_   => transaction_code_,
                                                       contract_           => contract_,
                                                       part_no_            => part_no_,
                                                       configuration_id_   => configuration_id_,
                                                       location_no_        => NULL,
                                                       lot_batch_no_       => NULL,
                                                       serial_no_          => NULL,
                                                       waiv_dev_rej_no_    => NULL,
                                                       eng_chg_level_      => NULL,
                                                       activity_seq_       => 0,
                                                       project_id_         => NULL,
                                                       source_ref1_        => NULL,
                                                       source_ref2_        => NULL,
                                                       source_ref3_        => NULL,
                                                       source_ref4_        => NULL,
                                                       source_ref5_        => NULL,
                                                       reject_code_        => NULL,
                                                       price_              => ABS(condition_rec_table_(i).value - transaction_cost_),
                                                       quantity_           => ABS(condition_rec_table_(i).quantity),
                                                       qty_reversed_       => 0,
                                                       catch_quantity_     => NULL,
                                                       source_             => NULL);

                    Inventory_Transaction_Hist_API.Do_Transaction_Booking(
                                                       transaction_id_,
                                                       home_company_,
                                                       'Y',
                                                       ABS(transaction_value_));
                 END IF;
               END IF;
            END IF;
         END LOOP;
      ELSE
         diff_transaction_cost_ := (inventory_value_ - transaction_cost_);
         IF (round(abs(total_quantity_ * diff_transaction_cost_), currency_rounding_) > 0) THEN
            IF NOT (Invent_Part_Quantity_Util_API.Check_Quantity_Exist(contract_,
                                                                       part_no_,
                                                                       configuration_id_,
                                                                       lot_batch_no_,
                                                                       serial_no_,
                                                                       db_true_,
                                                                       db_true_,
                                                                       db_true_,
                                                                       db_true_,
                                                                       db_false_,
                                                                       db_true_,
                                                                       db_true_,
                                                                       db_true_)) THEN         
            
               IF (diff_transaction_cost_ > 0) THEN
                   transaction_code_ := 'INVREVAL-';
               ELSIF (diff_transaction_cost_ < 0) THEN
                   transaction_code_ := 'INVREVAL+';
               END IF;

               Inventory_Transaction_Hist_API.Create_And_Account(transaction_id_     => transaction_id_,
                                                                 accounting_id_      => dummy_number_,
                                                                 value_              => transaction_value_,
                                                                 transaction_code_   => transaction_code_,
                                                                 contract_           => contract_,
                                                                 part_no_            => part_no_,
                                                                 configuration_id_   => configuration_id_,
                                                                 location_no_        => NULL,
                                                                 lot_batch_no_       => NULL,
                                                                 serial_no_          => NULL,
                                                                 waiv_dev_rej_no_    => NULL,
                                                                 eng_chg_level_      => NULL,
                                                                 activity_seq_       => 0,
                                                                 project_id_         => NULL,
                                                                 source_ref1_        => NULL,
                                                                 source_ref2_        => NULL,
                                                                 source_ref3_        => NULL,
                                                                 source_ref4_        => NULL,
                                                                 source_ref5_        => NULL,
                                                                 reject_code_        => NULL,
                                                                 cost_detail_tab_    => empty_cost_detail_tab_,
                                                                 unit_cost_          => NULL,
                                                                 quantity_           => ABS(total_quantity_),
                                                                 qty_reversed_       => 0,
                                                                 catch_quantity_     => NULL,
                                                                 source_             => NULL,
                                                                 source_ref_type_    => NULL,
                                                                 owning_vendor_no_   => NULL,
                                                                 condition_code_     => NULL,
                                                                 location_group_     => NULL,
                                                                 part_ownership_db_  => Part_Ownership_API.DB_COMPANY_OWNED,
                                                                 owning_customer_no_ => NULL,
                                                                 expiration_date_    => NULL);                              
            END IF;
         END IF;
      END IF;
   END IF;

   FOR index_ IN cancel_receipt_in_place_tab_.FIRST..cancel_receipt_in_place_tab_.LAST LOOP
      FOR transaction_ IN get_transactions(cancel_receipt_in_place_tab_(index_).order_no,
                                           cancel_receipt_in_place_tab_(index_).line_no,
                                           cancel_receipt_in_place_tab_(index_).release_no,
                                           cancel_receipt_in_place_tab_(index_).receipt_no)  LOOP
         IF transaction_.direction = '+' THEN
            Inventory_Transaction_Hist_API.Modify_Qty_Reversed(transaction_.transaction_id,
                                                               transaction_.qty_reversed + transaction_.quantity);

            serial_no_for_stock_          := transaction_.serial_no;
            transaction_.handling_unit_id := NVL(transaction_.handling_unit_id, 0);

            IF (serial_no_for_stock_ != '*') THEN
               IF NOT (Check_Exist(transaction_.contract,          
                                   transaction_.part_no,           
                                   transaction_.configuration_id,  
                                   transaction_.location_no,       
                                   transaction_.lot_batch_no,      
                                   serial_no_for_stock_,         
                                   transaction_.eng_chg_level,     
                                   transaction_.waiv_dev_rej_no,   
                                   transaction_.activity_seq,
                                   transaction_.handling_unit_id)) THEN

                  location_type_db_    := Inventory_Location_API.Get_Location_Type_Db(transaction_.contract, transaction_.location_no);
                  part_catalog_rec_    := Part_Catalog_API.Get(transaction_.part_no);
                  serial_no_for_stock_ := Get_Serial_No_For_Stock(transaction_.part_no,
                                                                  serial_no_for_stock_,
                                                                  part_catalog_rec_,
                                                                  location_type_db_,
                                                                  transaction_.handling_unit_id);
               END IF;
            END IF;
            oldrec_ := Lock_By_Keys___(transaction_.contract,
                                       transaction_.part_no,
                                       transaction_.configuration_id,
                                       transaction_.location_no,
                                       transaction_.lot_batch_no,
                                       serial_no_for_stock_,
                                       transaction_.eng_chg_level,
                                       transaction_.waiv_dev_rej_no,
                                       transaction_.activity_seq,
                                       transaction_.handling_unit_id);

            -- The Qty Onhand cannot go below zero during the transfer of Ownership, exceptions will not be handled
            IF ((oldrec_.qty_onhand + transaction_.quantity) >= 0) THEN
               newrec_                    := oldrec_;
               newrec_.part_ownership     := transaction_.previous_part_ownership;
               newrec_.owning_customer_no := transaction_.previous_owning_customer_no;
               newrec_.owning_vendor_no   := transaction_.previous_owning_vendor_no;
               newrec_.qty_onhand         := (oldrec_.qty_onhand + transaction_.quantity);
               Check_And_Update_By_Keys___(oldrec_                        => oldrec_,
                                           newrec_                        => newrec_,
                                           set_default_avail_control_id_  => FALSE,
                                           prevent_hu_snapshot_refresh_   => TRUE);
            END IF;    
         END IF;
      END LOOP;
   END LOOP;
END Cancel_Receipt_In_Place;


-- Transform_Cost_Details
--   When cost details should be passed between sites this method can be
--   used transform the cost bucket id:s from the source site to the the
--   corresponding cost bucket on the receiving site.
FUNCTION Transform_Cost_Details (
   from_contract_          IN VARCHAR2,
   from_cost_detail_tab_   IN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab ,
   to_contract_            IN VARCHAR2,
   to_valuation_method_db_ IN VARCHAR2,
   to_part_cost_level_db_  IN VARCHAR2 ) RETURN Inventory_Part_Unit_Cost_API.Cost_Detail_Tab
IS   
   to_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
BEGIN
   to_cost_detail_tab_ := from_cost_detail_tab_;
   IF (from_cost_detail_tab_.COUNT > 0) THEN
      FOR i_ IN from_cost_detail_tab_.FIRST..from_cost_detail_tab_.LAST LOOP
         to_cost_detail_tab_(i_).contract := to_contract_;

         IF (from_cost_detail_tab_(i_).cost_bucket_id != '*') THEN
            $IF Component_Cost_SYS.INSTALLED $THEN            
               to_cost_detail_tab_(i_).cost_bucket_id := Cost_Bucket_Cross_Ref_API.Get_Matching_Cost_Bucket_Id(from_contract_,
                                                                                     from_cost_detail_tab_(i_).cost_bucket_id,
                                                                                     to_contract_);               

               IF (to_cost_detail_tab_(i_).cost_bucket_id  IS NULL) THEN
                  -- No matching bucket found
                  Error_SYS.Record_General(lu_name_, 'BUCKET_X_REF: No matching cost bucket found for site :P1, cost bucket :P2 on site :P3',
                                           from_contract_, from_cost_detail_tab_(i_).cost_bucket_id, to_contract_);

               END IF;
            $ELSE
               NULL;
            $END
         END IF;
      END LOOP;
   END IF;

   IF ((to_valuation_method_db_ = 'ST') AND
       (to_part_cost_level_db_ IN ('COST PER PART', 'COST PER CONFIGURATION'))) THEN

      -- Clear out accounting year and cost source in the new details
      to_cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Clear_Details_Year_And_Source(
                                                                              to_cost_detail_tab_);
   END IF;

   -- Merge details having the same keys
   to_cost_detail_tab_ := Inventory_Part_Unit_Cost_API.Merge_Cost_Details(to_cost_detail_tab_);

   RETURN to_cost_detail_tab_;
END Transform_Cost_Details;


-- Check_Qty_For_Condition
--   Returns 1 if quantity exists in transit or onhand for a condition code.
@UncheckedAccess
FUNCTION Check_Qty_For_Condition (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   condition_code_   IN VARCHAR2,
   ownership_        IN VARCHAR2 ) RETURN NUMBER
IS
   found_ NUMBER;

   CURSOR get_qty IS
      SELECT 1
      FROM   INVENTORY_PART_IN_STOCK_TOTAL
      WHERE  part_no = part_no_
      AND    contract = contract_
      AND    configuration_id = configuration_id_
      AND    condition_code = condition_code_
      AND    part_ownership_db = ownership_
      AND    ((qty_onhand != 0) OR (qty_in_transit != 0));
BEGIN
   OPEN   get_qty;
   FETCH  get_qty INTO found_;
   CLOSE  get_qty;
   RETURN NVL(found_,0);
END Check_Qty_For_Condition;


-- Check_Qty_Onhand_Exist
--   Checks whether a quantity onhand exists for a given inventory part.
@UncheckedAccess
FUNCTION Check_Qty_Onhand_Exist (
   part_no_          IN VARCHAR2,
   contract_         IN VARCHAR2 DEFAULT NULL,
   configuration_id_ IN VARCHAR2 DEFAULT NULL ) RETURN VARCHAR2
IS
   dummy_      NUMBER;
   qty_found_  VARCHAR2(5) := db_false_;

   CURSOR check_exist IS
      SELECT 1
      FROM   INVENTORY_PART_IN_STOCK_TAB
      WHERE  qty_onhand       != 0
        AND  part_no          = part_no_
        AND (contract         = contract_         OR contract_         IS NULL)
        AND (configuration_id = configuration_id_ OR configuration_id_ IS NULL);
BEGIN
   OPEN check_exist;
   FETCH check_exist INTO dummy_;
   IF (check_exist%FOUND) THEN
      qty_found_ := db_true_;
   END IF;
   CLOSE check_exist;
   RETURN qty_found_;
END Check_Qty_Onhand_Exist;


-- Transi_Qty_Without_Catch_Exist
--   Checks whether a transit quantity exists for a given inventory part.
@UncheckedAccess
FUNCTION Transi_Qty_Without_Catch_Exist (
   part_no_          IN VARCHAR2,
   contract_         IN VARCHAR2 DEFAULT NULL,
   configuration_id_ IN VARCHAR2 DEFAULT NULL ) RETURN VARCHAR2
IS
   dummy_      NUMBER;
   qty_found_  VARCHAR2(5) := db_false_;
   CURSOR check_exist IS
      SELECT 1
      FROM   INVENTORY_PART_IN_STOCK_TAB
      WHERE  qty_in_transit  != 0
      AND  catch_qty_in_transit IS NULL
      AND  part_no          = part_no_
      AND (contract         = contract_         OR contract_         IS NULL)
      AND (configuration_id = configuration_id_ OR configuration_id_ IS NULL);
BEGIN
   OPEN check_exist;
   FETCH check_exist INTO dummy_;
   IF (check_exist%FOUND) THEN
      qty_found_ := db_true_;
   END IF;
   CLOSE check_exist;
   IF (qty_found_ = db_false_) THEN
      qty_found_ := Inventory_Part_In_Transit_API.Quantity_Without_Catch_Exist(part_no_,
                                                                               contract_,
                                                                               configuration_id_);
   END IF;
   RETURN qty_found_;
END Transi_Qty_Without_Catch_Exist;


-- Issue_Supplier_Owned_Stock
--   This is used to issue quantity from ARRIVAL or QA location, which are of
--   ownership type supplier owned to inventory.
PROCEDURE Issue_Supplier_Owned_Stock (
   catch_quantity_   IN OUT NUMBER,
   contract_         IN     VARCHAR2,
   part_no_          IN     VARCHAR2,
   configuration_id_ IN     VARCHAR2,
   location_no_      IN     VARCHAR2,
   lot_batch_no_     IN     VARCHAR2,
   serial_no_        IN     VARCHAR2,
   eng_chg_level_    IN     VARCHAR2,
   waiv_dev_rej_no_  IN     VARCHAR2,
   activity_seq_     IN     NUMBER,
   handling_unit_id_ IN     NUMBER,
   quantity_         IN     NUMBER,
   order_no_         IN     VARCHAR2,
   release_no_       IN     VARCHAR2,
   sequence_no_      IN     VARCHAR2,
   line_item_no_     IN     NUMBER,
   source_           IN     VARCHAR2,
   order_type_       IN     VARCHAR2 )
IS
   transaction_id_        NUMBER;
   accounting_id_         NUMBER := 0;
   trans_value_           NUMBER := 0;
   empty_cost_detail_tab_ Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
BEGIN
   Issue_Part_Impl___(transaction_id_               =>  transaction_id_,
                      accounting_id_                =>  accounting_id_,
                      trans_value_                  =>  trans_value_,
                      catch_quantity_               =>  catch_quantity_,
                      contract_                     =>  contract_,
                      part_no_                      =>  part_no_,
                      configuration_id_             =>  configuration_id_,
                      location_no_                  =>  location_no_,
                      lot_batch_no_                 =>  lot_batch_no_,
                      serial_no_                    =>  serial_no_,
                      eng_chg_level_                =>  eng_chg_level_,
                      waiv_dev_rej_no_              =>  waiv_dev_rej_no_,
                      activity_seq_                 =>  activity_seq_,
                      handling_unit_id_             =>  handling_unit_id_,
                      transaction_                  =>  'OWNTRANOUT',
                      quantity_                     =>  quantity_,
                      quantity_reserved_            =>  0,
                      source_ref1_                  =>  order_no_,
                      source_ref2_                  =>  release_no_,
                      source_ref3_                  =>  sequence_no_,
                      source_ref4_                  =>  line_item_no_,
                      source_ref5_                  =>  NULL,
                      source_                       =>  source_,
                      unreceive_                    =>  FALSE,
                      forced_                       =>  FALSE,
                      cost_detail_tab_              =>  empty_cost_detail_tab_,
                      source_ref_type_              =>  order_type_,
                      reject_code_                  =>  NULL,
                      remove_unit_cost_             =>  TRUE,
                      make_transaction_             =>  TRUE,
                      transit_location_group_       =>  NULL,
                      report_earned_value_db_       =>  NULL,
                      part_catalog_rec_             =>  NULL,
                      original_transaction_id_      =>  NULL,
                      prevent_fifo_action_          =>  FALSE,
                      ownership_transfer_reason_id_ =>  NULL);
END Issue_Supplier_Owned_Stock;


-- Validate_Create_Count_Report
--   Validates the parameters when running the Schedule for Create Count Report.
PROCEDURE Validate_Create_Count_Report (
   message_ IN VARCHAR2 )
IS
   count_                      NUMBER;
   name_arr_                   Message_SYS.name_table;
   value_arr_                  Message_SYS.line_table;
   contract_                   VARCHAR2(5);
   cycle_code_db_              VARCHAR2(100);
   process_count_              NUMBER;
   exclude_since_              NUMBER;
   exclude_company_owned_      VARCHAR2(10);
   exclude_customer_owned_     VARCHAR2(10);
   exclude_consignment_        VARCHAR2(10);
   exclude_supplier_loaned_    VARCHAR2(10);
   exclude_project_inventory_  VARCHAR2(10);
   exclude_standard_inventory_ VARCHAR2(10);
   project_id_                 VARCHAR2(10);
   print_count_report_db_      VARCHAR2(20);
BEGIN
   Message_SYS.Get_Attributes(message_, count_, name_arr_, value_arr_);

   FOR n_ IN 1..count_ LOOP
      IF (name_arr_(n_) = 'CONTRACT') THEN
         contract_ := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'CYCLE_CODE_DB') THEN
         cycle_code_db_ := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'PROCESS_COUNT') THEN
         process_count_ := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'EXCLUDE_SINCE') THEN
         exclude_since_ := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'EXCLUDE_COMPANY_OWNED') THEN
         exclude_company_owned_ := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'EXCLUDE_CUSTOMER_OWNED') THEN
         exclude_customer_owned_ := value_arr_(n_);   
      ELSIF (name_arr_(n_) = 'EXCLUDE_CONSIGNMENT') THEN
         exclude_consignment_ := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'EXCLUDE_SUPPLIER_LOANED') THEN
         exclude_supplier_loaned_ := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'EXCLUDE_PROJECT_INVENTORY') THEN
         exclude_project_inventory_ := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'EXCLUDE_STANDARD_INVENTORY') THEN
         exclude_standard_inventory_ := value_arr_(n_);   
      ELSIF (name_arr_(n_) = 'PROJECT_ID') THEN
         project_id_ := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'PRINT_COUNT_REPORT_DB') THEN
         print_count_report_db_ := value_arr_(n_);
      END IF;
   END LOOP;

   IF (contract_ IS NOT NULL) THEN
      User_Allowed_Site_API.Exist(Fnd_Session_API.Get_Fnd_User, contract_);
   END IF;

   IF (cycle_code_db_ IS NOT NULL) THEN
      Cyclic_Counting_API.Exist_Db(cycle_code_db_);
   END IF;
   IF (process_count_ < 1 OR MOD(process_count_, 1) != 0) THEN
      Error_SYS.Record_General(lu_name_, 'NOPROCCOUNT: The value for number of records to be printed should be an integer greater than zero.');
   END IF;

  -- Validate Exclude_Since
   IF (exclude_since_ < 0) THEN
      Error_SYS.Record_General(lu_name_, 'EXCLUDE: Exclude parts counted since may not be negative.');
   END IF;

   -- Validate Exclude_Part_Ownership
   IF ((exclude_customer_owned_ = 'EXCLUDE') AND (exclude_supplier_loaned_ = 'EXCLUDE') AND
       (exclude_consignment_ = 'EXCLUDE') AND (exclude_company_owned_ = 'EXCLUDE')) THEN
      Error_SYS.Record_General(lu_name_, 'NOOWNERINREP: All types of part ownership cannot be excluded FROM Inventory Part Counting.');
   END IF;

   -- Validate exclude_project_inventory and  exclude_standard_inventory
   IF (exclude_project_inventory_ = 'Y') AND (exclude_standard_inventory_ = 'Y') THEN
      Error_SYS.Record_General(lu_name_, 'EXPIST: Both Standard Inventory and Project Inventory cannot be excluded from Inventory Part Counting.');
   END IF;

   IF (exclude_project_inventory_ = 'Y') AND (project_id_ IS NOT NULL) THEN
      Error_SYS.Record_General(lu_name_, 'NOPROJECT: Project ID cannot have a value when Project Inventory is excluded from Inventory Part Counting.');
   END IF;
   IF (print_count_report_db_ IS NOT NULL) THEN
      Invent_Report_Print_Option_API.Exist_Db(print_count_report_db_);
   END IF;

END Validate_Create_Count_Report;


-- Fill_Inventory_Location_Tmp
--   Loads the temporary table inventory_location_tmp with Location No
--   information, to be used in operation FindPart.
PROCEDURE Fill_Inventory_Location_Tmp (
   inventory_location_tab_ IN  inventory_location_table )
IS
BEGIN
   IF inventory_location_tab_.COUNT > 0 THEN
      FORALL i IN inventory_location_tab_.FIRST..inventory_location_tab_.LAST
         INSERT
            INTO inventory_location_tmp ( location_no )
            VALUES ( inventory_location_tab_(i) );
   END IF;
END Fill_Inventory_Location_Tmp;


PROCEDURE Fill_Invent_Part_In_Stock_Tmp (
   keys_and_qty_rec_ IN Keys_And_Qty_Rec )
IS
BEGIN
   INSERT
      INTO inventory_part_in_stock_tmp
         ( contract,
           part_no,
           configuration_id,
           location_no,
           lot_batch_no,
           serial_no,
           eng_chg_level,
           waiv_dev_rej_no,
           activity_seq,
           handling_unit_id )
      VALUES
         ( keys_and_qty_rec_.contract,        
           keys_and_qty_rec_.part_no,         
           keys_and_qty_rec_.configuration_id,
           keys_and_qty_rec_.location_no,     
           keys_and_qty_rec_.lot_batch_no,    
           keys_and_qty_rec_.serial_no,       
           keys_and_qty_rec_.eng_chg_level,   
           keys_and_qty_rec_.waiv_dev_rej_no, 
           keys_and_qty_rec_.activity_seq,    
           keys_and_qty_rec_.handling_unit_id  );
END Fill_Invent_Part_In_Stock_Tmp;


-- Clear_Inventory_Location_Tmp
--   Clears the temporary table inventory_location_tmp
PROCEDURE Clear_Inventory_Location_Tmp
IS
BEGIN
   DELETE FROM inventory_location_tmp;
END Clear_Inventory_Location_Tmp;


PROCEDURE Clear_Invent_Part_In_Stock_Tmp
IS
BEGIN
   DELETE FROM inventory_part_in_stock_tmp;
END Clear_Invent_Part_In_Stock_Tmp;


-- Submit_Part_To_Mrb
--   Validates and modifies the IPIS records according to the MRB case.
PROCEDURE Submit_Part_To_Mrb (
   contract_                IN VARCHAR2,
   part_no_                 IN VARCHAR2,
   location_no_             IN VARCHAR2,
   availability_control_id_ IN VARCHAR2,
   part_detail_msg_         IN VARCHAR2 )
IS
   count_                      NUMBER;
   part_detail_tab_            Message_SYS.name_table;
   part_detail_value_tab_      Message_SYS.line_table;

   serial_no_                  INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE;
   lot_batch_no_               INVENTORY_PART_IN_STOCK_TAB.lot_batch_no%TYPE;
   waiv_dev_rej_no_            INVENTORY_PART_IN_STOCK_TAB.waiv_dev_rej_no%TYPE;
   configuration_id_           INVENTORY_PART_IN_STOCK_TAB.configuration_id%TYPE;
   eng_chg_level_              INVENTORY_PART_IN_STOCK_TAB.eng_chg_level%TYPE;
   activity_seq_               INVENTORY_PART_IN_STOCK_TAB.activity_seq%TYPE;
   handling_unit_id_           INVENTORY_PART_IN_STOCK_TAB.handling_unit_id%TYPE;
   qty_onhand_                 INVENTORY_PART_IN_STOCK_TAB.qty_onhand%TYPE;
   old_availability_cnt_id_    VARCHAR2(25);
   part_tracking_session_id_   NUMBER;
BEGIN
   Message_SYS.Get_Attributes(part_detail_msg_, count_, part_detail_tab_, part_detail_value_tab_);
   FOR n_ IN 1..count_ LOOP
      IF (part_detail_tab_(n_) = 'SERIAL_NO') THEN
         serial_no_ := part_detail_value_tab_(n_);
      ELSIF (part_detail_tab_(n_) = 'LOT_BATCH_NO') THEN
         lot_batch_no_ := part_detail_value_tab_(n_);
      ELSIF (part_detail_tab_(n_) = 'WAIV_DEV_REJ_NO') THEN
         waiv_dev_rej_no_ := part_detail_value_tab_(n_);
      ELSIF (part_detail_tab_(n_) = 'CONFIGURATION_ID') THEN
         configuration_id_ := part_detail_value_tab_(n_);
      ELSIF (part_detail_tab_(n_) = 'ENG_CHG_LEVEL') THEN
         eng_chg_level_ := part_detail_value_tab_(n_);
      ELSIF (part_detail_tab_(n_) = 'ACTIVITY_SEQ') THEN
         activity_seq_ := Client_SYS.Attr_Value_To_Number(part_detail_value_tab_(n_));
      ELSIF (part_detail_tab_(n_) = 'HANDLING_UNIT_ID') THEN
         handling_unit_id_ := Client_SYS.Attr_Value_To_Number(part_detail_value_tab_(n_));
      ELSIF (part_detail_tab_(n_) = 'PART_TRACKING_SESSION_ID') THEN
         part_tracking_session_id_ := Client_SYS.Attr_Value_To_Number(part_detail_value_tab_(n_));
      ELSIF (part_detail_tab_(n_) = 'QTY_ONHAND') THEN
         qty_onhand_ := Client_SYS.Attr_Value_To_Number(part_detail_value_tab_(n_));

         Validate_Mrb_Submission___(contract_, part_no_, configuration_id_, location_no_,
                                    lot_batch_no_, serial_no_, eng_chg_level_, waiv_dev_rej_no_,
                                    activity_seq_, handling_unit_id_,
                                    availability_control_id_, qty_onhand_);

         old_availability_cnt_id_ := Get_Availability_Control_Id(contract_,
                                                                 part_no_,
                                                                 configuration_id_,
                                                                 location_no_,
                                                                 lot_batch_no_,
                                                                 serial_no_,
                                                                 eng_chg_level_,
                                                                 waiv_dev_rej_no_,
                                                                 activity_seq_,
                                                                 handling_unit_id_);
         IF (NVL(old_availability_cnt_id_, CHR(32)) != availability_control_id_) THEN
            Modify_Availability_Control_Id(contract_,
                                           part_no_,
                                           configuration_id_,
                                           location_no_,
                                           lot_batch_no_,
                                           serial_no_,
                                           eng_chg_level_,
                                           waiv_dev_rej_no_,
                                           activity_seq_,
                                           handling_unit_id_,
                                           availability_control_id_);
         END IF;
      END IF;
   END LOOP;
END Submit_Part_To_Mrb;


-- Find_And_Lock_Part
--   Find locations with a quantity available and lock them for update.
FUNCTION Find_And_Lock_Part (
   available_record_was_skipped_  OUT BOOLEAN,
   location_no_                   IN  VARCHAR2,
   lot_batch_no_                  IN  VARCHAR2,
   serial_no_                     IN  VARCHAR2,
   eng_chg_level_                 IN  VARCHAR2,
   waiv_dev_rej_no_               IN  VARCHAR2,
   configuration_id_              IN  VARCHAR2,
   activity_seq_                  IN  NUMBER,
   handling_unit_id_              IN  NUMBER,
   contract_                      IN  VARCHAR2,
   part_no_                       IN  VARCHAR2,
   location_type_db_              IN  VARCHAR2,
   auto_reservation_db_           IN  VARCHAR2,
   order_issue_db_                IN  VARCHAR2,
   project_id_                    IN  VARCHAR2,
   condition_code_                IN  VARCHAR2,
   part_ownership_db_             IN  VARCHAR2,
   owning_vendor_no_              IN  VARCHAR2,
   owning_customer_no_            IN  VARCHAR2,
   only_one_lot_allowed_          IN  BOOLEAN,
   many_records_allowed_          IN  BOOLEAN,
   qty_to_find_and_lock_          IN  NUMBER,
   expiration_control_date_       IN  DATE     DEFAULT NULL,
   include_temp_table_locs_       IN  BOOLEAN  DEFAULT TRUE,
   warehouse_id_                  IN  VARCHAR2 DEFAULT NULL,
   ignore_this_avail_control_id_  IN  VARCHAR2 DEFAULT NULL,
   consume_partial_handling_unit_ IN  BOOLEAN  DEFAULT TRUE,
   part_movement_control_db_      IN  VARCHAR2 DEFAULT NULL,
   location_group_                IN  VARCHAR2 DEFAULT NULL ) RETURN Keys_And_Qty_Tab
IS
   keys_and_qty_tab_     Keys_And_Qty_Tab;
   qty_found_is_secured_ BOOLEAN;
   record_               INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
BEGIN

   LOOP
      keys_and_qty_tab_ := Find_Part___(available_record_was_skipped_  => available_record_was_skipped_,
                                        location_no_                   => location_no_,
                                        lot_batch_no_                  => lot_batch_no_,
                                        serial_no_                     => serial_no_,
                                        eng_chg_level_                 => eng_chg_level_,
                                        waiv_dev_rej_no_               => waiv_dev_rej_no_,
                                        configuration_id_              => configuration_id_,
                                        activity_seq_                  => activity_seq_,
                                        handling_unit_id_              => handling_unit_id_,
                                        contract_                      => contract_,
                                        part_no_                       => part_no_,
                                        location_type_db_              => location_type_db_,
                                        auto_reservation_db_           => auto_reservation_db_,
                                        order_issue_db_                => order_issue_db_,
                                        project_id_                    => project_id_,
                                        condition_code_                => condition_code_,
                                        part_ownership_db_             => part_ownership_db_,
                                        owning_vendor_no_              => owning_vendor_no_,
                                        owning_customer_no_            => owning_customer_no_,
                                        only_one_lot_allowed_          => only_one_lot_allowed_,
                                        many_records_allowed_          => many_records_allowed_,
                                        qty_to_find_                   => qty_to_find_and_lock_,
                                        expiration_control_date_       => expiration_control_date_,
                                        include_temp_table_locs_       => include_temp_table_locs_,
                                        warehouse_id_                  => warehouse_id_,
                                        ignore_this_avail_control_id_  => ignore_this_avail_control_id_,
                                        consume_partial_handling_unit_ => consume_partial_handling_unit_,
                                        part_movement_control_db_      => part_movement_control_db_,
                                        location_group_                => location_group_);

      EXIT WHEN keys_and_qty_tab_.COUNT = 0;

      qty_found_is_secured_ := TRUE;

      FOR i IN keys_and_qty_tab_.FIRST..keys_and_qty_tab_.LAST LOOP

         record_ := Lock_By_Keys___(keys_and_qty_tab_(i).contract,
                                    keys_and_qty_tab_(i).part_no,
                                    keys_and_qty_tab_(i).configuration_id,
                                    keys_and_qty_tab_(i).location_no,
                                    keys_and_qty_tab_(i).lot_batch_no,
                                    keys_and_qty_tab_(i).serial_no,
                                    keys_and_qty_tab_(i).eng_chg_level,
                                    keys_and_qty_tab_(i).waiv_dev_rej_no,
                                    keys_and_qty_tab_(i).activity_seq,
                                    keys_and_qty_tab_(i).handling_unit_id);

         IF ((record_.qty_onhand - record_.qty_reserved) < keys_and_qty_tab_(i).quantity) THEN
            qty_found_is_secured_ := FALSE;
            EXIT;
         END IF;
      END LOOP;

      EXIT WHEN qty_found_is_secured_;
   END LOOP;

   RETURN (keys_and_qty_tab_);
END Find_And_Lock_Part;


-- Get_Serial_Contract
--   Returns the contract in which the Serial exists whilst checking for inconsistency.
FUNCTION Get_Serial_Contract (
   part_no_   IN VARCHAR2,
   serial_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_  VARCHAR2(5):=NULL;
   dummy_ VARCHAR2(5);
   CURSOR get_contract IS
      SELECT contract
      FROM  INVENTORY_PART_IN_STOCK_TAB
      WHERE part_no        = part_no_
        AND serial_no      = serial_no_
        AND (qty_onhand != 0 OR qty_in_transit != 0);
BEGIN
   OPEN get_contract;
   FETCH get_contract INTO temp_;
   IF get_contract%FOUND THEN
      FETCH get_contract INTO dummy_;
      IF get_contract%FOUND THEN
         CLOSE get_contract;
         Error_SYS.Record_General(lu_name_,'GSCINCONS: Inconsistent database. Serial <:P1> exists on several inventory locations simultaneously.', part_no_||','||serial_no_);
      END IF;
   END IF;
   CLOSE get_contract;
   RETURN temp_;
END Get_Serial_Contract;


-- Scrap_Credit
--   Generic method for Scrap parts and get credit for it from Supplier.
PROCEDURE Scrap_Credit (
   catch_quantity_   IN OUT NUMBER,
   contract_         IN     VARCHAR2,
   part_no_          IN     VARCHAR2,
   configuration_id_ IN     VARCHAR2,
   location_no_      IN     VARCHAR2,
   lot_batch_no_     IN     VARCHAR2,
   serial_no_        IN     VARCHAR2,
   eng_chg_level_    IN     VARCHAR2,
   waiv_dev_rej_no_  IN     VARCHAR2,
   activity_seq_     IN     NUMBER,
   handling_unit_id_ IN     NUMBER,
   quantity_         IN     NUMBER,
   scrap_cause_      IN     VARCHAR2,
   scrap_note_       IN     VARCHAR2,
   order_no_         IN     VARCHAR2,
   release_no_       IN     VARCHAR2,
   sequence_no_      IN     VARCHAR2,
   line_item_no_     IN     NUMBER,
   order_type_       IN     VARCHAR2 )
IS
   transaction_id_            NUMBER;
   dummy_number_              NUMBER;
   empty_cost_detail_tab_     Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   acquisition_site_          INVENTORY_PART_IN_STOCK_TAB.contract%TYPE;
   acquisition_company_       VARCHAR2(20);
   this_company_              VARCHAR2(20);
   internal_transit_delivery_ BOOLEAN;
BEGIN
   this_company_              := Site_API.Get_Company(contract_);
   internal_transit_delivery_ := Is_Internal_Transit_Deliv___(order_no_,
                                                              release_no_,
                                                              sequence_no_);
   IF (internal_transit_delivery_) THEN
      acquisition_site_    := Get_Acquisition_Site___(order_no_);
      acquisition_company_ := Site_API.Get_Company(acquisition_site_);

      IF (acquisition_company_ = this_company_) THEN
         Error_SYS.Record_General(lu_name_, 'INTRANSITSCPCR: When internal order supply is used it''s not allowed to scrap for credit if demand and supply site belong to the same company.');
      END IF;
   END IF;

   Issue_Part_Impl___(transaction_id_               =>  transaction_id_,
                      accounting_id_                =>  dummy_number_,
                      trans_value_                  =>  dummy_number_,
                      catch_quantity_               =>  catch_quantity_,
                      contract_                     =>  contract_,
                      part_no_                      =>  part_no_,
                      configuration_id_             =>  configuration_id_,
                      location_no_                  =>  location_no_,
                      lot_batch_no_                 =>  lot_batch_no_,
                      serial_no_                    =>  serial_no_,
                      eng_chg_level_                =>  eng_chg_level_,
                      waiv_dev_rej_no_              =>  waiv_dev_rej_no_,
                      activity_seq_                 =>  activity_seq_,
                      handling_unit_id_             =>  handling_unit_id_,
                      transaction_                  =>  'SCPCREDIT',
                      quantity_                     =>  quantity_,
                      quantity_reserved_            =>  0,
                      source_ref1_                  =>  order_no_,
                      source_ref2_                  =>  release_no_,
                      source_ref3_                  =>  sequence_no_,
                      source_ref4_                  =>  line_item_no_,
                      source_ref5_                  =>  NULL,
                      source_                       =>  scrap_note_,
                      unreceive_                    =>  FALSE,
                      forced_                       =>  FALSE,
                      cost_detail_tab_              =>  empty_cost_detail_tab_,
                      source_ref_type_              =>  order_type_,
                      reject_code_                  =>  scrap_cause_,
                      remove_unit_cost_             =>  TRUE,
                      make_transaction_             =>  TRUE,
                      transit_location_group_       =>  NULL,
                      report_earned_value_db_       =>  NULL,
                      part_catalog_rec_             =>  NULL,
                      original_transaction_id_      =>  NULL,
                      prevent_fifo_action_          =>  FALSE,
                      ownership_transfer_reason_id_ =>  NULL);

    Inventory_Transaction_Hist_API.Do_Transaction_Booking(transaction_id_,
                                                         this_company_,
                                                         'N',
                                                         NULL);
    
END Scrap_Credit;


-- Get_Eng_Chg_Level_By_Location
--   This function used to get the Eng_Chg_Level_ according to the Location.
--   First find location with qty_onhand > 0, if found return the revision for that record.
--   If not found(qty_onhand = 0) return the first revision for that location.
--   If part never existed in the location return the current revision of the part.
FUNCTION Get_Eng_Chg_Level_By_Location (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_no_      IN VARCHAR2 ) RETURN VARCHAR2
IS
   eng_chg_level_     INVENTORY_PART_IN_STOCK_TAB.eng_chg_level%TYPE;

   CURSOR get_eng_chg_level_with_qty IS
      SELECT qty_onhand, eng_chg_level
      FROM   INVENTORY_PART_IN_STOCK_TAB
      WHERE  contract         = contract_
      AND    part_no          = part_no_
      AND    configuration_id = configuration_id_
      AND    location_no      = location_no_
      ORDER BY qty_onhand DESC;
BEGIN
   FOR rec_ IN get_eng_chg_level_with_qty LOOP
      IF (rec_.qty_onhand > 0) THEN
         -- Found location with quantity. Save the EC from this record and exit loop.
         eng_chg_level_ := rec_.eng_chg_level;
         EXIT;
      END IF;

      -- No location with qty_onhand was found. Pick the first (lowest) EC.
      DECLARE
         eng_chg_level_num_ NUMBER;
      BEGIN
         eng_chg_level_num_ := rec_.eng_chg_level;
         IF (eng_chg_level_ IS NULL) THEN
            eng_chg_level_ := rec_.eng_chg_level;
         ELSE
            IF (to_number(rec_.eng_chg_level) < to_number(eng_chg_level_)) THEN
               eng_chg_level_ := rec_.eng_chg_level;
            END IF;
         END IF;
      EXCEPTION
         WHEN value_error THEN
            NULL;
      END;
   END LOOP;

   IF (eng_chg_level_ IS NULL) THEN
      eng_chg_level_ := Inventory_Part_Revision_API.Get_Latest_Eng_Chg_Level(contract_, part_no_);
   END IF;

   RETURN eng_chg_level_;
END Get_Eng_Chg_Level_By_Location;


-- Quantity_Exist_At_Location
--   Returns TRUE if qty_onhand or qty_in_transit is not equal to zero
--   on any of the records identified with contract, part_no and location_no.
@UncheckedAccess
FUNCTION Quantity_Exist_At_Location (
   contract_    IN VARCHAR2,
   part_no_     IN VARCHAR2,
   location_no_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_                      NUMBER;
   quantity_exist_at_location_ BOOLEAN := FALSE;

   CURSOR exist_control IS
      SELECT 1
        FROM INVENTORY_PART_IN_STOCK_TAB
       WHERE contract    = contract_
         AND part_no     = part_no_
         AND location_no = location_no_
         AND ((qty_onhand != 0) OR (qty_in_transit != 0));
BEGIN
   OPEN  exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      quantity_exist_at_location_ := TRUE;
   END IF;
   CLOSE exist_control;

   RETURN(quantity_exist_at_location_);
END Quantity_Exist_At_Location;


@UncheckedAccess
FUNCTION Get_Owner (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_no_      IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER ) RETURN VARCHAR2
IS
   part_rec_  Public_Rec;
   owner_     INVENTORY_PART_IN_STOCK_TAB.owning_customer_no%TYPE;
BEGIN
   part_rec_ := Get(contract_,
                    part_no_,
                    configuration_id_,
                    location_no_,
                    lot_batch_no_,
                    serial_no_,
                    eng_chg_level_,
                    waiv_dev_rej_no_,
                    activity_seq_,
                    handling_unit_id_);

   IF (part_rec_.owning_customer_no IS NOT NULL) THEN
      owner_ := part_rec_.owning_customer_no;
   ELSIF (part_rec_.owning_vendor_no IS NOT NULL) THEN
      owner_ := part_rec_.owning_vendor_no;
   ELSE
      owner_ := NULL;
   END IF;

   RETURN (owner_);
END Get_Owner;


-- Get_Owner_Name
--   Returns the Owning Customer Name or the Owning Vendor Name or NULL
--   depending on the Part Ownership for a given Contract, Part No and
--   Location No combination. No value is returned when parameters
--   Qty On hand and Qty In Transit are zero.
@UncheckedAccess
FUNCTION Get_Owner_Name (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_no_      IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER ) RETURN VARCHAR2
IS
   part_rec_         Public_Rec;
   owner_name_       VARCHAR2(100):= NULL;   
BEGIN
   part_rec_ := Get(contract_,
                    part_no_,
                    configuration_id_,
                    location_no_,
                    lot_batch_no_,
                    serial_no_,
                    eng_chg_level_,
                    waiv_dev_rej_no_,
                    activity_seq_,
                    handling_unit_id_);
   
   IF (part_rec_.owning_customer_no IS NOT NULL) THEN
      $IF Component_Order_SYS.INSTALLED $THEN      
         owner_name_ := Cust_Ord_Customer_API.Get_Name(part_rec_.owning_customer_no);
      $ELSIF Component_Purch_SYS.INSTALLED $THEN
         IF (part_rec_.owning_vendor_no IS NOT NULL) THEN
            owner_name_ := Supplier_API.Get_Vendor_Name(part_rec_.owning_vendor_no);
         END IF;  
      $ELSE
         NULL;
      $END
   ELSIF (part_rec_.owning_vendor_no IS NOT NULL) THEN
      $IF Component_Purch_SYS.INSTALLED $THEN      
         owner_name_ := Supplier_API.Get_Vendor_Name(part_rec_.owning_vendor_no);
      $ELSE
         NULL;
      $END
   END IF; 
   
   RETURN (owner_name_);
END Get_Owner_Name;


-- This method is used by DataCaptAttachPartHu, DataCaptIssueInvPart, DataCaptRecFromTransit, DataCaptScrapInvPart,
-- DataCaptUnattachPartHu, DataCaptureMovePart, DataCaptReportPickPart, DataCaptManIssSoHu, DataCaptManIssSoPart, 
-- DataCaptRepPickPartSo, DataCaptManIssueWo and DataCaptUnplanIssueWo
@ServerOnlyAccess
PROCEDURE Record_With_Column_Value_Exist (
   contract_                   IN VARCHAR2,
   part_no_                    IN VARCHAR2,
   configuration_id_           IN VARCHAR2,
   location_no_                IN VARCHAR2,
   lot_batch_no_               IN VARCHAR2,
   serial_no_                  IN VARCHAR2,
   eng_chg_level_              IN VARCHAR2,
   waiv_dev_rej_no_            IN VARCHAR2,
   activity_seq_               IN NUMBER,
   handling_unit_id_           IN NUMBER,
   alt_handling_unit_label_id_ IN VARCHAR2,  -- send '%' if this item have not been entered/scanned yet
   column_name_                IN VARCHAR2,
   column_value_               IN VARCHAR2,
   column_description_         IN VARCHAR2,
   sql_where_expression_       IN VARCHAR2 DEFAULT NULL,
   column_value_exist_check_   IN BOOLEAN  DEFAULT TRUE,
   column_value_nullable_      IN BOOLEAN  DEFAULT FALSE)
IS
   TYPE Check_Exist IS REF CURSOR;
   exist_control_   Check_Exist;
   stmt_            VARCHAR2(32000);
   dummy_           NUMBER;
   exist_           BOOLEAN := FALSE;
BEGIN

   -- extra column check to be sure we have no risk for sql injection into column_/data_item_id
   Assert_SYS.Assert_Is_View_Column('INVENTORY_PART_IN_STOCK_TOTAL', column_name_);
   -- using INVENTORY_PART_IN_STOCK_TOTAL instead of table since we like to check condition_code among other columns that dont exist in the table.
   stmt_ := ' SELECT 1
              FROM  INVENTORY_PART_IN_STOCK_TOTAL
              WHERE EXISTS (SELECT 1 FROM user_allowed_site_pub WHERE site = contract) ';
   IF (contract_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND contract = :contract_ ';
   ELSE
      stmt_ := stmt_ || ' AND :contract_ IS NULL ';
   END IF;
   IF (part_no_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND part_no = :part_no_ ';
   ELSE
      stmt_ := stmt_ || ' AND :part_no_ IS NULL ';
   END IF;
   IF (configuration_id_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND configuration_id = :configuration_id_ ';
   ELSE
      stmt_ := stmt_ || ' AND :configuration_id_ IS NULL ';
   END IF;
   IF (location_no_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND location_no = :location_no_ ';
   ELSE
      stmt_ := stmt_ || ' AND :location_no_ IS NULL ';
   END IF;
   IF (lot_batch_no_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND lot_batch_no = :lot_batch_no_ ';
   ELSE
      stmt_ := stmt_ || ' AND :lot_batch_no_ IS NULL ';
   END IF;
    IF (serial_no_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND serial_no = :serial_no_ ';
   ELSE
      stmt_ := stmt_ || ' AND :serial_no_ IS NULL ';
   END IF;
   IF (eng_chg_level_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND eng_chg_level = :eng_chg_level_ ';
   ELSE
      stmt_ := stmt_ || ' AND :eng_chg_level_ IS NULL ';
   END IF;
   IF (waiv_dev_rej_no_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND waiv_dev_rej_no = :waiv_dev_rej_no_ ';
   ELSE
      stmt_ := stmt_ || ' AND :waiv_dev_rej_no_ IS NULL ';
   END IF;
   IF (activity_seq_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND activity_seq = :activity_seq_ ';
   ELSE
      stmt_ := stmt_ || ' AND :activity_seq_ IS NULL ';
   END IF;
   IF (handling_unit_id_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND handling_unit_id = :handling_unit_id_ ';
   ELSE
      stmt_ := stmt_ || ' AND :handling_unit_id_ IS NULL ';
   END IF;
   IF (alt_handling_unit_label_id_ = '%') THEN 
      stmt_ := stmt_ || ' AND :alt_handling_unit_label_id_ = ''%'' ';
   ELSIF (alt_handling_unit_label_id_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND alt_handling_unit_label_id  = :alt_handling_unit_label_id_ ';
   ELSE
      stmt_ := stmt_ || ' AND (alt_handling_unit_label_id IS NULL AND :alt_handling_unit_label_id_ IS NULL) ';
   END IF;
   
   IF (sql_where_expression_ IS NOT NULL) THEN
      stmt_ := stmt_ || sql_where_expression_;
   END IF;

   IF (column_value_exist_check_) THEN
      IF (column_value_nullable_) THEN
         stmt_ := stmt_ || ' AND NVL('|| column_name_ ||', :string_null_) = NVL(:column_value_, :string_null)';
      ELSE -- NOT column_value_nullable_
        stmt_ := stmt_ || ' AND ' || column_name_ ||'  = :column_value_ ';
      END IF;
   END IF;


   IF (NOT column_value_exist_check_) THEN
      -- No column value exist check, only check the rest of the keys
      @ApproveDynamicStatement(2014-11-03,CHJALK)
      OPEN exist_control_ FOR stmt_ USING contract_,
                                          part_no_,
                                          configuration_id_,
                                          location_no_,
                                          lot_batch_no_,
                                          serial_no_,
                                          eng_chg_level_,
                                          waiv_dev_rej_no_,
                                          activity_seq_,
                                          handling_unit_id_,
                                          alt_handling_unit_label_id_;

   ELSIF (column_value_nullable_) THEN
      -- Column value check on a nullable column
      @ApproveDynamicStatement(2014-11-03,CHJALK)
      OPEN exist_control_ FOR stmt_ USING contract_,
                                          part_no_,
                                          configuration_id_,
                                          location_no_,
                                          lot_batch_no_,
                                          serial_no_,
                                          eng_chg_level_,
                                          waiv_dev_rej_no_,
                                          activity_seq_,
                                          handling_unit_id_,
                                          alt_handling_unit_label_id_,
                                          string_null_,
                                          column_value_,
                                          string_null_;

   ELSE
      -- Column value check without any nullable handling
      @ApproveDynamicStatement(2014-11-03,CHJALK)
      OPEN exist_control_ FOR stmt_ USING contract_,
                                          part_no_,
                                          configuration_id_,
                                          location_no_,
                                          lot_batch_no_,
                                          serial_no_,
                                          eng_chg_level_,
                                          waiv_dev_rej_no_,
                                          activity_seq_,
                                          handling_unit_id_,
                                          alt_handling_unit_label_id_,
                                          column_value_;
   END IF;
             
             
   FETCH exist_control_ INTO dummy_;
   IF (exist_control_%FOUND) THEN
      exist_ := TRUE;
   END IF;
   CLOSE exist_control_;
   IF (NOT exist_) THEN
      Error_SYS.Record_General(lu_name_, 'VALUENOTEXIST: :P1 :P2 does not exist in the context of the entered data and this process.', column_description_, column_value_);
   END IF;
END Record_With_Column_Value_Exist;


@UncheckedAccess
FUNCTION Get_Sum_Column_Value (
   contract_               IN  VARCHAR2,
   part_no_                IN  VARCHAR2,
   configuration_id_       IN  VARCHAR2,
   location_no_            IN  VARCHAR2,
   lot_batch_no_           IN  VARCHAR2,
   serial_no_              IN  VARCHAR2,
   eng_chg_level_          IN  VARCHAR2,
   waiv_dev_rej_no_        IN  VARCHAR2,
   activity_seq_           IN  NUMBER,
   handling_unit_id_       IN  NUMBER,
   column_name_            IN  VARCHAR2,
   sql_where_expression_   IN  VARCHAR2 DEFAULT NULL ) RETURN NUMBER
IS
   TYPE Get_Column_Value IS REF CURSOR;
   get_column_values_             Get_Column_Value;
   stmt_                          VARCHAR2(4000);
   column_value_                  NUMBER;
BEGIN
      
   IF column_name_ IN ('QTY_ONHAND', 'CATCH_QTY_ONHAND', 'QTY_RESERVED', 'QTY_IN_TRANSIT', 
                       'CATCH_QTY_IN_TRANSIT', 'COUNT_VARIANCE') THEN
   -- extra column check to be sure we have no risk for sql injection into column_name/data_item_id
      Assert_SYS.Assert_Is_Table_Column('INVENTORY_PART_IN_STOCK_TAB', column_name_);

      stmt_ := ' SELECT SUM(' || column_name_ || ')
                 FROM  INVENTORY_PART_IN_STOCK_TAB
                 WHERE contract          = :contract
                 AND   part_no           = :part_no
                 AND   configuration_id  = NVL(:configuration_id_, configuration_id )
                 AND   location_no       = NVL(:location_no_,      location_no      )
                 AND   lot_batch_no      = NVL(:lot_batch_no_,     lot_batch_no     )
                 AND   serial_no         = NVL(:serial_no_,        serial_no        )
                 AND   eng_chg_level     = NVL(:eng_chg_level_,    eng_chg_level    )
                 AND   waiv_dev_rej_no   = NVL(:waiv_dev_rej_no_,  waiv_dev_rej_no  )
                 AND   activity_seq      = NVL(:activity_seq_,     activity_seq     ) 
                 AND   handling_unit_id  = NVL(:handling_unit_id_, handling_unit_id ) 
                 AND   EXISTS (SELECT 1 FROM user_allowed_site_pub WHERE site = contract) ';


      IF (sql_where_expression_  IS NOT NULL) THEN
         stmt_ := stmt_ || sql_where_expression_ ;
      END IF;

      @ApproveDynamicStatement(2015-12-07,KHVESE)
      OPEN get_column_values_ FOR stmt_ USING contract_,
                                              part_no_,
                                              configuration_id_,
                                              location_no_,
                                              lot_batch_no_,
                                              serial_no_,
                                              eng_chg_level_,
                                              waiv_dev_rej_no_,
                                              activity_seq_,
                                              handling_unit_id_;
      LOOP
         FETCH get_column_values_ INTO column_value_;
         EXIT WHEN get_column_values_%NOTFOUND;
         
      END LOOP;
      CLOSE get_column_values_;
   END IF;

   RETURN column_value_;
END Get_Sum_Column_Value;


-- This method is used by DataCaptAttachPartHu, DataCaptFindInventory, DataCaptIssueInvPart, DataCaptRecFromTransit,
-- DataCaptScrapInvPart, DataCaptTranspTaskPart, DataCaptUnattachPartHu, DataCaptureCountPart, DataCaptureMovePart,
-- HandlingUnit, DataCaptReportPickPart, DataCaptManIssSoHu, DataCaptManIssSoPart, DataCaptRecSo, DataCaptRecSoHu,
-- DataCaptRepPickPartSo, DataCaptManIssueWo and DataCaptUnplanIssueWo
@ServerOnlyAccess
FUNCTION Get_Column_Value_If_Unique (
   no_unique_value_found_      OUT BOOLEAN,
   contract_                   IN  VARCHAR2,
   part_no_                    IN  VARCHAR2,
   configuration_id_           IN  VARCHAR2,
   location_no_                IN  VARCHAR2,
   lot_batch_no_               IN  VARCHAR2,
   serial_no_                  IN  VARCHAR2,
   eng_chg_level_              IN  VARCHAR2,
   waiv_dev_rej_no_            IN  VARCHAR2,
   activity_seq_               IN  NUMBER,
   handling_unit_id_           IN  NUMBER,
   alt_handling_unit_label_id_ IN  VARCHAR2,  -- send '%' if this item have not been entered/scanned yet
   column_name_                IN  VARCHAR2,
   sql_where_expression_       IN  VARCHAR2 DEFAULT NULL ) RETURN VARCHAR2
IS
   TYPE Get_Column_Value IS REF CURSOR;
   get_column_values_             Get_Column_Value;
   stmt_                          VARCHAR2(4000);
   unique_column_value_           VARCHAR2(50);
   too_many_values_found_         BOOLEAN := FALSE;
   TYPE Column_Value_Tab IS TABLE OF VARCHAR2(50) INDEX BY PLS_INTEGER;
   column_value_tab_     Column_Value_Tab;  
BEGIN
   -- extra column check to be sure we have no risk for sql injection into column_name/data_item_id
   Assert_SYS.Assert_Is_View_Column('INVENTORY_PART_IN_STOCK_TOTAL', column_name_);
   -- using INVENTORY_PART_IN_STOCK_TOTAL instead of table since we like to fetch condition_code among other columns that dont exist in the table.
   stmt_ := ' SELECT DISTINCT(' || column_name_ || ') 
              FROM  INVENTORY_PART_IN_STOCK_TOTAL
              WHERE EXISTS (SELECT 1 FROM user_allowed_site_pub WHERE site = contract) ';
   IF (contract_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND contract = :contract_ ';
   ELSE
      stmt_ := stmt_ || ' AND :contract_ IS NULL ';
   END IF;
   IF (part_no_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND part_no = :part_no_ ';
   ELSE
      stmt_ := stmt_ || ' AND :part_no_ IS NULL ';
   END IF;
   IF (configuration_id_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND configuration_id = :configuration_id_ ';
   ELSE
      stmt_ := stmt_ || ' AND :configuration_id_ IS NULL ';
   END IF;
   IF (location_no_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND location_no = :location_no_ ';
   ELSE
      stmt_ := stmt_ || ' AND :location_no_ IS NULL ';
   END IF;
   IF (lot_batch_no_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND lot_batch_no = :lot_batch_no_ ';
   ELSE
      stmt_ := stmt_ || ' AND :lot_batch_no_ IS NULL ';
   END IF;
    IF (serial_no_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND serial_no = :serial_no_ ';
   ELSE
      stmt_ := stmt_ || ' AND :serial_no_ IS NULL ';
   END IF;
   IF (eng_chg_level_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND eng_chg_level = :eng_chg_level_ ';
   ELSE
      stmt_ := stmt_ || ' AND :eng_chg_level_ IS NULL ';
   END IF;
   IF (waiv_dev_rej_no_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND waiv_dev_rej_no = :waiv_dev_rej_no_ ';
   ELSE
      stmt_ := stmt_ || ' AND :waiv_dev_rej_no_ IS NULL ';
   END IF;
   IF (activity_seq_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND activity_seq = :activity_seq_ ';
   ELSE
      stmt_ := stmt_ || ' AND :activity_seq_ IS NULL ';
   END IF;
   IF (handling_unit_id_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND handling_unit_id = :handling_unit_id_ ';
   ELSE
      stmt_ := stmt_ || ' AND :handling_unit_id_ IS NULL ';
   END IF;
   IF (alt_handling_unit_label_id_ = '%') THEN 
      stmt_ := stmt_ || ' AND :alt_handling_unit_label_id_ = ''%'' ';
   ELSIF (alt_handling_unit_label_id_ IS NOT NULL) THEN 
      stmt_ := stmt_ || ' AND alt_handling_unit_label_id  = :alt_handling_unit_label_id_ ';
   ELSE
      stmt_ := stmt_ || ' AND (alt_handling_unit_label_id IS NULL AND :alt_handling_unit_label_id_ IS NULL) ';
   END IF;
   
   IF (sql_where_expression_  IS NOT NULL) THEN
      stmt_ := stmt_ || sql_where_expression_ ;
   END IF;

   stmt_ := stmt_ || ' FETCH FIRST 2 ROWS ONLY ';   
   
   @ApproveDynamicStatement(2014-11-03,CHJALK)
   OPEN get_column_values_ FOR stmt_ USING contract_,
                                           part_no_,
                                           configuration_id_,
                                           location_no_,
                                           lot_batch_no_,
                                           serial_no_,
                                           eng_chg_level_,
                                           waiv_dev_rej_no_,
                                           activity_seq_,
                                           handling_unit_id_,
                                           alt_handling_unit_label_id_;
   FETCH get_column_values_ BULK COLLECT INTO column_value_tab_;
      IF (column_value_tab_.COUNT = 1) THEN
         unique_column_value_ := NVL(To_Char(column_value_tab_(1)), 'NULL');
      ELSIF (column_value_tab_.COUNT = 2) THEN  
         too_many_values_found_ := TRUE; -- more then one unique value found
      END IF;
   CLOSE get_column_values_;

   -- If no values was found at all then set no_unique_value_found_ out-param to TRUE else set it to FALSE. 
   -- This to be able to see the why this method returned NULL so we can know if it was because no values 
   -- was found at all or if it was because to many values was found. This can be used in process utilities which
   -- fetch unique values from several data sources for a specific data item, so that utility can check if 
   -- there was a combined unique value from the data sources or not.
   IF (unique_column_value_ IS NULL AND NOT too_many_values_found_) THEN 
      no_unique_value_found_ := TRUE;    -- no records found
   ELSE
      no_unique_value_found_ := FALSE; -- either a unique value was found or too many values was found
   END IF;
   
   RETURN unique_column_value_;
END Get_Column_Value_If_Unique;


@UncheckedAccess
FUNCTION Check_Consignment_Exist (
   contract_    IN VARCHAR2,
   part_no_     IN VARCHAR2,
   location_no_ IN VARCHAR2 DEFAULT NULL ) RETURN BOOLEAN
IS
   dummy_             NUMBER;
   consignment_exist_ BOOLEAN := FALSE;
   
   CURSOR check_consignment IS
      SELECT 1
      FROM INVENTORY_PART_IN_STOCK_TAB
      WHERE contract = contract_
      AND part_no = part_no_
      AND part_ownership = 'CONSIGNMENT'
      AND (location_no   = location_no_ OR location_no_ IS NULL);
BEGIN
   OPEN check_consignment;
   FETCH check_consignment INTO dummy_;
   IF check_consignment%FOUND THEN
      consignment_exist_ := TRUE;
   END IF;
   CLOSE check_consignment;
   RETURN(consignment_exist_);
END Check_Consignment_Exist;


PROCEDURE Modify_Owning_Customer_No (
   contract_                     IN VARCHAR2,
   part_no_                      IN VARCHAR2,
   configuration_id_             IN VARCHAR2,
   location_no_                  IN VARCHAR2,
   lot_batch_no_                 IN VARCHAR2,
   serial_no_                    IN VARCHAR2,
   eng_chg_level_                IN VARCHAR2,
   waiv_dev_rej_no_              IN VARCHAR2,
   activity_seq_                 IN NUMBER,
   handling_unit_id_             IN NUMBER,
   owning_customer_              IN VARCHAR2,
   part_tracking_session_id_     IN NUMBER,
   ownership_transfer_reason_id_ IN VARCHAR2)
IS
   oldrec_           INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   newrec_           INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   serial_catch_tab_ Serial_Catch_Table;
   part_catalog_rec_ Part_Catalog_API.Public_Rec;
BEGIN
   part_catalog_rec_ := Part_Catalog_API.Get(part_no_);
   Inventory_Event_Manager_API.Start_Session;

   IF (part_tracking_session_id_ IS NULL) THEN
      serial_catch_tab_(1).serial_no := serial_no_;
   ELSE
      Temporary_Part_Tracking_API.Get_Serials_And_Remove_Session(serial_catch_tab_, part_tracking_session_id_);

      IF (serial_catch_tab_.COUNT = 0) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'MOCNNOSERIAL: No serials have been identified for the transfer of ownership to customer :P1.', owning_customer_);
      END IF;

      oldrec_ := Lock_By_Keys___(contract_,
                                 part_no_,
                                 configuration_id_,
                                 location_no_,
                                 lot_batch_no_,
                                 serial_no_,
                                 eng_chg_level_,
                                 waiv_dev_rej_no_,
                                 activity_seq_,
                                 handling_unit_id_);

      IF (serial_catch_tab_.COUNT != oldrec_.qty_onhand) THEN
         Error_SYS.Record_General('InventoryPartInStock', 'REINPLSERCOUNTQS: The quantity of the stock record which ownership is being transferred to customer :P1 is :P2 but the number of identified serials is :P3', owning_customer_, oldrec_.qty_onhand, serial_catch_tab_.COUNT);
      END IF;

      Split_Into_Serials(contract_           => contract_,
                         part_no_            => part_no_,
                         configuration_id_   => configuration_id_,
                         location_no_        => location_no_,
                         lot_batch_no_       => lot_batch_no_,
                         eng_chg_level_      => eng_chg_level_,
                         waiv_dev_rej_no_    => waiv_dev_rej_no_,
                         activity_seq_       => activity_seq_,
                         handling_unit_id_   => handling_unit_id_,
                         serial_catch_tab_   => serial_catch_tab_,
                         reservation_        => FALSE);
   END IF;

   FOR i IN serial_catch_tab_.FIRST..serial_catch_tab_.LAST LOOP
      oldrec_ := Lock_By_Keys___(contract_,
                                 part_no_,
                                 configuration_id_,
                                 location_no_,
                                 lot_batch_no_,
                                 serial_catch_tab_(i).serial_no,
                                 eng_chg_level_,
                                 waiv_dev_rej_no_,
                                 activity_seq_,
                                 handling_unit_id_);
      --Check if user has selected lines with same owner that ownership is to be transfered to.
      IF (oldrec_.owning_customer_no = owning_customer_ ) THEN
         Error_SYS.Record_General(lu_name_,'SAMECUST: Part :P1 in :P2 already belongs to the customer that ownership to be transferred.', part_no_,location_no_||', '||contract_);
      END IF;
      -- Check if zero quantity onhand.
      IF (NOT oldrec_.qty_onhand > 0) THEN
         Error_SYS.Record_General(lu_name_,'ZEROONHAND: The transfer ownership between customers can be performed only for non-zero quantities.');
      END IF;   
      newrec_                    := oldrec_;
      newrec_.owning_customer_no := owning_customer_;
      Check_And_Update_By_Keys___(oldrec_                        => oldrec_,
                                  newrec_                        => newrec_,
                                  part_catalog_rec_              => part_catalog_rec_,
                                  ownership_transfer_reason_id_  => ownership_transfer_reason_id_);
   END LOOP;

   IF (part_tracking_session_id_ IS NOT NULL) THEN
      FOR i IN serial_catch_tab_.FIRST..serial_catch_tab_.LAST LOOP
         oldrec_ := Lock_By_Keys___(contract_,
                                    part_no_,
                                    configuration_id_,
                                    location_no_,
                                    lot_batch_no_,
                                    serial_catch_tab_(i).serial_no,
                                    eng_chg_level_,
                                    waiv_dev_rej_no_,
                                    activity_seq_,
                                    handling_unit_id_);
         Move_Part_Impl___(catch_quantity_                => oldrec_.catch_qty_onhand,
                           contract_                      => oldrec_.contract,
                           part_no_                       => oldrec_.part_no,
                           configuration_id_              => oldrec_.configuration_id,
                           location_no_                   => oldrec_.location_no,
                           lot_batch_no_                  => oldrec_.lot_batch_no,
                           serial_no_                     => oldrec_.serial_no,
                           eng_chg_level_                 => oldrec_.eng_chg_level,
                           waiv_dev_rej_no_               => oldrec_.waiv_dev_rej_no,
                           activity_seq_                  => oldrec_.activity_seq,
                           handling_unit_id_              => oldrec_.handling_unit_id, 
                           expiration_date_               => oldrec_.expiration_date,
                           to_contract_                   => oldrec_.contract,
                           to_part_no_                    => oldrec_.part_no,
                           to_location_no_                => oldrec_.location_no,
                           to_destination_db_             => 'N',
                           to_waiv_dev_rej_no_            => oldrec_.waiv_dev_rej_no,
                           to_lot_batch_no_               => oldrec_.lot_batch_no,
                           to_serial_no_                  => '*',
                           to_activity_seq_               => oldrec_.activity_seq,
                           to_handling_unit_id_           => oldrec_.handling_unit_id, 
                           quantity_                      => 1,
                           quantity_reserved_             => 0,
                           move_comment_                  => NULL,
                           order_no_                      => NULL,
                           line_no_                       => NULL,
                           release_no_                    => NULL,
                           line_item_no_                  => NULL,
                           source_ref5_                   => NULL,
                           order_type_                    => NULL,
                           consume_consignment_stock_     => FALSE,
                           make_transaction_and_postings_ => FALSE,
                           report_earned_value_db_        => NULL,
                           from_part_catalog_rec_         => part_catalog_rec_,
                           to_part_catalog_rec_           => part_catalog_rec_,
                           transport_task_id_             => NULL,
                           validate_hu_struct_position_   => FALSE,
                           availability_ctrl_id_          => NULL,
                           always_preserve_serial_no_     => FALSE,
                           ownership_transfer_reason_id_  => NULL);
      END LOOP;
   END IF;
   Inventory_Event_Manager_API.Finish_Session;
END Modify_Owning_Customer_No;


-- Get_Company_Owned_Unit_Cost
--   This method retrieves unit cost of a company owned part.
--   --@PoReadOnly( Get_Company_Owned_Unit_Cost ) annotation has added to api
@UncheckedAccess
FUNCTION Get_Company_Owned_Unit_Cost (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_no_      IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,   
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER ) RETURN NUMBER
IS
   stock_rec_                 INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   company_owned_unit_cost_   NUMBER := 0;
   condition_code_            VARCHAR2(50);
   invent_part_cost_level_db_ VARCHAR2(50);
   use_get_default_details_   BOOLEAN := FALSE;
   qty_onhand_                NUMBER;
   qty_in_transit_            NUMBER;
BEGIN
   stock_rec_ := Get_Object_By_Keys___(contract_,        
                                       part_no_,         
                                       configuration_id_,
                                       location_no_,     
                                       lot_batch_no_,    
                                       serial_no_,       
                                       eng_chg_level_,   
                                       waiv_dev_rej_no_, 
                                       activity_seq_,
                                       handling_unit_id_);
                                       
   IF (stock_rec_.part_ownership = Part_Ownership_API.DB_COMPANY_OWNED) THEN
      Invent_Part_Quantity_Util_API.Get_Company_Owned_Inventory(qty_onhand_,
                                                                qty_in_transit_,
                                                                contract_,
                                                                part_no_,
                                                                configuration_id_,
                                                                lot_batch_no_,
                                                                serial_no_);

      IF ((qty_onhand_ = 0) AND (qty_in_transit_ = 0)) THEN

         invent_part_cost_level_db_ := Inventory_Part_API.Get_Invent_Part_Cost_Level_Db(contract_,
                                                                                        part_no_);
         IF (invent_part_cost_level_db_ IN ('COST PER CONDITION',
                                            'COST PER LOT BATCH',
                                            'COST PER SERIAL')) THEN
            IF (invent_part_cost_level_db_ = 'COST PER CONDITION') THEN
               condition_code_ := Condition_Code_Manager_API.Get_Condition_Code(part_no_,
                                                                                serial_no_,
                                                                                lot_batch_no_);
            END IF;
            use_get_default_details_ := TRUE;
         END IF;
      END IF;

      IF (use_get_default_details_) THEN
         company_owned_unit_cost_ := Inventory_Part_Unit_Cost_API.Get_Total_Unit_Cost(
                                        Inventory_Part_Unit_Cost_API.Get_Default_Details(contract_,
                                                                                         part_no_,
                                                                                         configuration_id_,
                                                                                         lot_batch_no_,
                                                                                         serial_no_,
                                                                                         condition_code_,
                                                                                         NULL));
      ELSE
         company_owned_unit_cost_ := Inventory_Part_Unit_Cost_API.Get_Inventory_Value_By_Method(contract_,
                                                                                                part_no_,
                                                                                                configuration_id_,
                                                                                                lot_batch_no_,
                                                                                                serial_no_);
      END IF;
   END IF;
   RETURN (company_owned_unit_cost_);
END Get_Company_Owned_Unit_Cost;


FUNCTION Get_Closest_Work_Day (
   calendar_id_ IN VARCHAR2,
   date_        IN DATE ) RETURN DATE
IS
   closest_work_day_       DATE;
   last_calendar_date_     DATE         := Database_Sys.last_calendar_date_;
BEGIN
   IF (date_ >= last_calendar_date_) THEN
      closest_work_day_ := date_;
   ELSE
      closest_work_day_ := Work_Time_Calendar_API.Get_Closest_Work_Day(calendar_id_, date_);
   END IF;
   RETURN (closest_work_day_);
END Get_Closest_Work_Day;


PROCEDURE Check_Ownership_Move_Part (
   from_part_ownership_db_    IN VARCHAR2,
   from_owning_vendor_no_     IN VARCHAR2,
   from_owning_customer_no_   IN VARCHAR2,
   from_part_no_              IN VARCHAR2,
   from_location_no_          IN VARCHAR2,
   from_location_type_        IN VARCHAR2,
   to_part_ownership_db_      IN VARCHAR2,
   to_owning_vendor_no_       IN VARCHAR2,
   to_owning_customer_no_     IN VARCHAR2,
   to_part_no_                IN VARCHAR2,
   to_location_no_            IN VARCHAR2,
   to_destination_db_         IN VARCHAR2,
   consume_consignment_stock_ IN BOOLEAN )
IS
   db_company_owned_   CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_COMPANY_OWNED;
   db_consignment_     CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_CONSIGNMENT;
   exit_procedure_     EXCEPTION;
BEGIN
  IF ((to_part_no_ IS NULL) OR
      (to_part_ownership_db_ IS NULL )) THEN
     RAISE exit_procedure_;
  END IF;

  IF ((from_part_ownership_db_                     != to_part_ownership_db_)  OR
      (NVL(from_owning_vendor_no_  , string_null_) != NVL(to_owning_vendor_no_  , string_null_))  OR
      (NVL(from_owning_customer_no_, string_null_) != NVL(to_owning_customer_no_, string_null_))) THEN
     IF NOT ((from_part_ownership_db_ = db_consignment_) AND
             (to_part_ownership_db_   = db_company_owned_)AND
             (consume_consignment_stock_)) THEN
        Raise_Ownership_Mism_Error___;
     END IF;
  END IF;

  IF ((consume_consignment_stock_) AND from_location_type_ IN (Inventory_Location_Type_API.DB_ARRIVAL,
                                                               Inventory_Location_Type_API.DB_QUALITY_ASSURANCE)) THEN
     Error_SYS.Record_General(lu_name_,'PURCON: You are not allowed to consume part :P1 from purchase location :P2.', from_part_no_, from_location_no_);
  END IF;

  IF (from_part_ownership_db_ = db_consignment_) OR (to_part_ownership_db_ = db_consignment_) THEN
       -- Transit
     IF (to_destination_db_ = Inventory_Part_Destination_API.DB_MOVE_TO_TRANSIT) THEN
        Error_SYS.Record_General(lu_name_,'DESTTRANSIT: You are not allowed to move a consignment stock of part :P1 at location :P2 into transit.', from_part_no_, from_location_no_);
     END IF;

     IF (to_part_ownership_db_ = db_consignment_ ) AND (consume_consignment_stock_) THEN
        Raise_Ownership_Mism_Error___;
     END IF;
  END IF;
EXCEPTION
   WHEN exit_procedure_ THEN
      NULL;
END Check_Ownership_Move_Part;


PROCEDURE Check_Allow_Ownership_Mix (
   contract_           IN VARCHAR2,
   part_no_            IN VARCHAR2,
   location_no_        IN VARCHAR2,
   part_ownership_db_  IN VARCHAR2,
   owning_customer_no_ IN VARCHAR2,
   owning_vendor_no_   IN VARCHAR2 )
IS
   db_consignment_           CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_CONSIGNMENT;
   db_supplier_loaned_       CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_SUPPLIER_LOANED;
   db_supplier_owned_        CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_SUPPLIER_OWNED;
   db_customer_owned_        CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_CUSTOMER_OWNED;
   db_supplier_rented_       CONSTANT INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE := Part_Ownership_API.DB_SUPPLIER_RENTED;
   stock_part_ownership_db_  INVENTORY_PART_IN_STOCK_TAB.part_ownership%TYPE;
   stock_owning_customer_no_ INVENTORY_PART_IN_STOCK_TAB.owning_customer_no%TYPE;
   stock_owning_vendor_no_   INVENTORY_PART_IN_STOCK_TAB.owning_vendor_no%TYPE;
   diff_owner_counter_       NUMBER := 0;
   other_owners_are_inbound_ BOOLEAN;

   CURSOR get_dif_owner IS
      SELECT part_ownership, owning_customer_no, owning_vendor_no 
        FROM INVENTORY_PART_IN_STOCK_TAB
       WHERE contract        = contract_    
         AND part_no         = part_no_     
         AND location_no     = location_no_ 
         AND (qty_onhand != 0 OR qty_in_transit != 0) 
         AND (NVL(part_ownership, string_null_) != NVL(part_ownership_db_, string_null_) OR 
              (part_ownership_db_ IN (db_consignment_, db_supplier_loaned_, db_supplier_owned_, db_supplier_rented_) AND 
               owning_vendor_no != NVL(owning_vendor_no_, string_null_)) OR 
              (part_ownership_db_ = db_customer_owned_ AND 
             owning_customer_no                != NVL(owning_customer_no_, string_null_)));
BEGIN
   IF (Site_Invent_Info_API.Get_Allow_Partloc_Owner_Mix_Db(contract_) = Fnd_Boolean_API.DB_FALSE) THEN
      FOR owner_rec_ IN get_dif_owner LOOP
         stock_part_ownership_db_  := owner_rec_.part_ownership; 
         stock_owning_customer_no_ := owner_rec_.owning_customer_no;
         stock_owning_vendor_no_   := owner_rec_.owning_vendor_no;
         diff_owner_counter_       := diff_owner_counter_ + 1;
      END LOOP;
      
      IF (diff_owner_counter_ > 0) THEN 
         IF (diff_owner_counter_ = 1) THEN                         
            -- Only if there is exactly one owner then we will disply the owner in the error message
            Error_SYS.Record_General(lu_name_, 'OWNERMISMATCHATLOC1: Multiple Owners per Inventory Part per Location is not allowed on site :P1. ' ||
                                            'Current ownership for part/location :P2 is :P3.',
                                  contract_,
                                  part_no_ || ' / ' || location_no_,
                                  Part_Ownership_API.Decode(stock_part_ownership_db_)||CASE stock_part_ownership_db_ 
                                                              WHEN Part_Ownership_API.DB_COMPANY_OWNED THEN NULL 
                                                              WHEN Part_Ownership_API.DB_COMPANY_RENTAL_ASSET THEN NULL 
                                                              ELSE ' - '||stock_owning_customer_no_||stock_owning_vendor_no_ END);
         ELSE         
            Error_SYS.Record_General(lu_name_, 'OWNERMISMATCHATLOC2: Multiple Owners per Inventory Part per Location is not allowed on site :P1. ', contract_);
         END IF;
      END IF;
      other_owners_are_inbound_ := Transport_Task_Line_API.Other_Owners_Are_Inbound(contract_,
                                                                                    part_no_,
                                                                                    location_no_,
                                                                                    part_ownership_db_,
                                                                                    owning_customer_no_,
                                                                                    owning_vendor_no_);
      IF (other_owners_are_inbound_) THEN
         Error_SYS.Record_General(lu_name_, 'OWNERMISMATCHATLOC3: Multiple Owners per Inventory Part per Location is not allowed on site :P1. Quantities of Part :P2 with different ownership is already inbound for Location :P3 on Transport Task(s).', contract_, part_no_, location_no_);
      END IF;
   END IF;
END Check_Allow_Ownership_Mix;


@UncheckedAccess
FUNCTION Externally_Owned_Stock_Exist (
   contract_    IN VARCHAR2,
   part_no_     IN VARCHAR2,
   location_no_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   exist_   BOOLEAN := FALSE;
   dummy_   NUMBER;

   CURSOR check_externally_owned_stock IS
      SELECT 1
      FROM INVENTORY_PART_IN_STOCK_TAB
      WHERE contract = contract_
      AND   part_no = part_no_
      AND   location_no = location_no_
      AND   NVL(part_ownership, Part_Ownership_API.DB_COMPANY_OWNED ) != Part_Ownership_API.DB_COMPANY_OWNED ;
BEGIN
   OPEN check_externally_owned_stock;
   FETCH check_externally_owned_stock INTO dummy_;
   IF check_externally_owned_stock%FOUND THEN
      exist_ := TRUE;
   END IF;
   CLOSE check_externally_owned_stock;
   RETURN(exist_);
END Externally_Owned_Stock_Exist;


PROCEDURE Split_Into_Serials (
   contract_            IN VARCHAR2,
   part_no_             IN VARCHAR2,
   configuration_id_    IN VARCHAR2,
   location_no_         IN VARCHAR2,
   lot_batch_no_        IN VARCHAR2,
   eng_chg_level_       IN VARCHAR2,
   waiv_dev_rej_no_     IN VARCHAR2,
   activity_seq_        IN NUMBER,
   handling_unit_id_    IN NUMBER,
   serial_catch_tab_    IN Serial_Catch_Table,
   reservation_         IN BOOLEAN)
IS
   dummy_number_                 NUMBER;
   part_catalog_rec_             Part_Catalog_API.Public_Rec;
   catch_quantity_               INVENTORY_PART_IN_STOCK_TAB.catch_qty_onhand%TYPE;
   from_stock_rec_               INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   quantity_reserved_            INVENTORY_PART_IN_STOCK_TAB.qty_reserved%TYPE;
BEGIN
   from_stock_rec_   := Lock_By_Keys___(contract_,
                                        part_no_,
                                        configuration_id_,
                                        location_no_,
                                        lot_batch_no_,
                                        '*',
                                        eng_chg_level_,
                                        waiv_dev_rej_no_,
                                        activity_seq_,
                                        handling_unit_id_);
   
   part_catalog_rec_     := Part_Catalog_API.Get(part_no_);

   IF (reservation_) THEN
      IF (from_stock_rec_.qty_reserved < serial_catch_tab_.COUNT) THEN
         Error_SYS.Record_General(lu_name_, 'SPLITRESQTY: Splitting into :P1 serial(s) is impossible since the quantity reserved on the stock record is only :P2.', serial_catch_tab_.COUNT, from_stock_rec_.qty_reserved);
      END IF;
      quantity_reserved_ := 1;
   ELSE
      IF ((from_stock_rec_.qty_onhand - from_stock_rec_.qty_reserved) < serial_catch_tab_.COUNT) THEN
         Error_SYS.Record_General(lu_name_, 'SPLITAVAILQTY: Splitting into :P1 serial(s) is impossible since the quantity available on the stock record is only :P2.', serial_catch_tab_.COUNT, (from_stock_rec_.qty_onhand - from_stock_rec_.qty_reserved));
      END IF;
      quantity_reserved_ := 0;
   END IF;

   IF (part_catalog_rec_.receipt_issue_serial_track = db_false_) THEN
      Error_SYS.Record_General(lu_name_, 'SPLITRECTRACK: Splitting a stock record into serials is only allowed for a part which is serial tracked at receipt and issue.');
   END IF;

   IF (serial_catch_tab_.COUNT > 0) THEN
      Inventory_Event_Manager_API.Start_Session;
      FOR i IN serial_catch_tab_.FIRST..serial_catch_tab_.LAST LOOP

         Check_Split_Into_Serials___(from_stock_rec_, serial_catch_tab_(i).serial_no);

         catch_quantity_ := serial_catch_tab_(i).catch_qty;

         Move_Part_Impl___(catch_quantity_                => catch_quantity_,
                           contract_                      => contract_,
                           part_no_                       => part_no_,
                           configuration_id_              => configuration_id_,
                           location_no_                   => location_no_,
                           lot_batch_no_                  => lot_batch_no_,
                           serial_no_                     => '*',
                           eng_chg_level_                 => eng_chg_level_,
                           waiv_dev_rej_no_               => waiv_dev_rej_no_,
                           activity_seq_                  => activity_seq_,
                           handling_unit_id_              => handling_unit_id_,
                           expiration_date_               => NULL,
                           to_contract_                   => contract_,
                           to_part_no_                    => part_no_,
                           to_location_no_                => location_no_,
                           to_destination_db_             => 'N',
                           to_waiv_dev_rej_no_            => waiv_dev_rej_no_,
                           to_lot_batch_no_               => lot_batch_no_,
                           to_serial_no_                  => serial_catch_tab_(i).serial_no,
                           to_activity_seq_               => activity_seq_,
                           to_handling_unit_id_           => handling_unit_id_,
                           quantity_                      => 1,
                           quantity_reserved_             => quantity_reserved_,
                           move_comment_                  => NULL,
                           order_no_                      => NULL,
                           line_no_                       => NULL,
                           release_no_                    => NULL,
                           line_item_no_                  => NULL,
                           source_ref5_                   => NULL,
                           order_type_                    => NULL,
                           consume_consignment_stock_     => FALSE,
                           make_transaction_and_postings_ => FALSE,
                           report_earned_value_db_        => NULL,
                           from_part_catalog_rec_         => part_catalog_rec_,
                           to_part_catalog_rec_           => part_catalog_rec_,
                           transport_task_id_             => NULL,
                           validate_hu_struct_position_   => FALSE,
                           availability_ctrl_id_          => NULL,
                           always_preserve_serial_no_     => FALSE,
                           ownership_transfer_reason_id_  => NULL);

         IF (reservation_) THEN
            Reserve_Part(catch_quantity_   => dummy_number_,
                         contract_         => contract_,
                         part_no_          => part_no_,
                         configuration_id_ => configuration_id_,
                         location_no_      => location_no_,
                         lot_batch_no_     => lot_batch_no_,
                         serial_no_        => serial_catch_tab_(i).serial_no,
                         eng_chg_level_    => eng_chg_level_,
                         waiv_dev_rej_no_  => waiv_dev_rej_no_,
                         activity_seq_     => activity_seq_,
                         handling_unit_id_ => handling_unit_id_,
                         quantity_         => 1);
         END IF;
      END LOOP;
      Inventory_Event_Manager_API.Finish_Session;
      END IF;
END Split_Into_Serials;


@UncheckedAccess
FUNCTION Get_Serial_No_For_Stock (
   part_no_          IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   part_catalog_rec_ IN Part_Catalog_API.Public_Rec,
   location_type_db_ IN VARCHAR2,
   handling_unit_id_ IN NUMBER ) RETURN VARCHAR2
IS
   serial_no_for_stock_ INVENTORY_PART_IN_STOCK_TAB.serial_no%TYPE;
BEGIN
   IF ((part_catalog_rec_.serial_tracking_code = db_not_serial_tracking_) AND
       (serial_no_ != '*') AND
       (Stock_Location___(location_type_db_)) AND
       (location_type_db_ != Inventory_Location_Type_API.DB_SHIPMENT) AND 
       (handling_unit_id_ = 0)) THEN
      -- IF the part is not serial tracked in inventory then receipt into a stock location (not Arrival, Qa or Shipment)
      -- should be done into records having serial_no = '*'.
      IF (Part_Serial_Catalog_API.Get_Tracked_In_Inventory_Db(part_no_, serial_no_) = db_true_) THEN
         serial_no_for_stock_ := serial_no_;
      ELSE
         serial_no_for_stock_ := '*';
      END IF;
   ELSE
      serial_no_for_stock_ := serial_no_;
   END IF;

   RETURN (serial_no_for_stock_);
END Get_Serial_No_For_Stock;


FUNCTION Get_Consumed_Carrying_Capacity (
   contract_                     IN VARCHAR2,
   warehouse_id_                 IN VARCHAR2,
   bay_id_                       IN VARCHAR2,
   tier_id_                      IN VARCHAR2 DEFAULT NULL,
   row_id_                       IN VARCHAR2 DEFAULT NULL,
   bin_id_                       IN VARCHAR2 DEFAULT NULL,
   ignore_this_handling_unit_id_ IN NUMBER   DEFAULT NULL ) RETURN NUMBER
IS
   consumed_carrying_capacity_    NUMBER := 0;
   carrying_capacity_requirement_ NUMBER;

   CURSOR get_part_bin_quantities IS
      SELECT part_no, SUM(qty_onhand + qty_in_transit) quantity
        FROM INVENTORY_PART_IN_STOCK_TAB
       WHERE contract         = contract_
         AND warehouse        = warehouse_id_
         AND bay_no           = bay_id_
         AND tier_no          = tier_id_
         AND row_no           = row_id_
         AND bin_no           = bin_id_
         AND handling_unit_id = 0
      GROUP BY part_no
      HAVING sum(qty_onhand + qty_in_transit) > 0;

   CURSOR get_part_tier_row_quantities IS
      SELECT part_no, SUM(qty_onhand + qty_in_transit) quantity
        FROM INVENTORY_PART_IN_STOCK_TAB
       WHERE contract         = contract_
         AND warehouse        = warehouse_id_
         AND bay_no           = bay_id_
         AND tier_no          = tier_id_
         AND row_no           = row_id_
         AND handling_unit_id = 0
      GROUP BY part_no
      HAVING sum(qty_onhand + qty_in_transit) > 0;

   CURSOR get_part_row_quantities IS
      SELECT part_no, SUM(qty_onhand + qty_in_transit) quantity
        FROM INVENTORY_PART_IN_STOCK_TAB
       WHERE contract         = contract_
         AND warehouse        = warehouse_id_
         AND bay_no           = bay_id_
         AND row_no           = row_id_
         AND handling_unit_id = 0
      GROUP BY part_no
      HAVING sum(qty_onhand + qty_in_transit) > 0;
   
   CURSOR get_part_tier_quantities IS
      SELECT part_no, SUM(qty_onhand + qty_in_transit) quantity
        FROM INVENTORY_PART_IN_STOCK_TAB
       WHERE contract         = contract_
         AND warehouse        = warehouse_id_
         AND bay_no           = bay_id_
         AND tier_no          = tier_id_
         AND handling_unit_id = 0
      GROUP BY part_no
      HAVING sum(qty_onhand + qty_in_transit) > 0;
   
   CURSOR get_part_bay_quantities IS
      SELECT part_no, SUM(qty_onhand + qty_in_transit) quantity
        FROM INVENTORY_PART_IN_STOCK_TAB
       WHERE contract         = contract_
         AND warehouse        = warehouse_id_
         AND bay_no           = bay_id_
         AND handling_unit_id = 0
      GROUP BY part_no
      HAVING sum(qty_onhand + qty_in_transit) > 0;

   TYPE Part_Quantity_Tab IS TABLE OF get_part_bin_quantities%ROWTYPE INDEX BY BINARY_INTEGER;
   part_quantity_tab_ Part_Quantity_Tab;

BEGIN
   IF (bin_id_ IS NULL) THEN
      IF (row_id_ IS NULL) THEN
         IF (tier_id_ IS NULL) THEN
            OPEN  get_part_bay_quantities;
            FETCH get_part_bay_quantities BULK COLLECT INTO part_quantity_tab_;
            CLOSE get_part_bay_quantities;
         ELSE
            OPEN  get_part_tier_quantities;
            FETCH get_part_tier_quantities BULK COLLECT INTO part_quantity_tab_;
            CLOSE get_part_tier_quantities;
         END IF;
      ELSE
         IF (tier_id_ IS NULL) THEN
            OPEN  get_part_row_quantities;
            FETCH get_part_row_quantities BULK COLLECT INTO part_quantity_tab_;
            CLOSE get_part_row_quantities;
         ELSE
            OPEN  get_part_tier_row_quantities;
            FETCH get_part_tier_row_quantities BULK COLLECT INTO part_quantity_tab_;
            CLOSE get_part_tier_row_quantities;
         END IF;
      END IF;
   ELSE
      OPEN  get_part_bin_quantities;
      FETCH get_part_bin_quantities BULK COLLECT INTO part_quantity_tab_;
      CLOSE get_part_bin_quantities;
   END IF;

   IF (part_quantity_tab_.COUNT > 0) THEN
      -- Find the weight of the unpacked parts stored in this storage area.
      FOR i IN part_quantity_tab_.FIRST..part_quantity_tab_.LAST LOOP
         carrying_capacity_requirement_ := Inventory_Part_API.Get_Storage_Weight_Requirement(contract_,
                                                                                             part_quantity_tab_(i).part_no);
         IF (carrying_capacity_requirement_ IS NULL) THEN
            consumed_carrying_capacity_ := Inventory_Putaway_Manager_API.positive_infinity_;
            EXIT;
         ELSE
            consumed_carrying_capacity_ := consumed_carrying_capacity_ +
                                           (carrying_capacity_requirement_ * part_quantity_tab_(i).quantity);
         END IF;
      END LOOP;
   END IF;

   IF (consumed_carrying_capacity_ < Inventory_Putaway_Manager_API.positive_infinity_) THEN
      -- Add the weight of the handling units stored in this storage area.
      consumed_carrying_capacity_ := consumed_carrying_capacity_ + Handling_Unit_API.Get_Operative_Gross_Weight(contract_,
                                                                                                                warehouse_id_,
                                                                                                                bay_id_,
                                                                                                                tier_id_,
                                                                                                                row_id_,
                                                                                                                bin_id_,
                                                                                                                ignore_this_handling_unit_id_);
   END IF;

   IF (consumed_carrying_capacity_ < Inventory_Putaway_Manager_API.positive_infinity_) THEN
      -- Add the weight of parts and handling units booked for transport into this storage area.
      consumed_carrying_capacity_ := consumed_carrying_capacity_ +
                                     Transport_Task_API.Get_Booked_Carrying_Capacity(contract_,
                                                                                     warehouse_id_,
                                                                                     bay_id_,
                                                                                     tier_id_,
                                                                                     row_id_,
                                                                                     bin_id_,
                                                                                     ignore_this_handling_unit_id_);
   END IF;

   RETURN (consumed_carrying_capacity_);
END Get_Consumed_Carrying_Capacity; 


FUNCTION Get_Consumed_Volume_Capacity (
   contract_                     IN VARCHAR2,
   warehouse_id_                 IN VARCHAR2,
   bay_id_                       IN VARCHAR2,
   tier_id_                      IN VARCHAR2,
   row_id_                       IN VARCHAR2,
   bin_id_                       IN VARCHAR2,
   ignore_this_handling_unit_id_ IN NUMBER DEFAULT NULL ) RETURN NUMBER
IS
   consumed_volume_capacity_    NUMBER := 0;
   volume_capacity_requirement_ NUMBER;

   CURSOR get_part_quantities IS
      SELECT part_no, SUM(qty_onhand + qty_in_transit) quantity
        FROM INVENTORY_PART_IN_STOCK_TAB
       WHERE contract         = contract_
         AND warehouse        = warehouse_id_
         AND bay_no           = bay_id_
         AND tier_no          = tier_id_
         AND row_no           = row_id_
         AND bin_no           = bin_id_
         AND handling_unit_id = 0
      GROUP BY part_no
      HAVING sum(qty_onhand + qty_in_transit) > 0;

   TYPE Part_Quantity_Tab IS TABLE OF get_part_quantities%ROWTYPE INDEX BY BINARY_INTEGER;
   part_quantity_tab_ Part_Quantity_Tab;

BEGIN
   OPEN  get_part_quantities;
   FETCH get_part_quantities BULK COLLECT INTO part_quantity_tab_;
   CLOSE get_part_quantities;

   IF (part_quantity_tab_.COUNT > 0) THEN
      -- Find the volume of the unpacked parts stored on this bin
      FOR i IN part_quantity_tab_.FIRST..part_quantity_tab_.LAST LOOP
         volume_capacity_requirement_ := Inventory_Part_API.Get_Storage_Volume_Requirement(contract_,
                                                                                           part_quantity_tab_(i).part_no);
         IF (volume_capacity_requirement_ IS NULL) THEN
            consumed_volume_capacity_ := Inventory_Putaway_Manager_API.positive_infinity_;
            EXIT;
         ELSE
            consumed_volume_capacity_ := consumed_volume_capacity_ +
                                           (volume_capacity_requirement_ * part_quantity_tab_(i).quantity);
         END IF;
      END LOOP;
   END IF;

   IF (consumed_volume_capacity_ < Inventory_Putaway_Manager_API.positive_infinity_) THEN
      -- Add the volume of the handling units stored on this bin
      consumed_volume_capacity_ := consumed_volume_capacity_ + Handling_Unit_API.Get_Operative_Volume(contract_,
                                                                                                      warehouse_id_,
                                                                                                      bay_id_,
                                                                                                      tier_id_,
                                                                                                      row_id_,
                                                                                                      bin_id_,
                                                                                                      ignore_this_handling_unit_id_);
   END IF;

   IF (consumed_volume_capacity_ < Inventory_Putaway_Manager_API.positive_infinity_) THEN
      -- Add the volume of parts and handling units booked for transport to this bin
      consumed_volume_capacity_ := consumed_volume_capacity_ +
                                     Transport_Task_API.Get_Booked_Volume_Capacity(contract_,
                                                                                   warehouse_id_,
                                                                                   bay_id_,
                                                                                   tier_id_,
                                                                                   row_id_,
                                                                                   bin_id_,
                                                                                   ignore_this_handling_unit_id_);
   END IF;

   RETURN (consumed_volume_capacity_);
END Get_Consumed_Volume_Capacity;


@UncheckedAccess
FUNCTION Other_Parts_Exist (
   contract_                      IN VARCHAR2,
   part_no_                       IN VARCHAR2,
   warehouse_id_                  IN VARCHAR2,
   bay_id_                        IN VARCHAR2,
   tier_id_                       IN VARCHAR2,
   row_id_                        IN VARCHAR2,
   bin_id_                        IN VARCHAR2,
   consider_unpicked_outbound_tt_ IN BOOLEAN  ) RETURN BOOLEAN
IS
   other_parts_exist_       BOOLEAN := FALSE;
   other_parts_are_inbound_ BOOLEAN := FALSE;
   qty_outbound_            NUMBER;
   location_no_             INVENTORY_PART_IN_STOCK_TAB.location_no%TYPE;

   CURSOR get_part_quantities IS
      SELECT part_no,
             configuration_id,
             location_no,
             SUM(qty_onhand + qty_in_transit) quantity
        FROM INVENTORY_PART_IN_STOCK_TAB
       WHERE contract     = contract_
         AND part_no     != part_no_
         AND warehouse    = warehouse_id_
         AND bay_no       = bay_id_
         AND tier_no      = tier_id_
         AND row_no       = row_id_
         AND bin_no       = bin_id_
         AND (qty_onhand != 0 OR qty_in_transit != 0)
      GROUP BY part_no, configuration_id, location_no;
BEGIN
   FOR rec_ IN get_part_quantities LOOP
      qty_outbound_ := Transport_Task_API.Get_Qty_Outbound(from_contract_          => contract_,
                                                           part_no_                => rec_.part_no,
                                                           configuration_id_       => rec_.configuration_id,
                                                           from_location_no_       => rec_.location_no,
                                                           include_unpicked_lines_ => consider_unpicked_outbound_tt_);
      IF (qty_outbound_ != rec_.quantity) THEN
         other_parts_exist_ := TRUE;
         EXIT;
      END IF;
   END LOOP;

   IF NOT (other_parts_exist_) THEN
      location_no_ := Warehouse_Bay_Bin_API.Get_Location_No(contract_,
                                                            warehouse_id_,
                                                            bay_id_,
                                                            tier_id_,
                                                            row_id_,
                                                            bin_id_);

      other_parts_are_inbound_ := Transport_Task_API.Other_Parts_Are_Inbound(contract_,
                                                                             part_no_,
                                                                             location_no_);
      IF (other_parts_are_inbound_) THEN
         other_parts_exist_ := TRUE;
      END IF;
   END IF;

   RETURN (other_parts_exist_);
END Other_Parts_Exist;

@UncheckedAccess
FUNCTION Any_Parts_Exist (
   contract_               IN VARCHAR2,
   warehouse_id_           IN VARCHAR2,
   bay_id_                 IN VARCHAR2,
   tier_id_                IN VARCHAR2,
   row_id_                 IN VARCHAR2,
   bin_id_                 IN VARCHAR2,
   consider_inbound_parts_ IN BOOLEAN ) RETURN BOOLEAN
IS
   any_parts_exist_       BOOLEAN := FALSE;
   any_parts_are_inbound_ BOOLEAN := FALSE;
   dummy_                 NUMBER;
   location_no_           INVENTORY_PART_IN_STOCK_TAB.location_no%TYPE;

   CURSOR exist_control IS
      SELECT 1
        FROM INVENTORY_PART_IN_STOCK_TAB
       WHERE contract     = contract_
         AND warehouse    = warehouse_id_
         AND bay_no       = bay_id_
         AND tier_no      = tier_id_
         AND row_no       = row_id_
         AND bin_no       = bin_id_
         AND (qty_onhand != 0 OR qty_in_transit != 0);
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      any_parts_exist_ := TRUE;
   END IF;
   CLOSE exist_control;

   IF NOT (any_parts_exist_) THEN
      IF (consider_inbound_parts_) THEN
         location_no_            := Warehouse_Bay_Bin_API.Get_Location_No(contract_, warehouse_id_, bay_id_, tier_id_, row_id_, bin_id_);
         any_parts_are_inbound_ := Transport_Task_API.Any_Parts_Are_Inbound(contract_, location_no_);
         IF (any_parts_are_inbound_) THEN
            any_parts_exist_ := TRUE;
         END IF;
      END IF;
   END IF;

   RETURN (any_parts_exist_);
END Any_Parts_Exist;


@UncheckedAccess
FUNCTION Other_Conditions_Exist (
   condition_code_                IN VARCHAR2,
   contract_                      IN VARCHAR2,
   warehouse_id_                  IN VARCHAR2,
   bay_id_                        IN VARCHAR2,
   tier_id_                       IN VARCHAR2,
   row_id_                        IN VARCHAR2,
   bin_id_                        IN VARCHAR2,
   consider_unpicked_outbound_tt_ IN BOOLEAN  ) RETURN BOOLEAN
IS
   other_conditions_exist_       BOOLEAN := FALSE;
   other_conditions_are_inbound_ BOOLEAN := FALSE;
   qty_outbound_                 NUMBER;
   location_no_                  INVENTORY_PART_IN_STOCK_TAB.location_no%TYPE;

   CURSOR get_condition_quantities IS
      SELECT part_no,
             configuration_id,
             lot_batch_no,
             serial_no,
             location_no,
             SUM(qty_onhand + qty_in_transit) quantity
        FROM INVENTORY_PART_IN_STOCK_TOTAL
       WHERE NVL(condition_code,Database_SYS.string_null_) != NVL(condition_code_,Database_SYS.string_null_)
         AND contract  = contract_
         AND warehouse = warehouse_id_
         AND bay_no    = bay_id_
         AND tier_no   = tier_id_
         AND row_no    = row_id_
         AND bin_no    = bin_id_
         AND (qty_onhand != 0 OR qty_in_transit != 0)
      GROUP BY part_no, configuration_id, lot_batch_no, serial_no, location_no;
BEGIN
   FOR rec_ IN get_condition_quantities LOOP

      qty_outbound_ := Transport_Task_API.Get_Qty_Outbound(from_contract_          => contract_,
                                                           part_no_                => rec_.part_no,
                                                           configuration_id_       => rec_.configuration_id,
                                                           from_location_no_       => rec_.location_no,
                                                           lot_batch_no_           => rec_.lot_batch_no,
                                                           serial_no_              => rec_.serial_no,
                                                           include_unpicked_lines_ => consider_unpicked_outbound_tt_);
      IF (qty_outbound_ != rec_.quantity) THEN
         other_conditions_exist_ := TRUE;
         EXIT;
      END IF;
   END LOOP;

   IF NOT (other_conditions_exist_) THEN
      location_no_ := Warehouse_Bay_Bin_API.Get_Location_No(contract_,
                                                            warehouse_id_,
                                                            bay_id_,
                                                            tier_id_,
                                                            row_id_,
                                                            bin_id_);

      other_conditions_are_inbound_ := Transport_Task_API.Other_Conditions_Are_Inbound(condition_code_,
                                                                                       contract_,
                                                                                       location_no_);
      IF (other_conditions_are_inbound_) THEN
         other_conditions_exist_ := TRUE;
      END IF;
   END IF;

   RETURN (other_conditions_exist_);
END Other_Conditions_Exist;


@UncheckedAccess
FUNCTION Other_Lots_Exist (
   contract_                      IN VARCHAR2,
   part_no_                       IN VARCHAR2,
   lot_batch_no_                  IN VARCHAR2,
   warehouse_id_                  IN VARCHAR2,
   bay_id_                        IN VARCHAR2,
   tier_id_                       IN VARCHAR2,
   row_id_                        IN VARCHAR2,
   bin_id_                        IN VARCHAR2,
   consider_unpicked_outbound_tt_ IN BOOLEAN  ) RETURN BOOLEAN
IS
   other_lots_exist_       BOOLEAN := FALSE;
   other_lots_are_inbound_ BOOLEAN := FALSE;
   qty_outbound_           NUMBER;
   location_no_            INVENTORY_PART_IN_STOCK_TAB.location_no%TYPE;

   CURSOR get_lot_quantities IS
      SELECT lot_batch_no,
             configuration_id,             
             location_no,
             SUM(qty_onhand + qty_in_transit) quantity
        FROM INVENTORY_PART_IN_STOCK_TAB
       WHERE lot_batch_no != lot_batch_no_
         AND contract      = contract_
         AND part_no       = part_no_
         AND warehouse     = warehouse_id_
         AND bay_no        = bay_id_
         AND tier_no       = tier_id_
         AND row_no        = row_id_
         AND bin_no        = bin_id_
         AND (qty_onhand != 0 OR qty_in_transit != 0)
      GROUP BY lot_batch_no, configuration_id, location_no;
BEGIN
   FOR rec_ IN get_lot_quantities LOOP
      qty_outbound_ := Transport_Task_API.Get_Qty_Outbound(from_contract_          => contract_,
                                                           part_no_                => part_no_,
                                                           configuration_id_       => rec_.configuration_id,
                                                           from_location_no_       => rec_.location_no,
                                                           lot_batch_no_           => rec_.lot_batch_no,
                                                           include_unpicked_lines_ => consider_unpicked_outbound_tt_);
      IF (qty_outbound_ != rec_.quantity) THEN
         other_lots_exist_ := TRUE;
         EXIT;
      END IF;
   END LOOP;

   IF NOT (other_lots_exist_) THEN
      location_no_ := Warehouse_Bay_Bin_API.Get_Location_No(contract_,
                                                            warehouse_id_,
                                                            bay_id_,
                                                            tier_id_,
                                                            row_id_,
                                                            bin_id_);

      other_lots_are_inbound_ := Transport_Task_API.Other_Lots_Are_Inbound(contract_,
                                                                           part_no_,
                                                                           lot_batch_no_,
                                                                           location_no_);
      IF (other_lots_are_inbound_) THEN
         other_lots_exist_ := TRUE;
      END IF;
   END IF;

   RETURN (other_lots_exist_);
END Other_Lots_Exist;


PROCEDURE Receive_Customer_Order_Return (
   transaction_id_tab_ OUT Inventory_Transaction_Hist_API.Transaction_Id_Tab,
   contract_           IN  VARCHAR2,
   part_no_            IN  VARCHAR2,
   configuration_id_   IN  VARCHAR2,
   location_no_        IN  VARCHAR2,
   lot_batch_no_       IN  VARCHAR2,
   serial_no_          IN  VARCHAR2,
   eng_chg_level_      IN  VARCHAR2,
   waiv_dev_rej_no_    IN  VARCHAR2,
   activity_seq_       IN  NUMBER,
   handling_unit_id_   IN  NUMBER,
   transaction_code_   IN  VARCHAR2,
   expiration_date_    IN  DATE,
   qty_returned_       IN  NUMBER,
   catch_qty_returned_ IN  NUMBER,
   rma_no_             IN  NUMBER,
   rma_line_no_        IN  NUMBER,
   source_             IN  VARCHAR2,
   condition_code_     IN  VARCHAR2,
   part_ownership_db_  IN  VARCHAR2,
   owning_vendor_no_   IN  VARCHAR2,   
   del_reason_id_      IN  VARCHAR2  DEFAULT NULL,
   del_note_no_        IN  VARCHAR2  DEFAULT NULL,
   del_note_date_      IN  DATE      DEFAULT NULL)
IS
   receipt_transaction_id_        NUMBER;
   cost_detail_tab_               Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   issue_transaction_id_tab_      Inventory_Transaction_Hist_API.Transaction_Id_Tab;
   issue_transaction_qty_         NUMBER := 0;
   receipt_transaction_qty_       NUMBER := 0;
   receipt_transaction_catch_qty_ NUMBER := 0;
   qty_left_to_be_received_       NUMBER := 0;
   catch_qty_left_to_be_received_ NUMBER := 0;
BEGIN
   qty_left_to_be_received_        := qty_returned_;
   catch_qty_left_to_be_received_  := catch_qty_returned_;
   IF ((Inventory_Part_API.Get_Invent_Valuation_Method_Db(contract_, part_no_) IN ('FIFO', 'LIFO')) AND
       (part_ownership_db_ = Part_Ownership_API.DB_COMPANY_OWNED)) THEN
      issue_transaction_id_tab_ := Inventory_Transaction_Hist_API.Get_Cust_Shipment_Transactions (contract_,
                                                                                                  part_no_,
                                                                                                  configuration_id_,
                                                                                                  lot_batch_no_,
                                                                                                  serial_no_,
                                                                                                  condition_code_,
                                                                                                  rma_no_,
                                                                                                  rma_line_no_,
                                                                                                  transaction_code_);
      
      IF (issue_transaction_id_tab_.COUNT > 0 ) THEN
         FOR i IN issue_transaction_id_tab_.FIRST..issue_transaction_id_tab_.LAST LOOP 
            issue_transaction_qty_         := Inventory_Part_Fifo_Issue_API.Get_Total_Issued_Quantity (issue_transaction_id_tab_(i));
            IF (issue_transaction_qty_ > 0) THEN
               receipt_transaction_qty_       := LEAST(issue_transaction_qty_, qty_left_to_be_received_);
               receipt_transaction_catch_qty_ := (receipt_transaction_qty_ / qty_returned_) * catch_qty_returned_;
               qty_left_to_be_received_       := qty_left_to_be_received_ - receipt_transaction_qty_;
               catch_qty_left_to_be_received_ := catch_qty_left_to_be_received_ - receipt_transaction_catch_qty_;
            
               Receive_Part ( transaction_id_                => receipt_transaction_id_,
                              contract_                      => contract_,
                              part_no_                       => part_no_,
                              configuration_id_              => configuration_id_,
                              location_no_                   => location_no_,
                              lot_batch_no_                  => lot_batch_no_,
                              serial_no_                     => serial_no_,
                              eng_chg_level_                 => eng_chg_level_,
                              waiv_dev_rej_no_               => waiv_dev_rej_no_,
                              activity_seq_                  => activity_seq_,
                              handling_unit_id_              => handling_unit_id_,
                              transaction_                   => transaction_code_,
                              expiration_date_               => expiration_date_,
                              quantity_                      => receipt_transaction_qty_,
                              catch_quantity_                => receipt_transaction_catch_qty_,
                              quantity_reserved_             => 0,
                              order_no_                      => to_char(rma_no_),
                              line_no_                       => NULL,
                              release_no_                    => NULL,
                              line_item_no_                  => rma_line_no_,
                              source_                        => source_,
                              value_                         => NULL,
                              cost_detail_tab_               => cost_detail_tab_,
                              order_type_                    => Order_Type_API.Decode('RMA'),
                              receive_correction_            => NULL,
                              owning_vendor_no_              => NULL,
                              condition_code_                => condition_code_,
                              part_ownership_                => Part_Ownership_API.DB_COMPANY_OWNED,
                              owning_customer_no_            => NULL,
                              receipt_date_                  => NULL,
                              issue_transaction_id_          => issue_transaction_id_tab_(i),
                              del_reason_id_                 => del_reason_id_,
                              del_note_no_                   => del_note_no_,
                              del_note_date_                 => del_note_date_ );

               transaction_id_tab_(i):= receipt_transaction_id_;
            END IF;
            EXIT WHEN qty_left_to_be_received_ = 0;
         END LOOP;
      END IF;
   END IF;
   IF (qty_left_to_be_received_ > 0 )THEN
      Receive_Part ( transaction_id_                => receipt_transaction_id_,
                     contract_                      => contract_,
                     part_no_                       => part_no_,
                     configuration_id_              => configuration_id_,
                     location_no_                   => location_no_,
                     lot_batch_no_                  => lot_batch_no_,
                     serial_no_                     => serial_no_,
                     eng_chg_level_                 => eng_chg_level_,
                     waiv_dev_rej_no_               => waiv_dev_rej_no_,
                     activity_seq_                  => activity_seq_,
                     handling_unit_id_              => handling_unit_id_,
                     transaction_                   => transaction_code_,
                     expiration_date_               => expiration_date_,
                     quantity_                      => qty_left_to_be_received_ ,
                     catch_quantity_                => catch_qty_left_to_be_received_,
                     quantity_reserved_             => 0,
                     order_no_                      => to_char(rma_no_),
                     line_no_                       => NULL,
                     release_no_                    => NULL,
                     line_item_no_                  => rma_line_no_,
                     source_                        => source_,
                     value_                         => NULL,
                     cost_detail_tab_               => cost_detail_tab_,
                     order_type_                    => Order_Type_API.Decode('RMA'),
                     receive_correction_            => NULL,
                     owning_vendor_no_              => owning_vendor_no_,
                     condition_code_                => condition_code_,
                     part_ownership_                => part_ownership_db_,
                     owning_customer_no_            => NULL,
                     receipt_date_                  => NULL,
                     issue_transaction_id_          => NULL,
                     del_reason_id_                 => del_reason_id_,
                     del_note_no_                   => del_note_no_,
                     del_note_date_                 => del_note_date_ );

      transaction_id_tab_(NVL(transaction_id_tab_.LAST+1,1)) := receipt_transaction_id_;
   END IF;
END Receive_Customer_Order_Return;


PROCEDURE Putaway (
   info_               OUT VARCHAR2,
   contract_           IN  VARCHAR2,
   part_no_            IN  VARCHAR2,
   configuration_id_   IN  VARCHAR2,
   location_no_        IN  VARCHAR2,
   lot_batch_no_       IN  VARCHAR2,
   serial_no_          IN  VARCHAR2,
   eng_chg_level_      IN  VARCHAR2,
   waiv_dev_rej_no_    IN  VARCHAR2,
   activity_seq_       IN  NUMBER,
   handling_unit_id_   IN  NUMBER,
   calling_process_    IN  VARCHAR2 DEFAULT 'PUTAWAY',
   to_warehouse_id_    IN  VARCHAR2 DEFAULT NULL,
   to_bay_id_          IN  VARCHAR2 DEFAULT NULL )
IS
   serial_no_tab_ Part_Serial_Catalog_API.Serial_No_Tab;
BEGIN
   IF (serial_no_ != '*') THEN
      serial_no_tab_(1).serial_no := serial_no_;
   END IF;

   Putaway___(info_               => info_,
              contract_           => contract_,
              part_no_            => part_no_,
              configuration_id_   => configuration_id_,
              location_no_        => location_no_,
              lot_batch_no_       => lot_batch_no_,
              serial_no_tab_      => serial_no_tab_,
              eng_chg_level_      => eng_chg_level_,
              waiv_dev_rej_no_    => waiv_dev_rej_no_,
              activity_seq_       => activity_seq_,
              handling_unit_id_   => handling_unit_id_,
              calling_process_    => calling_process_,
              to_warehouse_id_    => to_warehouse_id_,
              to_bay_id_          => to_bay_id_);
END Putaway;


PROCEDURE Identify_Serials (
   contract_                 IN VARCHAR2,
   part_no_                  IN VARCHAR2,
   configuration_id_         IN VARCHAR2,
   location_no_              IN VARCHAR2,
   lot_batch_no_             IN VARCHAR2,
   eng_chg_level_            IN VARCHAR2,
   waiv_dev_rej_no_          IN VARCHAR2,
   activity_seq_             IN NUMBER,
   handling_unit_id_         IN NUMBER,
   part_tracking_session_id_ IN NUMBER )
IS
   serial_catch_tab_ Serial_Catch_Table;
BEGIN
   Temporary_Part_Tracking_API.Get_Serials_And_Remove_Session(serial_catch_tab_, part_tracking_session_id_);

   Split_Into_Serials(contract_,
                      part_no_,
                      configuration_id_,
                      location_no_,
                      lot_batch_no_,
                      eng_chg_level_,
                      waiv_dev_rej_no_,
                      activity_seq_,
                      handling_unit_id_,
                      serial_catch_tab_,
                      reservation_ => FALSE);

   IF (serial_catch_tab_.COUNT > 0) THEN
      FOR i IN serial_catch_tab_.FIRST..serial_catch_tab_.LAST LOOP
         Part_Serial_Catalog_API.Set_Tracked_In_Inventory(part_no_, serial_catch_tab_(i).serial_no);
      END LOOP;
   END IF;
END Identify_Serials;


PROCEDURE Refill_Using_Putaway (
   contract_           IN VARCHAR2,
   part_no_            IN VARCHAR2,
   to_location_no_     IN VARCHAR2,
   from_location_no_   IN VARCHAR2,
   calling_process_    IN VARCHAR2,
   to_warehouse_id_    IN VARCHAR2 DEFAULT NULL,
   to_bay_id_          IN VARCHAR2 DEFAULT NULL )
IS
   location_type_db_         INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   location_ranking_         NUMBER;
   available_stock_tab_      Available_Stock_Tab;
   info_                     VARCHAR2(2000);
   today_                    DATE;
   from_to_refill_           EXCEPTION;
   last_calendar_date_       DATE := Database_Sys.last_calendar_date_;

   CURSOR get_location IS
      SELECT part_no,
             location_no,         
             lot_batch_no,
             serial_no,
             eng_chg_level,
             waiv_dev_rej_no,
             configuration_id,
             activity_seq,
             handling_unit_id,
             qty_onhand - qty_reserved   qty_available,
             warehouse,
             bay_no,
             tier_no,
             row_no,
             bin_no,
             expiration_date,
             receipt_date,
             warehouse_route_order,
             bay_route_order,
             row_route_order,
             tier_route_order,
             bin_route_order,
             NULL,
             NULL
        FROM inventory_part_in_stock_avail
       WHERE part_movement_control_db  = Part_Movement_Control_API.DB_ALL_ALLOWED
         AND putaway_zone_refill_source_db = Fnd_Boolean_API.DB_TRUE
         AND location_type_db IN (Inventory_Location_Type_API.DB_PICKING,
                                  Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                  Inventory_Location_Type_API.DB_PRODUCTION_LINE)
         AND (location_no != to_location_no_   OR to_location_no_   IS NULL)
         AND (location_no  = from_location_no_ OR from_location_no_ IS NULL)
         AND NVL(expiration_date, last_calendar_date_) > today_
         AND freeze_flag_db = 'N'
         AND qty_onhand - qty_reserved > 0
         AND rotable_part_pool_id IS NULL
         AND part_no  = part_no_
         AND contract = contract_
      ORDER BY location_no;
BEGIN
   today_ := TRUNC(Site_API.Get_Site_Date(contract_));

   IF (to_location_no_ IS NULL) THEN
      IF (from_location_no_ IS NULL) THEN
         -- Either from- och to- location needs to have a value
         RAISE from_to_refill_;
      END IF;
      -- Only from_location_no_ has a value. This means that the system has found a quantity to be suitable
      -- for moving to a location in a putaway zone with better ranking. We know from where to refill but need to find
      -- if there is a suitable destination to be refilled.
      location_type_db_ := Inventory_Location_API.Get_Location_Type_Db(contract_, from_location_no_);

      -- Since we are using the quantity from a specific location to refill unknown locations
      -- then there is no need to fetch any exact ranking of the from_location. We just want to make sure that
      -- method Invent_Part_Putaway_Zone_API.Get_Zone_And_Fifo_Sorted_Stock() does not filter away our from_location
      -- stock record. So we set the location_ranking_ hardcoded to zero.
      location_ranking_ := 0;
   ELSE
      IF (from_location_no_ IS NOT NULL) THEN
         -- Either from- och to- location needs to have a value. Not both.
         RAISE from_to_refill_;
      END IF;
      -- Only to_location_no_ has a value. This means that the system has dectected an issue from 
      -- this location and wants this location refilled from any available stock on a location in a zone with worse ranking.
      -- We know where we want the quantity to go but we need find out if there is a suitable quantity to move.
      location_type_db_ := Inventory_Location_API.Get_Location_Type_Db(contract_, to_location_no_);

      -- When refilling a specific location we want to refill from locations having worse ranking. So therefore
      -- we need to find out about the ranking of the location that needs to be refilled.
      location_ranking_ := Invent_Part_Putaway_Zone_API.Get_Best_Location_Ranking(contract_,
                                                                                  part_no_,
                                                                                  to_location_no_);
   END IF;

   IF NOT (Stock_Location___(location_type_db_)) THEN
      Error_SYS.Record_General(lu_name_,'LOCTYPEREFILL: The refill functionality cannot be executed for location type :P1', Inventory_Location_Type_API.Decode(location_type_db_));
   END IF;

   OPEN  get_location;
   FETCH get_location BULK COLLECT INTO available_stock_tab_;
   CLOSE get_location;
   
   available_stock_tab_ := Invent_Part_Putaway_Zone_API.Get_Zone_And_Fifo_Sorted_Stock(contract_,
                                                                                       part_no_,
                                                                                       available_stock_tab_,
                                                                                       location_ranking_);
   IF (available_stock_tab_.COUNT > 0) THEN
      Inventory_Event_Manager_API.Start_Session;
      FOR i IN available_stock_tab_.FIRST..available_stock_tab_.LAST LOOP
         Putaway(info_,
                 contract_,
                 part_no_,
                 available_stock_tab_(i).configuration_id,
                 available_stock_tab_(i).location_no,
                 available_stock_tab_(i).lot_batch_no,
                 available_stock_tab_(i).serial_no,
                 available_stock_tab_(i).eng_chg_level,
                 available_stock_tab_(i).waiv_dev_rej_no,
                 available_stock_tab_(i).activity_seq,
                 available_stock_tab_(i).handling_unit_id,
                 calling_process_,
                 to_warehouse_id_,
                 to_bay_id_);
      END LOOP;
      Inventory_Event_Manager_API.Finish_Session;
      END IF;
EXCEPTION
   WHEN from_to_refill_ THEN
      Error_SYS.Record_General(lu_name_,'FROMTOREFILL: Either From Location or To Location must have a value. Design Error. Contact System Support.');
END Refill_Using_Putaway;


PROCEDURE Optimize_Using_Putaway (
   message_ IN VARCHAR2 )
IS
   batch_desc_ VARCHAR2(500);
BEGIN
   IF (Transaction_SYS.Is_Session_Deferred()) THEN
      Optimize_Using_Putaway__(message_);
   ELSE
      batch_desc_:= Language_SYS.Translate_Constant(lu_name_,'OPTBATCHDESC: Optimize Inventory Using Putaway');
      Transaction_SYS.Deferred_Call('Inventory_Part_In_Stock_API.Optimize_Using_Putaway__', message_, batch_desc_);
   END IF;
END Optimize_Using_Putaway;


PROCEDURE Check_Optimize_Using_Putaway (
   message_ IN VARCHAR2 )
IS
   count_            NUMBER;
   name_arr_         Message_SYS.name_table;
   value_arr_        Message_SYS.line_table;
   contract_         INVENTORY_PART_IN_STOCK_TAB.contract%TYPE;
   part_no_          INVENTORY_PART_IN_STOCK_TAB.part_no%TYPE;
   warehouse_id_     INVENTORY_PART_IN_STOCK_TAB.warehouse%TYPE;
   bay_id_           INVENTORY_PART_IN_STOCK_TAB.bay_no%TYPE;
   tier_id_          INVENTORY_PART_IN_STOCK_TAB.tier_no%TYPE;
   row_id_           INVENTORY_PART_IN_STOCK_TAB.row_no%TYPE;
   location_type_db_ INVENTORY_PART_IN_STOCK_TAB.location_type%TYPE;
   location_group_   warehouse_bay_bin_tab.location_group%TYPE;
BEGIN
   Message_SYS.Get_Attributes(message_, count_, name_arr_, value_arr_);

   FOR n_ IN 1..count_ LOOP
      IF (name_arr_(n_) = 'CONTRACT') THEN
         contract_ := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'PART_NO') THEN
         part_no_ := NVL(value_arr_(n_),'%');
      ELSIF (name_arr_(n_) = 'WAREHOUSE_ID') THEN
         warehouse_id_ := NVL(value_arr_(n_),'%');
      ELSIF (name_arr_(n_) = 'BAY_ID') THEN
         bay_id_ := NVL(value_arr_(n_),'%');
      ELSIF (name_arr_(n_) = 'TIER_ID') THEN
         tier_id_ := NVL(value_arr_(n_),'%');
      ELSIF (name_arr_(n_) = 'ROW_ID') THEN
         row_id_ := NVL(value_arr_(n_),'%');
      ELSIF (name_arr_(n_) = 'LOCATION_TYPE') THEN
         location_type_db_ := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'LOCATION_GROUP') THEN
         location_group_ := NVL(value_arr_(n_),'%');
      ELSE
         Error_SYS.Record_General(lu_name_, 'INCORRECT_MESSAGE: Item :P1 can not be used in method Optimize_Using_Putaway__.');
      END IF;
   END LOOP;
   
   IF (location_type_db_ IS NOT NULL) THEN
      Inventory_Location_Type_API.Exist_Db(location_type_db_);
      IF (location_type_db_ NOT IN (Inventory_Location_Type_API.DB_PICKING,
                                    Inventory_Location_Type_API.DB_FLOOR_STOCK,
                                    Inventory_Location_Type_API.DB_PRODUCTION_LINE)) THEN
         Error_SYS.Record_General(lu_name_, 'OPTLOCTYPE: Location Type :P1 cannot be included in the Inventory Optimization.', Inventory_Location_Type_API.Decode(location_type_db_));
      END IF;
   END IF;

   location_type_db_ := NVL(location_type_db_, '%');

   Site_API.Exist(contract_);
   User_Allowed_Site_API.Exist(Fnd_Session_API.Get_Fnd_User, contract_);
   Inventory_Part_API.Exist_With_Wildcard(contract_, part_no_);
   Inventory_Location_Group_API.Exist_With_Wildcard(location_group_);
   Warehouse_Bay_Bin_API.Exist_With_Wildcard(contract_,
                                             warehouse_id_,
                                             bay_id_,
                                             tier_id_,
                                             row_id_,
                                             location_type_db_,
                                             location_group_);
END Check_Optimize_Using_Putaway;


@UncheckedAccess
FUNCTION Is_Frozen_For_Counting (
   contract_         IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   location_no_      IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER ) RETURN BOOLEAN
IS
BEGIN
   RETURN (Get_Freeze_Flag_Db (contract_, 
                               part_no_, 
                               configuration_id_, 
                               location_no_, 
                               lot_batch_no_, 
                               serial_no_, 
                               eng_chg_level_, 
                               waiv_dev_rej_no_, 
                               activity_seq_,
                               handling_unit_id_) = 'Y');
END Is_Frozen_For_Counting;


@UncheckedAccess
FUNCTION Trans_Inv_Part_Stk_To_Eng_Rev (
   target_key_ref_ IN VARCHAR2,
   service_name_   IN VARCHAR2 ) RETURN VARCHAR2
IS
   source_key_ref_ VARCHAR2(2000);
   contract_       INVENTORY_PART_IN_STOCK_TAB.contract%TYPE;
   part_no_        INVENTORY_PART_IN_STOCK_TAB.part_no%TYPE;
   eng_chg_level_  INVENTORY_PART_IN_STOCK_TAB.eng_chg_level%TYPE;
   eng_rev_        VARCHAR2(6); 
BEGIN
   $IF Component_Mfgstd_SYS.INSTALLED $THEN
      contract_       := Client_SYS.Get_Key_Reference_Value(target_key_ref_, 'CONTRACT');
      part_no_        := Client_SYS.Get_Key_Reference_Value(target_key_ref_, 'PART_NO');
      eng_chg_level_  := Client_SYS.Get_Key_Reference_Value(target_key_ref_, 'ENG_CHG_LEVEL');

      eng_rev_        := Part_Revision_API.Get_Eng_Revision(contract_, part_no_, eng_chg_level_);
      source_key_ref_ := 'PART_NO=' || part_no_ ||
                         '^PART_REV=' || eng_rev_ ||'^';  
   $END  
   RETURN source_key_ref_;      
END Trans_Inv_Part_Stk_To_Eng_Rev;


-- This method is used by DataCaptAttachPartHu, DataCaptFindInventory, DataCaptIssueInvPart, DataCaptRecFromTransit,
-- DataCaptScrapInvPart, DataCaptUnattachPartHu, DataCaptureCountPart, DataCaptureMovePart, DataCaptReportPickPart,
-- DataCaptManIssSoHu, DataCaptManIssSoPart, DataCaptRepPickPartSo, DataCaptManIssueWo and DataCaptUnplanIssueWo  
@ServerOnlyAccess
PROCEDURE Create_Data_Capture_Lov (
   contract_                   IN VARCHAR2,
   part_no_                    IN VARCHAR2,
   configuration_id_           IN VARCHAR2,
   location_no_                IN VARCHAR2,
   lot_batch_no_               IN VARCHAR2,
   serial_no_                  IN VARCHAR2,
   eng_chg_level_              IN VARCHAR2,
   waiv_dev_rej_no_            IN VARCHAR2,
   activity_seq_               IN NUMBER,
   handling_unit_id_           IN NUMBER,
   alt_handling_unit_label_id_ IN VARCHAR2,  -- send '%' if this item have not been entered/scanned yet
   capture_session_id_         IN NUMBER,
   column_name_                IN VARCHAR2,
   lov_type_db_                IN VARCHAR2,
   sql_where_expression_       IN VARCHAR2 DEFAULT NULL,
   data_item_id_               IN VARCHAR2 DEFAULT NULL )
IS
   TYPE Get_Lov_Values       IS REF CURSOR;
   get_lov_values_           Get_Lov_Values;
   stmt_                     VARCHAR2(32000);
   TYPE Lov_Value_Tab        IS TABLE OF VARCHAR2(2000) INDEX BY PLS_INTEGER;
   lov_value_tab_            Lov_Value_Tab;
   second_column_name_       VARCHAR2(200);
   second_column_value_      VARCHAR2(200);
   lov_item_description_     VARCHAR2(200);
   session_rec_              Data_Capture_Common_Util_API.Session_Rec;
   capture_process_id_       VARCHAR2(30);
   capture_config_id_        NUMBER;
   translation_res_          VARCHAR2(40):= Language_SYS.Translate_Constant(lu_name_, 'SHORTFORRESERVED: Res');
   translation_avail_        VARCHAR2(40):= Language_SYS.Translate_Constant(lu_name_, 'SHORTFORAVAILABLE: Avail');
   lov_desc_separator_       VARCHAR2(3) := ' | ';
   qty_available_            NUMBER;
   qty_reserved_             NUMBER;
   order_no_                 VARCHAR2(50);
   line_no_                  VARCHAR2(50);
   release_no_               VARCHAR2(50);
   line_item_no_             NUMBER;
   lov_row_limitation_       NUMBER;
   exit_lov_                 BOOLEAN := FALSE;
   temp_handling_unit_id_    NUMBER;
   local_lov_search_stmt_      VARCHAR2(1000);   
BEGIN
   $IF Component_Wadaco_SYS.INSTALLED $THEN
      session_rec_ := Data_Capture_Session_API.Get_Session_Rec(capture_session_id_);    
      lov_row_limitation_ := Data_Capture_Config_API.Get_Lov_Row_Limitation(session_rec_.capture_process_id, session_rec_.capture_config_id);

      -- extra column check to be sure we have no risk for sql injection into column_name/data_item_id
      Assert_SYS.Assert_Is_View_Column('INVENTORY_PART_IN_STOCK_TOTAL', column_name_);
      stmt_ := ' FROM  INVENTORY_PART_IN_STOCK_TOTAL
                 WHERE EXISTS (SELECT 1 FROM user_allowed_site_pub WHERE site = contract) ';
      IF (contract_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND contract = :contract_ ';
      ELSE
         stmt_ := stmt_ || ' AND :contract_ IS NULL ';
      END IF;
      IF (part_no_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND part_no = :part_no_ ';
      ELSE
         stmt_ := stmt_ || ' AND :part_no_ IS NULL ';
      END IF;
      IF (configuration_id_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND configuration_id = :configuration_id_ ';
      ELSE
         stmt_ := stmt_ || ' AND :configuration_id_ IS NULL ';
      END IF;
      IF (location_no_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND location_no = :location_no_ ';
      ELSE
         stmt_ := stmt_ || ' AND :location_no_ IS NULL ';
      END IF;
      IF (lot_batch_no_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND lot_batch_no = :lot_batch_no_ ';
      ELSE
         stmt_ := stmt_ || ' AND :lot_batch_no_ IS NULL ';
      END IF;
       IF (serial_no_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND serial_no = :serial_no_ ';
      ELSE
         stmt_ := stmt_ || ' AND :serial_no_ IS NULL ';
      END IF;
      IF (eng_chg_level_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND eng_chg_level = :eng_chg_level_ ';
      ELSE
         stmt_ := stmt_ || ' AND :eng_chg_level_ IS NULL ';
      END IF;
      IF (waiv_dev_rej_no_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND waiv_dev_rej_no = :waiv_dev_rej_no_ ';
      ELSE
         stmt_ := stmt_ || ' AND :waiv_dev_rej_no_ IS NULL ';
      END IF;
      IF (activity_seq_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND activity_seq = :activity_seq_ ';
      ELSE
         stmt_ := stmt_ || ' AND :activity_seq_ IS NULL ';
      END IF;
      IF (handling_unit_id_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND handling_unit_id = :handling_unit_id_ ';
      ELSE
         stmt_ := stmt_ || ' AND :handling_unit_id_ IS NULL ';
      END IF;
      IF (alt_handling_unit_label_id_ = '%') THEN 
         stmt_ := stmt_ || ' AND :alt_handling_unit_label_id_ = ''%'' ';
      ELSIF (alt_handling_unit_label_id_ IS NOT NULL) THEN 
         stmt_ := stmt_ || ' AND alt_handling_unit_label_id  = :alt_handling_unit_label_id_ ';
      ELSE
         stmt_ := stmt_ || ' AND (alt_handling_unit_label_id IS NULL AND :alt_handling_unit_label_id_ IS NULL) ';
      END IF;
      
      -- If the Lov search target is Description or ID_And_Description then we have to select all the possible values and later filter in Data_Capture_Session_Lov_API.New() method. 
      IF ((session_rec_.lov_search_statement IS NOT NULL) AND (session_rec_.lov_search_target = Lov_Search_Target_API.DB_ID)) THEN 
         local_lov_search_stmt_ := Data_Capture_Common_Util_API.Get_Lov_Search_Where_Clause(column_name_, 
                                                                                            session_rec_.lov_search_statement,                                                                                      
                                                                                            session_rec_.lov_search_string_match,
                                                                                            session_rec_.lov_search_target,
                                                                                            session_rec_.lov_search_case_sensitive);
         stmt_ := stmt_ || ' AND ' || local_lov_search_stmt_; 
      END IF;      
          
      IF (sql_where_expression_ IS NOT NULL) THEN
         stmt_ := stmt_ || sql_where_expression_;
      END IF;

      IF (lov_type_db_  = Data_Capture_Config_Lov_API.DB_AUTO_PICK) THEN
         -- Don't use DISTINCT select for AUTO PICK 
         stmt_ := 'SELECT ' || column_name_ || stmt_ || ' ORDER BY Utility_SYS.String_To_Number(' || column_name_ || '), ' || column_name_ || ' ASC' ;
      ELSE
         stmt_ := 'SELECT DISTINCT ' || column_name_ || stmt_ || ' ORDER BY Utility_SYS.String_To_Number(' || column_name_ || '), ' || column_name_ || ' ASC';
      END IF;
      @ApproveDynamicStatement(2014-11-03,CHJALK)
      OPEN get_lov_values_ FOR stmt_ USING contract_,
                                           part_no_,
                                           configuration_id_,
                                           location_no_,
                                           lot_batch_no_,
                                           serial_no_,
                                           eng_chg_level_,
                                           waiv_dev_rej_no_,
                                           activity_seq_,
                                           handling_unit_id_,
                                           alt_handling_unit_label_id_;
      IF (lov_type_db_  = Data_Capture_Config_Lov_API.DB_AUTO_PICK) THEN
         -- Only 1 value for AUTO PICK
         FETCH get_lov_values_ INTO lov_value_tab_(1);
      ELSE
         FETCH get_lov_values_ BULK COLLECT INTO lov_value_tab_;
      END IF;
      CLOSE get_lov_values_;

      IF (lov_value_tab_.COUNT > 0) THEN
         CASE (column_name_)
            WHEN ('PART_NO') THEN
               second_column_name_ := 'PART_DESCRIPTION';
            WHEN ('LOCATION_NO') THEN
               second_column_name_ := 'LOCATION_INFO';
            WHEN ('HANDLING_UNIT_ID') THEN
               second_column_name_ := 'HANDLING_UNIT_TYPE_DESC';
            WHEN ('SSCC') THEN
               second_column_name_ := 'HANDLING_UNIT_TYPE_DESC';
            WHEN ('ALT_HANDLING_UNIT_LABEL_ID') THEN
               second_column_name_ := 'HANDLING_UNIT_TYPE_DESC';
            ELSE
               NULL;
         END CASE;
         
         FOR i IN lov_value_tab_.FIRST..lov_value_tab_.LAST LOOP
            -- Don't fetch details for AUTO PICK
            IF (lov_type_db_ != Data_Capture_Config_Lov_API.DB_AUTO_PICK) THEN              
               IF (second_column_name_ IS NOT NULL) THEN
                  IF (second_column_name_ = 'PART_DESCRIPTION') THEN
                     second_column_value_ := Inventory_Part_API.Get_Description(contract_, lov_value_tab_(i));
                  ELSIF (second_column_name_ = 'LOCATION_INFO') THEN
                     capture_process_id_ := Data_Capture_Session_API.Get_Capture_Process_Id(capture_session_id_);
                     capture_config_id_  := Data_Capture_Session_API.Get_Capture_Config_Id(capture_session_id_);
                     IF (capture_process_id_ = 'MANUAL_ISSUE_SHOP_ORDER_PART') THEN
                        IF (Fnd_Boolean_API.Evaluate_Db(Data_Capture_Config_Detail_API.Get_Enabled_Db(capture_process_id_, capture_config_id_, 'DISPLAY_LOCATION_DESCRIPTION'))) THEN
                           -- Show location description
                           second_column_value_ := Inventory_Location_API.Get_Location_Name(contract_, lov_value_tab_(i));
                        END IF;
                        -- Get shop order keys. NOTE! Missmatch for line_no and release_no!
                        order_no_     := Data_Capture_Session_API.Get_Latest_A_If_Before_B(capture_session_id_, 'ORDER_NO', column_name_);
                        line_no_      := Data_Capture_Session_API.Get_Latest_A_If_Before_B(capture_session_id_, 'RELEASE_NO', column_name_);
                        release_no_   := Data_Capture_Session_API.Get_Latest_A_If_Before_B(capture_session_id_, 'SEQUENCE_NO', column_name_);
                        line_item_no_ := Data_Capture_Session_API.Get_Latest_A_If_Before_B(capture_session_id_, 'LINE_ITEM_NO', column_name_);
                        
                        IF (order_no_ IS NOT NULL AND line_no_ IS NOT NULL AND release_no_ IS NOT NULL AND 
                           line_item_no_ IS NOT NULL AND part_no_ IS NOT NULL AND configuration_id_ IS NOT NULL AND 
                           lot_batch_no_ IS NOT NULL AND serial_no_ IS NOT NULL AND eng_chg_level_ IS NOT NULL AND
                           waiv_dev_rej_no_ IS NOT NULL AND activity_seq_ IS NOT NULL AND handling_unit_id_ IS NOT NULL) THEN
                                                                                         
                           qty_reserved_ := Inv_Part_Stock_Reservation_API.Get_Qty_Reserved(order_no_                    => order_no_,
                                                                                            line_no_                     => line_no_,
                                                                                            release_no_                  => release_no_,
                                                                                            line_item_no_                => line_item_no_,
                                                                                            pick_list_no_                => NULL,
                                                                                            shipment_id_                 => NULL,
                                                                                            order_supply_demand_type_db_ => Order_Supply_Demand_Type_API.DB_MATERIAL_RES_SO,
                                                                                            contract_                    => contract_,
                                                                                            part_no_                     => part_no_,
                                                                                            configuration_id_            => configuration_id_,
                                                                                            location_no_                 => lov_value_tab_(i),
                                                                                            lot_batch_no_                => lot_batch_no_,
                                                                                            serial_no_                   => serial_no_,
                                                                                            eng_chg_level_               => eng_chg_level_,
                                                                                            waiv_dev_rej_no_             => waiv_dev_rej_no_,
                                                                                            activity_seq_                => activity_seq_,
                                                                                            handling_unit_id_            => handling_unit_id_);
                        END IF;
                        
                        IF (Fnd_Boolean_API.Evaluate_Db(Data_Capture_Config_Detail_API.Get_Enabled_Db(capture_process_id_, capture_config_id_, 'DISPLAY_QTY_RESERVED_HEADER'))) THEN
                           -- Add description separator
                           IF (second_column_value_ IS NOT NULL) THEN
                              second_column_value_ := second_column_value_  || lov_desc_separator_;
                           END IF;
                           -- Show desc AND value
                           second_column_value_ := second_column_value_ || translation_res_ || ': ' || qty_reserved_;
                        ELSIF (Fnd_Boolean_API.Evaluate_Db(Data_Capture_Config_Detail_API.Get_Enabled_Db(capture_process_id_, capture_config_id_, 'DISPLAY_QTY_RESERVED'))) THEN
                           -- Add description separator
                           IF (second_column_value_ IS NOT NULL) THEN
                              second_column_value_ := second_column_value_  || lov_desc_separator_;
                           END IF;
                           -- Show only value
                           second_column_value_ := second_column_value_ || qty_reserved_;
                        END IF;
                        qty_available_ := Get_Qty_Onhand(contract_,
                                                         part_no_,
                                                         configuration_id_,
                                                         lov_value_tab_(i),
                                                         lot_batch_no_,
                                                         serial_no_,
                                                         eng_chg_level_,
                                                         waiv_dev_rej_no_,
                                                         activity_seq_,
                                                         handling_unit_id_)
                                                         - 
                                          Get_Qty_Reserved(contract_,
                                                           part_no_,
                                                           configuration_id_,
                                                           lov_value_tab_(i),
                                                           lot_batch_no_,
                                                           serial_no_,
                                                           eng_chg_level_,
                                                           waiv_dev_rej_no_,
                                                           activity_seq_,
                                                           handling_unit_id_);
                        IF (Fnd_Boolean_API.Evaluate_Db(Data_Capture_Config_Detail_API.Get_Enabled_Db(capture_process_id_, capture_config_id_, 'DISPLAY_QTY_AVAILABLE_HEADER'))) THEN
                           -- Add description separator
                           IF (second_column_value_ IS NOT NULL) THEN
                              second_column_value_ := second_column_value_  || lov_desc_separator_;
                           END IF;
                           -- Show desc AND value
                           second_column_value_ := second_column_value_ || translation_avail_ || ': ' || qty_available_;
                        ELSIF (Fnd_Boolean_API.Evaluate_Db(Data_Capture_Config_Detail_API.Get_Enabled_Db(capture_process_id_, capture_config_id_, 'DISPLAY_QTY_AVAILABLE'))) THEN
                           -- Add description separator
                           IF (second_column_value_ IS NOT NULL) THEN
                              second_column_value_ := second_column_value_  || lov_desc_separator_;
                           END IF;
                           -- Show only value
                           second_column_value_ := second_column_value_ || qty_available_;
                        END IF;
                     ELSE -- Other processes
                        second_column_value_ := Inventory_Location_API.Get_Location_Name(contract_, lov_value_tab_(i));
                     END IF;

                  ELSIF (second_column_name_ = 'HANDLING_UNIT_TYPE_DESC') THEN
                     IF (column_name_ = 'HANDLING_UNIT_ID') THEN
                        temp_handling_unit_id_ := lov_value_tab_(i);
                     ELSIF (column_name_ = 'SSCC') THEN
                        temp_handling_unit_id_ := Handling_Unit_API.Get_Handling_Unit_From_Sscc(lov_value_tab_(i));
                     ELSIF (column_name_ = 'ALT_HANDLING_UNIT_LABEL_ID') THEN
                        temp_handling_unit_id_ := Handling_Unit_API.Get_Handling_Unit_From_Alt_Id(lov_value_tab_(i));
                     END IF;
                     -- If ALT_HANDLING_UNIT_LABEL_ID is not unique the method Get_Handling_Unit_From_Alt_Id can return null for handling unit id 
                     -- To avoid printing caracter '|' in those cases we first check if handling unit id is not null
                     IF temp_handling_unit_id_ IS NOT NULL THEN 
                        second_column_value_ := Handling_Unit_API.Get_Structure_Level(temp_handling_unit_id_) || lov_desc_separator_ || Handling_Unit_Type_API.Get_Description(Handling_Unit_API.Get_Handling_Unit_Type_Id(temp_handling_unit_id_));
                     END IF;
                  END IF;
                  IF (second_column_value_ IS NOT NULL) THEN
                     lov_item_description_ := second_column_value_;
                     second_column_value_ := NULL;
                  ELSE
                    lov_item_description_ := NULL;
                  END IF;
               END IF;
            END IF;
            Data_Capture_Session_Lov_API.New(exit_lov_              => exit_lov_,
                                             capture_session_id_    => capture_session_id_,
                                             lov_item_value_        => lov_value_tab_(i),
                                             lov_item_description_  => lov_item_description_,
                                             lov_row_limitation_    => lov_row_limitation_, 
                                             session_rec_           => session_rec_);
            EXIT WHEN exit_lov_;
         END LOOP;
      END IF;
   $ELSE
      NULL;
   $END
END Create_Data_Capture_Lov;

@UncheckedAccess
FUNCTION Quantity_In_Warehouse_Exist  (
   contract_     IN VARCHAR2,
   warehouse_id_ IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_                       NUMBER;
   quantity_in_warehouse_exist_ BOOLEAN := FALSE;

   CURSOR exist_control IS
      SELECT 1
        FROM INVENTORY_PART_IN_STOCK_TAB
       WHERE contract    = contract_
         AND warehouse   = warehouse_id_
         AND ((qty_onhand != 0) OR (qty_in_transit != 0));
BEGIN
   OPEN  exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      quantity_in_warehouse_exist_ := TRUE;
   END IF;
   CLOSE exist_control;

   RETURN(quantity_in_warehouse_exist_);
END Quantity_In_Warehouse_Exist ;

@UncheckedAccess
FUNCTION Get_Move_Dest_Supply_Ctrl_Db (
   from_contract_    IN VARCHAR2,
   from_location_no_ IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER,
   to_contract_      IN VARCHAR2,
   to_location_no_   IN VARCHAR2 ) RETURN VARCHAR2
IS
   move_dest_supply_ctrl_db_   VARCHAR2(20);
   move_dest_avail_control_id_ inventory_part_in_stock_tab.availability_control_id%TYPE;
   fromrec_                    inventory_part_in_stock_tab%ROWTYPE;  
   torec_                      inventory_part_in_stock_tab%ROWTYPE;  
   new_record_                 BOOLEAN;
   to_eng_chg_level_           inventory_part_in_stock_tab.eng_chg_level%TYPE;
BEGIN
   IF (from_contract_ = to_contract_) THEN
      -- move part within one site
      to_eng_chg_level_ := eng_chg_level_;
   ELSE
      -- move part between sites
      Inventory_Part_Revision_API.Get_Matched_Eng_Chg_Level(to_eng_chg_level_,
                                                            from_contract_,
                                                            to_contract_,
                                                            part_no_,
                                                            eng_chg_level_,
                                                            TRUE);
   END IF;

   fromrec_ := Get_Object_By_Keys___(from_contract_,
                                     part_no_,
                                     configuration_id_,
                                     from_location_no_,
                                     lot_batch_no_,
                                     serial_no_,
                                     eng_chg_level_,
                                     waiv_dev_rej_no_,
                                     activity_seq_,
                                     handling_unit_id_);
   IF (Check_Exist___(to_contract_,
                      part_no_,
                      configuration_id_,
                      to_location_no_,
                      lot_batch_no_,
                      serial_no_,
                      to_eng_chg_level_,
                      waiv_dev_rej_no_,
                      activity_seq_,
                      handling_unit_id_)) THEN
      new_record_ := FALSE;

      torec_ := Get_Object_By_Keys___(to_contract_,
                                      part_no_,
                                      configuration_id_,
                                      to_location_no_,
                                      lot_batch_no_,
                                      serial_no_,
                                      to_eng_chg_level_,
                                      waiv_dev_rej_no_,
                                      activity_seq_,
                                      handling_unit_id_);
   ELSE
      new_record_ := TRUE;
   END IF;
   
   move_dest_avail_control_id_ := Get_Move_Dest_Avail_Ctrl_Id___(fromrec_, torec_,to_contract_, to_location_no_, new_record_);
   move_dest_supply_ctrl_db_   := Part_Availability_Control_API.Check_Supply_Control(move_dest_avail_control_id_);                                                                 
   RETURN(move_dest_supply_ctrl_db_);
END Get_Move_Dest_Supply_Ctrl_Db;

--Transfer_Rental_Asset
--  This method is used when the ownership is transfered from Company rental asset to company owned and vice versa.
--  transfer_action_ parameter is used to decide the ownership transfer direction.
PROCEDURE Transfer_Rental_Asset (
   account_no_                IN VARCHAR2,
   code_b_                    IN VARCHAR2,
   code_c_                    IN VARCHAR2,
   code_d_                    IN VARCHAR2,
   code_e_                    IN VARCHAR2,
   code_f_                    IN VARCHAR2,
   code_g_                    IN VARCHAR2,
   code_h_                    IN VARCHAR2,
   code_i_                    IN VARCHAR2,
   code_j_                    IN VARCHAR2,
   transfer_action_           IN VARCHAR2,
   cost_detail_id_            IN NUMBER,
   rental_asset_transfer_tab_ IN Inv_Part_Ownership_Manager_API.ownership_transfer_table)
IS 
   serial_catch_tab_           Serial_Catch_Table;
   oldrec_                     inventory_part_in_stock_tab%ROWTYPE;
   local_quantity_             NUMBER;
   issue_transaction_          VARCHAR2(20);
   receipt_transaction_        VARCHAR2(20);
   current_avail_control_id_   inventory_part_in_stock_tab.availability_control_id%TYPE;
 BEGIN
   Inventory_Event_Manager_API.Start_Session;
   
   Fill_Part_Stock_Owner_Tmp___(rental_asset_transfer_tab_);
   -- transfer ownership
   FOR i IN rental_asset_transfer_tab_.FIRST..rental_asset_transfer_tab_.LAST LOOP
      current_avail_control_id_ := Get_Availability_Control_Id(rental_asset_transfer_tab_(i).contract,
                                                               rental_asset_transfer_tab_(i).part_no,
                                                               rental_asset_transfer_tab_(i).configuration_id,
                                                               rental_asset_transfer_tab_(i).location_no,
                                                               rental_asset_transfer_tab_(i).lot_batch_no,
                                                               rental_asset_transfer_tab_(i).serial_no,
                                                               rental_asset_transfer_tab_(i).eng_chg_level,
                                                               rental_asset_transfer_tab_(i).waiv_dev_rej_no,
                                                               rental_asset_transfer_tab_(i).activity_seq,
                                                               rental_asset_transfer_tab_(i).handling_unit_id);
      serial_catch_tab_.DELETE;
      IF (rental_asset_transfer_tab_(i).part_tracking_session_id IS NULL) THEN
         serial_catch_tab_(1).serial_no := rental_asset_transfer_tab_(i).serial_no;
         serial_catch_tab_(1).catch_qty := rental_asset_transfer_tab_(i).catch_qty;
         local_quantity_                := rental_asset_transfer_tab_(i).qty;
      ELSE
         Temporary_Part_Tracking_API.Get_Serials_And_Remove_Session(serial_catch_tab_, rental_asset_transfer_tab_(i).part_tracking_session_id);
   
         IF (serial_catch_tab_.COUNT = 0) THEN
            Raise_No_Serials_Error___;
         END IF;
   
         IF (serial_catch_tab_.COUNT != rental_asset_transfer_tab_(i).qty) THEN
            Error_SYS.Record_General('InventoryPartInStock', 'ISSPOSTSERCOUNT: The quantity to be issued is :P1 but the number of identified serials is :P2', rental_asset_transfer_tab_(i).qty, serial_catch_tab_.COUNT);
         END IF;
         Split_Into_Serials(contract_           => rental_asset_transfer_tab_(i).contract,
                            part_no_            => rental_asset_transfer_tab_(i).part_no,
                            configuration_id_   => rental_asset_transfer_tab_(i).configuration_id,
                            location_no_        => rental_asset_transfer_tab_(i).location_no,
                            lot_batch_no_       => rental_asset_transfer_tab_(i).lot_batch_no,
                            eng_chg_level_      => rental_asset_transfer_tab_(i).eng_chg_level,
                            waiv_dev_rej_no_    => rental_asset_transfer_tab_(i).waiv_dev_rej_no,
                            activity_seq_       => rental_asset_transfer_tab_(i).activity_seq,
                            handling_unit_id_   => rental_asset_transfer_tab_(i).handling_unit_id,
                            serial_catch_tab_   => serial_catch_tab_,
                            reservation_        => FALSE);
         local_quantity_ := 1;
      END IF;
      FOR index_ IN serial_catch_tab_.FIRST..serial_catch_tab_.LAST LOOP 
         oldrec_ := Lock_By_Keys___(rental_asset_transfer_tab_(i).contract,
                                    rental_asset_transfer_tab_(i).part_no,
                                    rental_asset_transfer_tab_(i).configuration_id,
                                    rental_asset_transfer_tab_(i).location_no,
                                    rental_asset_transfer_tab_(i).lot_batch_no,
                                    serial_catch_tab_(index_).serial_no,
                                    rental_asset_transfer_tab_(i).eng_chg_level,
                                    rental_asset_transfer_tab_(i).waiv_dev_rej_no,
                                    rental_asset_transfer_tab_(i).activity_seq,
                                    rental_asset_transfer_tab_(i).handling_unit_id);
         Check_Transfer_To_Own_Stock___(oldrec_,
                                        local_quantity_,
                                        NULL);                           
         IF (transfer_action_ = 'TransferToRentalAsset') THEN 
            IF(oldrec_.part_ownership != Part_Ownership_API.DB_COMPANY_OWNED) THEN
               Raise_Trf_Ownership_Error___(oldrec_.part_ownership);
            END IF;
         ELSE
            IF(oldrec_.part_ownership != Part_Ownership_API.DB_COMPANY_RENTAL_ASSET) THEN
               Raise_Trf_Ownership_Error___(oldrec_.part_ownership);
            END IF;
         END IF;  
         IF (oldrec_.activity_seq != 0) THEN
            Error_SYS.Record_General('InventoryPartInStock', 'CRATRFPROJINV: Transfer of ownership is not allowed for Project Inventory parts.');
         END IF;

         IF (transfer_action_ = 'TransferToRentalAsset') THEN 
            issue_transaction_   := 'COTOCRA-';
            receipt_transaction_ := 'COTOCRA+';
         ELSE
            issue_transaction_   := 'CRATOCO-';
            receipt_transaction_ := 'CRATOCO+';
         END IF; 
         
         Issue_Part_With_Posting___(contract_            => rental_asset_transfer_tab_(i).contract,
                                    part_no_             => rental_asset_transfer_tab_(i).part_no,
                                    configuration_id_    => rental_asset_transfer_tab_(i).configuration_id,
                                    location_no_         => rental_asset_transfer_tab_(i).location_no,
                                    lot_batch_no_        => rental_asset_transfer_tab_(i).lot_batch_no,
                                    serial_no_           => serial_catch_tab_(index_).serial_no,
                                    eng_chg_level_       => rental_asset_transfer_tab_(i).eng_chg_level,
                                    waiv_dev_rej_no_     => rental_asset_transfer_tab_(i).waiv_dev_rej_no,
                                    activity_seq_        => rental_asset_transfer_tab_(i).activity_seq,
                                    handling_unit_id_    => rental_asset_transfer_tab_(i).handling_unit_id,
                                    transaction_         => issue_transaction_,
                                    quantity_            => local_quantity_,
                                    catch_quantity_      => serial_catch_tab_(index_).catch_qty,
                                    account_no_          => CASE issue_transaction_ WHEN ('COTOCRA-') THEN account_no_ ELSE NULL END,
                                    code_b_              => CASE issue_transaction_ WHEN ('COTOCRA-') THEN code_b_     ELSE NULL END,
                                    code_c_              => CASE issue_transaction_ WHEN ('COTOCRA-') THEN code_c_     ELSE NULL END,
                                    code_d_              => CASE issue_transaction_ WHEN ('COTOCRA-') THEN code_d_     ELSE NULL END,
                                    code_e_              => CASE issue_transaction_ WHEN ('COTOCRA-') THEN code_e_     ELSE NULL END,
                                    code_f_              => CASE issue_transaction_ WHEN ('COTOCRA-') THEN code_f_     ELSE NULL END,
                                    code_g_              => CASE issue_transaction_ WHEN ('COTOCRA-') THEN code_g_     ELSE NULL END,
                                    code_h_              => CASE issue_transaction_ WHEN ('COTOCRA-') THEN code_h_     ELSE NULL END,
                                    code_i_              => CASE issue_transaction_ WHEN ('COTOCRA-') THEN code_i_     ELSE NULL END,
                                    code_j_              => CASE issue_transaction_ WHEN ('COTOCRA-') THEN code_j_     ELSE NULL END,
                                    source_              => NULL);

         Receive_Part_With_Posting (contract_                  => rental_asset_transfer_tab_(i).contract,
                                    part_no_                   => rental_asset_transfer_tab_(i).part_no,
                                    configuration_id_          => rental_asset_transfer_tab_(i).configuration_id,
                                    location_no_               => rental_asset_transfer_tab_(i).location_no,
                                    lot_batch_no_              => rental_asset_transfer_tab_(i).lot_batch_no,
                                    serial_no_                 => serial_catch_tab_(index_).serial_no,
                                    eng_chg_level_             => rental_asset_transfer_tab_(i).eng_chg_level,
                                    waiv_dev_rej_no_           => rental_asset_transfer_tab_(i).waiv_dev_rej_no,
                                    activity_seq_              => rental_asset_transfer_tab_(i).activity_seq,
                                    handling_unit_id_          => rental_asset_transfer_tab_(i).handling_unit_id,
                                    transaction_               => receipt_transaction_,
                                    expiration_date_           => oldrec_.expiration_date, 
                                    quantity_                  => local_quantity_,
                                    quantity_reserved_         => 0,
                                    catch_quantity_            => serial_catch_tab_(index_).catch_qty,
                                    account_no_                => CASE receipt_transaction_ WHEN ('CRATOCO+') THEN account_no_ ELSE NULL END,
                                    code_b_                    => CASE receipt_transaction_ WHEN ('CRATOCO+') THEN code_b_     ELSE NULL END,
                                    code_c_                    => CASE receipt_transaction_ WHEN ('CRATOCO+') THEN code_c_     ELSE NULL END,
                                    code_d_                    => CASE receipt_transaction_ WHEN ('CRATOCO+') THEN code_d_     ELSE NULL END,
                                    code_e_                    => CASE receipt_transaction_ WHEN ('CRATOCO+') THEN code_e_     ELSE NULL END,
                                    code_f_                    => CASE receipt_transaction_ WHEN ('CRATOCO+') THEN code_f_     ELSE NULL END,
                                    code_g_                    => CASE receipt_transaction_ WHEN ('CRATOCO+') THEN code_g_     ELSE NULL END,
                                    code_h_                    => CASE receipt_transaction_ WHEN ('CRATOCO+') THEN code_h_     ELSE NULL END,
                                    code_i_                    => CASE receipt_transaction_ WHEN ('CRATOCO+') THEN code_i_     ELSE NULL END,
                                    code_j_                    => CASE receipt_transaction_ WHEN ('CRATOCO+') THEN code_j_     ELSE NULL END,
                                    source_                    => NULL,
                                    price_                     => NULL,
                                    cost_detail_id_            => cost_detail_id_,
                                    condition_code_            => NULL,
                                    part_ownership_db_         => CASE receipt_transaction_ 
                                                                    WHEN ('CRATOCO+') THEN Part_Ownership_API.DB_COMPANY_OWNED
                                                                    ELSE Part_Ownership_API.DB_COMPANY_RENTAL_ASSET END);
      END LOOP;
      --restore availability_control_id to the previous value.
      IF (current_avail_control_id_ IS NOT NULL) THEN
         Modify_Availability_Control_Id(rental_asset_transfer_tab_(i).contract,
                                        rental_asset_transfer_tab_(i).part_no,
                                        rental_asset_transfer_tab_(i).configuration_id,
                                        rental_asset_transfer_tab_(i).location_no,
                                        rental_asset_transfer_tab_(i).lot_batch_no,
                                        rental_asset_transfer_tab_(i).serial_no,
                                        rental_asset_transfer_tab_(i).eng_chg_level,
                                        rental_asset_transfer_tab_(i).waiv_dev_rej_no,
                                        rental_asset_transfer_tab_(i).activity_seq,
                                        rental_asset_transfer_tab_(i).handling_unit_id,
                                        availability_control_id_ => current_avail_control_id_);
      END IF;
   END LOOP;
   IF (transfer_action_ = 'TransferToRentalAsset') THEN
      Validate_Ownership_Mix___(Part_Ownership_API.DB_COMPANY_RENTAL_ASSET); 
   ELSE
      Validate_Ownership_Mix___(Part_Ownership_API.DB_COMPANY_OWNED); 
   END IF;
   
   Inventory_Event_Manager_API.Finish_Session;
END Transfer_Rental_Asset;


FUNCTION Handling_Unit_Exist (
   handling_unit_id_ IN NUMBER ) RETURN BOOLEAN 
IS
   handling_unit_exist_ BOOLEAN := FALSE;
   dummy_number_        NUMBER;

   CURSOR exist_control IS
      SELECT 1
        FROM inventory_part_in_stock_tab
       WHERE handling_unit_id = handling_unit_id_
         AND (qty_onhand != 0 OR qty_in_transit != 0);
BEGIN
   OPEN  exist_control;
   FETCH exist_control INTO dummy_number_;
   IF (exist_control%FOUND) THEN
      handling_unit_exist_ := TRUE;
   END IF;
   CLOSE exist_control;

   RETURN (handling_unit_exist_);
END Handling_Unit_Exist;


-- Check_Handling_Unit_Exist
--   Checks if there is a quantity on hand for this HandlingUnit in the inventory.
--   Return 1 if there is a quantity otherwise 0
@UncheckedAccess
FUNCTION Check_Handling_Unit_Exist (
   handling_unit_id_ IN NUMBER ) RETURN NUMBER
IS
   CURSOR check_exist_control IS
      SELECT 1
        FROM inventory_part_in_stock_tab
       WHERE handling_unit_id = handling_unit_id_
         AND (qty_onhand != 0 OR qty_in_transit != 0);

   exist_   NUMBER := 1;
BEGIN
   OPEN check_exist_control;
   FETCH check_exist_control INTO exist_;
   IF check_exist_control%NOTFOUND THEN
      exist_ := 0;
   END IF;
   CLOSE check_exist_control;
   RETURN(exist_);
END Check_Handling_Unit_Exist;


PROCEDURE Change_Handling_Unit_Id (
   message_                  IN CLOB,
   new_handling_unit_id_     IN NUMBER )
IS
   TYPE Change_HU_Rec IS RECORD (
      contract                      inventory_part_in_stock_tab.contract%TYPE,
      part_no                       inventory_part_in_stock_tab.part_no%TYPE,
      configuration_id              inventory_part_in_stock_tab.configuration_id%TYPE,
      location_no                   inventory_part_in_stock_tab.location_no%TYPE,
      lot_batch_no                  inventory_part_in_stock_tab.lot_batch_no%TYPE,
      serial_no                     inventory_part_in_stock_tab.serial_no%TYPE,
      eng_chg_level                 inventory_part_in_stock_tab.eng_chg_level%TYPE,
      waiv_dev_rej_no               inventory_part_in_stock_tab.waiv_dev_rej_no%TYPE,
      activity_seq                  inventory_part_in_stock_tab.activity_seq%TYPE,
      handling_unit_id              inventory_part_in_stock_tab.handling_unit_id%TYPE,
      quantity                      inventory_part_in_stock_tab.qty_onhand%TYPE,
      catch_quantity                inventory_part_in_stock_tab.catch_qty_onhand%TYPE,
      source_ref1                   VARCHAR2(50),
      source_ref2                   VARCHAR2(50),
      source_ref3                   VARCHAR2(50),
      source_ref4                   VARCHAR2(50),
      inv_trans_source_ref_type_db  VARCHAR2(20),
      part_tracking_session_id      NUMBER);
      
   TYPE Change_HU_Tab IS TABLE OF Change_HU_Rec INDEX BY PLS_INTEGER;
   
   count_                      NUMBER;
   name_arr_                   Message_SYS.name_table_clob;
   value_arr_                  Message_SYS.line_table_clob;
   
   inv_part_in_stock_tab_      Change_HU_Tab;
   row_                        NUMBER := 0;
   serial_catch_tab_           Serial_Catch_Table;
   local_catch_quantity_       NUMBER;
   local_quantity_             NUMBER;
   reservation_                BOOLEAN := FALSE;
BEGIN
   Message_SYS.Get_Clob_Attributes(message_, count_, name_arr_, value_arr_);
   
   FOR n_ IN 1..count_ LOOP
      IF (name_arr_(n_) = 'CONTRACT') THEN
         row_ := row_ + 1;
         inv_part_in_stock_tab_(row_).contract := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'PART_NO') THEN
         inv_part_in_stock_tab_(row_).part_no := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'CONFIGURATION_ID') THEN
         inv_part_in_stock_tab_(row_).configuration_id := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'LOCATION_NO') THEN
         inv_part_in_stock_tab_(row_).location_no := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'LOT_BATCH_NO') THEN
         inv_part_in_stock_tab_(row_).lot_batch_no := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'SERIAL_NO') THEN
         inv_part_in_stock_tab_(row_).serial_no := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'ENG_CHG_LEVEL') THEN
         inv_part_in_stock_tab_(row_).eng_chg_level := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'WAIV_DEV_REJ_NO') THEN
         inv_part_in_stock_tab_(row_).waiv_dev_rej_no := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'ACTIVITY_SEQ') THEN
         inv_part_in_stock_tab_(row_).activity_seq := Client_SYS.Attr_Value_To_Number(value_arr_(n_));
      ELSIF (name_arr_(n_) = 'HANDLING_UNIT_ID') THEN
         inv_part_in_stock_tab_(row_).handling_unit_id := Client_SYS.Attr_Value_To_Number(value_arr_(n_));
      ELSIF (name_arr_(n_) = 'QUANTITY') THEN
         inv_part_in_stock_tab_(row_).quantity := Client_SYS.Attr_Value_To_Number(value_arr_(n_));
      ELSIF (name_arr_(n_) = 'CATCH_QUANTITY') THEN
         inv_part_in_stock_tab_(row_).catch_quantity := Client_SYS.Attr_Value_To_Number(value_arr_(n_)); 
         
      ELSIF (name_arr_(n_) = 'SOURCE_REF1') THEN
         inv_part_in_stock_tab_(row_).source_ref1 := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'SOURCE_REF2') THEN
         inv_part_in_stock_tab_(row_).source_ref2 := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'SOURCE_REF3') THEN
         inv_part_in_stock_tab_(row_).source_ref3 := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'SOURCE_REF4') THEN
         inv_part_in_stock_tab_(row_).source_ref4 := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'INV_TRANS_SOURCE_REF_TYPE_DB') THEN
         inv_part_in_stock_tab_(row_).inv_trans_source_ref_type_db := value_arr_(n_);
      ELSIF (name_arr_(n_) = 'PART_TRACKING_SESSION_ID') THEN
         inv_part_in_stock_tab_(row_).part_tracking_session_id := Client_SYS.Attr_Value_To_Number(value_arr_(n_));
      END IF;
   END LOOP;
   
   IF (inv_part_in_stock_tab_.COUNT > 0) THEN
      Inventory_Event_Manager_API.Start_Session;
      FOR i IN inv_part_in_stock_tab_.FIRST .. inv_part_in_stock_tab_.LAST LOOP
         IF (inv_part_in_stock_tab_(i).part_tracking_session_id IS NULL) THEN
            serial_catch_tab_(1).serial_no := inv_part_in_stock_tab_(i).serial_no;
            local_catch_quantity_          := inv_part_in_stock_tab_(i).catch_quantity;
            local_quantity_                := inv_part_in_stock_tab_(i).quantity;
         ELSE
            Temporary_Part_Tracking_API.Get_Serials_And_Remove_Session(serial_catch_tab_,inv_part_in_stock_tab_(i).part_tracking_session_id);

            IF (serial_catch_tab_.COUNT = 0) THEN
               Raise_No_Serials_Error___;
            END IF;

            IF (serial_catch_tab_.COUNT != inv_part_in_stock_tab_(i).quantity) THEN
               Error_SYS.Record_General(lu_name_, 'ATTACHSERCOUNT: The quantity to be attached is :P1 but the number of identified serials is :P2', inv_part_in_stock_tab_(i).quantity, serial_catch_tab_.COUNT);
            END IF;

            Split_Into_Serials(inv_part_in_stock_tab_(i).contract,
                               inv_part_in_stock_tab_(i).part_no,
                               inv_part_in_stock_tab_(i).configuration_id,
                               inv_part_in_stock_tab_(i).location_no,
                               inv_part_in_stock_tab_(i).lot_batch_no,
                               inv_part_in_stock_tab_(i).eng_chg_level,
                               inv_part_in_stock_tab_(i).waiv_dev_rej_no,
                               inv_part_in_stock_tab_(i).activity_seq,
                               inv_part_in_stock_tab_(i).handling_unit_id,
                               serial_catch_tab_,
                               reservation_);

            local_quantity_       := 1;
            local_catch_quantity_ := NULL;
         END IF;
         
         FOR j IN serial_catch_tab_.FIRST..serial_catch_tab_.LAST LOOP
         Change_Handling_Unit_Id(contract_                     => inv_part_in_stock_tab_(i).contract,
                                 part_no_                      => inv_part_in_stock_tab_(i).part_no,
                                 configuration_id_             => inv_part_in_stock_tab_(i).configuration_id,
                                 location_no_                  => inv_part_in_stock_tab_(i).location_no,
                                 lot_batch_no_                 => inv_part_in_stock_tab_(i).lot_batch_no,
                                 serial_no_                    => serial_catch_tab_(j).serial_no,
                                 eng_chg_level_                => inv_part_in_stock_tab_(i).eng_chg_level,
                                 waiv_dev_rej_no_              => inv_part_in_stock_tab_(i).waiv_dev_rej_no,
                                 activity_seq_                 => inv_part_in_stock_tab_(i).activity_seq,
                                 old_handling_unit_id_         => inv_part_in_stock_tab_(i).handling_unit_id,
                                 new_handling_unit_id_         => new_handling_unit_id_,
                                 quantity_                     => local_quantity_,
                                 catch_quantity_               => local_catch_quantity_,
                                 source_ref1_                  => inv_part_in_stock_tab_(i).source_ref1,
                                 source_ref2_                  => inv_part_in_stock_tab_(i).source_ref2,
                                 source_ref3_                  => inv_part_in_stock_tab_(i).source_ref3,
                                 source_ref4_                  => inv_part_in_stock_tab_(i).source_ref4,
                                 inv_trans_source_ref_type_db_ => inv_part_in_stock_tab_(i).inv_trans_source_ref_type_db,
                                 discon_zero_stock_handl_unit_ => FALSE );
      END LOOP;
         serial_catch_tab_.DELETE;
      END LOOP;
      Inventory_Event_Manager_API.Finish_Session;
   END IF;
END Change_Handling_Unit_Id;


PROCEDURE Change_Handling_Unit_Id (
   contract_                     IN VARCHAR2,
   part_no_                      IN VARCHAR2,
   configuration_id_             IN VARCHAR2,
   location_no_                  IN VARCHAR2,
   lot_batch_no_                 IN VARCHAR2,
   serial_no_                    IN VARCHAR2,
   eng_chg_level_                IN VARCHAR2,
   waiv_dev_rej_no_              IN VARCHAR2,
   activity_seq_                 IN NUMBER,
   old_handling_unit_id_         IN NUMBER,
   new_handling_unit_id_         IN NUMBER,
   quantity_                     IN NUMBER,
   catch_quantity_               IN NUMBER,
   source_ref1_                  IN VARCHAR2 DEFAULT NULL,
   source_ref2_                  IN VARCHAR2 DEFAULT NULL,
   source_ref3_                  IN VARCHAR2 DEFAULT NULL,
   source_ref4_                  IN VARCHAR2 DEFAULT NULL,
   inv_trans_source_ref_type_db_ IN VARCHAR2 DEFAULT NULL,
   validate_hu_struct_position_  IN BOOLEAN  DEFAULT TRUE,
   discon_zero_stock_handl_unit_ IN BOOLEAN  DEFAULT TRUE,
   always_preserve_serial_no_    IN BOOLEAN  DEFAULT FALSE )
IS
   local_catch_quantity_ NUMBER := NULL;
   fromrec_              INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   torec_                INVENTORY_PART_IN_STOCK_TAB%ROWTYPE;
   expiration_date_      INVENTORY_PART_IN_STOCK_TAB.expiration_date%TYPE;
   last_calendar_date_   DATE := Database_Sys.last_calendar_date_;
   torec_exists_         BOOLEAN;
   part_catalog_rec_     Part_Catalog_API.Public_Rec;
   serial_no_for_stock_  inventory_part_in_stock_tab.serial_no%TYPE;
BEGIN
   IF (inv_trans_source_ref_type_db_ IS NOT NULL) THEN
      Order_Type_API.Exist_Db(inv_trans_source_ref_type_db_);
   END IF;
   
   local_catch_quantity_ := catch_quantity_;

   fromrec_ := Lock_By_Keys___(contract_,
                               part_no_,
                               configuration_id_,
                               location_no_,
                               lot_batch_no_,
                               serial_no_,
                               eng_chg_level_,
                               waiv_dev_rej_no_,
                               activity_seq_,
                               old_handling_unit_id_);
                           
   IF (quantity_ > (fromrec_.qty_onhand - fromrec_.qty_reserved)) THEN
      IF (new_handling_unit_id_ = 0) THEN
         Error_SYS.Record_General(lu_name_, 'HU0QTYERR: Maximum available stock record quantity to be unattached is :P1.', (fromrec_.qty_onhand - fromrec_.qty_reserved));
      ELSE
         Error_SYS.Record_General(lu_name_, 'HUQTYERR: Maximum available stock record quantity to be attached is :P1.', (fromrec_.qty_onhand - fromrec_.qty_reserved));
      END IF;
   END IF;

   part_catalog_rec_    := Part_Catalog_API.Get(part_no_);

   IF (always_preserve_serial_no_) THEN
      -- This option is useful when moving reserved stock in combination with serial tracking only at receipt and issue
      -- and when unpacking the serial meaning that handling unit ID goes to zero. We still want to keep the identified serial number.
      serial_no_for_stock_ := serial_no_;
   ELSE
      serial_no_for_stock_ := Get_Serial_No_For_Stock(part_no_,
                                                      serial_no_,
                                                      part_catalog_rec_,
                                                      fromrec_.location_type,
                                                      new_handling_unit_id_);
   END IF;

   torec_exists_ := Check_Exist___(contract_,
                                   part_no_,
                                   configuration_id_,
                                   location_no_,
                                   lot_batch_no_,
                                   serial_no_for_stock_,
                                   eng_chg_level_,
                                   waiv_dev_rej_no_,
                                   activity_seq_,
                                   new_handling_unit_id_);
   IF (torec_exists_) THEN
      torec_ := Get_Object_By_Keys___(contract_,
                                      part_no_,
                                      configuration_id_,
                                      location_no_,
                                      lot_batch_no_,
                                      serial_no_for_stock_,
                                      eng_chg_level_,
                                      waiv_dev_rej_no_,
                                      activity_seq_,
                                      new_handling_unit_id_);
   END IF;

   IF (Nvl(torec_.expiration_date  , last_calendar_date_) <=
       Nvl(fromrec_.expiration_date, last_calendar_date_)) THEN
      expiration_date_ := torec_.expiration_date;
   ELSIF (fromrec_.expiration_date IS NOT NULL AND torec_.qty_reserved > 0) THEN
      IF (torec_.handling_unit_id = 0) THEN
         Error_SYS.Record_General(lu_name_, 'HU0CHANGEEXP: Unable to unattach part(s) with an earlier expiration date than the reserved qty that exists on the same location.');
      ELSE
         Error_SYS.Record_General(lu_name_, 'HUCHANGEEXP: Unable to attach part(s) with an earlier expiration date than the reserved qty that exists in Handling Unit :P1.', torec_.handling_unit_id);
      END IF;
   ELSE
      expiration_date_ := fromrec_.expiration_date;
   END IF;

   Move_Part_Impl___(catch_quantity_                => local_catch_quantity_,
                     contract_                      => fromrec_.contract,
                     part_no_                       => fromrec_.part_no,
                     configuration_id_              => fromrec_.configuration_id,
                     location_no_                   => fromrec_.location_no,
                     lot_batch_no_                  => fromrec_.lot_batch_no,
                     serial_no_                     => fromrec_.serial_no,
                     eng_chg_level_                 => fromrec_.eng_chg_level,
                     waiv_dev_rej_no_               => fromrec_.waiv_dev_rej_no,
                     activity_seq_                  => fromrec_.activity_seq,
                     handling_unit_id_              => fromrec_.handling_unit_id,
                     expiration_date_               => expiration_date_,
                     to_contract_                   => fromrec_.contract,
                     to_part_no_                    => fromrec_.part_no,
                     to_location_no_                => fromrec_.location_no,
                     to_destination_db_             => 'N',
                     to_waiv_dev_rej_no_            => fromrec_.waiv_dev_rej_no,
                     to_lot_batch_no_               => fromrec_.lot_batch_no,
                     to_serial_no_                  => fromrec_.serial_no,
                     to_activity_seq_               => fromrec_.activity_seq,
                     to_handling_unit_id_           => new_handling_unit_id_,
                     quantity_                      => quantity_,
                     quantity_reserved_             => 0,
                     move_comment_                  => NULL,
                     order_no_                      => source_ref1_,
                     line_no_                       => source_ref2_,
                     release_no_                    => source_ref3_,
                     line_item_no_                  => source_ref4_,
                     source_ref5_                   => NULL,
                     order_type_                    => Order_Type_API.Decode(inv_trans_source_ref_type_db_),
                     consume_consignment_stock_     => FALSE,
                     make_transaction_and_postings_ => TRUE,
                     report_earned_value_db_        => NULL,
                     from_part_catalog_rec_         => NULL,
                     to_part_catalog_rec_           => NULL,                 
                     transport_task_id_             => NULL,
                     validate_hu_struct_position_   => validate_hu_struct_position_,
                     availability_ctrl_id_          => NULL,
                     always_preserve_serial_no_     => always_preserve_serial_no_,
                     ownership_transfer_reason_id_  => NULL);

   IF ((NOT torec_exists_) OR ((torec_.qty_onhand = 0) AND (torec_.qty_in_transit = 0))) THEN
      Modify_Availability_Control_Id(contract_,
                                     part_no_,
                                     configuration_id_,
                                     location_no_,
                                     lot_batch_no_,
                                     serial_no_for_stock_,
                                     eng_chg_level_,
                                     waiv_dev_rej_no_,
                                     activity_seq_,
                                     new_handling_unit_id_,
                                     fromrec_.availability_control_id);
   END IF;
   Change_Source_Handl_Unit_Id___(contract_,
                                  part_no_,
                                  configuration_id_,
                                  location_no_,
                                  lot_batch_no_,
                                  serial_no_,
                                  eng_chg_level_,
                                  waiv_dev_rej_no_,
                                  activity_seq_,
                                  old_handling_unit_id_,
                                  new_handling_unit_id_,
                                  quantity_,
                                  catch_quantity_,
                                  source_ref1_,
                                  source_ref2_,
                                  source_ref3_,
                                  source_ref4_,
                                  inv_trans_source_ref_type_db_);
      
   Cleanup_Handl_Unit_Struct___(handling_unit_id_              => fromrec_.handling_unit_id, 
                                discon_zero_stock_handl_unit_  => discon_zero_stock_handl_unit_);

END Change_Handling_Unit_Id;


----------------------------------------------------------------------------------------------------------------------------------------------------
-- PROCEDURE Add_To_Transport_Task
--
-- This method will support moving inventory part in stock quantities having both available and reserved quantities in the same stock record.
-- When creating the Transport Task line, priority will be given to the available quantity. If the available quantity is not sufficient, 
-- the most suitable reservations will be fetched from the Inventory Part Stock Reservations to fill that shortage quantity. 
-- When fetching reservations we have to consider the entire quantity reserved for it and it will end up in not moving the entire available quantity 
-- to the Transport Task
----------------------------------------------------------------------------------------------------------------------------------------------------
PROCEDURE Move_Part_With_Transport_Task (
   moved_quantity_     OUT NUMBER,
   contract_           IN  VARCHAR2,
   part_no_            IN  VARCHAR2,
   configuration_id_   IN  VARCHAR2,
   from_location_no_   IN  VARCHAR2,
   lot_batch_no_       IN  VARCHAR2,
   serial_no_          IN  VARCHAR2,
   eng_chg_level_      IN  VARCHAR2,
   waiv_dev_rej_no_    IN  VARCHAR2,
   activity_seq_       IN  NUMBER,
   handling_unit_id_   IN  NUMBER,
   source_ref1_        IN  VARCHAR2,
   source_ref2_        IN  VARCHAR2,
   source_ref3_        IN  VARCHAR2,
   receipt_no_         IN  VARCHAR2,
   source_ref_type_    IN  VARCHAR2,
   quantity_to_move_   IN  NUMBER,
   to_contract_        IN  VARCHAR2,
   to_location_no_     IN  VARCHAR2,
   to_destination_     IN  VARCHAR2 DEFAULT Inventory_Part_Destination_API.Decode(Inventory_Part_Destination_API.DB_MOVE_TO_INVENTORY) )
IS
   inv_part_in_stock_pub_rec_   inventory_part_in_stock_tab%ROWTYPE;
   serial_no_tab_               Part_Serial_Catalog_API.Serial_No_Tab;
   serials_added_               Part_Serial_Catalog_API.Serial_No_Tab;
   reserved_stock_tab_          Inv_Part_Stock_Reservation_API.Inv_Part_In_Stock_Res_Table;
   dummy_number_                NUMBER;
   quantity_added_              NUMBER := 0;
   local_quantity_to_move_      NUMBER := 0;
   moved_reserved_qty_          NUMBER := 0;
   reserved_qty_to_move_        NUMBER := 0;   
   available_qty_to_move_       NUMBER;
   excess_moved_qty_            NUMBER;
   move_reservation_option_db_  VARCHAR2(20);
   order_type_                  VARCHAR2(2000);
BEGIN   
   inv_part_in_stock_pub_rec_ := Lock_By_Keys___( contract_,
                                                part_no_,
                                                configuration_id_,
                                                from_location_no_,
                                                lot_batch_no_,
                                                serial_no_,
                                                eng_chg_level_,
                                                waiv_dev_rej_no_,
                                                activity_seq_,
                                                handling_unit_id_);
   
   available_qty_to_move_ := inv_part_in_stock_pub_rec_.qty_onhand - inv_part_in_stock_pub_rec_.qty_reserved;
   reserved_qty_to_move_  := quantity_to_move_ - available_qty_to_move_;
   moved_quantity_        := 0;  
   -- If the available quantity is less than the quantity to move
   IF (reserved_qty_to_move_ > 0) THEN
      -- This will go further down if there is a quantity reserved for this stock record. If reservations fullfill the conditions, 
      -- Transport Task will be created for those reservations.
      IF (inv_part_in_stock_pub_rec_.qty_reserved > 0) THEN
         
         IF (to_destination_ = Inventory_Part_Destination_API.Decode(Inventory_Part_Destination_API.DB_MOVE_TO_TRANSIT)) THEN
            Error_SYS.Record_General(lu_name_, 'CANNOTMOVEINTOTRANSIT: Reserved stocks cannot be moved  to the destination :P1.', to_destination_);   
         END IF;
         
         move_reservation_option_db_ := Site_Invent_Info_API.Get_Move_Reservation_Option_Db(contract_);
         IF (move_reservation_option_db_ != Reservat_Adjustment_Option_API.DB_NOT_ALLOWED) THEN
            reserved_stock_tab_ := Inv_Part_Stock_Reservation_API.Find_Reservations(contract_,
                                                                                    part_no_,
                                                                                    configuration_id_,
                                                                                    from_location_no_,
                                                                                    lot_batch_no_,
                                                                                    serial_no_,
                                                                                    eng_chg_level_,
                                                                                    waiv_dev_rej_no_,
                                                                                    activity_seq_,
                                                                                    handling_unit_id_,
                                                                                    reserved_qty_to_move_,
                                                                                    move_reservation_option_db_);
            IF (reserved_stock_tab_.COUNT > 0) THEN
               FOR i IN reserved_stock_tab_.FIRST..reserved_stock_tab_.LAST LOOP
                  @ApproveTransactionStatement(2017-03-24,maeelk)
                  SAVEPOINT before_add_to_transport_task;
                  Inv_Part_Stock_Reservation_API.Move_Res_With_Transport_Task(part_no_                     => reserved_stock_tab_(i).part_no,
                                                                              configuration_id_            => reserved_stock_tab_(i).configuration_id,
                                                                              contract_                    => reserved_stock_tab_(i).contract,
                                                                              from_location_no_            => reserved_stock_tab_(i).location_no,
                                                                              to_location_no_              => to_location_no_,
                                                                              order_supply_demand_type_db_ => reserved_stock_tab_(i).order_supply_demand_type_db,
                                                                              order_no_                    => reserved_stock_tab_(i).order_no,
                                                                              line_no_                     => reserved_stock_tab_(i).line_no,
                                                                              release_no_                  => reserved_stock_tab_(i).release_no,
                                                                              line_item_no_                => reserved_stock_tab_(i).line_item_no,
                                                                              pick_list_no_                => reserved_stock_tab_(i).pick_list_no,
                                                                              shipment_id_                 => reserved_stock_tab_(i).shipment_id,
                                                                              lot_batch_no_                => reserved_stock_tab_(i).lot_batch_no,
                                                                              serial_no_                   => reserved_stock_tab_(i).serial_no,
                                                                              eng_chg_level_               => reserved_stock_tab_(i).eng_chg_level,
                                                                              waiv_dev_rej_no_             => reserved_stock_tab_(i).waiv_dev_rej_no,
                                                                              activity_seq_                => reserved_stock_tab_(i).activity_seq,
                                                                              handling_unit_id_            => reserved_stock_tab_(i).handling_unit_id,
                                                                              quantity_to_move_            => reserved_stock_tab_(i).qty_reserved,
                                                                              check_storage_requirements_  => TRUE);

                  moved_reserved_qty_ := moved_reserved_qty_ + reserved_stock_tab_(i).qty_reserved;

                  IF ((moved_reserved_qty_ + available_qty_to_move_) >=  quantity_to_move_) THEN
                     -- Find the Quantity that has been moved in excess
                     excess_moved_qty_ := moved_reserved_qty_ - reserved_qty_to_move_;
                     -- A Transport Task Line has been to a quantity more than asked
                     IF (excess_moved_qty_ > available_qty_to_move_) THEN 
                       -- Need to reduce the last moved reserved quantity from the total reserved quantity and remove the reservation added to the Transport Task.
                       moved_reserved_qty_ := moved_reserved_qty_ - reserved_stock_tab_(i).qty_reserved;
                       @ApproveTransactionStatement(2017-03-24,maeelk)
                       ROLLBACK TO before_add_to_transport_task;
                     ELSE
                       EXIT;
                     END IF;
                  END IF;
               END LOOP;                           
            END IF;   
         END IF;
      END IF;
   END IF;

   -- This section will cover adding Transport Task Lines for availabe quantity that can be moved. 
   IF (quantity_to_move_ > moved_reserved_qty_) AND (available_qty_to_move_ > 0) THEN 
      IF (serial_no_ != '*') THEN
         serial_no_tab_(1).serial_no := serial_no_;
         local_quantity_to_move_ := NULL;
      ELSE
         local_quantity_to_move_ := quantity_to_move_ - moved_reserved_qty_;
      END IF;
      
      $IF Component_Discom_SYS.INSTALLED $THEN
         order_type_ := Order_Type_API.Decode(Logistics_Source_Ref_Type_API.Get_Order_Type_Db(Logistics_Source_Ref_Type_API.Encode(source_ref_type_)));
      $ELSE
         Error_SYS.Component_Not_Exist('DISCOM');
      $END
      
      Transport_Task_API.New_Or_Add_To_Existing(transport_task_id_          => dummy_number_,
                                                quantity_added_             => quantity_added_,
                                                serials_added_              => serials_added_,
                                                part_no_                    => part_no_,
                                                configuration_id_           => configuration_id_,
                                                from_contract_              => contract_,
                                                from_location_no_           => from_location_no_,
                                                to_contract_                => to_contract_,
                                                to_location_no_             => to_location_no_,
                                                destination_                => to_destination_,
                                                order_type_                 => order_type_, 
                                                order_ref1_                 => source_ref1_, 
                                                order_ref2_                 => source_ref2_, 
                                                order_ref3_                 => source_ref3_, 
                                                order_ref4_                 => receipt_no_, 
                                                pick_list_no_               => NULL,
                                                shipment_id_                => NULL,
                                                lot_batch_no_               => lot_batch_no_,
                                                serial_no_tab_              => serial_no_tab_,
                                                eng_chg_level_              => eng_chg_level_,
                                                waiv_dev_rej_no_            => waiv_dev_rej_no_,
                                                activity_seq_               => activity_seq_,
                                                handling_unit_id_           => handling_unit_id_,
                                                quantity_to_add_            => local_quantity_to_move_,
                                                allow_deviating_avail_ctrl_ => Fnd_Boolean_API.DB_TRUE,
                                                check_storage_requirements_ => TRUE);
   END IF; 
   
   IF (serial_no_ != '*') THEN
     IF ((moved_reserved_qty_ > 0) OR (serials_added_.COUNT > 0)) THEN
        moved_quantity_ := 1;
     END IF;       
   ELSE
     moved_quantity_ := moved_reserved_qty_ + quantity_added_;
   END IF;    
   
   IF (moved_quantity_ = 0)THEN
      IF (excess_moved_qty_ > 0) THEN
         Error_SYS.Record_General(lu_name_, 'NOFRACMOVALL: It''s not possible to move reservations partially using transport task. No transport task created to move part :P1 with quantity :P2.', part_no_, quantity_to_move_);         
      END IF;      
      Error_SYS.Record_General(lu_name_, 'NOTTCREATED: No Transport Task was created to move the part :P1 with quantity :P2', part_no_, quantity_to_move_);
   END IF;
END Move_Part_With_Transport_Task;

PROCEDURE Move_Part_With_Transp_Task__ (
   info_               OUT VARCHAR2,
   moved_quantity_     OUT NUMBER,
   contract_           IN  VARCHAR2,
   part_no_            IN  VARCHAR2,
   configuration_id_   IN  VARCHAR2,
   from_location_no_   IN  VARCHAR2,
   lot_batch_no_       IN  VARCHAR2,
   serial_no_          IN  VARCHAR2,
   eng_chg_level_      IN  VARCHAR2,
   waiv_dev_rej_no_    IN  VARCHAR2,
   activity_seq_       IN  NUMBER,
   handling_unit_id_   IN  NUMBER,
   source_ref1_        IN  VARCHAR2,
   source_ref2_        IN  VARCHAR2,
   source_ref3_        IN  VARCHAR2,
   receipt_no_         IN  VARCHAR2,
   source_ref_type_    IN  VARCHAR2,
   quantity_to_move_   IN  NUMBER,
   to_contract_        IN  VARCHAR2,
   to_location_no_     IN  VARCHAR2,
   to_destination_     IN  VARCHAR2 DEFAULT Inventory_Part_Destination_API.Decode(Inventory_Part_Destination_API.DB_MOVE_TO_INVENTORY) )
IS
BEGIN

   Move_Part_With_Transport_Task(moved_quantity_    => moved_quantity_,
                                 contract_          => contract_,
                                 part_no_           => part_no_,
                                 configuration_id_  => configuration_id_,
                                 from_location_no_  => from_location_no_,
                                 lot_batch_no_      => lot_batch_no_,
                                 serial_no_         => serial_no_,
                                 eng_chg_level_     => eng_chg_level_,
                                 waiv_dev_rej_no_   => waiv_dev_rej_no_,
                                 activity_seq_      =>activity_seq_,
                                 handling_unit_id_  => handling_unit_id_,
                                 source_ref1_       => source_ref1_,
                                 source_ref2_       => source_ref2_,
                                 source_ref3_       => source_ref3_,
                                 receipt_no_        => receipt_no_,
                                 source_ref_type_   => source_ref_type_,
                                 quantity_to_move_  => quantity_to_move_,
                                 to_contract_       => to_contract_,
                                 to_location_no_    => to_location_no_,
                                 to_destination_    => to_destination_);
   info_ := Client_Sys.Get_All_Info();

END Move_Part_With_Transp_Task__;

@UncheckedAccess
FUNCTION Get_Default_Avail_Ctrl_Id (
   part_no_      IN VARCHAR2,
   serial_no_    IN VARCHAR2,
   lot_batch_no_ IN VARCHAR2,
   contract_     IN VARCHAR2,
   location_no_  IN VARCHAR2 ) RETURN VARCHAR2
IS
   availability_control_id_ INVENTORY_PART_IN_STOCK_TAB.availability_control_id%TYPE;
   warehouse_id_            INVENTORY_PART_IN_STOCK_TAB.warehouse%TYPE; 
   bay_id_                  INVENTORY_PART_IN_STOCK_TAB.bay_no%TYPE; 
   tier_id_                 INVENTORY_PART_IN_STOCK_TAB.tier_no%TYPE; 
   row_id_                  INVENTORY_PART_IN_STOCK_TAB.row_no%TYPE; 
   bin_id_                  INVENTORY_PART_IN_STOCK_TAB.bin_no%TYPE; 
BEGIN
   Warehouse_Bay_Bin_API.Get_Location_Strings(warehouse_id_,
                                              bay_id_,
                                              tier_id_,
                                              row_id_,
                                              bin_id_,
                                              contract_,
                                              location_no_);

   availability_control_id_ := Get_Default_Avail_Ctrl_Id___(part_no_,
                                                            serial_no_,
                                                            lot_batch_no_,
                                                            contract_,
                                                            warehouse_id_,
                                                            bay_id_,
                                                            tier_id_,
                                                            row_id_,
                                                            bin_id_);
   RETURN (availability_control_id_);
END Get_Default_Avail_Ctrl_Id;


FUNCTION Rece_Part_With_Posting_Clob (
   serial_no_attr_            IN    CLOB,
   contract_                  IN    VARCHAR2,
   part_no_                   IN    VARCHAR2,
   configuration_id_          IN    VARCHAR2,
   location_no_               IN    VARCHAR2,
   lot_batch_no_              IN    VARCHAR2,
   eng_chg_level_             IN    VARCHAR2,
   waiv_dev_rej_no_           IN    VARCHAR2,
   handling_unit_id_          IN    VARCHAR2,
   expiration_date_           IN    VARCHAR2,
   catch_quantity_            IN    VARCHAR2,
   account_no_                IN    VARCHAR2,
   code_b_                    IN    VARCHAR2,
   code_c_                    IN    VARCHAR2,
   code_d_                    IN    VARCHAR2,
   code_e_                    IN    VARCHAR2,
   code_f_                    IN    VARCHAR2,
   code_g_                    IN    VARCHAR2,
   code_h_                    IN    VARCHAR2,
   code_i_                    IN    VARCHAR2,
   code_j_                    IN    VARCHAR2,
   source_                    IN    VARCHAR2,
   cost_detail_id_            IN    VARCHAR2,
   condition_code_            IN    VARCHAR2,
   part_ownership_db_         IN    VARCHAR2,
   print_barcode_id_          IN    VARCHAR2,
   delivery_reason_id_        IN    VARCHAR2 DEFAULT NULL) RETURN CLOB
IS
   cost_detail_tab_           Inventory_Part_Unit_Cost_API.Cost_Detail_Tab;
   barcode_id_attr_           CLOB;
   local_expiration_date_     DATE;
   local_handling_unit_id_    NUMBER;
   local_catch_quantity_      NUMBER;
   local_cost_detail_id_      NUMBER;
   local_print_barcode_id_    NUMBER;
   local_barcode_id_          NUMBER;
   new_cost_detail_id_        NUMBER;
   dummy_number1_             NUMBER;
   serial_no_tab_             utility_sys.STRING_TABLE;
BEGIN
   local_expiration_date_  := Client_SYS.Attr_Value_To_Date(expiration_date_);
   local_handling_unit_id_ := Client_SYS.Attr_Value_To_Number(handling_unit_id_);
   local_catch_quantity_   := Client_SYS.Attr_Value_To_Number(catch_quantity_);
   local_cost_detail_id_   := Client_SYS.Attr_Value_To_Number(cost_detail_id_);
   local_print_barcode_id_ := Client_SYS.Attr_Value_To_Number(print_barcode_id_);

   Utility_SYS.Tokenize(serial_no_attr_, Client_Sys.record_separator_, serial_no_tab_, dummy_number1_);
   
   Inventory_Event_Manager_API.Start_Session;
   FOR i_ IN serial_no_tab_.FIRST..serial_no_tab_.LAST LOOP
      cost_detail_tab_ := Temporary_Part_Cost_Detail_API.Get_Details(local_cost_detail_id_);
      Temporary_Part_Cost_Detail_API.Add_Details(new_cost_detail_id_, cost_detail_tab_, part_no_);

      Inventory_Part_In_Stock_API.Receive_Part_With_Posting(contract_   => contract_,
                                                            part_no_        => part_no_,
                                                            configuration_id_   => configuration_id_,
                                                            location_no_        => location_no_,
                                                            lot_batch_no_       => lot_batch_no_,
                                                            serial_no_          => serial_no_tab_(i_),
                                                            eng_chg_level_      => eng_chg_level_,
                                                            waiv_dev_rej_no_    => waiv_dev_rej_no_,
                                                            activity_seq_       => 0,
                                                            handling_unit_id_   => local_handling_unit_id_,
                                                            transaction_        => 'NREC',
                                                            expiration_date_    => local_expiration_date_,
                                                            quantity_           => 1,
                                                            quantity_reserved_  => 0,
                                                            catch_quantity_     => local_catch_quantity_,
                                                            account_no_         => account_no_,
                                                            code_b_             => code_b_,
                                                            code_c_             => code_c_,
                                                            code_d_             => code_d_,
                                                            code_e_             => code_e_,
                                                            code_f_             => code_f_,
                                                            code_g_             => code_g_,
                                                            code_h_             => code_h_,
                                                            code_i_             => code_i_,
                                                            code_j_             => code_j_,
                                                            source_             => source_,
                                                            price_              => NULL,
                                                            cost_detail_id_     => local_cost_detail_id_,
                                                            condition_code_     => condition_code_,
                                                            part_ownership_db_  => part_ownership_db_,
                                                            delivery_reason_id_ => delivery_reason_id_);
      local_cost_detail_id_ := new_cost_detail_id_;
      
      IF (local_print_barcode_id_ = 1) THEN
         Inventory_Part_Barcode_API.New(local_barcode_id_,
                                        contract_,
                                        part_no_,
                                        configuration_id_,
                                        lot_batch_no_,
                                        serial_no_tab_(i_),
                                        eng_chg_level_,
                                        waiv_dev_rej_no_,
                                        1,
                                        0);
         
         IF (barcode_id_attr_ IS NULL) THEN
            barcode_id_attr_ := to_char(local_barcode_id_);
         ELSE
            IF local_barcode_id_ IS NOT NULL THEN
               barcode_id_attr_ := barcode_id_attr_ || Client_SYS.record_separator_|| to_char(local_barcode_id_);
            END IF;
         END IF;
      END IF;
   END LOOP;
   Inventory_Event_Manager_API.Finish_Session;
   Temporary_Part_Cost_Detail_API.Remove_Details(local_cost_detail_id_);
   RETURN barcode_id_attr_;
EXCEPTION WHEN OTHERS THEN
   IF (local_cost_detail_id_ IS NOT NULL) THEN
      Temporary_Part_Cost_Detail_API.Remove_Details(local_cost_detail_id_);
   END IF;
   RAISE;
END Rece_Part_With_Posting_Clob;

@UncheckedAccess
FUNCTION Lock_By_Keys( contract_          VARCHAR2,
                       part_no_           VARCHAR2,
                       configuration_id_  VARCHAR2,
                       location_no_       VARCHAR2,
                       lot_batch_no_      VARCHAR2,
                       serial_no_         VARCHAR2,
                       eng_chg_level_     VARCHAR2,
                       waiv_dev_rej_no_   VARCHAR2,
                       activity_seq_      NUMBER,
                       handling_unit_id_  NUMBER ) RETURN Public_Rec
                       
IS
   rec_     inventory_part_in_stock_tab%ROWTYPE;
BEGIN
   rec_ := Lock_By_Keys___(contract_,
                           part_no_,
                           configuration_id_,
                           location_no_,
                           lot_batch_no_,
                           serial_no_,
                           eng_chg_level_,
                           waiv_dev_rej_no_,
                           activity_seq_,
                           handling_unit_id_);
                           
   RETURN Get (contract_,
               part_no_,
               configuration_id_,
               location_no_,
               lot_batch_no_,
               serial_no_,
               eng_chg_level_,
               waiv_dev_rej_no_,
               activity_seq_,
               handling_unit_id_);                           
                           
END Lock_By_Keys;


@UncheckedAccess
FUNCTION Expiration_Date_Is_Missing (
   contract_ IN VARCHAR2,
   part_no_  IN VARCHAR2 ) RETURN BOOLEAN
IS
   dummy_                      NUMBER;
   expiration_date_is_missing_ BOOLEAN := FALSE;

   CURSOR exist_control IS
      SELECT 1
        FROM inventory_part_in_stock_tab
       WHERE contract = contract_
         AND part_no  = part_no_
         AND location_type NOT IN (Inventory_Location_Type_API.DB_ARRIVAL, Inventory_Location_Type_API.DB_QUALITY_ASSURANCE)
         AND (qty_onhand > 0 OR qty_in_transit > 0)
         AND expiration_date IS NULL;
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      expiration_date_is_missing_ := TRUE;
   END IF;
   CLOSE exist_control;

   RETURN (expiration_date_is_missing_);
END Expiration_Date_Is_Missing;


PROCEDURE Raise_Freeze_Flag_Error (
   part_no_     IN VARCHAR2,
   location_no_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'PART_IS_FROZEN: Inventory part :P1 on location :P2 is blocked for inventory transactions because of counting.', part_no_, location_no_);
END Raise_Freeze_Flag_Error;


PROCEDURE Raise_Putaway_Locat_Type_Error (
   location_type_db_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General(lu_name_,'PUTAWAYLOCTYPE: Putaway is not allowed for locations of type :P1.', Inventory_Location_Type_API.Decode(location_type_db_));
END Raise_Putaway_Locat_Type_Error;


PROCEDURE Raise_Rotable_Pool_Move_Error (
   part_no_              IN VARCHAR2,
   rotable_part_pool_id_ IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General('InventoryPartInStock', 'ROTABLENOTNULL: Part :P1 with Rotable Part Pool ID :P2 cannot be moved.', part_no_, rotable_part_pool_id_);
END Raise_Rotable_Pool_Move_Error;


@UncheckedAccess
FUNCTION Get_Handling_Unit_Row_Count (
   handling_unit_id_  IN  NUMBER)  RETURN NUMBER
IS
   row_count_ NUMBER;
   CURSOR get_row_count IS
      SELECT count(*)
      FROM   inventory_part_in_stock_tab
      WHERE  handling_unit_id = handling_unit_id_;
BEGIN
   OPEN get_row_count;
   FETCH get_row_count INTO row_count_;
   CLOSE get_row_count;
   
   RETURN row_count_;
END Get_Handling_Unit_Row_Count;

PROCEDURE Raise_Move_To_Location_Error (
   order_type_db_        IN VARCHAR2,
   to_location_type_db_  IN VARCHAR2 )
IS
BEGIN
   Error_SYS.Record_General(lu_name_, 'MOVE_TO_LOCATION_NOT_ALLOW: It is not allowed to move material that is reserved on a :P1 to a :P2 location.', 
                                         Order_Type_API.Decode(order_type_db_), Inventory_Location_Type_API.Decode(to_location_type_db_));   
END Raise_Move_To_Location_Error;


@UncheckedAccess
FUNCTION Get_Root_Hu_Types_In_Stock (
   contract_                     IN VARCHAR2,
   warehouse_id_                 IN VARCHAR2,
   bay_id_                       IN VARCHAR2,
   tier_id_                      IN VARCHAR2,
   row_id_                       IN VARCHAR2,
   bin_id_                       IN VARCHAR2,
   ignore_this_handling_unit_id_ IN NUMBER DEFAULT NULL ) RETURN Handling_Unit_Type_API.Unit_Type_Tab
IS
   handling_unit_type_tab_ Handling_Unit_Type_API.Unit_Type_Tab;
   index_                  PLS_INTEGER := 0;   
   -- This cursor returns one record for each root (topmost) handling Unit on the location, and also one NULL record for unpacked parts.
   -- So if a certain handling unit type occurs three times in the result it means that there are three handling units of that type on the location.
   CURSOR get_root_hu_types_in_stock IS
      SELECT DISTINCT (SELECT LPAD(hu.handling_unit_id,20,'0')||hu.handling_unit_type_id
                         FROM   handling_unit_tab hu
                        WHERE  hu.parent_handling_unit_id IS NULL
                        CONNECT BY PRIOR hu.parent_handling_unit_id = hu.handling_unit_id
                        START WITH       hu.handling_unit_id        = ipis.handling_unit_id) handling_unit_type_id
        FROM inventory_part_in_stock_tab ipis
       WHERE ipis.contract = contract_
         AND ipis.warehouse = warehouse_id_
         AND ipis.bay_no    = bay_id_
         AND ipis.tier_no   = tier_id_
         AND ipis.row_no    = row_id_
         AND ipis.bin_no    = bin_id_
         AND (ipis.qty_onhand > 0 OR ipis.qty_in_transit > 0);
         
   TYPE Stock_Hu_Type_Tab IS TABLE OF get_root_hu_types_in_stock%ROWTYPE
      INDEX BY PLS_INTEGER;
   stock_hu_type_tab_ Stock_Hu_Type_Tab;
BEGIN
   OPEN  get_root_hu_types_in_stock;
   FETCH get_root_hu_types_in_stock BULK COLLECT INTO stock_hu_type_tab_;
   CLOSE get_root_hu_types_in_stock;

   IF (stock_hu_type_tab_.COUNT > 0) THEN
      FOR i IN stock_hu_type_tab_.FIRST..stock_hu_type_tab_.LAST LOOP
         IF ((ignore_this_handling_unit_id_ IS NULL) OR 
            (SUBSTR(stock_hu_type_tab_(i).handling_unit_type_id, 1, 20) != ignore_this_handling_unit_id_)) THEN 
           -- Removing the Handling Unit ID from the string using SUBSTR
           index_ := index_ + 1;
           handling_unit_type_tab_(index_).handling_unit_type_id := SUBSTR(stock_hu_type_tab_(i).handling_unit_type_id, 21);
         END IF;
      END LOOP;
   END IF;

   RETURN (handling_unit_type_tab_);
END Get_Root_Hu_Types_In_Stock;


@UncheckedAccess
FUNCTION Get_Destinat_Expiration_Date (
   from_contract_    IN VARCHAR2,
   to_contract_      IN VARCHAR2,
   part_no_          IN VARCHAR2,
   configuration_id_ IN VARCHAR2,
   from_location_no_ IN VARCHAR2,
   to_location_no_   IN VARCHAR2,
   lot_batch_no_     IN VARCHAR2,
   serial_no_        IN VARCHAR2,
   eng_chg_level_    IN VARCHAR2,
   waiv_dev_rej_no_  IN VARCHAR2,
   activity_seq_     IN NUMBER,
   handling_unit_id_ IN NUMBER ) RETURN DATE
IS
   from_expiration_date_   DATE;
   to_expiration_date_     DATE;
   result_expiration_date_ DATE;
BEGIN
   from_expiration_date_ := Get_Expiration_Date(contract_          => from_contract_,
                                                part_no_           => part_no_,
                                                configuration_id_  => configuration_id_,
                                                location_no_       => from_location_no_,
                                                lot_batch_no_      => lot_batch_no_,
                                                serial_no_         => serial_no_,
                                                eng_chg_level_     => eng_chg_level_,
                                                waiv_dev_rej_no_   => waiv_dev_rej_no_,
                                                activity_seq_      => activity_seq_,
                                                handling_unit_id_  => handling_unit_id_);
   to_expiration_date_ := Get_Expiration_Date(contract_          => to_contract_,
                                              part_no_           => part_no_,
                                              configuration_id_  => configuration_id_,
                                              location_no_       => to_location_no_,
                                              lot_batch_no_      => lot_batch_no_,
                                              serial_no_         => serial_no_,
                                              eng_chg_level_     => eng_chg_level_,
                                              waiv_dev_rej_no_   => waiv_dev_rej_no_,
                                              activity_seq_      => activity_seq_,
                                              handling_unit_id_  => handling_unit_id_);

   -- Always use the earliest expiration date for the resulting stock on the destination location.
   IF (NVL(to_expiration_date_  , Database_Sys.last_calendar_date_) < NVL(from_expiration_date_, Database_Sys.last_calendar_date_)) THEN
      result_expiration_date_ := to_expiration_date_;
   ELSE
      result_expiration_date_ := from_expiration_date_;
   END IF;

   RETURN (result_expiration_date_);
END Get_Destinat_Expiration_Date;

-- Get_Serial_Avail_Control_Id
-- Returns the availability control id in which the Serial exists whilst checking for inconsistency.
FUNCTION Get_Serial_Avail_Control_Id (
   part_no_   IN VARCHAR2,
   serial_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   availability_control_id_   INVENTORY_PART_IN_STOCK_TAB.availability_control_id%TYPE;
   dummy_                     VARCHAR2(25);
   
   CURSOR get_avail_control_id IS
      SELECT availability_control_id
      FROM  INVENTORY_PART_IN_STOCK_TAB
      WHERE part_no        = part_no_
        AND serial_no      = serial_no_
        AND (qty_onhand != 0 OR qty_in_transit != 0);
BEGIN
   OPEN get_avail_control_id;
   FETCH get_avail_control_id INTO availability_control_id_;
   IF get_avail_control_id%FOUND THEN
      FETCH get_avail_control_id INTO dummy_;
      IF get_avail_control_id%FOUND THEN
         CLOSE get_avail_control_id;
         Error_SYS.Record_General(lu_name_,'GSCINCONS: Inconsistent database. Serial <:P1> exists on several inventory locations simultaneously.', part_no_||','||serial_no_);
      END IF;
   END IF;
   CLOSE get_avail_control_id;
   RETURN availability_control_id_;
END Get_Serial_Avail_Control_Id;

PROCEDURE Get_Available_Stock_Keys(
   lot_batch_no_     IN OUT VARCHAR2,
   eng_chg_level_    IN OUT VARCHAR2,
   waiv_dev_rej_no_  IN OUT VARCHAR2,
   activity_seq_     IN OUT NUMBER,
   handling_unit_id_ IN OUT NUMBER,
   contract_         IN     VARCHAR2,
   part_no_          IN     VARCHAR2,
   configuration_id_ IN     VARCHAR2,
   location_no_      IN     VARCHAR2,
   serial_no_        IN     VARCHAR2 )
IS
   CURSOR fetch_data IS
      SELECT lot_batch_no, eng_chg_level, waiv_dev_rej_no, activity_seq, handling_unit_id
      FROM   inventory_part_in_stock_lov4
      WHERE  part_no          = part_no_
      AND    serial_no        = serial_no_
      AND    ( contract         = contract_         OR contract_         IS NULL )
      AND    ( configuration_id = configuration_id_ OR configuration_id_ IS NULL )
      AND    ( location_no      = location_no_      OR location_no_      IS NULL )
      AND    ( lot_batch_no     = lot_batch_no_     OR lot_batch_no_     IS NULL )
      AND    ( eng_chg_level    = eng_chg_level_    OR eng_chg_level_    IS NULL )
      AND    ( waiv_dev_rej_no  = waiv_dev_rej_no_  OR waiv_dev_rej_no_  IS NULL )
      AND    ( activity_seq     = activity_seq_     OR activity_seq_     IS NULL )
      AND    ( handling_unit_id = handling_unit_id_ OR handling_unit_id_ IS NULL );
   
   rec_  fetch_data%ROWTYPE;
BEGIN
   OPEN  fetch_data;
   FETCH fetch_data INTO rec_;
   IF(fetch_data%ROWCOUNT = 1 ) THEN
      lot_batch_no_     := rec_.lot_batch_no;
      eng_chg_level_    := rec_.eng_chg_level;
      waiv_dev_rej_no_  := rec_.waiv_dev_rej_no;
      activity_seq_     := rec_.activity_seq;
      handling_unit_id_ := rec_.handling_unit_id;
   END IF;
   CLOSE fetch_data;
END Get_Available_Stock_Keys;

PROCEDURE Get_Id_Version_By_Keys (
   objid_             OUT VARCHAR2,
   objversion_        OUT VARCHAR2,
   contract_          IN VARCHAR2,
   part_no_           IN VARCHAR2,
   configuration_id_  IN VARCHAR2,
   location_no_       IN VARCHAR2,
   lot_batch_no_      IN VARCHAR2,
   serial_no_         IN VARCHAR2,
   eng_chg_level_     IN VARCHAR2,
   waiv_dev_rej_no_   IN VARCHAR2,
   activity_seq_      IN NUMBER,
   handling_unit_id_  IN NUMBER )
IS    
BEGIN
   Get_Id_Version_By_Keys___(objid_,
                             objversion_,
                             contract_,
                             part_no_,
                             configuration_id_,
                             location_no_,
                             lot_batch_no_,
                             serial_no_,
                             eng_chg_level_,
                             waiv_dev_rej_no_,
                             activity_seq_,
                             handling_unit_id_);
END Get_Id_Version_By_Keys; 



@UncheckedAccess
FUNCTION Get_Move_Dest_Avail_Ctrl_Id (
   from_contract_          IN VARCHAR2,
   from_location_no_       IN VARCHAR2,
   to_contract_            IN VARCHAR2,
   to_location_no_         IN VARCHAR2,   
   part_no_                IN VARCHAR2,   
   configuration_id_       IN VARCHAR2,   
   lot_batch_no_           IN VARCHAR2,
   serial_no_              IN VARCHAR2,
   eng_chg_level_          IN VARCHAR2,
   waiv_dev_rej_no_        IN VARCHAR2,
   activity_seq_           IN NUMBER, 
   handling_unit_id_       IN NUMBER ) RETURN inventory_part_in_stock_tab.availability_control_id%TYPE
IS
   fromrec_    inventory_part_in_stock_tab%ROWTYPE;
   torec_      inventory_part_in_stock_tab%ROWTYPE;
   new_record_ BOOLEAN := FALSE;
   
BEGIN
   fromrec_:= Get_Object_By_Keys___(from_contract_,
                                    part_no_,
                                    configuration_id_ ,
                                    from_location_no_,
                                    lot_batch_no_,
                                    serial_no_,
                                    eng_chg_level_,
                                    waiv_dev_rej_no_,
                                    activity_seq_,
                                    handling_unit_id_);   
   
   torec_:= Get_Object_By_Keys___(to_contract_,
                                  part_no_,
                                  configuration_id_ ,
                                  to_location_no_,
                                  lot_batch_no_,
                                  serial_no_,
                                  eng_chg_level_,
                                  waiv_dev_rej_no_,
                                  activity_seq_,
                                  handling_unit_id_);                                                     
                                                              
   IF (torec_.contract IS NULL) THEN
      new_record_ := TRUE;   
   END IF;
   
   RETURN Get_Move_Dest_Avail_Ctrl_Id___(fromrec_, torec_, to_contract_, to_location_no_, new_record_);   
END Get_Move_Dest_Avail_Ctrl_Id;    

-- Fill_Warehouse_Id_Tmp
-- Loads the temporary table Fill_Warehouse_Id_Tmp with warehouse_id
-- gelr:access_ctrl_for_inv_reserv, start  
PROCEDURE Fill_Warehouse_Id_Tmp (
   warehouse_id_tab_ IN  Warehouse_Id_Tab )
IS
BEGIN
   IF warehouse_id_tab_.COUNT > 0 THEN
      FORALL i IN warehouse_id_tab_.FIRST..warehouse_id_tab_.LAST
         INSERT
            INTO warehouse_id_tmp ( warehouse_id )
            VALUES ( warehouse_id_tab_(i) );
   END IF;
END Fill_Warehouse_Id_Tmp;
-- gelr:access_ctrl_for_inv_reserv, end


@UncheckedAccess
FUNCTION Get_Other_Stock_Loc_Onhand(
   contract_          IN VARCHAR2,
   part_no_           IN VARCHAR2,
   configuration_id_  IN VARCHAR2,
   location_no_       IN VARCHAR2,
   lot_batch_no_      IN VARCHAR2,
   serial_no_         IN VARCHAR2,
   eng_chg_level_     IN VARCHAR2,
   waiv_dev_rej_no_   IN VARCHAR2,
   activity_seq_      IN NUMBER,
   handling_unit_id_  IN NUMBER ) RETURN Public_Tab
IS
   inv_part_in_stock_tab_  Public_Tab;
   location_no_tab_        Warehouse_Bay_Bin_API.Location_No_Tab;
   CURSOR get_location_no IS
     SELECT location_no
       FROM inventory_part_in_stock_tab
      WHERE contract         =  contract_
        AND part_no          =  part_no_
        AND configuration_id =  configuration_id_
        AND location_no      != location_no_
        AND lot_batch_no     =  lot_batch_no_
        AND serial_no        =  serial_no_
        AND eng_chg_level    =  eng_chg_level_
        AND waiv_dev_rej_no  =  waiv_dev_rej_no_
        AND activity_seq     =  activity_seq_
        AND handling_unit_id =  handling_unit_id_
        AND qty_onhand != 0 ;
BEGIN
   OPEN get_location_no;
   FETCH get_location_no BULK COLLECT INTO location_no_tab_;
   CLOSE get_location_no;
   IF location_no_tab_.COUNT > 0 THEN 
      FOR i IN location_no_tab_.FIRST..location_no_tab_.LAST LOOP
         inv_part_in_stock_tab_(i) := Inventory_Part_In_Stock_API.Get(contract_,
                                                                      part_no_, 
                                                                      configuration_id_, 
                                                                      location_no_tab_(i),
                                                                      lot_batch_no_,
                                                                      serial_no_,
                                                                      eng_chg_level_,
                                                                      waiv_dev_rej_no_,
                                                                      activity_seq_,
                                                                      handling_unit_id_);   
      END LOOP;   
   END IF;   
   RETURN inv_part_in_stock_tab_;
END Get_Other_Stock_Loc_Onhand;